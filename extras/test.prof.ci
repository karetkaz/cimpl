
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:13: debug: inline file: `lib/std/debug.ci`
lib/std/debug.ci:48: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/std/debug.ci:69: warn: adding implicit cast variant(expected: int32)
lib/std/debug.ci:70: warn: adding implicit cast variant(returned: int32)
lib/std/debug.ci:71: warn: adding implicit cast char[*](message: char[*])
lib/std/debug.ci:68: debug: using default field initializer: NotEquals.argument := null
lib/std/debug.ci:56: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:19: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:239: warn: adding implicit cast float64(data.length: uint32)
lib/std/math.ci:257: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:309: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:315: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:317: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:319: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:323: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:323: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:327: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:332: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:367: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:371: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:373: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:379: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:386: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:382: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:378: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:396: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:399: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:421: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:426: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:432: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:448: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:451: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:463: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:469: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:474: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:479: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:481: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:497: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:521: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:524: warn: adding implicit cast float64(180: int32)
lib/stdlib.ci:20: debug: inline file: `lib/std/math/Complex.ci`
lib/std/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:22: debug: inline file: `lib/std/math/Vector4f.ci`
lib/stdlib.ci:23: debug: inline file: `lib/std/math/Matrix4f.ci`
lib/std/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
lib/std/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:168: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
lib/std/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
lib/std/math/Matrix4f.ci:179: warn: adding implicit cast float32(1: int32)
lib/stdlib.ci:24: debug: inline file: `lib/std/math/Vector2d.ci`
lib/stdlib.ci:29: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:117: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
lib/std/string.ci:123: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
lib/std/string.ci:129: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:137: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:137: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:139: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:162: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:165: warn: adding implicit cast uint64(0: int32)
lib/std/string.ci:165: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:166: warn: adding implicit cast uint64(radix: int32)
lib/std/string.ci:180: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:190: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:197: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:204: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:209: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:210: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:210: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:212: warn: adding implicit cast char(0: int32)
lib/std/string.ci:225: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:225: warn: adding implicit cast int32('-': char)
lib/std/string.ci:225: warn: adding implicit cast int64(0: int32)
lib/std/string.ci:227: warn: adding implicit cast int32('-': char)
lib/std/string.ci:229: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:229: warn: adding implicit cast int32('-': char)
lib/std/string.ci:229: warn: adding implicit cast int32(value: int16)
lib/std/string.ci:231: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:231: warn: adding implicit cast int32('-': char)
lib/std/string.ci:231: warn: adding implicit cast int32(value: int8)
lib/std/string.ci:248: warn: adding implicit cast float64(0: int32)
lib/std/string.ci:248: warn: adding implicit cast int32('-': char)
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.showSign := false
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.precision := 0
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:120: warn: adding implicit cast char(0: int32)
lib/std/string.ci:263: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/std/number.ci`
test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/std/memory.ci`
test/test.ci:27: debug: inline file: `test/std/tryExec.ci`
test/std/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/std/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/std/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/std/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/std/test.math.ci`
test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:239: warn: using signed cast for unsigned value: `data.length`
lib/std/math.ci:314: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:317: warn: using default type initializer: e := 0
lib/std/math.ci:321: warn: using default type initializer: f := 0
lib/std/math.ci:373: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:430: warn: using default type initializer: Math.sinh.result := 0
lib/std/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:84: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:116: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:117: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:118: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:119: warn: uninitialized variable `.result`
lib/std/math/Matrix4f.ci:155: warn: uninitialized variable `.result`
lib/std/string.ci:149: warn: uninitialized variable `append.digits`
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:41: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/string.ci:250: warn: using signed cast for unsigned value: `value`
lib/std/string.ci:254: warn: using signed cast for unsigned value: `fract`
test/std/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
lib/std/debug.ci:45: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@0062b0>, cast: static const inline)
.field file: function (size: 0, offs: <@0064b0>, cast: static const inline)
.field line: function (size: 0, offs: <@0066b0>, cast: static const inline)
.field name: function (size: 0, offs: <@0068b0>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/stdlib.ci:17: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 11
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:17: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0062b0>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0064b0>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0066b0>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0068b0>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/std/tryExec.ci:42: referenced as `void`
	test/std/tryExec.ci:37: referenced as `void`
	test/std/tryExec.ci:23: referenced as `void`
	test/std/tryExec.ci:19: referenced as `void`
	test/std/tryExec.ci:14: referenced as `void`
	test/std/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/std/debug.ci:64: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:45: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:43: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	lib/std/debug.ci:41: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/std/test.math.ci:68: referenced as `bool`
	test/std/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:114: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:468: referenced as `bool`
	lib/std/math.ci:420: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/std/math.ci:364: referenced as `bool`
	lib/std/debug.ci:45: referenced as `bool`
	lib/std/debug.ci:43: referenced as `bool`
	lib/std/debug.ci:41: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
	internal usages: 1
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/std/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:262: referenced as `char`
	lib/std/string.ci:259: referenced as `char`
	lib/std/string.ci:248: referenced as `char`
	lib/std/string.ci:234: referenced as `char`
	lib/std/string.ci:231: referenced as `char`
	lib/std/string.ci:229: referenced as `char`
	lib/std/string.ci:227: referenced as `char`
	lib/std/string.ci:225: referenced as `char`
	lib/std/string.ci:223: referenced as `char`
	lib/std/string.ci:221: referenced as `char`
	lib/std/string.ci:219: referenced as `char`
	lib/std/string.ci:217: referenced as `char`
	lib/std/string.ci:174: referenced as `char`
	lib/std/string.ci:149: referenced as `char`
	lib/std/string.ci:146: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:127: referenced as `char`
	lib/std/string.ci:127: referenced as `char`
	lib/std/string.ci:120: referenced as `char`
	lib/std/string.ci:98: referenced as `char`
	lib/std/string.ci:98: referenced as `char`
	lib/std/string.ci:95: referenced as `char`
	lib/std/string.ci:95: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/std/debug.ci:64: referenced as `char`
	lib/std/debug.ci:59: referenced as `char`
	lib/std/debug.ci:43: referenced as `char`
	lib/std/debug.ci:41: referenced as `char`
	lib/std/debug.ci:36: referenced as `char`
	lib/std/debug.ci:34: referenced as `char`
	lib/std/debug.ci:31: referenced as `char`
	lib/std/debug.ci:29: referenced as `char`
	lib/std/debug.ci:26: referenced as `char`
	lib/std/debug.ci:24: referenced as `char`
	lib/std/debug.ci:21: referenced as `char`
	lib/std/debug.ci:19: referenced as `char`
	lib/std/debug.ci:16: referenced as `char`
	lib/std/debug.ci:14: referenced as `char`
	lib/std/debug.ci:11: referenced as `char`
	lib/std/debug.ci:9: referenced as `char`
	lib/std/debug.ci:6: referenced as `char`
	lib/std/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
	lib/std/string.ci:231: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
	lib/std/string.ci:229: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/std/tryExec.ci:52: referenced as `int32`
	test/std/tryExec.ci:51: referenced as `int32`
	test/std/tryExec.ci:50: referenced as `int32`
	test/std/tryExec.ci:49: referenced as `int32`
	test/std/tryExec.ci:48: referenced as `int32`
	test/std/tryExec.ci:47: referenced as `int32`
	test/std/tryExec.ci:46: referenced as `int32`
	test/std/tryExec.ci:39: referenced as `int32`
	test/std/tryExec.ci:38: referenced as `int32`
	test/std/tryExec.ci:27: referenced as `int32`
	test/std/tryExec.ci:26: referenced as `int32`
	test/std/tryExec.ci:20: referenced as `int32`
	test/std/memory.ci:4: referenced as `int32`
	test/std/memory.ci:3: referenced as `int32`
	test/std/number.ci:66: referenced as `int32`
	test/std/number.ci:65: referenced as `int32`
	test/std/number.ci:63: referenced as `int32`
	test/std/number.ci:62: referenced as `int32`
	test/std/number.ci:60: referenced as `int32`
	test/std/number.ci:59: referenced as `int32`
	test/std/number.ci:58: referenced as `int32`
	test/std/number.ci:57: referenced as `int32`
	test/std/number.ci:55: referenced as `int32`
	test/std/number.ci:35: referenced as `int32`
	test/std/number.ci:34: referenced as `int32`
	test/std/number.ci:33: referenced as `int32`
	test/std/number.ci:31: referenced as `int32`
	test/std/number.ci:30: referenced as `int32`
	test/std/number.ci:29: referenced as `int32`
	test/std/number.ci:27: referenced as `int32`
	test/std/number.ci:26: referenced as `int32`
	test/std/number.ci:25: referenced as `int32`
	test/std/number.ci:23: referenced as `int32`
	test/std/number.ci:22: referenced as `int32`
	test/std/number.ci:21: referenced as `int32`
	test/std/number.ci:19: referenced as `int32`
	test/std/number.ci:18: referenced as `int32`
	test/std/number.ci:16: referenced as `int32`
	test/std/number.ci:15: referenced as `int32`
	test/std/number.ci:14: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:12: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/std/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:262: referenced as `int32`
	lib/std/string.ci:262: referenced as `int32`
	lib/std/string.ci:262: referenced as `int32`
	lib/std/string.ci:259: referenced as `int32`
	lib/std/string.ci:234: referenced as `int32`
	lib/std/string.ci:234: referenced as `int32`
	lib/std/string.ci:231: referenced as `int32`
	lib/std/string.ci:229: referenced as `int32`
	lib/std/string.ci:227: referenced as `int32`
	lib/std/string.ci:227: referenced as `int32`
	lib/std/string.ci:225: referenced as `int32`
	lib/std/string.ci:223: referenced as `int32`
	lib/std/string.ci:221: referenced as `int32`
	lib/std/string.ci:219: referenced as `int32`
	lib/std/string.ci:217: referenced as `int32`
	lib/std/string.ci:203: referenced as `int32`
	lib/std/string.ci:172: referenced as `int32`
	lib/std/string.ci:157: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:144: referenced as `int32`
	lib/std/string.ci:144: referenced as `int32`
	lib/std/string.ci:128: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:123: referenced as `int32`
	lib/std/string.ci:117: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:375: referenced as `int32`
	lib/std/math.ci:375: referenced as `int32`
	lib/std/math.ci:326: referenced as `int32`
	lib/std/math.ci:294: referenced as `int32`
	lib/std/math.ci:279: referenced as `int32`
	lib/std/math.ci:264: referenced as `int32`
	lib/std/math.ci:257: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:17: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:76: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	lib/std/debug.ci:64: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/std/memory.ci:30: referenced as `int64`
	test/std/memory.ci:29: referenced as `int64`
	test/std/memory.ci:24: referenced as `int64`
	test/std/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	lib/std/string.ci:225: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/std/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
	lib/std/string.ci:223: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
	lib/std/string.ci:221: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@009a50>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009d80>, cast: static const inline)
.field pop: function (size: 0, offs: <@009f80>, cast: static const inline)
.field swap: function (size: 0, offs: <@00a180>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00a380>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00a580>, cast: static const inline)
.field hib: function (size: 0, offs: <@00a780>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a980>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/std/number.ci:63: referenced as `uint32`
	test/std/number.ci:62: referenced as `uint32`
	test/std/number.ci:60: referenced as `uint32`
	test/std/number.ci:59: referenced as `uint32`
	test/std/number.ci:58: referenced as `uint32`
	test/std/number.ci:57: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:56: referenced as `uint32`
	test/std/number.ci:55: referenced as `uint32`
	test/std/number.ci:35: referenced as `uint32`
	test/std/number.ci:34: referenced as `uint32`
	test/std/number.ci:33: referenced as `uint32`
	test/std/number.ci:31: referenced as `uint32`
	test/std/number.ci:30: referenced as `uint32`
	test/std/number.ci:29: referenced as `uint32`
	test/std/number.ci:27: referenced as `uint32`
	test/std/number.ci:26: referenced as `uint32`
	test/std/number.ci:25: referenced as `uint32`
	test/std/number.ci:23: referenced as `uint32`
	test/std/number.ci:22: referenced as `uint32`
	test/std/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:219: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a50>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/std/number.ci:62: referenced as `zxt`
	test/std/number.ci:31: referenced as `zxt`
	test/std/number.ci:30: referenced as `zxt`
	test/std/number.ci:29: referenced as `zxt`
	test/std/number.ci:23: referenced as `zxt`
	test/std/number.ci:22: referenced as `zxt`
	test/std/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009d80>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/std/number.ci:63: referenced as `sxt`
	test/std/number.ci:35: referenced as `sxt`
	test/std/number.ci:34: referenced as `sxt`
	test/std/number.ci:33: referenced as `sxt`
	test/std/number.ci:27: referenced as `sxt`
	test/std/number.ci:26: referenced as `sxt`
	test/std/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009f80>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/std/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a180>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/std/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a380>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/std/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a580>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/std/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a780>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	test/std/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a980>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(29)
.usages:
	test/std/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00aca8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00afd0>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/std/number.ci:66: referenced as `uint64`
	test/std/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
	lib/std/string.ci:254: referenced as `uint64`
	lib/std/string.ci:250: referenced as `uint64`
	lib/std/string.ci:231: referenced as `uint64`
	lib/std/string.ci:229: referenced as `uint64`
	lib/std/string.ci:227: referenced as `uint64`
	lib/std/string.ci:225: referenced as `uint64`
	lib/std/string.ci:223: referenced as `uint64`
	lib/std/string.ci:221: referenced as `uint64`
	lib/std/string.ci:219: referenced as `uint64`
	lib/std/string.ci:217: referenced as `uint64`
	lib/std/string.ci:217: referenced as `uint64`
	lib/std/string.ci:144: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00aca8>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(30)
.usages:
	test/std/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00afd0>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(31)
.usages:
	test/std/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00b1d0>, cast: static const inline)
.field cos: function (size: 0, offs: <@00b3d0>, cast: static const inline)
.field tan: function (size: 0, offs: <@00b5d0>, cast: static const inline)
.field log: function (size: 0, offs: <@00b7d0>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b9d0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00bc68>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00be68>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c100>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:96: referenced as `float32`
	test/std/test.math.ci:95: referenced as `float32`
	test/std/test.math.ci:94: referenced as `float32`
	test/std/test.math.ci:93: referenced as `float32`
	test/std/test.math.ci:91: referenced as `float32`
	test/std/test.math.ci:90: referenced as `float32`
	test/std/test.math.ci:89: referenced as `float32`
	test/std/test.math.ci:88: referenced as `float32`
	test/std/test.math.ci:86: referenced as `float32`
	test/std/test.math.ci:85: referenced as `float32`
	test/std/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:53: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:52: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:51: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:50: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:49: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:48: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:47: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:46: referenced as `float32`
	test/std/number.ci:7: referenced as `float32`
	test/std/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/std/string.ci:259: referenced as `float32`
	lib/std/math/Matrix4f.ci:174: referenced as `float32`
	lib/std/math/Matrix4f.ci:173: referenced as `float32`
	lib/std/math/Matrix4f.ci:163: referenced as `float32`
	lib/std/math/Matrix4f.ci:160: referenced as `float32`
	lib/std/math/Matrix4f.ci:137: referenced as `float32`
	lib/std/math/Matrix4f.ci:136: referenced as `float32`
	lib/std/math/Matrix4f.ci:136: referenced as `float32`
	lib/std/math/Matrix4f.ci:135: referenced as `float32`
	lib/std/math/Matrix4f.ci:135: referenced as `float32`
	lib/std/math/Matrix4f.ci:133: referenced as `float32`
	lib/std/math/Matrix4f.ci:132: referenced as `float32`
	lib/std/math/Matrix4f.ci:131: referenced as `float32`
	lib/std/math/Matrix4f.ci:130: referenced as `float32`
	lib/std/math/Matrix4f.ci:129: referenced as `float32`
	lib/std/math/Matrix4f.ci:128: referenced as `float32`
	lib/std/math/Matrix4f.ci:127: referenced as `float32`
	lib/std/math/Matrix4f.ci:126: referenced as `float32`
	lib/std/math/Matrix4f.ci:125: referenced as `float32`
	lib/std/math/Matrix4f.ci:124: referenced as `float32`
	lib/std/math/Matrix4f.ci:123: referenced as `float32`
	lib/std/math/Matrix4f.ci:122: referenced as `float32`
	lib/std/math/Matrix4f.ci:112: referenced as `float32`
	lib/std/math/Matrix4f.ci:111: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:65: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:64: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:63: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:62: referenced as `float32`
	lib/std/math/Matrix4f.ci:57: referenced as `float32`
	lib/std/math/Matrix4f.ci:55: referenced as `float32`
	lib/std/math/Matrix4f.ci:53: referenced as `float32`
	lib/std/math/Matrix4f.ci:51: referenced as `float32`
	lib/std/math/Matrix4f.ci:48: referenced as `float32`
	lib/std/math/Matrix4f.ci:46: referenced as `float32`
	lib/std/math/Matrix4f.ci:44: referenced as `float32`
	lib/std/math/Matrix4f.ci:42: referenced as `float32`
	lib/std/math/Matrix4f.ci:39: referenced as `float32`
	lib/std/math/Matrix4f.ci:37: referenced as `float32`
	lib/std/math/Matrix4f.ci:35: referenced as `float32`
	lib/std/math/Matrix4f.ci:33: referenced as `float32`
	lib/std/math/Matrix4f.ci:30: referenced as `float32`
	lib/std/math/Matrix4f.ci:28: referenced as `float32`
	lib/std/math/Matrix4f.ci:26: referenced as `float32`
	lib/std/math/Matrix4f.ci:24: referenced as `float32`
	lib/std/math/Matrix4f.ci:7: referenced as `float32`
	lib/std/math/Matrix4f.ci:4: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:107: referenced as `float32`
	lib/std/math/Vector4f.ci:102: referenced as `float32`
	lib/std/math/Vector4f.ci:96: referenced as `float32`
	lib/std/math/Vector4f.ci:92: referenced as `float32`
	lib/std/math/Vector4f.ci:88: referenced as `float32`
	lib/std/math/Vector4f.ci:84: referenced as `float32`
	lib/std/math/Vector4f.ci:82: referenced as `float32`
	lib/std/math/Vector4f.ci:40: referenced as `float32`
	lib/std/math/Vector4f.ci:37: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:34: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:31: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:26: referenced as `float32`
	lib/std/math/Vector4f.ci:13: referenced as `float32`
	lib/std/math/Vector4f.ci:11: referenced as `float32`
	lib/std/math/Vector4f.ci:9: referenced as `float32`
	lib/std/math/Vector4f.ci:7: referenced as `float32`
	lib/std/math/Vector4f.ci:4: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:264: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b1d0>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/std/number.ci:46: referenced as `sin`
	lib/std/math/Matrix4f.ci:135: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b3d0>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/std/number.ci:47: referenced as `cos`
	lib/std/math/Matrix4f.ci:136: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5d0>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/std/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b7d0>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/std/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b9d0>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	test/std/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc68>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(37)
.usages:
	test/std/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be68>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(38)
.usages:
	test/std/number.ci:52: referenced as `sqrt`
	lib/std/math/Vector4f.ci:102: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c100>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(39)
.usages:
	test/std/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00c2f8>, cast: static const inline)
.field cos: function (size: 0, offs: <@00c4f0>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c6e8>, cast: static const inline)
.field log: function (size: 0, offs: <@00c8e0>, cast: static const inline)
.field exp: function (size: 0, offs: <@00cad8>, cast: static const inline)
.field pow: function (size: 0, offs: <@00cd68>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00cf60>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00d1f0>, cast: static const inline)
.value: 0
.usages:
	test/std/test.math.ci:82: referenced as `float64`
	test/std/test.math.ci:81: referenced as `float64`
	test/std/test.math.ci:80: referenced as `float64`
	test/std/test.math.ci:79: referenced as `float64`
	test/std/test.math.ci:77: referenced as `float64`
	test/std/test.math.ci:76: referenced as `float64`
	test/std/test.math.ci:75: referenced as `float64`
	test/std/test.math.ci:74: referenced as `float64`
	test/std/test.math.ci:72: referenced as `float64`
	test/std/test.math.ci:71: referenced as `float64`
	test/std/test.math.ci:70: referenced as `float64`
	test/std/test.math.ci:64: referenced as `float64`
	test/std/test.math.ci:63: referenced as `float64`
	test/std/test.math.ci:61: referenced as `float64`
	test/std/test.math.ci:60: referenced as `float64`
	test/std/test.math.ci:59: referenced as `float64`
	test/std/test.math.ci:58: referenced as `float64`
	test/std/test.math.ci:57: referenced as `float64`
	test/std/test.math.ci:55: referenced as `float64`
	test/std/test.math.ci:54: referenced as `float64`
	test/std/test.math.ci:53: referenced as `float64`
	test/std/test.math.ci:52: referenced as `float64`
	test/std/test.math.ci:51: referenced as `float64`
	test/std/test.math.ci:50: referenced as `float64`
	test/std/test.math.ci:49: referenced as `float64`
	test/std/test.math.ci:48: referenced as `float64`
	test/std/test.math.ci:46: referenced as `float64`
	test/std/test.math.ci:45: referenced as `float64`
	test/std/test.math.ci:44: referenced as `float64`
	test/std/test.math.ci:43: referenced as `float64`
	test/std/test.math.ci:41: referenced as `float64`
	test/std/test.math.ci:40: referenced as `float64`
	test/std/test.math.ci:39: referenced as `float64`
	test/std/test.math.ci:38: referenced as `float64`
	test/std/test.math.ci:36: referenced as `float64`
	test/std/test.math.ci:35: referenced as `float64`
	test/std/test.math.ci:33: referenced as `float64`
	test/std/test.math.ci:32: referenced as `float64`
	test/std/test.math.ci:30: referenced as `float64`
	test/std/test.math.ci:29: referenced as `float64`
	test/std/test.math.ci:27: referenced as `float64`
	test/std/test.math.ci:26: referenced as `float64`
	test/std/test.math.ci:25: referenced as `float64`
	test/std/test.math.ci:24: referenced as `float64`
	test/std/test.math.ci:22: referenced as `float64`
	test/std/test.math.ci:21: referenced as `float64`
	test/std/test.math.ci:20: referenced as `float64`
	test/std/test.math.ci:19: referenced as `float64`
	test/std/test.math.ci:18: referenced as `float64`
	test/std/test.math.ci:17: referenced as `float64`
	test/std/test.math.ci:15: referenced as `float64`
	test/std/test.math.ci:14: referenced as `float64`
	test/std/test.math.ci:13: referenced as `float64`
	test/std/test.math.ci:12: referenced as `float64`
	test/std/test.math.ci:11: referenced as `float64`
	test/std/test.math.ci:10: referenced as `float64`
	test/std/test.math.ci:8: referenced as `float64`
	test/std/test.math.ci:7: referenced as `float64`
	test/std/test.math.ci:6: referenced as `float64`
	test/std/test.math.ci:5: referenced as `float64`
	test/std/test.math.ci:4: referenced as `float64`
	test/std/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:44: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:43: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:42: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:41: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:40: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:39: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:38: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:37: referenced as `float64`
	test/std/number.ci:4: referenced as `float64`
	test/std/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/std/string.ci:259: referenced as `float64`
	lib/std/string.ci:253: referenced as `float64`
	lib/std/string.ci:249: referenced as `float64`
	lib/std/string.ci:234: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:14: referenced as `float64`
	lib/std/math/Vector2d.ci:9: referenced as `float64`
	lib/std/math/Vector2d.ci:7: referenced as `float64`
	lib/std/math/Vector2d.ci:4: referenced as `float64`
	lib/std/math/Complex.ci:187: referenced as `float64`
	lib/std/math/Complex.ci:187: referenced as `float64`
	lib/std/math/Complex.ci:151: referenced as `float64`
	lib/std/math/Complex.ci:151: referenced as `float64`
	lib/std/math/Complex.ci:149: referenced as `float64`
	lib/std/math/Complex.ci:149: referenced as `float64`
	lib/std/math/Complex.ci:146: referenced as `float64`
	lib/std/math/Complex.ci:142: referenced as `float64`
	lib/std/math/Complex.ci:141: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:139: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:138: referenced as `float64`
	lib/std/math/Complex.ci:137: referenced as `float64`
	lib/std/math/Complex.ci:136: referenced as `float64`
	lib/std/math/Complex.ci:132: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:129: referenced as `float64`
	lib/std/math/Complex.ci:118: referenced as `float64`
	lib/std/math/Complex.ci:114: referenced as `float64`
	lib/std/math/Complex.ci:112: referenced as `float64`
	lib/std/math/Complex.ci:109: referenced as `float64`
	lib/std/math/Complex.ci:107: referenced as `float64`
	lib/std/math/Complex.ci:99: referenced as `float64`
	lib/std/math/Complex.ci:98: referenced as `float64`
	lib/std/math/Complex.ci:92: referenced as `float64`
	lib/std/math/Complex.ci:91: referenced as `float64`
	lib/std/math/Complex.ci:83: referenced as `float64`
	lib/std/math/Complex.ci:81: referenced as `float64`
	lib/std/math/Complex.ci:73: referenced as `float64`
	lib/std/math/Complex.ci:71: referenced as `float64`
	lib/std/math/Complex.ci:66: referenced as `float64`
	lib/std/math/Complex.ci:64: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:31: referenced as `float64`
	lib/std/math/Complex.ci:24: referenced as `float64`
	lib/std/math/Complex.ci:8: referenced as `float64`
	lib/std/math/Complex.ci:5: referenced as `float64`
	lib/std/math.ci:524: referenced as `float64`
	lib/std/math.ci:524: referenced as `float64`
	lib/std/math.ci:521: referenced as `float64`
	lib/std/math.ci:521: referenced as `float64`
	lib/std/math.ci:497: referenced as `float64`
	lib/std/math.ci:484: referenced as `float64`
	lib/std/math.ci:481: referenced as `float64`
	lib/std/math.ci:479: referenced as `float64`
	lib/std/math.ci:479: referenced as `float64`
	lib/std/math.ci:462: referenced as `float64`
	lib/std/math.ci:462: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:447: referenced as `float64`
	lib/std/math.ci:447: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:430: referenced as `float64`
	lib/std/math.ci:427: referenced as `float64`
	lib/std/math.ci:410: referenced as `float64`
	lib/std/math.ci:408: referenced as `float64`
	lib/std/math.ci:408: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:391: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:373: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:351: referenced as `float64`
	lib/std/math.ci:351: referenced as `float64`
	lib/std/math.ci:348: referenced as `float64`
	lib/std/math.ci:345: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:338: referenced as `float64`
	lib/std/math.ci:321: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:314: referenced as `float64`
	lib/std/math.ci:308: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:294: referenced as `float64`
	lib/std/math.ci:294: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:279: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:255: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:246: referenced as `float64`
	lib/std/math.ci:243: referenced as `float64`
	lib/std/math.ci:243: referenced as `float64`
	lib/std/math.ci:238: referenced as `float64`
	lib/std/math.ci:238: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c2f8>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/std/number.ci:37: referenced as `sin`
	lib/std/math/Complex.ci:187: referenced as `sin`
	lib/std/math/Complex.ci:151: referenced as `sin`
	lib/std/math/Complex.ci:149: referenced as `sin`
	lib/std/math/Complex.ci:142: referenced as `sin`
	lib/std/math/Complex.ci:129: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c4f0>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/std/number.ci:38: referenced as `cos`
	lib/std/math/Complex.ci:187: referenced as `cos`
	lib/std/math/Complex.ci:151: referenced as `cos`
	lib/std/math/Complex.ci:149: referenced as `cos`
	lib/std/math/Complex.ci:141: referenced as `cos`
	lib/std/math/Complex.ci:129: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6e8>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/std/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c8e0>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/std/number.ci:40: referenced as `log`
	lib/std/math/Complex.ci:138: referenced as `log`
	lib/std/math/Complex.ci:132: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cad8>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	test/std/number.ci:41: referenced as `exp`
	lib/std/math/Complex.ci:139: referenced as `exp`
	lib/std/math/Complex.ci:129: referenced as `exp`
	lib/std/math/Complex.ci:129: referenced as `exp`
	lib/std/math.ci:454: referenced as `exp`
	lib/std/math.ci:454: referenced as `exp`
	lib/std/math.ci:452: referenced as `exp`
	lib/std/math.ci:432: referenced as `exp`
	lib/std/math.ci:432: referenced as `exp`
	lib/std/math.ci:427: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cd68>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(45)
.usages:
	test/std/number.ci:42: referenced as `pow`
	lib/std/string.ci:253: referenced as `pow`
	lib/std/math/Complex.ci:139: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cf60>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(46)
.usages:
	test/std/number.ci:43: referenced as `sqrt`
	lib/std/math/Complex.ci:112: referenced as `sqrt`
	lib/std/math.ci:479: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d1f0>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(47)
.usages:
	test/std/number.ci:44: referenced as `atan2`
	lib/std/math/Complex.ci:114: referenced as `atan2`
	lib/std/math.ci:484: referenced as `atan2`
	lib/std/math.ci:481: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@008128>, cast: static const inline)
.field fill: function (size: 0, offs: <@008460>, cast: static const inline)
.field copy: function (size: 0, offs: <@008798>, cast: static const inline)
.field move: function (size: 0, offs: <@008ac8>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/std/tryExec.ci:42: referenced as `pointer`
	test/std/tryExec.ci:37: referenced as `pointer`
	test/std/tryExec.ci:23: referenced as `pointer`
	test/std/tryExec.ci:19: referenced as `pointer`
	test/std/tryExec.ci:14: referenced as `pointer`
	test/std/tryExec.ci:11: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:30: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:29: referenced as `pointer`
	test/std/memory.ci:14: referenced as `pointer`
	test/std/memory.ci:13: referenced as `pointer`
	test/std/memory.ci:10: referenced as `pointer`
	test/std/memory.ci:9: referenced as `pointer`
	test/std/memory.ci:8: referenced as `pointer`
	test/std/memory.ci:7: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:5: referenced as `pointer`
	test/std/memory.ci:4: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/std/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008128>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(11)
.usages:
	test/std/memory.ci:5: referenced as `alloc`
	test/std/memory.ci:4: referenced as `alloc`
	test/std/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008460>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	test/std/memory.ci:30: referenced as `fill`
	test/std/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008798>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/std/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008ac8>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(14)
.usages:
	test/std/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.field is: function (size: 0, offs: <@005cd8>, cast: static const inline)
.field as: function (size: 0, offs: <@005f70>, cast: static const inline)
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/std/debug.ci:56: referenced as `variant`
	lib/std/debug.ci:53: referenced as `variant`
	lib/std/debug.ci:50: referenced as `variant`
	lib/std/debug.ci:41: referenced as `variant`
	lib/std/debug.ci:34: referenced as `variant`
	lib/std/debug.ci:29: referenced as `variant`
	lib/std/debug.ci:24: referenced as `variant`
	lib/std/debug.ci:19: referenced as `variant`
	lib/std/debug.ci:14: referenced as `variant`
	lib/std/debug.ci:9: referenced as `variant`
	lib/std/debug.ci:4: referenced as `variant`
	internal usages: 3
}
variant.is(var: variant, type: typename): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005cd8>
.name: 'is'
.owner: variant
.param .result: bool (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005f70>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006b50>, cast: static const inline)
.field as: function (size: 0, offs: <@006de8>, cast: static const inline)
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006de8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/std/tryExec.ci:52: referenced as `null`
	test/std/tryExec.ci:51: referenced as `null`
	test/std/tryExec.ci:50: referenced as `null`
	test/std/tryExec.ci:49: referenced as `null`
	test/std/tryExec.ci:48: referenced as `null`
	test/std/tryExec.ci:47: referenced as `null`
	test/std/tryExec.ci:47: referenced as `null`
	test/std/tryExec.ci:46: referenced as `null`
	test/std/tryExec.ci:38: referenced as `null`
	test/std/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/std/debug.ci:76: referenced as `null`
	lib/std/debug.ci:59: referenced as `null`
	lib/std/debug.ci:56: referenced as `null`
	lib/std/debug.ci:38: referenced as `null`
	lib/std/debug.ci:36: referenced as `null`
	lib/std/debug.ci:31: referenced as `null`
	lib/std/debug.ci:26: referenced as `null`
	lib/std/debug.ci:21: referenced as `null`
	lib/std/debug.ci:16: referenced as `null`
	lib/std/debug.ci:11: referenced as `null`
	lib/std/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000d38>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000dd8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001198>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001238>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0014b8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a58>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001df0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001fd0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0021a0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002370>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002540>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002710>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002a10>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002e60>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003290>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036c0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c20>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004180>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0045b0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@0049e0>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004e10>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005240>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005410>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@0055e0>, cast: static const typename(void))
.usages:
	test/std/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/std/math/Vector2d.ci:40: referenced as `emit`
	lib/std/math/Vector2d.ci:37: referenced as `emit`
	lib/std/math/Vector2d.ci:34: referenced as `emit`
	lib/std/math/Vector2d.ci:31: referenced as `emit`
	lib/std/math/Vector2d.ci:28: referenced as `emit`
	lib/std/math/Vector2d.ci:25: referenced as `emit`
	lib/std/math/Vector2d.ci:22: referenced as `emit`
	lib/std/math/Vector4f.ci:96: referenced as `emit`
	lib/std/math/Vector4f.ci:92: referenced as `emit`
	lib/std/math/Vector4f.ci:88: referenced as `emit`
	lib/std/math/Vector4f.ci:84: referenced as `emit`
	lib/std/math/Vector4f.ci:82: referenced as `emit`
	lib/std/math/Vector4f.ci:79: referenced as `emit`
	lib/std/math/Vector4f.ci:77: referenced as `emit`
	lib/std/math/Vector4f.ci:75: referenced as `emit`
	lib/std/math/Vector4f.ci:73: referenced as `emit`
	lib/std/math/Vector4f.ci:71: referenced as `emit`
	lib/std/math/Complex.ci:76: referenced as `emit`
	lib/std/math/Complex.ci:69: referenced as `emit`
	lib/std/math/Complex.ci:62: referenced as `emit`
	lib/std/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/std/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001198>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `p4x`
	lib/std/math/Vector4f.ci:92: referenced as `p4x`
	lib/std/math/Vector4f.ci:88: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/std/math/Vector4f.ci:88: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/std/math/Vector4f.ci:96: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/std/math/Vector4f.ci:92: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001238>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0014b8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/std/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/std/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a58>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001df0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001fd0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0021a0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002370>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002540>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002710>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a10>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	lib/std/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002e60>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/std/math/Vector2d.ci:22: referenced as `add`
	lib/std/math/Vector4f.ci:73: referenced as `add`
	lib/std/math/Complex.ci:77: referenced as `add`
	lib/std/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	lib/std/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/std/math/Vector4f.ci:73: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	lib/std/math/Vector2d.ci:22: referenced as `p2d`
	lib/std/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003290>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `sub`
	lib/std/math/Vector4f.ci:75: referenced as `sub`
	lib/std/math/Complex.ci:78: referenced as `sub`
	lib/std/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	lib/std/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/std/math/Vector4f.ci:75: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/std/math/Vector2d.ci:25: referenced as `p2d`
	lib/std/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036c0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:28: referenced as `mul`
	lib/std/math/Vector4f.ci:77: referenced as `mul`
	lib/std/math/Complex.ci:78: referenced as `mul`
	lib/std/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/std/math/Vector4f.ci:77: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	lib/std/math/Vector2d.ci:28: referenced as `p2d`
	lib/std/math/Complex.ci:78: referenced as `p2d`
	lib/std/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c20>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/std/math/Vector2d.ci:31: referenced as `div`
	lib/std/math/Vector4f.ci:79: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/std/math/Vector4f.ci:79: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	lib/std/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004180>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0045b0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	lib/std/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0049e0>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e10>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005240>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/std/math/Vector4f.ci:82: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	lib/std/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005410>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/std/math/Vector4f.ci:84: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	lib/std/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0055e0>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/std/math/Complex.ci:78: referenced as `swz`
	lib/std/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	lib/std/math/Complex.ci:78: referenced as `x2`
	lib/std/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005a38>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0075a8>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(9)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:73: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:38: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:36: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:34: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:31: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:29: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:26: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:24: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:21: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:19: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:16: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:14: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:11: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:9: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:6: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/std/debug.ci:4: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/std/debug.ci:73: referenced as `abort`
	lib/std/debug.ci:38: referenced as `abort`
	lib/std/debug.ci:36: referenced as `abort`
	lib/std/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/std/debug.ci:31: referenced as `error`
	lib/std/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/std/debug.ci:26: referenced as `warn`
	lib/std/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/std/debug.ci:21: referenced as `info`
	lib/std/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/std/debug.ci:16: referenced as `debug`
	lib/std/debug.ci:14: referenced as `debug`
	lib/std/debug.ci:11: referenced as `debug`
	lib/std/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/std/debug.ci:6: referenced as `verbose`
	lib/std/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/std/debug.ci:26: referenced as `noTrace`
	lib/std/debug.ci:24: referenced as `noTrace`
	lib/std/debug.ci:21: referenced as `noTrace`
	lib/std/debug.ci:19: referenced as `noTrace`
	lib/std/debug.ci:11: referenced as `noTrace`
	lib/std/debug.ci:9: referenced as `noTrace`
	lib/std/debug.ci:6: referenced as `noTrace`
	lib/std/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/std/debug.ci:73: referenced as `defTrace`
	lib/std/debug.ci:38: referenced as `defTrace`
	lib/std/debug.ci:36: referenced as `defTrace`
	lib/std/debug.ci:34: referenced as `defTrace`
	lib/std/debug.ci:31: referenced as `defTrace`
	lib/std/debug.ci:29: referenced as `defTrace`
	lib/std/debug.ci:16: referenced as `defTrace`
	lib/std/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e88>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(10)
.usages:
	test/std/tryExec.ci:52: referenced as `tryExec`
	test/std/tryExec.ci:51: referenced as `tryExec`
	test/std/tryExec.ci:50: referenced as `tryExec`
	test/std/tryExec.ci:49: referenced as `tryExec`
	test/std/tryExec.ci:48: referenced as `tryExec`
	test/std/tryExec.ci:47: referenced as `tryExec`
	test/std/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008af8>
.name: 'System'
.field exit: function (size: 0, offs: <@008d70>, cast: static const inline)
.field srand: function (size: 0, offs: <@008f78>, cast: static const inline)
.field rand: function (size: 0, offs: <@0090e0>, cast: static const inline)
.field time: function (size: 0, offs: <@009248>, cast: static const inline)
.field clock: function (size: 0, offs: <@0093b0>, cast: static const inline)
.field millis: function (size: 0, offs: <@009518>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009718>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d70>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(15)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f78>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(16)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0090e0>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009248>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093b0>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(19)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009518>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(20)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009718>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(21)
.usages:
	internal usages: 1
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:470: referenced as `true`
	lib/std/math.ci:423: referenced as `true`
	lib/std/math.ci:384: referenced as `true`
	lib/std/math.ci:380: referenced as `true`
	lib/std/math.ci:369: referenced as `true`
	lib/stdlib.ci:4: defined as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:242: referenced as `false`
	lib/std/string.ci:114: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:468: referenced as `false`
	lib/std/math.ci:420: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/std/math.ci:364: referenced as `false`
	lib/stdlib.ci:5: defined as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
	lib/stdlib.ci:8: defined as `byte`
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
	lib/stdlib.ci:9: defined as `float`
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
	lib/stdlib.ci:10: defined as `double`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:4: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/std/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:6: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/std/memory.ci:33: referenced as `debug`
	test/std/memory.ci:32: referenced as `debug`
	test/std/memory.ci:27: referenced as `debug`
	test/std/memory.ci:26: referenced as `debug`
	lib/std/debug.ci:9: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/std/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/std/debug.ci:11: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/std/math/Matrix4f.ci:114: referenced as `trace`
	lib/std/debug.ci:14: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/std/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/std/debug.ci:16: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:19: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/std/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:21: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/std/debug.ci:24: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/std/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/std/debug.ci:26: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/std/debug.ci:29: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/std/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/std/debug.ci:31: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/std/tryExec.ci:34: referenced as `abort`
	lib/std/debug.ci:41: referenced as `abort`
	lib/std/debug.ci:34: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/std/debug.ci:45: referenced as `abort`
	lib/std/debug.ci:43: referenced as `abort`
	lib/std/debug.ci:36: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/std/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/std/debug.ci:38: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:162: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/std/debug.ci:41: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/std/debug.ci:43: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/std/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:204: referenced as `assert`
	lib/std/string.ci:197: referenced as `assert`
	lib/std/string.ci:190: referenced as `assert`
	lib/std/string.ci:185: referenced as `assert`
	lib/std/debug.ci:45: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0107e8>
.name: 'NotEquals'
.file: 'lib/std/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/std/debug.ci:68: referenced as `NotEquals`
	lib/std/debug.ci:48: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/std/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/std/debug.ci:69: referenced as `expected`
	lib/std/debug.ci:50: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/std/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/std/debug.ci:70: referenced as `returned`
	lib/std/debug.ci:53: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/std/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:56: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/std/debug.ci:59'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/std/debug.ci:71: referenced as `message`
	lib/std/debug.ci:59: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@057570>
.name: 'assertEq'
.file: 'lib/std/debug.ci:64'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@057570> - <@0575ce>)
	lib/std/debug.ci:65: (10 bytes: <@057570> - <@05757a>): if (bool(returned == expected))
	<assertEq @057570>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @057572>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @057574>    : 57                         ceq.i32
	<assertEq+5 @057575>    : 06 05 00 00                jz <assertEq+10 @05757a>
	lib/std/debug.ci:66: (1 byte: <@057579> - <@05757a>): return;
	<assertEq+9 @057579>    : 03                         ret
	lib/std/debug.ci:68: (41 bytes: <@05757a> - <@0575a3>): details: NotEquals := {...}
	<assertEq+10 @05757a>   : 09 20 00 00                inc.sp(+32)
	lib/std/debug.ci:69: (11 bytes: <@05757e> - <@057589>): void(details.expected := (expected));
	<assertEq+14 @05757e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @057583>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @057587>   : 14 02                      set.x64 sp(2)
	lib/std/debug.ci:70: (11 bytes: <@057589> - <@057594>): void(details.returned := (returned));
	<assertEq+25 @057589>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @05758e>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @057592>   : 14 04                      set.x64 sp(4)
	lib/std/debug.ci:71: (3 bytes: <@057594> - <@057597>): void(details.message := (message));
	<assertEq+36 @057594>   : 16 06 09                   mov.x32 sp(6, 9)
	:: (12 bytes: <@057597> - <@0575a3>): void(details.argument := (null))
	<assertEq+39 @057597>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @05759c>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @0575a1>   : 14 06                      set.x64 sp(6)
	lib/std/debug.ci:73: (38 bytes: <@0575a3> - <@0575c9>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @0575a3>   : 1f e8 d5 00 00             load.ref <@00d5e8> ;"lib/std/debug.ci"
	<assertEq+56 @0575a8>   : 1c 49 00 00 00             load.c32 73
	<assertEq+61 @0575ad>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @0575b2>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @0575b7>   : 1f ee d8 00 00             load.ref <@00d8ee> ;"assertion failed"
	<assertEq+76 @0575bc>   : 1f e8 07 01 00             load.ref <@0107e8> ;NotEquals
	<assertEq+81 @0575c1>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @0575c5>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @0575c9>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @0575cd>   : 03                         ret
.usages:
	lib/std/debug.ci:76: referenced as `assertEq`
	lib/std/debug.ci:64: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/std/debug.ci:76'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/std/debug.ci:76: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:17'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/std/memory.ci:30: referenced as `sizeof`
	test/std/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:17: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@011a78>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@0575d0>, cast: static const function)
.field floor: function (size: 24, offs: <@057628>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@057640>, cast: static const function)
.field abs: function (size: 18, offs: <@057658>, cast: static const function)
.field absMod: function (size: 27, offs: <@057670>, cast: static const function)
.field absMod: function (size: 27, offs: <@057690>, cast: static const function)
.field min: function (size: 17, offs: <@0576b0>, cast: static const function)
.field min: function (size: 17, offs: <@0576c8>, cast: static const function)
.field max: function (size: 17, offs: <@0576e0>, cast: static const function)
.field max: function (size: 17, offs: <@0576f8>, cast: static const function)
.field clamp: function (size: 30, offs: <@057710>, cast: static const function)
.field clamp: function (size: 30, offs: <@057730>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@057750>, cast: static const function)
.field max: function (size: 79, offs: <@0577a0>, cast: static const function)
.field sum: function (size: 40, offs: <@0577f0>, cast: static const function)
.field mean: function (size: 20, offs: <@057818>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@057830>, cast: static const function)
.field cmp: function (size: 57, offs: <@057860>, cast: static const function)
.field cmp: function (size: 57, offs: <@0578a0>, cast: static const function)
.field sinCos: function (size: 335, offs: <@0578e0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@057a30>, cast: static const function)
.field sinh: function (size: 241, offs: <@057bb0>, cast: static const function)
.field cosh: function (size: 75, offs: <@057ca8>, cast: static const function)
.field asin: function (size: 173, offs: <@057cf8>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/std/test.math.ci:96: referenced as `Math`
	test/std/test.math.ci:95: referenced as `Math`
	test/std/test.math.ci:94: referenced as `Math`
	test/std/test.math.ci:93: referenced as `Math`
	test/std/test.math.ci:91: referenced as `Math`
	test/std/test.math.ci:90: referenced as `Math`
	test/std/test.math.ci:89: referenced as `Math`
	test/std/test.math.ci:88: referenced as `Math`
	test/std/test.math.ci:86: referenced as `Math`
	test/std/test.math.ci:85: referenced as `Math`
	test/std/test.math.ci:84: referenced as `Math`
	test/std/test.math.ci:82: referenced as `Math`
	test/std/test.math.ci:81: referenced as `Math`
	test/std/test.math.ci:80: referenced as `Math`
	test/std/test.math.ci:79: referenced as `Math`
	test/std/test.math.ci:77: referenced as `Math`
	test/std/test.math.ci:76: referenced as `Math`
	test/std/test.math.ci:75: referenced as `Math`
	test/std/test.math.ci:74: referenced as `Math`
	test/std/test.math.ci:72: referenced as `Math`
	test/std/test.math.ci:71: referenced as `Math`
	test/std/test.math.ci:70: referenced as `Math`
	test/std/test.math.ci:68: referenced as `Math`
	test/std/test.math.ci:67: referenced as `Math`
	test/std/test.math.ci:64: referenced as `Math`
	test/std/test.math.ci:63: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:61: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:60: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:59: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:58: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:57: referenced as `Math`
	test/std/test.math.ci:55: referenced as `Math`
	test/std/test.math.ci:54: referenced as `Math`
	test/std/test.math.ci:53: referenced as `Math`
	test/std/test.math.ci:52: referenced as `Math`
	test/std/test.math.ci:51: referenced as `Math`
	test/std/test.math.ci:50: referenced as `Math`
	test/std/test.math.ci:49: referenced as `Math`
	test/std/test.math.ci:46: referenced as `Math`
	test/std/test.math.ci:45: referenced as `Math`
	test/std/test.math.ci:44: referenced as `Math`
	test/std/test.math.ci:43: referenced as `Math`
	test/std/test.math.ci:41: referenced as `Math`
	test/std/test.math.ci:40: referenced as `Math`
	test/std/test.math.ci:39: referenced as `Math`
	test/std/test.math.ci:38: referenced as `Math`
	test/std/test.math.ci:36: referenced as `Math`
	test/std/test.math.ci:35: referenced as `Math`
	test/std/test.math.ci:33: referenced as `Math`
	test/std/test.math.ci:32: referenced as `Math`
	test/std/test.math.ci:30: referenced as `Math`
	test/std/test.math.ci:29: referenced as `Math`
	test/std/test.math.ci:27: referenced as `Math`
	test/std/test.math.ci:26: referenced as `Math`
	test/std/test.math.ci:25: referenced as `Math`
	test/std/test.math.ci:24: referenced as `Math`
	test/std/test.math.ci:22: referenced as `Math`
	test/std/test.math.ci:21: referenced as `Math`
	test/std/test.math.ci:20: referenced as `Math`
	test/std/test.math.ci:19: referenced as `Math`
	test/std/test.math.ci:18: referenced as `Math`
	test/std/test.math.ci:17: referenced as `Math`
	test/std/test.math.ci:15: referenced as `Math`
	test/std/test.math.ci:14: referenced as `Math`
	test/std/test.math.ci:13: referenced as `Math`
	test/std/test.math.ci:12: referenced as `Math`
	test/std/test.math.ci:11: referenced as `Math`
	test/std/test.math.ci:10: referenced as `Math`
	test/std/test.math.ci:8: referenced as `Math`
	test/std/test.math.ci:7: referenced as `Math`
	test/std/test.math.ci:6: referenced as `Math`
	test/std/test.math.ci:5: referenced as `Math`
	test/std/test.math.ci:4: referenced as `Math`
	test/std/test.math.ci:3: referenced as `Math`
	lib/std/string.ci:249: referenced as `Math`
	lib/std/string.ci:249: referenced as `Math`
	lib/std/math/Complex.ci:151: referenced as `Math`
	lib/std/math/Complex.ci:151: referenced as `Math`
	lib/std/math/Complex.ci:149: referenced as `Math`
	lib/std/math/Complex.ci:149: referenced as `Math`
	lib/std/math/Complex.ci:90: referenced as `Math`
	lib/std/math/Complex.ci:90: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/std/test.math.ci:61: referenced as `pi`
	test/std/test.math.ci:60: referenced as `pi`
	test/std/test.math.ci:59: referenced as `pi`
	test/std/test.math.ci:58: referenced as `pi`
	test/std/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:524: referenced as `pi`
	lib/std/math.ci:521: referenced as `pi`
	lib/std/math.ci:497: referenced as `pi`
	lib/std/math.ci:481: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:476: referenced as `nan`
	lib/std/math.ci:397: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@0575d0>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@0575d0> - <@057626>)
	lib/std/math.ci:23: (63 bytes: <@0575d0> - <@05760f>): if (bool(x < (1)))
	<modf @0575d0>      : 11 02                      dup.x64 sp(2)
	<modf+2 @0575d2>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0575db>   : 88                         clt.f64
	<modf+12 @0575dc>   : 06 33 00 00                jz <modf+63 @05760f>
	lib/std/math.ci:24: (39 bytes: <@0575e0> - <@057607>): if (bool(x < (0)))
	<modf+16 @0575e0>   : 11 02                      dup.x64 sp(2)
	<modf+18 @0575e2>   : 1a                         load.z64
	<modf+19 @0575e3>   : 88                         clt.f64
	<modf+20 @0575e4>   : 06 23 00 00                jz <modf+55 @057607>
	lib/std/math.ci:25: (17 bytes: <@0575e8> - <@0575f9>): result: float64 := float64(-modf(void(float64(-x), float64(&intPart))))
	<modf+24 @0575e8>   : 1a                         load.z64
	<modf+25 @0575e9>   : 11 04                      dup.x64 sp(4)
	<modf+27 @0575eb>   : 80                         neg.f64
	<modf+28 @0575ec>   : 10 05                      dup.x32 sp(5)
	<modf+30 @0575ee>   : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @0575f3>   : 02                         call
	<modf+36 @0575f4>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @0575f8>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@0575f9> - <@057600>): float64(intPart := float64(-intPart));
	<modf+41 @0575f9>   : 10 03                      dup.x32 sp(3)
	<modf+43 @0575fb>   : 23                         load.i64
	<modf+44 @0575fc>   : 80                         neg.f64
	<modf+45 @0575fd>   : 10 05                      dup.x32 sp(5)
	<modf+47 @0575ff>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@057600> - <@057603>): return float64(.result := result);
	<modf+48 @057600>   : 14 06                      set.x64 sp(6)
	<modf+50 @057602>   : 03                         ret
	<modf+51 @057603>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@057607> - <@05760b>): float64(intPart := (0));
	<modf+55 @057607>   : 1a                         load.z64
	<modf+56 @057608>   : 10 03                      dup.x32 sp(3)
	<modf+58 @05760a>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@05760b> - <@05760f>): return float64(.result := x);
	<modf+59 @05760b>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @05760e>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@05760f> - <@05761b>): result: float64 := float64(x % (1))
	<modf+63 @05760f>   : 11 02                      dup.x64 sp(2)
	<modf+65 @057611>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @05761a>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@05761b> - <@057623>): float64(intPart := float64(x - result));
	<modf+75 @05761b>   : 11 04                      dup.x64 sp(4)
	<modf+77 @05761d>   : 11 02                      dup.x64 sp(2)
	<modf+79 @05761f>   : 82                         sub.f64
	<modf+80 @057620>   : 10 05                      dup.x32 sp(5)
	<modf+82 @057622>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@057623> - <@057626>): return float64(.result := result);
	<modf+83 @057623>   : 14 06                      set.x64 sp(6)
	<modf+85 @057625>   : 03                         ret
.usages:
	lib/std/string.ci:249: referenced as `modf`
	lib/std/math.ci:374: referenced as `modf`
	lib/std/math.ci:322: referenced as `modf`
	lib/std/math.ci:318: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@057628>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <@057628> - <@057640>)
	lib/std/math.ci:48: (1 byte: <@057628> - <@057629>): result: float64
	<floor @057628>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@057629> - <@05763d>): modf(void(x, float64(&result)));
	<floor+1 @057629>    : 11 05                      dup.x64 sp(5)
	<floor+3 @05762b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @05762f>    : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @057634>   : 02                         call
	<floor+13 @057635>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @057639>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@05763d> - <@057640>): return float64(.result := result);
	<floor+21 @05763d>   : 14 05                      set.x64 sp(5)
	<floor+23 @05763f>   : 03                         ret
.usages:
	test/std/test.math.ci:8: referenced as `floor`
	test/std/test.math.ci:7: referenced as `floor`
	test/std/test.math.ci:6: referenced as `floor`
	test/std/test.math.ci:5: referenced as `floor`
	test/std/test.math.ci:4: referenced as `floor`
	test/std/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:15: referenced as `sign`
	test/std/test.math.ci:14: referenced as `sign`
	test/std/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/std/test.math.ci:12: referenced as `sign`
	test/std/test.math.ci:11: referenced as `sign`
	test/std/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@057640>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@057640> - <@057652>)
	lib/std/math.ci:78: (14 bytes: <@057640> - <@05764e>): if (bool(x < (0)))
	<abs @057640>      : 10 01                      dup.x32 sp(1)
	<abs+2 @057642>    : 19                         load.z32
	<abs+3 @057643>    : 78                         clt.f32
	<abs+4 @057644>    : 06 0a 00 00                jz <abs+14 @05764e>
	lib/std/math.ci:79: (6 bytes: <@057648> - <@05764e>): return float32(.result := float32(-x));
	<abs+8 @057648>    : 10 01                      dup.x32 sp(1)
	<abs+10 @05764a>   : 70                         neg.f32
	<abs+11 @05764b>   : 13 03                      set.x32 sp(3)
	<abs+13 @05764d>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@05764e> - <@057652>): return float32(.result := x);
	<abs+14 @05764e>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @057651>   : 03                         ret
.usages:
	test/std/test.math.ci:22: referenced as `abs`
	test/std/test.math.ci:21: referenced as `abs`
	test/std/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@057658>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@057658> - <@05766a>)
	lib/std/math.ci:86: (14 bytes: <@057658> - <@057666>): if (bool(x < (0)))
	<abs @057658>      : 11 01                      dup.x64 sp(1)
	<abs+2 @05765a>    : 1a                         load.z64
	<abs+3 @05765b>    : 88                         clt.f64
	<abs+4 @05765c>    : 06 0a 00 00                jz <abs+14 @057666>
	lib/std/math.ci:87: (6 bytes: <@057660> - <@057666>): return float64(.result := float64(-x));
	<abs+8 @057660>    : 11 01                      dup.x64 sp(1)
	<abs+10 @057662>   : 80                         neg.f64
	<abs+11 @057663>   : 14 05                      set.x64 sp(5)
	<abs+13 @057665>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@057666> - <@05766a>): return float64(.result := x);
	<abs+14 @057666>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @057669>   : 03                         ret
.usages:
	test/std/test.math.ci:19: referenced as `abs`
	test/std/test.math.ci:18: referenced as `abs`
	test/std/test.math.ci:17: referenced as `abs`
	lib/std/string.ci:249: referenced as `abs`
	lib/std/math/Complex.ci:90: referenced as `abs`
	lib/std/math/Complex.ci:90: referenced as `abs`
	lib/std/math.ci:348: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@057670>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@057670> - <@05768b>)
	lib/std/math.ci:94: (23 bytes: <@057670> - <@057687>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @057670>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @057672>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @057674>    : 75                         mod.f32
	<absMod+5 @057675>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @057677>    : 13 04                      set.x32 sp(4)
	<absMod+9 @057679>    : 19                         load.z32
	<absMod+10 @05767a>   : 78                         clt.f32
	<absMod+11 @05767b>   : 06 0c 00 00                jz <absMod+23 @057687>
	lib/std/math.ci:95: (8 bytes: <@05767f> - <@057687>): return float32(.result := float32(val + mod));
	<absMod+15 @05767f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @057681>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @057683>   : 71                         add.f32
	<absMod+20 @057684>   : 13 04                      set.x32 sp(4)
	<absMod+22 @057686>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@057687> - <@05768b>): return float32(.result := val);
	<absMod+23 @057687>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @05768a>   : 03                         ret
.usages:
	test/std/test.math.ci:96: referenced as `absMod`
	test/std/test.math.ci:95: referenced as `absMod`
	test/std/test.math.ci:94: referenced as `absMod`
	test/std/test.math.ci:93: referenced as `absMod`
	test/std/test.math.ci:91: referenced as `absMod`
	test/std/test.math.ci:90: referenced as `absMod`
	test/std/test.math.ci:89: referenced as `absMod`
	test/std/test.math.ci:88: referenced as `absMod`
	test/std/test.math.ci:86: referenced as `absMod`
	test/std/test.math.ci:85: referenced as `absMod`
	test/std/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@057690>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@057690> - <@0576ab>)
	lib/std/math.ci:102: (23 bytes: <@057690> - <@0576a7>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @057690>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @057692>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @057694>    : 85                         mod.f64
	<absMod+5 @057695>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @057697>    : 14 07                      set.x64 sp(7)
	<absMod+9 @057699>    : 1a                         load.z64
	<absMod+10 @05769a>   : 88                         clt.f64
	<absMod+11 @05769b>   : 06 0c 00 00                jz <absMod+23 @0576a7>
	lib/std/math.ci:103: (8 bytes: <@05769f> - <@0576a7>): return float64(.result := float64(val + mod));
	<absMod+15 @05769f>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @0576a1>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @0576a3>   : 81                         add.f64
	<absMod+20 @0576a4>   : 14 07                      set.x64 sp(7)
	<absMod+22 @0576a6>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@0576a7> - <@0576ab>): return float64(.result := val);
	<absMod+23 @0576a7>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @0576aa>   : 03                         ret
.usages:
	test/std/test.math.ci:82: referenced as `absMod`
	test/std/test.math.ci:81: referenced as `absMod`
	test/std/test.math.ci:80: referenced as `absMod`
	test/std/test.math.ci:79: referenced as `absMod`
	test/std/test.math.ci:77: referenced as `absMod`
	test/std/test.math.ci:76: referenced as `absMod`
	test/std/test.math.ci:75: referenced as `absMod`
	test/std/test.math.ci:74: referenced as `absMod`
	test/std/test.math.ci:72: referenced as `absMod`
	test/std/test.math.ci:71: referenced as `absMod`
	test/std/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0576b0>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0576b0> - <@0576c1>)
	lib/std/math.ci:116: (13 bytes: <@0576b0> - <@0576bd>): if (bool(a < b))
	<min @0576b0>      : 10 02                      dup.x32 sp(2)
	<min+2 @0576b2>    : 10 02                      dup.x32 sp(2)
	<min+4 @0576b4>    : 78                         clt.f32
	<min+5 @0576b5>    : 06 08 00 00                jz <min+13 @0576bd>
	lib/std/math.ci:117: (4 bytes: <@0576b9> - <@0576bd>): return float32(.result := a);
	<min+9 @0576b9>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @0576bc>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@0576bd> - <@0576c1>): return float32(.result := b);
	<min+13 @0576bd>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @0576c0>   : 03                         ret
.usages:
	test/std/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0576c8>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0576c8> - <@0576d9>)
	lib/std/math.ci:124: (13 bytes: <@0576c8> - <@0576d5>): if (bool(a < b))
	<min @0576c8>      : 11 03                      dup.x64 sp(3)
	<min+2 @0576ca>    : 11 03                      dup.x64 sp(3)
	<min+4 @0576cc>    : 88                         clt.f64
	<min+5 @0576cd>    : 06 08 00 00                jz <min+13 @0576d5>
	lib/std/math.ci:125: (4 bytes: <@0576d1> - <@0576d5>): return float64(.result := a);
	<min+9 @0576d1>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @0576d4>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@0576d5> - <@0576d9>): return float64(.result := b);
	<min+13 @0576d5>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @0576d8>   : 03                         ret
.usages:
	test/std/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0576e0>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0576e0> - <@0576f1>)
	lib/std/math.ci:138: (13 bytes: <@0576e0> - <@0576ed>): if (bool(a > b))
	<max @0576e0>      : 10 02                      dup.x32 sp(2)
	<max+2 @0576e2>    : 10 02                      dup.x32 sp(2)
	<max+4 @0576e4>    : 79                         cgt.f32
	<max+5 @0576e5>    : 06 08 00 00                jz <max+13 @0576ed>
	lib/std/math.ci:139: (4 bytes: <@0576e9> - <@0576ed>): return float32(.result := a);
	<max+9 @0576e9>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @0576ec>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@0576ed> - <@0576f1>): return float32(.result := b);
	<max+13 @0576ed>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @0576f0>   : 03                         ret
.usages:
	test/std/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0576f8>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0576f8> - <@057709>)
	lib/std/math.ci:146: (13 bytes: <@0576f8> - <@057705>): if (bool(a > b))
	<max @0576f8>      : 11 03                      dup.x64 sp(3)
	<max+2 @0576fa>    : 11 03                      dup.x64 sp(3)
	<max+4 @0576fc>    : 89                         cgt.f64
	<max+5 @0576fd>    : 06 08 00 00                jz <max+13 @057705>
	lib/std/math.ci:147: (4 bytes: <@057701> - <@057705>): return float64(.result := a);
	<max+9 @057701>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @057704>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@057705> - <@057709>): return float64(.result := b);
	<max+13 @057705>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @057708>   : 03                         ret
.usages:
	test/std/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@057710>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@057710> - <@05772e>)
	lib/std/math.ci:160: (13 bytes: <@057710> - <@05771d>): if (bool(t < a))
	<clamp @057710>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @057712>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @057714>    : 78                         clt.f32
	<clamp+5 @057715>    : 06 08 00 00                jz <clamp+13 @05771d>
	lib/std/math.ci:161: (4 bytes: <@057719> - <@05771d>): return float32(.result := a);
	<clamp+9 @057719>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @05771c>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@05771d> - <@05772a>): if (bool(t > b))
	<clamp+13 @05771d>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @05771f>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @057721>   : 79                         cgt.f32
	<clamp+18 @057722>   : 06 08 00 00                jz <clamp+26 @05772a>
	lib/std/math.ci:164: (4 bytes: <@057726> - <@05772a>): return float32(.result := b);
	<clamp+22 @057726>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @057729>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@05772a> - <@05772e>): return float32(.result := t);
	<clamp+26 @05772a>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @05772d>   : 03                         ret
.usages:
	test/std/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@057730>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@057730> - <@05774e>)
	lib/std/math.ci:171: (13 bytes: <@057730> - <@05773d>): if (bool(t < a))
	<clamp @057730>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @057732>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @057734>    : 88                         clt.f64
	<clamp+5 @057735>    : 06 08 00 00                jz <clamp+13 @05773d>
	lib/std/math.ci:172: (4 bytes: <@057739> - <@05773d>): return float64(.result := a);
	<clamp+9 @057739>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @05773c>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@05773d> - <@05774a>): if (bool(t > b))
	<clamp+13 @05773d>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @05773f>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @057741>   : 89                         cgt.f64
	<clamp+18 @057742>   : 06 08 00 00                jz <clamp+26 @05774a>
	lib/std/math.ci:175: (4 bytes: <@057746> - <@05774a>): return float64(.result := b);
	<clamp+22 @057746>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @057749>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@05774a> - <@05774e>): return float64(.result := t);
	<clamp+26 @05774a>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @05774d>   : 03                         ret
.usages:
	test/std/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/std/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/std/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/std/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/std/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@057750>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@057750> - <@05779f>)
	lib/std/math.ci:202: (20 bytes: <@057750> - <@057764>): if (bool(data.length == (0)))
	<min @057750>      : 10 02                      dup.x32 sp(2)
	<min+2 @057752>    : 19                         load.z32
	<min+3 @057753>    : 57                         ceq.i32
	<min+4 @057754>    : 06 10 00 00                jz <min+20 @057764>
	lib/std/math.ci:203: (12 bytes: <@057758> - <@057764>): return float64(.result := nan);
	<min+8 @057758>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @057761>   : 14 05                      set.x64 sp(5)
	<min+19 @057763>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@057764> - <@057767>): result: float64 := data[0]
	<min+20 @057764>   : 10 01                      dup.x32 sp(1)
	<min+22 @057766>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@057767> - <@05779c>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+23 @057767>   : 1c 01 00 00 00             load.c32 1
	<min+28 @05776c>   : 04 23 00 00                jmp <min+63 @05778f>
	lib/std/math.ci:207: (27 bytes: <@057770> - <@05778b>): if (bool(result > data[i]))
	<min+32 @057770>   : 11 01                      dup.x64 sp(1)
	<min+34 @057772>   : 10 06                      dup.x32 sp(6)
	<min+36 @057774>   : 10 03                      dup.x32 sp(3)
	<min+38 @057776>   : 0d 08 00 00                mad.u32 8
	<min+42 @05777a>   : 23                         load.i64
	<min+43 @05777b>   : 89                         cgt.f64
	<min+44 @05777c>   : 06 0f 00 00                jz <min+59 @05778b>
	lib/std/math.ci:208: (11 bytes: <@057780> - <@05778b>): float64(result := data[i]);
	<min+48 @057780>   : 10 04                      dup.x32 sp(4)
	<min+50 @057782>   : 10 01                      dup.x32 sp(1)
	<min+52 @057784>   : 0d 08 00 00                mad.u32 8
	<min+56 @057788>   : 23                         load.i64
	<min+57 @057789>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@05778b> - <@05778f>): int32(i := int32(i + 1))
	<min+59 @05778b>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@05778f> - <@057798>): bool(i < (data.length))
	<min+63 @05778f>   : 10 00                      dup.x32 sp(0)
	<min+65 @057791>   : 10 06                      dup.x32 sp(6)
	<min+67 @057793>   : 58                         clt.i32
	<min+68 @057794>   : 05 dc ff ff                jnz <min+32 @057770>
	<min+72 @057798>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@05779c> - <@05779f>): return float64(.result := result);
	<min+76 @05779c>   : 14 05                      set.x64 sp(5)
	<min+78 @05779e>   : 03                         ret
.usages:
	test/std/test.math.ci:39: referenced as `min`
	test/std/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@0577a0>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@0577a0> - <@0577ef>)
	lib/std/math.ci:216: (20 bytes: <@0577a0> - <@0577b4>): if (bool(data.length == (0)))
	<max @0577a0>      : 10 02                      dup.x32 sp(2)
	<max+2 @0577a2>    : 19                         load.z32
	<max+3 @0577a3>    : 57                         ceq.i32
	<max+4 @0577a4>    : 06 10 00 00                jz <max+20 @0577b4>
	lib/std/math.ci:217: (12 bytes: <@0577a8> - <@0577b4>): return float64(.result := nan);
	<max+8 @0577a8>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @0577b1>   : 14 05                      set.x64 sp(5)
	<max+19 @0577b3>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@0577b4> - <@0577b7>): result: float64 := data[0]
	<max+20 @0577b4>   : 10 01                      dup.x32 sp(1)
	<max+22 @0577b6>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@0577b7> - <@0577ec>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+23 @0577b7>   : 1c 01 00 00 00             load.c32 1
	<max+28 @0577bc>   : 04 23 00 00                jmp <max+63 @0577df>
	lib/std/math.ci:221: (27 bytes: <@0577c0> - <@0577db>): if (bool(result < data[i]))
	<max+32 @0577c0>   : 11 01                      dup.x64 sp(1)
	<max+34 @0577c2>   : 10 06                      dup.x32 sp(6)
	<max+36 @0577c4>   : 10 03                      dup.x32 sp(3)
	<max+38 @0577c6>   : 0d 08 00 00                mad.u32 8
	<max+42 @0577ca>   : 23                         load.i64
	<max+43 @0577cb>   : 88                         clt.f64
	<max+44 @0577cc>   : 06 0f 00 00                jz <max+59 @0577db>
	lib/std/math.ci:222: (11 bytes: <@0577d0> - <@0577db>): float64(result := data[i]);
	<max+48 @0577d0>   : 10 04                      dup.x32 sp(4)
	<max+50 @0577d2>   : 10 01                      dup.x32 sp(1)
	<max+52 @0577d4>   : 0d 08 00 00                mad.u32 8
	<max+56 @0577d8>   : 23                         load.i64
	<max+57 @0577d9>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@0577db> - <@0577df>): int32(i := int32(i + 1))
	<max+59 @0577db>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@0577df> - <@0577e8>): bool(i < (data.length))
	<max+63 @0577df>   : 10 00                      dup.x32 sp(0)
	<max+65 @0577e1>   : 10 06                      dup.x32 sp(6)
	<max+67 @0577e3>   : 58                         clt.i32
	<max+68 @0577e4>   : 05 dc ff ff                jnz <max+32 @0577c0>
	<max+72 @0577e8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@0577ec> - <@0577ef>): return float64(.result := result);
	<max+76 @0577ec>   : 14 05                      set.x64 sp(5)
	<max+78 @0577ee>   : 03                         ret
.usages:
	test/std/test.math.ci:41: referenced as `max`
	test/std/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@0577f0>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@0577f0> - <@057818>)
	lib/std/math.ci:230: (1 byte: <@0577f0> - <@0577f1>): result: float64 := 0
	<sum @0577f0>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@0577f1> - <@057815>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @0577f1>    : 6a                         i64.2i32
	<sum+2 @0577f2>    : 04 16 00 00                jmp <sum+24 @057808>
	lib/std/math.ci:232: (14 bytes: <@0577f6> - <@057804>): float64(result := float64(result + data[i]));
	<sum+6 @0577f6>    : 11 01                      dup.x64 sp(1)
	<sum+8 @0577f8>    : 10 06                      dup.x32 sp(6)
	<sum+10 @0577fa>   : 10 03                      dup.x32 sp(3)
	<sum+12 @0577fc>   : 0d 08 00 00                mad.u32 8
	<sum+16 @057800>   : 23                         load.i64
	<sum+17 @057801>   : 81                         add.f64
	<sum+18 @057802>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@057804> - <@057808>): int32(i := int32(i + 1))
	<sum+20 @057804>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@057808> - <@057811>): bool(i < (data.length))
	<sum+24 @057808>   : 10 00                      dup.x32 sp(0)
	<sum+26 @05780a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @05780c>   : 58                         clt.i32
	<sum+29 @05780d>   : 05 e9 ff ff                jnz <sum+6 @0577f6>
	<sum+33 @057811>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@057815> - <@057818>): return float64(.result := result);
	<sum+37 @057815>   : 14 05                      set.x64 sp(5)
	<sum+39 @057817>   : 03                         ret
.usages:
	test/std/test.math.ci:46: referenced as `sum`
	test/std/test.math.ci:45: referenced as `sum`
	test/std/test.math.ci:44: referenced as `sum`
	test/std/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:239: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.mean(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 20
.offset: <@057818>
.name: 'mean'
.file: 'lib/std/math.ci:238'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (data.length)));
}
.instructions: (20 bytes: <@057818> - <@05782c>)
	lib/std/math.ci:239: (20 bytes: <@057818> - <@05782c>): return float64(.result := float64(sum(float64[](...data)) / (data.length)));
	<mean @057818>      : 1a                         load.z64
	<mean+1 @057819>    : 11 03                      dup.x64 sp(3)
	<mean+3 @05781b>    : 1f f0 77 05 00             load.ref <@0577f0> ;Math.sum(data: float64[]): float64
	<mean+8 @057820>    : 02                         call
	<mean+9 @057821>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @057825>   : 10 04                      dup.x32 sp(4)
	<mean+15 @057827>   : 5d                         i32.2f64
	<mean+16 @057828>   : 84                         div.f64
	<mean+17 @057829>   : 14 05                      set.x64 sp(5)
	<mean+19 @05782b>   : 03                         ret
.usages:
	lib/std/math.ci:238: defined as `mean(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/std/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:243: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:246'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/std/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:249: referenced as `eval`
	lib/std/math.ci:246: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:249'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/std/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:252: referenced as `eval`
	lib/std/math.ci:249: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:252'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/std/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:252: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@057830>
.name: 'eval'
.file: 'lib/std/math.ci:255'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@057830> - <@05785f>)
	lib/std/math.ci:256: (1 byte: <@057830> - <@057831>): result: float64 := 0
	<eval @057830>      : 1a                         load.z64
	lib/std/math.ci:257: (43 bytes: <@057831> - <@05785c>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @057831>    : 10 04                      dup.x32 sp(4)
	<eval+3 @057833>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @057837>    : 04 19 00 00                jmp <eval+32 @057850>
	lib/std/math.ci:258: (17 bytes: <@05783b> - <@05784c>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @05783b>   : 11 01                      dup.x64 sp(1)
	<eval+13 @05783d>   : 11 08                      dup.x64 sp(8)
	<eval+15 @05783f>   : 83                         mul.f64
	<eval+16 @057840>   : 10 06                      dup.x32 sp(6)
	<eval+18 @057842>   : 10 03                      dup.x32 sp(3)
	<eval+20 @057844>   : 0d 08 00 00                mad.u32 8
	<eval+24 @057848>   : 23                         load.i64
	<eval+25 @057849>   : 81                         add.f64
	<eval+26 @05784a>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:257: (4 bytes: <@05784c> - <@057850>): int32(i := int32(i - 1))
	<eval+28 @05784c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:257: (8 bytes: <@057850> - <@057858>): bool(i >= 0)
	<eval+32 @057850>   : 10 00                      dup.x32 sp(0)
	<eval+34 @057852>   : 19                         load.z32
	<eval+35 @057853>   : 58                         clt.i32
	<eval+36 @057854>   : 06 e7 ff ff                jz <eval+11 @05783b>
	<eval+40 @057858>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:260: (3 bytes: <@05785c> - <@05785f>): return float64(.result := result);
	<eval+44 @05785c>   : 14 07                      set.x64 sp(7)
	<eval+46 @05785e>   : 03                         ret
.usages:
	test/std/test.math.ci:55: referenced as `eval`
	test/std/test.math.ci:54: referenced as `eval`
	test/std/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:255: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@057860>
.name: 'cmp'
.file: 'lib/std/math.ci:264'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@057860> - <@057899>)
	lib/std/math.ci:265: (53 bytes: <@057860> - <@057895>): if (bool(a < b))
	<cmp @057860>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @057862>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @057864>    : 78                         clt.f32
	<cmp+5 @057865>    : 06 1c 00 00                jz <cmp+33 @057881>
	lib/std/math.ci:266: (20 bytes: <@057869> - <@05787d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @057869>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @05786b>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @05786d>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @05786f>   : 72                         sub.f32
	<cmp+16 @057870>   : 78                         clt.f32
	<cmp+17 @057871>   : 06 0c 00 00                jz <cmp+29 @05787d>
	lib/std/math.ci:267: (8 bytes: <@057875> - <@05787d>): return int32(.result := int32(-1));
	<cmp+21 @057875>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05787a>   : 13 05                      set.x32 sp(5)
	<cmp+28 @05787c>   : 03                         ret
	<cmp+29 @05787d>   : 04 18 00 00                jmp <cmp+53 @057895>
	lib/std/math.ci:271: (20 bytes: <@057881> - <@057895>): if (bool(eps < (float32(a - b))))
	<cmp+33 @057881>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @057883>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @057885>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @057887>   : 72                         sub.f32
	<cmp+40 @057888>   : 78                         clt.f32
	<cmp+41 @057889>   : 06 0c 00 00                jz <cmp+53 @057895>
	lib/std/math.ci:272: (8 bytes: <@05788d> - <@057895>): return int32(.result := int32(+1));
	<cmp+45 @05788d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @057892>   : 13 05                      set.x32 sp(5)
	<cmp+52 @057894>   : 03                         ret
	lib/std/math.ci:275: (4 bytes: <@057895> - <@057899>): return int32(.result := 0);
	<cmp+53 @057895>   : 19                         load.z32
	<cmp+54 @057896>   : 13 05                      set.x32 sp(5)
	<cmp+56 @057898>   : 03                         ret
.usages:
	test/std/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:264: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@0578a0>
.name: 'cmp'
.file: 'lib/std/math.ci:279'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@0578a0> - <@0578d9>)
	lib/std/math.ci:280: (53 bytes: <@0578a0> - <@0578d5>): if (bool(a < b))
	<cmp @0578a0>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @0578a2>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @0578a4>    : 88                         clt.f64
	<cmp+5 @0578a5>    : 06 1c 00 00                jz <cmp+33 @0578c1>
	lib/std/math.ci:281: (20 bytes: <@0578a9> - <@0578bd>): if (bool(eps < (float64(b - a))))
	<cmp+9 @0578a9>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @0578ab>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @0578ad>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @0578af>   : 82                         sub.f64
	<cmp+16 @0578b0>   : 88                         clt.f64
	<cmp+17 @0578b1>   : 06 0c 00 00                jz <cmp+29 @0578bd>
	lib/std/math.ci:282: (8 bytes: <@0578b5> - <@0578bd>): return int32(.result := int32(-1));
	<cmp+21 @0578b5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0578ba>   : 13 08                      set.x32 sp(8)
	<cmp+28 @0578bc>   : 03                         ret
	<cmp+29 @0578bd>   : 04 18 00 00                jmp <cmp+53 @0578d5>
	lib/std/math.ci:286: (20 bytes: <@0578c1> - <@0578d5>): if (bool(eps < (float64(a - b))))
	<cmp+33 @0578c1>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @0578c3>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @0578c5>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @0578c7>   : 82                         sub.f64
	<cmp+40 @0578c8>   : 88                         clt.f64
	<cmp+41 @0578c9>   : 06 0c 00 00                jz <cmp+53 @0578d5>
	lib/std/math.ci:287: (8 bytes: <@0578cd> - <@0578d5>): return int32(.result := int32(+1));
	<cmp+45 @0578cd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @0578d2>   : 13 08                      set.x32 sp(8)
	<cmp+52 @0578d4>   : 03                         ret
	lib/std/math.ci:290: (4 bytes: <@0578d5> - <@0578d9>): return int32(.result := 0);
	<cmp+53 @0578d5>   : 19                         load.z32
	<cmp+54 @0578d6>   : 13 08                      set.x32 sp(8)
	<cmp+56 @0578d8>   : 03                         ret
.usages:
	test/std/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:279: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@0578e0>
.name: 'sinCos'
.file: 'lib/std/math.ci:294'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@0578e0> - <@057a2f>)
	lib/std/math.ci:308: (2 bytes: <@0578e0> - <@0578e2>): x: float64 := arg
	<sinCos @0578e0>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:309: (17 bytes: <@0578e2> - <@0578f3>): if (bool(x < (0)))
	<sinCos+2 @0578e2>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @0578e4>    : 1a                         load.z64
	<sinCos+5 @0578e5>    : 88                         clt.f64
	<sinCos+6 @0578e6>    : 06 0d 00 00                jz <sinCos+19 @0578f3>
	lib/std/math.ci:310: (1 byte: <@0578ea> - <@0578eb>): float64(x := float64(-x));
	<sinCos+10 @0578ea>   : 80                         neg.f64
	lib/std/math.ci:311: (8 bytes: <@0578eb> - <@0578f3>): int32(quad := int32(quad + 2));
	<sinCos+11 @0578eb>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @0578ed>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @0578f1>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:314: (1 byte: <@0578f3> - <@0578f4>): y: float64
	<sinCos+19 @0578f3>   : 1a                         load.z64
	lib/std/math.ci:315: (24 bytes: <@0578f4> - <@05790c>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @0578f4>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @0578f6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @0578ff>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @057908>   : 84                         div.f64
	<sinCos+41 @057909>   : 83                         mul.f64
	<sinCos+42 @05790a>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:316: (124 bytes: <@05790c> - <@057988>): if (bool(x > (32764)))
	<sinCos+44 @05790c>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @05790e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @057917>   : 89                         cgt.f64
	<sinCos+56 @057918>   : 06 54 00 00                jz <sinCos+140 @05796c>
	lib/std/math.ci:317: (1 byte: <@05791c> - <@05791d>): e: float64
	<sinCos+60 @05791c>   : 1b                         load.z128
	lib/std/math.ci:318: (18 bytes: <@05791d> - <@05792f>): float64(y := modf(void(x, float64(&e))));
	<sinCos+61 @05791d>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @05791f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @057923>   : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @057928>   : 02                         call
	<sinCos+73 @057929>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @05792d>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:319: (4 bytes: <@05792f> - <@057933>): float64(e := float64(e + (quad)));
	<sinCos+79 @05792f>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @057931>   : 5d                         i32.2f64
	<sinCos+82 @057932>   : 81                         add.f64
	lib/std/math.ci:321: (1 byte: <@057933> - <@057934>): f: float64
	<sinCos+83 @057933>   : 1b                         load.z128
	lib/std/math.ci:322: (30 bytes: <@057934> - <@057952>): modf(void(float64(0.250000 * e), float64(&f)));
	<sinCos+84 @057934>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @05793d>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @05793f>   : 83                         mul.f64
	<sinCos+96 @057940>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @057944>  : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @057949>  : 02                         call
	<sinCos+106 @05794a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @05794e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:323: (18 bytes: <@057952> - <@057964>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @057952>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @057954>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @05795d>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @05795f>  : 83                         mul.f64
	<sinCos+128 @057960>  : 82                         sub.f64
	<sinCos+129 @057961>  : 8a                         f64.2i32
	<sinCos+130 @057962>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @057964>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @057968>  : 04 20 00 00                jmp <sinCos+168 @057988>
	lib/std/math.ci:326: (3 bytes: <@05796c> - <@05796f>): k: int32 := x
	<sinCos+140 @05796c>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @05796e>  : 8a                         f64.2i32
	lib/std/math.ci:327: (8 bytes: <@05796f> - <@057977>): float64(y := float64(x - (k)));
	<sinCos+143 @05796f>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @057971>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @057973>  : 5d                         i32.2f64
	<sinCos+148 @057974>  : 82                         sub.f64
	<sinCos+149 @057975>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:328: (7 bytes: <@057977> - <@05797e>): int32(quad := int32(quad + k));
	<sinCos+151 @057977>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @057979>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @05797b>  : 51                         add.i32
	<sinCos+156 @05797c>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:329: (6 bytes: <@05797e> - <@057984>): int32(quad := int32(quad & 3));
	<sinCos+158 @05797e>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @057980>  : 3f 02                      b32.and 0x003
	<sinCos+162 @057982>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @057984>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:331: (22 bytes: <@057988> - <@05799e>): if (int32(quad & 1))
	<sinCos+168 @057988>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @05798a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @05798c>  : 06 12 00 00                jz <sinCos+190 @05799e>
	lib/std/math.ci:332: (14 bytes: <@057990> - <@05799e>): float64(y := float64((1) - y));
	<sinCos+176 @057990>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @057999>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @05799b>  : 82                         sub.f64
	<sinCos+188 @05799c>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:334: (13 bytes: <@05799e> - <@0579ab>): if (bool(quad > 1))
	<sinCos+190 @05799e>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @0579a0>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @0579a5>  : 59                         cgt.i32
	<sinCos+198 @0579a6>  : 06 05 00 00                jz <sinCos+203 @0579ab>
	lib/std/math.ci:335: (1 byte: <@0579aa> - <@0579ab>): float64(y := float64(-y));
	<sinCos+202 @0579aa>  : 80                         neg.f64
	lib/std/math.ci:338: (5 bytes: <@0579ab> - <@0579b0>): ysq: float64 := float64(y * y)
	<sinCos+203 @0579ab>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @0579ad>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @0579af>  : 83                         mul.f64
	lib/std/math.ci:339: (64 bytes: <@0579b0> - <@0579f0>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @0579b0>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @0579b9>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @0579bb>  : 83                         mul.f64
	<sinCos+220 @0579bc>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @0579c5>  : 81                         add.f64
	<sinCos+230 @0579c6>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @0579c8>  : 83                         mul.f64
	<sinCos+233 @0579c9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @0579d2>  : 81                         add.f64
	<sinCos+243 @0579d3>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @0579d5>  : 83                         mul.f64
	<sinCos+246 @0579d6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @0579df>  : 81                         add.f64
	<sinCos+256 @0579e0>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @0579e2>  : 83                         mul.f64
	<sinCos+259 @0579e3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @0579ec>  : 81                         add.f64
	<sinCos+269 @0579ed>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @0579ef>  : 83                         mul.f64
	lib/std/math.ci:340: (51 bytes: <@0579f0> - <@057a23>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @0579f0>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @0579f2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @0579fb>  : 81                         add.f64
	<sinCos+284 @0579fc>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @0579fe>  : 83                         mul.f64
	<sinCos+287 @0579ff>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @057a08>  : 81                         add.f64
	<sinCos+297 @057a09>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @057a0b>  : 83                         mul.f64
	<sinCos+300 @057a0c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @057a15>  : 81                         add.f64
	<sinCos+310 @057a16>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @057a18>  : 83                         mul.f64
	<sinCos+313 @057a19>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @057a22>  : 81                         add.f64
	lib/std/math.ci:341: (12 bytes: <@057a23> - <@057a2f>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @057a23>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @057a25>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @057a27>  : 84                         div.f64
	<sinCos+328 @057a28>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @057a2a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @057a2e>  : 03                         ret
.usages:
	lib/std/math.ci:348: referenced as `sinCos`
	lib/std/math.ci:345: referenced as `sinCos`
	lib/std/math.ci:294: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:345'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/std/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:345: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:348'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/std/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:348: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@057a30>
.name: 'tan'
.file: 'lib/std/math.ci:351'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@057a30> - <@057baa>)
	lib/std/math.ci:364: (1 byte: <@057a30> - <@057a31>): complement: bool := false
	<tan @057a30>      : 19                         load.z32
	lib/std/math.ci:365: (1 byte: <@057a31> - <@057a32>): negate: bool := false
	<tan+1 @057a31>    : 19                         load.z32
	lib/std/math.ci:367: (23 bytes: <@057a32> - <@057a49>): if (bool(arg < (0)))
	<tan+2 @057a32>    : 11 03                      dup.x64 sp(3)
	<tan+4 @057a34>    : 1a                         load.z64
	<tan+5 @057a35>    : 88                         clt.f64
	<tan+6 @057a36>    : 06 13 00 00                jz <tan+25 @057a49>
	lib/std/math.ci:368: (5 bytes: <@057a3a> - <@057a3f>): float64(arg := float64(-arg));
	<tan+10 @057a3a>   : 11 03                      dup.x64 sp(3)
	<tan+12 @057a3c>   : 80                         neg.f64
	<tan+13 @057a3d>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:369: (10 bytes: <@057a3f> - <@057a49>): bool(negate := true);
	<tan+15 @057a3f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @057a44>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @057a48>   : 25                         store.i8
	lib/std/math.ci:371: (24 bytes: <@057a49> - <@057a61>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @057a49>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @057a52>   : 11 05                      dup.x64 sp(5)
	<tan+36 @057a54>   : 83                         mul.f64
	<tan+37 @057a55>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @057a5e>   : 84                         div.f64
	<tan+47 @057a5f>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:373: (1 byte: <@057a61> - <@057a62>): e: float64
	<tan+49 @057a61>   : 1b                         load.z128
	lib/std/math.ci:374: (16 bytes: <@057a62> - <@057a72>): x: float64 := modf(void(arg, float64(&e)))
	<tan+50 @057a62>   : 11 07                      dup.x64 sp(7)
	<tan+52 @057a64>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @057a68>   : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @057a6d>   : 02                         call
	<tan+62 @057a6e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:375: (9 bytes: <@057a72> - <@057a7b>): i: int32 := int32(int32(e) % 4)
	<tan+66 @057a72>   : 11 02                      dup.x64 sp(2)
	<tan+68 @057a74>   : 8a                         f64.2i32
	<tan+69 @057a75>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @057a7a>   : 55                         mod.i32
	lib/std/math.ci:377: (122 bytes: <@057a7b> - <@057af5>): if (bool(i == 0))
	<tan+75 @057a7b>   : 10 00                      dup.x32 sp(0)
	<tan+77 @057a7d>   : 19                         load.z32
	<tan+78 @057a7e>   : 57                         ceq.i32
	<tan+79 @057a7f>   : 05 76 00 00                jnz <tan+197 @057af5>
	lib/std/math.ci:378: (114 bytes: <@057a83> - <@057af5>): if (bool(i == 1))
	<tan+83 @057a83>   : 10 00                      dup.x32 sp(0)
	<tan+85 @057a85>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @057a8a>   : 57                         ceq.i32
	<tan+91 @057a8b>   : 06 20 00 00                jz <tan+123 @057aab>
	lib/std/math.ci:379: (14 bytes: <@057a8f> - <@057a9d>): float64(x := float64((1) - x));
	<tan+95 @057a8f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @057a98>  : 11 03                      dup.x64 sp(3)
	<tan+106 @057a9a>  : 82                         sub.f64
	<tan+107 @057a9b>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:380: (10 bytes: <@057a9d> - <@057aa7>): bool(complement := true);
	<tan+109 @057a9d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @057aa2>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @057aa6>  : 25                         store.i8
	<tan+119 @057aa7>  : 04 4e 00 00                jmp <tan+197 @057af5>
	lib/std/math.ci:382: (74 bytes: <@057aab> - <@057af5>): if (bool(i == 2))
	<tan+123 @057aab>  : 10 00                      dup.x32 sp(0)
	<tan+125 @057aad>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @057ab2>  : 57                         ceq.i32
	<tan+131 @057ab3>  : 06 1d 00 00                jz <tan+160 @057ad0>
	lib/std/math.ci:383: (11 bytes: <@057ab7> - <@057ac2>): bool(negate := bool(!negate));
	<tan+135 @057ab7>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @057abb>  : 20                         load.i8
	<tan+140 @057abc>  : 0b                         not.b32
	<tan+141 @057abd>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @057ac1>  : 25                         store.i8
	lib/std/math.ci:384: (10 bytes: <@057ac2> - <@057acc>): bool(complement := true);
	<tan+146 @057ac2>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @057ac7>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @057acb>  : 25                         store.i8
	<tan+156 @057acc>  : 04 29 00 00                jmp <tan+197 @057af5>
	lib/std/math.ci:386: (37 bytes: <@057ad0> - <@057af5>): if (bool(i == 3))
	<tan+160 @057ad0>  : 10 00                      dup.x32 sp(0)
	<tan+162 @057ad2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @057ad7>  : 57                         ceq.i32
	<tan+168 @057ad8>  : 06 1d 00 00                jz <tan+197 @057af5>
	lib/std/math.ci:387: (14 bytes: <@057adc> - <@057aea>): float64(x := float64((1) - x));
	<tan+172 @057adc>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @057ae5>  : 11 03                      dup.x64 sp(3)
	<tan+183 @057ae7>  : 82                         sub.f64
	<tan+184 @057ae8>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:388: (11 bytes: <@057aea> - <@057af5>): bool(negate := bool(!negate));
	<tan+186 @057aea>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @057aee>  : 20                         load.i8
	<tan+191 @057aef>  : 0b                         not.b32
	<tan+192 @057af0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @057af4>  : 25                         store.i8
	lib/std/math.ci:391: (5 bytes: <@057af5> - <@057afa>): xsq: float64 := float64(x * x)
	<tan+197 @057af5>  : 11 01                      dup.x64 sp(1)
	<tan+199 @057af7>  : 11 03                      dup.x64 sp(3)
	<tan+201 @057af9>  : 83                         mul.f64
	lib/std/math.ci:392: (64 bytes: <@057afa> - <@057b3a>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @057afa>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @057b03>  : 11 02                      dup.x64 sp(2)
	<tan+213 @057b05>  : 83                         mul.f64
	<tan+214 @057b06>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @057b0f>  : 81                         add.f64
	<tan+224 @057b10>  : 11 02                      dup.x64 sp(2)
	<tan+226 @057b12>  : 83                         mul.f64
	<tan+227 @057b13>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @057b1c>  : 81                         add.f64
	<tan+237 @057b1d>  : 11 02                      dup.x64 sp(2)
	<tan+239 @057b1f>  : 83                         mul.f64
	<tan+240 @057b20>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @057b29>  : 81                         add.f64
	<tan+250 @057b2a>  : 11 02                      dup.x64 sp(2)
	<tan+252 @057b2c>  : 83                         mul.f64
	<tan+253 @057b2d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @057b36>  : 81                         add.f64
	<tan+263 @057b37>  : 11 05                      dup.x64 sp(5)
	<tan+265 @057b39>  : 83                         mul.f64
	lib/std/math.ci:393: (39 bytes: <@057b3a> - <@057b61>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @057b3a>  : 11 02                      dup.x64 sp(2)
	<tan+268 @057b3c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @057b45>  : 81                         add.f64
	<tan+278 @057b46>  : 11 04                      dup.x64 sp(4)
	<tan+280 @057b48>  : 83                         mul.f64
	<tan+281 @057b49>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @057b52>  : 81                         add.f64
	<tan+291 @057b53>  : 11 04                      dup.x64 sp(4)
	<tan+293 @057b55>  : 83                         mul.f64
	<tan+294 @057b56>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @057b5f>  : 81                         add.f64
	<tan+304 @057b60>  : 84                         div.f64
	lib/std/math.ci:395: (47 bytes: <@057b61> - <@057b90>): if (complement)
	<tan+305 @057b61>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @057b65>  : 20                         load.i8
	<tan+310 @057b66>  : 06 2a 00 00                jz <tan+352 @057b90>
	lib/std/math.ci:396: (24 bytes: <@057b6a> - <@057b82>): if (bool(result == (0)))
	<tan+314 @057b6a>  : 11 00                      dup.x64 sp(0)
	<tan+316 @057b6c>  : 1a                         load.z64
	<tan+317 @057b6d>  : 87                         ceq.f64
	<tan+318 @057b6e>  : 06 14 00 00                jz <tan+338 @057b82>
	lib/std/math.ci:397: (16 bytes: <@057b72> - <@057b82>): return float64(.result := nan);
	<tan+322 @057b72>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @057b7b>  : 14 10                      set.x64 sp(16)
	<tan+333 @057b7d>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @057b81>  : 03                         ret
	lib/std/math.ci:399: (14 bytes: <@057b82> - <@057b90>): float64(result := float64((1) / result));
	<tan+338 @057b82>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @057b8b>  : 11 02                      dup.x64 sp(2)
	<tan+349 @057b8d>  : 84                         div.f64
	<tan+350 @057b8e>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:401: (19 bytes: <@057b90> - <@057ba3>): if (negate)
	<tan+352 @057b90>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @057b94>  : 20                         load.i8
	<tan+357 @057b95>  : 06 0e 00 00                jz <tan+371 @057ba3>
	lib/std/math.ci:402: (10 bytes: <@057b99> - <@057ba3>): return float64(.result := float64(-result));
	<tan+361 @057b99>  : 11 00                      dup.x64 sp(0)
	<tan+363 @057b9b>  : 80                         neg.f64
	<tan+364 @057b9c>  : 14 10                      set.x64 sp(16)
	<tan+366 @057b9e>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @057ba2>  : 03                         ret
	lib/std/math.ci:404: (7 bytes: <@057ba3> - <@057baa>): return float64(.result := result);
	<tan+371 @057ba3>  : 14 0e                      set.x64 sp(14)
	<tan+373 @057ba5>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @057ba9>  : 03                         ret
.usages:
	test/std/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:351: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@057bb0>
.name: 'sinh'
.file: 'lib/std/math.ci:408'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@057bb0> - <@057ca1>)
	lib/std/math.ci:420: (1 byte: <@057bb0> - <@057bb1>): negate: bool := false
	<sinh @057bb0>      : 19                         load.z32
	lib/std/math.ci:421: (23 bytes: <@057bb1> - <@057bc8>): if (bool(x < (0)))
	<sinh+1 @057bb1>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @057bb3>    : 1a                         load.z64
	<sinh+4 @057bb4>    : 88                         clt.f64
	<sinh+5 @057bb5>    : 06 13 00 00                jz <sinh+24 @057bc8>
	lib/std/math.ci:422: (5 bytes: <@057bb9> - <@057bbe>): float64(x := float64(-x));
	<sinh+9 @057bb9>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @057bbb>   : 80                         neg.f64
	<sinh+12 @057bbc>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:423: (10 bytes: <@057bbe> - <@057bc8>): bool(negate := true);
	<sinh+14 @057bbe>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @057bc3>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @057bc7>   : 25                         store.i8
	lib/std/math.ci:426: (39 bytes: <@057bc8> - <@057bef>): if (bool(x > (21)))
	<sinh+24 @057bc8>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @057bca>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @057bd3>   : 89                         cgt.f64
	<sinh+36 @057bd4>   : 06 1b 00 00                jz <sinh+63 @057bef>
	lib/std/math.ci:427: (23 bytes: <@057bd8> - <@057bef>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @057bd8>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @057bda>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+46 @057bde>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @057be7>   : 84                         div.f64
	<sinh+56 @057be8>   : 14 06                      set.x64 sp(6)
	<sinh+58 @057bea>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @057bee>   : 03                         ret
	lib/std/math.ci:430: (1 byte: <@057bef> - <@057bf0>): result: float64
	<sinh+63 @057bef>   : 1a                         load.z64
	lib/std/math.ci:431: (151 bytes: <@057bf0> - <@057c87>): if (bool(x > 0.500000))
	<sinh+64 @057bf0>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @057bf2>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @057bfb>   : 89                         cgt.f64
	<sinh+76 @057bfc>   : 06 22 00 00                jz <sinh+110 @057c1e>
	lib/std/math.ci:432: (26 bytes: <@057c00> - <@057c1a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @057c00>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @057c02>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+86 @057c06>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @057c08>   : 80                         neg.f64
	<sinh+89 @057c09>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<sinh+93 @057c0d>   : 82                         sub.f64
	<sinh+94 @057c0e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @057c17>  : 84                         div.f64
	<sinh+104 @057c18>  : 14 02                      set.x64 sp(2)
	<sinh+106 @057c1a>  : 04 6d 00 00                jmp <sinh+215 @057c87>
	lib/std/math.ci:435: (5 bytes: <@057c1e> - <@057c23>): sq: float64 := float64(x * x)
	<sinh+110 @057c1e>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @057c20>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @057c22>  : 83                         mul.f64
	lib/std/math.ci:436: (53 bytes: <@057c23> - <@057c58>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @057c23>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @057c2c>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @057c2e>  : 83                         mul.f64
	<sinh+127 @057c2f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @057c38>  : 81                         add.f64
	<sinh+137 @057c39>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @057c3b>  : 83                         mul.f64
	<sinh+140 @057c3c>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @057c45>  : 81                         add.f64
	<sinh+150 @057c46>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @057c48>  : 83                         mul.f64
	<sinh+153 @057c49>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @057c52>  : 81                         add.f64
	<sinh+163 @057c53>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @057c55>  : 83                         mul.f64
	<sinh+166 @057c56>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:437: (43 bytes: <@057c58> - <@057c83>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @057c58>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @057c5a>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @057c5c>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @057c65>  : 81                         add.f64
	<sinh+182 @057c66>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @057c68>  : 83                         mul.f64
	<sinh+185 @057c69>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @057c72>  : 81                         add.f64
	<sinh+195 @057c73>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @057c75>  : 83                         mul.f64
	<sinh+198 @057c76>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @057c7f>  : 81                         add.f64
	<sinh+208 @057c80>  : 84                         div.f64
	<sinh+209 @057c81>  : 14 04                      set.x64 sp(4)
	<sinh+211 @057c83>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:440: (19 bytes: <@057c87> - <@057c9a>): if (negate)
	<sinh+215 @057c87>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @057c8b>  : 20                         load.i8
	<sinh+220 @057c8c>  : 06 0e 00 00                jz <sinh+234 @057c9a>
	lib/std/math.ci:441: (10 bytes: <@057c90> - <@057c9a>): return float64(.result := float64(-result));
	<sinh+224 @057c90>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @057c92>  : 80                         neg.f64
	<sinh+227 @057c93>  : 14 08                      set.x64 sp(8)
	<sinh+229 @057c95>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @057c99>  : 03                         ret
	lib/std/math.ci:443: (7 bytes: <@057c9a> - <@057ca1>): return float64(.result := result);
	<sinh+234 @057c9a>  : 14 06                      set.x64 sp(6)
	<sinh+236 @057c9c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @057ca0>  : 03                         ret
.usages:
	test/std/test.math.ci:60: referenced as `sinh`
	lib/std/math/Complex.ci:151: referenced as `sinh`
	lib/std/math/Complex.ci:149: referenced as `sinh`
	lib/std/math.ci:408: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@057ca8>
.name: 'cosh'
.file: 'lib/std/math.ci:447'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@057ca8> - <@057cf3>)
	lib/std/math.ci:448: (13 bytes: <@057ca8> - <@057cb5>): if (bool(x < (0)))
	<cosh @057ca8>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @057caa>    : 1a                         load.z64
	<cosh+3 @057cab>    : 88                         clt.f64
	<cosh+4 @057cac>    : 06 09 00 00                jz <cosh+13 @057cb5>
	lib/std/math.ci:449: (5 bytes: <@057cb0> - <@057cb5>): float64(x := float64(-x));
	<cosh+8 @057cb0>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @057cb2>   : 80                         neg.f64
	<cosh+11 @057cb3>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:451: (35 bytes: <@057cb5> - <@057cd8>): if (bool(x > (21)))
	<cosh+13 @057cb5>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @057cb7>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @057cc0>   : 89                         cgt.f64
	<cosh+25 @057cc1>   : 06 17 00 00                jz <cosh+48 @057cd8>
	lib/std/math.ci:452: (19 bytes: <@057cc5> - <@057cd8>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @057cc5>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @057cc7>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+35 @057ccb>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @057cd4>   : 84                         div.f64
	<cosh+45 @057cd5>   : 14 05                      set.x64 sp(5)
	<cosh+47 @057cd7>   : 03                         ret
	lib/std/math.ci:454: (27 bytes: <@057cd8> - <@057cf3>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @057cd8>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @057cda>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+54 @057cde>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @057ce0>   : 80                         neg.f64
	<cosh+57 @057ce1>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<cosh+61 @057ce5>   : 81                         add.f64
	<cosh+62 @057ce6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @057cef>   : 84                         div.f64
	<cosh+72 @057cf0>   : 14 05                      set.x64 sp(5)
	<cosh+74 @057cf2>   : 03                         ret
.usages:
	test/std/test.math.ci:61: referenced as `cosh`
	lib/std/math/Complex.ci:151: referenced as `cosh`
	lib/std/math/Complex.ci:149: referenced as `cosh`
	lib/std/math.ci:447: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.offset: <@057cf8>
.name: 'asin'
.file: 'lib/std/math.ci:462'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <@057cf8> - <@057da5>)
	lib/std/math.ci:463: (12 bytes: <@057cf8> - <@057d04>): if (bool(x == (0)))
	<asin @057cf8>      : 11 01                      dup.x64 sp(1)
	<asin+2 @057cfa>    : 1a                         load.z64
	<asin+3 @057cfb>    : 87                         ceq.f64
	<asin+4 @057cfc>    : 06 08 00 00                jz <asin+12 @057d04>
	lib/std/math.ci:465: (4 bytes: <@057d00> - <@057d04>): return float64(.result := x);
	<asin+8 @057d00>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @057d03>   : 03                         ret
	lib/std/math.ci:468: (1 byte: <@057d04> - <@057d05>): negate: bool := false
	<asin+12 @057d04>   : 19                         load.z32
	lib/std/math.ci:469: (23 bytes: <@057d05> - <@057d1c>): if (bool(x < (0)))
	<asin+13 @057d05>   : 11 02                      dup.x64 sp(2)
	<asin+15 @057d07>   : 1a                         load.z64
	<asin+16 @057d08>   : 88                         clt.f64
	<asin+17 @057d09>   : 06 13 00 00                jz <asin+36 @057d1c>
	lib/std/math.ci:470: (10 bytes: <@057d0d> - <@057d17>): bool(negate := true);
	<asin+21 @057d0d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @057d12>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @057d16>   : 25                         store.i8
	lib/std/math.ci:471: (5 bytes: <@057d17> - <@057d1c>): float64(x := float64(-x));
	<asin+31 @057d17>   : 11 02                      dup.x64 sp(2)
	<asin+33 @057d19>   : 80                         neg.f64
	<asin+34 @057d1a>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:474: (32 bytes: <@057d1c> - <@057d3c>): if (bool(x > (1)))
	<asin+36 @057d1c>   : 11 02                      dup.x64 sp(2)
	<asin+38 @057d1e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @057d27>   : 89                         cgt.f64
	<asin+48 @057d28>   : 06 14 00 00                jz <asin+68 @057d3c>
	lib/std/math.ci:476: (16 bytes: <@057d2c> - <@057d3c>): return float64(.result := nan);
	<asin+52 @057d2c>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @057d35>   : 14 06                      set.x64 sp(6)
	<asin+63 @057d37>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @057d3b>   : 03                         ret
	lib/std/math.ci:479: (19 bytes: <@057d3c> - <@057d4f>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+68 @057d3c>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @057d45>   : 11 04                      dup.x64 sp(4)
	<asin+79 @057d47>   : 11 06                      dup.x64 sp(6)
	<asin+81 @057d49>   : 83                         mul.f64
	<asin+82 @057d4a>   : 82                         sub.f64
	<asin+83 @057d4b>   : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:480: (60 bytes: <@057d4f> - <@057d8b>): if (bool(x > 0.700000))
	<asin+87 @057d4f>   : 11 04                      dup.x64 sp(4)
	<asin+89 @057d51>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @057d5a>   : 89                         cgt.f64
	<asin+99 @057d5b>   : 06 26 00 00                jz <asin+137 @057d81>
	lib/std/math.ci:481: (30 bytes: <@057d5f> - <@057d7d>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+103 @057d5f>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @057d68>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @057d71>  : 84                         div.f64
	<asin+122 @057d72>  : 11 02                      dup.x64 sp(2)
	<asin+124 @057d74>  : 11 08                      dup.x64 sp(8)
	<asin+126 @057d76>  : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @057d7a>  : 82                         sub.f64
	<asin+131 @057d7b>  : 14 02                      set.x64 sp(2)
	<asin+133 @057d7d>  : 04 0e 00 00                jmp <asin+147 @057d8b>
	lib/std/math.ci:484: (10 bytes: <@057d81> - <@057d8b>): float64(result := float64.atan2(void(x, result)));
	<asin+137 @057d81>  : 11 04                      dup.x64 sp(4)
	<asin+139 @057d83>  : 11 02                      dup.x64 sp(2)
	<asin+141 @057d85>  : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @057d89>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:487: (19 bytes: <@057d8b> - <@057d9e>): if (negate)
	<asin+147 @057d8b>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @057d8f>  : 20                         load.i8
	<asin+152 @057d90>  : 06 0e 00 00                jz <asin+166 @057d9e>
	lib/std/math.ci:488: (10 bytes: <@057d94> - <@057d9e>): return float64(.result := float64(-result));
	<asin+156 @057d94>  : 11 00                      dup.x64 sp(0)
	<asin+158 @057d96>  : 80                         neg.f64
	<asin+159 @057d97>  : 14 08                      set.x64 sp(8)
	<asin+161 @057d99>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @057d9d>  : 03                         ret
	lib/std/math.ci:490: (7 bytes: <@057d9e> - <@057da5>): return float64(.result := result);
	<asin+166 @057d9e>  : 14 06                      set.x64 sp(6)
	<asin+168 @057da0>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @057da4>  : 03                         ret
.usages:
	test/std/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:497: referenced as `asin`
	lib/std/math.ci:462: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:497'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/std/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:497: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:521'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:521: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:524'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:524: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01aab8>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math/Complex.ci:189: referenced as `Complex`
	lib/std/math/Complex.ci:187: referenced as `Complex`
	lib/std/math/Complex.ci:184: referenced as `Complex`
	lib/std/math/Complex.ci:182: referenced as `Complex`
	lib/std/math/Complex.ci:180: referenced as `Complex`
	lib/std/math/Complex.ci:178: referenced as `Complex`
	lib/std/math/Complex.ci:175: referenced as `Complex`
	lib/std/math/Complex.ci:173: referenced as `Complex`
	lib/std/math/Complex.ci:171: referenced as `Complex`
	lib/std/math/Complex.ci:169: referenced as `Complex`
	lib/std/math/Complex.ci:166: referenced as `Complex`
	lib/std/math/Complex.ci:164: referenced as `Complex`
	lib/std/math/Complex.ci:151: referenced as `Complex`
	lib/std/math/Complex.ci:149: referenced as `Complex`
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:135: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:117: referenced as `Complex`
	lib/std/math/Complex.ci:117: referenced as `Complex`
	lib/std/math/Complex.ci:114: referenced as `Complex`
	lib/std/math/Complex.ci:112: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:107: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:86: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:81: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:76: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:69: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:62: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:59: referenced as `Complex`
	lib/std/math/Complex.ci:31: referenced as `Complex`
	lib/std/math/Complex.ci:24: referenced as `Complex`
	lib/std/math/Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math/Complex.ci:187: referenced as `re`
	lib/std/math/Complex.ci:187: referenced as `re`
	lib/std/math/Complex.ci:151: referenced as `re`
	lib/std/math/Complex.ci:151: referenced as `re`
	lib/std/math/Complex.ci:149: referenced as `re`
	lib/std/math/Complex.ci:149: referenced as `re`
	lib/std/math/Complex.ci:141: referenced as `re`
	lib/std/math/Complex.ci:139: referenced as `re`
	lib/std/math/Complex.ci:138: referenced as `re`
	lib/std/math/Complex.ci:129: referenced as `re`
	lib/std/math/Complex.ci:129: referenced as `re`
	lib/std/math/Complex.ci:126: referenced as `re`
	lib/std/math/Complex.ci:120: referenced as `re`
	lib/std/math/Complex.ci:120: referenced as `re`
	lib/std/math/Complex.ci:118: referenced as `re`
	lib/std/math/Complex.ci:118: referenced as `re`
	lib/std/math/Complex.ci:114: referenced as `re`
	lib/std/math/Complex.ci:112: referenced as `re`
	lib/std/math/Complex.ci:112: referenced as `re`
	lib/std/math/Complex.ci:101: referenced as `re`
	lib/std/math/Complex.ci:102: referenced as `re`
	lib/std/math/Complex.ci:101: referenced as `re`
	lib/std/math/Complex.ci:99: referenced as `re`
	lib/std/math/Complex.ci:98: referenced as `re`
	lib/std/math/Complex.ci:94: referenced as `re`
	lib/std/math/Complex.ci:95: referenced as `re`
	lib/std/math/Complex.ci:94: referenced as `re`
	lib/std/math/Complex.ci:92: referenced as `re`
	lib/std/math/Complex.ci:91: referenced as `re`
	lib/std/math/Complex.ci:90: referenced as `re`
	lib/std/math/Complex.ci:83: referenced as `re`
	lib/std/math/Complex.ci:81: referenced as `re`
	lib/std/math/Complex.ci:73: referenced as `re`
	lib/std/math/Complex.ci:71: referenced as `re`
	lib/std/math/Complex.ci:66: referenced as `re`
	lib/std/math/Complex.ci:64: referenced as `re`
	lib/std/math/Complex.ci:33: referenced as `re`
	lib/std/math/Complex.ci:26: referenced as `re`
	lib/std/math/Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math/Complex.ci:187: referenced as `im`
	lib/std/math/Complex.ci:187: referenced as `im`
	lib/std/math/Complex.ci:151: referenced as `im`
	lib/std/math/Complex.ci:151: referenced as `im`
	lib/std/math/Complex.ci:149: referenced as `im`
	lib/std/math/Complex.ci:149: referenced as `im`
	lib/std/math/Complex.ci:142: referenced as `im`
	lib/std/math/Complex.ci:139: referenced as `im`
	lib/std/math/Complex.ci:138: referenced as `im`
	lib/std/math/Complex.ci:129: referenced as `im`
	lib/std/math/Complex.ci:129: referenced as `im`
	lib/std/math/Complex.ci:126: referenced as `im`
	lib/std/math/Complex.ci:121: referenced as `im`
	lib/std/math/Complex.ci:121: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:118: referenced as `im`
	lib/std/math/Complex.ci:114: referenced as `im`
	lib/std/math/Complex.ci:112: referenced as `im`
	lib/std/math/Complex.ci:112: referenced as `im`
	lib/std/math/Complex.ci:102: referenced as `im`
	lib/std/math/Complex.ci:102: referenced as `im`
	lib/std/math/Complex.ci:101: referenced as `im`
	lib/std/math/Complex.ci:99: referenced as `im`
	lib/std/math/Complex.ci:98: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:95: referenced as `im`
	lib/std/math/Complex.ci:94: referenced as `im`
	lib/std/math/Complex.ci:92: referenced as `im`
	lib/std/math/Complex.ci:91: referenced as `im`
	lib/std/math/Complex.ci:90: referenced as `im`
	lib/std/math/Complex.ci:83: referenced as `im`
	lib/std/math/Complex.ci:81: referenced as `im`
	lib/std/math/Complex.ci:73: referenced as `im`
	lib/std/math/Complex.ci:71: referenced as `im`
	lib/std/math/Complex.ci:66: referenced as `im`
	lib/std/math/Complex.ci:64: referenced as `im`
	lib/std/math/Complex.ci:34: referenced as `im`
	lib/std/math/Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@057da8>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@057da8> - <@057daf>)
	lib/std/math/Complex.ci:25: (7 bytes: <@057da8> - <@057daf>): return void(.result := {...});
	<Complex @057da8>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@057dab> - <@057dae>): void(.result.im := (0))
	<Complex+3 @057dab>    : 1a                         load.z64
	<Complex+4 @057dac>    : 14 07                      set.x64 sp(7)
	<Complex+6 @057dae>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:146: referenced as `Complex`
	lib/std/math/Complex.ci:109: referenced as `Complex`
	lib/std/math/Complex.ci:107: referenced as `Complex`
	lib/std/math/Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@057db0>
.name: 'Complex'
.file: 'lib/std/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@057db0> - <@057db7>)
	lib/std/math/Complex.ci:32: (7 bytes: <@057db0> - <@057db7>): return void(.result := {...});
	<Complex @057db0>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Complex.ci:34: (3 bytes: <@057db3> - <@057db6>): void(.result.im := im);
	<Complex+3 @057db3>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @057db6>    : 03                         ret
.usages:
	lib/std/math/Complex.ci:189: referenced as `Complex`
	lib/std/math/Complex.ci:187: referenced as `Complex`
	lib/std/math/Complex.ci:151: referenced as `Complex`
	lib/std/math/Complex.ci:149: referenced as `Complex`
	lib/std/math/Complex.ci:132: referenced as `Complex`
	lib/std/math/Complex.ci:129: referenced as `Complex`
	lib/std/math/Complex.ci:126: referenced as `Complex`
	lib/std/math/Complex.ci:83: referenced as `Complex`
	lib/std/math/Complex.ci:81: referenced as `Complex`
	lib/std/math/Complex.ci:73: referenced as `Complex`
	lib/std/math/Complex.ci:71: referenced as `Complex`
	lib/std/math/Complex.ci:66: referenced as `Complex`
	lib/std/math/Complex.ci:64: referenced as `Complex`
	lib/std/math/Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	lib/std/math/Vector4f.ci:71: referenced as `neg`
	lib/std/math/Complex.ci:171: referenced as `neg`
	lib/std/math/Complex.ci:169: referenced as `neg`
	lib/std/math/Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	lib/std/math/Complex.ci:171: referenced as `add`
	lib/std/math/Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math/Complex.ci:175: referenced as `add`
	lib/std/math/Complex.ci:173: referenced as `add`
	lib/std/math/Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math/Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/std/math/Complex.ci:169: referenced as `sub`
	lib/std/math/Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math/Complex.ci:175: referenced as `sub`
	lib/std/math/Complex.ci:173: referenced as `sub`
	lib/std/math/Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math/Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
	lib/std/math/Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math/Complex.ci:81: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math/Complex.ci:175: referenced as `mul`
	lib/std/math/Complex.ci:175: referenced as `mul`
	lib/std/math/Complex.ci:173: referenced as `mul`
	lib/std/math/Complex.ci:173: referenced as `mul`
	lib/std/math/Complex.ci:83: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@057db8>
.name: 'div'
.file: 'lib/std/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@057db8> - <@057e33>)
	lib/std/math/Complex.ci:90: (79 bytes: <@057db8> - <@057e07>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @057db8>      : 1a                         load.z64
	<div+1 @057db9>    : 11 03                      dup.x64 sp(3)
	<div+3 @057dbb>    : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<div+8 @057dc0>    : 02                         call
	<div+9 @057dc1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @057dc5>   : 1a                         load.z64
	<div+14 @057dc6>   : 11 07                      dup.x64 sp(7)
	<div+16 @057dc8>   : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<div+21 @057dcd>   : 02                         call
	<div+22 @057dce>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @057dd2>   : 88                         clt.f64
	<div+27 @057dd3>   : 05 34 00 00                jnz <div+79 @057e07>
	lib/std/math/Complex.ci:91: (5 bytes: <@057dd7> - <@057ddc>): r: float64 := float64(b.im / b.re)
	<div+31 @057dd7>   : 11 03                      dup.x64 sp(3)
	<div+33 @057dd9>   : 11 03                      dup.x64 sp(3)
	<div+35 @057ddb>   : 84                         div.f64
	lib/std/math/Complex.ci:92: (8 bytes: <@057ddc> - <@057de4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @057ddc>   : 11 03                      dup.x64 sp(3)
	<div+38 @057dde>   : 11 02                      dup.x64 sp(2)
	<div+40 @057de0>   : 11 09                      dup.x64 sp(9)
	<div+42 @057de2>   : 83                         mul.f64
	<div+43 @057de3>   : 81                         add.f64
	lib/std/math/Complex.ci:93: (31 bytes: <@057de4> - <@057e03>): return void(.result := {...});
	<div+44 @057de4>   : 11 09                      dup.x64 sp(9)
	<div+46 @057de6>   : 11 04                      dup.x64 sp(4)
	<div+48 @057de8>   : 11 0f                      dup.x64 sp(15)
	<div+50 @057dea>   : 83                         mul.f64
	<div+51 @057deb>   : 81                         add.f64
	<div+52 @057dec>   : 11 02                      dup.x64 sp(2)
	<div+54 @057dee>   : 84                         div.f64
	<div+55 @057def>   : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:95: (13 bytes: <@057df1> - <@057dfe>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @057df1>   : 11 0b                      dup.x64 sp(11)
	<div+59 @057df3>   : 11 04                      dup.x64 sp(4)
	<div+61 @057df5>   : 11 0d                      dup.x64 sp(13)
	<div+63 @057df7>   : 83                         mul.f64
	<div+64 @057df8>   : 82                         sub.f64
	<div+65 @057df9>   : 11 02                      dup.x64 sp(2)
	<div+67 @057dfb>   : 84                         div.f64
	<div+68 @057dfc>   : 14 11                      set.x64 sp(17)
	<div+70 @057dfe>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @057e02>   : 03                         ret
	<div+75 @057e03>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math/Complex.ci:98: (5 bytes: <@057e07> - <@057e0c>): r: float64 := float64(b.re / b.im)
	<div+79 @057e07>   : 11 01                      dup.x64 sp(1)
	<div+81 @057e09>   : 11 05                      dup.x64 sp(5)
	<div+83 @057e0b>   : 84                         div.f64
	lib/std/math/Complex.ci:99: (8 bytes: <@057e0c> - <@057e14>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @057e0c>   : 11 05                      dup.x64 sp(5)
	<div+86 @057e0e>   : 11 02                      dup.x64 sp(2)
	<div+88 @057e10>   : 11 07                      dup.x64 sp(7)
	<div+90 @057e12>   : 83                         mul.f64
	<div+91 @057e13>   : 81                         add.f64
	lib/std/math/Complex.ci:100: (31 bytes: <@057e14> - <@057e33>): return void(.result := {...});
	<div+92 @057e14>   : 11 09                      dup.x64 sp(9)
	<div+94 @057e16>   : 11 04                      dup.x64 sp(4)
	<div+96 @057e18>   : 83                         mul.f64
	<div+97 @057e19>   : 11 0d                      dup.x64 sp(13)
	<div+99 @057e1b>   : 81                         add.f64
	<div+100 @057e1c>  : 11 02                      dup.x64 sp(2)
	<div+102 @057e1e>  : 84                         div.f64
	<div+103 @057e1f>  : 14 0f                      set.x64 sp(15)
	lib/std/math/Complex.ci:102: (13 bytes: <@057e21> - <@057e2e>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @057e21>  : 11 0b                      dup.x64 sp(11)
	<div+107 @057e23>  : 11 04                      dup.x64 sp(4)
	<div+109 @057e25>  : 83                         mul.f64
	<div+110 @057e26>  : 11 0b                      dup.x64 sp(11)
	<div+112 @057e28>  : 82                         sub.f64
	<div+113 @057e29>  : 11 02                      dup.x64 sp(2)
	<div+115 @057e2b>  : 84                         div.f64
	<div+116 @057e2c>  : 14 11                      set.x64 sp(17)
	<div+118 @057e2e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @057e32>  : 03                         ret
.usages:
	lib/std/math/Complex.ci:175: referenced as `div`
	lib/std/math/Complex.ci:173: referenced as `div`
	lib/std/math/Complex.ci:166: referenced as `div`
	lib/std/math/Complex.ci:164: referenced as `div`
	lib/std/math/Complex.ci:109: referenced as `div`
	lib/std/math/Complex.ci:107: referenced as `div`
	lib/std/math/Complex.ci:86: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math/Complex.ci:171: referenced as `div`
	lib/std/math/Complex.ci:169: referenced as `div`
	lib/std/math/Complex.ci:107: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math/Complex.ci:109: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math/Complex.ci:189: referenced as `abs`
	lib/std/math/Complex.ci:136: referenced as `abs`
	lib/std/math/Complex.ci:132: referenced as `abs`
	lib/std/math/Complex.ci:112: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math/Complex.ci:189: referenced as `arg`
	lib/std/math/Complex.ci:137: referenced as `arg`
	lib/std/math/Complex.ci:132: referenced as `arg`
	lib/std/math/Complex.ci:114: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@057e38>
.name: 'inv'
.file: 'lib/std/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@057e38> - <@057e57>)
	lib/std/math/Complex.ci:118: (11 bytes: <@057e38> - <@057e43>): d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im))
	<inv @057e38>      : 11 01                      dup.x64 sp(1)
	<inv+2 @057e3a>    : 11 03                      dup.x64 sp(3)
	<inv+4 @057e3c>    : 83                         mul.f64
	<inv+5 @057e3d>    : 11 05                      dup.x64 sp(5)
	<inv+7 @057e3f>    : 11 07                      dup.x64 sp(7)
	<inv+9 @057e41>    : 83                         mul.f64
	<inv+10 @057e42>   : 81                         add.f64
	lib/std/math/Complex.ci:119: (20 bytes: <@057e43> - <@057e57>): return void(.result := {...});
	<inv+11 @057e43>   : 11 03                      dup.x64 sp(3)
	<inv+13 @057e45>   : 11 02                      dup.x64 sp(2)
	<inv+15 @057e47>   : 84                         div.f64
	<inv+16 @057e48>   : 14 09                      set.x64 sp(9)
	lib/std/math/Complex.ci:121: (8 bytes: <@057e4a> - <@057e52>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @057e4a>   : 11 05                      dup.x64 sp(5)
	<inv+20 @057e4c>   : 80                         neg.f64
	<inv+21 @057e4d>   : 11 02                      dup.x64 sp(2)
	<inv+23 @057e4f>   : 84                         div.f64
	<inv+24 @057e50>   : 14 0b                      set.x64 sp(11)
	<inv+26 @057e52>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @057e56>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:184: referenced as `inv`
	lib/std/math/Complex.ci:182: referenced as `inv`
	lib/std/math/Complex.ci:180: referenced as `inv`
	lib/std/math/Complex.ci:178: referenced as `inv`
	lib/std/math/Complex.ci:117: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math/Complex.ci:126: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math/Complex.ci:175: referenced as `exp`
	lib/std/math/Complex.ci:175: referenced as `exp`
	lib/std/math/Complex.ci:173: referenced as `exp`
	lib/std/math/Complex.ci:173: referenced as `exp`
	lib/std/math/Complex.ci:171: referenced as `exp`
	lib/std/math/Complex.ci:171: referenced as `exp`
	lib/std/math/Complex.ci:169: referenced as `exp`
	lib/std/math/Complex.ci:169: referenced as `exp`
	lib/std/math/Complex.ci:129: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math/Complex.ci:132: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@057e58>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@057e58> - <@057ebc>)
	lib/std/math/Complex.ci:136: (23 bytes: <@057e58> - <@057e6f>): r: float64 := abs(a)
	<pow @057e58>      : 12 05                      dup.x128 sp(5)
	<pow+2 @057e5a>    : 11 00                      dup.x64 sp(0)
	<pow+4 @057e5c>    : 11 02                      dup.x64 sp(2)
	<pow+6 @057e5e>    : 83                         mul.f64
	<pow+7 @057e5f>    : 11 04                      dup.x64 sp(4)
	<pow+9 @057e61>    : 11 06                      dup.x64 sp(6)
	<pow+11 @057e63>   : 83                         mul.f64
	<pow+12 @057e64>   : 81                         add.f64
	<pow+13 @057e65>   : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	<pow+17 @057e69>   : 14 04                      set.x64 sp(4)
	<pow+19 @057e6b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:137: (16 bytes: <@057e6f> - <@057e7f>): t: float64 := arg(a)
	<pow+23 @057e6f>   : 12 07                      dup.x128 sp(7)
	<pow+25 @057e71>   : 11 00                      dup.x64 sp(0)
	<pow+27 @057e73>   : 11 04                      dup.x64 sp(4)
	<pow+29 @057e75>   : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @057e79>   : 14 04                      set.x64 sp(4)
	<pow+35 @057e7b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math/Complex.ci:138: (15 bytes: <@057e7f> - <@057e8e>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @057e7f>   : 11 05                      dup.x64 sp(5)
	<pow+41 @057e81>   : 11 02                      dup.x64 sp(2)
	<pow+43 @057e83>   : 83                         mul.f64
	<pow+44 @057e84>   : 11 09                      dup.x64 sp(9)
	<pow+46 @057e86>   : 11 06                      dup.x64 sp(6)
	<pow+48 @057e88>   : 01 2b 00 00                nfc(43) ;float64.log(x: float64): float64
	<pow+52 @057e8c>   : 83                         mul.f64
	<pow+53 @057e8d>   : 81                         add.f64
	lib/std/math/Complex.ci:139: (19 bytes: <@057e8e> - <@057ea1>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @057e8e>   : 11 04                      dup.x64 sp(4)
	<pow+56 @057e90>   : 11 09                      dup.x64 sp(9)
	<pow+58 @057e92>   : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @057e96>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @057e98>   : 80                         neg.f64
	<pow+65 @057e99>   : 11 06                      dup.x64 sp(6)
	<pow+67 @057e9b>   : 83                         mul.f64
	<pow+68 @057e9c>   : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<pow+72 @057ea0>   : 83                         mul.f64
	lib/std/math/Complex.ci:140: (27 bytes: <@057ea1> - <@057ebc>): return void(.result := {...});
	<pow+73 @057ea1>   : 11 00                      dup.x64 sp(0)
	<pow+75 @057ea3>   : 11 04                      dup.x64 sp(4)
	<pow+77 @057ea5>   : 01 29 00 00                nfc(41) ;float64.cos(x: float64): float64
	<pow+81 @057ea9>   : 83                         mul.f64
	<pow+82 @057eaa>   : 14 13                      set.x64 sp(19)
	lib/std/math/Complex.ci:142: (11 bytes: <@057eac> - <@057eb7>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @057eac>   : 11 00                      dup.x64 sp(0)
	<pow+86 @057eae>   : 11 04                      dup.x64 sp(4)
	<pow+88 @057eb0>   : 01 28 00 00                nfc(40) ;float64.sin(x: float64): float64
	<pow+92 @057eb4>   : 83                         mul.f64
	<pow+93 @057eb5>   : 14 15                      set.x64 sp(21)
	<pow+95 @057eb7>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @057ebb>   : 03                         ret
.usages:
	lib/std/math/Complex.ci:146: referenced as `pow`
	lib/std/math/Complex.ci:135: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math/Complex.ci:146: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:180: referenced as `sin`
	lib/std/math/Complex.ci:166: referenced as `sin`
	lib/std/math/Complex.ci:164: referenced as `sin`
	lib/std/math/Complex.ci:149: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math/Complex.ci:178: referenced as `cos`
	lib/std/math/Complex.ci:166: referenced as `cos`
	lib/std/math/Complex.ci:164: referenced as `cos`
	lib/std/math/Complex.ci:151: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math/Complex.ci:164: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math/Complex.ci:166: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:184: referenced as `sinh`
	lib/std/math/Complex.ci:169: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math/Complex.ci:182: referenced as `cosh`
	lib/std/math/Complex.ci:171: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math/Complex.ci:173: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math/Complex.ci:175: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math/Complex.ci:178: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math/Complex.ci:180: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math/Complex.ci:182: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math/Complex.ci:184: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math/Complex.ci:187: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math/Complex.ci:189: defined as `toPolar(x: Complex): Complex`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020090>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:2'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/std/math/Matrix4f.ci:173: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:163: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:160: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:111: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:75: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:20: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:18: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:16: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:14: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:10: referenced as `vec4f`
	lib/std/math/Vector4f.ci:107: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:102: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:96: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:92: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:88: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:84: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:82: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:79: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:77: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:75: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:73: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:71: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: referenced as `vec4f`
	lib/std/math/Vector4f.ci:2: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector4f.ci:4'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/std/math/Vector4f.ci:4: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector4f.ci:126'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/std/math/Vector4f.ci:126: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `x`
	lib/std/math/Matrix4f.ci:178: referenced as `x`
	lib/std/math/Matrix4f.ci:177: referenced as `x`
	lib/std/math/Matrix4f.ci:176: referenced as `x`
	lib/std/math/Matrix4f.ci:176: referenced as `x`
	lib/std/math/Matrix4f.ci:168: referenced as `x`
	lib/std/math/Matrix4f.ci:167: referenced as `x`
	lib/std/math/Matrix4f.ci:166: referenced as `x`
	lib/std/math/Matrix4f.ci:165: referenced as `x`
	lib/std/math/Matrix4f.ci:165: referenced as `x`
	lib/std/math/Matrix4f.ci:125: referenced as `x`
	lib/std/math/Matrix4f.ci:122: referenced as `x`
	lib/std/math/Matrix4f.ci:70: referenced as `x`
	lib/std/math/Matrix4f.ci:69: referenced as `x`
	lib/std/math/Matrix4f.ci:68: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Vector4f.ci:107: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:99: referenced as `x`
	lib/std/math/Vector4f.ci:37: referenced as `x`
	lib/std/math/Vector4f.ci:27: referenced as `x`
	lib/std/math/Vector4f.ci:7: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `y`
	lib/std/math/Matrix4f.ci:178: referenced as `y`
	lib/std/math/Matrix4f.ci:177: referenced as `y`
	lib/std/math/Matrix4f.ci:176: referenced as `y`
	lib/std/math/Matrix4f.ci:177: referenced as `y`
	lib/std/math/Matrix4f.ci:168: referenced as `y`
	lib/std/math/Matrix4f.ci:167: referenced as `y`
	lib/std/math/Matrix4f.ci:166: referenced as `y`
	lib/std/math/Matrix4f.ci:165: referenced as `y`
	lib/std/math/Matrix4f.ci:166: referenced as `y`
	lib/std/math/Matrix4f.ci:126: referenced as `y`
	lib/std/math/Matrix4f.ci:123: referenced as `y`
	lib/std/math/Matrix4f.ci:70: referenced as `y`
	lib/std/math/Matrix4f.ci:69: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:67: referenced as `y`
	lib/std/math/Vector4f.ci:107: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:99: referenced as `y`
	lib/std/math/Vector4f.ci:37: referenced as `y`
	lib/std/math/Vector4f.ci:27: referenced as `y`
	lib/std/math/Vector4f.ci:9: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `z`
	lib/std/math/Matrix4f.ci:178: referenced as `z`
	lib/std/math/Matrix4f.ci:177: referenced as `z`
	lib/std/math/Matrix4f.ci:176: referenced as `z`
	lib/std/math/Matrix4f.ci:178: referenced as `z`
	lib/std/math/Matrix4f.ci:168: referenced as `z`
	lib/std/math/Matrix4f.ci:167: referenced as `z`
	lib/std/math/Matrix4f.ci:166: referenced as `z`
	lib/std/math/Matrix4f.ci:165: referenced as `z`
	lib/std/math/Matrix4f.ci:167: referenced as `z`
	lib/std/math/Matrix4f.ci:127: referenced as `z`
	lib/std/math/Matrix4f.ci:124: referenced as `z`
	lib/std/math/Matrix4f.ci:70: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:68: referenced as `z`
	lib/std/math/Matrix4f.ci:67: referenced as `z`
	lib/std/math/Vector4f.ci:107: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:99: referenced as `z`
	lib/std/math/Vector4f.ci:37: referenced as `z`
	lib/std/math/Vector4f.ci:27: referenced as `z`
	lib/std/math/Vector4f.ci:11: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `w`
	lib/std/math/Matrix4f.ci:178: referenced as `w`
	lib/std/math/Matrix4f.ci:177: referenced as `w`
	lib/std/math/Matrix4f.ci:176: referenced as `w`
	lib/std/math/Matrix4f.ci:168: referenced as `w`
	lib/std/math/Matrix4f.ci:167: referenced as `w`
	lib/std/math/Matrix4f.ci:166: referenced as `w`
	lib/std/math/Matrix4f.ci:165: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:69: referenced as `w`
	lib/std/math/Matrix4f.ci:68: referenced as `w`
	lib/std/math/Matrix4f.ci:67: referenced as `w`
	lib/std/math/Vector4f.ci:107: referenced as `w`
	lib/std/math/Vector4f.ci:27: referenced as `w`
	lib/std/math/Vector4f.ci:13: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Vector4f.ci:13'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@057ec0>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@057ec0> - <@057ecd>)
	lib/std/math/Vector4f.ci:27: (13 bytes: <@057ec0> - <@057ecd>): return void(.result := {...});
	<vec4f @057ec0>      : 16 05 04                   mov.x32 sp(5, 4)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@057ec3> - <@057ec6>): void(.result.y := y);
	<vec4f+3 @057ec3>    : 16 06 03                   mov.x32 sp(6, 3)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@057ec6> - <@057ec9>): void(.result.z := z);
	<vec4f+6 @057ec6>    : 16 07 02                   mov.x32 sp(7, 2)
	lib/std/math/Vector4f.ci:27: (3 bytes: <@057ec9> - <@057ecc>): void(.result.w := w);
	<vec4f+9 @057ec9>    : 16 08 01                   mov.x32 sp(8, 1)
	<vec4f+12 @057ecc>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:155: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:119: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:118: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:117: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:116: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:84: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:82: referenced as `vec4f`
	lib/std/math/Matrix4f.ci:80: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: referenced as `vec4f`
	lib/std/math/Vector4f.ci:37: referenced as `vec4f`
	lib/std/math/Vector4f.ci:34: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: referenced as `vec4f`
	lib/std/math/Vector4f.ci:26: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:31'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	lib/std/math/Vector4f.ci:99: referenced as `vec4f`
	lib/std/math/Vector4f.ci:31: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
	lib/std/math/Vector4f.ci:34: defined as `vec4f(x: float32, y: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:37'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/std/math/Vector4f.ci:37: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/std/math/Vector4f.ci:40'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/std/math/Matrix4f.ci:160: referenced as `vec4f`
	lib/std/math/Vector4f.ci:104: referenced as `vec4f`
	lib/std/math/Vector4f.ci:40: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/std/math/Vector4f.ci:71: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/std/math/Vector4f.ci:73: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/std/math/Vector4f.ci:75: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/std/math/Vector4f.ci:77: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Vector4f.ci:79'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/std/math/Vector4f.ci:104: referenced as `div`
	lib/std/math/Vector4f.ci:79: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/std/math/Vector4f.ci:82'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	lib/std/math/Vector2d.ci:34: referenced as `min`
	lib/std/math/Vector4f.ci:82: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/std/math/Vector4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	lib/std/math/Vector2d.ci:37: referenced as `max`
	lib/std/math/Vector4f.ci:84: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Vector4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Matrix4f.ci:80: referenced as `dp3`
	lib/std/math/Vector4f.ci:102: referenced as `dp3`
	lib/std/math/Vector4f.ci:88: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Vector4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Matrix4f.ci:82: referenced as `dph`
	lib/std/math/Vector4f.ci:92: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Vector4f.ci:96'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: referenced as `dp4`
	lib/std/math/Vector4f.ci:96: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/std/math/Vector4f.ci:99'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/std/math/Vector4f.ci:99: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'lib/std/math/Vector4f.ci:102'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/std/math/Matrix4f.ci:112: referenced as `length`
	lib/std/math/Vector4f.ci:104: referenced as `length`
	lib/std/math/Vector4f.ci:102: defined as `length(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/std/math/Vector4f.ci:104'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
	lib/std/math/Vector4f.ci:104: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math/Vector4f.ci:107'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/std/math/Vector4f.ci:107: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@023828>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:2'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/std/math/Matrix4f.ci:173: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:163: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:111: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:98: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:97: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:87: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:84: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:82: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:80: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:75: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:62: referenced as `mat4f`
	lib/std/math/Matrix4f.ci:2: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:4: defined as `data`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/std/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:7: defined as `m`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/std/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/std/math/Matrix4f.ci:10: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/std/math/Matrix4f.ci:182: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:176: referenced as `x`
	lib/std/math/Matrix4f.ci:165: referenced as `x`
	lib/std/math/Matrix4f.ci:116: referenced as `x`
	lib/std/math/Matrix4f.ci:100: referenced as `x`
	lib/std/math/Matrix4f.ci:100: referenced as `x`
	lib/std/math/Matrix4f.ci:84: referenced as `x`
	lib/std/math/Matrix4f.ci:82: referenced as `x`
	lib/std/math/Matrix4f.ci:80: referenced as `x`
	lib/std/math/Matrix4f.ci:76: referenced as `x`
	lib/std/math/Matrix4f.ci:67: referenced as `x`
	lib/std/math/Matrix4f.ci:14: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:177: referenced as `y`
	lib/std/math/Matrix4f.ci:166: referenced as `y`
	lib/std/math/Matrix4f.ci:117: referenced as `y`
	lib/std/math/Matrix4f.ci:101: referenced as `y`
	lib/std/math/Matrix4f.ci:101: referenced as `y`
	lib/std/math/Matrix4f.ci:84: referenced as `y`
	lib/std/math/Matrix4f.ci:82: referenced as `y`
	lib/std/math/Matrix4f.ci:80: referenced as `y`
	lib/std/math/Matrix4f.ci:76: referenced as `y`
	lib/std/math/Matrix4f.ci:68: referenced as `y`
	lib/std/math/Matrix4f.ci:16: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:178: referenced as `z`
	lib/std/math/Matrix4f.ci:167: referenced as `z`
	lib/std/math/Matrix4f.ci:118: referenced as `z`
	lib/std/math/Matrix4f.ci:102: referenced as `z`
	lib/std/math/Matrix4f.ci:102: referenced as `z`
	lib/std/math/Matrix4f.ci:84: referenced as `z`
	lib/std/math/Matrix4f.ci:82: referenced as `z`
	lib/std/math/Matrix4f.ci:80: referenced as `z`
	lib/std/math/Matrix4f.ci:76: referenced as `z`
	lib/std/math/Matrix4f.ci:69: referenced as `z`
	lib/std/math/Matrix4f.ci:18: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:179: referenced as `w`
	lib/std/math/Matrix4f.ci:168: referenced as `w`
	lib/std/math/Matrix4f.ci:155: referenced as `w`
	lib/std/math/Matrix4f.ci:119: referenced as `w`
	lib/std/math/Matrix4f.ci:103: referenced as `w`
	lib/std/math/Matrix4f.ci:103: referenced as `w`
	lib/std/math/Matrix4f.ci:84: referenced as `w`
	lib/std/math/Matrix4f.ci:82: referenced as `w`
	lib/std/math/Matrix4f.ci:76: referenced as `w`
	lib/std/math/Matrix4f.ci:70: referenced as `w`
	lib/std/math/Matrix4f.ci:20: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/std/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/std/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
	lib/std/math/Matrix4f.ci:182: defined as `<?>`
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:140: referenced as `xx`
	lib/std/math/Matrix4f.ci:89: referenced as `xx`
	lib/std/math/Matrix4f.ci:89: referenced as `xx`
	lib/std/math/Matrix4f.ci:24: defined as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:141: referenced as `xy`
	lib/std/math/Matrix4f.ci:89: referenced as `xy`
	lib/std/math/Matrix4f.ci:90: referenced as `xy`
	lib/std/math/Matrix4f.ci:26: defined as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:142: referenced as `xz`
	lib/std/math/Matrix4f.ci:89: referenced as `xz`
	lib/std/math/Matrix4f.ci:91: referenced as `xz`
	lib/std/math/Matrix4f.ci:28: defined as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:143: referenced as `xw`
	lib/std/math/Matrix4f.ci:89: referenced as `xw`
	lib/std/math/Matrix4f.ci:92: referenced as `xw`
	lib/std/math/Matrix4f.ci:30: defined as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:145: referenced as `yx`
	lib/std/math/Matrix4f.ci:90: referenced as `yx`
	lib/std/math/Matrix4f.ci:89: referenced as `yx`
	lib/std/math/Matrix4f.ci:33: defined as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:146: referenced as `yy`
	lib/std/math/Matrix4f.ci:90: referenced as `yy`
	lib/std/math/Matrix4f.ci:90: referenced as `yy`
	lib/std/math/Matrix4f.ci:35: defined as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:147: referenced as `yz`
	lib/std/math/Matrix4f.ci:90: referenced as `yz`
	lib/std/math/Matrix4f.ci:91: referenced as `yz`
	lib/std/math/Matrix4f.ci:37: defined as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:148: referenced as `yw`
	lib/std/math/Matrix4f.ci:90: referenced as `yw`
	lib/std/math/Matrix4f.ci:92: referenced as `yw`
	lib/std/math/Matrix4f.ci:39: defined as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:150: referenced as `zx`
	lib/std/math/Matrix4f.ci:91: referenced as `zx`
	lib/std/math/Matrix4f.ci:89: referenced as `zx`
	lib/std/math/Matrix4f.ci:42: defined as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:151: referenced as `zy`
	lib/std/math/Matrix4f.ci:91: referenced as `zy`
	lib/std/math/Matrix4f.ci:90: referenced as `zy`
	lib/std/math/Matrix4f.ci:44: defined as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:152: referenced as `zz`
	lib/std/math/Matrix4f.ci:91: referenced as `zz`
	lib/std/math/Matrix4f.ci:91: referenced as `zz`
	lib/std/math/Matrix4f.ci:46: defined as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:153: referenced as `zw`
	lib/std/math/Matrix4f.ci:91: referenced as `zw`
	lib/std/math/Matrix4f.ci:92: referenced as `zw`
	lib/std/math/Matrix4f.ci:48: defined as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:92: referenced as `wx`
	lib/std/math/Matrix4f.ci:89: referenced as `wx`
	lib/std/math/Matrix4f.ci:51: defined as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:92: referenced as `wy`
	lib/std/math/Matrix4f.ci:90: referenced as `wy`
	lib/std/math/Matrix4f.ci:53: defined as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:92: referenced as `wz`
	lib/std/math/Matrix4f.ci:91: referenced as `wz`
	lib/std/math/Matrix4f.ci:55: defined as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/std/math/Matrix4f.ci:92: referenced as `ww`
	lib/std/math/Matrix4f.ci:92: referenced as `ww`
	lib/std/math/Matrix4f.ci:57: defined as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'lib/std/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'lib/std/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'lib/std/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'lib/std/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'lib/std/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'lib/std/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'lib/std/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'lib/std/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'lib/std/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'lib/std/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'lib/std/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'lib/std/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'lib/std/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'lib/std/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'lib/std/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'lib/std/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@057ed0>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@057ed0> - <@057f01>)
	lib/std/math/Matrix4f.ci:66: (49 bytes: <@057ed0> - <@057f01>): return void(.result := {...});
	<mat4f @057ed0>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@057ed3> - <@057ed6>): void(.result.x.y := xy);
	<mat4f+3 @057ed3>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@057ed6> - <@057ed9>): void(.result.x.z := xz);
	<mat4f+6 @057ed6>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/std/math/Matrix4f.ci:67: (3 bytes: <@057ed9> - <@057edc>): void(.result.x.w := xw);
	<mat4f+9 @057ed9>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@057edc> - <@057edf>): void(.result.y.x := yx);
	<mat4f+12 @057edc>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@057edf> - <@057ee2>): void(.result.y.y := yy);
	<mat4f+15 @057edf>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@057ee2> - <@057ee5>): void(.result.y.z := yz);
	<mat4f+18 @057ee2>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:68: (3 bytes: <@057ee5> - <@057ee8>): void(.result.y.w := yw);
	<mat4f+21 @057ee5>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@057ee8> - <@057eeb>): void(.result.z.x := zx);
	<mat4f+24 @057ee8>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@057eeb> - <@057eee>): void(.result.z.y := zy);
	<mat4f+27 @057eeb>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@057eee> - <@057ef1>): void(.result.z.z := zz);
	<mat4f+30 @057eee>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/std/math/Matrix4f.ci:69: (3 bytes: <@057ef1> - <@057ef4>): void(.result.z.w := zw);
	<mat4f+33 @057ef1>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@057ef4> - <@057ef7>): void(.result.w.x := wx);
	<mat4f+36 @057ef4>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@057ef7> - <@057efa>): void(.result.w.y := wy);
	<mat4f+39 @057ef7>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@057efa> - <@057efd>): void(.result.w.z := wz);
	<mat4f+42 @057efa>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/std/math/Matrix4f.ci:70: (3 bytes: <@057efd> - <@057f00>): void(.result.w.w := ww);
	<mat4f+45 @057efd>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @057f00>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:62: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@057f08>
.name: 'mat4f'
.file: 'lib/std/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@057f08> - <@057f1d>)
	lib/std/math/Matrix4f.ci:76: (21 bytes: <@057f08> - <@057f1d>): return void(.result := {...});
	<mat4f @057f08>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @057f0a>    : 24                         load.i128
	<mat4f+3 @057f0b>    : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@057f0d> - <@057f12>): void(.result.y := y);
	<mat4f+5 @057f0d>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @057f0f>    : 24                         load.i128
	<mat4f+8 @057f10>    : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@057f12> - <@057f17>): void(.result.z := z);
	<mat4f+10 @057f12>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @057f14>   : 24                         load.i128
	<mat4f+13 @057f15>   : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:76: (5 bytes: <@057f17> - <@057f1c>): void(.result.w := w);
	<mat4f+15 @057f17>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @057f19>   : 24                         load.i128
	<mat4f+18 @057f1a>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @057f1c>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:75: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/std/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/std/math/Matrix4f.ci:80: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/std/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/std/math/Matrix4f.ci:82: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/std/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/std/math/Matrix4f.ci:103: referenced as `dp4`
	lib/std/math/Matrix4f.ci:102: referenced as `dp4`
	lib/std/math/Matrix4f.ci:101: referenced as `dp4`
	lib/std/math/Matrix4f.ci:100: referenced as `dp4`
	lib/std/math/Matrix4f.ci:84: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
transpose(mat: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@057f20>
.name: 'transpose'
.file: 'lib/std/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <@057f20> - <@057f51>)
	lib/std/math/Matrix4f.ci:88: (49 bytes: <@057f20> - <@057f51>): return void(.result := {...});
	<transpose @057f20>      : 16 11 01                   mov.x32 sp(17, 1)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@057f23> - <@057f26>): void(.result.xy := mat.yx);
	<transpose+3 @057f23>    : 16 12 05                   mov.x32 sp(18, 5)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@057f26> - <@057f29>): void(.result.xz := mat.zx);
	<transpose+6 @057f26>    : 16 13 09                   mov.x32 sp(19, 9)
	lib/std/math/Matrix4f.ci:89: (3 bytes: <@057f29> - <@057f2c>): void(.result.xw := mat.wx);
	<transpose+9 @057f29>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@057f2c> - <@057f2f>): void(.result.yx := mat.xy);
	<transpose+12 @057f2c>   : 16 15 02                   mov.x32 sp(21, 2)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@057f2f> - <@057f32>): void(.result.yy := mat.yy);
	<transpose+15 @057f2f>   : 16 16 06                   mov.x32 sp(22, 6)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@057f32> - <@057f35>): void(.result.yz := mat.zy);
	<transpose+18 @057f32>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/std/math/Matrix4f.ci:90: (3 bytes: <@057f35> - <@057f38>): void(.result.yw := mat.wy);
	<transpose+21 @057f35>   : 16 18 0e                   mov.x32 sp(24, 14)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@057f38> - <@057f3b>): void(.result.zx := mat.xz);
	<transpose+24 @057f38>   : 16 19 03                   mov.x32 sp(25, 3)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@057f3b> - <@057f3e>): void(.result.zy := mat.yz);
	<transpose+27 @057f3b>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@057f3e> - <@057f41>): void(.result.zz := mat.zz);
	<transpose+30 @057f3e>   : 16 1b 0b                   mov.x32 sp(27, 11)
	lib/std/math/Matrix4f.ci:91: (3 bytes: <@057f41> - <@057f44>): void(.result.zw := mat.wz);
	<transpose+33 @057f41>   : 16 1c 0f                   mov.x32 sp(28, 15)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@057f44> - <@057f47>): void(.result.wx := mat.xw);
	<transpose+36 @057f44>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@057f47> - <@057f4a>): void(.result.wy := mat.yw);
	<transpose+39 @057f47>   : 16 1e 08                   mov.x32 sp(30, 8)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@057f4a> - <@057f4d>): void(.result.wz := mat.zw);
	<transpose+42 @057f4a>   : 16 1f 0c                   mov.x32 sp(31, 12)
	lib/std/math/Matrix4f.ci:92: (3 bytes: <@057f4d> - <@057f50>): void(.result.ww := mat.ww);
	<transpose+45 @057f4d>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @057f50>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:98: referenced as `transpose`
	lib/std/math/Matrix4f.ci:87: defined as `transpose(mat: mat4f): mat4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 301
.offset: <@057f58>
.name: 'mul'
.file: 'lib/std/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (301 bytes: <@057f58> - <@058085>)
	lib/std/math/Matrix4f.ci:98: (28 bytes: <@057f58> - <@057f74>): transposed: mat4f := transpose(rhs)
	<mul @057f58>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @057f5c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @057f5e>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @057f62>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @057f66>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @057f6a>   : 1f 20 7f 05 00             load.ref <@057f20> ;transpose(mat: mat4f): mat4f
	<mul+23 @057f6f>   : 02                         call
	<mul+24 @057f70>   : 09 c0 ff ff                inc.sp(-64)
	lib/std/math/Matrix4f.ci:99: (273 bytes: <@057f74> - <@058085>): return void(.result := {...});
	<mul+28 @057f74>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @057f78>   : 10 13                      dup.x32 sp(19)
	<mul+34 @057f7a>   : 09 10 00 00                inc.sp(+16)
	<mul+38 @057f7e>   : 10 05                      dup.x32 sp(5)
	<mul+40 @057f80>   : 24                         load.i128
	<mul+41 @057f81>   : 10 08                      dup.x32 sp(8)
	<mul+43 @057f83>   : 24                         load.i128
	<mul+44 @057f84>   : 9b                         dp4.v4f
	<mul+45 @057f85>   : 10 06                      dup.x32 sp(6)
	<mul+47 @057f87>   : 0c 10 00 00                inc.i32(+16)
	<mul+51 @057f8b>   : 24                         load.i128
	<mul+52 @057f8c>   : 10 09                      dup.x32 sp(9)
	<mul+54 @057f8e>   : 24                         load.i128
	<mul+55 @057f8f>   : 9b                         dp4.v4f
	<mul+56 @057f90>   : 10 07                      dup.x32 sp(7)
	<mul+58 @057f92>   : 0c 20 00 00                inc.i32(+32)
	<mul+62 @057f96>   : 24                         load.i128
	<mul+63 @057f97>   : 10 0a                      dup.x32 sp(10)
	<mul+65 @057f99>   : 24                         load.i128
	<mul+66 @057f9a>   : 9b                         dp4.v4f
	<mul+67 @057f9b>   : 10 08                      dup.x32 sp(8)
	<mul+69 @057f9d>   : 0c 30 00 00                inc.i32(+48)
	<mul+73 @057fa1>   : 24                         load.i128
	<mul+74 @057fa2>   : 10 0b                      dup.x32 sp(11)
	<mul+76 @057fa4>   : 24                         load.i128
	<mul+77 @057fa5>   : 9b                         dp4.v4f
	<mul+78 @057fa6>   : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+83 @057fab>   : 02                         call
	<mul+84 @057fac>   : 09 f0 ff ff                inc.sp(-16)
	<mul+88 @057fb0>   : 15 02                      set.x128 sp(2)
	<mul+90 @057fb2>   : 15 17                      set.x128 sp(23)
	lib/std/math/Matrix4f.ci:101: (68 bytes: <@057fb4> - <@057ff8>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+92 @057fb4>   : 0a 00 00 00                load.sp(+0)
	<mul+96 @057fb8>   : 10 13                      dup.x32 sp(19)
	<mul+98 @057fba>   : 0c 10 00 00                inc.i32(+16)
	<mul+102 @057fbe>  : 09 10 00 00                inc.sp(+16)
	<mul+106 @057fc2>  : 10 05                      dup.x32 sp(5)
	<mul+108 @057fc4>  : 24                         load.i128
	<mul+109 @057fc5>  : 10 08                      dup.x32 sp(8)
	<mul+111 @057fc7>  : 24                         load.i128
	<mul+112 @057fc8>  : 9b                         dp4.v4f
	<mul+113 @057fc9>  : 10 06                      dup.x32 sp(6)
	<mul+115 @057fcb>  : 0c 10 00 00                inc.i32(+16)
	<mul+119 @057fcf>  : 24                         load.i128
	<mul+120 @057fd0>  : 10 09                      dup.x32 sp(9)
	<mul+122 @057fd2>  : 24                         load.i128
	<mul+123 @057fd3>  : 9b                         dp4.v4f
	<mul+124 @057fd4>  : 10 07                      dup.x32 sp(7)
	<mul+126 @057fd6>  : 0c 20 00 00                inc.i32(+32)
	<mul+130 @057fda>  : 24                         load.i128
	<mul+131 @057fdb>  : 10 0a                      dup.x32 sp(10)
	<mul+133 @057fdd>  : 24                         load.i128
	<mul+134 @057fde>  : 9b                         dp4.v4f
	<mul+135 @057fdf>  : 10 08                      dup.x32 sp(8)
	<mul+137 @057fe1>  : 0c 30 00 00                inc.i32(+48)
	<mul+141 @057fe5>  : 24                         load.i128
	<mul+142 @057fe6>  : 10 0b                      dup.x32 sp(11)
	<mul+144 @057fe8>  : 24                         load.i128
	<mul+145 @057fe9>  : 9b                         dp4.v4f
	<mul+146 @057fea>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+151 @057fef>  : 02                         call
	<mul+152 @057ff0>  : 09 f0 ff ff                inc.sp(-16)
	<mul+156 @057ff4>  : 15 02                      set.x128 sp(2)
	<mul+158 @057ff6>  : 15 1b                      set.x128 sp(27)
	lib/std/math/Matrix4f.ci:102: (68 bytes: <@057ff8> - <@05803c>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+160 @057ff8>  : 0a 00 00 00                load.sp(+0)
	<mul+164 @057ffc>  : 10 13                      dup.x32 sp(19)
	<mul+166 @057ffe>  : 0c 20 00 00                inc.i32(+32)
	<mul+170 @058002>  : 09 10 00 00                inc.sp(+16)
	<mul+174 @058006>  : 10 05                      dup.x32 sp(5)
	<mul+176 @058008>  : 24                         load.i128
	<mul+177 @058009>  : 10 08                      dup.x32 sp(8)
	<mul+179 @05800b>  : 24                         load.i128
	<mul+180 @05800c>  : 9b                         dp4.v4f
	<mul+181 @05800d>  : 10 06                      dup.x32 sp(6)
	<mul+183 @05800f>  : 0c 10 00 00                inc.i32(+16)
	<mul+187 @058013>  : 24                         load.i128
	<mul+188 @058014>  : 10 09                      dup.x32 sp(9)
	<mul+190 @058016>  : 24                         load.i128
	<mul+191 @058017>  : 9b                         dp4.v4f
	<mul+192 @058018>  : 10 07                      dup.x32 sp(7)
	<mul+194 @05801a>  : 0c 20 00 00                inc.i32(+32)
	<mul+198 @05801e>  : 24                         load.i128
	<mul+199 @05801f>  : 10 0a                      dup.x32 sp(10)
	<mul+201 @058021>  : 24                         load.i128
	<mul+202 @058022>  : 9b                         dp4.v4f
	<mul+203 @058023>  : 10 08                      dup.x32 sp(8)
	<mul+205 @058025>  : 0c 30 00 00                inc.i32(+48)
	<mul+209 @058029>  : 24                         load.i128
	<mul+210 @05802a>  : 10 0b                      dup.x32 sp(11)
	<mul+212 @05802c>  : 24                         load.i128
	<mul+213 @05802d>  : 9b                         dp4.v4f
	<mul+214 @05802e>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+219 @058033>  : 02                         call
	<mul+220 @058034>  : 09 f0 ff ff                inc.sp(-16)
	<mul+224 @058038>  : 15 02                      set.x128 sp(2)
	<mul+226 @05803a>  : 15 1f                      set.x128 sp(31)
	lib/std/math/Matrix4f.ci:103: (68 bytes: <@05803c> - <@058080>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+228 @05803c>  : 0a 00 00 00                load.sp(+0)
	<mul+232 @058040>  : 10 13                      dup.x32 sp(19)
	<mul+234 @058042>  : 0c 30 00 00                inc.i32(+48)
	<mul+238 @058046>  : 09 10 00 00                inc.sp(+16)
	<mul+242 @05804a>  : 10 05                      dup.x32 sp(5)
	<mul+244 @05804c>  : 24                         load.i128
	<mul+245 @05804d>  : 10 08                      dup.x32 sp(8)
	<mul+247 @05804f>  : 24                         load.i128
	<mul+248 @058050>  : 9b                         dp4.v4f
	<mul+249 @058051>  : 10 06                      dup.x32 sp(6)
	<mul+251 @058053>  : 0c 10 00 00                inc.i32(+16)
	<mul+255 @058057>  : 24                         load.i128
	<mul+256 @058058>  : 10 09                      dup.x32 sp(9)
	<mul+258 @05805a>  : 24                         load.i128
	<mul+259 @05805b>  : 9b                         dp4.v4f
	<mul+260 @05805c>  : 10 07                      dup.x32 sp(7)
	<mul+262 @05805e>  : 0c 20 00 00                inc.i32(+32)
	<mul+266 @058062>  : 24                         load.i128
	<mul+267 @058063>  : 10 0a                      dup.x32 sp(10)
	<mul+269 @058065>  : 24                         load.i128
	<mul+270 @058066>  : 9b                         dp4.v4f
	<mul+271 @058067>  : 10 08                      dup.x32 sp(8)
	<mul+273 @058069>  : 0c 30 00 00                inc.i32(+48)
	<mul+277 @05806d>  : 24                         load.i128
	<mul+278 @05806e>  : 10 0b                      dup.x32 sp(11)
	<mul+280 @058070>  : 24                         load.i128
	<mul+281 @058071>  : 9b                         dp4.v4f
	<mul+282 @058072>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+287 @058077>  : 02                         call
	<mul+288 @058078>  : 09 f0 ff ff                inc.sp(-16)
	<mul+292 @05807c>  : 15 02                      set.x128 sp(2)
	<mul+294 @05807e>  : 15 23                      set.x128 sp(35)
	<mul+296 @058080>  : 09 c0 ff ff                inc.sp(-64)
	<mul+300 @058084>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:97: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 524
.offset: <@058088>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (524 bytes: <@058088> - <@058294>)
	lib/std/math/Matrix4f.ci:112: (18 bytes: <@058088> - <@05809a>): len: float32 := length(direction)
	<rotation @058088>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @05808a>    : 24                         load.i128
	<rotation+3 @05808b>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @05808d>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @05808f>    : 9a                         dp3.v4f
	<rotation+8 @058090>    : 01 26 00 00                nfc(38) ;float32.sqrt(x: float32): float32
	<rotation+12 @058094>   : 13 04                      set.x32 sp(4)
	<rotation+14 @058096>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math/Matrix4f.ci:113: (138 bytes: <@05809a> - <@058124>): if (bool((len) < 0.000000))
	<rotation+18 @05809a>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @05809c>   : 7d                         f32.2f64
	<rotation+21 @05809d>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @0580a6>   : 88                         clt.f64
	<rotation+31 @0580a7>   : 06 7d 00 00                jz <rotation+156 @058124>
	lib/std/math/Matrix4f.ci:114: (36 bytes: <@0580ab> - <@0580cf>): trace(void("invalid direction of rotation", direction));
	<rotation+35 @0580ab>   : 1f d8 34 02 00             load.ref <@0234d8> ;"lib/std/math/Matrix4f.ci"
	<rotation+40 @0580b0>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @0580b5>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @0580ba>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @0580bf>   : 1f 95 37 02 00             load.ref <@023795> ;"invalid direction of rotation"
	<rotation+60 @0580c4>   : 1f 90 00 02 00             load.ref <@020090> ;vec4f
	<rotation+65 @0580c9>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @0580cb>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/math/Matrix4f.ci:115: (85 bytes: <@0580cf> - <@058124>): return void(.result := {...});
	<rotation+71 @0580cf>   : 09 10 00 00                inc.sp(+16)
	<rotation+75 @0580d3>   : 19                         load.z32
	<rotation+76 @0580d4>   : 19                         load.z32
	<rotation+77 @0580d5>   : 19                         load.z32
	<rotation+78 @0580d6>   : 19                         load.z32
	<rotation+79 @0580d7>   : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+84 @0580dc>   : 02                         call
	<rotation+85 @0580dd>   : 09 f0 ff ff                inc.sp(-16)
	<rotation+89 @0580e1>   : 15 09                      set.x128 sp(9)
	lib/std/math/Matrix4f.ci:117: (20 bytes: <@0580e3> - <@0580f7>): void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+91 @0580e3>   : 09 10 00 00                inc.sp(+16)
	<rotation+95 @0580e7>   : 19                         load.z32
	<rotation+96 @0580e8>   : 19                         load.z32
	<rotation+97 @0580e9>   : 19                         load.z32
	<rotation+98 @0580ea>   : 19                         load.z32
	<rotation+99 @0580eb>   : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+104 @0580f0>  : 02                         call
	<rotation+105 @0580f1>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+109 @0580f5>  : 15 0d                      set.x128 sp(13)
	lib/std/math/Matrix4f.ci:118: (20 bytes: <@0580f7> - <@05810b>): void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+111 @0580f7>  : 09 10 00 00                inc.sp(+16)
	<rotation+115 @0580fb>  : 19                         load.z32
	<rotation+116 @0580fc>  : 19                         load.z32
	<rotation+117 @0580fd>  : 19                         load.z32
	<rotation+118 @0580fe>  : 19                         load.z32
	<rotation+119 @0580ff>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+124 @058104>  : 02                         call
	<rotation+125 @058105>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+129 @058109>  : 15 11                      set.x128 sp(17)
	lib/std/math/Matrix4f.ci:119: (20 bytes: <@05810b> - <@05811f>): void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
	<rotation+131 @05810b>  : 09 10 00 00                inc.sp(+16)
	<rotation+135 @05810f>  : 19                         load.z32
	<rotation+136 @058110>  : 19                         load.z32
	<rotation+137 @058111>  : 19                         load.z32
	<rotation+138 @058112>  : 19                         load.z32
	<rotation+139 @058113>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+144 @058118>  : 02                         call
	<rotation+145 @058119>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+149 @05811d>  : 15 15                      set.x128 sp(21)
	<rotation+151 @05811f>  : 09 fc ff ff                inc.sp(-4)
	<rotation+155 @058123>  : 03                         ret
	lib/std/math/Matrix4f.ci:122: (6 bytes: <@058124> - <@05812a>): x: float32 := float32(direction.x / len)
	<rotation+156 @058124>  : 10 03                      dup.x32 sp(3)
	<rotation+158 @058126>  : 22                         load.i32
	<rotation+159 @058127>  : 10 01                      dup.x32 sp(1)
	<rotation+161 @058129>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:123: (10 bytes: <@05812a> - <@058134>): y: float32 := float32(direction.y / len)
	<rotation+162 @05812a>  : 10 04                      dup.x32 sp(4)
	<rotation+164 @05812c>  : 0c 04 00 00                inc.i32(+4)
	<rotation+168 @058130>  : 22                         load.i32
	<rotation+169 @058131>  : 10 02                      dup.x32 sp(2)
	<rotation+171 @058133>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:124: (10 bytes: <@058134> - <@05813e>): z: float32 := float32(direction.z / len)
	<rotation+172 @058134>  : 10 05                      dup.x32 sp(5)
	<rotation+174 @058136>  : 0c 08 00 00                inc.i32(+8)
	<rotation+178 @05813a>  : 22                         load.i32
	<rotation+179 @05813b>  : 10 03                      dup.x32 sp(3)
	<rotation+181 @05813d>  : 74                         div.f32
	lib/std/math/Matrix4f.ci:125: (3 bytes: <@05813e> - <@058141>): cx: float32 := center.x
	<rotation+182 @05813e>  : 10 07                      dup.x32 sp(7)
	<rotation+184 @058140>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:126: (7 bytes: <@058141> - <@058148>): cy: float32 := center.y
	<rotation+185 @058141>  : 10 08                      dup.x32 sp(8)
	<rotation+187 @058143>  : 0c 04 00 00                inc.i32(+4)
	<rotation+191 @058147>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:127: (7 bytes: <@058148> - <@05814f>): cz: float32 := center.z
	<rotation+192 @058148>  : 10 09                      dup.x32 sp(9)
	<rotation+194 @05814a>  : 0c 08 00 00                inc.i32(+8)
	<rotation+198 @05814e>  : 22                         load.i32
	lib/std/math/Matrix4f.ci:128: (5 bytes: <@05814f> - <@058154>): xx: float32 := float32(x * x)
	<rotation+199 @05814f>  : 10 05                      dup.x32 sp(5)
	<rotation+201 @058151>  : 10 06                      dup.x32 sp(6)
	<rotation+203 @058153>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:129: (5 bytes: <@058154> - <@058159>): xy: float32 := float32(x * y)
	<rotation+204 @058154>  : 10 06                      dup.x32 sp(6)
	<rotation+206 @058156>  : 10 06                      dup.x32 sp(6)
	<rotation+208 @058158>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:130: (5 bytes: <@058159> - <@05815e>): xz: float32 := float32(x * z)
	<rotation+209 @058159>  : 10 07                      dup.x32 sp(7)
	<rotation+211 @05815b>  : 10 06                      dup.x32 sp(6)
	<rotation+213 @05815d>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:131: (5 bytes: <@05815e> - <@058163>): yy: float32 := float32(y * y)
	<rotation+214 @05815e>  : 10 07                      dup.x32 sp(7)
	<rotation+216 @058160>  : 10 08                      dup.x32 sp(8)
	<rotation+218 @058162>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:132: (5 bytes: <@058163> - <@058168>): yz: float32 := float32(y * z)
	<rotation+219 @058163>  : 10 08                      dup.x32 sp(8)
	<rotation+221 @058165>  : 10 08                      dup.x32 sp(8)
	<rotation+223 @058167>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:133: (5 bytes: <@058168> - <@05816d>): zz: float32 := float32(z * z)
	<rotation+224 @058168>  : 10 08                      dup.x32 sp(8)
	<rotation+226 @05816a>  : 10 09                      dup.x32 sp(9)
	<rotation+228 @05816c>  : 73                         mul.f32
	lib/std/math/Matrix4f.ci:135: (6 bytes: <@05816d> - <@058173>): s: float32 := float32.sin(angle)
	<rotation+229 @05816d>  : 10 0e                      dup.x32 sp(14)
	<rotation+231 @05816f>  : 01 20 00 00                nfc(32) ;float32.sin(x: float32): float32
	lib/std/math/Matrix4f.ci:136: (6 bytes: <@058173> - <@058179>): c: float32 := float32.cos(angle)
	<rotation+235 @058173>  : 10 0f                      dup.x32 sp(15)
	<rotation+237 @058175>  : 01 21 00 00                nfc(33) ;float32.cos(x: float32): float32
	lib/std/math/Matrix4f.ci:137: (8 bytes: <@058179> - <@058181>): k: float32 := float32((1) - c)
	<rotation+241 @058179>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+246 @05817e>  : 10 01                      dup.x32 sp(1)
	<rotation+248 @058180>  : 72                         sub.f32
	lib/std/math/Matrix4f.ci:139: (275 bytes: <@058181> - <@058294>): return void(.result := {...});
	<rotation+249 @058181>  : 10 08                      dup.x32 sp(8)
	<rotation+251 @058183>  : 10 06                      dup.x32 sp(6)
	<rotation+253 @058185>  : 10 05                      dup.x32 sp(5)
	<rotation+255 @058187>  : 71                         add.f32
	<rotation+256 @058188>  : 10 03                      dup.x32 sp(3)
	<rotation+258 @05818a>  : 73                         mul.f32
	<rotation+259 @05818b>  : 71                         add.f32
	<rotation+260 @05818c>  : 13 15                      set.x32 sp(21)
	lib/std/math/Matrix4f.ci:141: (13 bytes: <@05818e> - <@05819b>): void(.result.xy := float32(float32(xy * k) - float32(z * s)));
	<rotation+262 @05818e>  : 10 07                      dup.x32 sp(7)
	<rotation+264 @058190>  : 10 01                      dup.x32 sp(1)
	<rotation+266 @058192>  : 73                         mul.f32
	<rotation+267 @058193>  : 10 0d                      dup.x32 sp(13)
	<rotation+269 @058195>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @058197>  : 73                         mul.f32
	<rotation+272 @058198>  : 72                         sub.f32
	<rotation+273 @058199>  : 13 16                      set.x32 sp(22)
	lib/std/math/Matrix4f.ci:142: (13 bytes: <@05819b> - <@0581a8>): void(.result.xz := float32(float32(xz * k) + float32(y * s)));
	<rotation+275 @05819b>  : 10 06                      dup.x32 sp(6)
	<rotation+277 @05819d>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @05819f>  : 73                         mul.f32
	<rotation+280 @0581a0>  : 10 0e                      dup.x32 sp(14)
	<rotation+282 @0581a2>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @0581a4>  : 73                         mul.f32
	<rotation+285 @0581a5>  : 71                         add.f32
	<rotation+286 @0581a6>  : 13 17                      set.x32 sp(23)
	lib/std/math/Matrix4f.ci:143: (43 bytes: <@0581a8> - <@0581d3>): void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
	<rotation+288 @0581a8>  : 10 0b                      dup.x32 sp(11)
	<rotation+290 @0581aa>  : 10 06                      dup.x32 sp(6)
	<rotation+292 @0581ac>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @0581ae>  : 71                         add.f32
	<rotation+295 @0581af>  : 73                         mul.f32
	<rotation+296 @0581b0>  : 10 0f                      dup.x32 sp(15)
	<rotation+298 @0581b2>  : 10 0c                      dup.x32 sp(12)
	<rotation+300 @0581b4>  : 10 10                      dup.x32 sp(16)
	<rotation+302 @0581b6>  : 73                         mul.f32
	<rotation+303 @0581b7>  : 10 0c                      dup.x32 sp(12)
	<rotation+305 @0581b9>  : 10 10                      dup.x32 sp(16)
	<rotation+307 @0581bb>  : 73                         mul.f32
	<rotation+308 @0581bc>  : 71                         add.f32
	<rotation+309 @0581bd>  : 73                         mul.f32
	<rotation+310 @0581be>  : 72                         sub.f32
	<rotation+311 @0581bf>  : 10 01                      dup.x32 sp(1)
	<rotation+313 @0581c1>  : 73                         mul.f32
	<rotation+314 @0581c2>  : 10 0b                      dup.x32 sp(11)
	<rotation+316 @0581c4>  : 10 0e                      dup.x32 sp(14)
	<rotation+318 @0581c6>  : 73                         mul.f32
	<rotation+319 @0581c7>  : 10 0b                      dup.x32 sp(11)
	<rotation+321 @0581c9>  : 10 10                      dup.x32 sp(16)
	<rotation+323 @0581cb>  : 73                         mul.f32
	<rotation+324 @0581cc>  : 72                         sub.f32
	<rotation+325 @0581cd>  : 10 04                      dup.x32 sp(4)
	<rotation+327 @0581cf>  : 73                         mul.f32
	<rotation+328 @0581d0>  : 71                         add.f32
	<rotation+329 @0581d1>  : 13 18                      set.x32 sp(24)
	lib/std/math/Matrix4f.ci:145: (13 bytes: <@0581d3> - <@0581e0>): void(.result.yx := float32(float32(xy * k) + float32(z * s)));
	<rotation+331 @0581d3>  : 10 07                      dup.x32 sp(7)
	<rotation+333 @0581d5>  : 10 01                      dup.x32 sp(1)
	<rotation+335 @0581d7>  : 73                         mul.f32
	<rotation+336 @0581d8>  : 10 0d                      dup.x32 sp(13)
	<rotation+338 @0581da>  : 10 04                      dup.x32 sp(4)
	<rotation+340 @0581dc>  : 73                         mul.f32
	<rotation+341 @0581dd>  : 71                         add.f32
	<rotation+342 @0581de>  : 13 19                      set.x32 sp(25)
	lib/std/math/Matrix4f.ci:146: (13 bytes: <@0581e0> - <@0581ed>): void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
	<rotation+344 @0581e0>  : 10 05                      dup.x32 sp(5)
	<rotation+346 @0581e2>  : 10 09                      dup.x32 sp(9)
	<rotation+348 @0581e4>  : 10 05                      dup.x32 sp(5)
	<rotation+350 @0581e6>  : 71                         add.f32
	<rotation+351 @0581e7>  : 10 03                      dup.x32 sp(3)
	<rotation+353 @0581e9>  : 73                         mul.f32
	<rotation+354 @0581ea>  : 71                         add.f32
	<rotation+355 @0581eb>  : 13 1a                      set.x32 sp(26)
	lib/std/math/Matrix4f.ci:147: (13 bytes: <@0581ed> - <@0581fa>): void(.result.yz := float32(float32(yz * k) - float32(x * s)));
	<rotation+357 @0581ed>  : 10 04                      dup.x32 sp(4)
	<rotation+359 @0581ef>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @0581f1>  : 73                         mul.f32
	<rotation+362 @0581f2>  : 10 0f                      dup.x32 sp(15)
	<rotation+364 @0581f4>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @0581f6>  : 73                         mul.f32
	<rotation+367 @0581f7>  : 72                         sub.f32
	<rotation+368 @0581f8>  : 13 1b                      set.x32 sp(27)
	lib/std/math/Matrix4f.ci:148: (43 bytes: <@0581fa> - <@058225>): void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
	<rotation+370 @0581fa>  : 10 0a                      dup.x32 sp(10)
	<rotation+372 @0581fc>  : 10 09                      dup.x32 sp(9)
	<rotation+374 @0581fe>  : 10 05                      dup.x32 sp(5)
	<rotation+376 @058200>  : 71                         add.f32
	<rotation+377 @058201>  : 73                         mul.f32
	<rotation+378 @058202>  : 10 0e                      dup.x32 sp(14)
	<rotation+380 @058204>  : 10 0d                      dup.x32 sp(13)
	<rotation+382 @058206>  : 10 11                      dup.x32 sp(17)
	<rotation+384 @058208>  : 73                         mul.f32
	<rotation+385 @058209>  : 10 0c                      dup.x32 sp(12)
	<rotation+387 @05820b>  : 10 10                      dup.x32 sp(16)
	<rotation+389 @05820d>  : 73                         mul.f32
	<rotation+390 @05820e>  : 71                         add.f32
	<rotation+391 @05820f>  : 73                         mul.f32
	<rotation+392 @058210>  : 72                         sub.f32
	<rotation+393 @058211>  : 10 01                      dup.x32 sp(1)
	<rotation+395 @058213>  : 73                         mul.f32
	<rotation+396 @058214>  : 10 0a                      dup.x32 sp(10)
	<rotation+398 @058216>  : 10 10                      dup.x32 sp(16)
	<rotation+400 @058218>  : 73                         mul.f32
	<rotation+401 @058219>  : 10 0d                      dup.x32 sp(13)
	<rotation+403 @05821b>  : 10 0f                      dup.x32 sp(15)
	<rotation+405 @05821d>  : 73                         mul.f32
	<rotation+406 @05821e>  : 72                         sub.f32
	<rotation+407 @05821f>  : 10 04                      dup.x32 sp(4)
	<rotation+409 @058221>  : 73                         mul.f32
	<rotation+410 @058222>  : 71                         add.f32
	<rotation+411 @058223>  : 13 1c                      set.x32 sp(28)
	lib/std/math/Matrix4f.ci:150: (13 bytes: <@058225> - <@058232>): void(.result.zx := float32(float32(xz * k) - float32(y * s)));
	<rotation+413 @058225>  : 10 06                      dup.x32 sp(6)
	<rotation+415 @058227>  : 10 01                      dup.x32 sp(1)
	<rotation+417 @058229>  : 73                         mul.f32
	<rotation+418 @05822a>  : 10 0e                      dup.x32 sp(14)
	<rotation+420 @05822c>  : 10 04                      dup.x32 sp(4)
	<rotation+422 @05822e>  : 73                         mul.f32
	<rotation+423 @05822f>  : 72                         sub.f32
	<rotation+424 @058230>  : 13 1d                      set.x32 sp(29)
	lib/std/math/Matrix4f.ci:151: (13 bytes: <@058232> - <@05823f>): void(.result.zy := float32(float32(yz * k) + float32(x * s)));
	<rotation+426 @058232>  : 10 04                      dup.x32 sp(4)
	<rotation+428 @058234>  : 10 01                      dup.x32 sp(1)
	<rotation+430 @058236>  : 73                         mul.f32
	<rotation+431 @058237>  : 10 0f                      dup.x32 sp(15)
	<rotation+433 @058239>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @05823b>  : 73                         mul.f32
	<rotation+436 @05823c>  : 71                         add.f32
	<rotation+437 @05823d>  : 13 1e                      set.x32 sp(30)
	lib/std/math/Matrix4f.ci:152: (13 bytes: <@05823f> - <@05824c>): void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
	<rotation+439 @05823f>  : 10 03                      dup.x32 sp(3)
	<rotation+441 @058241>  : 10 09                      dup.x32 sp(9)
	<rotation+443 @058243>  : 10 07                      dup.x32 sp(7)
	<rotation+445 @058245>  : 71                         add.f32
	<rotation+446 @058246>  : 10 03                      dup.x32 sp(3)
	<rotation+448 @058248>  : 73                         mul.f32
	<rotation+449 @058249>  : 71                         add.f32
	<rotation+450 @05824a>  : 13 1f                      set.x32 sp(31)
	lib/std/math/Matrix4f.ci:153: (43 bytes: <@05824c> - <@058277>): void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
	<rotation+452 @05824c>  : 10 09                      dup.x32 sp(9)
	<rotation+454 @05824e>  : 10 09                      dup.x32 sp(9)
	<rotation+456 @058250>  : 10 07                      dup.x32 sp(7)
	<rotation+458 @058252>  : 71                         add.f32
	<rotation+459 @058253>  : 73                         mul.f32
	<rotation+460 @058254>  : 10 0d                      dup.x32 sp(13)
	<rotation+462 @058256>  : 10 0d                      dup.x32 sp(13)
	<rotation+464 @058258>  : 10 11                      dup.x32 sp(17)
	<rotation+466 @05825a>  : 73                         mul.f32
	<rotation+467 @05825b>  : 10 0d                      dup.x32 sp(13)
	<rotation+469 @05825d>  : 10 11                      dup.x32 sp(17)
	<rotation+471 @05825f>  : 73                         mul.f32
	<rotation+472 @058260>  : 71                         add.f32
	<rotation+473 @058261>  : 73                         mul.f32
	<rotation+474 @058262>  : 72                         sub.f32
	<rotation+475 @058263>  : 10 01                      dup.x32 sp(1)
	<rotation+477 @058265>  : 73                         mul.f32
	<rotation+478 @058266>  : 10 0c                      dup.x32 sp(12)
	<rotation+480 @058268>  : 10 0f                      dup.x32 sp(15)
	<rotation+482 @05826a>  : 73                         mul.f32
	<rotation+483 @05826b>  : 10 0c                      dup.x32 sp(12)
	<rotation+485 @05826d>  : 10 11                      dup.x32 sp(17)
	<rotation+487 @05826f>  : 73                         mul.f32
	<rotation+488 @058270>  : 72                         sub.f32
	<rotation+489 @058271>  : 10 04                      dup.x32 sp(4)
	<rotation+491 @058273>  : 73                         mul.f32
	<rotation+492 @058274>  : 71                         add.f32
	<rotation+493 @058275>  : 13 20                      set.x32 sp(32)
	lib/std/math/Matrix4f.ci:155: (24 bytes: <@058277> - <@05828f>): void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
	<rotation+495 @058277>  : 09 10 00 00                inc.sp(+16)
	<rotation+499 @05827b>  : 19                         load.z32
	<rotation+500 @05827c>  : 19                         load.z32
	<rotation+501 @05827d>  : 19                         load.z32
	<rotation+502 @05827e>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+507 @058283>  : 1f c0 7e 05 00             load.ref <@057ec0> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<rotation+512 @058288>  : 02                         call
	<rotation+513 @058289>  : 09 f0 ff ff                inc.sp(-16)
	<rotation+517 @05828d>  : 15 24                      set.x128 sp(36)
	<rotation+519 @05828f>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+523 @058293>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:160: referenced as `rotation`
	lib/std/math/Matrix4f.ci:111: defined as `rotation(center: vec4f, direction: vec4f, angle: float32): mat4f`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'lib/std/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
	lib/std/math/Matrix4f.ci:160: defined as `rotation(direction: vec4f, angle: float32): mat4f`
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 88
.offset: <@058298>
.name: 'translation'
.file: 'lib/std/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (88 bytes: <@058298> - <@0582f0>)
	lib/std/math/Matrix4f.ci:164: (88 bytes: <@058298> - <@0582f0>): return void(.result := {...});
	<translation @058298>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @05829d>    : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:165: (3 bytes: <@05829f> - <@0582a2>): void(.result.x.y := (0));
	<translation+7 @05829f>    : 19                         load.z32
	<translation+8 @0582a0>    : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:165: (3 bytes: <@0582a2> - <@0582a5>): void(.result.x.z := (0));
	<translation+10 @0582a2>   : 19                         load.z32
	<translation+11 @0582a3>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:165: (8 bytes: <@0582a5> - <@0582ad>): void(.result.x.w := float32(direction.x * amount));
	<translation+13 @0582a5>   : 10 02                      dup.x32 sp(2)
	<translation+15 @0582a7>   : 22                         load.i32
	<translation+16 @0582a8>   : 10 02                      dup.x32 sp(2)
	<translation+18 @0582aa>   : 73                         mul.f32
	<translation+19 @0582ab>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:166: (3 bytes: <@0582ad> - <@0582b0>): void(.result.y.x := (0));
	<translation+21 @0582ad>   : 19                         load.z32
	<translation+22 @0582ae>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:166: (7 bytes: <@0582b0> - <@0582b7>): void(.result.y.y := (1));
	<translation+24 @0582b0>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @0582b5>   : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:166: (3 bytes: <@0582b7> - <@0582ba>): void(.result.y.z := (0));
	<translation+31 @0582b7>   : 19                         load.z32
	<translation+32 @0582b8>   : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:166: (12 bytes: <@0582ba> - <@0582c6>): void(.result.y.w := float32(direction.y * amount));
	<translation+34 @0582ba>   : 10 02                      dup.x32 sp(2)
	<translation+36 @0582bc>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @0582c0>   : 22                         load.i32
	<translation+41 @0582c1>   : 10 02                      dup.x32 sp(2)
	<translation+43 @0582c3>   : 73                         mul.f32
	<translation+44 @0582c4>   : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:167: (3 bytes: <@0582c6> - <@0582c9>): void(.result.z.x := (0));
	<translation+46 @0582c6>   : 19                         load.z32
	<translation+47 @0582c7>   : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:167: (3 bytes: <@0582c9> - <@0582cc>): void(.result.z.y := (0));
	<translation+49 @0582c9>   : 19                         load.z32
	<translation+50 @0582ca>   : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:167: (7 bytes: <@0582cc> - <@0582d3>): void(.result.z.z := (1));
	<translation+52 @0582cc>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @0582d1>   : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:167: (12 bytes: <@0582d3> - <@0582df>): void(.result.z.w := float32(direction.z * amount));
	<translation+59 @0582d3>   : 10 02                      dup.x32 sp(2)
	<translation+61 @0582d5>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @0582d9>   : 22                         load.i32
	<translation+66 @0582da>   : 10 02                      dup.x32 sp(2)
	<translation+68 @0582dc>   : 73                         mul.f32
	<translation+69 @0582dd>   : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@0582df> - <@0582e2>): void(.result.w.x := (0));
	<translation+71 @0582df>   : 19                         load.z32
	<translation+72 @0582e0>   : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@0582e2> - <@0582e5>): void(.result.w.y := (0));
	<translation+74 @0582e2>   : 19                         load.z32
	<translation+75 @0582e3>   : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:168: (3 bytes: <@0582e5> - <@0582e8>): void(.result.w.z := (0));
	<translation+77 @0582e5>   : 19                         load.z32
	<translation+78 @0582e6>   : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:168: (7 bytes: <@0582e8> - <@0582ef>): void(.result.w.w := (1));
	<translation+80 @0582e8>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @0582ed>   : 13 13                      set.x32 sp(19)
	<translation+87 @0582ef>   : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:163: defined as `translation(direction: vec4f, amount: float32): mat4f`
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 217
.offset: <@0582f0>
.name: 'scale'
.file: 'lib/std/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
}
.instructions: (217 bytes: <@0582f0> - <@0583c9>)
	lib/std/math/Matrix4f.ci:175: (217 bytes: <@0582f0> - <@0583c9>): return void(.result := {...});
	<scale @0582f0>      : 10 02                      dup.x32 sp(2)
	<scale+2 @0582f2>    : 22                         load.i32
	<scale+3 @0582f3>    : 10 02                      dup.x32 sp(2)
	<scale+5 @0582f5>    : 73                         mul.f32
	<scale+6 @0582f6>    : 10 00                      dup.x32 sp(0)
	<scale+8 @0582f8>    : 19                         load.z32
	<scale+9 @0582f9>    : 78                         clt.f32
	<scale+10 @0582fa>   : 06 0b 00 00                jz <scale+21 @058305>
	<scale+14 @0582fe>   : 10 00                      dup.x32 sp(0)
	<scale+16 @058300>   : 70                         neg.f32
	<scale+17 @058301>   : 04 06 00 00                jmp <scale+23 @058307>
	<scale+21 @058305>   : 10 00                      dup.x32 sp(0)
	<scale+23 @058307>   : 7d                         f32.2f64
	<scale+24 @058308>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @058311>   : 88                         clt.f64
	<scale+34 @058312>   : 06 09 00 00                jz <scale+43 @05831b>
	<scale+38 @058316>   : 19                         load.z32
	<scale+39 @058317>   : 04 0c 00 00                jmp <scale+51 @058323>
	<scale+43 @05831b>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @058320>   : 10 01                      dup.x32 sp(1)
	<scale+50 @058322>   : 74                         div.f32
	<scale+51 @058323>   : 13 01                      set.x32 sp(1)
	<scale+53 @058325>   : 13 04                      set.x32 sp(4)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@058327> - <@05832a>): void(.result.x.y := (0));
	<scale+55 @058327>   : 19                         load.z32
	<scale+56 @058328>   : 13 05                      set.x32 sp(5)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@05832a> - <@05832d>): void(.result.x.z := (0));
	<scale+58 @05832a>   : 19                         load.z32
	<scale+59 @05832b>   : 13 06                      set.x32 sp(6)
	lib/std/math/Matrix4f.ci:176: (3 bytes: <@05832d> - <@058330>): void(.result.x.w := (0));
	<scale+61 @05832d>   : 19                         load.z32
	<scale+62 @05832e>   : 13 07                      set.x32 sp(7)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@058330> - <@058333>): void(.result.y.x := (0));
	<scale+64 @058330>   : 19                         load.z32
	<scale+65 @058331>   : 13 08                      set.x32 sp(8)
	lib/std/math/Matrix4f.ci:177: (59 bytes: <@058333> - <@05836e>): void(.result.y.y := rcp(float32(direction.y * amount)));
	<scale+67 @058333>   : 10 02                      dup.x32 sp(2)
	<scale+69 @058335>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @058339>   : 22                         load.i32
	<scale+74 @05833a>   : 10 02                      dup.x32 sp(2)
	<scale+76 @05833c>   : 73                         mul.f32
	<scale+77 @05833d>   : 10 00                      dup.x32 sp(0)
	<scale+79 @05833f>   : 19                         load.z32
	<scale+80 @058340>   : 78                         clt.f32
	<scale+81 @058341>   : 06 0b 00 00                jz <scale+92 @05834c>
	<scale+85 @058345>   : 10 00                      dup.x32 sp(0)
	<scale+87 @058347>   : 70                         neg.f32
	<scale+88 @058348>   : 04 06 00 00                jmp <scale+94 @05834e>
	<scale+92 @05834c>   : 10 00                      dup.x32 sp(0)
	<scale+94 @05834e>   : 7d                         f32.2f64
	<scale+95 @05834f>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @058358>  : 88                         clt.f64
	<scale+105 @058359>  : 06 09 00 00                jz <scale+114 @058362>
	<scale+109 @05835d>  : 19                         load.z32
	<scale+110 @05835e>  : 04 0c 00 00                jmp <scale+122 @05836a>
	<scale+114 @058362>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @058367>  : 10 01                      dup.x32 sp(1)
	<scale+121 @058369>  : 74                         div.f32
	<scale+122 @05836a>  : 13 01                      set.x32 sp(1)
	<scale+124 @05836c>  : 13 09                      set.x32 sp(9)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@05836e> - <@058371>): void(.result.y.z := (0));
	<scale+126 @05836e>  : 19                         load.z32
	<scale+127 @05836f>  : 13 0a                      set.x32 sp(10)
	lib/std/math/Matrix4f.ci:177: (3 bytes: <@058371> - <@058374>): void(.result.y.w := (0));
	<scale+129 @058371>  : 19                         load.z32
	<scale+130 @058372>  : 13 0b                      set.x32 sp(11)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@058374> - <@058377>): void(.result.z.x := (0));
	<scale+132 @058374>  : 19                         load.z32
	<scale+133 @058375>  : 13 0c                      set.x32 sp(12)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@058377> - <@05837a>): void(.result.z.y := (0));
	<scale+135 @058377>  : 19                         load.z32
	<scale+136 @058378>  : 13 0d                      set.x32 sp(13)
	lib/std/math/Matrix4f.ci:178: (59 bytes: <@05837a> - <@0583b5>): void(.result.z.z := rcp(float32(direction.z * amount)));
	<scale+138 @05837a>  : 10 02                      dup.x32 sp(2)
	<scale+140 @05837c>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @058380>  : 22                         load.i32
	<scale+145 @058381>  : 10 02                      dup.x32 sp(2)
	<scale+147 @058383>  : 73                         mul.f32
	<scale+148 @058384>  : 10 00                      dup.x32 sp(0)
	<scale+150 @058386>  : 19                         load.z32
	<scale+151 @058387>  : 78                         clt.f32
	<scale+152 @058388>  : 06 0b 00 00                jz <scale+163 @058393>
	<scale+156 @05838c>  : 10 00                      dup.x32 sp(0)
	<scale+158 @05838e>  : 70                         neg.f32
	<scale+159 @05838f>  : 04 06 00 00                jmp <scale+165 @058395>
	<scale+163 @058393>  : 10 00                      dup.x32 sp(0)
	<scale+165 @058395>  : 7d                         f32.2f64
	<scale+166 @058396>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @05839f>  : 88                         clt.f64
	<scale+176 @0583a0>  : 06 09 00 00                jz <scale+185 @0583a9>
	<scale+180 @0583a4>  : 19                         load.z32
	<scale+181 @0583a5>  : 04 0c 00 00                jmp <scale+193 @0583b1>
	<scale+185 @0583a9>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @0583ae>  : 10 01                      dup.x32 sp(1)
	<scale+192 @0583b0>  : 74                         div.f32
	<scale+193 @0583b1>  : 13 01                      set.x32 sp(1)
	<scale+195 @0583b3>  : 13 0e                      set.x32 sp(14)
	lib/std/math/Matrix4f.ci:178: (3 bytes: <@0583b5> - <@0583b8>): void(.result.z.w := (0));
	<scale+197 @0583b5>  : 19                         load.z32
	<scale+198 @0583b6>  : 13 0f                      set.x32 sp(15)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@0583b8> - <@0583bb>): void(.result.w.x := (0));
	<scale+200 @0583b8>  : 19                         load.z32
	<scale+201 @0583b9>  : 13 10                      set.x32 sp(16)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@0583bb> - <@0583be>): void(.result.w.y := (0));
	<scale+203 @0583bb>  : 19                         load.z32
	<scale+204 @0583bc>  : 13 11                      set.x32 sp(17)
	lib/std/math/Matrix4f.ci:179: (3 bytes: <@0583be> - <@0583c1>): void(.result.w.z := (0));
	<scale+206 @0583be>  : 19                         load.z32
	<scale+207 @0583bf>  : 13 12                      set.x32 sp(18)
	lib/std/math/Matrix4f.ci:179: (7 bytes: <@0583c1> - <@0583c8>): void(.result.w.w := (1));
	<scale+209 @0583c1>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @0583c6>  : 13 13                      set.x32 sp(19)
	<scale+216 @0583c8>  : 03                         ret
.usages:
	lib/std/math/Matrix4f.ci:173: defined as `scale(direction: vec4f, amount: float32): mat4f`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0288d0>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:2'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `vec2d`
	lib/std/math/Vector2d.ci:43: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:40: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:37: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:34: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:31: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:28: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:25: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:22: referenced as `vec2d`
	lib/std/math/Vector2d.ci:14: referenced as `vec2d`
	lib/std/math/Vector2d.ci:2: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/std/math/Vector2d.ci:4'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/std/math/Vector2d.ci:4: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/std/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/std/math/Vector2d.ci:44: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `x`
	lib/std/math/Vector2d.ci:43: referenced as `x`
	lib/std/math/Vector2d.ci:16: referenced as `x`
	lib/std/math/Vector2d.ci:7: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/std/math/Vector2d.ci:43: referenced as `y`
	lib/std/math/Vector2d.ci:43: referenced as `y`
	lib/std/math/Vector2d.ci:17: referenced as `y`
	lib/std/math/Vector2d.ci:9: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/std/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/std/math/Vector2d.ci:9'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0583d0>
.name: 'vec2d'
.file: 'lib/std/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@0583d0> - <@0583d7>)
	lib/std/math/Vector2d.ci:15: (7 bytes: <@0583d0> - <@0583d7>): return void(.result := {...});
	<vec2d @0583d0>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math/Vector2d.ci:17: (3 bytes: <@0583d3> - <@0583d6>): void(.result.y := y);
	<vec2d+3 @0583d3>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @0583d6>    : 03                         ret
.usages:
	lib/std/math/Vector2d.ci:14: defined as `vec2d(x: float64, y: float64): vec2d`
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	lib/std/math/Vector2d.ci:22: defined as `add(a: vec2d, b: vec2d): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/std/math/Vector2d.ci:25: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
	lib/std/math/Vector2d.ci:28: defined as `mul(a: vec2d, b: vec2d): vec2d`
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
	lib/std/math/Vector2d.ci:31: defined as `div(a: vec2d, b: vec2d): vec2d`
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/std/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
	lib/std/math/Vector2d.ci:34: defined as `min(a: vec2d, b: vec2d): vec2d`
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/std/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
	lib/std/math/Vector2d.ci:37: defined as `max(a: vec2d, b: vec2d): vec2d`
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'lib/std/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
	lib/std/math/Vector2d.ci:40: defined as `ceq(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/std/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/std/math/Vector2d.ci:43: defined as `dot(a: vec2d, b: vec2d): float64`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@0583d8>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@0583d8> - <@0583fe>)
	lib/std/string.ci:5: (16 bytes: <@0583d8> - <@0583e8>): if (bool((str) == null))
	<length @0583d8>      : 10 01                      dup.x32 sp(1)
	<length+2 @0583da>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @0583df>    : 57                         ceq.i32
	<length+8 @0583e0>    : 06 08 00 00                jz <length+16 @0583e8>
	lib/std/string.ci:6: (4 bytes: <@0583e4> - <@0583e8>): return int32(.result := 0);
	<length+12 @0583e4>   : 19                         load.z32
	<length+13 @0583e5>   : 13 03                      set.x32 sp(3)
	<length+15 @0583e7>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@0583e8> - <@0583e9>): result: int32 := 0
	<length+16 @0583e8>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@0583e9> - <@0583fb>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @0583e9>   : 04 08 00 00                jmp <length+25 @0583f1>
	lib/std/string.ci:9: (4 bytes: <@0583ed> - <@0583f1>): int32(result := int32(result + 1))
	<length+21 @0583ed>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@0583f1> - <@0583fb>): str[result]
	<length+25 @0583f1>   : 10 02                      dup.x32 sp(2)
	<length+27 @0583f3>   : 10 01                      dup.x32 sp(1)
	<length+29 @0583f5>   : 51                         add.i32
	<length+30 @0583f6>   : 20                         load.i8
	<length+31 @0583f7>   : 05 f6 ff ff                jnz <length+21 @0583ed>
	lib/std/string.ci:11: (3 bytes: <@0583fb> - <@0583fe>): return int32(.result := result);
	<length+35 @0583fb>   : 13 03                      set.x32 sp(3)
	<length+37 @0583fd>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@058400>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@058400> - <@058432>)
	lib/std/string.ci:16: (42 bytes: <@058400> - <@05842a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @058400>      : 19                         load.z32
	<indexOf+1 @058401>    : 04 1b 00 00                jmp <indexOf+28 @05841c>
	lib/std/string.ci:17: (19 bytes: <@058405> - <@058418>): if (bool(str[i] == chr))
	<indexOf+5 @058405>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @058407>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @058409>    : 51                         add.i32
	<indexOf+10 @05840a>   : 20                         load.i8
	<indexOf+11 @05840b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @05840f>   : 20                         load.i8
	<indexOf+16 @058410>   : 57                         ceq.i32
	<indexOf+17 @058411>   : 06 07 00 00                jz <indexOf+24 @058418>
	lib/std/string.ci:18: (3 bytes: <@058415> - <@058418>): return int32(.result := i);
	<indexOf+21 @058415>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @058417>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@058418> - <@05841c>): int32(i := int32(i + 1))
	<indexOf+24 @058418>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@05841c> - <@058426>): str[i]
	<indexOf+28 @05841c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @05841e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @058420>   : 51                         add.i32
	<indexOf+33 @058421>   : 20                         load.i8
	<indexOf+34 @058422>   : 05 e3 ff ff                jnz <indexOf+5 @058405>
	<indexOf+38 @058426>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@05842a> - <@058432>): return int32(.result := int32(-1));
	<indexOf+42 @05842a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @05842f>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @058431>   : 03                         ret
.usages:
	lib/std/string.ci:98: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@058438>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@058438> - <@05846a>)
	lib/std/string.ci:26: (5 bytes: <@058438> - <@05843d>): result: int32 := int32(-1)
	<lastIndexOf @058438>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@05843d> - <@058467>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @05843d>    : 19                         load.z32
	<lastIndexOf+6 @05843e>    : 04 1b 00 00                jmp <lastIndexOf+33 @058459>
	lib/std/string.ci:28: (19 bytes: <@058442> - <@058455>): if (bool(str[i] == chr))
	<lastIndexOf+10 @058442>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @058444>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @058446>   : 51                         add.i32
	<lastIndexOf+15 @058447>   : 20                         load.i8
	<lastIndexOf+16 @058448>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @05844c>   : 20                         load.i8
	<lastIndexOf+21 @05844d>   : 57                         ceq.i32
	<lastIndexOf+22 @05844e>   : 06 07 00 00                jz <lastIndexOf+29 @058455>
	lib/std/string.ci:29: (3 bytes: <@058452> - <@058455>): int32(result := i);
	<lastIndexOf+26 @058452>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@058455> - <@058459>): int32(i := int32(i + 1))
	<lastIndexOf+29 @058455>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@058459> - <@058463>): str[i]
	<lastIndexOf+33 @058459>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @05845b>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @05845d>   : 51                         add.i32
	<lastIndexOf+38 @05845e>   : 20                         load.i8
	<lastIndexOf+39 @05845f>   : 05 e3 ff ff                jnz <lastIndexOf+10 @058442>
	<lastIndexOf+43 @058463>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@058467> - <@05846a>): return int32(.result := result);
	<lastIndexOf+47 @058467>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @058469>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@058470>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@058470> - <@0584b9>)
	lib/std/string.ci:37: (62 bytes: <@058470> - <@0584ae>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @058470>      : 19                         load.z32
	<startsWith+1 @058471>    : 04 2d 00 00                jmp <startsWith+46 @05849e>
	lib/std/string.ci:38: (37 bytes: <@058475> - <@05849a>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @058475>    : 19                         load.z32
	<startsWith+6 @058476>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @058478>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @05847a>   : 51                         add.i32
	<startsWith+11 @05847b>   : 20                         load.i8
	<startsWith+12 @05847c>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @05847e>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @058480>   : 51                         add.i32
	<startsWith+17 @058481>   : 20                         load.i8
	<startsWith+18 @058482>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @058484>   : 02                         call
	<startsWith+21 @058485>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @058489>   : 19                         load.z32
	<startsWith+26 @05848a>   : 57                         ceq.i32
	<startsWith+27 @05848b>   : 05 0f 00 00                jnz <startsWith+42 @05849a>
	lib/std/string.ci:39: (11 bytes: <@05848f> - <@05849a>): return bool(.result := false);
	<startsWith+31 @05848f>   : 19                         load.z32
	<startsWith+32 @058490>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @058494>   : 25                         store.i8
	<startsWith+37 @058495>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @058499>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@05849a> - <@05849e>): int32(i := int32(i + 1))
	<startsWith+42 @05849a>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@05849e> - <@0584aa>): bool((with[i]) != 0)
	<startsWith+46 @05849e>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @0584a0>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @0584a2>   : 51                         add.i32
	<startsWith+51 @0584a3>   : 20                         load.i8
	<startsWith+52 @0584a4>   : 19                         load.z32
	<startsWith+53 @0584a5>   : 57                         ceq.i32
	<startsWith+54 @0584a6>   : 06 cf ff ff                jz <startsWith+5 @058475>
	<startsWith+58 @0584aa>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@0584ae> - <@0584b9>): return bool(.result := true);
	<startsWith+62 @0584ae>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @0584b3>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @0584b7>   : 25                         store.i8
	<startsWith+72 @0584b8>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@0584c0>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@0584c0> - <@05853e>)
	lib/std/string.ci:47: (13 bytes: <@0584c0> - <@0584cd>): withLen: int32 := length(with)
	<endsWith @0584c0>      : 19                         load.z32
	<endsWith+1 @0584c1>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @0584c3>    : 1f d8 83 05 00             load.ref <@0583d8> ;length(str: char[*]): int32
	<endsWith+8 @0584c8>    : 02                         call
	<endsWith+9 @0584c9>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@0584cd> - <@0584da>): strLen: int32 := length(str)
	<endsWith+13 @0584cd>   : 19                         load.z32
	<endsWith+14 @0584ce>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @0584d0>   : 1f d8 83 05 00             load.ref <@0583d8> ;length(str: char[*]): int32
	<endsWith+21 @0584d5>   : 02                         call
	<endsWith+22 @0584d6>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@0584da> - <@0584ee>): if (bool(strLen < withLen))
	<endsWith+26 @0584da>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @0584dc>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @0584de>   : 58                         clt.i32
	<endsWith+31 @0584df>   : 06 0f 00 00                jz <endsWith+46 @0584ee>
	lib/std/string.ci:50: (11 bytes: <@0584e3> - <@0584ee>): return bool(.result := false);
	<endsWith+35 @0584e3>   : 19                         load.z32
	<endsWith+36 @0584e4>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @0584e8>   : 25                         store.i8
	<endsWith+41 @0584e9>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @0584ed>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@0584ee> - <@05852f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @0584ee>   : 19                         load.z32
	<endsWith+47 @0584ef>   : 04 33 00 00                jmp <endsWith+98 @058522>
	lib/std/string.ci:53: (43 bytes: <@0584f3> - <@05851e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @0584f3>   : 19                         load.z32
	<endsWith+52 @0584f4>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @0584f6>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @0584f8>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @0584fa>   : 52                         sub.i32
	<endsWith+59 @0584fb>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @0584fd>   : 51                         add.i32
	<endsWith+62 @0584fe>   : 51                         add.i32
	<endsWith+63 @0584ff>   : 20                         load.i8
	<endsWith+64 @058500>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @058502>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @058504>   : 51                         add.i32
	<endsWith+69 @058505>   : 20                         load.i8
	<endsWith+70 @058506>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @058508>   : 02                         call
	<endsWith+73 @058509>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @05850d>   : 19                         load.z32
	<endsWith+78 @05850e>   : 57                         ceq.i32
	<endsWith+79 @05850f>   : 05 0f 00 00                jnz <endsWith+94 @05851e>
	lib/std/string.ci:54: (11 bytes: <@058513> - <@05851e>): return bool(.result := false);
	<endsWith+83 @058513>   : 19                         load.z32
	<endsWith+84 @058514>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @058518>   : 25                         store.i8
	<endsWith+89 @058519>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @05851d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@05851e> - <@058522>): int32(i := int32(i + 1))
	<endsWith+94 @05851e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@058522> - <@05852b>): bool(i < withLen)
	<endsWith+98 @058522>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @058524>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @058526>  : 58                         clt.i32
	<endsWith+103 @058527>  : 05 cc ff ff                jnz <endsWith+51 @0584f3>
	<endsWith+107 @05852b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@05852f> - <@05853e>): return bool(.result := true);
	<endsWith+111 @05852f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @058534>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @058538>  : 25                         store.i8
	<endsWith+121 @058539>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @05853d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@058540>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@058540> - <@05857f>)
	lib/std/string.ci:62: (1 byte: <@058540> - <@058541>): result: int32 := 0
	<compare @058540>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@058541> - <@05857c>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @058541>    : 19                         load.z32
	<compare+2 @058542>    : 04 2e 00 00                jmp <compare+48 @058570>
	lib/std/string.ci:64: (22 bytes: <@058546> - <@05855c>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @058546>    : 19                         load.z32
	<compare+7 @058547>    : 10 06                      dup.x32 sp(6)
	<compare+9 @058549>    : 10 02                      dup.x32 sp(2)
	<compare+11 @05854b>   : 51                         add.i32
	<compare+12 @05854c>   : 20                         load.i8
	<compare+13 @05854d>   : 10 06                      dup.x32 sp(6)
	<compare+15 @05854f>   : 10 03                      dup.x32 sp(3)
	<compare+17 @058551>   : 51                         add.i32
	<compare+18 @058552>   : 20                         load.i8
	<compare+19 @058553>   : 10 06                      dup.x32 sp(6)
	<compare+21 @058555>   : 02                         call
	<compare+22 @058556>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @05855a>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@05855c> - <@05856c>): if (bool((str[i]) == 0))
	<compare+28 @05855c>   : 10 05                      dup.x32 sp(5)
	<compare+30 @05855e>   : 10 01                      dup.x32 sp(1)
	<compare+32 @058560>   : 51                         add.i32
	<compare+33 @058561>   : 20                         load.i8
	<compare+34 @058562>   : 19                         load.z32
	<compare+35 @058563>   : 57                         ceq.i32
	<compare+36 @058564>   : 06 08 00 00                jz <compare+44 @05856c>
	lib/std/string.ci:66: (4 bytes: <@058568> - <@05856c>): break;
	<compare+40 @058568>   : 04 10 00 00                jmp <compare+56 @058578>
	lib/std/string.ci:63: (4 bytes: <@05856c> - <@058570>): int32(i := int32(i + 1))
	<compare+44 @05856c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@058570> - <@058578>): bool(result == 0)
	<compare+48 @058570>   : 10 01                      dup.x32 sp(1)
	<compare+50 @058572>   : 19                         load.z32
	<compare+51 @058573>   : 57                         ceq.i32
	<compare+52 @058574>   : 05 d2 ff ff                jnz <compare+6 @058546>
	<compare+56 @058578>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@05857c> - <@05857f>): return int32(.result := result);
	<compare+60 @05857c>   : 13 05                      set.x32 sp(5)
	<compare+62 @05857e>   : 03                         ret
.usages:
	lib/std/string.ci:95: referenced as `compare`
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@0585c8>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@0585c8> - <@0585ec>)
	lib/std/string.ci:84: (36 bytes: <@0585c8> - <@0585ec>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @0585c8>      : 19                         load.z32
	<ignCaseCmp+1 @0585c9>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @0585cd>    : 20                         load.i8
	<ignCaseCmp+6 @0585ce>    : 1f 80 85 05 00             load.ref <@058580> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @0585d3>   : 02                         call
	<ignCaseCmp+12 @0585d4>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @0585d8>   : 19                         load.z32
	<ignCaseCmp+17 @0585d9>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @0585dd>   : 20                         load.i8
	<ignCaseCmp+22 @0585de>   : 1f 80 85 05 00             load.ref <@058580> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @0585e3>   : 02                         call
	<ignCaseCmp+28 @0585e4>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @0585e8>   : 52                         sub.i32
	<ignCaseCmp+33 @0585e9>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @0585eb>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@0585f0>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@0585f0> - <@0585fe>)
	lib/std/string.ci:89: (14 bytes: <@0585f0> - <@0585fe>): return char(.result := char(chr - with));
	<caseCmp @0585f0>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @0585f4>    : 20                         load.i8
	<caseCmp+5 @0585f5>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @0585f9>    : 20                         load.i8
	<caseCmp+10 @0585fa>   : 52                         sub.i32
	<caseCmp+11 @0585fb>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @0585fd>   : 03                         ret
.usages:
	lib/std/string.ci:95: referenced as `caseCmp`
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'lib/std/string.ci:95'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
	lib/std/string.ci:95: defined as `equals(str: char[*], with: char[*]): bool`
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:98'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:182: referenced as `contains`
	lib/std/string.ci:98: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02df78>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:112'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:263: referenced as `FormatFlags`
	lib/std/string.ci:259: referenced as `FormatFlags`
	lib/std/string.ci:241: referenced as `FormatFlags`
	lib/std/string.ci:235: referenced as `FormatFlags`
	lib/std/string.ci:234: referenced as `FormatFlags`
	lib/std/string.ci:231: referenced as `FormatFlags`
	lib/std/string.ci:229: referenced as `FormatFlags`
	lib/std/string.ci:227: referenced as `FormatFlags`
	lib/std/string.ci:225: referenced as `FormatFlags`
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:221: referenced as `FormatFlags`
	lib/std/string.ci:219: referenced as `FormatFlags`
	lib/std/string.ci:217: referenced as `FormatFlags`
	lib/std/string.ci:144: referenced as `FormatFlags`
	lib/std/string.ci:112: defined as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'lib/std/string.ci:114'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	lib/std/string.ci:242: referenced as `showSign`
	lib/std/string.ci:236: referenced as `showSign`
	lib/std/string.ci:236: referenced as `showSign`
	lib/std/string.ci:151: referenced as `showSign`
	lib/std/string.ci:114: defined as `showSign`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'lib/std/string.ci:117'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	lib/std/string.ci:253: referenced as `precision`
	lib/std/string.ci:243: referenced as `precision`
	lib/std/string.ci:245: referenced as `precision`
	lib/std/string.ci:237: referenced as `precision`
	lib/std/string.ci:239: referenced as `precision`
	lib/std/string.ci:157: referenced as `precision`
	lib/std/string.ci:117: defined as `precision`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'lib/std/string.ci:120'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:244: referenced as `padChr`
	lib/std/string.ci:238: referenced as `padChr`
	lib/std/string.ci:238: referenced as `padChr`
	lib/std/string.ci:174: referenced as `padChr`
	lib/std/string.ci:120: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'lib/std/string.ci:123'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:245: referenced as `padLen`
	lib/std/string.ci:239: referenced as `padLen`
	lib/std/string.ci:239: referenced as `padLen`
	lib/std/string.ci:172: referenced as `padLen`
	lib/std/string.ci:123: defined as `padLen`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@058600>
.name: 'append'
.file: 'lib/std/string.ci:127'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@058600> - <@058654>)
	lib/std/string.ci:128: (56 bytes: <@058600> - <@058638>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @058600>      : 19                         load.z32
	<append+1 @058601>    : 04 29 00 00                jmp <append+42 @05862a>
	lib/std/string.ci:129: (13 bytes: <@058605> - <@058612>): if (bool(pos >= (output.length)))
	<append+5 @058605>    : 10 03                      dup.x32 sp(3)
	<append+7 @058607>    : 10 06                      dup.x32 sp(6)
	<append+9 @058609>    : 58                         clt.i32
	<append+10 @05860a>   : 05 08 00 00                jnz <append+18 @058612>
	lib/std/string.ci:130: (4 bytes: <@05860e> - <@058612>): break;
	<append+14 @05860e>   : 04 26 00 00                jmp <append+52 @058634>
	lib/std/string.ci:132: (12 bytes: <@058612> - <@05861e>): char(output[pos] := value[i]);
	<append+18 @058612>   : 10 02                      dup.x32 sp(2)
	<append+20 @058614>   : 10 01                      dup.x32 sp(1)
	<append+22 @058616>   : 51                         add.i32
	<append+23 @058617>   : 20                         load.i8
	<append+24 @058618>   : 10 05                      dup.x32 sp(5)
	<append+26 @05861a>   : 10 05                      dup.x32 sp(5)
	<append+28 @05861c>   : 51                         add.i32
	<append+29 @05861d>   : 25                         store.i8
	lib/std/string.ci:133: (8 bytes: <@05861e> - <@058626>): int32(pos := int32(pos + 1));
	<append+30 @05861e>   : 10 03                      dup.x32 sp(3)
	<append+32 @058620>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @058624>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:128: (4 bytes: <@058626> - <@05862a>): int32(i := int32(i + 1))
	<append+38 @058626>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:128: (10 bytes: <@05862a> - <@058634>): value[i]
	<append+42 @05862a>   : 10 02                      dup.x32 sp(2)
	<append+44 @05862c>   : 10 01                      dup.x32 sp(1)
	<append+46 @05862e>   : 51                         add.i32
	<append+47 @05862f>   : 20                         load.i8
	<append+48 @058630>   : 05 d5 ff ff                jnz <append+5 @058605>
	<append+52 @058634>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:136: (17 bytes: <@058638> - <@058649>): if (bool(pos >= (output.length)))
	<append+56 @058638>   : 10 02                      dup.x32 sp(2)
	<append+58 @05863a>   : 10 05                      dup.x32 sp(5)
	<append+60 @05863c>   : 58                         clt.i32
	<append+61 @05863d>   : 05 0c 00 00                jnz <append+73 @058649>
	lib/std/string.ci:137: (8 bytes: <@058641> - <@058649>): int32(pos := (uint32(output.length - (1))));
	<append+65 @058641>   : 10 04                      dup.x32 sp(4)
	<append+67 @058643>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @058647>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:139: (7 bytes: <@058649> - <@058650>): char(output[pos] := (0));
	<append+73 @058649>   : 19                         load.z32
	<append+74 @05864a>   : 10 04                      dup.x32 sp(4)
	<append+76 @05864c>   : 10 04                      dup.x32 sp(4)
	<append+78 @05864e>   : 51                         add.i32
	<append+79 @05864f>   : 25                         store.i8
	lib/std/string.ci:140: (4 bytes: <@058650> - <@058654>): return int32(.result := pos);
	<append+80 @058650>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @058653>   : 03                         ret
.usages:
	lib/std/string.ci:252: referenced as `append`
	lib/std/string.ci:127: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 707
.offset: <@058668>
.name: 'append'
.file: 'lib/std/string.ci:144'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <@058668> - <@05892b>)
	lib/std/string.ci:148: (1 byte: <@058668> - <@058669>): len: int32 := 0
	<append @058668>      : 19                         load.z32
	lib/std/string.ci:149: (4 bytes: <@058669> - <@05866d>): digits: char[80]
	<append+1 @058669>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:151: (28 bytes: <@05866d> - <@058689>): if (format.showSign)
	<append+5 @05866d>    : 10 16                      dup.x32 sp(22)
	<append+7 @05866f>    : 20                         load.i8
	<append+8 @058670>    : 06 19 00 00                jz <append+33 @058689>
	lib/std/string.ci:152: (21 bytes: <@058674> - <@058689>): if (bool((sign) == 0))
	<append+12 @058674>   : 0a 64 00 00                load.sp(+100)
	<append+16 @058678>   : 20                         load.i8
	<append+17 @058679>   : 19                         load.z32
	<append+18 @05867a>   : 57                         ceq.i32
	<append+19 @05867b>   : 06 0e 00 00                jz <append+33 @058689>
	lib/std/string.ci:153: (10 bytes: <@05867f> - <@058689>): char(sign := '+');
	<append+23 @05867f>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @058684>   : 0a 68 00 00                load.sp(+104)
	<append+32 @058688>   : 25                         store.i8
	lib/std/string.ci:157: (7 bytes: <@058689> - <@058690>): radix: int32 := format.precision
	<append+33 @058689>   : 10 16                      dup.x32 sp(22)
	<append+35 @05868b>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @05868f>   : 22                         load.i32
	lib/std/string.ci:158: (15 bytes: <@058690> - <@05869f>): if (bool(radix == 0))
	<append+40 @058690>   : 10 00                      dup.x32 sp(0)
	<append+42 @058692>   : 19                         load.z32
	<append+43 @058693>   : 57                         ceq.i32
	<append+44 @058694>   : 06 0b 00 00                jz <append+55 @05869f>
	lib/std/string.ci:159: (7 bytes: <@058698> - <@05869f>): int32(radix := 10);
	<append+48 @058698>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @05869d>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:161: (54 bytes: <@05869f> - <@0586d5>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+55 @05869f>   : 10 00                      dup.x32 sp(0)
	<append+57 @0586a1>   : 1c 01 00 00 00             load.c32 1
	<append+62 @0586a6>   : 59                         cgt.i32
	<append+63 @0586a7>   : 06 08 00 00                jz <append+71 @0586af>
	<append+67 @0586ab>   : 04 2a 00 00                jmp <append+109 @0586d5>
	<append+71 @0586af>   : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+76 @0586b4>   : 1c a1 00 00 00             load.c32 161
	<append+81 @0586b9>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @0586be>   : 1c 80 00 00 00             load.c32 128
	<append+91 @0586c3>   : 1f 27 a7 02 00             load.ref <@02a727> ;"radix is too small"
	<append+96 @0586c8>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+101 @0586cd>  : 0a 18 00 00                load.sp(+24)
	<append+105 @0586d1>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (53 bytes: <@0586d5> - <@05870a>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+109 @0586d5>  : 10 00                      dup.x32 sp(0)
	<append+111 @0586d7>  : 2a 64 86 05                load.m32 <@058664> ;append.radixDigits+4
	<append+115 @0586db>  : 58                         clt.i32
	<append+116 @0586dc>  : 06 08 00 00                jz <append+124 @0586e4>
	<append+120 @0586e0>  : 04 2a 00 00                jmp <append+162 @05870a>
	<append+124 @0586e4>  : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+129 @0586e9>  : 1c a2 00 00 00             load.c32 162
	<append+134 @0586ee>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @0586f3>  : 1c 80 00 00 00             load.c32 128
	<append+144 @0586f8>  : 1f 3a a7 02 00             load.ref <@02a73a> ;"radix is too big"
	<append+149 @0586fd>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+154 @058702>  : 0a 18 00 00                load.sp(+24)
	<append+158 @058706>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:165: (49 bytes: <@05870a> - <@05873b>): for ( ; bool(value > (0)); uint64(value := uint64(value / (radix))))
	<append+162 @05870a>  : 04 29 00 00                jmp <append+203 @058733>
	lib/std/string.ci:166: (29 bytes: <@05870e> - <@05872b>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	<append+166 @05870e>  : 2a 60 86 05                load.m32 <@058660> ;append.radixDigits
	<append+170 @058712>  : 11 19                      dup.x64 sp(25)
	<append+172 @058714>  : 10 03                      dup.x32 sp(3)
	<append+174 @058716>  : 5b                         i32.2i64
	<append+175 @058717>  : 45                         mod.u64
	<append+176 @058718>  : 6a                         i64.2i32
	<append+177 @058719>  : 51                         add.i32
	<append+178 @05871a>  : 20                         load.i8
	<append+179 @05871b>  : 0a 08 00 00                load.sp(+8)
	<append+183 @05871f>  : 10 17                      dup.x32 sp(23)
	<append+185 @058721>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @058725>  : 10 00                      dup.x32 sp(0)
	<append+191 @058727>  : 13 19                      set.x32 sp(25)
	<append+193 @058729>  : 51                         add.i32
	<append+194 @05872a>  : 25                         store.i8
	lib/std/string.ci:165: (8 bytes: <@05872b> - <@058733>): uint64(value := uint64(value / (radix)))
	<append+195 @05872b>  : 11 18                      dup.x64 sp(24)
	<append+197 @05872d>  : 10 02                      dup.x32 sp(2)
	<append+199 @05872f>  : 5b                         i32.2i64
	<append+200 @058730>  : 44                         div.u64
	<append+201 @058731>  : 14 1a                      set.x64 sp(26)
	lib/std/string.ci:165: (8 bytes: <@058733> - <@05873b>): bool(value > (0))
	<append+203 @058733>  : 11 18                      dup.x64 sp(24)
	<append+205 @058735>  : 1a                         load.z64
	<append+206 @058736>  : 49                         cgt.u64
	<append+207 @058737>  : 05 d7 ff ff                jnz <append+166 @05870e>
	lib/std/string.ci:168: (29 bytes: <@05873b> - <@058758>): if (bool(len == 0))
	<append+211 @05873b>  : 10 15                      dup.x32 sp(21)
	<append+213 @05873d>  : 19                         load.z32
	<append+214 @05873e>  : 57                         ceq.i32
	<append+215 @05873f>  : 06 19 00 00                jz <append+240 @058758>
	lib/std/string.ci:169: (21 bytes: <@058743> - <@058758>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+219 @058743>  : 1c 30 00 00 00             load.c32 48
	<append+224 @058748>  : 0a 08 00 00                load.sp(+8)
	<append+228 @05874c>  : 10 17                      dup.x32 sp(23)
	<append+230 @05874e>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @058752>  : 10 00                      dup.x32 sp(0)
	<append+236 @058754>  : 13 19                      set.x32 sp(25)
	<append+238 @058756>  : 51                         add.i32
	<append+239 @058757>  : 25                         store.i8
	lib/std/string.ci:172: (10 bytes: <@058758> - <@058762>): maxLen: int32 := int32(format.padLen - len)
	<append+240 @058758>  : 10 17                      dup.x32 sp(23)
	<append+242 @05875a>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @05875e>  : 22                         load.i32
	<append+247 @05875f>  : 10 16                      dup.x32 sp(22)
	<append+249 @058761>  : 52                         sub.i32
	lib/std/string.ci:174: (7 bytes: <@058762> - <@058769>): padChr: char := format.padChr
	<append+250 @058762>  : 10 18                      dup.x32 sp(24)
	<append+252 @058764>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @058768>  : 20                         load.i8
	lib/std/string.ci:175: (21 bytes: <@058769> - <@05877e>): if (bool(padChr == ''))
	<append+257 @058769>  : 0a 00 00 00                load.sp(+0)
	<append+261 @05876d>  : 20                         load.i8
	<append+262 @05876e>  : 19                         load.z32
	<append+263 @05876f>  : 57                         ceq.i32
	<append+264 @058770>  : 06 0e 00 00                jz <append+278 @05877e>
	lib/std/string.ci:176: (10 bytes: <@058774> - <@05877e>): char(padChr := ' ');
	<append+268 @058774>  : 1c 20 00 00 00             load.c32 32
	<append+273 @058779>  : 0a 04 00 00                load.sp(+4)
	<append+277 @05877d>  : 25                         store.i8
	lib/std/string.ci:180: (207 bytes: <@05877e> - <@05884d>): if (bool((sign) != 0))
	<append+278 @05877e>  : 0a 70 00 00                load.sp(+112)
	<append+282 @058782>  : 20                         load.i8
	<append+283 @058783>  : 19                         load.z32
	<append+284 @058784>  : 57                         ceq.i32
	<append+285 @058785>  : 05 c8 00 00                jnz <append+485 @05884d>
	lib/std/string.ci:181: (8 bytes: <@058789> - <@058791>): int32(maxLen := int32(maxLen - 1));
	<append+289 @058789>  : 10 01                      dup.x32 sp(1)
	<append+291 @05878b>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @05878f>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:182: (117 bytes: <@058791> - <@058806>): if (contains(void(whiteSpace, padChr)))
	<append+297 @058791>  : 19                         load.z32
	<append+298 @058792>  : 2a 58 86 05                load.m32 <@058658> ;append.whiteSpace
	<append+302 @058796>  : 0a 08 00 00                load.sp(+8)
	<append+306 @05879a>  : 20                         load.i8
	<append+307 @05879b>  : 1f 00 84 05 00             load.ref <@058400> ;indexOf(str: char[*], chr: char): int32
	<append+312 @0587a0>  : 02                         call
	<append+313 @0587a1>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @0587a5>  : 19                         load.z32
	<append+318 @0587a6>  : 58                         clt.i32
	<append+319 @0587a7>  : 05 5f 00 00                jnz <append+414 @058806>
	lib/std/string.ci:184: (91 bytes: <@0587ab> - <@058806>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+323 @0587ab>  : 04 53 00 00                jmp <append+406 @0587fe>
	lib/std/string.ci:185: (52 bytes: <@0587af> - <@0587e3>): assert(bool(pos < (output.length)));
	<append+327 @0587af>  : 10 1d                      dup.x32 sp(29)
	<append+329 @0587b1>  : 10 20                      dup.x32 sp(32)
	<append+331 @0587b3>  : 58                         clt.i32
	<append+332 @0587b4>  : 06 08 00 00                jz <append+340 @0587bc>
	<append+336 @0587b8>  : 04 2b 00 00                jmp <append+379 @0587e3>
	<append+340 @0587bc>  : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+345 @0587c1>  : 1c b9 00 00 00             load.c32 185
	<append+350 @0587c6>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @0587cb>  : 1c 80 00 00 00             load.c32 128
	<append+360 @0587d0>  : 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<append+365 @0587d5>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+370 @0587da>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @0587df>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:186: (11 bytes: <@0587e3> - <@0587ee>): char(output[pos] := padChr);
	<append+379 @0587e3>  : 0a 00 00 00                load.sp(+0)
	<append+383 @0587e7>  : 20                         load.i8
	<append+384 @0587e8>  : 10 1f                      dup.x32 sp(31)
	<append+386 @0587ea>  : 10 1f                      dup.x32 sp(31)
	<append+388 @0587ec>  : 51                         add.i32
	<append+389 @0587ed>  : 25                         store.i8
	lib/std/string.ci:187: (8 bytes: <@0587ee> - <@0587f6>): int32(pos := int32(pos + 1));
	<append+390 @0587ee>  : 10 1d                      dup.x32 sp(29)
	<append+392 @0587f0>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @0587f4>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:184: (8 bytes: <@0587f6> - <@0587fe>): int32(maxLen := int32(maxLen - 1))
	<append+398 @0587f6>  : 10 01                      dup.x32 sp(1)
	<append+400 @0587f8>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @0587fc>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:184: (8 bytes: <@0587fe> - <@058806>): bool(maxLen > 0)
	<append+406 @0587fe>  : 10 01                      dup.x32 sp(1)
	<append+408 @058800>  : 19                         load.z32
	<append+409 @058801>  : 59                         cgt.i32
	<append+410 @058802>  : 05 ad ff ff                jnz <append+327 @0587af>
	lib/std/string.ci:190: (52 bytes: <@058806> - <@05883a>): assert(bool(pos < (output.length)));
	<append+414 @058806>  : 10 1d                      dup.x32 sp(29)
	<append+416 @058808>  : 10 20                      dup.x32 sp(32)
	<append+418 @05880a>  : 58                         clt.i32
	<append+419 @05880b>  : 06 08 00 00                jz <append+427 @058813>
	<append+423 @05880f>  : 04 2b 00 00                jmp <append+466 @05883a>
	<append+427 @058813>  : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+432 @058818>  : 1c be 00 00 00             load.c32 190
	<append+437 @05881d>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @058822>  : 1c 80 00 00 00             load.c32 128
	<append+447 @058827>  : 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<append+452 @05882c>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+457 @058831>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @058836>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:191: (11 bytes: <@05883a> - <@058845>): char(output[pos] := sign);
	<append+466 @05883a>  : 0a 70 00 00                load.sp(+112)
	<append+470 @05883e>  : 20                         load.i8
	<append+471 @05883f>  : 10 1f                      dup.x32 sp(31)
	<append+473 @058841>  : 10 1f                      dup.x32 sp(31)
	<append+475 @058843>  : 51                         add.i32
	<append+476 @058844>  : 25                         store.i8
	lib/std/string.ci:192: (8 bytes: <@058845> - <@05884d>): int32(pos := int32(pos + 1));
	<append+477 @058845>  : 10 1d                      dup.x32 sp(29)
	<append+479 @058847>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @05884b>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:196: (91 bytes: <@05884d> - <@0588a8>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+485 @05884d>  : 04 53 00 00                jmp <append+568 @0588a0>
	lib/std/string.ci:197: (52 bytes: <@058851> - <@058885>): assert(bool(pos < (output.length)));
	<append+489 @058851>  : 10 1d                      dup.x32 sp(29)
	<append+491 @058853>  : 10 20                      dup.x32 sp(32)
	<append+493 @058855>  : 58                         clt.i32
	<append+494 @058856>  : 06 08 00 00                jz <append+502 @05885e>
	<append+498 @05885a>  : 04 2b 00 00                jmp <append+541 @058885>
	<append+502 @05885e>  : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+507 @058863>  : 1c c5 00 00 00             load.c32 197
	<append+512 @058868>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @05886d>  : 1c 80 00 00 00             load.c32 128
	<append+522 @058872>  : 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<append+527 @058877>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+532 @05887c>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @058881>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:198: (11 bytes: <@058885> - <@058890>): char(output[pos] := padChr);
	<append+541 @058885>  : 0a 00 00 00                load.sp(+0)
	<append+545 @058889>  : 20                         load.i8
	<append+546 @05888a>  : 10 1f                      dup.x32 sp(31)
	<append+548 @05888c>  : 10 1f                      dup.x32 sp(31)
	<append+550 @05888e>  : 51                         add.i32
	<append+551 @05888f>  : 25                         store.i8
	lib/std/string.ci:199: (8 bytes: <@058890> - <@058898>): int32(pos := int32(pos + 1));
	<append+552 @058890>  : 10 1d                      dup.x32 sp(29)
	<append+554 @058892>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @058896>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:196: (8 bytes: <@058898> - <@0588a0>): int32(maxLen := int32(maxLen - 1))
	<append+560 @058898>  : 10 01                      dup.x32 sp(1)
	<append+562 @05889a>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @05889e>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:196: (8 bytes: <@0588a0> - <@0588a8>): bool(maxLen > 0)
	<append+568 @0588a0>  : 10 01                      dup.x32 sp(1)
	<append+570 @0588a2>  : 19                         load.z32
	<append+571 @0588a3>  : 59                         cgt.i32
	<append+572 @0588a4>  : 05 ad ff ff                jnz <append+489 @058851>
	lib/std/string.ci:203: (99 bytes: <@0588a8> - <@05890b>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+576 @0588a8>  : 19                         load.z32
	<append+577 @0588a9>  : 04 55 00 00                jmp <append+662 @0588fe>
	lib/std/string.ci:204: (52 bytes: <@0588ad> - <@0588e1>): assert(bool(i < (output.length)));
	<append+581 @0588ad>  : 10 00                      dup.x32 sp(0)
	<append+583 @0588af>  : 10 21                      dup.x32 sp(33)
	<append+585 @0588b1>  : 58                         clt.i32
	<append+586 @0588b2>  : 06 08 00 00                jz <append+594 @0588ba>
	<append+590 @0588b6>  : 04 2b 00 00                jmp <append+633 @0588e1>
	<append+594 @0588ba>  : 1f 88 a3 02 00             load.ref <@02a388> ;"lib/std/string.ci"
	<append+599 @0588bf>  : 1c cc 00 00 00             load.c32 204
	<append+604 @0588c4>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @0588c9>  : 1c 80 00 00 00             load.c32 128
	<append+614 @0588ce>  : 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<append+619 @0588d3>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+624 @0588d8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @0588dd>  : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:205: (17 bytes: <@0588e1> - <@0588f2>): char(output[pos] := digits[int32(len - i)]);
	<append+633 @0588e1>  : 0a 10 00 00                load.sp(+16)
	<append+637 @0588e5>  : 10 19                      dup.x32 sp(25)
	<append+639 @0588e7>  : 10 02                      dup.x32 sp(2)
	<append+641 @0588e9>  : 52                         sub.i32
	<append+642 @0588ea>  : 51                         add.i32
	<append+643 @0588eb>  : 20                         load.i8
	<append+644 @0588ec>  : 10 20                      dup.x32 sp(32)
	<append+646 @0588ee>  : 10 20                      dup.x32 sp(32)
	<append+648 @0588f0>  : 51                         add.i32
	<append+649 @0588f1>  : 25                         store.i8
	lib/std/string.ci:206: (8 bytes: <@0588f2> - <@0588fa>): int32(pos := int32(pos + 1));
	<append+650 @0588f2>  : 10 1e                      dup.x32 sp(30)
	<append+652 @0588f4>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @0588f8>  : 13 1f                      set.x32 sp(31)
	lib/std/string.ci:203: (4 bytes: <@0588fa> - <@0588fe>): int32(i := int32(i + 1))
	<append+658 @0588fa>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:203: (9 bytes: <@0588fe> - <@058907>): bool(i < len)
	<append+662 @0588fe>  : 10 00                      dup.x32 sp(0)
	<append+664 @058900>  : 10 19                      dup.x32 sp(25)
	<append+666 @058902>  : 58                         clt.i32
	<append+667 @058903>  : 05 aa ff ff                jnz <append+581 @0588ad>
	<append+671 @058907>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:209: (17 bytes: <@05890b> - <@05891c>): if (bool(pos >= (output.length)))
	<append+675 @05890b>  : 10 1d                      dup.x32 sp(29)
	<append+677 @05890d>  : 10 20                      dup.x32 sp(32)
	<append+679 @05890f>  : 58                         clt.i32
	<append+680 @058910>  : 05 0c 00 00                jnz <append+692 @05891c>
	lib/std/string.ci:210: (8 bytes: <@058914> - <@05891c>): int32(pos := (uint32(output.length - (1))));
	<append+684 @058914>  : 10 1f                      dup.x32 sp(31)
	<append+686 @058916>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @05891a>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:212: (7 bytes: <@05891c> - <@058923>): char(output[pos] := (0));
	<append+692 @05891c>  : 19                         load.z32
	<append+693 @05891d>  : 10 1f                      dup.x32 sp(31)
	<append+695 @05891f>  : 10 1f                      dup.x32 sp(31)
	<append+697 @058921>  : 51                         add.i32
	<append+698 @058922>  : 25                         store.i8
	lib/std/string.ci:213: (8 bytes: <@058923> - <@05892b>): return int32(.result := pos);
	<append+699 @058923>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @058926>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @05892a>  : 03                         ret
.usages:
	lib/std/string.ci:254: referenced as `append`
	lib/std/string.ci:250: referenced as `append`
	lib/std/string.ci:231: referenced as `append`
	lib/std/string.ci:229: referenced as `append`
	lib/std/string.ci:227: referenced as `append`
	lib/std/string.ci:225: referenced as `append`
	lib/std/string.ci:223: referenced as `append`
	lib/std/string.ci:221: referenced as `append`
	lib/std/string.ci:219: referenced as `append`
	lib/std/string.ci:217: referenced as `append`
	lib/std/string.ci:144: defined as `append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:217'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:217: defined as `append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:219'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:219: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:221'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:221: defined as `append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
	lib/std/string.ci:223: defined as `append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:225'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
	lib/std/string.ci:225: defined as `append(output: char[], pos: int32, value: int64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:227'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	lib/std/string.ci:264: referenced as `append`
	lib/std/string.ci:227: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:229'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
	lib/std/string.ci:229: defined as `append(output: char[], pos: int32, value: int16, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:231'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
	lib/std/string.ci:231: defined as `append(output: char[], pos: int32, value: int8, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 227
.offset: <@058930>
.name: 'append'
.file: 'lib/std/string.ci:234'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
	return int32(.result := pos);
}
.instructions: (227 bytes: <@058930> - <@058a13>)
	lib/std/string.ci:235: (44 bytes: <@058930> - <@05895c>): formatInt: FormatFlags := {...}
	<append @058930>      : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:236: (8 bytes: <@058934> - <@05893c>): void(formatInt.showSign := format.showSign);
	<append+4 @058934>    : 10 05                      dup.x32 sp(5)
	<append+6 @058936>    : 20                         load.i8
	<append+7 @058937>    : 0a 04 00 00                load.sp(+4)
	<append+11 @05893b>   : 25                         store.i8
	lib/std/string.ci:237: (3 bytes: <@05893c> - <@05893f>): void(formatInt.precision := 0);
	<append+12 @05893c>   : 19                         load.z32
	<append+13 @05893d>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:238: (12 bytes: <@05893f> - <@05894b>): void(formatInt.padChr := format.padChr);
	<append+15 @05893f>   : 10 05                      dup.x32 sp(5)
	<append+17 @058941>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @058945>   : 20                         load.i8
	<append+22 @058946>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @05894a>   : 25                         store.i8
	lib/std/string.ci:239: (17 bytes: <@05894b> - <@05895c>): void(formatInt.padLen := int32(format.padLen - format.precision));
	<append+27 @05894b>   : 10 05                      dup.x32 sp(5)
	<append+29 @05894d>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @058951>   : 22                         load.i32
	<append+34 @058952>   : 10 06                      dup.x32 sp(6)
	<append+36 @058954>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @058958>   : 22                         load.i32
	<append+41 @058959>   : 52                         sub.i32
	<append+42 @05895a>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:241: (32 bytes: <@05895c> - <@05897c>): formatDec: FormatFlags := {...}
	<append+44 @05895c>   : 09 10 00 00                inc.sp(+16)
	lib/std/string.ci:242: (6 bytes: <@058960> - <@058966>): void(formatDec.showSign := false);
	<append+48 @058960>   : 19                         load.z32
	<append+49 @058961>   : 0a 04 00 00                load.sp(+4)
	<append+53 @058965>   : 25                         store.i8
	lib/std/string.ci:243: (3 bytes: <@058966> - <@058969>): void(formatDec.precision := 0);
	<append+54 @058966>   : 19                         load.z32
	<append+55 @058967>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:244: (10 bytes: <@058969> - <@058973>): void(formatDec.padChr := '0');
	<append+57 @058969>   : 1c 30 00 00 00             load.c32 48
	<append+62 @05896e>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @058972>   : 25                         store.i8
	lib/std/string.ci:245: (9 bytes: <@058973> - <@05897c>): void(formatDec.padLen := format.precision);
	<append+67 @058973>   : 10 09                      dup.x32 sp(9)
	<append+69 @058975>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @058979>   : 22                         load.i32
	<append+74 @05897a>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:248: (18 bytes: <@05897c> - <@05898e>): sign: char := bool(value < (0)) ? ('-') : 0
	<append+76 @05897c>   : 11 0a                      dup.x64 sp(10)
	<append+78 @05897e>   : 1a                         load.z64
	<append+79 @05897f>   : 88                         clt.f64
	<append+80 @058980>   : 06 0d 00 00                jz <append+93 @05898d>
	<append+84 @058984>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @058989>   : 04 05 00 00                jmp <append+94 @05898e>
	<append+93 @05898d>   : 19                         load.z32
	lib/std/string.ci:249: (27 bytes: <@05898e> - <@0589a9>): fract: float64 := Math.modf(void(Math.abs(value), float64(&value)))
	<append+94 @05898e>   : 1b                         load.z128
	<append+95 @05898f>   : 11 0f                      dup.x64 sp(15)
	<append+97 @058991>   : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<append+102 @058996>  : 02                         call
	<append+103 @058997>  : 09 f8 ff ff                inc.sp(-8)
	<append+107 @05899b>  : 0a 3c 00 00                load.sp(+60)
	<append+111 @05899f>  : 1f d0 75 05 00             load.ref <@0575d0> ;Math.modf(x: float64, intPart: float64): float64
	<append+116 @0589a4>  : 02                         call
	<append+117 @0589a5>  : 09 f4 ff ff                inc.sp(-12)
	lib/std/string.ci:250: (29 bytes: <@0589a9> - <@0589c6>): int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
	<append+121 @0589a9>  : 19                         load.z32
	<append+122 @0589aa>  : 11 11                      dup.x64 sp(17)
	<append+124 @0589ac>  : 10 12                      dup.x32 sp(18)
	<append+126 @0589ae>  : 0a 18 00 00                load.sp(+24)
	<append+130 @0589b2>  : 20                         load.i8
	<append+131 @0589b3>  : 11 12                      dup.x64 sp(18)
	<append+133 @0589b5>  : 8b                         f64.2i64
	<append+134 @0589b6>  : 0a 38 00 00                load.sp(+56)
	<append+138 @0589ba>  : 1f 68 86 05 00             load.ref <@058668> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+143 @0589bf>  : 02                         call
	<append+144 @0589c0>  : 09 e4 ff ff                inc.sp(-28)
	<append+148 @0589c4>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:252: (22 bytes: <@0589c6> - <@0589dc>): int32(pos := append(void(output, void(pos, "."))));
	<append+150 @0589c6>  : 19                         load.z32
	<append+151 @0589c7>  : 11 11                      dup.x64 sp(17)
	<append+153 @0589c9>  : 10 12                      dup.x32 sp(18)
	<append+155 @0589cb>  : 1f a0 a7 02 00             load.ref <@02a7a0> ;"."
	<append+160 @0589d0>  : 1f 00 86 05 00             load.ref <@058600> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+165 @0589d5>  : 02                         call
	<append+166 @0589d6>  : 09 f0 ff ff                inc.sp(-16)
	<append+170 @0589da>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:253: (22 bytes: <@0589dc> - <@0589f2>): float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	<append+172 @0589dc>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+181 @0589e5>  : 10 0e                      dup.x32 sp(14)
	<append+183 @0589e7>  : 0c 04 00 00                inc.i32(+4)
	<append+187 @0589eb>  : 22                         load.i32
	<append+188 @0589ec>  : 5d                         i32.2f64
	<append+189 @0589ed>  : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<append+193 @0589f1>  : 83                         mul.f64
	lib/std/string.ci:254: (25 bytes: <@0589f2> - <@058a0b>): int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
	<append+194 @0589f2>  : 19                         load.z32
	<append+195 @0589f3>  : 11 11                      dup.x64 sp(17)
	<append+197 @0589f5>  : 10 12                      dup.x32 sp(18)
	<append+199 @0589f7>  : 19                         load.z32
	<append+200 @0589f8>  : 11 05                      dup.x64 sp(5)
	<append+202 @0589fa>  : 8b                         f64.2i64
	<append+203 @0589fb>  : 0a 28 00 00                load.sp(+40)
	<append+207 @0589ff>  : 1f 68 86 05 00             load.ref <@058668> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+212 @058a04>  : 02                         call
	<append+213 @058a05>  : 09 e4 ff ff                inc.sp(-28)
	<append+217 @058a09>  : 13 10                      set.x32 sp(16)
	lib/std/string.ci:255: (8 bytes: <@058a0b> - <@058a13>): return int32(.result := pos);
	<append+219 @058a0b>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+222 @058a0e>  : 09 d4 ff ff                inc.sp(-44)
	<append+226 @058a12>  : 03                         ret
.usages:
	lib/std/string.ci:259: referenced as `append`
	lib/std/string.ci:234: defined as `append(output: char[], pos: int32, value: float64, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'lib/std/string.ci:259'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
	lib/std/string.ci:259: defined as `append(output: char[], pos: int32, value: float32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@058a28>
.name: 'append'
.file: 'lib/std/string.ci:262'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <@058a28> - <@058a67>)
	lib/std/string.ci:264: (63 bytes: <@058a28> - <@058a67>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @058a28>      : 10 01                      dup.x32 sp(1)
	<append+2 @058a2a>    : 19                         load.z32
	<append+3 @058a2b>    : 11 05                      dup.x64 sp(5)
	<append+5 @058a2d>    : 10 06                      dup.x32 sp(6)
	<append+7 @058a2f>    : 10 04                      dup.x32 sp(4)
	<append+9 @058a31>    : 19                         load.z32
	<append+10 @058a32>   : 58                         clt.i32
	<append+11 @058a33>   : 06 0d 00 00                jz <append+24 @058a40>
	<append+15 @058a37>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @058a3c>   : 04 05 00 00                jmp <append+25 @058a41>
	<append+24 @058a40>   : 19                         load.z32
	<append+25 @058a41>   : 10 05                      dup.x32 sp(5)
	<append+27 @058a43>   : 19                         load.z32
	<append+28 @058a44>   : 58                         clt.i32
	<append+29 @058a45>   : 06 0b 00 00                jz <append+40 @058a50>
	<append+33 @058a49>   : 10 05                      dup.x32 sp(5)
	<append+35 @058a4b>   : 50                         neg.i32
	<append+36 @058a4c>   : 04 06 00 00                jmp <append+42 @058a52>
	<append+40 @058a50>   : 10 05                      dup.x32 sp(5)
	<append+42 @058a52>   : 5b                         i32.2i64
	<append+43 @058a53>   : 1f 18 8a 05 00             load.ref <@058a18> ;append.format
	<append+48 @058a58>   : 1f 68 86 05 00             load.ref <@058668> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @058a5d>   : 02                         call
	<append+54 @058a5e>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @058a62>   : 13 01                      set.x32 sp(1)
	<append+60 @058a64>   : 13 06                      set.x32 sp(6)
	<append+62 @058a66>   : 03                         ret
.usages:
	lib/std/string.ci:262: defined as `append(output: char[], pos: int32, value: int32): int32`
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a68>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058a70>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a78>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a80>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a88>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a90>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058a98>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058aa0>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058aa8>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058ab0>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@058ab8>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ac0>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ac8>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ad0>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ad8>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ae0>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ae8>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058af0>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058af8>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b00>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b08>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b10>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b18>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b20>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b28>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b30>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b38>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b40>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b48>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b50>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b58>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b60>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b68>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b70>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b78>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b80>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b88>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b90>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058b98>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ba0>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ba8>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bb0>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bb8>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bc0>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bc8>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bd0>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bd8>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058be0>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058be8>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bf0>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058bf8>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c00>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c08>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c10>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c18>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c20>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058c28>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058c30>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058c38>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058c40>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058c48>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@058c50>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@038380>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0384b0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@058c58>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@058c60>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058c68>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@058c70>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058c78>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058c80>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058c88>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@058c90>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@058c98>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@058ca0>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058ca8>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058cb0>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058cb8>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@058cc0>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@058cc8>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058cd0>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058cd8>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ce0>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058ce8>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@058cf0>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@058cf8>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d00>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058d08>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058d10>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d18>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d20>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d28>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d30>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d38>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d40>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d48>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d50>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d58>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d60>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d68>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d70>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d78>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d80>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d88>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d90>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058d98>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058da0>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058da8>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058db0>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058db8>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058dc0>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058dc8>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058dd0>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058dd8>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058de0>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058de8>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058df0>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058df8>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e00>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e08>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e10>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e18>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e20>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e28>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058e30>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e38>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e40>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e48>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e50>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e58>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e60>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e68>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e70>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e78>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e80>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e88>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e90>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058e98>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ea0>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ea8>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058eb0>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058eb8>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ec0>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058ec8>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058ed0>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ed8>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@058ee0>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@058ee8>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@058ef0>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@058ef8>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@058ef8> - <@058ef9>)
	<empty @058ef8>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@058f00>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@058f00> - <@058f08>)
	test/lang/function.ci:8: (8 bytes: <@058f00> - <@058f08>): return int32(.result := int32(x + y));
	<funAdd @058f00>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @058f02>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @058f04>    : 51                         add.i32
	<funAdd+5 @058f05>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @058f07>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f08>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@058f10>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f18>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@058f20>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f28>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@058f30>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f38>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@058f40>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@058f40> - <@058f48>)
	test/lang/function.ci:34: (8 bytes: <@058f40> - <@058f48>): return int32(.result := int32(x * y));
	<funMul @058f40>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @058f42>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @058f44>    : 53                         mul.i32
	<funMul+5 @058f45>    : 13 04                      set.x32 sp(4)
	<funMul+7 @058f47>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@058f48>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@058f48> - <@058f7e>)
	test/lang/function.ci:39: (16 bytes: <@058f48> - <@058f58>): if (bool(n <= (1)))
	<fib @058f48>      : 10 01                      dup.x32 sp(1)
	<fib+2 @058f4a>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @058f4f>    : 39                         cgt.u32
	<fib+8 @058f50>    : 05 08 00 00                jnz <fib+16 @058f58>
	test/lang/function.ci:40: (4 bytes: <@058f54> - <@058f58>): return uint32(.result := n);
	<fib+12 @058f54>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @058f57>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@058f58> - <@058f7e>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @058f58>   : 19                         load.z32
	<fib+17 @058f59>   : 10 02                      dup.x32 sp(2)
	<fib+19 @058f5b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @058f5f>   : 1f 48 8f 05 00             load.ref <@058f48> ;fib(n: uint32): uint32
	<fib+28 @058f64>   : 02                         call
	<fib+29 @058f65>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @058f69>   : 19                         load.z32
	<fib+34 @058f6a>   : 10 03                      dup.x32 sp(3)
	<fib+36 @058f6c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @058f70>   : 1f 48 8f 05 00             load.ref <@058f48> ;fib(n: uint32): uint32
	<fib+45 @058f75>   : 02                         call
	<fib+46 @058f76>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @058f7a>   : 51                         add.i32
	<fib+51 @058f7b>   : 13 03                      set.x32 sp(3)
	<fib+53 @058f7d>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@058f80>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f88>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f90>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058f98>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fa0>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fa8>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fb0>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fb8>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fc0>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fc8>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fd0>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fd8>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fe0>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058fe8>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ff0>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@058ff8>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059000>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059008>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059010>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@03e318>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006b50>, cast: static const inline)
.field as: function (size: 0, offs: <@006de8>, cast: static const inline)
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006de8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@03e448>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006b50>, cast: static const inline)
.field as: function (size: 0, offs: <@006de8>, cast: static const inline)
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006de8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@059018>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@059020>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059028>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059030>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@059038>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059040>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@059048>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@059050>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059058>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059060>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@059068>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059070>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@059078>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059080>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059088>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@059090>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059098>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590a0>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0590a8>
.name: 'pi64'
.file: 'test/std/number.ci:3'
.value: 3.141593
.usages:
	test/std/number.ci:44: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:43: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:42: referenced as `pi64`
	test/std/number.ci:39: referenced as `pi64`
	test/std/number.ci:38: referenced as `pi64`
	test/std/number.ci:37: referenced as `pi64`
	test/std/number.ci:6: referenced as `pi64`
	test/std/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0590b0>
.name: 'e64'
.file: 'test/std/number.ci:4'
.value: 2.718282
.usages:
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:40: referenced as `e64`
	test/std/number.ci:7: referenced as `e64`
	test/std/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0590b8>
.name: 'pi32'
.file: 'test/std/number.ci:6'
.value: pi64
.usages:
	test/std/number.ci:53: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:52: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:51: referenced as `pi32`
	test/std/number.ci:48: referenced as `pi32`
	test/std/number.ci:47: referenced as `pi32`
	test/std/number.ci:46: referenced as `pi32`
	test/std/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0590c0>
.name: 'e32'
.file: 'test/std/number.ci:7'
.value: e64
.usages:
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:49: referenced as `e32`
	test/std/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/std/number.ci:19: referenced as `rgb888`
	test/std/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/std/number.ci:18: referenced as `rgb565`
	test/std/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590c8>
.name: 'r_comp'
.file: 'test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/std/number.ci:19: referenced as `r_comp`
	test/std/number.ci:18: referenced as `r_comp`
	test/std/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590d0>
.name: 'g_comp'
.file: 'test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/std/number.ci:19: referenced as `g_comp`
	test/std/number.ci:18: referenced as `g_comp`
	test/std/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590d8>
.name: 'b_comp'
.file: 'test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/std/number.ci:19: referenced as `b_comp`
	test/std/number.ci:18: referenced as `b_comp`
	test/std/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590e0>
.name: 'r5g6b5'
.file: 'test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:66: referenced as `r5g6b5`
	test/std/number.ci:65: referenced as `r5g6b5`
	test/std/number.ci:63: referenced as `r5g6b5`
	test/std/number.ci:62: referenced as `r5g6b5`
	test/std/number.ci:60: referenced as `r5g6b5`
	test/std/number.ci:59: referenced as `r5g6b5`
	test/std/number.ci:58: referenced as `r5g6b5`
	test/std/number.ci:57: referenced as `r5g6b5`
	test/std/number.ci:56: referenced as `r5g6b5`
	test/std/number.ci:55: referenced as `r5g6b5`
	test/std/number.ci:27: referenced as `r5g6b5`
	test/std/number.ci:26: referenced as `r5g6b5`
	test/std/number.ci:25: referenced as `r5g6b5`
	test/std/number.ci:23: referenced as `r5g6b5`
	test/std/number.ci:22: referenced as `r5g6b5`
	test/std/number.ci:21: referenced as `r5g6b5`
	test/std/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590e8>
.name: 'r8g8b8'
.file: 'test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/std/number.ci:35: referenced as `r8g8b8`
	test/std/number.ci:34: referenced as `r8g8b8`
	test/std/number.ci:33: referenced as `r8g8b8`
	test/std/number.ci:31: referenced as `r8g8b8`
	test/std/number.ci:30: referenced as `r8g8b8`
	test/std/number.ci:29: referenced as `r8g8b8`
	test/std/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590f0>
.name: 'zxtR5'
.file: 'test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/std/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0590f8>
.name: 'zxtG6'
.file: 'test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/std/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059100>
.name: 'zxtB5'
.file: 'test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059108>
.name: 'sxtR5'
.file: 'test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/std/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059110>
.name: 'sxtG6'
.file: 'test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/std/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059118>
.name: 'sxtB5'
.file: 'test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059120>
.name: 'zxtR8'
.file: 'test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/std/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059128>
.name: 'zxtG8'
.file: 'test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/std/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059130>
.name: 'zxtB8'
.file: 'test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/std/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059138>
.name: 'sxtR8'
.file: 'test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/std/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059140>
.name: 'sxtG8'
.file: 'test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/std/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059148>
.name: 'sxtB8'
.file: 'test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/std/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059150>
.name: 'testSin_f64'
.file: 'test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/std/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059158>
.name: 'testCos_f64'
.file: 'test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/std/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059160>
.name: 'testTan_f64'
.file: 'test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/std/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059168>
.name: 'testLog_f64'
.file: 'test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/std/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059170>
.name: 'testExp_f64'
.file: 'test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/std/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059178>
.name: 'testPow_f64'
.file: 'test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/std/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059180>
.name: 'testSqrt_f64'
.file: 'test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/std/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059188>
.name: 'testAtan_f64'
.file: 'test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/std/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059190>
.name: 'testSin_f32'
.file: 'test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/std/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059198>
.name: 'testCos_f32'
.file: 'test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/std/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591a0>
.name: 'testTan_f32'
.file: 'test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/std/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591a8>
.name: 'testLog_f32'
.file: 'test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/std/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591b0>
.name: 'testExp_f32'
.file: 'test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/std/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591b8>
.name: 'testPow_f32'
.file: 'test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/std/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591c0>
.name: 'testSqrt_f32'
.file: 'test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/std/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0591c8>
.name: 'testAtan_f32'
.file: 'test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/std/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0591d0>
.name: 'testPopulation_u32'
.file: 'test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/std/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0591d8>
.name: 'testSwapBits_u32'
.file: 'test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/std/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0591e0>
.name: 'testBitScanReverse_u32'
.file: 'test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/std/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0591e8>
.name: 'testBitScanForward_u32'
.file: 'test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/std/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0591f0>
.name: 'testHighBit_u32'
.file: 'test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/std/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0591f8>
.name: 'testLowBit_u32'
.file: 'test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/std/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059200>
.name: 'testZeroExtend_u32'
.file: 'test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059208>
.name: 'testSignExtend_u32'
.file: 'test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059210>
.name: 'testZeroExtend_u64'
.file: 'test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059218>
.name: 'testSignExtend_u64'
.file: 'test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/std/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/std/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/std/memory.ci:10: referenced as `malloc`
	test/std/memory.ci:9: referenced as `malloc`
	test/std/memory.ci:8: referenced as `malloc`
	test/std/memory.ci:7: referenced as `malloc`
	test/std/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/std/memory.ci:20: referenced as `free`
	test/std/memory.ci:19: referenced as `free`
	test/std/memory.ci:18: referenced as `free`
	test/std/memory.ci:17: referenced as `free`
	test/std/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059220>
.name: 'p1'
.file: 'test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	test/std/memory.ci:17: referenced as `p1`
	test/std/memory.ci:14: referenced as `p1`
	test/std/memory.ci:13: referenced as `p1`
	test/std/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059228>
.name: 'p2'
.file: 'test/std/memory.ci:8'
.value: malloc(80)
.usages:
	test/std/memory.ci:18: referenced as `p2`
	test/std/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059230>
.name: 'p3'
.file: 'test/std/memory.ci:9'
.value: malloc(160)
.usages:
	test/std/memory.ci:19: referenced as `p3`
	test/std/memory.ci:14: referenced as `p3`
	test/std/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059238>
.name: 'p4'
.file: 'test/std/memory.ci:10'
.value: malloc(820)
.usages:
	test/std/memory.ci:20: referenced as `p4`
	test/std/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059240>
.name: 'val1'
.file: 'test/std/memory.ci:23'
.value: 42
.usages:
	test/std/memory.ci:32: referenced as `val1`
	test/std/memory.ci:30: referenced as `val1`
	test/std/memory.ci:29: referenced as `val1`
	test/std/memory.ci:26: referenced as `val1`
	test/std/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059248>
.name: 'val2'
.file: 'test/std/memory.ci:24'
.value: 96
.usages:
	test/std/memory.ci:33: referenced as `val2`
	test/std/memory.ci:29: referenced as `val2`
	test/std/memory.ci:27: referenced as `val2`
	test/std/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@059250>
.name: 'noError'
.file: 'test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@059250> - <@059251>)
	<noError @059250>      : 03                         ret
.usages:
	test/std/tryExec.ci:46: referenced as `noError`
	test/std/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@059258>
.name: 'stackOverflow'
.file: 'test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@059258> - <@059270>)
	test/std/tryExec.ci:15: (4 bytes: <@059258> - <@05925c>): data: uint8[8192]
	<stackOverflow @059258>      : 09 00 20 00                inc.sp(+8192)
	test/std/tryExec.ci:16: (15 bytes: <@05925c> - <@05926b>): stackOverflow(ptr);
	<stackOverflow+4 @05925c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @059260>    : 22                         load.i32
	<stackOverflow+9 @059261>    : 1f 58 92 05 00             load.ref <@059258> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @059266>   : 02                         call
	<stackOverflow+15 @059267>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @05926b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @05926f>   : 03                         ret
.usages:
	test/std/tryExec.ci:48: referenced as `stackOverflow`
	test/std/tryExec.ci:16: referenced as `stackOverflow`
	test/std/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@059270>
.name: 'divisionByZero'
.file: 'test/std/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@059270> - <@05927c>)
	test/std/tryExec.ci:20: (7 bytes: <@059270> - <@059277>): value: int32 := int32(3 / 0)
	<divisionByZero @059270>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @059275>    : 19                         load.z32
	<divisionByZero+6 @059276>    : 54                         div.i32
	<divisionByZero+7 @059277>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @05927b>   : 03                         ret
.usages:
	test/std/tryExec.ci:49: referenced as `divisionByZero`
	test/std/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@059280>
.name: 'abortExecution'
.file: 'test/std/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@059280> - <@0592c4>)
	test/std/tryExec.ci:29: (25 bytes: <@059280> - <@059299>): details: NotEquals := {...}
	<abortExecution @059280>      : 09 10 00 00                inc.sp(+16)
	test/std/tryExec.ci:30: (7 bytes: <@059284> - <@05928b>): void(details.message := ("assertion failed"));
	<abortExecution+4 @059284>    : 1f ee d8 00 00             load.ref <@00d8ee> ;"assertion failed"
	<abortExecution+9 @059289>    : 13 01                      set.x32 sp(1)
	test/std/tryExec.ci:31: (7 bytes: <@05928b> - <@059292>): void(details.expected := 97);
	<abortExecution+11 @05928b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @059290>   : 13 02                      set.x32 sp(2)
	test/std/tryExec.ci:32: (7 bytes: <@059292> - <@059299>): void(details.returned := 77);
	<abortExecution+18 @059292>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @059297>   : 13 03                      set.x32 sp(3)
	test/std/tryExec.ci:34: (38 bytes: <@059299> - <@0592bf>): abort(void("fatal error", details));
	<abortExecution+25 @059299>   : 1f b8 20 04 00             load.ref <@0420b8> ;"test/std/tryExec.ci"
	<abortExecution+30 @05929e>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @0592a3>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @0592a8>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @0592ad>   : 1f 00 21 04 00             load.ref <@042100> ;"fatal error"
	<abortExecution+50 @0592b2>   : 1f 18 2b 04 00             load.ref <@042b18> ;abortExecution.NotEquals
	<abortExecution+55 @0592b7>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @0592bb>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @0592bf>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @0592c3>   : 03                         ret
.usages:
	test/std/tryExec.ci:52: referenced as `abortExecution`
	test/std/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@0592c8>
.name: 'invalidMemoryAccess'
.file: 'test/std/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@0592c8> - <@0592d5>)
	test/std/tryExec.ci:38: (5 bytes: <@0592c8> - <@0592cd>): i32Ref: int32 := null
	<invalidMemoryAccess @0592c8>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/std/tryExec.ci:39: (3 bytes: <@0592cd> - <@0592d0>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @0592cd>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @0592cf>    : 22                         load.i32
	<invalidMemoryAccess+8 @0592d0>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @0592d4>   : 03                         ret
.usages:
	test/std/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/std/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@0592d8>
.name: 'invalidInstruction'
.file: 'test/std/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@0592d8> - <@0592da>)
	test/std/tryExec.ci:43: (2 bytes: <@0592d8> - <@0592da>): emit(void(load.z32, ret));
	<invalidInstruction @0592d8>      : 19                         load.z32
	<invalidInstruction+1 @0592d9>    : 03                         ret
.usages:
	test/std/tryExec.ci:50: referenced as `invalidInstruction`
	test/std/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0592e0>
.name: 'tryExecErr0'
.file: 'test/std/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/std/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0592e8>
.name: 'tryExecErr1'
.file: 'test/std/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/std/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0592f0>
.name: 'tryExecErr2'
.file: 'test/std/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/std/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0592f8>
.name: 'tryExecErr3'
.file: 'test/std/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/std/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059300>
.name: 'tryExecErr4'
.file: 'test/std/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/std/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059308>
.name: 'tryExecErr5'
.file: 'test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/std/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059310>
.name: 'tryExecErr6'
.file: 'test/std/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/std/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@059318>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@059350>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@059358>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@059360>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@059368>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@059370>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@059378>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@059380>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@059388>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@059390>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@059398>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@0593a0>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@0593a8>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@0593b0>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: const variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@0593b0> - <@0593b4>)
	test/lang/array.ci:103: (4 bytes: <@0593b0> - <@0593b4>): return uint32(.result := values.length);
	<lenSlice @0593b0>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @0593b3>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0593b8>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0593b8> - <@0593c4>)
	test/lang/array.ci:104: (12 bytes: <@0593b8> - <@0593c4>): return int64(.result := values[idx]);
	<nthFixed @0593b8>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @0593ba>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @0593bc>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @0593c0>    : 23                         load.i64
	<nthFixed+9 @0593c1>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @0593c3>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0593c8>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0593c8> - <@0593d4>)
	test/lang/array.ci:105: (12 bytes: <@0593c8> - <@0593d4>): return int64(.result := values[idx]);
	<nthArray @0593c8>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @0593ca>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @0593cc>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @0593d0>    : 23                         load.i64
	<nthArray+9 @0593d1>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @0593d3>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0593d8>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: const variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0593d8> - <@0593e4>)
	test/lang/array.ci:106: (12 bytes: <@0593d8> - <@0593e4>): return int64(.result := values[idx]);
	<nthSlice @0593d8>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @0593da>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @0593dc>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @0593e0>    : 23                         load.i64
	<nthSlice+9 @0593e1>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @0593e3>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@045860>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@0458f8>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@0593e8>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@0593f0>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@0593f8>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@059400>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@059408>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@059410>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0458f8>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0593e8>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0593f0>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@0593f8>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@059400>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@059408>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@059410>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@059418>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0466e8>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@059438>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@059460>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@059468>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@059490>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@059438>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@059438> - <@05945f>)
	test/lang/method.ci:11: (38 bytes: <@059438> - <@05945e>): trace(void("staticMethod", x));
	<staticMethod @059438>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<staticMethod+5 @05943d>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @059442>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @059447>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @05944c>   : 1f 15 63 04 00             load.ref <@046315> ;"staticMethod"
	<staticMethod+25 @059451>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @059456>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @05945a>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @05945e>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@059460>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@059468>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@059468> - <@05948f>)
	test/lang/method.ci:41: (38 bytes: <@059468> - <@05948e>): trace(void("virtualMethod", x));
	<virtualMethod @059468>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<virtualMethod+5 @05946d>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @059472>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @059477>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @05947c>   : 1f 06 66 04 00             load.ref <@046606> ;"virtualMethod"
	<virtualMethod+25 @059481>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @059486>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @05948a>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @05948e>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@059490>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@059490> - <@0594b7>)
	test/lang/method.ci:48: (38 bytes: <@059490> - <@0594b6>): trace(void("forwardMethod", x));
	<forwardMethod @059490>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<forwardMethod+5 @059495>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @05949a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @05949f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @0594a4>   : 1f 8d 63 04 00             load.ref <@04638d> ;"forwardMethod"
	<forwardMethod+25 @0594a9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @0594ae>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @0594b2>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @0594b6>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@0594b8>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@0594b8> - <@0594df>)
	test/lang/method.ci:58: (38 bytes: <@0594b8> - <@0594de>): trace(void("globalFunction", x));
	<globalFunction @0594b8>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<globalFunction+5 @0594bd>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @0594c2>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @0594c7>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @0594cc>   : 1f 39 66 04 00             load.ref <@046639> ;"globalFunction"
	<globalFunction+25 @0594d1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @0594d6>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @0594da>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @0594de>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@0594e0>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@0594f0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@0594f0> - <@059532>)
	test/lang/method.ci:85: (35 bytes: <@0594f0> - <@059513>): debug("extension.staticMethod");
	<staticMethod @0594f0>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<staticMethod+5 @0594f5>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @0594fa>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0594ff>   : 19                         load.z32
	<staticMethod+16 @059500>   : 1f b5 66 04 00             load.ref <@0466b5> ;"extension.staticMethod"
	<staticMethod+21 @059505>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @05950a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @05950f>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@059513> - <@059531>): if (bool((this) != null))
	<staticMethod+35 @059513>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @059517>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @05951c>   : 57                         ceq.i32
	<staticMethod+45 @05951d>   : 05 14 00 00                jnz <staticMethod+65 @059531>
	test/lang/method.ci:87: (16 bytes: <@059521> - <@059531>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @059521>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @059523>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @059525>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @059527>   : 1f 38 94 05 00             load.ref <@059438> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @05952c>   : 02                         call
	<staticMethod+61 @05952d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @059531>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@059538>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@059538> - <@059577>)
	test/lang/method.ci:91: (35 bytes: <@059538> - <@05955b>): debug("extension.virtualMethod");
	<virtualMethod @059538>      : 1f 78 62 04 00             load.ref <@046278> ;"test/lang/method.ci"
	<virtualMethod+5 @05953d>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @059542>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @059547>   : 19                         load.z32
	<virtualMethod+16 @059548>   : 1f cc 66 04 00             load.ref <@0466cc> ;"extension.virtualMethod"
	<virtualMethod+21 @05954d>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @059552>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @059557>   : 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@05955b> - <@059576>): if (bool((this) != null))
	<virtualMethod+35 @05955b>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @05955f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @059564>   : 57                         ceq.i32
	<virtualMethod+45 @059565>   : 05 11 00 00                jnz <virtualMethod+62 @059576>
	test/lang/method.ci:93: (13 bytes: <@059569> - <@059576>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @059569>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @05956b>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @05956d>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @05956f>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @059571>   : 02                         call
	<virtualMethod+58 @059572>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @059576>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@047e68>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@0480c8>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@048328>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@0484f0>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006b50>, cast: static const inline)
.field as: function (size: 0, offs: <@006de8>, cast: static const inline)
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b50>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(7)
.usages:
	internal usages: 1
}
object.as(obj: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006de8>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param obj: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	internal usages: 1
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@059578>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@059580>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@059588>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@059590>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@059598>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@048990>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@048db8>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0491e0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@049608>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@049a30>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@049e58>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0595a0>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595a8>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595b0>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595b8>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595c0>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595c8>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595d0>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595d8>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595e0>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595e8>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595f0>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0595f8>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059600>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059608>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059610>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059618>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059620>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059628>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059630>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059638>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059640>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059648>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059650>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059658>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059660>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059668>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059670>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@059678>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059680>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059688>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059690>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059698>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0596a0>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0596a8>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0596b0>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596b8>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596c0>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596c8>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596d0>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596d8>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596e0>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596e8>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596f0>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0596f8>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059700>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059708>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059710>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059718>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059720>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@059728>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059730>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059738>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059740>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059748>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059750>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059758>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059760>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059768>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059770>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059778>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059780>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059788>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059790>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@059798>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597a0>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597a8>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597b0>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597b8>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597c0>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597c8>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597d0>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0597d8>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0597e0>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0597e8>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0597f0>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0597f8>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059800>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059808>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059810>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059818>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059820>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059828>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059830>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059838>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059840>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059848>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059850>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059858>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059860>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059868>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059870>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059878>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059880>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@059888>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059890>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059898>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0598a0>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0598a8>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0598b0>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0598b8>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0598c0>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598c8>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598d0>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598d8>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598e0>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598e8>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598f0>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0598f8>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059900>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059908>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059910>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059918>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059920>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059928>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059930>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@059938>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059940>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059948>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059950>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059958>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059960>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059968>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059970>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059978>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059980>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059988>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059990>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059998>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599a0>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599a8>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599b0>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599b8>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599c0>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599c8>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599d0>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599d8>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599e0>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0599e8>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0599f0>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0599f8>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059a00>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059a08>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059a10>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059a18>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059a20>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a28>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a30>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a38>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a40>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a48>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a50>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a58>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a60>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a68>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a70>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a78>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a80>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a88>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a90>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@059a98>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059aa0>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059aa8>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ab0>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ab8>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ac0>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ac8>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ad0>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059ad8>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059ae0>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059ae8>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059af0>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059af8>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b00>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b08>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b10>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b18>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b20>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b28>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b30>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b38>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b40>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@059b48>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b50>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b58>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b60>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b68>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b70>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b78>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059b80>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059b88>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059b90>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059b98>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059ba0>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059ba8>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bb0>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bb8>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bc0>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bc8>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bd0>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bd8>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059be0>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059be8>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bf0>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@059bf8>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c00>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c08>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c10>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c18>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c20>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c28>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c30>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c38>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c40>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c48>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c50>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c58>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c60>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c68>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c70>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059c78>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c80>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c88>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c90>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059c98>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ca0>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059ca8>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059cb0>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cb8>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cc0>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cc8>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cd0>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cd8>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ce0>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ce8>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cf0>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059cf8>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d00>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d08>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d10>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d18>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d20>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d28>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d30>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059d38>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@059d40>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d48>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059d50>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059d58>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@059d60>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d68>
.name: 'testMathFloor_1'
.file: 'test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/std/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d70>
.name: 'testMathFloor_2'
.file: 'test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/std/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d78>
.name: 'testMathFloor_3'
.file: 'test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/std/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d80>
.name: 'testMathFloor_4'
.file: 'test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/std/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d88>
.name: 'testMathFloor_5'
.file: 'test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/std/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d90>
.name: 'testMathFloor_6'
.file: 'test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/std/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059d98>
.name: 'testMathSign_1F'
.file: 'test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/std/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059da0>
.name: 'testMathSign_2F'
.file: 'test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/std/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059da8>
.name: 'testMathSign_3F'
.file: 'test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/std/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059db0>
.name: 'testMathSign_1f'
.file: 'test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/std/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059db8>
.name: 'testMathSign_2f'
.file: 'test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/std/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059dc0>
.name: 'testMathSign_3f'
.file: 'test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/std/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059dc8>
.name: 'testMathAbs_1F'
.file: 'test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/std/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059dd0>
.name: 'testMathAbs_2F'
.file: 'test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/std/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059dd8>
.name: 'testMathAbs_3F'
.file: 'test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/std/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059de0>
.name: 'testMathAbs_1f'
.file: 'test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/std/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059de8>
.name: 'testMathAbs_2f'
.file: 'test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/std/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059df0>
.name: 'testMathAbs_3f'
.file: 'test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/std/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059df8>
.name: 'testMathMin_1f'
.file: 'test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e00>
.name: 'testMathMax_2f'
.file: 'test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e08>
.name: 'testMathMin_1F'
.file: 'test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e10>
.name: 'testMathMax_2F'
.file: 'test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/std/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e18>
.name: 'testMathClamp_1f'
.file: 'test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e20>
.name: 'testMathClamp_1F'
.file: 'test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e28>
.name: 'testMathLerp_1f'
.file: 'test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/std/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e30>
.name: 'testMathLerp_1F'
.file: 'test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/std/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e38>
.name: 'testMathSmooth_1f'
.file: 'test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e40>
.name: 'testMathSmooth_1F'
.file: 'test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/std/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e48>
.name: 'testMathMin_nan'
.file: 'test/std/test.math.ci:38'
.value: Math.min()
.usages:
	test/std/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e50>
.name: 'testMathMin_1'
.file: 'test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/std/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e58>
.name: 'testMathMax_nan'
.file: 'test/std/test.math.ci:40'
.value: Math.max()
.usages:
	test/std/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e60>
.name: 'testMathMax_9'
.file: 'test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/std/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e68>
.name: 'testMathSum_0'
.file: 'test/std/test.math.ci:43'
.value: Math.sum()
.usages:
	test/std/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e70>
.name: 'testMathSum_1'
.file: 'test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/std/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e78>
.name: 'testMathSum_3'
.file: 'test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/std/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e80>
.name: 'testMathSum_55'
.file: 'test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/std/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e88>
.name: 'testMathEval_x'
.file: 'test/std/test.math.ci:48'
.value: 10
.usages:
	test/std/test.math.ci:55: referenced as `testMathEval_x`
	test/std/test.math.ci:54: referenced as `testMathEval_x`
	test/std/test.math.ci:53: referenced as `testMathEval_x`
	test/std/test.math.ci:52: referenced as `testMathEval_x`
	test/std/test.math.ci:51: referenced as `testMathEval_x`
	test/std/test.math.ci:50: referenced as `testMathEval_x`
	test/std/test.math.ci:49: referenced as `testMathEval_x`
	test/std/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e90>
.name: 'testMathEval_0'
.file: 'test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/std/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059e98>
.name: 'testMathEval_1'
.file: 'test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/std/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ea0>
.name: 'testMathEval_2'
.file: 'test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ea8>
.name: 'testMathEval_3'
.file: 'test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059eb0>
.name: 'testMathEval_4'
.file: 'test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059eb8>
.name: 'testMathEval_5'
.file: 'test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ec0>
.name: 'testMathEval_6'
.file: 'test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/std/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ec8>
.name: 'testMathSin_f64'
.file: 'test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ed0>
.name: 'testMathCos_f64'
.file: 'test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ed8>
.name: 'testMathTan_f64'
.file: 'test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/std/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ee0>
.name: 'testMathSinh_f64'
.file: 'test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ee8>
.name: 'testMathCosh_f64'
.file: 'test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/std/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ef0>
.name: 'testMathAsin_f64'
.file: 'test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/std/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059ef8>
.name: 'testMathAcos_f64'
.file: 'test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/std/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059f00>
.name: 'testMathCmp_f32'
.file: 'test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/std/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@059f08>
.name: 'testMathCmp_f64'
.file: 'test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/std/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f10>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/std/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f18>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/std/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f20>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/std/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f28>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/std/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f30>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/std/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f38>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/std/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f40>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/std/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f48>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/std/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f50>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/std/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f58>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/std/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@059f60>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/std/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f68>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/std/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f70>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/std/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f78>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/std/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f80>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/std/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f88>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/std/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f90>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/std/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059f98>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/std/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059fa0>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/std/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059fa8>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/std/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059fb0>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/std/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@059fb8>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/std/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 14634
.offset: <@059fbc>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000d38>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000dd8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005a38>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0075a8>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@007e88>, cast: static const inline)
.field System: typename (size: 0, offs: <@008af8>, cast: static const typename(void))
.field true: bool (size: 1, offs: <@000000>, cast: static const val)
.field false: bool (size: 1, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 32, offs: <@0107e8>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@057570>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@011a78>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01aab8>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@057da8>, cast: static const function)
.field Complex: function (size: 7, offs: <@057db0>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@057db8>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@057e38>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@057e58>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@020090>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@057ec0>, cast: static const function)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@023828>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@057ed0>, cast: static const function)
.field mat4f: function (size: 21, offs: <@057f08>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@057f20>, cast: static const function)
.field mul: function (size: 301, offs: <@057f58>, cast: static const function)
.field rotation: function (size: 524, offs: <@058088>, cast: static const function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@058298>, cast: static const function)
.field scale: function (size: 217, offs: <@0582f0>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@0288d0>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@0583d0>, cast: static const function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@0583d8>, cast: static const function)
.field indexOf: function (size: 50, offs: <@058400>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@058438>, cast: static const function)
.field startsWith: function (size: 73, offs: <@058470>, cast: static const function)
.field endsWith: function (size: 126, offs: <@0584c0>, cast: static const function)
.field compare: function (size: 63, offs: <@058540>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@0585c8>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@0585f0>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@02df78>, cast: static const typename(val))
.field append: function (size: 84, offs: <@058600>, cast: static const function)
.field append: function (size: 707, offs: <@058668>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 227, offs: <@058930>, cast: static const function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@058a28>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@058a68>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@058a70>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@058a78>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@058a80>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@058a88>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@058a90>, cast: static variable(i32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@058a98>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@058aa0>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@058aa8>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@058ab0>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@058ab8>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@058ac0>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@058ac8>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@058ad0>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@058ad8>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@058ae0>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@058ae8>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@058af0>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@058af8>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@058b00>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@058b08>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@058b10>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@058b18>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@058b20>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@058b28>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@058b30>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@058b38>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@058b40>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@058b48>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@058b50>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@058b58>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@058b60>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@058b68>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@058b70>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@058b78>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@058b80>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@058b88>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@058b90>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@058b98>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@058ba0>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@058ba8>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@058bb0>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@058bb8>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@058bc0>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@058bc8>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@058bd0>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@058bd8>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@058be0>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@058be8>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@058bf0>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@058bf8>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@058c00>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@058c08>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@058c10>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@058c18>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@058c20>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@058c28>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@058c30>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@058c38>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@058c40>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@058c48>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@058c50>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@038380>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@0384b0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@058c58>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@058c60>, cast: static variable(val))
.field value: int64 (size: 8, offs: <@058c68>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@058c70>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@058c78>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@058c80>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@058c88>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@058c90>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@058c98>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@058ca0>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@058ca8>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@058cb0>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@058cb8>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@058cc0>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@058cc8>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@058cd0>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@058cd8>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@058ce0>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@058ce8>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@058cf0>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@058cf8>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@058d00>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@058d08>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@058d10>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@058d18>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@058d20>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@058d28>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@058d30>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@058d38>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@058d40>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@058d48>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@058d50>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@058d58>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@058d60>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@058d68>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@058d70>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@058d78>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@058d80>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@058d88>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@058d90>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@058d98>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@058da0>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@058da8>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@058db0>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@058db8>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@058dc0>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@058dc8>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@058dd0>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@058dd8>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@058de0>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@058de8>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@058df0>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@058df8>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@058e00>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@058e08>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@058e10>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@058e18>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@058e20>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@058e28>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@058e30>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@058e38>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@058e40>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@058e48>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@058e50>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@058e58>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@058e60>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@058e68>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@058e70>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@058e78>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@058e80>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@058e88>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@058e90>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@058e98>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@058ea0>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@058ea8>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@058eb0>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@058eb8>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@058ec0>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@058ec8>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@058ed0>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@058ed8>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@058ee0>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@058ee8>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@058ef0>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@058ef8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@058f00>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@058f08>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@058f10>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@058f18>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@058f20>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@058f28>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@058f30>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@058f38>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@058f40>, cast: static const function)
.field fib: function (size: 54, offs: <@058f48>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@058f80>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@058f88>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@058f90>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@058f98>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@058fa0>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@058fa8>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@058fb0>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@058fb8>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@058fc0>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@058fc8>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@058fd0>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@058fd8>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@058fe0>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@058fe8>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@058ff0>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@058ff8>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@059000>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@059008>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@059010>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@03e318>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@03e448>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@059018>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@059020>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@059028>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@059030>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@059038>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@059040>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@059048>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@059050>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@059058>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@059060>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@059068>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@059070>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@059078>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@059080>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@059088>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@059090>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@059098>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@0590a0>, cast: static variable(i32))
.field pi64: float64 (size: 8, offs: <@0590a8>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@0590b0>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@0590b8>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@0590c0>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@0590c8>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@0590d0>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@0590d8>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@0590e0>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@0590e8>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@0590f0>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@0590f8>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@059100>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@059108>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@059110>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@059118>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@059120>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@059128>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@059130>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@059138>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@059140>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@059148>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@059150>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@059158>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@059160>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@059168>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@059170>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@059178>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@059180>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@059188>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@059190>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@059198>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@0591a0>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@0591a8>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@0591b0>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@0591b8>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@0591c0>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@0591c8>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@0591d0>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@0591d8>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@0591e0>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@0591e8>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@0591f0>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@0591f8>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@059200>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@059208>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@059210>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@059218>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@059220>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@059228>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@059230>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@059238>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@059240>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@059248>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@059250>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@059258>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@059270>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@059280>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@0592c8>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@0592d8>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@0592e0>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@0592e8>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@0592f0>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@0592f8>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@059300>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@059308>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@059310>, cast: static variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <@059318>, cast: static variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <@059350>, cast: static variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <@059358>, cast: static variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@059360>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@059368>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@059370>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@059378>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@059380>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@059388>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@059390>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@059398>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@0593a0>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@0593a8>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@0593b0>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@0593b8>, cast: static const function)
.field nthArray: function (size: 12, offs: <@0593c8>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@0593d8>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@045860>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@059418>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@0466e8>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@0594b8>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@0594e0>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@0594f0>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@059538>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@047e68>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@0480c8>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@048328>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@0484f0>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@059578>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@059580>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@059588>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@059590>, cast: static variable(val))
.field blue: color (size: 4, offs: <@059598>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@048990>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@048db8>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0491e0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@049608>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@049a30>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@049e58>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@0595a0>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@0595a8>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@0595b0>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@0595b8>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@0595c0>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@0595c8>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@0595d0>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@0595d8>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@0595e0>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@0595e8>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@0595f0>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@0595f8>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@059600>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@059608>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@059610>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@059618>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@059620>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@059628>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@059630>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@059638>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@059640>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@059648>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@059650>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@059658>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@059660>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@059668>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@059670>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@059678>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@059680>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@059688>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@059690>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@059698>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@0596a0>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@0596a8>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@0596b0>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@0596b8>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@0596c0>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@0596c8>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@0596d0>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@0596d8>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@0596e0>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@0596e8>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@0596f0>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@0596f8>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@059700>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@059708>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@059710>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@059718>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@059720>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@059728>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@059730>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@059738>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@059740>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@059748>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@059750>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@059758>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@059760>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@059768>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@059770>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@059778>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@059780>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@059788>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@059790>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@059798>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@0597a0>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@0597a8>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@0597b0>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@0597b8>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@0597c0>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@0597c8>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@0597d0>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@0597d8>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@0597e0>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@0597e8>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@0597f0>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@0597f8>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@059800>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@059808>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@059810>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@059818>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@059820>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@059828>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@059830>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@059838>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@059840>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@059848>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@059850>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@059858>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@059860>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@059868>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@059870>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@059878>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@059880>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@059888>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@059890>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@059898>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@0598a0>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@0598a8>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@0598b0>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@0598b8>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@0598c0>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@0598c8>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@0598d0>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@0598d8>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@0598e0>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@0598e8>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@0598f0>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@0598f8>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@059900>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@059908>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@059910>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@059918>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@059920>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@059928>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@059930>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@059938>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@059940>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@059948>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@059950>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@059958>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@059960>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@059968>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@059970>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@059978>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@059980>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@059988>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@059990>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@059998>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@0599a0>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@0599a8>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@0599b0>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@0599b8>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@0599c0>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@0599c8>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@0599d0>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@0599d8>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@0599e0>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@0599e8>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@0599f0>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@0599f8>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@059a00>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@059a08>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@059a10>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@059a18>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@059a20>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@059a28>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@059a30>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@059a38>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@059a40>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@059a48>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@059a50>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@059a58>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@059a60>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@059a68>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@059a70>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@059a78>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@059a80>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@059a88>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@059a90>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@059a98>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@059aa0>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@059aa8>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@059ab0>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@059ab8>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@059ac0>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@059ac8>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@059ad0>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@059ad8>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@059ae0>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@059ae8>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@059af0>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@059af8>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@059b00>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@059b08>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@059b10>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@059b18>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@059b20>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@059b28>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@059b30>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@059b38>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@059b40>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@059b48>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@059b50>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@059b58>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@059b60>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@059b68>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@059b70>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@059b78>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@059b80>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@059b88>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@059b90>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@059b98>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@059ba0>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@059ba8>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@059bb0>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@059bb8>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@059bc0>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@059bc8>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@059bd0>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@059bd8>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@059be0>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@059be8>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@059bf0>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@059bf8>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@059c00>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@059c08>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@059c10>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@059c18>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@059c20>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@059c28>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@059c30>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@059c38>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@059c40>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@059c48>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@059c50>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@059c58>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@059c60>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@059c68>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@059c70>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@059c78>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@059c80>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@059c88>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@059c90>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@059c98>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@059ca0>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@059ca8>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@059cb0>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@059cb8>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@059cc0>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@059cc8>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@059cd0>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@059cd8>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@059ce0>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@059ce8>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@059cf0>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@059cf8>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@059d00>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@059d08>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@059d10>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@059d18>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@059d20>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@059d28>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@059d30>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@059d38>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@059d40>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@059d48>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@059d50>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@059d58>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@059d60>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@059d68>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@059d70>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@059d78>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@059d80>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@059d88>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@059d90>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@059d98>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@059da0>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@059da8>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@059db0>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@059db8>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@059dc0>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@059dc8>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@059dd0>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@059dd8>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@059de0>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@059de8>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@059df0>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@059df8>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@059e00>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@059e08>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@059e10>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@059e18>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@059e20>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@059e28>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@059e30>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@059e38>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@059e40>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@059e48>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@059e50>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@059e58>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@059e60>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@059e68>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@059e70>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@059e78>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@059e80>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@059e88>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@059e90>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@059e98>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@059ea0>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@059ea8>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@059eb0>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@059eb8>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@059ec0>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@059ec8>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@059ed0>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@059ed8>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@059ee0>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@059ee8>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@059ef0>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@059ef8>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@059f00>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@059f08>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@059f10>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@059f18>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@059f20>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@059f28>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@059f30>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@059f38>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@059f40>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@059f48>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@059f50>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@059f58>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@059f60>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@059f68>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@059f70>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@059f78>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@059f80>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@059f88>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@059f90>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@059f98>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@059fa0>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@059fa8>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@059fb0>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@059fb8>, cast: static variable(f32))
.field .main: function (size: 14634, offs: <@059fbc>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static const mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (data.length)));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			data: float32[4];
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
		};
		static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			data: float32[16];
			m: float32[4][4];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
		};
		static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static const transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static const rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static const translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.x.x := (1));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := float32(direction.x * amount));
			void(.result.y.x := (0));
			void(.result.y.y := (1));
			void(.result.y.z := (0));
			void(.result.y.w := float32(direction.y * amount));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := (1));
			void(.result.z.w := float32(direction.z * amount));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
		};
		static const scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.x.x := rcp(float32(direction.x * amount)));
			void(.result.x.y := (0));
			void(.result.x.z := (0));
			void(.result.x.w := (0));
			void(.result.y.x := (0));
			void(.result.y.y := rcp(float32(direction.y * amount)));
			void(.result.y.z := (0));
			void(.result.y.w := (0));
			void(.result.z.x := (0));
			void(.result.z.y := (0));
			void(.result.z.z := rcp(float32(direction.z * amount)));
			void(.result.z.w := (0));
			void(.result.w.x := (0));
			void(.result.w.y := (0));
			void(.result.w.z := (0));
			void(.result.w.w := (1));
		});
		};
		static const vec2d: struct {
			data: float64[2];
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
		};
		static const vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static const length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static const append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static const append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(value)), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(fract)), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static const append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedNoInit: int64[7];
		static arrArrayNoInit: int64[*];
		static arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedNoInit;
		static arrSliceInitFixed: int64[] := arrFixedNoInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(const values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, const values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, const values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, const values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const as(obj: object, type: typename): pointer := nfc(8);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14634 bytes: <@059fbc> - <@05d8e6>)
	lib/std/string.ci:145: (14 bytes: <@059fbc> - <@059fca>): static const whiteSpace: char[] := " \t\n\r"
	<.main @059fbc>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @059fc1>    : 1f e4 a6 02 00             load.ref <@02a6e4> ;" \t\n\r"
	<.main+10 @059fc6>   : 2d 58 86 05                store.m64 <@058658> ;append.whiteSpace
	lib/std/string.ci:146: (14 bytes: <@059fca> - <@059fd8>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @059fca>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @059fcf>   : 1f f5 a6 02 00             load.ref <@02a6f5> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @059fd4>   : 2d 60 86 05                store.m64 <@058660> ;append.radixDigits
	lib/std/string.ci:263: (24 bytes: <@059fd8> - <@059ff0>): static const format: FormatFlags := {...}
	<.main+28 @059fd8>   : 19                         load.z32
	<.main+29 @059fd9>   : 1f 18 8a 05 00             load.ref <@058a18> ;append.format
	<.main+34 @059fde>   : 25                         store.i8
	:: (5 bytes: <@059fdf> - <@059fe4>): void(format.precision := 0)
	<.main+35 @059fdf>   : 19                         load.z32
	<.main+36 @059fe0>   : 2e 1c 8a 05                store.m32 <@058a1c> ;append.format+4
	:: (7 bytes: <@059fe4> - <@059feb>): void(format.padChr := (0))
	<.main+40 @059fe4>   : 19                         load.z32
	<.main+41 @059fe5>   : 1f 20 8a 05 00             load.ref <@058a20> ;append.format+8
	<.main+46 @059fea>   : 25                         store.i8
	:: (5 bytes: <@059feb> - <@059ff0>): void(format.padLen := 0)
	<.main+47 @059feb>   : 19                         load.z32
	<.main+48 @059fec>   : 2e 24 8a 05                store.m32 <@058a24> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@059ff0> - <@059ff5>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @059ff0>   : 19                         load.z32
	<.main+53 @059ff1>   : 2e 68 8a 05                store.m32 <@058a68> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@059ff5> - <@059ffa>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @059ff5>   : 1a                         load.z64
	<.main+58 @059ff6>   : 2d 70 8a 05                store.m64 <@058a70> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@059ffa> - <@05a003>): static emitA: int32 := 42
	<.main+62 @059ffa>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @059fff>   : 2e 78 8a 05                store.m32 <@058a78> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@05a003> - <@05a00c>): static emitB: int32 := 96
	<.main+71 @05a003>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @05a008>   : 2e 80 8a 05                store.m32 <@058a80> ;emitB
	test/lang/emit.ci:9: (13 bytes: <@05a00c> - <@05a019>): static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+80 @05a00c>   : 2a 78 8a 05                load.m32 <@058a78> ;emitA
	<.main+84 @05a010>   : 2a 80 8a 05                load.m32 <@058a80> ;emitB
	<.main+88 @05a014>   : 51                         add.i32
	<.main+89 @05a015>   : 2e 88 8a 05                store.m32 <@058a88> ;emitAddI32
	test/lang/emit.ci:10: (15 bytes: <@05a019> - <@05a028>): static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+93 @05a019>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @05a01e>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @05a023>  : 54                         div.i32
	<.main+104 @05a024>  : 2e 90 8a 05                store.m32 <@058a90> ;emitDivI32
	test/lang/emit.ci:17: (9 bytes: <@05a028> - <@05a031>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+108 @05a028>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+113 @05a02d>  : 2e 98 8a 05                store.m32 <@058a98> ;emitFloatAsInt1
	test/lang/emit.ci:18: (10 bytes: <@05a031> - <@05a03b>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+117 @05a031>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+122 @05a036>  : 5b                         i32.2i64
	<.main+123 @05a037>  : 2d a0 8a 05                store.m64 <@058aa0> ;emitFloatAsInt2
	test/lang/emit.ci:19: (14 bytes: <@05a03b> - <@05a049>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+127 @05a03b>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+136 @05a044>  : 6a                         i64.2i32
	<.main+137 @05a045>  : 2e a8 8a 05                store.m32 <@058aa8> ;emitFloatAsInt3
	test/lang/emit.ci:20: (13 bytes: <@05a049> - <@05a056>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+141 @05a049>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+150 @05a052>  : 2d b0 8a 05                store.m64 <@058ab0> ;emitFloatAsInt4
	test/lang/emit.ci:23: (14 bytes: <@05a056> - <@05a064>): static emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+154 @05a056>  : 1c 03 00 00 00             load.c32 3
	<.main+159 @05a05b>  : 1f bc 25 03 00             load.ref <@0325bc> ;"string"
	<.main+164 @05a060>  : 2d b8 8a 05                store.m64 <@058ab8> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@05a064> - <@05a06d>): static i3: int32 := 3
	<.main+168 @05a064>  : 1c 03 00 00 00             load.c32 3
	<.main+173 @05a069>  : 2e c0 8a 05                store.m32 <@058ac0> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@05a06d> - <@05a076>): static i6: int32 := 6
	<.main+177 @05a06d>  : 1c 06 00 00 00             load.c32 6
	<.main+182 @05a072>  : 2e c8 8a 05                store.m32 <@058ac8> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@05a076> - <@05a07f>): static i2: int32 := 2
	<.main+186 @05a076>  : 1c 02 00 00 00             load.c32 2
	<.main+191 @05a07b>  : 2e d0 8a 05                store.m32 <@058ad0> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@05a07f> - <@05a088>): static i8: int32 := 8
	<.main+195 @05a07f>  : 1c 08 00 00 00             load.c32 8
	<.main+200 @05a084>  : 2e d8 8a 05                store.m32 <@058ad8> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@05a088> - <@05a08d>): static zeroVal: int32 := zero(void(3, 6))
	<.main+204 @05a088>  : 19                         load.z32
	<.main+205 @05a089>  : 2e e0 8a 05                store.m32 <@058ae0> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@05a08d> - <@05a092>): static zeroVar: int32 := zero(void(i3, i6))
	<.main+209 @05a08d>  : 19                         load.z32
	<.main+210 @05a08e>  : 2e e8 8a 05                store.m32 <@058ae8> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@05a092> - <@05a097>): static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+214 @05a092>  : 19                         load.z32
	<.main+215 @05a093>  : 2e f0 8a 05                store.m32 <@058af0> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@05a097> - <@05a0a0>): static lastVal: int32 := last(void(3, 6))
	<.main+219 @05a097>  : 1c 06 00 00 00             load.c32 6
	<.main+224 @05a09c>  : 2e f8 8a 05                store.m32 <@058af8> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@05a0a0> - <@05a0a8>): static lastVar: int32 := last(void(i3, i6))
	<.main+228 @05a0a0>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+232 @05a0a4>  : 2e 00 8b 05                store.m32 <@058b00> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@05a0a8> - <@05a0b8>): static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+236 @05a0a8>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+240 @05a0ac>  : 0c 01 00 00                inc.i32(+1)
	<.main+244 @05a0b0>  : 0c ff ff ff                inc.i32(-1)
	<.main+248 @05a0b4>  : 2e 08 8b 05                store.m32 <@058b08> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@05a0b8> - <@05a0c5>): static sum2Val: int32 := sum(void(3, 6))
	<.main+252 @05a0b8>  : 1c 03 00 00 00             load.c32 3
	<.main+257 @05a0bd>  : 0c 06 00 00                inc.i32(+6)
	<.main+261 @05a0c1>  : 2e 10 8b 05                store.m32 <@058b10> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@05a0c5> - <@05a0d2>): static sum2Var: int32 := sum(void(i3, i6))
	<.main+265 @05a0c5>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+269 @05a0c9>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+273 @05a0cd>  : 51                         add.i32
	<.main+274 @05a0ce>  : 2e 18 8b 05                store.m32 <@058b18> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@05a0d2> - <@05a0eb>): static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+278 @05a0d2>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+282 @05a0d6>  : 0c 01 00 00                inc.i32(+1)
	<.main+286 @05a0da>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+290 @05a0de>  : 0c 01 00 00                inc.i32(+1)
	<.main+294 @05a0e2>  : 51                         add.i32
	<.main+295 @05a0e3>  : 0c fe ff ff                inc.i32(-2)
	<.main+299 @05a0e7>  : 2e 20 8b 05                store.m32 <@058b20> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@05a0eb> - <@05a107>): static any2Val: int32 := any(void(3, 6))
	<.main+303 @05a0eb>  : 1c 03 00 00 00             load.c32 3
	<.main+308 @05a0f0>  : 10 00                      dup.x32 sp(0)
	<.main+310 @05a0f2>  : 06 0a 00 00                jz <.main+320 @05a0fc>
	<.main+314 @05a0f6>  : 10 00                      dup.x32 sp(0)
	<.main+316 @05a0f8>  : 04 09 00 00                jmp <.main+325 @05a101>
	<.main+320 @05a0fc>  : 1c 06 00 00 00             load.c32 6
	<.main+325 @05a101>  : 13 01                      set.x32 sp(1)
	<.main+327 @05a103>  : 2e 28 8b 05                store.m32 <@058b28> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@05a107> - <@05a121>): static any2Var: int32 := any(void(i3, i6))
	<.main+331 @05a107>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+335 @05a10b>  : 10 00                      dup.x32 sp(0)
	<.main+337 @05a10d>  : 06 0a 00 00                jz <.main+347 @05a117>
	<.main+341 @05a111>  : 10 00                      dup.x32 sp(0)
	<.main+343 @05a113>  : 04 08 00 00                jmp <.main+351 @05a11b>
	<.main+347 @05a117>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+351 @05a11b>  : 13 01                      set.x32 sp(1)
	<.main+353 @05a11d>  : 2e 30 8b 05                store.m32 <@058b30> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@05a121> - <@05a147>): static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+357 @05a121>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+361 @05a125>  : 0c 01 00 00                inc.i32(+1)
	<.main+365 @05a129>  : 10 00                      dup.x32 sp(0)
	<.main+367 @05a12b>  : 06 0a 00 00                jz <.main+377 @05a135>
	<.main+371 @05a12f>  : 10 00                      dup.x32 sp(0)
	<.main+373 @05a131>  : 04 0c 00 00                jmp <.main+385 @05a13d>
	<.main+377 @05a135>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+381 @05a139>  : 0c 01 00 00                inc.i32(+1)
	<.main+385 @05a13d>  : 13 01                      set.x32 sp(1)
	<.main+387 @05a13f>  : 0c ff ff ff                inc.i32(-1)
	<.main+391 @05a143>  : 2e 38 8b 05                store.m32 <@058b38> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@05a147> - <@05a16c>): static min2Val: int32 := min(void(3, 6))
	<.main+395 @05a147>  : 1c 03 00 00 00             load.c32 3
	<.main+400 @05a14c>  : 1c 06 00 00 00             load.c32 6
	<.main+405 @05a151>  : 10 01                      dup.x32 sp(1)
	<.main+407 @05a153>  : 10 01                      dup.x32 sp(1)
	<.main+409 @05a155>  : 58                         clt.i32
	<.main+410 @05a156>  : 06 0a 00 00                jz <.main+420 @05a160>
	<.main+414 @05a15a>  : 10 01                      dup.x32 sp(1)
	<.main+416 @05a15c>  : 04 06 00 00                jmp <.main+422 @05a162>
	<.main+420 @05a160>  : 10 00                      dup.x32 sp(0)
	<.main+422 @05a162>  : 13 02                      set.x32 sp(2)
	<.main+424 @05a164>  : 09 fc ff ff                inc.sp(-4)
	<.main+428 @05a168>  : 2e 40 8b 05                store.m32 <@058b40> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@05a16c> - <@05a18f>): static min2Var: int32 := min(void(i3, i6))
	<.main+432 @05a16c>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+436 @05a170>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+440 @05a174>  : 10 01                      dup.x32 sp(1)
	<.main+442 @05a176>  : 10 01                      dup.x32 sp(1)
	<.main+444 @05a178>  : 58                         clt.i32
	<.main+445 @05a179>  : 06 0a 00 00                jz <.main+455 @05a183>
	<.main+449 @05a17d>  : 10 01                      dup.x32 sp(1)
	<.main+451 @05a17f>  : 04 06 00 00                jmp <.main+457 @05a185>
	<.main+455 @05a183>  : 10 00                      dup.x32 sp(0)
	<.main+457 @05a185>  : 13 02                      set.x32 sp(2)
	<.main+459 @05a187>  : 09 fc ff ff                inc.sp(-4)
	<.main+463 @05a18b>  : 2e 48 8b 05                store.m32 <@058b48> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@05a18f> - <@05a1be>): static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+467 @05a18f>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+471 @05a193>  : 0c 01 00 00                inc.i32(+1)
	<.main+475 @05a197>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+479 @05a19b>  : 0c 01 00 00                inc.i32(+1)
	<.main+483 @05a19f>  : 10 01                      dup.x32 sp(1)
	<.main+485 @05a1a1>  : 10 01                      dup.x32 sp(1)
	<.main+487 @05a1a3>  : 58                         clt.i32
	<.main+488 @05a1a4>  : 06 0a 00 00                jz <.main+498 @05a1ae>
	<.main+492 @05a1a8>  : 10 01                      dup.x32 sp(1)
	<.main+494 @05a1aa>  : 04 06 00 00                jmp <.main+500 @05a1b0>
	<.main+498 @05a1ae>  : 10 00                      dup.x32 sp(0)
	<.main+500 @05a1b0>  : 13 02                      set.x32 sp(2)
	<.main+502 @05a1b2>  : 09 fc ff ff                inc.sp(-4)
	<.main+506 @05a1b6>  : 0c ff ff ff                inc.i32(-1)
	<.main+510 @05a1ba>  : 2e 50 8b 05                store.m32 <@058b50> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@05a1be> - <@05a1e3>): static max2Val: int32 := max(void(3, 6))
	<.main+514 @05a1be>  : 1c 03 00 00 00             load.c32 3
	<.main+519 @05a1c3>  : 1c 06 00 00 00             load.c32 6
	<.main+524 @05a1c8>  : 10 01                      dup.x32 sp(1)
	<.main+526 @05a1ca>  : 10 01                      dup.x32 sp(1)
	<.main+528 @05a1cc>  : 59                         cgt.i32
	<.main+529 @05a1cd>  : 06 0a 00 00                jz <.main+539 @05a1d7>
	<.main+533 @05a1d1>  : 10 01                      dup.x32 sp(1)
	<.main+535 @05a1d3>  : 04 06 00 00                jmp <.main+541 @05a1d9>
	<.main+539 @05a1d7>  : 10 00                      dup.x32 sp(0)
	<.main+541 @05a1d9>  : 13 02                      set.x32 sp(2)
	<.main+543 @05a1db>  : 09 fc ff ff                inc.sp(-4)
	<.main+547 @05a1df>  : 2e 58 8b 05                store.m32 <@058b58> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@05a1e3> - <@05a206>): static max2Var: int32 := max(void(i3, i6))
	<.main+551 @05a1e3>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+555 @05a1e7>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+559 @05a1eb>  : 10 01                      dup.x32 sp(1)
	<.main+561 @05a1ed>  : 10 01                      dup.x32 sp(1)
	<.main+563 @05a1ef>  : 59                         cgt.i32
	<.main+564 @05a1f0>  : 06 0a 00 00                jz <.main+574 @05a1fa>
	<.main+568 @05a1f4>  : 10 01                      dup.x32 sp(1)
	<.main+570 @05a1f6>  : 04 06 00 00                jmp <.main+576 @05a1fc>
	<.main+574 @05a1fa>  : 10 00                      dup.x32 sp(0)
	<.main+576 @05a1fc>  : 13 02                      set.x32 sp(2)
	<.main+578 @05a1fe>  : 09 fc ff ff                inc.sp(-4)
	<.main+582 @05a202>  : 2e 60 8b 05                store.m32 <@058b60> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@05a206> - <@05a235>): static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+586 @05a206>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+590 @05a20a>  : 0c 01 00 00                inc.i32(+1)
	<.main+594 @05a20e>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+598 @05a212>  : 0c 01 00 00                inc.i32(+1)
	<.main+602 @05a216>  : 10 01                      dup.x32 sp(1)
	<.main+604 @05a218>  : 10 01                      dup.x32 sp(1)
	<.main+606 @05a21a>  : 59                         cgt.i32
	<.main+607 @05a21b>  : 06 0a 00 00                jz <.main+617 @05a225>
	<.main+611 @05a21f>  : 10 01                      dup.x32 sp(1)
	<.main+613 @05a221>  : 04 06 00 00                jmp <.main+619 @05a227>
	<.main+617 @05a225>  : 10 00                      dup.x32 sp(0)
	<.main+619 @05a227>  : 13 02                      set.x32 sp(2)
	<.main+621 @05a229>  : 09 fc ff ff                inc.sp(-4)
	<.main+625 @05a22d>  : 0c ff ff ff                inc.i32(-1)
	<.main+629 @05a231>  : 2e 68 8b 05                store.m32 <@058b68> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@05a235> - <@05a24e>): static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+633 @05a235>  : 1c 03 00 00 00             load.c32 3
	<.main+638 @05a23a>  : 1c 06 00 00 00             load.c32 6
	<.main+643 @05a23f>  : 1c 02 00 00 00             load.c32 2
	<.main+648 @05a244>  : 0c 08 00 00                inc.i32(+8)
	<.main+652 @05a248>  : 51                         add.i32
	<.main+653 @05a249>  : 51                         add.i32
	<.main+654 @05a24a>  : 2e 70 8b 05                store.m32 <@058b70> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@05a24e> - <@05a263>): static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+658 @05a24e>  : 1c 03 00 00 00             load.c32 3
	<.main+663 @05a253>  : 0c 06 00 00                inc.i32(+6)
	<.main+667 @05a257>  : 0c 02 00 00                inc.i32(+2)
	<.main+671 @05a25b>  : 0c 08 00 00                inc.i32(+8)
	<.main+675 @05a25f>  : 2e 78 8b 05                store.m32 <@058b78> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@05a263> - <@05a27a>): static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+679 @05a263>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+683 @05a267>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+687 @05a26b>  : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+691 @05a26f>  : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+695 @05a273>  : 51                         add.i32
	<.main+696 @05a274>  : 51                         add.i32
	<.main+697 @05a275>  : 51                         add.i32
	<.main+698 @05a276>  : 2e 80 8b 05                store.m32 <@058b80> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@05a27a> - <@05a291>): static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+702 @05a27a>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+706 @05a27e>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+710 @05a282>  : 51                         add.i32
	<.main+711 @05a283>  : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+715 @05a287>  : 51                         add.i32
	<.main+716 @05a288>  : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+720 @05a28c>  : 51                         add.i32
	<.main+721 @05a28d>  : 2e 88 8b 05                store.m32 <@058b88> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@05a291> - <@05a2bc>): static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+725 @05a291>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+729 @05a295>  : 0c 01 00 00                inc.i32(+1)
	<.main+733 @05a299>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+737 @05a29d>  : 0c 01 00 00                inc.i32(+1)
	<.main+741 @05a2a1>  : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+745 @05a2a5>  : 0c 01 00 00                inc.i32(+1)
	<.main+749 @05a2a9>  : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+753 @05a2ad>  : 0c 01 00 00                inc.i32(+1)
	<.main+757 @05a2b1>  : 51                         add.i32
	<.main+758 @05a2b2>  : 51                         add.i32
	<.main+759 @05a2b3>  : 51                         add.i32
	<.main+760 @05a2b4>  : 0c fc ff ff                inc.i32(-4)
	<.main+764 @05a2b8>  : 2e 90 8b 05                store.m32 <@058b90> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@05a2bc> - <@05a2e7>): static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+768 @05a2bc>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+772 @05a2c0>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @05a2c4>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+780 @05a2c8>  : 0c 01 00 00                inc.i32(+1)
	<.main+784 @05a2cc>  : 51                         add.i32
	<.main+785 @05a2cd>  : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+789 @05a2d1>  : 0c 01 00 00                inc.i32(+1)
	<.main+793 @05a2d5>  : 51                         add.i32
	<.main+794 @05a2d6>  : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+798 @05a2da>  : 0c 01 00 00                inc.i32(+1)
	<.main+802 @05a2de>  : 51                         add.i32
	<.main+803 @05a2df>  : 0c fc ff ff                inc.i32(-4)
	<.main+807 @05a2e3>  : 2e 98 8b 05                store.m32 <@058b98> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@05a2e7> - <@05a329>): static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+811 @05a2e7>  : 1c 03 00 00 00             load.c32 3
	<.main+816 @05a2ec>  : 10 00                      dup.x32 sp(0)
	<.main+818 @05a2ee>  : 06 0a 00 00                jz <.main+828 @05a2f8>
	<.main+822 @05a2f2>  : 10 00                      dup.x32 sp(0)
	<.main+824 @05a2f4>  : 04 2f 00 00                jmp <.main+871 @05a323>
	<.main+828 @05a2f8>  : 1c 06 00 00 00             load.c32 6
	<.main+833 @05a2fd>  : 10 00                      dup.x32 sp(0)
	<.main+835 @05a2ff>  : 06 0a 00 00                jz <.main+845 @05a309>
	<.main+839 @05a303>  : 10 00                      dup.x32 sp(0)
	<.main+841 @05a305>  : 04 1c 00 00                jmp <.main+869 @05a321>
	<.main+845 @05a309>  : 1c 02 00 00 00             load.c32 2
	<.main+850 @05a30e>  : 10 00                      dup.x32 sp(0)
	<.main+852 @05a310>  : 06 0a 00 00                jz <.main+862 @05a31a>
	<.main+856 @05a314>  : 10 00                      dup.x32 sp(0)
	<.main+858 @05a316>  : 04 09 00 00                jmp <.main+867 @05a31f>
	<.main+862 @05a31a>  : 1c 08 00 00 00             load.c32 8
	<.main+867 @05a31f>  : 13 01                      set.x32 sp(1)
	<.main+869 @05a321>  : 13 01                      set.x32 sp(1)
	<.main+871 @05a323>  : 13 01                      set.x32 sp(1)
	<.main+873 @05a325>  : 2e a0 8b 05                store.m32 <@058ba0> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@05a329> - <@05a36b>): static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+877 @05a329>  : 1c 03 00 00 00             load.c32 3
	<.main+882 @05a32e>  : 10 00                      dup.x32 sp(0)
	<.main+884 @05a330>  : 06 0a 00 00                jz <.main+894 @05a33a>
	<.main+888 @05a334>  : 10 00                      dup.x32 sp(0)
	<.main+890 @05a336>  : 04 09 00 00                jmp <.main+899 @05a33f>
	<.main+894 @05a33a>  : 1c 06 00 00 00             load.c32 6
	<.main+899 @05a33f>  : 13 01                      set.x32 sp(1)
	<.main+901 @05a341>  : 10 00                      dup.x32 sp(0)
	<.main+903 @05a343>  : 06 0a 00 00                jz <.main+913 @05a34d>
	<.main+907 @05a347>  : 10 00                      dup.x32 sp(0)
	<.main+909 @05a349>  : 04 09 00 00                jmp <.main+918 @05a352>
	<.main+913 @05a34d>  : 1c 02 00 00 00             load.c32 2
	<.main+918 @05a352>  : 13 01                      set.x32 sp(1)
	<.main+920 @05a354>  : 10 00                      dup.x32 sp(0)
	<.main+922 @05a356>  : 06 0a 00 00                jz <.main+932 @05a360>
	<.main+926 @05a35a>  : 10 00                      dup.x32 sp(0)
	<.main+928 @05a35c>  : 04 09 00 00                jmp <.main+937 @05a365>
	<.main+932 @05a360>  : 1c 08 00 00 00             load.c32 8
	<.main+937 @05a365>  : 13 01                      set.x32 sp(1)
	<.main+939 @05a367>  : 2e a8 8b 05                store.m32 <@058ba8> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@05a36b> - <@05a3a9>): static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+943 @05a36b>  : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+947 @05a36f>  : 10 00                      dup.x32 sp(0)
	<.main+949 @05a371>  : 06 0a 00 00                jz <.main+959 @05a37b>
	<.main+953 @05a375>  : 10 00                      dup.x32 sp(0)
	<.main+955 @05a377>  : 04 2c 00 00                jmp <.main+999 @05a3a3>
	<.main+959 @05a37b>  : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+963 @05a37f>  : 10 00                      dup.x32 sp(0)
	<.main+965 @05a381>  : 06 0a 00 00                jz <.main+975 @05a38b>
	<.main+969 @05a385>  : 10 00                      dup.x32 sp(0)
	<.main+971 @05a387>  : 04 1a 00 00                jmp <.main+997 @05a3a1>
	<.main+975 @05a38b>  : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+979 @05a38f>  : 10 00                      dup.x32 sp(0)
	<.main+981 @05a391>  : 06 0a 00 00                jz <.main+991 @05a39b>
	<.main+985 @05a395>  : 10 00                      dup.x32 sp(0)
	<.main+987 @05a397>  : 04 08 00 00                jmp <.main+995 @05a39f>
	<.main+991 @05a39b>  : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+995 @05a39f>  : 13 01                      set.x32 sp(1)
	<.main+997 @05a3a1>  : 13 01                      set.x32 sp(1)
	<.main+999 @05a3a3>  : 13 01                      set.x32 sp(1)
	<.main+1001 @05a3a5> : 2e b0 8b 05                store.m32 <@058bb0> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@05a3a9> - <@05a3e7>): static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+1005 @05a3a9> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1009 @05a3ad> : 10 00                      dup.x32 sp(0)
	<.main+1011 @05a3af> : 06 0a 00 00                jz <.main+1021 @05a3b9>
	<.main+1015 @05a3b3> : 10 00                      dup.x32 sp(0)
	<.main+1017 @05a3b5> : 04 08 00 00                jmp <.main+1025 @05a3bd>
	<.main+1021 @05a3b9> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1025 @05a3bd> : 13 01                      set.x32 sp(1)
	<.main+1027 @05a3bf> : 10 00                      dup.x32 sp(0)
	<.main+1029 @05a3c1> : 06 0a 00 00                jz <.main+1039 @05a3cb>
	<.main+1033 @05a3c5> : 10 00                      dup.x32 sp(0)
	<.main+1035 @05a3c7> : 04 08 00 00                jmp <.main+1043 @05a3cf>
	<.main+1039 @05a3cb> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1043 @05a3cf> : 13 01                      set.x32 sp(1)
	<.main+1045 @05a3d1> : 10 00                      dup.x32 sp(0)
	<.main+1047 @05a3d3> : 06 0a 00 00                jz <.main+1057 @05a3dd>
	<.main+1051 @05a3d7> : 10 00                      dup.x32 sp(0)
	<.main+1053 @05a3d9> : 04 08 00 00                jmp <.main+1061 @05a3e1>
	<.main+1057 @05a3dd> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1061 @05a3e1> : 13 01                      set.x32 sp(1)
	<.main+1063 @05a3e3> : 2e b8 8b 05                store.m32 <@058bb8> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@05a3e7> - <@05a439>): static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1067 @05a3e7> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1071 @05a3eb> : 0c 01 00 00                inc.i32(+1)
	<.main+1075 @05a3ef> : 10 00                      dup.x32 sp(0)
	<.main+1077 @05a3f1> : 06 0a 00 00                jz <.main+1087 @05a3fb>
	<.main+1081 @05a3f5> : 10 00                      dup.x32 sp(0)
	<.main+1083 @05a3f7> : 04 38 00 00                jmp <.main+1139 @05a42f>
	<.main+1087 @05a3fb> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1091 @05a3ff> : 0c 01 00 00                inc.i32(+1)
	<.main+1095 @05a403> : 10 00                      dup.x32 sp(0)
	<.main+1097 @05a405> : 06 0a 00 00                jz <.main+1107 @05a40f>
	<.main+1101 @05a409> : 10 00                      dup.x32 sp(0)
	<.main+1103 @05a40b> : 04 22 00 00                jmp <.main+1137 @05a42d>
	<.main+1107 @05a40f> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1111 @05a413> : 0c 01 00 00                inc.i32(+1)
	<.main+1115 @05a417> : 10 00                      dup.x32 sp(0)
	<.main+1117 @05a419> : 06 0a 00 00                jz <.main+1127 @05a423>
	<.main+1121 @05a41d> : 10 00                      dup.x32 sp(0)
	<.main+1123 @05a41f> : 04 0c 00 00                jmp <.main+1135 @05a42b>
	<.main+1127 @05a423> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1131 @05a427> : 0c 01 00 00                inc.i32(+1)
	<.main+1135 @05a42b> : 13 01                      set.x32 sp(1)
	<.main+1137 @05a42d> : 13 01                      set.x32 sp(1)
	<.main+1139 @05a42f> : 13 01                      set.x32 sp(1)
	<.main+1141 @05a431> : 0c ff ff ff                inc.i32(-1)
	<.main+1145 @05a435> : 2e c0 8b 05                store.m32 <@058bc0> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@05a439> - <@05a48b>): static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1149 @05a439> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1153 @05a43d> : 0c 01 00 00                inc.i32(+1)
	<.main+1157 @05a441> : 10 00                      dup.x32 sp(0)
	<.main+1159 @05a443> : 06 0a 00 00                jz <.main+1169 @05a44d>
	<.main+1163 @05a447> : 10 00                      dup.x32 sp(0)
	<.main+1165 @05a449> : 04 0c 00 00                jmp <.main+1177 @05a455>
	<.main+1169 @05a44d> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1173 @05a451> : 0c 01 00 00                inc.i32(+1)
	<.main+1177 @05a455> : 13 01                      set.x32 sp(1)
	<.main+1179 @05a457> : 10 00                      dup.x32 sp(0)
	<.main+1181 @05a459> : 06 0a 00 00                jz <.main+1191 @05a463>
	<.main+1185 @05a45d> : 10 00                      dup.x32 sp(0)
	<.main+1187 @05a45f> : 04 0c 00 00                jmp <.main+1199 @05a46b>
	<.main+1191 @05a463> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1195 @05a467> : 0c 01 00 00                inc.i32(+1)
	<.main+1199 @05a46b> : 13 01                      set.x32 sp(1)
	<.main+1201 @05a46d> : 10 00                      dup.x32 sp(0)
	<.main+1203 @05a46f> : 06 0a 00 00                jz <.main+1213 @05a479>
	<.main+1207 @05a473> : 10 00                      dup.x32 sp(0)
	<.main+1209 @05a475> : 04 0c 00 00                jmp <.main+1221 @05a481>
	<.main+1213 @05a479> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1217 @05a47d> : 0c 01 00 00                inc.i32(+1)
	<.main+1221 @05a481> : 13 01                      set.x32 sp(1)
	<.main+1223 @05a483> : 0c ff ff ff                inc.i32(-1)
	<.main+1227 @05a487> : 2e c8 8b 05                store.m32 <@058bc8> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@05a48b> - <@05a4e8>): static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1231 @05a48b> : 1c 03 00 00 00             load.c32 3
	<.main+1236 @05a490> : 1c 06 00 00 00             load.c32 6
	<.main+1241 @05a495> : 1c 02 00 00 00             load.c32 2
	<.main+1246 @05a49a> : 1c 08 00 00 00             load.c32 8
	<.main+1251 @05a49f> : 10 01                      dup.x32 sp(1)
	<.main+1253 @05a4a1> : 10 01                      dup.x32 sp(1)
	<.main+1255 @05a4a3> : 58                         clt.i32
	<.main+1256 @05a4a4> : 06 0a 00 00                jz <.main+1266 @05a4ae>
	<.main+1260 @05a4a8> : 10 01                      dup.x32 sp(1)
	<.main+1262 @05a4aa> : 04 06 00 00                jmp <.main+1268 @05a4b0>
	<.main+1266 @05a4ae> : 10 00                      dup.x32 sp(0)
	<.main+1268 @05a4b0> : 13 02                      set.x32 sp(2)
	<.main+1270 @05a4b2> : 09 fc ff ff                inc.sp(-4)
	<.main+1274 @05a4b6> : 10 01                      dup.x32 sp(1)
	<.main+1276 @05a4b8> : 10 01                      dup.x32 sp(1)
	<.main+1278 @05a4ba> : 58                         clt.i32
	<.main+1279 @05a4bb> : 06 0a 00 00                jz <.main+1289 @05a4c5>
	<.main+1283 @05a4bf> : 10 01                      dup.x32 sp(1)
	<.main+1285 @05a4c1> : 04 06 00 00                jmp <.main+1291 @05a4c7>
	<.main+1289 @05a4c5> : 10 00                      dup.x32 sp(0)
	<.main+1291 @05a4c7> : 13 02                      set.x32 sp(2)
	<.main+1293 @05a4c9> : 09 fc ff ff                inc.sp(-4)
	<.main+1297 @05a4cd> : 10 01                      dup.x32 sp(1)
	<.main+1299 @05a4cf> : 10 01                      dup.x32 sp(1)
	<.main+1301 @05a4d1> : 58                         clt.i32
	<.main+1302 @05a4d2> : 06 0a 00 00                jz <.main+1312 @05a4dc>
	<.main+1306 @05a4d6> : 10 01                      dup.x32 sp(1)
	<.main+1308 @05a4d8> : 04 06 00 00                jmp <.main+1314 @05a4de>
	<.main+1312 @05a4dc> : 10 00                      dup.x32 sp(0)
	<.main+1314 @05a4de> : 13 02                      set.x32 sp(2)
	<.main+1316 @05a4e0> : 09 fc ff ff                inc.sp(-4)
	<.main+1320 @05a4e4> : 2e d0 8b 05                store.m32 <@058bd0> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@05a4e8> - <@05a545>): static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1324 @05a4e8> : 1c 03 00 00 00             load.c32 3
	<.main+1329 @05a4ed> : 1c 06 00 00 00             load.c32 6
	<.main+1334 @05a4f2> : 10 01                      dup.x32 sp(1)
	<.main+1336 @05a4f4> : 10 01                      dup.x32 sp(1)
	<.main+1338 @05a4f6> : 58                         clt.i32
	<.main+1339 @05a4f7> : 06 0a 00 00                jz <.main+1349 @05a501>
	<.main+1343 @05a4fb> : 10 01                      dup.x32 sp(1)
	<.main+1345 @05a4fd> : 04 06 00 00                jmp <.main+1351 @05a503>
	<.main+1349 @05a501> : 10 00                      dup.x32 sp(0)
	<.main+1351 @05a503> : 13 02                      set.x32 sp(2)
	<.main+1353 @05a505> : 09 fc ff ff                inc.sp(-4)
	<.main+1357 @05a509> : 1c 02 00 00 00             load.c32 2
	<.main+1362 @05a50e> : 10 01                      dup.x32 sp(1)
	<.main+1364 @05a510> : 10 01                      dup.x32 sp(1)
	<.main+1366 @05a512> : 58                         clt.i32
	<.main+1367 @05a513> : 06 0a 00 00                jz <.main+1377 @05a51d>
	<.main+1371 @05a517> : 10 01                      dup.x32 sp(1)
	<.main+1373 @05a519> : 04 06 00 00                jmp <.main+1379 @05a51f>
	<.main+1377 @05a51d> : 10 00                      dup.x32 sp(0)
	<.main+1379 @05a51f> : 13 02                      set.x32 sp(2)
	<.main+1381 @05a521> : 09 fc ff ff                inc.sp(-4)
	<.main+1385 @05a525> : 1c 08 00 00 00             load.c32 8
	<.main+1390 @05a52a> : 10 01                      dup.x32 sp(1)
	<.main+1392 @05a52c> : 10 01                      dup.x32 sp(1)
	<.main+1394 @05a52e> : 58                         clt.i32
	<.main+1395 @05a52f> : 06 0a 00 00                jz <.main+1405 @05a539>
	<.main+1399 @05a533> : 10 01                      dup.x32 sp(1)
	<.main+1401 @05a535> : 04 06 00 00                jmp <.main+1407 @05a53b>
	<.main+1405 @05a539> : 10 00                      dup.x32 sp(0)
	<.main+1407 @05a53b> : 13 02                      set.x32 sp(2)
	<.main+1409 @05a53d> : 09 fc ff ff                inc.sp(-4)
	<.main+1413 @05a541> : 2e d8 8b 05                store.m32 <@058bd8> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@05a545> - <@05a59e>): static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1417 @05a545> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1421 @05a549> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1425 @05a54d> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1429 @05a551> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1433 @05a555> : 10 01                      dup.x32 sp(1)
	<.main+1435 @05a557> : 10 01                      dup.x32 sp(1)
	<.main+1437 @05a559> : 58                         clt.i32
	<.main+1438 @05a55a> : 06 0a 00 00                jz <.main+1448 @05a564>
	<.main+1442 @05a55e> : 10 01                      dup.x32 sp(1)
	<.main+1444 @05a560> : 04 06 00 00                jmp <.main+1450 @05a566>
	<.main+1448 @05a564> : 10 00                      dup.x32 sp(0)
	<.main+1450 @05a566> : 13 02                      set.x32 sp(2)
	<.main+1452 @05a568> : 09 fc ff ff                inc.sp(-4)
	<.main+1456 @05a56c> : 10 01                      dup.x32 sp(1)
	<.main+1458 @05a56e> : 10 01                      dup.x32 sp(1)
	<.main+1460 @05a570> : 58                         clt.i32
	<.main+1461 @05a571> : 06 0a 00 00                jz <.main+1471 @05a57b>
	<.main+1465 @05a575> : 10 01                      dup.x32 sp(1)
	<.main+1467 @05a577> : 04 06 00 00                jmp <.main+1473 @05a57d>
	<.main+1471 @05a57b> : 10 00                      dup.x32 sp(0)
	<.main+1473 @05a57d> : 13 02                      set.x32 sp(2)
	<.main+1475 @05a57f> : 09 fc ff ff                inc.sp(-4)
	<.main+1479 @05a583> : 10 01                      dup.x32 sp(1)
	<.main+1481 @05a585> : 10 01                      dup.x32 sp(1)
	<.main+1483 @05a587> : 58                         clt.i32
	<.main+1484 @05a588> : 06 0a 00 00                jz <.main+1494 @05a592>
	<.main+1488 @05a58c> : 10 01                      dup.x32 sp(1)
	<.main+1490 @05a58e> : 04 06 00 00                jmp <.main+1496 @05a594>
	<.main+1494 @05a592> : 10 00                      dup.x32 sp(0)
	<.main+1496 @05a594> : 13 02                      set.x32 sp(2)
	<.main+1498 @05a596> : 09 fc ff ff                inc.sp(-4)
	<.main+1502 @05a59a> : 2e e0 8b 05                store.m32 <@058be0> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@05a59e> - <@05a5f7>): static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1506 @05a59e> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1510 @05a5a2> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1514 @05a5a6> : 10 01                      dup.x32 sp(1)
	<.main+1516 @05a5a8> : 10 01                      dup.x32 sp(1)
	<.main+1518 @05a5aa> : 58                         clt.i32
	<.main+1519 @05a5ab> : 06 0a 00 00                jz <.main+1529 @05a5b5>
	<.main+1523 @05a5af> : 10 01                      dup.x32 sp(1)
	<.main+1525 @05a5b1> : 04 06 00 00                jmp <.main+1531 @05a5b7>
	<.main+1529 @05a5b5> : 10 00                      dup.x32 sp(0)
	<.main+1531 @05a5b7> : 13 02                      set.x32 sp(2)
	<.main+1533 @05a5b9> : 09 fc ff ff                inc.sp(-4)
	<.main+1537 @05a5bd> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1541 @05a5c1> : 10 01                      dup.x32 sp(1)
	<.main+1543 @05a5c3> : 10 01                      dup.x32 sp(1)
	<.main+1545 @05a5c5> : 58                         clt.i32
	<.main+1546 @05a5c6> : 06 0a 00 00                jz <.main+1556 @05a5d0>
	<.main+1550 @05a5ca> : 10 01                      dup.x32 sp(1)
	<.main+1552 @05a5cc> : 04 06 00 00                jmp <.main+1558 @05a5d2>
	<.main+1556 @05a5d0> : 10 00                      dup.x32 sp(0)
	<.main+1558 @05a5d2> : 13 02                      set.x32 sp(2)
	<.main+1560 @05a5d4> : 09 fc ff ff                inc.sp(-4)
	<.main+1564 @05a5d8> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1568 @05a5dc> : 10 01                      dup.x32 sp(1)
	<.main+1570 @05a5de> : 10 01                      dup.x32 sp(1)
	<.main+1572 @05a5e0> : 58                         clt.i32
	<.main+1573 @05a5e1> : 06 0a 00 00                jz <.main+1583 @05a5eb>
	<.main+1577 @05a5e5> : 10 01                      dup.x32 sp(1)
	<.main+1579 @05a5e7> : 04 06 00 00                jmp <.main+1585 @05a5ed>
	<.main+1583 @05a5eb> : 10 00                      dup.x32 sp(0)
	<.main+1585 @05a5ed> : 13 02                      set.x32 sp(2)
	<.main+1587 @05a5ef> : 09 fc ff ff                inc.sp(-4)
	<.main+1591 @05a5f3> : 2e e8 8b 05                store.m32 <@058be8> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@05a5f7> - <@05a664>): static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1595 @05a5f7> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1599 @05a5fb> : 0c 01 00 00                inc.i32(+1)
	<.main+1603 @05a5ff> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1607 @05a603> : 0c 01 00 00                inc.i32(+1)
	<.main+1611 @05a607> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1615 @05a60b> : 0c 01 00 00                inc.i32(+1)
	<.main+1619 @05a60f> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1623 @05a613> : 0c 01 00 00                inc.i32(+1)
	<.main+1627 @05a617> : 10 01                      dup.x32 sp(1)
	<.main+1629 @05a619> : 10 01                      dup.x32 sp(1)
	<.main+1631 @05a61b> : 58                         clt.i32
	<.main+1632 @05a61c> : 06 0a 00 00                jz <.main+1642 @05a626>
	<.main+1636 @05a620> : 10 01                      dup.x32 sp(1)
	<.main+1638 @05a622> : 04 06 00 00                jmp <.main+1644 @05a628>
	<.main+1642 @05a626> : 10 00                      dup.x32 sp(0)
	<.main+1644 @05a628> : 13 02                      set.x32 sp(2)
	<.main+1646 @05a62a> : 09 fc ff ff                inc.sp(-4)
	<.main+1650 @05a62e> : 10 01                      dup.x32 sp(1)
	<.main+1652 @05a630> : 10 01                      dup.x32 sp(1)
	<.main+1654 @05a632> : 58                         clt.i32
	<.main+1655 @05a633> : 06 0a 00 00                jz <.main+1665 @05a63d>
	<.main+1659 @05a637> : 10 01                      dup.x32 sp(1)
	<.main+1661 @05a639> : 04 06 00 00                jmp <.main+1667 @05a63f>
	<.main+1665 @05a63d> : 10 00                      dup.x32 sp(0)
	<.main+1667 @05a63f> : 13 02                      set.x32 sp(2)
	<.main+1669 @05a641> : 09 fc ff ff                inc.sp(-4)
	<.main+1673 @05a645> : 10 01                      dup.x32 sp(1)
	<.main+1675 @05a647> : 10 01                      dup.x32 sp(1)
	<.main+1677 @05a649> : 58                         clt.i32
	<.main+1678 @05a64a> : 06 0a 00 00                jz <.main+1688 @05a654>
	<.main+1682 @05a64e> : 10 01                      dup.x32 sp(1)
	<.main+1684 @05a650> : 04 06 00 00                jmp <.main+1690 @05a656>
	<.main+1688 @05a654> : 10 00                      dup.x32 sp(0)
	<.main+1690 @05a656> : 13 02                      set.x32 sp(2)
	<.main+1692 @05a658> : 09 fc ff ff                inc.sp(-4)
	<.main+1696 @05a65c> : 0c ff ff ff                inc.i32(-1)
	<.main+1700 @05a660> : 2e f0 8b 05                store.m32 <@058bf0> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@05a664> - <@05a6d1>): static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1704 @05a664> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+1708 @05a668> : 0c 01 00 00                inc.i32(+1)
	<.main+1712 @05a66c> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+1716 @05a670> : 0c 01 00 00                inc.i32(+1)
	<.main+1720 @05a674> : 10 01                      dup.x32 sp(1)
	<.main+1722 @05a676> : 10 01                      dup.x32 sp(1)
	<.main+1724 @05a678> : 58                         clt.i32
	<.main+1725 @05a679> : 06 0a 00 00                jz <.main+1735 @05a683>
	<.main+1729 @05a67d> : 10 01                      dup.x32 sp(1)
	<.main+1731 @05a67f> : 04 06 00 00                jmp <.main+1737 @05a685>
	<.main+1735 @05a683> : 10 00                      dup.x32 sp(0)
	<.main+1737 @05a685> : 13 02                      set.x32 sp(2)
	<.main+1739 @05a687> : 09 fc ff ff                inc.sp(-4)
	<.main+1743 @05a68b> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+1747 @05a68f> : 0c 01 00 00                inc.i32(+1)
	<.main+1751 @05a693> : 10 01                      dup.x32 sp(1)
	<.main+1753 @05a695> : 10 01                      dup.x32 sp(1)
	<.main+1755 @05a697> : 58                         clt.i32
	<.main+1756 @05a698> : 06 0a 00 00                jz <.main+1766 @05a6a2>
	<.main+1760 @05a69c> : 10 01                      dup.x32 sp(1)
	<.main+1762 @05a69e> : 04 06 00 00                jmp <.main+1768 @05a6a4>
	<.main+1766 @05a6a2> : 10 00                      dup.x32 sp(0)
	<.main+1768 @05a6a4> : 13 02                      set.x32 sp(2)
	<.main+1770 @05a6a6> : 09 fc ff ff                inc.sp(-4)
	<.main+1774 @05a6aa> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+1778 @05a6ae> : 0c 01 00 00                inc.i32(+1)
	<.main+1782 @05a6b2> : 10 01                      dup.x32 sp(1)
	<.main+1784 @05a6b4> : 10 01                      dup.x32 sp(1)
	<.main+1786 @05a6b6> : 58                         clt.i32
	<.main+1787 @05a6b7> : 06 0a 00 00                jz <.main+1797 @05a6c1>
	<.main+1791 @05a6bb> : 10 01                      dup.x32 sp(1)
	<.main+1793 @05a6bd> : 04 06 00 00                jmp <.main+1799 @05a6c3>
	<.main+1797 @05a6c1> : 10 00                      dup.x32 sp(0)
	<.main+1799 @05a6c3> : 13 02                      set.x32 sp(2)
	<.main+1801 @05a6c5> : 09 fc ff ff                inc.sp(-4)
	<.main+1805 @05a6c9> : 0c ff ff ff                inc.i32(-1)
	<.main+1809 @05a6cd> : 2e f8 8b 05                store.m32 <@058bf8> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@05a6d1> - <@05a72e>): static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1813 @05a6d1> : 1c 03 00 00 00             load.c32 3
	<.main+1818 @05a6d6> : 1c 06 00 00 00             load.c32 6
	<.main+1823 @05a6db> : 1c 02 00 00 00             load.c32 2
	<.main+1828 @05a6e0> : 1c 08 00 00 00             load.c32 8
	<.main+1833 @05a6e5> : 10 01                      dup.x32 sp(1)
	<.main+1835 @05a6e7> : 10 01                      dup.x32 sp(1)
	<.main+1837 @05a6e9> : 59                         cgt.i32
	<.main+1838 @05a6ea> : 06 0a 00 00                jz <.main+1848 @05a6f4>
	<.main+1842 @05a6ee> : 10 01                      dup.x32 sp(1)
	<.main+1844 @05a6f0> : 04 06 00 00                jmp <.main+1850 @05a6f6>
	<.main+1848 @05a6f4> : 10 00                      dup.x32 sp(0)
	<.main+1850 @05a6f6> : 13 02                      set.x32 sp(2)
	<.main+1852 @05a6f8> : 09 fc ff ff                inc.sp(-4)
	<.main+1856 @05a6fc> : 10 01                      dup.x32 sp(1)
	<.main+1858 @05a6fe> : 10 01                      dup.x32 sp(1)
	<.main+1860 @05a700> : 59                         cgt.i32
	<.main+1861 @05a701> : 06 0a 00 00                jz <.main+1871 @05a70b>
	<.main+1865 @05a705> : 10 01                      dup.x32 sp(1)
	<.main+1867 @05a707> : 04 06 00 00                jmp <.main+1873 @05a70d>
	<.main+1871 @05a70b> : 10 00                      dup.x32 sp(0)
	<.main+1873 @05a70d> : 13 02                      set.x32 sp(2)
	<.main+1875 @05a70f> : 09 fc ff ff                inc.sp(-4)
	<.main+1879 @05a713> : 10 01                      dup.x32 sp(1)
	<.main+1881 @05a715> : 10 01                      dup.x32 sp(1)
	<.main+1883 @05a717> : 59                         cgt.i32
	<.main+1884 @05a718> : 06 0a 00 00                jz <.main+1894 @05a722>
	<.main+1888 @05a71c> : 10 01                      dup.x32 sp(1)
	<.main+1890 @05a71e> : 04 06 00 00                jmp <.main+1896 @05a724>
	<.main+1894 @05a722> : 10 00                      dup.x32 sp(0)
	<.main+1896 @05a724> : 13 02                      set.x32 sp(2)
	<.main+1898 @05a726> : 09 fc ff ff                inc.sp(-4)
	<.main+1902 @05a72a> : 2e 00 8c 05                store.m32 <@058c00> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@05a72e> - <@05a78b>): static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1906 @05a72e> : 1c 03 00 00 00             load.c32 3
	<.main+1911 @05a733> : 1c 06 00 00 00             load.c32 6
	<.main+1916 @05a738> : 10 01                      dup.x32 sp(1)
	<.main+1918 @05a73a> : 10 01                      dup.x32 sp(1)
	<.main+1920 @05a73c> : 59                         cgt.i32
	<.main+1921 @05a73d> : 06 0a 00 00                jz <.main+1931 @05a747>
	<.main+1925 @05a741> : 10 01                      dup.x32 sp(1)
	<.main+1927 @05a743> : 04 06 00 00                jmp <.main+1933 @05a749>
	<.main+1931 @05a747> : 10 00                      dup.x32 sp(0)
	<.main+1933 @05a749> : 13 02                      set.x32 sp(2)
	<.main+1935 @05a74b> : 09 fc ff ff                inc.sp(-4)
	<.main+1939 @05a74f> : 1c 02 00 00 00             load.c32 2
	<.main+1944 @05a754> : 10 01                      dup.x32 sp(1)
	<.main+1946 @05a756> : 10 01                      dup.x32 sp(1)
	<.main+1948 @05a758> : 59                         cgt.i32
	<.main+1949 @05a759> : 06 0a 00 00                jz <.main+1959 @05a763>
	<.main+1953 @05a75d> : 10 01                      dup.x32 sp(1)
	<.main+1955 @05a75f> : 04 06 00 00                jmp <.main+1961 @05a765>
	<.main+1959 @05a763> : 10 00                      dup.x32 sp(0)
	<.main+1961 @05a765> : 13 02                      set.x32 sp(2)
	<.main+1963 @05a767> : 09 fc ff ff                inc.sp(-4)
	<.main+1967 @05a76b> : 1c 08 00 00 00             load.c32 8
	<.main+1972 @05a770> : 10 01                      dup.x32 sp(1)
	<.main+1974 @05a772> : 10 01                      dup.x32 sp(1)
	<.main+1976 @05a774> : 59                         cgt.i32
	<.main+1977 @05a775> : 06 0a 00 00                jz <.main+1987 @05a77f>
	<.main+1981 @05a779> : 10 01                      dup.x32 sp(1)
	<.main+1983 @05a77b> : 04 06 00 00                jmp <.main+1989 @05a781>
	<.main+1987 @05a77f> : 10 00                      dup.x32 sp(0)
	<.main+1989 @05a781> : 13 02                      set.x32 sp(2)
	<.main+1991 @05a783> : 09 fc ff ff                inc.sp(-4)
	<.main+1995 @05a787> : 2e 08 8c 05                store.m32 <@058c08> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@05a78b> - <@05a7e4>): static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1999 @05a78b> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+2003 @05a78f> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+2007 @05a793> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+2011 @05a797> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+2015 @05a79b> : 10 01                      dup.x32 sp(1)
	<.main+2017 @05a79d> : 10 01                      dup.x32 sp(1)
	<.main+2019 @05a79f> : 59                         cgt.i32
	<.main+2020 @05a7a0> : 06 0a 00 00                jz <.main+2030 @05a7aa>
	<.main+2024 @05a7a4> : 10 01                      dup.x32 sp(1)
	<.main+2026 @05a7a6> : 04 06 00 00                jmp <.main+2032 @05a7ac>
	<.main+2030 @05a7aa> : 10 00                      dup.x32 sp(0)
	<.main+2032 @05a7ac> : 13 02                      set.x32 sp(2)
	<.main+2034 @05a7ae> : 09 fc ff ff                inc.sp(-4)
	<.main+2038 @05a7b2> : 10 01                      dup.x32 sp(1)
	<.main+2040 @05a7b4> : 10 01                      dup.x32 sp(1)
	<.main+2042 @05a7b6> : 59                         cgt.i32
	<.main+2043 @05a7b7> : 06 0a 00 00                jz <.main+2053 @05a7c1>
	<.main+2047 @05a7bb> : 10 01                      dup.x32 sp(1)
	<.main+2049 @05a7bd> : 04 06 00 00                jmp <.main+2055 @05a7c3>
	<.main+2053 @05a7c1> : 10 00                      dup.x32 sp(0)
	<.main+2055 @05a7c3> : 13 02                      set.x32 sp(2)
	<.main+2057 @05a7c5> : 09 fc ff ff                inc.sp(-4)
	<.main+2061 @05a7c9> : 10 01                      dup.x32 sp(1)
	<.main+2063 @05a7cb> : 10 01                      dup.x32 sp(1)
	<.main+2065 @05a7cd> : 59                         cgt.i32
	<.main+2066 @05a7ce> : 06 0a 00 00                jz <.main+2076 @05a7d8>
	<.main+2070 @05a7d2> : 10 01                      dup.x32 sp(1)
	<.main+2072 @05a7d4> : 04 06 00 00                jmp <.main+2078 @05a7da>
	<.main+2076 @05a7d8> : 10 00                      dup.x32 sp(0)
	<.main+2078 @05a7da> : 13 02                      set.x32 sp(2)
	<.main+2080 @05a7dc> : 09 fc ff ff                inc.sp(-4)
	<.main+2084 @05a7e0> : 2e 10 8c 05                store.m32 <@058c10> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@05a7e4> - <@05a83d>): static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+2088 @05a7e4> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+2092 @05a7e8> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+2096 @05a7ec> : 10 01                      dup.x32 sp(1)
	<.main+2098 @05a7ee> : 10 01                      dup.x32 sp(1)
	<.main+2100 @05a7f0> : 59                         cgt.i32
	<.main+2101 @05a7f1> : 06 0a 00 00                jz <.main+2111 @05a7fb>
	<.main+2105 @05a7f5> : 10 01                      dup.x32 sp(1)
	<.main+2107 @05a7f7> : 04 06 00 00                jmp <.main+2113 @05a7fd>
	<.main+2111 @05a7fb> : 10 00                      dup.x32 sp(0)
	<.main+2113 @05a7fd> : 13 02                      set.x32 sp(2)
	<.main+2115 @05a7ff> : 09 fc ff ff                inc.sp(-4)
	<.main+2119 @05a803> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+2123 @05a807> : 10 01                      dup.x32 sp(1)
	<.main+2125 @05a809> : 10 01                      dup.x32 sp(1)
	<.main+2127 @05a80b> : 59                         cgt.i32
	<.main+2128 @05a80c> : 06 0a 00 00                jz <.main+2138 @05a816>
	<.main+2132 @05a810> : 10 01                      dup.x32 sp(1)
	<.main+2134 @05a812> : 04 06 00 00                jmp <.main+2140 @05a818>
	<.main+2138 @05a816> : 10 00                      dup.x32 sp(0)
	<.main+2140 @05a818> : 13 02                      set.x32 sp(2)
	<.main+2142 @05a81a> : 09 fc ff ff                inc.sp(-4)
	<.main+2146 @05a81e> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+2150 @05a822> : 10 01                      dup.x32 sp(1)
	<.main+2152 @05a824> : 10 01                      dup.x32 sp(1)
	<.main+2154 @05a826> : 59                         cgt.i32
	<.main+2155 @05a827> : 06 0a 00 00                jz <.main+2165 @05a831>
	<.main+2159 @05a82b> : 10 01                      dup.x32 sp(1)
	<.main+2161 @05a82d> : 04 06 00 00                jmp <.main+2167 @05a833>
	<.main+2165 @05a831> : 10 00                      dup.x32 sp(0)
	<.main+2167 @05a833> : 13 02                      set.x32 sp(2)
	<.main+2169 @05a835> : 09 fc ff ff                inc.sp(-4)
	<.main+2173 @05a839> : 2e 18 8c 05                store.m32 <@058c18> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@05a83d> - <@05a8aa>): static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2177 @05a83d> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+2181 @05a841> : 0c 01 00 00                inc.i32(+1)
	<.main+2185 @05a845> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+2189 @05a849> : 0c 01 00 00                inc.i32(+1)
	<.main+2193 @05a84d> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+2197 @05a851> : 0c 01 00 00                inc.i32(+1)
	<.main+2201 @05a855> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+2205 @05a859> : 0c 01 00 00                inc.i32(+1)
	<.main+2209 @05a85d> : 10 01                      dup.x32 sp(1)
	<.main+2211 @05a85f> : 10 01                      dup.x32 sp(1)
	<.main+2213 @05a861> : 59                         cgt.i32
	<.main+2214 @05a862> : 06 0a 00 00                jz <.main+2224 @05a86c>
	<.main+2218 @05a866> : 10 01                      dup.x32 sp(1)
	<.main+2220 @05a868> : 04 06 00 00                jmp <.main+2226 @05a86e>
	<.main+2224 @05a86c> : 10 00                      dup.x32 sp(0)
	<.main+2226 @05a86e> : 13 02                      set.x32 sp(2)
	<.main+2228 @05a870> : 09 fc ff ff                inc.sp(-4)
	<.main+2232 @05a874> : 10 01                      dup.x32 sp(1)
	<.main+2234 @05a876> : 10 01                      dup.x32 sp(1)
	<.main+2236 @05a878> : 59                         cgt.i32
	<.main+2237 @05a879> : 06 0a 00 00                jz <.main+2247 @05a883>
	<.main+2241 @05a87d> : 10 01                      dup.x32 sp(1)
	<.main+2243 @05a87f> : 04 06 00 00                jmp <.main+2249 @05a885>
	<.main+2247 @05a883> : 10 00                      dup.x32 sp(0)
	<.main+2249 @05a885> : 13 02                      set.x32 sp(2)
	<.main+2251 @05a887> : 09 fc ff ff                inc.sp(-4)
	<.main+2255 @05a88b> : 10 01                      dup.x32 sp(1)
	<.main+2257 @05a88d> : 10 01                      dup.x32 sp(1)
	<.main+2259 @05a88f> : 59                         cgt.i32
	<.main+2260 @05a890> : 06 0a 00 00                jz <.main+2270 @05a89a>
	<.main+2264 @05a894> : 10 01                      dup.x32 sp(1)
	<.main+2266 @05a896> : 04 06 00 00                jmp <.main+2272 @05a89c>
	<.main+2270 @05a89a> : 10 00                      dup.x32 sp(0)
	<.main+2272 @05a89c> : 13 02                      set.x32 sp(2)
	<.main+2274 @05a89e> : 09 fc ff ff                inc.sp(-4)
	<.main+2278 @05a8a2> : 0c ff ff ff                inc.i32(-1)
	<.main+2282 @05a8a6> : 2e 20 8c 05                store.m32 <@058c20> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@05a8aa> - <@05a917>): static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2286 @05a8aa> : 2a c0 8a 05                load.m32 <@058ac0> ;i3
	<.main+2290 @05a8ae> : 0c 01 00 00                inc.i32(+1)
	<.main+2294 @05a8b2> : 2a c8 8a 05                load.m32 <@058ac8> ;i6
	<.main+2298 @05a8b6> : 0c 01 00 00                inc.i32(+1)
	<.main+2302 @05a8ba> : 10 01                      dup.x32 sp(1)
	<.main+2304 @05a8bc> : 10 01                      dup.x32 sp(1)
	<.main+2306 @05a8be> : 59                         cgt.i32
	<.main+2307 @05a8bf> : 06 0a 00 00                jz <.main+2317 @05a8c9>
	<.main+2311 @05a8c3> : 10 01                      dup.x32 sp(1)
	<.main+2313 @05a8c5> : 04 06 00 00                jmp <.main+2319 @05a8cb>
	<.main+2317 @05a8c9> : 10 00                      dup.x32 sp(0)
	<.main+2319 @05a8cb> : 13 02                      set.x32 sp(2)
	<.main+2321 @05a8cd> : 09 fc ff ff                inc.sp(-4)
	<.main+2325 @05a8d1> : 2a d0 8a 05                load.m32 <@058ad0> ;i2
	<.main+2329 @05a8d5> : 0c 01 00 00                inc.i32(+1)
	<.main+2333 @05a8d9> : 10 01                      dup.x32 sp(1)
	<.main+2335 @05a8db> : 10 01                      dup.x32 sp(1)
	<.main+2337 @05a8dd> : 59                         cgt.i32
	<.main+2338 @05a8de> : 06 0a 00 00                jz <.main+2348 @05a8e8>
	<.main+2342 @05a8e2> : 10 01                      dup.x32 sp(1)
	<.main+2344 @05a8e4> : 04 06 00 00                jmp <.main+2350 @05a8ea>
	<.main+2348 @05a8e8> : 10 00                      dup.x32 sp(0)
	<.main+2350 @05a8ea> : 13 02                      set.x32 sp(2)
	<.main+2352 @05a8ec> : 09 fc ff ff                inc.sp(-4)
	<.main+2356 @05a8f0> : 2a d8 8a 05                load.m32 <@058ad8> ;i8
	<.main+2360 @05a8f4> : 0c 01 00 00                inc.i32(+1)
	<.main+2364 @05a8f8> : 10 01                      dup.x32 sp(1)
	<.main+2366 @05a8fa> : 10 01                      dup.x32 sp(1)
	<.main+2368 @05a8fc> : 59                         cgt.i32
	<.main+2369 @05a8fd> : 06 0a 00 00                jz <.main+2379 @05a907>
	<.main+2373 @05a901> : 10 01                      dup.x32 sp(1)
	<.main+2375 @05a903> : 04 06 00 00                jmp <.main+2381 @05a909>
	<.main+2379 @05a907> : 10 00                      dup.x32 sp(0)
	<.main+2381 @05a909> : 13 02                      set.x32 sp(2)
	<.main+2383 @05a90b> : 09 fc ff ff                inc.sp(-4)
	<.main+2387 @05a90f> : 0c ff ff ff                inc.i32(-1)
	<.main+2391 @05a913> : 2e 28 8c 05                store.m32 <@058c28> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@05a917> - <@05a920>): static overload1: float32 := overload
	<.main+2395 @05a917> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2400 @05a91c> : 2e 30 8c 05                store.m32 <@058c30> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@05a920> - <@05a929>): static overload2: float32 := overload()
	<.main+2404 @05a920> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2409 @05a925> : 2e 38 8c 05                store.m32 <@058c38> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@05a929> - <@05a932>): static overload3: float32 := overload(0)
	<.main+2413 @05a929> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2418 @05a92e> : 2e 40 8c 05                store.m32 <@058c40> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@05a932> - <@05a93b>): static overload4: float32 := overload(0.000000)
	<.main+2422 @05a932> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2427 @05a937> : 2e 48 8c 05                store.m32 <@058c48> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@05a93b> - <@05a944>): static overload5: float32 := overload(void(0, 0))
	<.main+2431 @05a93b> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2436 @05a940> : 2e 50 8c 05                store.m32 <@058c50> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@05a944> - <@05a951>): static boilC: Celsius := Celsius(100.000000)
	<.main+2440 @05a944> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2449 @05a94d> : 2d 58 8c 05                store.m64 <@058c58> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@05a951> - <@05a96d>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2453 @05a951> : 2b 58 8c 05                load.m64 <@058c58> ;boilC
	<.main+2457 @05a955> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2466 @05a95e> : 83                         mul.f64
	<.main+2467 @05a95f> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2476 @05a968> : 81                         add.f64
	<.main+2477 @05a969> : 2d 60 8c 05                store.m64 <@058c60> ;boilF
	test/lang/initByRef.ci:7: (13 bytes: <@05a96d> - <@05a97a>): static value: int64 := 42
	<.main+2481 @05a96d> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+2490 @05a976> : 2d 68 8c 05                store.m64 <@058c68> ;value
	test/lang/initByRef.ci:8: (9 bytes: <@05a97a> - <@05a983>): static valueRef: int64 := value
	<.main+2494 @05a97a> : 1f 68 8c 05 00             load.ref <@058c68> ;value
	<.main+2499 @05a97f> : 2e 70 8c 05                store.m32 <@058c70> ;valueRef
	test/lang/initByRef.ci:9: (9 bytes: <@05a983> - <@05a98c>): static valuePtr: pointer := value
	<.main+2503 @05a983> : 1f 68 8c 05 00             load.ref <@058c68> ;value
	<.main+2508 @05a988> : 2e 78 8c 05                store.m32 <@058c78> ;valuePtr
	test/lang/initByRef.ci:10: (14 bytes: <@05a98c> - <@05a99a>): static valueVar: variant := value
	<.main+2512 @05a98c> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2517 @05a991> : 1f 68 8c 05 00             load.ref <@058c68> ;value
	<.main+2522 @05a996> : 2d 80 8c 05                store.m64 <@058c80> ;valueVar
	test/lang/initByRef.ci:12: (9 bytes: <@05a99a> - <@05a9a3>): static fromRef: int64 := valueRef
	<.main+2526 @05a99a> : 2a 70 8c 05                load.m32 <@058c70> ;valueRef
	<.main+2530 @05a99e> : 23                         load.i64
	<.main+2531 @05a99f> : 2d 88 8c 05                store.m64 <@058c88> ;fromRef
	test/lang/initByRef.ci:13: (8 bytes: <@05a9a3> - <@05a9ab>): static fromPtr: int64 := valuePtr
	<.main+2535 @05a9a3> : 2a 78 8c 05                load.m32 <@058c78> ;valuePtr
	<.main+2539 @05a9a7> : 2e 90 8c 05                store.m32 <@058c90> ;fromPtr
	test/lang/initByRef.ci:14: (8 bytes: <@05a9ab> - <@05a9b3>): static fromVar: int64 := valueVar
	<.main+2543 @05a9ab> : 2a 80 8c 05                load.m32 <@058c80> ;valueVar
	<.main+2547 @05a9af> : 2e 98 8c 05                store.m32 <@058c98> ;fromVar
	test/lang/initByRef.ci:16: (9 bytes: <@05a9b3> - <@05a9bc>): static nullRef: int64 := null
	<.main+2551 @05a9b3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2556 @05a9b8> : 2e a0 8c 05                store.m32 <@058ca0> ;nullRef
	test/lang/initByRef.ci:17: (9 bytes: <@05a9bc> - <@05a9c5>): static nullPtr: pointer := null
	<.main+2560 @05a9bc> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2565 @05a9c1> : 2e a8 8c 05                store.m32 <@058ca8> ;nullPtr
	test/lang/initByRef.ci:18: (14 bytes: <@05a9c5> - <@05a9d3>): static nullVar: variant := null
	<.main+2569 @05a9c5> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2574 @05a9ca> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2579 @05a9cf> : 2d b0 8c 05                store.m64 <@058cb0> ;nullVar
	test/lang/initByRef.ci:19: (9 bytes: <@05a9d3> - <@05a9dc>): static nullTyp: typename := null
	<.main+2583 @05a9d3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2588 @05a9d8> : 2e b8 8c 05                store.m32 <@058cb8> ;nullTyp
	test/lang/initByRef.ci:20: (9 bytes: <@05a9dc> - <@05a9e5>): static nullFun: function := null
	<.main+2592 @05a9dc> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2597 @05a9e1> : 2e c0 8c 05                store.m32 <@058cc0> ;nullFun
	test/lang/initByRef.ci:21: (9 bytes: <@05a9e5> - <@05a9ee>): static nullObj: object := null
	<.main+2601 @05a9e5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2606 @05a9ea> : 2e c8 8c 05                store.m32 <@058cc8> ;nullObj
	test/lang/initByRef.ci:23: (9 bytes: <@05a9ee> - <@05a9f7>): static typePtr: pointer := int64
	<.main+2610 @05a9ee> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2615 @05a9f3> : 2e d0 8c 05                store.m32 <@058cd0> ;typePtr
	test/lang/initByRef.ci:24: (14 bytes: <@05a9f7> - <@05aa05>): static typeVar: variant := int64
	<.main+2619 @05a9f7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2624 @05a9fc> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2629 @05aa01> : 2d d8 8c 05                store.m64 <@058cd8> ;typeVar
	test/lang/initByRef.ci:25: (9 bytes: <@05aa05> - <@05aa0e>): static typeTyp: typename := int64
	<.main+2633 @05aa05> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2638 @05aa0a> : 2e e0 8c 05                store.m32 <@058ce0> ;typeTyp
	test/lang/initByRef.ci:27: (8 bytes: <@05aa0e> - <@05aa16>): static local: int64 := value
	<.main+2642 @05aa0e> : 2b 68 8c 05                load.m64 <@058c68> ;value
	<.main+2646 @05aa12> : 2d e8 8c 05                store.m64 <@058ce8> ;local
	test/lang/initByRef.ci:28: (8 bytes: <@05aa16> - <@05aa1e>): static copyVal: int64 := local
	<.main+2650 @05aa16> : 2b e8 8c 05                load.m64 <@058ce8> ;local
	<.main+2654 @05aa1a> : 2d f0 8c 05                store.m64 <@058cf0> ;copyVal
	test/lang/initByRef.ci:29: (8 bytes: <@05aa1e> - <@05aa26>): static copyRef: int64 := valueRef
	<.main+2658 @05aa1e> : 2a 70 8c 05                load.m32 <@058c70> ;valueRef
	<.main+2662 @05aa22> : 2e f8 8c 05                store.m32 <@058cf8> ;copyRef
	test/lang/initByRef.ci:30: (8 bytes: <@05aa26> - <@05aa2e>): static copyPtr: pointer := valuePtr
	<.main+2666 @05aa26> : 2a 78 8c 05                load.m32 <@058c78> ;valuePtr
	<.main+2670 @05aa2a> : 2e 00 8d 05                store.m32 <@058d00> ;copyPtr
	test/lang/initByRef.ci:31: (8 bytes: <@05aa2e> - <@05aa36>): static copyVar: variant := valueVar
	<.main+2674 @05aa2e> : 2b 80 8c 05                load.m64 <@058c80> ;valueVar
	<.main+2678 @05aa32> : 2d 08 8d 05                store.m64 <@058d08> ;copyVar
	test/lang/initByRef.ci:32: (8 bytes: <@05aa36> - <@05aa3e>): static copyTyp: typename := typeTyp
	<.main+2682 @05aa36> : 2a e0 8c 05                load.m32 <@058ce0> ;typeTyp
	<.main+2686 @05aa3a> : 2e 10 8d 05                store.m32 <@058d10> ;copyTyp
	test/lang/initByRef.ci:35: (9 bytes: <@05aa3e> - <@05aa47>): static ptrVoid: pointer := void
	<.main+2690 @05aa3e> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2695 @05aa43> : 2e 18 8d 05                store.m32 <@058d18> ;ptrVoid
	test/lang/initByRef.ci:36: (9 bytes: <@05aa47> - <@05aa50>): static ptrBool: pointer := bool
	<.main+2699 @05aa47> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2704 @05aa4c> : 2e 20 8d 05                store.m32 <@058d20> ;ptrBool
	test/lang/initByRef.ci:37: (9 bytes: <@05aa50> - <@05aa59>): static ptrChar: pointer := char
	<.main+2708 @05aa50> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2713 @05aa55> : 2e 28 8d 05                store.m32 <@058d28> ;ptrChar
	test/lang/initByRef.ci:38: (9 bytes: <@05aa59> - <@05aa62>): static ptrInt8: pointer := int8
	<.main+2717 @05aa59> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2722 @05aa5e> : 2e 30 8d 05                store.m32 <@058d30> ;ptrInt8
	test/lang/initByRef.ci:39: (9 bytes: <@05aa62> - <@05aa6b>): static ptrInt16: pointer := int16
	<.main+2726 @05aa62> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2731 @05aa67> : 2e 38 8d 05                store.m32 <@058d38> ;ptrInt16
	test/lang/initByRef.ci:40: (9 bytes: <@05aa6b> - <@05aa74>): static ptrInt32: pointer := int32
	<.main+2735 @05aa6b> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2740 @05aa70> : 2e 40 8d 05                store.m32 <@058d40> ;ptrInt32
	test/lang/initByRef.ci:41: (9 bytes: <@05aa74> - <@05aa7d>): static ptrInt64: pointer := int64
	<.main+2744 @05aa74> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2749 @05aa79> : 2e 48 8d 05                store.m32 <@058d48> ;ptrInt64
	test/lang/initByRef.ci:42: (9 bytes: <@05aa7d> - <@05aa86>): static ptrUint8: pointer := uint8
	<.main+2753 @05aa7d> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2758 @05aa82> : 2e 50 8d 05                store.m32 <@058d50> ;ptrUint8
	test/lang/initByRef.ci:43: (9 bytes: <@05aa86> - <@05aa8f>): static ptrUint16: pointer := uint16
	<.main+2762 @05aa86> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2767 @05aa8b> : 2e 58 8d 05                store.m32 <@058d58> ;ptrUint16
	test/lang/initByRef.ci:44: (9 bytes: <@05aa8f> - <@05aa98>): static ptrUint32: pointer := uint32
	<.main+2771 @05aa8f> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2776 @05aa94> : 2e 60 8d 05                store.m32 <@058d60> ;ptrUint32
	test/lang/initByRef.ci:45: (9 bytes: <@05aa98> - <@05aaa1>): static ptrUint64: pointer := uint64
	<.main+2780 @05aa98> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+2785 @05aa9d> : 2e 68 8d 05                store.m32 <@058d68> ;ptrUint64
	test/lang/initByRef.ci:46: (9 bytes: <@05aaa1> - <@05aaaa>): static ptrFloat32: pointer := float32
	<.main+2789 @05aaa1> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+2794 @05aaa6> : 2e 70 8d 05                store.m32 <@058d70> ;ptrFloat32
	test/lang/initByRef.ci:47: (9 bytes: <@05aaaa> - <@05aab3>): static ptrFloat64: pointer := float64
	<.main+2798 @05aaaa> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+2803 @05aaaf> : 2e 78 8d 05                store.m32 <@058d78> ;ptrFloat64
	test/lang/initByRef.ci:48: (9 bytes: <@05aab3> - <@05aabc>): static ptrTypename: pointer := typename
	<.main+2807 @05aab3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2812 @05aab8> : 2e 80 8d 05                store.m32 <@058d80> ;ptrTypename
	test/lang/initByRef.ci:49: (9 bytes: <@05aabc> - <@05aac5>): static ptrFunction: pointer := function
	<.main+2816 @05aabc> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+2821 @05aac1> : 2e 88 8d 05                store.m32 <@058d88> ;ptrFunction
	test/lang/initByRef.ci:50: (9 bytes: <@05aac5> - <@05aace>): static ptrPointer: pointer := pointer
	<.main+2825 @05aac5> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2830 @05aaca> : 2e 90 8d 05                store.m32 <@058d90> ;ptrPointer
	test/lang/initByRef.ci:51: (9 bytes: <@05aace> - <@05aad7>): static ptrVariant: pointer := variant
	<.main+2834 @05aace> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+2839 @05aad3> : 2e 98 8d 05                store.m32 <@058d98> ;ptrVariant
	test/lang/initByRef.ci:52: (9 bytes: <@05aad7> - <@05aae0>): static ptrObject: pointer := object
	<.main+2843 @05aad7> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+2848 @05aadc> : 2e a0 8d 05                store.m32 <@058da0> ;ptrObject
	test/lang/initByRef.ci:55: (14 bytes: <@05aae0> - <@05aaee>): static varVoid: variant := void
	<.main+2852 @05aae0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2857 @05aae5> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2862 @05aaea> : 2d a8 8d 05                store.m64 <@058da8> ;varVoid
	test/lang/initByRef.ci:56: (14 bytes: <@05aaee> - <@05aafc>): static varBool: variant := bool
	<.main+2866 @05aaee> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2871 @05aaf3> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2876 @05aaf8> : 2d b0 8d 05                store.m64 <@058db0> ;varBool
	test/lang/initByRef.ci:57: (14 bytes: <@05aafc> - <@05ab0a>): static varChar: variant := char
	<.main+2880 @05aafc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2885 @05ab01> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2890 @05ab06> : 2d b8 8d 05                store.m64 <@058db8> ;varChar
	test/lang/initByRef.ci:58: (14 bytes: <@05ab0a> - <@05ab18>): static varInt8: variant := int8
	<.main+2894 @05ab0a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2899 @05ab0f> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2904 @05ab14> : 2d c0 8d 05                store.m64 <@058dc0> ;varInt8
	test/lang/initByRef.ci:59: (14 bytes: <@05ab18> - <@05ab26>): static varInt16: variant := int16
	<.main+2908 @05ab18> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2913 @05ab1d> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2918 @05ab22> : 2d c8 8d 05                store.m64 <@058dc8> ;varInt16
	test/lang/initByRef.ci:60: (14 bytes: <@05ab26> - <@05ab34>): static varInt32: variant := int32
	<.main+2922 @05ab26> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2927 @05ab2b> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2932 @05ab30> : 2d d0 8d 05                store.m64 <@058dd0> ;varInt32
	test/lang/initByRef.ci:61: (14 bytes: <@05ab34> - <@05ab42>): static varInt64: variant := int64
	<.main+2936 @05ab34> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2941 @05ab39> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2946 @05ab3e> : 2d d8 8d 05                store.m64 <@058dd8> ;varInt64
	test/lang/initByRef.ci:62: (14 bytes: <@05ab42> - <@05ab50>): static varUint8: variant := uint8
	<.main+2950 @05ab42> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2955 @05ab47> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2960 @05ab4c> : 2d e0 8d 05                store.m64 <@058de0> ;varUint8
	test/lang/initByRef.ci:63: (14 bytes: <@05ab50> - <@05ab5e>): static varUint16: variant := uint16
	<.main+2964 @05ab50> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2969 @05ab55> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2974 @05ab5a> : 2d e8 8d 05                store.m64 <@058de8> ;varUint16
	test/lang/initByRef.ci:64: (14 bytes: <@05ab5e> - <@05ab6c>): static varUint32: variant := uint32
	<.main+2978 @05ab5e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2983 @05ab63> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2988 @05ab68> : 2d f0 8d 05                store.m64 <@058df0> ;varUint32
	test/lang/initByRef.ci:65: (14 bytes: <@05ab6c> - <@05ab7a>): static varUint64: variant := uint64
	<.main+2992 @05ab6c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2997 @05ab71> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3002 @05ab76> : 2d f8 8d 05                store.m64 <@058df8> ;varUint64
	test/lang/initByRef.ci:66: (14 bytes: <@05ab7a> - <@05ab88>): static varFloat32: variant := float32
	<.main+3006 @05ab7a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3011 @05ab7f> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3016 @05ab84> : 2d 00 8e 05                store.m64 <@058e00> ;varFloat32
	test/lang/initByRef.ci:67: (14 bytes: <@05ab88> - <@05ab96>): static varFloat64: variant := float64
	<.main+3020 @05ab88> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3025 @05ab8d> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3030 @05ab92> : 2d 08 8e 05                store.m64 <@058e08> ;varFloat64
	test/lang/initByRef.ci:68: (14 bytes: <@05ab96> - <@05aba4>): static varTypename: variant := typename
	<.main+3034 @05ab96> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3039 @05ab9b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3044 @05aba0> : 2d 10 8e 05                store.m64 <@058e10> ;varTypename
	test/lang/initByRef.ci:69: (14 bytes: <@05aba4> - <@05abb2>): static varFunction: variant := function
	<.main+3048 @05aba4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3053 @05aba9> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3058 @05abae> : 2d 18 8e 05                store.m64 <@058e18> ;varFunction
	test/lang/initByRef.ci:70: (14 bytes: <@05abb2> - <@05abc0>): static varPointer: variant := pointer
	<.main+3062 @05abb2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3067 @05abb7> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3072 @05abbc> : 2d 20 8e 05                store.m64 <@058e20> ;varPointer
	test/lang/initByRef.ci:71: (14 bytes: <@05abc0> - <@05abce>): static varVariant: variant := variant
	<.main+3076 @05abc0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3081 @05abc5> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3086 @05abca> : 2d 28 8e 05                store.m64 <@058e28> ;varVariant
	test/lang/initByRef.ci:72: (14 bytes: <@05abce> - <@05abdc>): static varObject: variant := object
	<.main+3090 @05abce> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3095 @05abd3> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3100 @05abd8> : 2d 30 8e 05                store.m64 <@058e30> ;varObject
	test/lang/initByRef.ci:75: (9 bytes: <@05abdc> - <@05abe5>): static typVoid: typename := void
	<.main+3104 @05abdc> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3109 @05abe1> : 2e 38 8e 05                store.m32 <@058e38> ;typVoid
	test/lang/initByRef.ci:76: (9 bytes: <@05abe5> - <@05abee>): static typBool: typename := bool
	<.main+3113 @05abe5> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3118 @05abea> : 2e 40 8e 05                store.m32 <@058e40> ;typBool
	test/lang/initByRef.ci:77: (9 bytes: <@05abee> - <@05abf7>): static typChar: typename := char
	<.main+3122 @05abee> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3127 @05abf3> : 2e 48 8e 05                store.m32 <@058e48> ;typChar
	test/lang/initByRef.ci:78: (9 bytes: <@05abf7> - <@05ac00>): static typInt8: typename := int8
	<.main+3131 @05abf7> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3136 @05abfc> : 2e 50 8e 05                store.m32 <@058e50> ;typInt8
	test/lang/initByRef.ci:79: (9 bytes: <@05ac00> - <@05ac09>): static typInt16: typename := int16
	<.main+3140 @05ac00> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3145 @05ac05> : 2e 58 8e 05                store.m32 <@058e58> ;typInt16
	test/lang/initByRef.ci:80: (9 bytes: <@05ac09> - <@05ac12>): static typInt32: typename := int32
	<.main+3149 @05ac09> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3154 @05ac0e> : 2e 60 8e 05                store.m32 <@058e60> ;typInt32
	test/lang/initByRef.ci:81: (9 bytes: <@05ac12> - <@05ac1b>): static typInt64: typename := int64
	<.main+3158 @05ac12> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3163 @05ac17> : 2e 68 8e 05                store.m32 <@058e68> ;typInt64
	test/lang/initByRef.ci:82: (9 bytes: <@05ac1b> - <@05ac24>): static typUint8: typename := uint8
	<.main+3167 @05ac1b> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3172 @05ac20> : 2e 70 8e 05                store.m32 <@058e70> ;typUint8
	test/lang/initByRef.ci:83: (9 bytes: <@05ac24> - <@05ac2d>): static typUint16: typename := uint16
	<.main+3176 @05ac24> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3181 @05ac29> : 2e 78 8e 05                store.m32 <@058e78> ;typUint16
	test/lang/initByRef.ci:84: (9 bytes: <@05ac2d> - <@05ac36>): static typUint32: typename := uint32
	<.main+3185 @05ac2d> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3190 @05ac32> : 2e 80 8e 05                store.m32 <@058e80> ;typUint32
	test/lang/initByRef.ci:85: (9 bytes: <@05ac36> - <@05ac3f>): static typUint64: typename := uint64
	<.main+3194 @05ac36> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3199 @05ac3b> : 2e 88 8e 05                store.m32 <@058e88> ;typUint64
	test/lang/initByRef.ci:86: (9 bytes: <@05ac3f> - <@05ac48>): static typFloat32: typename := float32
	<.main+3203 @05ac3f> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3208 @05ac44> : 2e 90 8e 05                store.m32 <@058e90> ;typFloat32
	test/lang/initByRef.ci:87: (9 bytes: <@05ac48> - <@05ac51>): static typFloat64: typename := float64
	<.main+3212 @05ac48> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3217 @05ac4d> : 2e 98 8e 05                store.m32 <@058e98> ;typFloat64
	test/lang/initByRef.ci:88: (9 bytes: <@05ac51> - <@05ac5a>): static typTypename: typename := typename
	<.main+3221 @05ac51> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3226 @05ac56> : 2e a0 8e 05                store.m32 <@058ea0> ;typTypename
	test/lang/initByRef.ci:89: (9 bytes: <@05ac5a> - <@05ac63>): static typFunction: typename := function
	<.main+3230 @05ac5a> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3235 @05ac5f> : 2e a8 8e 05                store.m32 <@058ea8> ;typFunction
	test/lang/initByRef.ci:90: (9 bytes: <@05ac63> - <@05ac6c>): static typPointer: typename := pointer
	<.main+3239 @05ac63> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3244 @05ac68> : 2e b0 8e 05                store.m32 <@058eb0> ;typPointer
	test/lang/initByRef.ci:91: (9 bytes: <@05ac6c> - <@05ac75>): static typVariant: typename := variant
	<.main+3248 @05ac6c> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3253 @05ac71> : 2e b8 8e 05                store.m32 <@058eb8> ;typVariant
	test/lang/initByRef.ci:92: (9 bytes: <@05ac75> - <@05ac7e>): static typObject: typename := object
	<.main+3257 @05ac75> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3262 @05ac7a> : 2e c0 8e 05                store.m32 <@058ec0> ;typObject
	test/lang/initByRef.ci:95: (9 bytes: <@05ac7e> - <@05ac87>): static valueOfPtr: pointer := pointer(value)
	<.main+3266 @05ac7e> : 1f 68 8c 05 00             load.ref <@058c68> ;value
	<.main+3271 @05ac83> : 2e c8 8e 05                store.m32 <@058ec8> ;valueOfPtr
	test/lang/initByRef.ci:96: (14 bytes: <@05ac87> - <@05ac95>): static valueOfVar: variant := variant(value)
	<.main+3275 @05ac87> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3280 @05ac8c> : 1f 68 8c 05 00             load.ref <@058c68> ;value
	<.main+3285 @05ac91> : 2d d0 8e 05                store.m64 <@058ed0> ;valueOfVar
	test/lang/initByRef.ci:97: (9 bytes: <@05ac95> - <@05ac9e>): static valueOfTyp: typename := typename(value)
	<.main+3289 @05ac95> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3294 @05ac9a> : 2e d8 8e 05                store.m32 <@058ed8> ;valueOfTyp
	test/lang/initByRef.ci:99: (9 bytes: <@05ac9e> - <@05aca7>): static typeOfValue: typename := typename(value)
	<.main+3298 @05ac9e> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3303 @05aca3> : 2e e0 8e 05                store.m32 <@058ee0> ;typeOfValue
	test/lang/initByRef.ci:105: (13 bytes: <@05aca7> - <@05acb4>): static copyPtrFloat64: variant := ptrFloat64
	<.main+3307 @05aca7> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3312 @05acac> : 2a 78 8d 05                load.m32 <@058d78> ;ptrFloat64
	<.main+3316 @05acb0> : 2d e8 8e 05                store.m64 <@058ee8> ;copyPtrFloat64
	test/lang/initByRef.ci:108: (8 bytes: <@05acb4> - <@05acbc>): static copyVarFloat64: pointer := varFloat64
	<.main+3320 @05acb4> : 2a 08 8e 05                load.m32 <@058e08> ;varFloat64
	<.main+3324 @05acb8> : 2e f0 8e 05                store.m32 <@058ef0> ;copyVarFloat64
	test/lang/function.ci:12: (25 bytes: <@05acbc> - <@05acd5>): static funAddResult: int32 := funAdd(void(2, 7))
	<.main+3328 @05acbc> : 19                         load.z32
	<.main+3329 @05acbd> : 1c 02 00 00 00             load.c32 2
	<.main+3334 @05acc2> : 1c 07 00 00 00             load.c32 7
	<.main+3339 @05acc7> : 1f 00 8f 05 00             load.ref <@058f00> ;funAdd(x: int32, y: int32): int32
	<.main+3344 @05accc> : 02                         call
	<.main+3345 @05accd> : 09 f8 ff ff                inc.sp(-8)
	<.main+3349 @05acd1> : 2e 08 8f 05                store.m32 <@058f08> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@05acd5> - <@05acde>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+3353 @05acd5> : 1f 00 8f 05 00             load.ref <@058f00> ;funAdd(x: int32, y: int32): int32
	<.main+3358 @05acda> : 2e 10 8f 05                store.m32 <@058f10> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@05acde> - <@05acf6>): static funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+3362 @05acde> : 19                         load.z32
	<.main+3363 @05acdf> : 1c 02 00 00 00             load.c32 2
	<.main+3368 @05ace4> : 1c 08 00 00 00             load.c32 8
	<.main+3373 @05ace9> : 2a 10 8f 05                load.m32 <@058f10> ;funAddRef(x: int32, y: int32): int32
	<.main+3377 @05aced> : 02                         call
	<.main+3378 @05acee> : 09 f8 ff ff                inc.sp(-8)
	<.main+3382 @05acf2> : 2e 18 8f 05                store.m32 <@058f18> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@05acf6> - <@05acff>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+3386 @05acf6> : 1f 40 8f 05 00             load.ref <@058f40> ;funMul(x: int32, y: int32): int32
	<.main+3391 @05acfb> : 2e 20 8f 05                store.m32 <@058f20> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@05acff> - <@05ad17>): static funMulResult: int32 := funMul(void(2, 6))
	<.main+3395 @05acff> : 19                         load.z32
	<.main+3396 @05ad00> : 1c 02 00 00 00             load.c32 2
	<.main+3401 @05ad05> : 1c 06 00 00 00             load.c32 6
	<.main+3406 @05ad0a> : 2a 20 8f 05                load.m32 <@058f20> ;funMul(x: int32, y: int32): int32
	<.main+3410 @05ad0e> : 02                         call
	<.main+3411 @05ad0f> : 09 f8 ff ff                inc.sp(-8)
	<.main+3415 @05ad13> : 2e 28 8f 05                store.m32 <@058f28> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@05ad17> - <@05ad1f>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+3419 @05ad17> : 2a 20 8f 05                load.m32 <@058f20> ;funMul(x: int32, y: int32): int32
	<.main+3423 @05ad1b> : 2e 30 8f 05                store.m32 <@058f30> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@05ad1f> - <@05ad37>): static funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+3427 @05ad1f> : 19                         load.z32
	<.main+3428 @05ad20> : 1c 02 00 00 00             load.c32 2
	<.main+3433 @05ad25> : 1c 07 00 00 00             load.c32 7
	<.main+3438 @05ad2a> : 2a 30 8f 05                load.m32 <@058f30> ;funMulRef(x: int32, y: int32): int32
	<.main+3442 @05ad2e> : 02                         call
	<.main+3443 @05ad2f> : 09 f8 ff ff                inc.sp(-8)
	<.main+3447 @05ad33> : 2e 38 8f 05                store.m32 <@058f38> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@05ad37> - <@05ad4b>): static fibonacci_13: uint32 := fib(13)
	<.main+3451 @05ad37> : 19                         load.z32
	<.main+3452 @05ad38> : 1c 0d 00 00 00             load.c32 13
	<.main+3457 @05ad3d> : 1f 48 8f 05 00             load.ref <@058f48> ;fib(n: uint32): uint32
	<.main+3462 @05ad42> : 02                         call
	<.main+3463 @05ad43> : 09 fc ff ff                inc.sp(-4)
	<.main+3467 @05ad47> : 2e 80 8f 05                store.m32 <@058f80> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@05ad4b> - <@05ad53>): static sizeofVoid: int32 := sizeof(void)
	<.main+3471 @05ad4b> : 2a d0 00 00                load.m32 <@0000d0> ;void+32
	<.main+3475 @05ad4f> : 2e 88 8f 05                store.m32 <@058f88> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@05ad53> - <@05ad5b>): static sizeofBool: int32 := sizeof(bool)
	<.main+3479 @05ad53> : 2a 70 01 00                load.m32 <@000170> ;bool+32
	<.main+3483 @05ad57> : 2e 90 8f 05                store.m32 <@058f90> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@05ad5b> - <@05ad63>): static sizeofChar: int32 := sizeof(char)
	<.main+3487 @05ad5b> : 2a 10 02 00                load.m32 <@000210> ;char+32
	<.main+3491 @05ad5f> : 2e 98 8f 05                store.m32 <@058f98> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@05ad63> - <@05ad6b>): static sizeofInt8: int32 := sizeof(int8)
	<.main+3495 @05ad63> : 2a b0 02 00                load.m32 <@0002b0> ;int8+32
	<.main+3499 @05ad67> : 2e a0 8f 05                store.m32 <@058fa0> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@05ad6b> - <@05ad73>): static sizeofInt16: int32 := sizeof(int16)
	<.main+3503 @05ad6b> : 2a 50 03 00                load.m32 <@000350> ;int16+32
	<.main+3507 @05ad6f> : 2e a8 8f 05                store.m32 <@058fa8> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@05ad73> - <@05ad7b>): static sizeofInt32: int32 := sizeof(int32)
	<.main+3511 @05ad73> : 2a f0 03 00                load.m32 <@0003f0> ;int32+32
	<.main+3515 @05ad77> : 2e b0 8f 05                store.m32 <@058fb0> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@05ad7b> - <@05ad83>): static sizeofInt64: int32 := sizeof(int64)
	<.main+3519 @05ad7b> : 2a 90 04 00                load.m32 <@000490> ;int64+32
	<.main+3523 @05ad7f> : 2e b8 8f 05                store.m32 <@058fb8> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@05ad83> - <@05ad8b>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+3527 @05ad83> : 2a 30 05 00                load.m32 <@000530> ;uint8+32
	<.main+3531 @05ad87> : 2e c0 8f 05                store.m32 <@058fc0> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@05ad8b> - <@05ad93>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+3535 @05ad8b> : 2a d0 05 00                load.m32 <@0005d0> ;uint16+32
	<.main+3539 @05ad8f> : 2e c8 8f 05                store.m32 <@058fc8> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@05ad93> - <@05ad9b>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+3543 @05ad93> : 2a 70 06 00                load.m32 <@000670> ;uint32+32
	<.main+3547 @05ad97> : 2e d0 8f 05                store.m32 <@058fd0> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@05ad9b> - <@05ada3>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+3551 @05ad9b> : 2a 10 07 00                load.m32 <@000710> ;uint64+32
	<.main+3555 @05ad9f> : 2e d8 8f 05                store.m32 <@058fd8> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@05ada3> - <@05adab>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+3559 @05ada3> : 2a b0 07 00                load.m32 <@0007b0> ;float32+32
	<.main+3563 @05ada7> : 2e e0 8f 05                store.m32 <@058fe0> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@05adab> - <@05adb3>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+3567 @05adab> : 2a 50 08 00                load.m32 <@000850> ;float64+32
	<.main+3571 @05adaf> : 2e e8 8f 05                store.m32 <@058fe8> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@05adb3> - <@05adbb>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+3575 @05adb3> : 2a f0 08 00                load.m32 <@0008f0> ;pointer+32
	<.main+3579 @05adb7> : 2e f0 8f 05                store.m32 <@058ff0> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@05adbb> - <@05adc3>): static sizeofVariant: int32 := sizeof(variant)
	<.main+3583 @05adbb> : 2a 90 09 00                load.m32 <@000990> ;variant+32
	<.main+3587 @05adbf> : 2e f8 8f 05                store.m32 <@058ff8> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@05adc3> - <@05adcb>): static sizeofTypename: int32 := sizeof(typename)
	<.main+3591 @05adc3> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	<.main+3595 @05adc7> : 2e 00 90 05                store.m32 <@059000> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@05adcb> - <@05add3>): static sizeofFunction: int32 := sizeof(function)
	<.main+3599 @05adcb> : 2a 30 0a 00                load.m32 <@000a30> ;function+32
	<.main+3603 @05adcf> : 2e 08 90 05                store.m32 <@059008> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@05add3> - <@05addb>): static sizeofObject: int32 := sizeof(object)
	<.main+3607 @05add3> : 2a d8 0a 00                load.m32 <@000ad8> ;object+32
	<.main+3611 @05add7> : 2e 10 90 05                store.m32 <@059010> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@05addb> - <@05ade4>): static typeofRecord: typename := RecordSizeofExt
	<.main+3615 @05addb> : 1f 48 e4 03 00             load.ref <@03e448> ;RecordSizeofExt
	<.main+3620 @05ade0> : 2e 18 90 05                store.m32 <@059018> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@05ade4> - <@05adf0>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+3624 @05ade4> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3628 @05ade8> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3632 @05adec> : 2e 20 90 05                store.m32 <@059020> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@05adf0> - <@05adfd>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+3636 @05adf0> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3640 @05adf4> : 0c 28 00 00                inc.i32(+40)
	<.main+3644 @05adf8> : 22                         load.i32
	<.main+3645 @05adf9> : 2e 28 90 05                store.m32 <@059028> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@05adfd> - <@05ae0a>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+3649 @05adfd> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3653 @05ae01> : 0c 20 00 00                inc.i32(+32)
	<.main+3657 @05ae05> : 22                         load.i32
	<.main+3658 @05ae06> : 2e 30 90 05                store.m32 <@059030> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@05ae0a> - <@05ae16>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+3662 @05ae0a> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3666 @05ae0e> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3670 @05ae12> : 2e 38 90 05                store.m32 <@059038> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@05ae16> - <@05ae22>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+3674 @05ae16> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3678 @05ae1a> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3682 @05ae1e> : 2e 40 90 05                store.m32 <@059040> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@05ae22> - <@05ae2e>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+3686 @05ae22> : 2a 18 90 05                load.m32 <@059018> ;typeofRecord
	<.main+3690 @05ae26> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3694 @05ae2a> : 2e 48 90 05                store.m32 <@059048> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@05ae2e> - <@05ae3a>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+3698 @05ae2e> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3702 @05ae32> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3706 @05ae36> : 2e 50 90 05                store.m32 <@059050> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@05ae3a> - <@05ae47>): static offsetOfBase: int32 := typeofBase.offset
	<.main+3710 @05ae3a> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3714 @05ae3e> : 0c 28 00 00                inc.i32(+40)
	<.main+3718 @05ae42> : 22                         load.i32
	<.main+3719 @05ae43> : 2e 58 90 05                store.m32 <@059058> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@05ae47> - <@05ae54>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+3723 @05ae47> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3727 @05ae4b> : 0c 20 00 00                inc.i32(+32)
	<.main+3731 @05ae4f> : 22                         load.i32
	<.main+3732 @05ae50> : 2e 60 90 05                store.m32 <@059060> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@05ae54> - <@05ae60>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+3736 @05ae54> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3740 @05ae58> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3744 @05ae5c> : 2e 68 90 05                store.m32 <@059068> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@05ae60> - <@05ae6c>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+3748 @05ae60> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3752 @05ae64> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3756 @05ae68> : 2e 70 90 05                store.m32 <@059070> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@05ae6c> - <@05ae78>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+3760 @05ae6c> : 2a 48 90 05                load.m32 <@059048> ;typeofBase
	<.main+3764 @05ae70> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3768 @05ae74> : 2e 78 90 05                store.m32 <@059078> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@05ae78> - <@05ae85>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+3772 @05ae78> : 2a 78 90 05                load.m32 <@059078> ;typeofBase1
	<.main+3776 @05ae7c> : 0c 28 00 00                inc.i32(+40)
	<.main+3780 @05ae80> : 22                         load.i32
	<.main+3781 @05ae81> : 2e 80 90 05                store.m32 <@059080> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@05ae85> - <@05ae92>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+3785 @05ae85> : 2a 78 90 05                load.m32 <@059078> ;typeofBase1
	<.main+3789 @05ae89> : 0c 20 00 00                inc.i32(+32)
	<.main+3793 @05ae8d> : 22                         load.i32
	<.main+3794 @05ae8e> : 2e 88 90 05                store.m32 <@059088> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@05ae92> - <@05ae9e>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+3798 @05ae92> : 2a 78 90 05                load.m32 <@059078> ;typeofBase1
	<.main+3802 @05ae96> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3806 @05ae9a> : 2e 90 90 05                store.m32 <@059090> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@05ae9e> - <@05aeab>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+3810 @05ae9e> : 2a 90 90 05                load.m32 <@059090> ;typeofBase2
	<.main+3814 @05aea2> : 0c 28 00 00                inc.i32(+40)
	<.main+3818 @05aea6> : 22                         load.i32
	<.main+3819 @05aea7> : 2e 98 90 05                store.m32 <@059098> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@05aeab> - <@05aeb8>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+3823 @05aeab> : 2a 90 90 05                load.m32 <@059090> ;typeofBase2
	<.main+3827 @05aeaf> : 0c 20 00 00                inc.i32(+32)
	<.main+3831 @05aeb3> : 22                         load.i32
	<.main+3832 @05aeb4> : 2e a0 90 05                store.m32 <@0590a0> ;sizeOfBase2
	test/std/number.ci:3: (13 bytes: <@05aeb8> - <@05aec5>): static pi64: float64 := 3.141593
	<.main+3836 @05aeb8> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+3845 @05aec1> : 2d a8 90 05                store.m64 <@0590a8> ;pi64
	test/std/number.ci:4: (13 bytes: <@05aec5> - <@05aed2>): static e64: float64 := 2.718282
	<.main+3849 @05aec5> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+3858 @05aece> : 2d b0 90 05                store.m64 <@0590b0> ;e64
	test/std/number.ci:6: (9 bytes: <@05aed2> - <@05aedb>): static pi32: float32 := pi64
	<.main+3862 @05aed2> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+3866 @05aed6> : 8c                         f64.2f32
	<.main+3867 @05aed7> : 2e b8 90 05                store.m32 <@0590b8> ;pi32
	test/std/number.ci:7: (9 bytes: <@05aedb> - <@05aee4>): static e32: float32 := e64
	<.main+3871 @05aedb> : 2b b0 90 05                load.m64 <@0590b0> ;e64
	<.main+3875 @05aedf> : 8c                         f64.2f32
	<.main+3876 @05aee0> : 2e c0 90 05                store.m32 <@0590c0> ;e32
	test/std/number.ci:14: (11 bytes: <@05aee4> - <@05aeef>): static r_comp: int32 := int32(14 << 3)
	<.main+3880 @05aee4> : 1c 0e 00 00 00             load.c32 14
	<.main+3885 @05aee9> : 3f 43                      b32.shl 0x003
	<.main+3887 @05aeeb> : 2e c8 90 05                store.m32 <@0590c8> ;r_comp
	test/std/number.ci:15: (11 bytes: <@05aeef> - <@05aefa>): static g_comp: int32 := int32(63 << 2)
	<.main+3891 @05aeef> : 1c 3f 00 00 00             load.c32 63
	<.main+3896 @05aef4> : 3f 42                      b32.shl 0x002
	<.main+3898 @05aef6> : 2e d0 90 05                store.m32 <@0590d0> ;g_comp
	test/std/number.ci:16: (11 bytes: <@05aefa> - <@05af05>): static b_comp: int32 := int32(31 << 3)
	<.main+3902 @05aefa> : 1c 1f 00 00 00             load.c32 31
	<.main+3907 @05aeff> : 3f 43                      b32.shl 0x003
	<.main+3909 @05af01> : 2e d8 90 05                store.m32 <@0590d8> ;b_comp
	test/std/number.ci:18: (38 bytes: <@05af05> - <@05af2b>): static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+3913 @05af05> : 2a c8 90 05                load.m32 <@0590c8> ;r_comp
	<.main+3917 @05af09> : 3f 48                      b32.shl 0x008
	<.main+3919 @05af0b> : 1c 00 f8 00 00             load.c32 63488
	<.main+3924 @05af10> : 31                         and.b32
	<.main+3925 @05af11> : 2a d0 90 05                load.m32 <@0590d0> ;g_comp
	<.main+3929 @05af15> : 3f 43                      b32.shl 0x003
	<.main+3931 @05af17> : 1c e0 07 00 00             load.c32 2016
	<.main+3936 @05af1c> : 31                         and.b32
	<.main+3937 @05af1d> : 32                         or.b32
	<.main+3938 @05af1e> : 2a d8 90 05                load.m32 <@0590d8> ;b_comp
	<.main+3942 @05af22> : 3f c3                      b32.sar 0x003
	<.main+3944 @05af24> : 3f 05                      b32.and 0x01f
	<.main+3946 @05af26> : 32                         or.b32
	<.main+3947 @05af27> : 2e e0 90 05                store.m32 <@0590e0> ;r5g6b5
	test/std/number.ci:19: (36 bytes: <@05af2b> - <@05af4f>): static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3951 @05af2b> : 2a c8 90 05                load.m32 <@0590c8> ;r_comp
	<.main+3955 @05af2f> : 3f 50                      b32.shl 0x010
	<.main+3957 @05af31> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3962 @05af36> : 31                         and.b32
	<.main+3963 @05af37> : 2a d0 90 05                load.m32 <@0590d0> ;g_comp
	<.main+3967 @05af3b> : 3f 48                      b32.shl 0x008
	<.main+3969 @05af3d> : 1c 00 ff 00 00             load.c32 65280
	<.main+3974 @05af42> : 31                         and.b32
	<.main+3975 @05af43> : 32                         or.b32
	<.main+3976 @05af44> : 2a d8 90 05                load.m32 <@0590d8> ;b_comp
	<.main+3980 @05af48> : 3f 08                      b32.and 0x0ff
	<.main+3982 @05af4a> : 32                         or.b32
	<.main+3983 @05af4b> : 2e e8 90 05                store.m32 <@0590e8> ;r8g8b8
	test/std/number.ci:21: (22 bytes: <@05af4f> - <@05af65>): static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3987 @05af4f> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+3991 @05af53> : 1c 0b 00 00 00             load.c32 11
	<.main+3996 @05af58> : 1c 05 00 00 00             load.c32 5
	<.main+4001 @05af5d> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4005 @05af61> : 2e f0 90 05                store.m32 <@0590f0> ;zxtR5
	test/std/number.ci:22: (22 bytes: <@05af65> - <@05af7b>): static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+4009 @05af65> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4013 @05af69> : 1c 05 00 00 00             load.c32 5
	<.main+4018 @05af6e> : 1c 06 00 00 00             load.c32 6
	<.main+4023 @05af73> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4027 @05af77> : 2e f8 90 05                store.m32 <@0590f8> ;zxtG6
	test/std/number.ci:23: (18 bytes: <@05af7b> - <@05af8d>): static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4031 @05af7b> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4035 @05af7f> : 19                         load.z32
	<.main+4036 @05af80> : 1c 05 00 00 00             load.c32 5
	<.main+4041 @05af85> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4045 @05af89> : 2e 00 91 05                store.m32 <@059100> ;zxtB5
	test/std/number.ci:25: (22 bytes: <@05af8d> - <@05afa3>): static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+4049 @05af8d> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4053 @05af91> : 1c 0b 00 00 00             load.c32 11
	<.main+4058 @05af96> : 1c 05 00 00 00             load.c32 5
	<.main+4063 @05af9b> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4067 @05af9f> : 2e 08 91 05                store.m32 <@059108> ;sxtR5
	test/std/number.ci:26: (22 bytes: <@05afa3> - <@05afb9>): static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+4071 @05afa3> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4075 @05afa7> : 1c 05 00 00 00             load.c32 5
	<.main+4080 @05afac> : 1c 06 00 00 00             load.c32 6
	<.main+4085 @05afb1> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4089 @05afb5> : 2e 10 91 05                store.m32 <@059110> ;sxtG6
	test/std/number.ci:27: (18 bytes: <@05afb9> - <@05afcb>): static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4093 @05afb9> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4097 @05afbd> : 19                         load.z32
	<.main+4098 @05afbe> : 1c 05 00 00 00             load.c32 5
	<.main+4103 @05afc3> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4107 @05afc7> : 2e 18 91 05                store.m32 <@059118> ;sxtB5
	test/std/number.ci:29: (22 bytes: <@05afcb> - <@05afe1>): static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+4111 @05afcb> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4115 @05afcf> : 1c 10 00 00 00             load.c32 16
	<.main+4120 @05afd4> : 1c 08 00 00 00             load.c32 8
	<.main+4125 @05afd9> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4129 @05afdd> : 2e 20 91 05                store.m32 <@059120> ;zxtR8
	test/std/number.ci:30: (22 bytes: <@05afe1> - <@05aff7>): static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+4133 @05afe1> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4137 @05afe5> : 1c 08 00 00 00             load.c32 8
	<.main+4142 @05afea> : 1c 08 00 00 00             load.c32 8
	<.main+4147 @05afef> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4151 @05aff3> : 2e 28 91 05                store.m32 <@059128> ;zxtG8
	test/std/number.ci:31: (18 bytes: <@05aff7> - <@05b009>): static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+4155 @05aff7> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4159 @05affb> : 19                         load.z32
	<.main+4160 @05affc> : 1c 08 00 00 00             load.c32 8
	<.main+4165 @05b001> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4169 @05b005> : 2e 30 91 05                store.m32 <@059130> ;zxtB8
	test/std/number.ci:33: (22 bytes: <@05b009> - <@05b01f>): static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+4173 @05b009> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4177 @05b00d> : 1c 10 00 00 00             load.c32 16
	<.main+4182 @05b012> : 1c 08 00 00 00             load.c32 8
	<.main+4187 @05b017> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4191 @05b01b> : 2e 38 91 05                store.m32 <@059138> ;sxtR8
	test/std/number.ci:34: (22 bytes: <@05b01f> - <@05b035>): static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+4195 @05b01f> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4199 @05b023> : 1c 08 00 00 00             load.c32 8
	<.main+4204 @05b028> : 1c 08 00 00 00             load.c32 8
	<.main+4209 @05b02d> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4213 @05b031> : 2e 40 91 05                store.m32 <@059140> ;sxtG8
	test/std/number.ci:35: (18 bytes: <@05b035> - <@05b047>): static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+4217 @05b035> : 2a e8 90 05                load.m32 <@0590e8> ;r8g8b8
	<.main+4221 @05b039> : 19                         load.z32
	<.main+4222 @05b03a> : 1c 08 00 00 00             load.c32 8
	<.main+4227 @05b03f> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4231 @05b043> : 2e 48 91 05                store.m32 <@059148> ;sxtB8
	test/std/number.ci:37: (22 bytes: <@05b047> - <@05b05d>): static testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+4235 @05b047> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4239 @05b04b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4248 @05b054> : 84                         div.f64
	<.main+4249 @05b055> : 01 28 00 00                nfc(40) ;float64.sin(x: float64): float64
	<.main+4253 @05b059> : 2d 50 91 05                store.m64 <@059150> ;testSin_f64
	test/std/number.ci:38: (22 bytes: <@05b05d> - <@05b073>): static testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+4257 @05b05d> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4261 @05b061> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4270 @05b06a> : 84                         div.f64
	<.main+4271 @05b06b> : 01 29 00 00                nfc(41) ;float64.cos(x: float64): float64
	<.main+4275 @05b06f> : 2d 58 91 05                store.m64 <@059158> ;testCos_f64
	test/std/number.ci:39: (22 bytes: <@05b073> - <@05b089>): static testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+4279 @05b073> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4283 @05b077> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+4292 @05b080> : 84                         div.f64
	<.main+4293 @05b081> : 01 2a 00 00                nfc(42) ;float64.tan(x: float64): float64
	<.main+4297 @05b085> : 2d 60 91 05                store.m64 <@059160> ;testTan_f64
	test/std/number.ci:40: (22 bytes: <@05b089> - <@05b09f>): static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+4301 @05b089> : 2b b0 90 05                load.m64 <@0590b0> ;e64
	<.main+4305 @05b08d> : 2b b0 90 05                load.m64 <@0590b0> ;e64
	<.main+4309 @05b091> : 83                         mul.f64
	<.main+4310 @05b092> : 2b b0 90 05                load.m64 <@0590b0> ;e64
	<.main+4314 @05b096> : 83                         mul.f64
	<.main+4315 @05b097> : 01 2b 00 00                nfc(43) ;float64.log(x: float64): float64
	<.main+4319 @05b09b> : 2d 68 91 05                store.m64 <@059168> ;testLog_f64
	test/std/number.ci:41: (17 bytes: <@05b09f> - <@05b0b0>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+4323 @05b09f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4332 @05b0a8> : 01 2c 00 00                nfc(44) ;float64.exp(x: float64): float64
	<.main+4336 @05b0ac> : 2d 70 91 05                store.m64 <@059170> ;testExp_f64
	test/std/number.ci:42: (26 bytes: <@05b0b0> - <@05b0ca>): static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+4340 @05b0b0> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4344 @05b0b4> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4348 @05b0b8> : 83                         mul.f64
	<.main+4349 @05b0b9> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+4358 @05b0c2> : 01 2d 00 00                nfc(45) ;float64.pow(x: float64, y: float64): float64
	<.main+4362 @05b0c6> : 2d 78 91 05                store.m64 <@059178> ;testPow_f64
	test/std/number.ci:43: (17 bytes: <@05b0ca> - <@05b0db>): static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+4366 @05b0ca> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4370 @05b0ce> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4374 @05b0d2> : 83                         mul.f64
	<.main+4375 @05b0d3> : 01 2e 00 00                nfc(46) ;float64.sqrt(x: float64): float64
	<.main+4379 @05b0d7> : 2d 80 91 05                store.m64 <@059180> ;testSqrt_f64
	test/std/number.ci:44: (21 bytes: <@05b0db> - <@05b0f0>): static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+4383 @05b0db> : 2b a8 90 05                load.m64 <@0590a8> ;pi64
	<.main+4387 @05b0df> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4396 @05b0e8> : 01 2f 00 00                nfc(47) ;float64.atan2(x: float64, y: float64): float64
	<.main+4400 @05b0ec> : 2d 88 91 05                store.m64 <@059188> ;testAtan_f64
	test/std/number.ci:46: (18 bytes: <@05b0f0> - <@05b102>): static testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+4404 @05b0f0> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4408 @05b0f4> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4413 @05b0f9> : 74                         div.f32
	<.main+4414 @05b0fa> : 01 20 00 00                nfc(32) ;float32.sin(x: float32): float32
	<.main+4418 @05b0fe> : 2e 90 91 05                store.m32 <@059190> ;testSin_f32
	test/std/number.ci:47: (18 bytes: <@05b102> - <@05b114>): static testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+4422 @05b102> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4426 @05b106> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4431 @05b10b> : 74                         div.f32
	<.main+4432 @05b10c> : 01 21 00 00                nfc(33) ;float32.cos(x: float32): float32
	<.main+4436 @05b110> : 2e 98 91 05                store.m32 <@059198> ;testCos_f32
	test/std/number.ci:48: (18 bytes: <@05b114> - <@05b126>): static testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+4440 @05b114> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4444 @05b118> : 7f 00 00 80 40             load.f32 4.000000
	<.main+4449 @05b11d> : 74                         div.f32
	<.main+4450 @05b11e> : 01 22 00 00                nfc(34) ;float32.tan(x: float32): float32
	<.main+4454 @05b122> : 2e a0 91 05                store.m32 <@0591a0> ;testTan_f32
	test/std/number.ci:49: (22 bytes: <@05b126> - <@05b13c>): static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+4458 @05b126> : 2a c0 90 05                load.m32 <@0590c0> ;e32
	<.main+4462 @05b12a> : 2a c0 90 05                load.m32 <@0590c0> ;e32
	<.main+4466 @05b12e> : 73                         mul.f32
	<.main+4467 @05b12f> : 2a c0 90 05                load.m32 <@0590c0> ;e32
	<.main+4471 @05b133> : 73                         mul.f32
	<.main+4472 @05b134> : 01 23 00 00                nfc(35) ;float32.log(x: float32): float32
	<.main+4476 @05b138> : 2e a8 91 05                store.m32 <@0591a8> ;testLog_f32
	test/std/number.ci:50: (13 bytes: <@05b13c> - <@05b149>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+4480 @05b13c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4485 @05b141> : 01 24 00 00                nfc(36) ;float32.exp(x: float32): float32
	<.main+4489 @05b145> : 2e b0 91 05                store.m32 <@0591b0> ;testExp_f32
	test/std/number.ci:51: (22 bytes: <@05b149> - <@05b15f>): static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+4493 @05b149> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4497 @05b14d> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4501 @05b151> : 73                         mul.f32
	<.main+4502 @05b152> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+4507 @05b157> : 01 25 00 00                nfc(37) ;float32.pow(x: float32, y: float32): float32
	<.main+4511 @05b15b> : 2e b8 91 05                store.m32 <@0591b8> ;testPow_f32
	test/std/number.ci:52: (17 bytes: <@05b15f> - <@05b170>): static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+4515 @05b15f> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4519 @05b163> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4523 @05b167> : 73                         mul.f32
	<.main+4524 @05b168> : 01 26 00 00                nfc(38) ;float32.sqrt(x: float32): float32
	<.main+4528 @05b16c> : 2e c0 91 05                store.m32 <@0591c0> ;testSqrt_f32
	test/std/number.ci:53: (17 bytes: <@05b170> - <@05b181>): static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+4532 @05b170> : 2a b8 90 05                load.m32 <@0590b8> ;pi32
	<.main+4536 @05b174> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4541 @05b179> : 01 27 00 00                nfc(39) ;float32.atan2(x: float32, y: float32): float32
	<.main+4545 @05b17d> : 2e c8 91 05                store.m32 <@0591c8> ;testAtan_f32
	test/std/number.ci:55: (12 bytes: <@05b181> - <@05b18d>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+4549 @05b181> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4553 @05b185> : 01 18 00 00                nfc(24) ;uint32.pop(value: int32): int32
	<.main+4557 @05b189> : 2e d0 91 05                store.m32 <@0591d0> ;testPopulation_u32
	test/std/number.ci:56: (12 bytes: <@05b18d> - <@05b199>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+4561 @05b18d> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4565 @05b191> : 01 19 00 00                nfc(25) ;uint32.swap(value: int32): int32
	<.main+4569 @05b195> : 2e d8 91 05                store.m32 <@0591d8> ;testSwapBits_u32
	test/std/number.ci:57: (12 bytes: <@05b199> - <@05b1a5>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+4573 @05b199> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4577 @05b19d> : 01 1a 00 00                nfc(26) ;uint32.bsr(value: int32): int32
	<.main+4581 @05b1a1> : 2e e0 91 05                store.m32 <@0591e0> ;testBitScanReverse_u32
	test/std/number.ci:58: (12 bytes: <@05b1a5> - <@05b1b1>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+4585 @05b1a5> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4589 @05b1a9> : 01 1b 00 00                nfc(27) ;uint32.bsf(value: int32): int32
	<.main+4593 @05b1ad> : 2e e8 91 05                store.m32 <@0591e8> ;testBitScanForward_u32
	test/std/number.ci:59: (12 bytes: <@05b1b1> - <@05b1bd>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+4597 @05b1b1> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4601 @05b1b5> : 01 1c 00 00                nfc(28) ;uint32.hib(value: int32): int32
	<.main+4605 @05b1b9> : 2e f0 91 05                store.m32 <@0591f0> ;testHighBit_u32
	test/std/number.ci:60: (12 bytes: <@05b1bd> - <@05b1c9>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+4609 @05b1bd> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4613 @05b1c1> : 01 1d 00 00                nfc(29) ;uint32.lob(value: int32): int32
	<.main+4617 @05b1c5> : 2e f8 91 05                store.m32 <@0591f8> ;testLowBit_u32
	test/std/number.ci:62: (18 bytes: <@05b1c9> - <@05b1db>): static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4621 @05b1c9> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4625 @05b1cd> : 19                         load.z32
	<.main+4626 @05b1ce> : 1c 05 00 00 00             load.c32 5
	<.main+4631 @05b1d3> : 01 16 00 00                nfc(22) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4635 @05b1d7> : 2e 00 92 05                store.m32 <@059200> ;testZeroExtend_u32
	test/std/number.ci:63: (18 bytes: <@05b1db> - <@05b1ed>): static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4639 @05b1db> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4643 @05b1df> : 19                         load.z32
	<.main+4644 @05b1e0> : 1c 05 00 00 00             load.c32 5
	<.main+4649 @05b1e5> : 01 17 00 00                nfc(23) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4653 @05b1e9> : 2e 08 92 05                store.m32 <@059208> ;testSignExtend_u32
	test/std/number.ci:65: (20 bytes: <@05b1ed> - <@05b201>): static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+4657 @05b1ed> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4661 @05b1f1> : 5b                         i32.2i64
	<.main+4662 @05b1f2> : 19                         load.z32
	<.main+4663 @05b1f3> : 1c 05 00 00 00             load.c32 5
	<.main+4668 @05b1f8> : 01 1e 00 00                nfc(30) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+4672 @05b1fc> : 6a                         i64.2i32
	<.main+4673 @05b1fd> : 2e 10 92 05                store.m32 <@059210> ;testZeroExtend_u64
	test/std/number.ci:66: (20 bytes: <@05b201> - <@05b215>): static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+4677 @05b201> : 2a e0 90 05                load.m32 <@0590e0> ;r5g6b5
	<.main+4681 @05b205> : 5b                         i32.2i64
	<.main+4682 @05b206> : 19                         load.z32
	<.main+4683 @05b207> : 1c 05 00 00 00             load.c32 5
	<.main+4688 @05b20c> : 01 1f 00 00                nfc(31) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+4692 @05b210> : 6a                         i64.2i32
	<.main+4693 @05b211> : 2e 18 92 05                store.m32 <@059218> ;testSignExtend_u64
	test/std/memory.ci:7: (18 bytes: <@05b215> - <@05b227>): static p1: pointer := malloc(1024)
	<.main+4697 @05b215> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4702 @05b21a> : 1c 00 04 00 00             load.c32 1024
	<.main+4707 @05b21f> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4711 @05b223> : 2e 20 92 05                store.m32 <@059220> ;p1
	test/std/memory.ci:8: (18 bytes: <@05b227> - <@05b239>): static p2: pointer := malloc(80)
	<.main+4715 @05b227> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4720 @05b22c> : 1c 50 00 00 00             load.c32 80
	<.main+4725 @05b231> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4729 @05b235> : 2e 28 92 05                store.m32 <@059228> ;p2
	test/std/memory.ci:9: (18 bytes: <@05b239> - <@05b24b>): static p3: pointer := malloc(160)
	<.main+4733 @05b239> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4738 @05b23e> : 1c a0 00 00 00             load.c32 160
	<.main+4743 @05b243> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4747 @05b247> : 2e 30 92 05                store.m32 <@059230> ;p3
	test/std/memory.ci:10: (18 bytes: <@05b24b> - <@05b25d>): static p4: pointer := malloc(820)
	<.main+4751 @05b24b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4756 @05b250> : 1c 34 03 00 00             load.c32 820
	<.main+4761 @05b255> : 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4765 @05b259> : 2e 38 92 05                store.m32 <@059238> ;p4
	test/std/memory.ci:23: (13 bytes: <@05b25d> - <@05b26a>): static val1: int64 := 42
	<.main+4769 @05b25d> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4778 @05b266> : 2d 40 92 05                store.m64 <@059240> ;val1
	test/std/memory.ci:24: (13 bytes: <@05b26a> - <@05b277>): static val2: int64 := 96
	<.main+4782 @05b26a> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+4791 @05b273> : 2d 48 92 05                store.m64 <@059248> ;val2
	test/std/tryExec.ci:46: (18 bytes: <@05b277> - <@05b289>): static tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+4795 @05b277> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4800 @05b27c> : 1f 50 92 05 00             load.ref <@059250> ;noError(ptr: pointer): void
	<.main+4805 @05b281> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4809 @05b285> : 2e e0 92 05                store.m32 <@0592e0> ;tryExecErr0
	test/std/tryExec.ci:47: (18 bytes: <@05b289> - <@05b29b>): static tryExecErr1: int32 := tryExec(void(null, null))
	<.main+4813 @05b289> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4818 @05b28e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4823 @05b293> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4827 @05b297> : 2e e8 92 05                store.m32 <@0592e8> ;tryExecErr1
	test/std/tryExec.ci:48: (18 bytes: <@05b29b> - <@05b2ad>): static tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+4831 @05b29b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4836 @05b2a0> : 1f 58 92 05 00             load.ref <@059258> ;stackOverflow(ptr: pointer): void
	<.main+4841 @05b2a5> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4845 @05b2a9> : 2e f0 92 05                store.m32 <@0592f0> ;tryExecErr2
	test/std/tryExec.ci:49: (18 bytes: <@05b2ad> - <@05b2bf>): static tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+4849 @05b2ad> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4854 @05b2b2> : 1f 70 92 05 00             load.ref <@059270> ;divisionByZero(args: pointer): void
	<.main+4859 @05b2b7> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4863 @05b2bb> : 2e f8 92 05                store.m32 <@0592f8> ;tryExecErr3
	test/std/tryExec.ci:50: (18 bytes: <@05b2bf> - <@05b2d1>): static tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+4867 @05b2bf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4872 @05b2c4> : 1f d8 92 05 00             load.ref <@0592d8> ;invalidInstruction(args: pointer): void
	<.main+4877 @05b2c9> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4881 @05b2cd> : 2e 00 93 05                store.m32 <@059300> ;tryExecErr4
	test/std/tryExec.ci:51: (18 bytes: <@05b2d1> - <@05b2e3>): static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+4885 @05b2d1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4890 @05b2d6> : 1f c8 92 05 00             load.ref <@0592c8> ;invalidMemoryAccess(args: pointer): void
	<.main+4895 @05b2db> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4899 @05b2df> : 2e 08 93 05                store.m32 <@059308> ;tryExecErr5
	test/std/tryExec.ci:52: (18 bytes: <@05b2e3> - <@05b2f5>): static tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+4903 @05b2e3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4908 @05b2e8> : 1f 80 92 05 00             load.ref <@059280> ;abortExecution(args: pointer): void
	<.main+4913 @05b2ed> : 01 0a 00 00                nfc(10) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4917 @05b2f1> : 2e 10 93 05                store.m32 <@059310> ;tryExecErr6
	test/lang/array.ci:59: (9 bytes: <@05b2f5> - <@05b2fe>): static arrArrayInitNull: int64[*] := null
	<.main+4921 @05b2f5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4926 @05b2fa> : 2e 60 93 05                store.m32 <@059360> ;arrArrayInitNull
	test/lang/array.ci:60: (10 bytes: <@05b2fe> - <@05b308>): static arrSliceInitNull: int64[] := null
	<.main+4930 @05b2fe> : 19                         load.z32
	<.main+4931 @05b2ff> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4936 @05b304> : 2d 68 93 05                store.m64 <@059368> ;arrSliceInitNull
	test/lang/array.ci:63: (9 bytes: <@05b308> - <@05b311>): static arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+4940 @05b308> : 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+4945 @05b30d> : 2e 70 93 05                store.m32 <@059370> ;arrArrayInitFixed
	test/lang/array.ci:64: (14 bytes: <@05b311> - <@05b31f>): static arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+4949 @05b311> : 1c 07 00 00 00             load.c32 7
	<.main+4954 @05b316> : 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+4959 @05b31b> : 2d 78 93 05                store.m64 <@059378> ;arrSliceInitFixed
	test/lang/array.ci:67: (8 bytes: <@05b31f> - <@05b327>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+4963 @05b31f> : 2a 78 93 05                load.m32 <@059378> ;arrSliceInitFixed
	<.main+4967 @05b323> : 2e 80 93 05                store.m32 <@059380> ;arrArrayInitSlice
	test/lang/array.ci:68: (8 bytes: <@05b327> - <@05b32f>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+4971 @05b327> : 2b 78 93 05                load.m64 <@059378> ;arrSliceInitFixed
	<.main+4975 @05b32b> : 2d 88 93 05                store.m64 <@059388> ;arrSliceInitSlice
	test/lang/array.ci:71: (8 bytes: <@05b32f> - <@05b337>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+4979 @05b32f> : 2a 70 93 05                load.m32 <@059370> ;arrArrayInitFixed
	<.main+4983 @05b333> : 2e 90 93 05                store.m32 <@059390> ;arrArrayInitPtr
	test/lang/array.ci:86: (9 bytes: <@05b337> - <@05b340>): static strArray: char[*] := "string"
	<.main+4987 @05b337> : 1f bc 25 03 00             load.ref <@0325bc> ;"string"
	<.main+4992 @05b33c> : 2e a0 93 05                store.m32 <@0593a0> ;strArray
	test/lang/array.ci:90: (14 bytes: <@05b340> - <@05b34e>): static strSlice: char[] := "string"
	<.main+4996 @05b340> : 1c 06 00 00 00             load.c32 6
	<.main+5001 @05b345> : 1f bc 25 03 00             load.ref <@0325bc> ;"string"
	<.main+5006 @05b34a> : 2d a8 93 05                store.m64 <@0593a8> ;strSlice
	test/lang/member.ci:35: (5 bytes: <@05b34e> - <@05b353>): static global: int32
	<.main+5010 @05b34e> : 19                         load.z32
	<.main+5011 @05b34f> : 2e e8 93 05                store.m32 <@0593e8> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@05b353> - <@05b35c>): static globalInit: int32 := 1
	<.main+5015 @05b353> : 1c 01 00 00 00             load.c32 1
	<.main+5020 @05b358> : 2e f0 93 05                store.m32 <@0593f0> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@05b35c> - <@05b365>): static const globalConstant: int32 := 2
	<.main+5024 @05b35c> : 1c 02 00 00 00             load.c32 2
	<.main+5029 @05b361> : 2e f8 93 05                store.m32 <@0593f8> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@05b365> - <@05b377>): static globalRecInit: Inner := {...}
	<.main+5033 @05b365> : 1c 04 00 00 00             load.c32 4
	<.main+5038 @05b36a> : 2e 08 94 05                store.m32 <@059408> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@05b36e> - <@05b377>): void(globalRecInit.constant := 5);
	<.main+5042 @05b36e> : 1c 05 00 00 00             load.c32 5
	<.main+5047 @05b373> : 2e 0c 94 05                store.m32 <@05940c> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@05b377> - <@05b389>): static const globalConstantRec: Inner := {...}
	<.main+5051 @05b377> : 1c 06 00 00 00             load.c32 6
	<.main+5056 @05b37c> : 2e 10 94 05                store.m32 <@059410> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@05b380> - <@05b389>): void(globalConstantRec.constant := 7);
	<.main+5060 @05b380> : 1c 07 00 00 00             load.c32 7
	<.main+5065 @05b385> : 2e 14 94 05                store.m32 <@059414> ;RecordMemberTest.globalConstantRec+4
	test/lang/member.ci:53: (72 bytes: <@05b389> - <@05b3d1>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5069 @05b389> : 1c 0a 00 00 00             load.c32 10
	<.main+5074 @05b38e> : 2e 18 94 05                store.m32 <@059418> ;recordMemberTest
	test/lang/member.ci:55: (9 bytes: <@05b392> - <@05b39b>): void(recordMemberTest.constant := 11);
	<.main+5078 @05b392> : 1c 0b 00 00 00             load.c32 11
	<.main+5083 @05b397> : 2e 1c 94 05                store.m32 <@05941c> ;recordMemberTest+4
	test/lang/member.ci:56: (9 bytes: <@05b39b> - <@05b3a4>): void(recordMemberTest.memberInit := 12);
	<.main+5087 @05b39b> : 1c 0c 00 00 00             load.c32 12
	<.main+5092 @05b3a0> : 2e 20 94 05                store.m32 <@059420> ;recordMemberTest+8
	test/lang/member.ci:57: (9 bytes: <@05b3a4> - <@05b3ad>): void(recordMemberTest.constantInit := 13);
	<.main+5096 @05b3a4> : 1c 0d 00 00 00             load.c32 13
	<.main+5101 @05b3a9> : 2e 24 94 05                store.m32 <@059424> ;recordMemberTest+12
	test/lang/member.ci:60: (9 bytes: <@05b3ad> - <@05b3b6>): void(recordMemberTest.memberRec.member := 14);
	<.main+5105 @05b3ad> : 1c 0e 00 00 00             load.c32 14
	<.main+5110 @05b3b2> : 2e 28 94 05                store.m32 <@059428> ;recordMemberTest+16
	test/lang/member.ci:61: (9 bytes: <@05b3b6> - <@05b3bf>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5114 @05b3b6> : 1c 0f 00 00 00             load.c32 15
	<.main+5119 @05b3bb> : 2e 2c 94 05                store.m32 <@05942c> ;recordMemberTest+20
	test/lang/member.ci:65: (9 bytes: <@05b3bf> - <@05b3c8>): void(recordMemberTest.constantRec.member := 16);
	<.main+5123 @05b3bf> : 1c 10 00 00 00             load.c32 16
	<.main+5128 @05b3c4> : 2e 30 94 05                store.m32 <@059430> ;recordMemberTest+24
	test/lang/member.ci:66: (9 bytes: <@05b3c8> - <@05b3d1>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5132 @05b3c8> : 1c 11 00 00 00             load.c32 17
	<.main+5137 @05b3cd> : 2e 34 94 05                store.m32 <@059434> ;recordMemberTest+28
	test/lang/method.ci:18: (9 bytes: <@05b3d1> - <@05b3da>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5141 @05b3d1> : 1f 90 94 05 00             load.ref <@059490> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5146 @05b3d6> : 2e 60 94 05                store.m32 <@059460> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/method.ci:62: (26 bytes: <@05b3da> - <@05b3f4>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5150 @05b3da> : 1f b8 94 05 00             load.ref <@0594b8> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5155 @05b3df> : 2e e0 94 05                store.m32 <@0594e0> ;recordMethodTest
	:: (8 bytes: <@05b3e3> - <@05b3eb>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5159 @05b3e3> : 2a 60 94 05                load.m32 <@059460> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5163 @05b3e7> : 2e e4 94 05                store.m32 <@0594e4> ;recordMethodTest+4
	:: (9 bytes: <@05b3eb> - <@05b3f4>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5167 @05b3eb> : 1f 68 94 05 00             load.ref <@059468> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5172 @05b3f0> : 2e e8 94 05                store.m32 <@0594e8> ;recordMethodTest+8
	test/lang/recUnion.ci:26: (21 bytes: <@05b3f4> - <@05b409>): static black: rgbU8 := {...}
	<.main+5176 @05b3f4> : 19                         load.z32
	<.main+5177 @05b3f5> : 1f 7a 95 05 00             load.ref <@05957a> ;black+2
	<.main+5182 @05b3fa> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@05b3fb> - <@05b402>): void(black.g := (0));
	<.main+5183 @05b3fb> : 19                         load.z32
	<.main+5184 @05b3fc> : 1f 79 95 05 00             load.ref <@059579> ;black+1
	<.main+5189 @05b401> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@05b402> - <@05b409>): void(black.b := (0));
	<.main+5190 @05b402> : 19                         load.z32
	<.main+5191 @05b403> : 1f 78 95 05 00             load.ref <@059578> ;black
	<.main+5196 @05b408> : 25                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@05b409> - <@05b422>): static green: rgbU8 := {...}
	<.main+5197 @05b409> : 19                         load.z32
	<.main+5198 @05b40a> : 1f 82 95 05 00             load.ref <@059582> ;green+2
	<.main+5203 @05b40f> : 25                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@05b410> - <@05b41b>): void(green.g := (255));
	<.main+5204 @05b410> : 1c ff 00 00 00             load.c32 255
	<.main+5209 @05b415> : 1f 81 95 05 00             load.ref <@059581> ;green+1
	<.main+5214 @05b41a> : 25                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@05b41b> - <@05b422>): void(green.b := (0));
	<.main+5215 @05b41b> : 19                         load.z32
	<.main+5216 @05b41c> : 1f 80 95 05 00             load.ref <@059580> ;green
	<.main+5221 @05b421> : 25                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@05b422> - <@05b443>): static white: rgbU8 := {...}
	<.main+5222 @05b422> : 1c ff 00 00 00             load.c32 255
	<.main+5227 @05b427> : 1f 8a 95 05 00             load.ref <@05958a> ;white+2
	<.main+5232 @05b42c> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@05b42d> - <@05b438>): void(white.g := (255));
	<.main+5233 @05b42d> : 1c ff 00 00 00             load.c32 255
	<.main+5238 @05b432> : 1f 89 95 05 00             load.ref <@059589> ;white+1
	<.main+5243 @05b437> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@05b438> - <@05b443>): void(white.b := (255));
	<.main+5244 @05b438> : 1c ff 00 00 00             load.c32 255
	<.main+5249 @05b43d> : 1f 88 95 05 00             load.ref <@059588> ;white
	<.main+5254 @05b442> : 25                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@05b443> - <@05b44c>): static cyan: color := {...}
	<.main+5255 @05b443> : 1c ff ff 00 00             load.c32 65535
	<.main+5260 @05b448> : 2e 90 95 05                store.m32 <@059590> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@05b44c> - <@05b465>): static blue: color := {...}
	<.main+5264 @05b44c> : 19                         load.z32
	<.main+5265 @05b44d> : 1f 9a 95 05 00             load.ref <@05959a> ;blue+2
	<.main+5270 @05b452> : 25                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@05b453> - <@05b45a>): void(blue.rgb.g := (0));
	<.main+5271 @05b453> : 19                         load.z32
	<.main+5272 @05b454> : 1f 99 95 05 00             load.ref <@059599> ;blue+1
	<.main+5277 @05b459> : 25                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@05b45a> - <@05b465>): void(blue.rgb.b := (255));
	<.main+5278 @05b45a> : 1c ff 00 00 00             load.c32 255
	<.main+5283 @05b45f> : 1f 98 95 05 00             load.ref <@059598> ;blue
	<.main+5288 @05b464> : 25                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@05b465> - <@05b46e>): static shift: int32 := 2
	<.main+5289 @05b465> : 1c 02 00 00 00             load.c32 2
	<.main+5294 @05b46a> : 2e a0 95 05                store.m32 <@0595a0> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@05b46e> - <@05b479>): static boolA: bool := true
	<.main+5298 @05b46e> : 1c 01 00 00 00             load.c32 1
	<.main+5303 @05b473> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5308 @05b478> : 25                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@05b479> - <@05b484>): static boolB: bool := bool(!false)
	<.main+5309 @05b479> : 1c 01 00 00 00             load.c32 1
	<.main+5314 @05b47e> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5319 @05b483> : 25                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@05b484> - <@05b497>): static boolAnd: bool := bool(boolA & boolB)
	<.main+5320 @05b484> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5325 @05b489> : 20                         load.i8
	<.main+5326 @05b48a> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5331 @05b48f> : 20                         load.i8
	<.main+5332 @05b490> : 31                         and.b32
	<.main+5333 @05b491> : 1f b8 95 05 00             load.ref <@0595b8> ;boolAnd
	<.main+5338 @05b496> : 25                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@05b497> - <@05b4aa>): static boolIor: bool := bool(boolA | boolB)
	<.main+5339 @05b497> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5344 @05b49c> : 20                         load.i8
	<.main+5345 @05b49d> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5350 @05b4a2> : 20                         load.i8
	<.main+5351 @05b4a3> : 32                         or.b32
	<.main+5352 @05b4a4> : 1f c0 95 05 00             load.ref <@0595c0> ;boolIor
	<.main+5357 @05b4a9> : 25                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@05b4aa> - <@05b4bd>): static boolXor: bool := bool(boolA ^ boolB)
	<.main+5358 @05b4aa> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5363 @05b4af> : 20                         load.i8
	<.main+5364 @05b4b0> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5369 @05b4b5> : 20                         load.i8
	<.main+5370 @05b4b6> : 36                         xor.b32
	<.main+5371 @05b4b7> : 1f c8 95 05 00             load.ref <@0595c8> ;boolXor
	<.main+5376 @05b4bc> : 25                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@05b4bd> - <@05b4ca>): static boolNot: bool := bool(!boolB)
	<.main+5377 @05b4bd> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5382 @05b4c2> : 20                         load.i8
	<.main+5383 @05b4c3> : 0b                         not.b32
	<.main+5384 @05b4c4> : 1f d0 95 05 00             load.ref <@0595d0> ;boolNot
	<.main+5389 @05b4c9> : 25                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@05b4ca> - <@05b4dd>): static boolCeq: bool := bool(boolA == boolB)
	<.main+5390 @05b4ca> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5395 @05b4cf> : 20                         load.i8
	<.main+5396 @05b4d0> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5401 @05b4d5> : 20                         load.i8
	<.main+5402 @05b4d6> : 57                         ceq.i32
	<.main+5403 @05b4d7> : 1f d8 95 05 00             load.ref <@0595d8> ;boolCeq
	<.main+5408 @05b4dc> : 25                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@05b4dd> - <@05b4f1>): static boolCne: bool := bool(boolA != boolB)
	<.main+5409 @05b4dd> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5414 @05b4e2> : 20                         load.i8
	<.main+5415 @05b4e3> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5420 @05b4e8> : 20                         load.i8
	<.main+5421 @05b4e9> : 57                         ceq.i32
	<.main+5422 @05b4ea> : 0b                         not.b32
	<.main+5423 @05b4eb> : 1f e0 95 05 00             load.ref <@0595e0> ;boolCne
	<.main+5428 @05b4f0> : 25                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@05b4f1> - <@05b504>): static boolClt: bool := bool(boolA < boolB)
	<.main+5429 @05b4f1> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5434 @05b4f6> : 20                         load.i8
	<.main+5435 @05b4f7> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5440 @05b4fc> : 20                         load.i8
	<.main+5441 @05b4fd> : 58                         clt.i32
	<.main+5442 @05b4fe> : 1f e8 95 05 00             load.ref <@0595e8> ;boolClt
	<.main+5447 @05b503> : 25                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@05b504> - <@05b518>): static boolCle: bool := bool(boolA <= boolB)
	<.main+5448 @05b504> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5453 @05b509> : 20                         load.i8
	<.main+5454 @05b50a> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5459 @05b50f> : 20                         load.i8
	<.main+5460 @05b510> : 59                         cgt.i32
	<.main+5461 @05b511> : 0b                         not.b32
	<.main+5462 @05b512> : 1f f0 95 05 00             load.ref <@0595f0> ;boolCle
	<.main+5467 @05b517> : 25                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@05b518> - <@05b52b>): static boolCgt: bool := bool(boolA > boolB)
	<.main+5468 @05b518> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5473 @05b51d> : 20                         load.i8
	<.main+5474 @05b51e> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5479 @05b523> : 20                         load.i8
	<.main+5480 @05b524> : 59                         cgt.i32
	<.main+5481 @05b525> : 1f f8 95 05 00             load.ref <@0595f8> ;boolCgt
	<.main+5486 @05b52a> : 25                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@05b52b> - <@05b53f>): static boolCge: bool := bool(boolA >= boolB)
	<.main+5487 @05b52b> : 1f a8 95 05 00             load.ref <@0595a8> ;boolA
	<.main+5492 @05b530> : 20                         load.i8
	<.main+5493 @05b531> : 1f b0 95 05 00             load.ref <@0595b0> ;boolB
	<.main+5498 @05b536> : 20                         load.i8
	<.main+5499 @05b537> : 58                         clt.i32
	<.main+5500 @05b538> : 0b                         not.b32
	<.main+5501 @05b539> : 1f 00 96 05 00             load.ref <@059600> ;boolCge
	<.main+5506 @05b53e> : 25                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@05b53f> - <@05b54a>): static chrA: char := 'a'
	<.main+5507 @05b53f> : 1c 61 00 00 00             load.c32 97
	<.main+5512 @05b544> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5517 @05b549> : 25                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@05b54a> - <@05b555>): static chrB: char := 'b'
	<.main+5518 @05b54a> : 1c 62 00 00 00             load.c32 98
	<.main+5523 @05b54f> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5528 @05b554> : 25                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@05b555> - <@05b561>): static chrPls: char := char(+chrB)
	<.main+5529 @05b555> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5534 @05b55a> : 20                         load.i8
	<.main+5535 @05b55b> : 1f 18 96 05 00             load.ref <@059618> ;chrPls
	<.main+5540 @05b560> : 25                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@05b561> - <@05b56e>): static chrNeg: char := char(-chrB)
	<.main+5541 @05b561> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5546 @05b566> : 20                         load.i8
	<.main+5547 @05b567> : 50                         neg.i32
	<.main+5548 @05b568> : 1f 20 96 05 00             load.ref <@059620> ;chrNeg
	<.main+5553 @05b56d> : 25                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@05b56e> - <@05b57b>): static chrCmt: char := char(~chrB)
	<.main+5554 @05b56e> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5559 @05b573> : 20                         load.i8
	<.main+5560 @05b574> : 30                         cmt.b32
	<.main+5561 @05b575> : 1f 28 96 05 00             load.ref <@059628> ;chrCmt
	<.main+5566 @05b57a> : 25                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@05b57b> - <@05b58e>): static chrAdd: char := char(chrA + chrB)
	<.main+5567 @05b57b> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5572 @05b580> : 20                         load.i8
	<.main+5573 @05b581> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5578 @05b586> : 20                         load.i8
	<.main+5579 @05b587> : 51                         add.i32
	<.main+5580 @05b588> : 1f 30 96 05 00             load.ref <@059630> ;chrAdd
	<.main+5585 @05b58d> : 25                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@05b58e> - <@05b5a1>): static chrSub: char := char(chrA - chrB)
	<.main+5586 @05b58e> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5591 @05b593> : 20                         load.i8
	<.main+5592 @05b594> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5597 @05b599> : 20                         load.i8
	<.main+5598 @05b59a> : 52                         sub.i32
	<.main+5599 @05b59b> : 1f 38 96 05 00             load.ref <@059638> ;chrSub
	<.main+5604 @05b5a0> : 25                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@05b5a1> - <@05b5b4>): static chrMul: char := char(chrA * chrB)
	<.main+5605 @05b5a1> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5610 @05b5a6> : 20                         load.i8
	<.main+5611 @05b5a7> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5616 @05b5ac> : 20                         load.i8
	<.main+5617 @05b5ad> : 53                         mul.i32
	<.main+5618 @05b5ae> : 1f 40 96 05 00             load.ref <@059640> ;chrMul
	<.main+5623 @05b5b3> : 25                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@05b5b4> - <@05b5c7>): static chrDiv: char := char(chrA / chrB)
	<.main+5624 @05b5b4> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5629 @05b5b9> : 20                         load.i8
	<.main+5630 @05b5ba> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5635 @05b5bf> : 20                         load.i8
	<.main+5636 @05b5c0> : 54                         div.i32
	<.main+5637 @05b5c1> : 1f 48 96 05 00             load.ref <@059648> ;chrDiv
	<.main+5642 @05b5c6> : 25                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@05b5c7> - <@05b5da>): static chrMod: char := char(chrA % chrB)
	<.main+5643 @05b5c7> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5648 @05b5cc> : 20                         load.i8
	<.main+5649 @05b5cd> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5654 @05b5d2> : 20                         load.i8
	<.main+5655 @05b5d3> : 55                         mod.i32
	<.main+5656 @05b5d4> : 1f 50 96 05 00             load.ref <@059650> ;chrMod
	<.main+5661 @05b5d9> : 25                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@05b5da> - <@05b5ed>): static chrAnd: char := char(chrA & chrB)
	<.main+5662 @05b5da> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5667 @05b5df> : 20                         load.i8
	<.main+5668 @05b5e0> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5673 @05b5e5> : 20                         load.i8
	<.main+5674 @05b5e6> : 31                         and.b32
	<.main+5675 @05b5e7> : 1f 58 96 05 00             load.ref <@059658> ;chrAnd
	<.main+5680 @05b5ec> : 25                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@05b5ed> - <@05b600>): static chrIor: char := char(chrA | chrB)
	<.main+5681 @05b5ed> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5686 @05b5f2> : 20                         load.i8
	<.main+5687 @05b5f3> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5692 @05b5f8> : 20                         load.i8
	<.main+5693 @05b5f9> : 32                         or.b32
	<.main+5694 @05b5fa> : 1f 60 96 05 00             load.ref <@059660> ;chrIor
	<.main+5699 @05b5ff> : 25                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@05b600> - <@05b613>): static chrXor: char := char(chrA ^ chrB)
	<.main+5700 @05b600> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5705 @05b605> : 20                         load.i8
	<.main+5706 @05b606> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5711 @05b60b> : 20                         load.i8
	<.main+5712 @05b60c> : 36                         xor.b32
	<.main+5713 @05b60d> : 1f 68 96 05 00             load.ref <@059668> ;chrXor
	<.main+5718 @05b612> : 25                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@05b613> - <@05b624>): static chrShl: char := int32((chrA) << shift)
	<.main+5719 @05b613> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5724 @05b618> : 20                         load.i8
	<.main+5725 @05b619> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+5729 @05b61d> : 3a                         shl.b32
	<.main+5730 @05b61e> : 1f 70 96 05 00             load.ref <@059670> ;chrShl
	<.main+5735 @05b623> : 25                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@05b624> - <@05b635>): static chrShr: char := int32((chrA) >> shift)
	<.main+5736 @05b624> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5741 @05b629> : 20                         load.i8
	<.main+5742 @05b62a> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+5746 @05b62e> : 3c                         sar.b32
	<.main+5747 @05b62f> : 1f 78 96 05 00             load.ref <@059678> ;chrShr
	<.main+5752 @05b634> : 25                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@05b635> - <@05b643>): static chrNot: bool := bool(!(chrB))
	<.main+5753 @05b635> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5758 @05b63a> : 20                         load.i8
	<.main+5759 @05b63b> : 5a                         i32.2bool
	<.main+5760 @05b63c> : 0b                         not.b32
	<.main+5761 @05b63d> : 1f 80 96 05 00             load.ref <@059680> ;chrNot
	<.main+5766 @05b642> : 25                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@05b643> - <@05b656>): static chrCeq: bool := bool(chrA == chrB)
	<.main+5767 @05b643> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5772 @05b648> : 20                         load.i8
	<.main+5773 @05b649> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5778 @05b64e> : 20                         load.i8
	<.main+5779 @05b64f> : 57                         ceq.i32
	<.main+5780 @05b650> : 1f 88 96 05 00             load.ref <@059688> ;chrCeq
	<.main+5785 @05b655> : 25                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@05b656> - <@05b66a>): static chrCne: bool := bool(chrA != chrB)
	<.main+5786 @05b656> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5791 @05b65b> : 20                         load.i8
	<.main+5792 @05b65c> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5797 @05b661> : 20                         load.i8
	<.main+5798 @05b662> : 57                         ceq.i32
	<.main+5799 @05b663> : 0b                         not.b32
	<.main+5800 @05b664> : 1f 90 96 05 00             load.ref <@059690> ;chrCne
	<.main+5805 @05b669> : 25                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@05b66a> - <@05b67d>): static chrClt: bool := bool(chrA < chrB)
	<.main+5806 @05b66a> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5811 @05b66f> : 20                         load.i8
	<.main+5812 @05b670> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5817 @05b675> : 20                         load.i8
	<.main+5818 @05b676> : 58                         clt.i32
	<.main+5819 @05b677> : 1f 98 96 05 00             load.ref <@059698> ;chrClt
	<.main+5824 @05b67c> : 25                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@05b67d> - <@05b691>): static chrCle: bool := bool(chrA <= chrB)
	<.main+5825 @05b67d> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5830 @05b682> : 20                         load.i8
	<.main+5831 @05b683> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5836 @05b688> : 20                         load.i8
	<.main+5837 @05b689> : 59                         cgt.i32
	<.main+5838 @05b68a> : 0b                         not.b32
	<.main+5839 @05b68b> : 1f a0 96 05 00             load.ref <@0596a0> ;chrCle
	<.main+5844 @05b690> : 25                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@05b691> - <@05b6a4>): static chrCgt: bool := bool(chrA > chrB)
	<.main+5845 @05b691> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5850 @05b696> : 20                         load.i8
	<.main+5851 @05b697> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5856 @05b69c> : 20                         load.i8
	<.main+5857 @05b69d> : 59                         cgt.i32
	<.main+5858 @05b69e> : 1f a8 96 05 00             load.ref <@0596a8> ;chrCgt
	<.main+5863 @05b6a3> : 25                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@05b6a4> - <@05b6b8>): static chrCge: bool := bool(chrA >= chrB)
	<.main+5864 @05b6a4> : 1f 08 96 05 00             load.ref <@059608> ;chrA
	<.main+5869 @05b6a9> : 20                         load.i8
	<.main+5870 @05b6aa> : 1f 10 96 05 00             load.ref <@059610> ;chrB
	<.main+5875 @05b6af> : 20                         load.i8
	<.main+5876 @05b6b0> : 58                         clt.i32
	<.main+5877 @05b6b1> : 0b                         not.b32
	<.main+5878 @05b6b2> : 1f b0 96 05 00             load.ref <@0596b0> ;chrCge
	<.main+5883 @05b6b7> : 25                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@05b6b8> - <@05b6c3>): static i8A: int8 := a
	<.main+5884 @05b6b8> : 1c 60 00 00 00             load.c32 96
	<.main+5889 @05b6bd> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+5894 @05b6c2> : 25                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@05b6c3> - <@05b6ce>): static i8B: int8 := b
	<.main+5895 @05b6c3> : 1c 2a 00 00 00             load.c32 42
	<.main+5900 @05b6c8> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5905 @05b6cd> : 25                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@05b6ce> - <@05b6da>): static i8Pls: int8 := int8(+i8B)
	<.main+5906 @05b6ce> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5911 @05b6d3> : 20                         load.i8
	<.main+5912 @05b6d4> : 1f c8 96 05 00             load.ref <@0596c8> ;i8Pls
	<.main+5917 @05b6d9> : 25                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@05b6da> - <@05b6e7>): static i8Neg: int8 := int8(-i8B)
	<.main+5918 @05b6da> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5923 @05b6df> : 20                         load.i8
	<.main+5924 @05b6e0> : 50                         neg.i32
	<.main+5925 @05b6e1> : 1f d0 96 05 00             load.ref <@0596d0> ;i8Neg
	<.main+5930 @05b6e6> : 25                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@05b6e7> - <@05b6f4>): static i8Cmt: int8 := int8(~i8B)
	<.main+5931 @05b6e7> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5936 @05b6ec> : 20                         load.i8
	<.main+5937 @05b6ed> : 30                         cmt.b32
	<.main+5938 @05b6ee> : 1f d8 96 05 00             load.ref <@0596d8> ;i8Cmt
	<.main+5943 @05b6f3> : 25                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@05b6f4> - <@05b707>): static i8Add: int8 := int8(i8A + i8B)
	<.main+5944 @05b6f4> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+5949 @05b6f9> : 20                         load.i8
	<.main+5950 @05b6fa> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5955 @05b6ff> : 20                         load.i8
	<.main+5956 @05b700> : 51                         add.i32
	<.main+5957 @05b701> : 1f e0 96 05 00             load.ref <@0596e0> ;i8Add
	<.main+5962 @05b706> : 25                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@05b707> - <@05b71a>): static i8Sub: int8 := int8(i8A - i8B)
	<.main+5963 @05b707> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+5968 @05b70c> : 20                         load.i8
	<.main+5969 @05b70d> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5974 @05b712> : 20                         load.i8
	<.main+5975 @05b713> : 52                         sub.i32
	<.main+5976 @05b714> : 1f e8 96 05 00             load.ref <@0596e8> ;i8Sub
	<.main+5981 @05b719> : 25                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@05b71a> - <@05b72d>): static i8Mul: int8 := int8(i8A * i8B)
	<.main+5982 @05b71a> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+5987 @05b71f> : 20                         load.i8
	<.main+5988 @05b720> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+5993 @05b725> : 20                         load.i8
	<.main+5994 @05b726> : 53                         mul.i32
	<.main+5995 @05b727> : 1f f0 96 05 00             load.ref <@0596f0> ;i8Mul
	<.main+6000 @05b72c> : 25                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@05b72d> - <@05b740>): static i8Div: int8 := int8(i8A / i8B)
	<.main+6001 @05b72d> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6006 @05b732> : 20                         load.i8
	<.main+6007 @05b733> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6012 @05b738> : 20                         load.i8
	<.main+6013 @05b739> : 54                         div.i32
	<.main+6014 @05b73a> : 1f f8 96 05 00             load.ref <@0596f8> ;i8Div
	<.main+6019 @05b73f> : 25                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@05b740> - <@05b753>): static i8Mod: int8 := int8(i8A % i8B)
	<.main+6020 @05b740> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6025 @05b745> : 20                         load.i8
	<.main+6026 @05b746> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6031 @05b74b> : 20                         load.i8
	<.main+6032 @05b74c> : 55                         mod.i32
	<.main+6033 @05b74d> : 1f 00 97 05 00             load.ref <@059700> ;i8Mod
	<.main+6038 @05b752> : 25                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@05b753> - <@05b766>): static i8And: int8 := int8(i8A & i8B)
	<.main+6039 @05b753> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6044 @05b758> : 20                         load.i8
	<.main+6045 @05b759> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6050 @05b75e> : 20                         load.i8
	<.main+6051 @05b75f> : 31                         and.b32
	<.main+6052 @05b760> : 1f 08 97 05 00             load.ref <@059708> ;i8And
	<.main+6057 @05b765> : 25                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@05b766> - <@05b779>): static i8Ior: int8 := int8(i8A | i8B)
	<.main+6058 @05b766> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6063 @05b76b> : 20                         load.i8
	<.main+6064 @05b76c> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6069 @05b771> : 20                         load.i8
	<.main+6070 @05b772> : 32                         or.b32
	<.main+6071 @05b773> : 1f 10 97 05 00             load.ref <@059710> ;i8Ior
	<.main+6076 @05b778> : 25                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@05b779> - <@05b78c>): static i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6077 @05b779> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6082 @05b77e> : 20                         load.i8
	<.main+6083 @05b77f> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6088 @05b784> : 20                         load.i8
	<.main+6089 @05b785> : 36                         xor.b32
	<.main+6090 @05b786> : 1f 18 97 05 00             load.ref <@059718> ;i8Xor
	<.main+6095 @05b78b> : 25                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@05b78c> - <@05b79d>): static i8Shl: int8 := int32((i8A) << shift)
	<.main+6096 @05b78c> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6101 @05b791> : 20                         load.i8
	<.main+6102 @05b792> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6106 @05b796> : 3a                         shl.b32
	<.main+6107 @05b797> : 1f 20 97 05 00             load.ref <@059720> ;i8Shl
	<.main+6112 @05b79c> : 25                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@05b79d> - <@05b7ae>): static i8Shr: int8 := int32((i8A) >> shift)
	<.main+6113 @05b79d> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6118 @05b7a2> : 20                         load.i8
	<.main+6119 @05b7a3> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6123 @05b7a7> : 3c                         sar.b32
	<.main+6124 @05b7a8> : 1f 28 97 05 00             load.ref <@059728> ;i8Shr
	<.main+6129 @05b7ad> : 25                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@05b7ae> - <@05b7bc>): static i8Not: bool := bool(!(i8B))
	<.main+6130 @05b7ae> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6135 @05b7b3> : 20                         load.i8
	<.main+6136 @05b7b4> : 5a                         i32.2bool
	<.main+6137 @05b7b5> : 0b                         not.b32
	<.main+6138 @05b7b6> : 1f 30 97 05 00             load.ref <@059730> ;i8Not
	<.main+6143 @05b7bb> : 25                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@05b7bc> - <@05b7cf>): static i8Ceq: bool := bool(i8A == i8B)
	<.main+6144 @05b7bc> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6149 @05b7c1> : 20                         load.i8
	<.main+6150 @05b7c2> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6155 @05b7c7> : 20                         load.i8
	<.main+6156 @05b7c8> : 57                         ceq.i32
	<.main+6157 @05b7c9> : 1f 38 97 05 00             load.ref <@059738> ;i8Ceq
	<.main+6162 @05b7ce> : 25                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@05b7cf> - <@05b7e3>): static i8Cne: bool := bool(i8A != i8B)
	<.main+6163 @05b7cf> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6168 @05b7d4> : 20                         load.i8
	<.main+6169 @05b7d5> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6174 @05b7da> : 20                         load.i8
	<.main+6175 @05b7db> : 57                         ceq.i32
	<.main+6176 @05b7dc> : 0b                         not.b32
	<.main+6177 @05b7dd> : 1f 40 97 05 00             load.ref <@059740> ;i8Cne
	<.main+6182 @05b7e2> : 25                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@05b7e3> - <@05b7f6>): static i8Clt: bool := bool(i8A < i8B)
	<.main+6183 @05b7e3> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6188 @05b7e8> : 20                         load.i8
	<.main+6189 @05b7e9> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6194 @05b7ee> : 20                         load.i8
	<.main+6195 @05b7ef> : 58                         clt.i32
	<.main+6196 @05b7f0> : 1f 48 97 05 00             load.ref <@059748> ;i8Clt
	<.main+6201 @05b7f5> : 25                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@05b7f6> - <@05b80a>): static i8Cle: bool := bool(i8A <= i8B)
	<.main+6202 @05b7f6> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6207 @05b7fb> : 20                         load.i8
	<.main+6208 @05b7fc> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6213 @05b801> : 20                         load.i8
	<.main+6214 @05b802> : 59                         cgt.i32
	<.main+6215 @05b803> : 0b                         not.b32
	<.main+6216 @05b804> : 1f 50 97 05 00             load.ref <@059750> ;i8Cle
	<.main+6221 @05b809> : 25                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@05b80a> - <@05b81d>): static i8Cgt: bool := bool(i8A > i8B)
	<.main+6222 @05b80a> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6227 @05b80f> : 20                         load.i8
	<.main+6228 @05b810> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6233 @05b815> : 20                         load.i8
	<.main+6234 @05b816> : 59                         cgt.i32
	<.main+6235 @05b817> : 1f 58 97 05 00             load.ref <@059758> ;i8Cgt
	<.main+6240 @05b81c> : 25                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@05b81d> - <@05b831>): static i8Cge: bool := bool(i8A >= i8B)
	<.main+6241 @05b81d> : 1f b8 96 05 00             load.ref <@0596b8> ;i8A
	<.main+6246 @05b822> : 20                         load.i8
	<.main+6247 @05b823> : 1f c0 96 05 00             load.ref <@0596c0> ;i8B
	<.main+6252 @05b828> : 20                         load.i8
	<.main+6253 @05b829> : 58                         clt.i32
	<.main+6254 @05b82a> : 0b                         not.b32
	<.main+6255 @05b82b> : 1f 60 97 05 00             load.ref <@059760> ;i8Cge
	<.main+6260 @05b830> : 25                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@05b831> - <@05b83c>): static u8A: uint8 := a
	<.main+6261 @05b831> : 1c 60 00 00 00             load.c32 96
	<.main+6266 @05b836> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6271 @05b83b> : 25                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@05b83c> - <@05b847>): static u8B: uint8 := b
	<.main+6272 @05b83c> : 1c 2a 00 00 00             load.c32 42
	<.main+6277 @05b841> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6282 @05b846> : 25                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@05b847> - <@05b853>): static u8Pls: uint8 := uint8(+u8B)
	<.main+6283 @05b847> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6288 @05b84c> : 20                         load.i8
	<.main+6289 @05b84d> : 1f 78 97 05 00             load.ref <@059778> ;u8Pls
	<.main+6294 @05b852> : 25                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@05b853> - <@05b860>): static u8Neg: uint8 := uint8(-u8B)
	<.main+6295 @05b853> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6300 @05b858> : 20                         load.i8
	<.main+6301 @05b859> : 50                         neg.i32
	<.main+6302 @05b85a> : 1f 80 97 05 00             load.ref <@059780> ;u8Neg
	<.main+6307 @05b85f> : 25                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@05b860> - <@05b86d>): static u8Cmt: uint8 := uint8(~u8B)
	<.main+6308 @05b860> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6313 @05b865> : 20                         load.i8
	<.main+6314 @05b866> : 30                         cmt.b32
	<.main+6315 @05b867> : 1f 88 97 05 00             load.ref <@059788> ;u8Cmt
	<.main+6320 @05b86c> : 25                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@05b86d> - <@05b880>): static u8Add: uint8 := uint8(u8A + u8B)
	<.main+6321 @05b86d> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6326 @05b872> : 20                         load.i8
	<.main+6327 @05b873> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6332 @05b878> : 20                         load.i8
	<.main+6333 @05b879> : 51                         add.i32
	<.main+6334 @05b87a> : 1f 90 97 05 00             load.ref <@059790> ;u8Add
	<.main+6339 @05b87f> : 25                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@05b880> - <@05b893>): static u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6340 @05b880> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6345 @05b885> : 20                         load.i8
	<.main+6346 @05b886> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6351 @05b88b> : 20                         load.i8
	<.main+6352 @05b88c> : 52                         sub.i32
	<.main+6353 @05b88d> : 1f 98 97 05 00             load.ref <@059798> ;u8Sub
	<.main+6358 @05b892> : 25                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@05b893> - <@05b8a6>): static u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6359 @05b893> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6364 @05b898> : 20                         load.i8
	<.main+6365 @05b899> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6370 @05b89e> : 20                         load.i8
	<.main+6371 @05b89f> : 33                         mul.u32
	<.main+6372 @05b8a0> : 1f a0 97 05 00             load.ref <@0597a0> ;u8Mul
	<.main+6377 @05b8a5> : 25                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@05b8a6> - <@05b8b9>): static u8Div: uint8 := uint8(u8A / u8B)
	<.main+6378 @05b8a6> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6383 @05b8ab> : 20                         load.i8
	<.main+6384 @05b8ac> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6389 @05b8b1> : 20                         load.i8
	<.main+6390 @05b8b2> : 34                         div.u32
	<.main+6391 @05b8b3> : 1f a8 97 05 00             load.ref <@0597a8> ;u8Div
	<.main+6396 @05b8b8> : 25                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@05b8b9> - <@05b8cc>): static u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6397 @05b8b9> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6402 @05b8be> : 20                         load.i8
	<.main+6403 @05b8bf> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6408 @05b8c4> : 20                         load.i8
	<.main+6409 @05b8c5> : 35                         mod.u32
	<.main+6410 @05b8c6> : 1f b0 97 05 00             load.ref <@0597b0> ;u8Mod
	<.main+6415 @05b8cb> : 25                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@05b8cc> - <@05b8df>): static u8And: uint8 := uint8(u8A & u8B)
	<.main+6416 @05b8cc> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6421 @05b8d1> : 20                         load.i8
	<.main+6422 @05b8d2> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6427 @05b8d7> : 20                         load.i8
	<.main+6428 @05b8d8> : 31                         and.b32
	<.main+6429 @05b8d9> : 1f b8 97 05 00             load.ref <@0597b8> ;u8And
	<.main+6434 @05b8de> : 25                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@05b8df> - <@05b8f2>): static u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6435 @05b8df> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6440 @05b8e4> : 20                         load.i8
	<.main+6441 @05b8e5> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6446 @05b8ea> : 20                         load.i8
	<.main+6447 @05b8eb> : 32                         or.b32
	<.main+6448 @05b8ec> : 1f c0 97 05 00             load.ref <@0597c0> ;u8Ior
	<.main+6453 @05b8f1> : 25                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@05b8f2> - <@05b905>): static u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6454 @05b8f2> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6459 @05b8f7> : 20                         load.i8
	<.main+6460 @05b8f8> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6465 @05b8fd> : 20                         load.i8
	<.main+6466 @05b8fe> : 36                         xor.b32
	<.main+6467 @05b8ff> : 1f c8 97 05 00             load.ref <@0597c8> ;u8Xor
	<.main+6472 @05b904> : 25                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@05b905> - <@05b916>): static u8Shl: uint8 := int32((u8A) << shift)
	<.main+6473 @05b905> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6478 @05b90a> : 20                         load.i8
	<.main+6479 @05b90b> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6483 @05b90f> : 3a                         shl.b32
	<.main+6484 @05b910> : 1f d0 97 05 00             load.ref <@0597d0> ;u8Shl
	<.main+6489 @05b915> : 25                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@05b916> - <@05b927>): static u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6490 @05b916> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6495 @05b91b> : 20                         load.i8
	<.main+6496 @05b91c> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6500 @05b920> : 3c                         sar.b32
	<.main+6501 @05b921> : 1f d8 97 05 00             load.ref <@0597d8> ;u8Shr
	<.main+6506 @05b926> : 25                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@05b927> - <@05b935>): static u8Not: bool := bool(!(u8B))
	<.main+6507 @05b927> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6512 @05b92c> : 20                         load.i8
	<.main+6513 @05b92d> : 5a                         i32.2bool
	<.main+6514 @05b92e> : 0b                         not.b32
	<.main+6515 @05b92f> : 1f e0 97 05 00             load.ref <@0597e0> ;u8Not
	<.main+6520 @05b934> : 25                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@05b935> - <@05b948>): static u8Ceq: bool := bool(u8A == u8B)
	<.main+6521 @05b935> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6526 @05b93a> : 20                         load.i8
	<.main+6527 @05b93b> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6532 @05b940> : 20                         load.i8
	<.main+6533 @05b941> : 57                         ceq.i32
	<.main+6534 @05b942> : 1f e8 97 05 00             load.ref <@0597e8> ;u8Ceq
	<.main+6539 @05b947> : 25                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@05b948> - <@05b95c>): static u8Cne: bool := bool(u8A != u8B)
	<.main+6540 @05b948> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6545 @05b94d> : 20                         load.i8
	<.main+6546 @05b94e> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6551 @05b953> : 20                         load.i8
	<.main+6552 @05b954> : 57                         ceq.i32
	<.main+6553 @05b955> : 0b                         not.b32
	<.main+6554 @05b956> : 1f f0 97 05 00             load.ref <@0597f0> ;u8Cne
	<.main+6559 @05b95b> : 25                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@05b95c> - <@05b96f>): static u8Clt: bool := bool(u8A < u8B)
	<.main+6560 @05b95c> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6565 @05b961> : 20                         load.i8
	<.main+6566 @05b962> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6571 @05b967> : 20                         load.i8
	<.main+6572 @05b968> : 38                         clt.u32
	<.main+6573 @05b969> : 1f f8 97 05 00             load.ref <@0597f8> ;u8Clt
	<.main+6578 @05b96e> : 25                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@05b96f> - <@05b983>): static u8Cle: bool := bool(u8A <= u8B)
	<.main+6579 @05b96f> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6584 @05b974> : 20                         load.i8
	<.main+6585 @05b975> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6590 @05b97a> : 20                         load.i8
	<.main+6591 @05b97b> : 39                         cgt.u32
	<.main+6592 @05b97c> : 0b                         not.b32
	<.main+6593 @05b97d> : 1f 00 98 05 00             load.ref <@059800> ;u8Cle
	<.main+6598 @05b982> : 25                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@05b983> - <@05b996>): static u8Cgt: bool := bool(u8A > u8B)
	<.main+6599 @05b983> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6604 @05b988> : 20                         load.i8
	<.main+6605 @05b989> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6610 @05b98e> : 20                         load.i8
	<.main+6611 @05b98f> : 39                         cgt.u32
	<.main+6612 @05b990> : 1f 08 98 05 00             load.ref <@059808> ;u8Cgt
	<.main+6617 @05b995> : 25                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@05b996> - <@05b9aa>): static u8Cge: bool := bool(u8A >= u8B)
	<.main+6618 @05b996> : 1f 68 97 05 00             load.ref <@059768> ;u8A
	<.main+6623 @05b99b> : 20                         load.i8
	<.main+6624 @05b99c> : 1f 70 97 05 00             load.ref <@059770> ;u8B
	<.main+6629 @05b9a1> : 20                         load.i8
	<.main+6630 @05b9a2> : 38                         clt.u32
	<.main+6631 @05b9a3> : 0b                         not.b32
	<.main+6632 @05b9a4> : 1f 10 98 05 00             load.ref <@059810> ;u8Cge
	<.main+6637 @05b9a9> : 25                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@05b9aa> - <@05b9b5>): static i16A: int16 := a
	<.main+6638 @05b9aa> : 1c 60 00 00 00             load.c32 96
	<.main+6643 @05b9af> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6648 @05b9b4> : 26                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@05b9b5> - <@05b9c0>): static i16B: int16 := b
	<.main+6649 @05b9b5> : 1c 2a 00 00 00             load.c32 42
	<.main+6654 @05b9ba> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6659 @05b9bf> : 26                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@05b9c0> - <@05b9cc>): static i16Pls: int16 := int16(+i16B)
	<.main+6660 @05b9c0> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6665 @05b9c5> : 21                         load.i16
	<.main+6666 @05b9c6> : 1f 28 98 05 00             load.ref <@059828> ;i16Pls
	<.main+6671 @05b9cb> : 26                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@05b9cc> - <@05b9d9>): static i16Neg: int16 := int16(-i16B)
	<.main+6672 @05b9cc> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6677 @05b9d1> : 21                         load.i16
	<.main+6678 @05b9d2> : 50                         neg.i32
	<.main+6679 @05b9d3> : 1f 30 98 05 00             load.ref <@059830> ;i16Neg
	<.main+6684 @05b9d8> : 26                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@05b9d9> - <@05b9e6>): static i16Cmt: int16 := int16(~i16B)
	<.main+6685 @05b9d9> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6690 @05b9de> : 21                         load.i16
	<.main+6691 @05b9df> : 30                         cmt.b32
	<.main+6692 @05b9e0> : 1f 38 98 05 00             load.ref <@059838> ;i16Cmt
	<.main+6697 @05b9e5> : 26                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@05b9e6> - <@05b9f9>): static i16Add: int16 := int16(i16A + i16B)
	<.main+6698 @05b9e6> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6703 @05b9eb> : 21                         load.i16
	<.main+6704 @05b9ec> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6709 @05b9f1> : 21                         load.i16
	<.main+6710 @05b9f2> : 51                         add.i32
	<.main+6711 @05b9f3> : 1f 40 98 05 00             load.ref <@059840> ;i16Add
	<.main+6716 @05b9f8> : 26                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@05b9f9> - <@05ba0c>): static i16Sub: int16 := int16(i16A - i16B)
	<.main+6717 @05b9f9> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6722 @05b9fe> : 21                         load.i16
	<.main+6723 @05b9ff> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6728 @05ba04> : 21                         load.i16
	<.main+6729 @05ba05> : 52                         sub.i32
	<.main+6730 @05ba06> : 1f 48 98 05 00             load.ref <@059848> ;i16Sub
	<.main+6735 @05ba0b> : 26                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@05ba0c> - <@05ba1f>): static i16Mul: int16 := int16(i16A * i16B)
	<.main+6736 @05ba0c> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6741 @05ba11> : 21                         load.i16
	<.main+6742 @05ba12> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6747 @05ba17> : 21                         load.i16
	<.main+6748 @05ba18> : 53                         mul.i32
	<.main+6749 @05ba19> : 1f 50 98 05 00             load.ref <@059850> ;i16Mul
	<.main+6754 @05ba1e> : 26                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@05ba1f> - <@05ba32>): static i16Div: int16 := int16(i16A / i16B)
	<.main+6755 @05ba1f> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6760 @05ba24> : 21                         load.i16
	<.main+6761 @05ba25> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6766 @05ba2a> : 21                         load.i16
	<.main+6767 @05ba2b> : 54                         div.i32
	<.main+6768 @05ba2c> : 1f 58 98 05 00             load.ref <@059858> ;i16Div
	<.main+6773 @05ba31> : 26                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@05ba32> - <@05ba45>): static i16Mod: int16 := int16(i16A % i16B)
	<.main+6774 @05ba32> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6779 @05ba37> : 21                         load.i16
	<.main+6780 @05ba38> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6785 @05ba3d> : 21                         load.i16
	<.main+6786 @05ba3e> : 55                         mod.i32
	<.main+6787 @05ba3f> : 1f 60 98 05 00             load.ref <@059860> ;i16Mod
	<.main+6792 @05ba44> : 26                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@05ba45> - <@05ba58>): static i16And: int16 := int16(i16A & i16B)
	<.main+6793 @05ba45> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6798 @05ba4a> : 21                         load.i16
	<.main+6799 @05ba4b> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6804 @05ba50> : 21                         load.i16
	<.main+6805 @05ba51> : 31                         and.b32
	<.main+6806 @05ba52> : 1f 68 98 05 00             load.ref <@059868> ;i16And
	<.main+6811 @05ba57> : 26                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@05ba58> - <@05ba6b>): static i16Ior: int16 := int16(i16A | i16B)
	<.main+6812 @05ba58> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6817 @05ba5d> : 21                         load.i16
	<.main+6818 @05ba5e> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6823 @05ba63> : 21                         load.i16
	<.main+6824 @05ba64> : 32                         or.b32
	<.main+6825 @05ba65> : 1f 70 98 05 00             load.ref <@059870> ;i16Ior
	<.main+6830 @05ba6a> : 26                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@05ba6b> - <@05ba7e>): static i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6831 @05ba6b> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6836 @05ba70> : 21                         load.i16
	<.main+6837 @05ba71> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6842 @05ba76> : 21                         load.i16
	<.main+6843 @05ba77> : 36                         xor.b32
	<.main+6844 @05ba78> : 1f 78 98 05 00             load.ref <@059878> ;i16Xor
	<.main+6849 @05ba7d> : 26                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@05ba7e> - <@05ba8f>): static i16Shl: int16 := int32((i16A) << shift)
	<.main+6850 @05ba7e> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6855 @05ba83> : 21                         load.i16
	<.main+6856 @05ba84> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6860 @05ba88> : 3a                         shl.b32
	<.main+6861 @05ba89> : 1f 80 98 05 00             load.ref <@059880> ;i16Shl
	<.main+6866 @05ba8e> : 26                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@05ba8f> - <@05baa0>): static i16Shr: int16 := int32((i16A) >> shift)
	<.main+6867 @05ba8f> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6872 @05ba94> : 21                         load.i16
	<.main+6873 @05ba95> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+6877 @05ba99> : 3c                         sar.b32
	<.main+6878 @05ba9a> : 1f 88 98 05 00             load.ref <@059888> ;i16Shr
	<.main+6883 @05ba9f> : 26                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@05baa0> - <@05baae>): static i16Not: bool := bool(!(i16B))
	<.main+6884 @05baa0> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6889 @05baa5> : 21                         load.i16
	<.main+6890 @05baa6> : 5a                         i32.2bool
	<.main+6891 @05baa7> : 0b                         not.b32
	<.main+6892 @05baa8> : 1f 90 98 05 00             load.ref <@059890> ;i16Not
	<.main+6897 @05baad> : 25                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@05baae> - <@05bac1>): static i16Ceq: bool := bool(i16A == i16B)
	<.main+6898 @05baae> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6903 @05bab3> : 21                         load.i16
	<.main+6904 @05bab4> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6909 @05bab9> : 21                         load.i16
	<.main+6910 @05baba> : 57                         ceq.i32
	<.main+6911 @05babb> : 1f 98 98 05 00             load.ref <@059898> ;i16Ceq
	<.main+6916 @05bac0> : 25                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@05bac1> - <@05bad5>): static i16Cne: bool := bool(i16A != i16B)
	<.main+6917 @05bac1> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6922 @05bac6> : 21                         load.i16
	<.main+6923 @05bac7> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6928 @05bacc> : 21                         load.i16
	<.main+6929 @05bacd> : 57                         ceq.i32
	<.main+6930 @05bace> : 0b                         not.b32
	<.main+6931 @05bacf> : 1f a0 98 05 00             load.ref <@0598a0> ;i16Cne
	<.main+6936 @05bad4> : 25                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@05bad5> - <@05bae8>): static i16Clt: bool := bool(i16A < i16B)
	<.main+6937 @05bad5> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6942 @05bada> : 21                         load.i16
	<.main+6943 @05badb> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6948 @05bae0> : 21                         load.i16
	<.main+6949 @05bae1> : 58                         clt.i32
	<.main+6950 @05bae2> : 1f a8 98 05 00             load.ref <@0598a8> ;i16Clt
	<.main+6955 @05bae7> : 25                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@05bae8> - <@05bafc>): static i16Cle: bool := bool(i16A <= i16B)
	<.main+6956 @05bae8> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6961 @05baed> : 21                         load.i16
	<.main+6962 @05baee> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6967 @05baf3> : 21                         load.i16
	<.main+6968 @05baf4> : 59                         cgt.i32
	<.main+6969 @05baf5> : 0b                         not.b32
	<.main+6970 @05baf6> : 1f b0 98 05 00             load.ref <@0598b0> ;i16Cle
	<.main+6975 @05bafb> : 25                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@05bafc> - <@05bb0f>): static i16Cgt: bool := bool(i16A > i16B)
	<.main+6976 @05bafc> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+6981 @05bb01> : 21                         load.i16
	<.main+6982 @05bb02> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+6987 @05bb07> : 21                         load.i16
	<.main+6988 @05bb08> : 59                         cgt.i32
	<.main+6989 @05bb09> : 1f b8 98 05 00             load.ref <@0598b8> ;i16Cgt
	<.main+6994 @05bb0e> : 25                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@05bb0f> - <@05bb23>): static i16Cge: bool := bool(i16A >= i16B)
	<.main+6995 @05bb0f> : 1f 18 98 05 00             load.ref <@059818> ;i16A
	<.main+7000 @05bb14> : 21                         load.i16
	<.main+7001 @05bb15> : 1f 20 98 05 00             load.ref <@059820> ;i16B
	<.main+7006 @05bb1a> : 21                         load.i16
	<.main+7007 @05bb1b> : 58                         clt.i32
	<.main+7008 @05bb1c> : 0b                         not.b32
	<.main+7009 @05bb1d> : 1f c0 98 05 00             load.ref <@0598c0> ;i16Cge
	<.main+7014 @05bb22> : 25                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@05bb23> - <@05bb2e>): static u16A: uint16 := a
	<.main+7015 @05bb23> : 1c 60 00 00 00             load.c32 96
	<.main+7020 @05bb28> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7025 @05bb2d> : 26                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@05bb2e> - <@05bb39>): static u16B: uint16 := b
	<.main+7026 @05bb2e> : 1c 2a 00 00 00             load.c32 42
	<.main+7031 @05bb33> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7036 @05bb38> : 26                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@05bb39> - <@05bb45>): static u16Pls: uint16 := uint16(+u16B)
	<.main+7037 @05bb39> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7042 @05bb3e> : 21                         load.i16
	<.main+7043 @05bb3f> : 1f d8 98 05 00             load.ref <@0598d8> ;u16Pls
	<.main+7048 @05bb44> : 26                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@05bb45> - <@05bb52>): static u16Neg: uint16 := uint16(-u16B)
	<.main+7049 @05bb45> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7054 @05bb4a> : 21                         load.i16
	<.main+7055 @05bb4b> : 50                         neg.i32
	<.main+7056 @05bb4c> : 1f e0 98 05 00             load.ref <@0598e0> ;u16Neg
	<.main+7061 @05bb51> : 26                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@05bb52> - <@05bb5f>): static u16Cmt: uint16 := uint16(~u16B)
	<.main+7062 @05bb52> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7067 @05bb57> : 21                         load.i16
	<.main+7068 @05bb58> : 30                         cmt.b32
	<.main+7069 @05bb59> : 1f e8 98 05 00             load.ref <@0598e8> ;u16Cmt
	<.main+7074 @05bb5e> : 26                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@05bb5f> - <@05bb72>): static u16Add: uint16 := uint16(u16A + u16B)
	<.main+7075 @05bb5f> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7080 @05bb64> : 21                         load.i16
	<.main+7081 @05bb65> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7086 @05bb6a> : 21                         load.i16
	<.main+7087 @05bb6b> : 51                         add.i32
	<.main+7088 @05bb6c> : 1f f0 98 05 00             load.ref <@0598f0> ;u16Add
	<.main+7093 @05bb71> : 26                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@05bb72> - <@05bb85>): static u16Sub: uint16 := uint16(u16A - u16B)
	<.main+7094 @05bb72> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7099 @05bb77> : 21                         load.i16
	<.main+7100 @05bb78> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7105 @05bb7d> : 21                         load.i16
	<.main+7106 @05bb7e> : 52                         sub.i32
	<.main+7107 @05bb7f> : 1f f8 98 05 00             load.ref <@0598f8> ;u16Sub
	<.main+7112 @05bb84> : 26                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@05bb85> - <@05bb98>): static u16Mul: uint16 := uint16(u16A * u16B)
	<.main+7113 @05bb85> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7118 @05bb8a> : 21                         load.i16
	<.main+7119 @05bb8b> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7124 @05bb90> : 21                         load.i16
	<.main+7125 @05bb91> : 33                         mul.u32
	<.main+7126 @05bb92> : 1f 00 99 05 00             load.ref <@059900> ;u16Mul
	<.main+7131 @05bb97> : 26                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@05bb98> - <@05bbab>): static u16Div: uint16 := uint16(u16A / u16B)
	<.main+7132 @05bb98> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7137 @05bb9d> : 21                         load.i16
	<.main+7138 @05bb9e> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7143 @05bba3> : 21                         load.i16
	<.main+7144 @05bba4> : 34                         div.u32
	<.main+7145 @05bba5> : 1f 08 99 05 00             load.ref <@059908> ;u16Div
	<.main+7150 @05bbaa> : 26                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@05bbab> - <@05bbbe>): static u16Mod: uint16 := uint16(u16A % u16B)
	<.main+7151 @05bbab> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7156 @05bbb0> : 21                         load.i16
	<.main+7157 @05bbb1> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7162 @05bbb6> : 21                         load.i16
	<.main+7163 @05bbb7> : 35                         mod.u32
	<.main+7164 @05bbb8> : 1f 10 99 05 00             load.ref <@059910> ;u16Mod
	<.main+7169 @05bbbd> : 26                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@05bbbe> - <@05bbd1>): static u16And: uint16 := uint16(u16A & u16B)
	<.main+7170 @05bbbe> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7175 @05bbc3> : 21                         load.i16
	<.main+7176 @05bbc4> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7181 @05bbc9> : 21                         load.i16
	<.main+7182 @05bbca> : 31                         and.b32
	<.main+7183 @05bbcb> : 1f 18 99 05 00             load.ref <@059918> ;u16And
	<.main+7188 @05bbd0> : 26                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@05bbd1> - <@05bbe4>): static u16Ior: uint16 := uint16(u16A | u16B)
	<.main+7189 @05bbd1> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7194 @05bbd6> : 21                         load.i16
	<.main+7195 @05bbd7> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7200 @05bbdc> : 21                         load.i16
	<.main+7201 @05bbdd> : 32                         or.b32
	<.main+7202 @05bbde> : 1f 20 99 05 00             load.ref <@059920> ;u16Ior
	<.main+7207 @05bbe3> : 26                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@05bbe4> - <@05bbf7>): static u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+7208 @05bbe4> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7213 @05bbe9> : 21                         load.i16
	<.main+7214 @05bbea> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7219 @05bbef> : 21                         load.i16
	<.main+7220 @05bbf0> : 36                         xor.b32
	<.main+7221 @05bbf1> : 1f 28 99 05 00             load.ref <@059928> ;u16Xor
	<.main+7226 @05bbf6> : 26                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@05bbf7> - <@05bc08>): static u16Shl: uint16 := int32((u16A) << shift)
	<.main+7227 @05bbf7> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7232 @05bbfc> : 21                         load.i16
	<.main+7233 @05bbfd> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7237 @05bc01> : 3a                         shl.b32
	<.main+7238 @05bc02> : 1f 30 99 05 00             load.ref <@059930> ;u16Shl
	<.main+7243 @05bc07> : 26                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@05bc08> - <@05bc19>): static u16Shr: uint16 := int32((u16A) >> shift)
	<.main+7244 @05bc08> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7249 @05bc0d> : 21                         load.i16
	<.main+7250 @05bc0e> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7254 @05bc12> : 3c                         sar.b32
	<.main+7255 @05bc13> : 1f 38 99 05 00             load.ref <@059938> ;u16Shr
	<.main+7260 @05bc18> : 26                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@05bc19> - <@05bc27>): static u16Not: bool := bool(!(u16B))
	<.main+7261 @05bc19> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7266 @05bc1e> : 21                         load.i16
	<.main+7267 @05bc1f> : 5a                         i32.2bool
	<.main+7268 @05bc20> : 0b                         not.b32
	<.main+7269 @05bc21> : 1f 40 99 05 00             load.ref <@059940> ;u16Not
	<.main+7274 @05bc26> : 25                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@05bc27> - <@05bc3a>): static u16Ceq: bool := bool(u16A == u16B)
	<.main+7275 @05bc27> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7280 @05bc2c> : 21                         load.i16
	<.main+7281 @05bc2d> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7286 @05bc32> : 21                         load.i16
	<.main+7287 @05bc33> : 57                         ceq.i32
	<.main+7288 @05bc34> : 1f 48 99 05 00             load.ref <@059948> ;u16Ceq
	<.main+7293 @05bc39> : 25                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@05bc3a> - <@05bc4e>): static u16Cne: bool := bool(u16A != u16B)
	<.main+7294 @05bc3a> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7299 @05bc3f> : 21                         load.i16
	<.main+7300 @05bc40> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7305 @05bc45> : 21                         load.i16
	<.main+7306 @05bc46> : 57                         ceq.i32
	<.main+7307 @05bc47> : 0b                         not.b32
	<.main+7308 @05bc48> : 1f 50 99 05 00             load.ref <@059950> ;u16Cne
	<.main+7313 @05bc4d> : 25                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@05bc4e> - <@05bc61>): static u16Clt: bool := bool(u16A < u16B)
	<.main+7314 @05bc4e> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7319 @05bc53> : 21                         load.i16
	<.main+7320 @05bc54> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7325 @05bc59> : 21                         load.i16
	<.main+7326 @05bc5a> : 38                         clt.u32
	<.main+7327 @05bc5b> : 1f 58 99 05 00             load.ref <@059958> ;u16Clt
	<.main+7332 @05bc60> : 25                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@05bc61> - <@05bc75>): static u16Cle: bool := bool(u16A <= u16B)
	<.main+7333 @05bc61> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7338 @05bc66> : 21                         load.i16
	<.main+7339 @05bc67> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7344 @05bc6c> : 21                         load.i16
	<.main+7345 @05bc6d> : 39                         cgt.u32
	<.main+7346 @05bc6e> : 0b                         not.b32
	<.main+7347 @05bc6f> : 1f 60 99 05 00             load.ref <@059960> ;u16Cle
	<.main+7352 @05bc74> : 25                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@05bc75> - <@05bc88>): static u16Cgt: bool := bool(u16A > u16B)
	<.main+7353 @05bc75> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7358 @05bc7a> : 21                         load.i16
	<.main+7359 @05bc7b> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7364 @05bc80> : 21                         load.i16
	<.main+7365 @05bc81> : 39                         cgt.u32
	<.main+7366 @05bc82> : 1f 68 99 05 00             load.ref <@059968> ;u16Cgt
	<.main+7371 @05bc87> : 25                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@05bc88> - <@05bc9c>): static u16Cge: bool := bool(u16A >= u16B)
	<.main+7372 @05bc88> : 1f c8 98 05 00             load.ref <@0598c8> ;u16A
	<.main+7377 @05bc8d> : 21                         load.i16
	<.main+7378 @05bc8e> : 1f d0 98 05 00             load.ref <@0598d0> ;u16B
	<.main+7383 @05bc93> : 21                         load.i16
	<.main+7384 @05bc94> : 38                         clt.u32
	<.main+7385 @05bc95> : 0b                         not.b32
	<.main+7386 @05bc96> : 1f 70 99 05 00             load.ref <@059970> ;u16Cge
	<.main+7391 @05bc9b> : 25                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@05bc9c> - <@05bca5>): static i32A: int32 := a
	<.main+7392 @05bc9c> : 1c 60 00 00 00             load.c32 96
	<.main+7397 @05bca1> : 2e 78 99 05                store.m32 <@059978> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@05bca5> - <@05bcae>): static i32B: int32 := b
	<.main+7401 @05bca5> : 1c 2a 00 00 00             load.c32 42
	<.main+7406 @05bcaa> : 2e 80 99 05                store.m32 <@059980> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@05bcae> - <@05bcb6>): static i32Pls: int32 := int32(+i32B)
	<.main+7410 @05bcae> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7414 @05bcb2> : 2e 88 99 05                store.m32 <@059988> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@05bcb6> - <@05bcbf>): static i32Neg: int32 := int32(-i32B)
	<.main+7418 @05bcb6> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7422 @05bcba> : 50                         neg.i32
	<.main+7423 @05bcbb> : 2e 90 99 05                store.m32 <@059990> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@05bcbf> - <@05bcc8>): static i32Cmt: int32 := int32(~i32B)
	<.main+7427 @05bcbf> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7431 @05bcc3> : 30                         cmt.b32
	<.main+7432 @05bcc4> : 2e 98 99 05                store.m32 <@059998> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@05bcc8> - <@05bcd5>): static i32Add: int32 := int32(i32A + i32B)
	<.main+7436 @05bcc8> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7440 @05bccc> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7444 @05bcd0> : 51                         add.i32
	<.main+7445 @05bcd1> : 2e a0 99 05                store.m32 <@0599a0> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@05bcd5> - <@05bce2>): static i32Sub: int32 := int32(i32A - i32B)
	<.main+7449 @05bcd5> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7453 @05bcd9> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7457 @05bcdd> : 52                         sub.i32
	<.main+7458 @05bcde> : 2e a8 99 05                store.m32 <@0599a8> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@05bce2> - <@05bcef>): static i32Mul: int32 := int32(i32A * i32B)
	<.main+7462 @05bce2> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7466 @05bce6> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7470 @05bcea> : 53                         mul.i32
	<.main+7471 @05bceb> : 2e b0 99 05                store.m32 <@0599b0> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@05bcef> - <@05bcfc>): static i32Div: int32 := int32(i32A / i32B)
	<.main+7475 @05bcef> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7479 @05bcf3> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7483 @05bcf7> : 54                         div.i32
	<.main+7484 @05bcf8> : 2e b8 99 05                store.m32 <@0599b8> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@05bcfc> - <@05bd09>): static i32Mod: int32 := int32(i32A % i32B)
	<.main+7488 @05bcfc> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7492 @05bd00> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7496 @05bd04> : 55                         mod.i32
	<.main+7497 @05bd05> : 2e c0 99 05                store.m32 <@0599c0> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@05bd09> - <@05bd16>): static i32And: int32 := int32(i32A & i32B)
	<.main+7501 @05bd09> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7505 @05bd0d> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7509 @05bd11> : 31                         and.b32
	<.main+7510 @05bd12> : 2e c8 99 05                store.m32 <@0599c8> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@05bd16> - <@05bd23>): static i32Ior: int32 := int32(i32A | i32B)
	<.main+7514 @05bd16> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7518 @05bd1a> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7522 @05bd1e> : 32                         or.b32
	<.main+7523 @05bd1f> : 2e d0 99 05                store.m32 <@0599d0> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@05bd23> - <@05bd30>): static i32Xor: int32 := int32(i32A ^ i32B)
	<.main+7527 @05bd23> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7531 @05bd27> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7535 @05bd2b> : 36                         xor.b32
	<.main+7536 @05bd2c> : 2e d8 99 05                store.m32 <@0599d8> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@05bd30> - <@05bd3d>): static i32Shl: int32 := int32(i32A << shift)
	<.main+7540 @05bd30> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7544 @05bd34> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7548 @05bd38> : 3a                         shl.b32
	<.main+7549 @05bd39> : 2e e0 99 05                store.m32 <@0599e0> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@05bd3d> - <@05bd4a>): static i32Shr: int32 := int32(i32A >> shift)
	<.main+7553 @05bd3d> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7557 @05bd41> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7561 @05bd45> : 3c                         sar.b32
	<.main+7562 @05bd46> : 2e e8 99 05                store.m32 <@0599e8> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@05bd4a> - <@05bd56>): static i32Not: bool := bool(!(i32B))
	<.main+7566 @05bd4a> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7570 @05bd4e> : 5a                         i32.2bool
	<.main+7571 @05bd4f> : 0b                         not.b32
	<.main+7572 @05bd50> : 1f f0 99 05 00             load.ref <@0599f0> ;i32Not
	<.main+7577 @05bd55> : 25                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@05bd56> - <@05bd65>): static i32Ceq: bool := bool(i32A == i32B)
	<.main+7578 @05bd56> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7582 @05bd5a> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7586 @05bd5e> : 57                         ceq.i32
	<.main+7587 @05bd5f> : 1f f8 99 05 00             load.ref <@0599f8> ;i32Ceq
	<.main+7592 @05bd64> : 25                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@05bd65> - <@05bd75>): static i32Cne: bool := bool(i32A != i32B)
	<.main+7593 @05bd65> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7597 @05bd69> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7601 @05bd6d> : 57                         ceq.i32
	<.main+7602 @05bd6e> : 0b                         not.b32
	<.main+7603 @05bd6f> : 1f 00 9a 05 00             load.ref <@059a00> ;i32Cne
	<.main+7608 @05bd74> : 25                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@05bd75> - <@05bd84>): static i32Clt: bool := bool(i32A < i32B)
	<.main+7609 @05bd75> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7613 @05bd79> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7617 @05bd7d> : 58                         clt.i32
	<.main+7618 @05bd7e> : 1f 08 9a 05 00             load.ref <@059a08> ;i32Clt
	<.main+7623 @05bd83> : 25                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@05bd84> - <@05bd94>): static i32Cle: bool := bool(i32A <= i32B)
	<.main+7624 @05bd84> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7628 @05bd88> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7632 @05bd8c> : 59                         cgt.i32
	<.main+7633 @05bd8d> : 0b                         not.b32
	<.main+7634 @05bd8e> : 1f 10 9a 05 00             load.ref <@059a10> ;i32Cle
	<.main+7639 @05bd93> : 25                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@05bd94> - <@05bda3>): static i32Cgt: bool := bool(i32A > i32B)
	<.main+7640 @05bd94> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7644 @05bd98> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7648 @05bd9c> : 59                         cgt.i32
	<.main+7649 @05bd9d> : 1f 18 9a 05 00             load.ref <@059a18> ;i32Cgt
	<.main+7654 @05bda2> : 25                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@05bda3> - <@05bdb3>): static i32Cge: bool := bool(i32A >= i32B)
	<.main+7655 @05bda3> : 2a 78 99 05                load.m32 <@059978> ;i32A
	<.main+7659 @05bda7> : 2a 80 99 05                load.m32 <@059980> ;i32B
	<.main+7663 @05bdab> : 58                         clt.i32
	<.main+7664 @05bdac> : 0b                         not.b32
	<.main+7665 @05bdad> : 1f 20 9a 05 00             load.ref <@059a20> ;i32Cge
	<.main+7670 @05bdb2> : 25                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@05bdb3> - <@05bdbc>): static u32A: uint32 := a
	<.main+7671 @05bdb3> : 1c 60 00 00 00             load.c32 96
	<.main+7676 @05bdb8> : 2e 28 9a 05                store.m32 <@059a28> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@05bdbc> - <@05bdc5>): static u32B: uint32 := b
	<.main+7680 @05bdbc> : 1c 2a 00 00 00             load.c32 42
	<.main+7685 @05bdc1> : 2e 30 9a 05                store.m32 <@059a30> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@05bdc5> - <@05bdcd>): static u32Pls: uint32 := uint32(+u32B)
	<.main+7689 @05bdc5> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7693 @05bdc9> : 2e 38 9a 05                store.m32 <@059a38> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@05bdcd> - <@05bdd6>): static u32Neg: uint32 := uint32(-u32B)
	<.main+7697 @05bdcd> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7701 @05bdd1> : 50                         neg.i32
	<.main+7702 @05bdd2> : 2e 40 9a 05                store.m32 <@059a40> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@05bdd6> - <@05bddf>): static u32Cmt: uint32 := uint32(~u32B)
	<.main+7706 @05bdd6> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7710 @05bdda> : 30                         cmt.b32
	<.main+7711 @05bddb> : 2e 48 9a 05                store.m32 <@059a48> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@05bddf> - <@05bdec>): static u32Add: uint32 := uint32(u32A + u32B)
	<.main+7715 @05bddf> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7719 @05bde3> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7723 @05bde7> : 51                         add.i32
	<.main+7724 @05bde8> : 2e 50 9a 05                store.m32 <@059a50> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@05bdec> - <@05bdf9>): static u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7728 @05bdec> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7732 @05bdf0> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7736 @05bdf4> : 52                         sub.i32
	<.main+7737 @05bdf5> : 2e 58 9a 05                store.m32 <@059a58> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@05bdf9> - <@05be06>): static u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7741 @05bdf9> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7745 @05bdfd> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7749 @05be01> : 33                         mul.u32
	<.main+7750 @05be02> : 2e 60 9a 05                store.m32 <@059a60> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@05be06> - <@05be13>): static u32Div: uint32 := uint32(u32A / u32B)
	<.main+7754 @05be06> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7758 @05be0a> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7762 @05be0e> : 34                         div.u32
	<.main+7763 @05be0f> : 2e 68 9a 05                store.m32 <@059a68> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@05be13> - <@05be20>): static u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7767 @05be13> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7771 @05be17> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7775 @05be1b> : 35                         mod.u32
	<.main+7776 @05be1c> : 2e 70 9a 05                store.m32 <@059a70> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@05be20> - <@05be2d>): static u32And: uint32 := uint32(u32A & u32B)
	<.main+7780 @05be20> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7784 @05be24> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7788 @05be28> : 31                         and.b32
	<.main+7789 @05be29> : 2e 78 9a 05                store.m32 <@059a78> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@05be2d> - <@05be3a>): static u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7793 @05be2d> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7797 @05be31> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7801 @05be35> : 32                         or.b32
	<.main+7802 @05be36> : 2e 80 9a 05                store.m32 <@059a80> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@05be3a> - <@05be47>): static u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7806 @05be3a> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7810 @05be3e> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7814 @05be42> : 36                         xor.b32
	<.main+7815 @05be43> : 2e 88 9a 05                store.m32 <@059a88> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@05be47> - <@05be54>): static u32Shl: uint32 := uint32(u32A << shift)
	<.main+7819 @05be47> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7823 @05be4b> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7827 @05be4f> : 3a                         shl.b32
	<.main+7828 @05be50> : 2e 90 9a 05                store.m32 <@059a90> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@05be54> - <@05be61>): static u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7832 @05be54> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7836 @05be58> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+7840 @05be5c> : 3b                         shr.b32
	<.main+7841 @05be5d> : 2e 98 9a 05                store.m32 <@059a98> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@05be61> - <@05be6d>): static u32Not: bool := bool(!(u32B))
	<.main+7845 @05be61> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7849 @05be65> : 5a                         i32.2bool
	<.main+7850 @05be66> : 0b                         not.b32
	<.main+7851 @05be67> : 1f a0 9a 05 00             load.ref <@059aa0> ;u32Not
	<.main+7856 @05be6c> : 25                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@05be6d> - <@05be7c>): static u32Ceq: bool := bool(u32A == u32B)
	<.main+7857 @05be6d> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7861 @05be71> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7865 @05be75> : 57                         ceq.i32
	<.main+7866 @05be76> : 1f a8 9a 05 00             load.ref <@059aa8> ;u32Ceq
	<.main+7871 @05be7b> : 25                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@05be7c> - <@05be8c>): static u32Cne: bool := bool(u32A != u32B)
	<.main+7872 @05be7c> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7876 @05be80> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7880 @05be84> : 57                         ceq.i32
	<.main+7881 @05be85> : 0b                         not.b32
	<.main+7882 @05be86> : 1f b0 9a 05 00             load.ref <@059ab0> ;u32Cne
	<.main+7887 @05be8b> : 25                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@05be8c> - <@05be9b>): static u32Clt: bool := bool(u32A < u32B)
	<.main+7888 @05be8c> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7892 @05be90> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7896 @05be94> : 38                         clt.u32
	<.main+7897 @05be95> : 1f b8 9a 05 00             load.ref <@059ab8> ;u32Clt
	<.main+7902 @05be9a> : 25                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@05be9b> - <@05beab>): static u32Cle: bool := bool(u32A <= u32B)
	<.main+7903 @05be9b> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7907 @05be9f> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7911 @05bea3> : 39                         cgt.u32
	<.main+7912 @05bea4> : 0b                         not.b32
	<.main+7913 @05bea5> : 1f c0 9a 05 00             load.ref <@059ac0> ;u32Cle
	<.main+7918 @05beaa> : 25                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@05beab> - <@05beba>): static u32Cgt: bool := bool(u32A > u32B)
	<.main+7919 @05beab> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7923 @05beaf> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7927 @05beb3> : 39                         cgt.u32
	<.main+7928 @05beb4> : 1f c8 9a 05 00             load.ref <@059ac8> ;u32Cgt
	<.main+7933 @05beb9> : 25                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@05beba> - <@05beca>): static u32Cge: bool := bool(u32A >= u32B)
	<.main+7934 @05beba> : 2a 28 9a 05                load.m32 <@059a28> ;u32A
	<.main+7938 @05bebe> : 2a 30 9a 05                load.m32 <@059a30> ;u32B
	<.main+7942 @05bec2> : 38                         clt.u32
	<.main+7943 @05bec3> : 0b                         not.b32
	<.main+7944 @05bec4> : 1f d0 9a 05 00             load.ref <@059ad0> ;u32Cge
	<.main+7949 @05bec9> : 25                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@05beca> - <@05bed7>): static i64A: int64 := a
	<.main+7950 @05beca> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+7959 @05bed3> : 2d d8 9a 05                store.m64 <@059ad8> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@05bed7> - <@05bee4>): static i64B: int64 := b
	<.main+7963 @05bed7> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+7972 @05bee0> : 2d e0 9a 05                store.m64 <@059ae0> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@05bee4> - <@05beec>): static i64Pls: int64 := int64(+i64B)
	<.main+7976 @05bee4> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+7980 @05bee8> : 2d e8 9a 05                store.m64 <@059ae8> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@05beec> - <@05bef5>): static i64Neg: int64 := int64(-i64B)
	<.main+7984 @05beec> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+7988 @05bef0> : 60                         neg.i64
	<.main+7989 @05bef1> : 2d f0 9a 05                store.m64 <@059af0> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@05bef5> - <@05befe>): static i64Cmt: int64 := int64(~i64B)
	<.main+7993 @05bef5> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+7997 @05bef9> : 40                         cmt.b64
	<.main+7998 @05befa> : 2d f8 9a 05                store.m64 <@059af8> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@05befe> - <@05bf0b>): static i64Add: int64 := int64(i64A + i64B)
	<.main+8002 @05befe> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8006 @05bf02> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8010 @05bf06> : 61                         add.i64
	<.main+8011 @05bf07> : 2d 00 9b 05                store.m64 <@059b00> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@05bf0b> - <@05bf18>): static i64Sub: int64 := int64(i64A - i64B)
	<.main+8015 @05bf0b> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8019 @05bf0f> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8023 @05bf13> : 62                         sub.i64
	<.main+8024 @05bf14> : 2d 08 9b 05                store.m64 <@059b08> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@05bf18> - <@05bf25>): static i64Mul: int64 := int64(i64A * i64B)
	<.main+8028 @05bf18> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8032 @05bf1c> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8036 @05bf20> : 63                         mul.i64
	<.main+8037 @05bf21> : 2d 10 9b 05                store.m64 <@059b10> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@05bf25> - <@05bf32>): static i64Div: int64 := int64(i64A / i64B)
	<.main+8041 @05bf25> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8045 @05bf29> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8049 @05bf2d> : 64                         div.i64
	<.main+8050 @05bf2e> : 2d 18 9b 05                store.m64 <@059b18> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@05bf32> - <@05bf3f>): static i64Mod: int64 := int64(i64A % i64B)
	<.main+8054 @05bf32> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8058 @05bf36> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8062 @05bf3a> : 65                         mod.i64
	<.main+8063 @05bf3b> : 2d 20 9b 05                store.m64 <@059b20> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@05bf3f> - <@05bf4c>): static i64And: int64 := int64(i64A & i64B)
	<.main+8067 @05bf3f> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8071 @05bf43> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8075 @05bf47> : 41                         and.b64
	<.main+8076 @05bf48> : 2d 28 9b 05                store.m64 <@059b28> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@05bf4c> - <@05bf59>): static i64Ior: int64 := int64(i64A | i64B)
	<.main+8080 @05bf4c> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8084 @05bf50> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8088 @05bf54> : 42                         or.b64
	<.main+8089 @05bf55> : 2d 30 9b 05                store.m64 <@059b30> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@05bf59> - <@05bf66>): static i64Xor: int64 := int64(i64A ^ i64B)
	<.main+8093 @05bf59> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8097 @05bf5d> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8101 @05bf61> : 46                         xor.b64
	<.main+8102 @05bf62> : 2d 38 9b 05                store.m64 <@059b38> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@05bf66> - <@05bf73>): static i64Shl: int64 := int64(i64A << shift)
	<.main+8106 @05bf66> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8110 @05bf6a> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+8114 @05bf6e> : 4a                         shl.b64
	<.main+8115 @05bf6f> : 2d 40 9b 05                store.m64 <@059b40> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@05bf73> - <@05bf80>): static i64Shr: int64 := int64(i64A >> shift)
	<.main+8119 @05bf73> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8123 @05bf77> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+8127 @05bf7b> : 4c                         sar.b64
	<.main+8128 @05bf7c> : 2d 48 9b 05                store.m64 <@059b48> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@05bf80> - <@05bf8c>): static i64Not: bool := bool(!(i64B))
	<.main+8132 @05bf80> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8136 @05bf84> : 6b                         i64.2bool
	<.main+8137 @05bf85> : 0b                         not.b32
	<.main+8138 @05bf86> : 1f 50 9b 05 00             load.ref <@059b50> ;i64Not
	<.main+8143 @05bf8b> : 25                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@05bf8c> - <@05bf9b>): static i64Ceq: bool := bool(i64A == i64B)
	<.main+8144 @05bf8c> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8148 @05bf90> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8152 @05bf94> : 67                         ceq.i64
	<.main+8153 @05bf95> : 1f 58 9b 05 00             load.ref <@059b58> ;i64Ceq
	<.main+8158 @05bf9a> : 25                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@05bf9b> - <@05bfab>): static i64Cne: bool := bool(i64A != i64B)
	<.main+8159 @05bf9b> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8163 @05bf9f> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8167 @05bfa3> : 67                         ceq.i64
	<.main+8168 @05bfa4> : 0b                         not.b32
	<.main+8169 @05bfa5> : 1f 60 9b 05 00             load.ref <@059b60> ;i64Cne
	<.main+8174 @05bfaa> : 25                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@05bfab> - <@05bfba>): static i64Clt: bool := bool(i64A < i64B)
	<.main+8175 @05bfab> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8179 @05bfaf> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8183 @05bfb3> : 68                         clt.i64
	<.main+8184 @05bfb4> : 1f 68 9b 05 00             load.ref <@059b68> ;i64Clt
	<.main+8189 @05bfb9> : 25                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@05bfba> - <@05bfca>): static i64Cle: bool := bool(i64A <= i64B)
	<.main+8190 @05bfba> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8194 @05bfbe> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8198 @05bfc2> : 69                         cgt.i64
	<.main+8199 @05bfc3> : 0b                         not.b32
	<.main+8200 @05bfc4> : 1f 70 9b 05 00             load.ref <@059b70> ;i64Cle
	<.main+8205 @05bfc9> : 25                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@05bfca> - <@05bfd9>): static i64Cgt: bool := bool(i64A > i64B)
	<.main+8206 @05bfca> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8210 @05bfce> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8214 @05bfd2> : 69                         cgt.i64
	<.main+8215 @05bfd3> : 1f 78 9b 05 00             load.ref <@059b78> ;i64Cgt
	<.main+8220 @05bfd8> : 25                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@05bfd9> - <@05bfe9>): static i64Cge: bool := bool(i64A >= i64B)
	<.main+8221 @05bfd9> : 2b d8 9a 05                load.m64 <@059ad8> ;i64A
	<.main+8225 @05bfdd> : 2b e0 9a 05                load.m64 <@059ae0> ;i64B
	<.main+8229 @05bfe1> : 68                         clt.i64
	<.main+8230 @05bfe2> : 0b                         not.b32
	<.main+8231 @05bfe3> : 1f 80 9b 05 00             load.ref <@059b80> ;i64Cge
	<.main+8236 @05bfe8> : 25                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@05bfe9> - <@05bff6>): static u64A: uint64 := a
	<.main+8237 @05bfe9> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8246 @05bff2> : 2d 88 9b 05                store.m64 <@059b88> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@05bff6> - <@05c003>): static u64B: uint64 := b
	<.main+8250 @05bff6> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8259 @05bfff> : 2d 90 9b 05                store.m64 <@059b90> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@05c003> - <@05c00b>): static u64Pls: uint64 := uint64(+u64B)
	<.main+8263 @05c003> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8267 @05c007> : 2d 98 9b 05                store.m64 <@059b98> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@05c00b> - <@05c014>): static u64Neg: uint64 := uint64(-u64B)
	<.main+8271 @05c00b> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8275 @05c00f> : 60                         neg.i64
	<.main+8276 @05c010> : 2d a0 9b 05                store.m64 <@059ba0> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@05c014> - <@05c01d>): static u64Cmt: uint64 := uint64(~u64B)
	<.main+8280 @05c014> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8284 @05c018> : 40                         cmt.b64
	<.main+8285 @05c019> : 2d a8 9b 05                store.m64 <@059ba8> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@05c01d> - <@05c02a>): static u64Add: uint64 := uint64(u64A + u64B)
	<.main+8289 @05c01d> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8293 @05c021> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8297 @05c025> : 61                         add.i64
	<.main+8298 @05c026> : 2d b0 9b 05                store.m64 <@059bb0> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@05c02a> - <@05c037>): static u64Sub: uint64 := uint64(u64A - u64B)
	<.main+8302 @05c02a> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8306 @05c02e> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8310 @05c032> : 62                         sub.i64
	<.main+8311 @05c033> : 2d b8 9b 05                store.m64 <@059bb8> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@05c037> - <@05c044>): static u64Mul: uint64 := uint64(u64A * u64B)
	<.main+8315 @05c037> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8319 @05c03b> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8323 @05c03f> : 43                         mul.u64
	<.main+8324 @05c040> : 2d c0 9b 05                store.m64 <@059bc0> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@05c044> - <@05c051>): static u64Div: uint64 := uint64(u64A / u64B)
	<.main+8328 @05c044> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8332 @05c048> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8336 @05c04c> : 44                         div.u64
	<.main+8337 @05c04d> : 2d c8 9b 05                store.m64 <@059bc8> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@05c051> - <@05c05e>): static u64Mod: uint64 := uint64(u64A % u64B)
	<.main+8341 @05c051> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8345 @05c055> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8349 @05c059> : 45                         mod.u64
	<.main+8350 @05c05a> : 2d d0 9b 05                store.m64 <@059bd0> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@05c05e> - <@05c06b>): static u64And: uint64 := uint64(u64A & u64B)
	<.main+8354 @05c05e> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8358 @05c062> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8362 @05c066> : 41                         and.b64
	<.main+8363 @05c067> : 2d d8 9b 05                store.m64 <@059bd8> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@05c06b> - <@05c078>): static u64Ior: uint64 := uint64(u64A | u64B)
	<.main+8367 @05c06b> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8371 @05c06f> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8375 @05c073> : 42                         or.b64
	<.main+8376 @05c074> : 2d e0 9b 05                store.m64 <@059be0> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@05c078> - <@05c085>): static u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+8380 @05c078> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8384 @05c07c> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8388 @05c080> : 46                         xor.b64
	<.main+8389 @05c081> : 2d e8 9b 05                store.m64 <@059be8> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@05c085> - <@05c092>): static u64Shl: uint64 := uint64(u64A << shift)
	<.main+8393 @05c085> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8397 @05c089> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+8401 @05c08d> : 4a                         shl.b64
	<.main+8402 @05c08e> : 2d f0 9b 05                store.m64 <@059bf0> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@05c092> - <@05c09f>): static u64Shr: uint64 := uint64(u64A >> shift)
	<.main+8406 @05c092> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8410 @05c096> : 2a a0 95 05                load.m32 <@0595a0> ;shift
	<.main+8414 @05c09a> : 4b                         shr.b64
	<.main+8415 @05c09b> : 2d f8 9b 05                store.m64 <@059bf8> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@05c09f> - <@05c0ab>): static u64Not: bool := bool(!(u64B))
	<.main+8419 @05c09f> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8423 @05c0a3> : 6b                         i64.2bool
	<.main+8424 @05c0a4> : 0b                         not.b32
	<.main+8425 @05c0a5> : 1f 00 9c 05 00             load.ref <@059c00> ;u64Not
	<.main+8430 @05c0aa> : 25                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@05c0ab> - <@05c0ba>): static u64Ceq: bool := bool(u64A == u64B)
	<.main+8431 @05c0ab> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8435 @05c0af> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8439 @05c0b3> : 67                         ceq.i64
	<.main+8440 @05c0b4> : 1f 08 9c 05 00             load.ref <@059c08> ;u64Ceq
	<.main+8445 @05c0b9> : 25                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@05c0ba> - <@05c0ca>): static u64Cne: bool := bool(u64A != u64B)
	<.main+8446 @05c0ba> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8450 @05c0be> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8454 @05c0c2> : 67                         ceq.i64
	<.main+8455 @05c0c3> : 0b                         not.b32
	<.main+8456 @05c0c4> : 1f 10 9c 05 00             load.ref <@059c10> ;u64Cne
	<.main+8461 @05c0c9> : 25                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@05c0ca> - <@05c0d9>): static u64Clt: bool := bool(u64A < u64B)
	<.main+8462 @05c0ca> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8466 @05c0ce> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8470 @05c0d2> : 48                         clt.u64
	<.main+8471 @05c0d3> : 1f 18 9c 05 00             load.ref <@059c18> ;u64Clt
	<.main+8476 @05c0d8> : 25                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@05c0d9> - <@05c0e9>): static u64Cle: bool := bool(u64A <= u64B)
	<.main+8477 @05c0d9> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8481 @05c0dd> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8485 @05c0e1> : 49                         cgt.u64
	<.main+8486 @05c0e2> : 0b                         not.b32
	<.main+8487 @05c0e3> : 1f 20 9c 05 00             load.ref <@059c20> ;u64Cle
	<.main+8492 @05c0e8> : 25                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@05c0e9> - <@05c0f8>): static u64Cgt: bool := bool(u64A > u64B)
	<.main+8493 @05c0e9> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8497 @05c0ed> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8501 @05c0f1> : 49                         cgt.u64
	<.main+8502 @05c0f2> : 1f 28 9c 05 00             load.ref <@059c28> ;u64Cgt
	<.main+8507 @05c0f7> : 25                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@05c0f8> - <@05c108>): static u64Cge: bool := bool(u64A >= u64B)
	<.main+8508 @05c0f8> : 2b 88 9b 05                load.m64 <@059b88> ;u64A
	<.main+8512 @05c0fc> : 2b 90 9b 05                load.m64 <@059b90> ;u64B
	<.main+8516 @05c100> : 48                         clt.u64
	<.main+8517 @05c101> : 0b                         not.b32
	<.main+8518 @05c102> : 1f 30 9c 05 00             load.ref <@059c30> ;u64Cge
	<.main+8523 @05c107> : 25                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@05c108> - <@05c111>): static f32A: float32 := a
	<.main+8524 @05c108> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8529 @05c10d> : 2e 38 9c 05                store.m32 <@059c38> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@05c111> - <@05c11a>): static f32B: float32 := b
	<.main+8533 @05c111> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8538 @05c116> : 2e 40 9c 05                store.m32 <@059c40> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@05c11a> - <@05c122>): static f32Pls: float32 := float32(+f32B)
	<.main+8542 @05c11a> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8546 @05c11e> : 2e 48 9c 05                store.m32 <@059c48> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@05c122> - <@05c12b>): static f32Neg: float32 := float32(-f32B)
	<.main+8550 @05c122> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8554 @05c126> : 70                         neg.f32
	<.main+8555 @05c127> : 2e 50 9c 05                store.m32 <@059c50> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@05c12b> - <@05c138>): static f32Add: float32 := float32(f32A + f32B)
	<.main+8559 @05c12b> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8563 @05c12f> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8567 @05c133> : 71                         add.f32
	<.main+8568 @05c134> : 2e 58 9c 05                store.m32 <@059c58> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@05c138> - <@05c145>): static f32Sub: float32 := float32(f32A - f32B)
	<.main+8572 @05c138> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8576 @05c13c> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8580 @05c140> : 72                         sub.f32
	<.main+8581 @05c141> : 2e 60 9c 05                store.m32 <@059c60> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@05c145> - <@05c152>): static f32Mul: float32 := float32(f32A * f32B)
	<.main+8585 @05c145> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8589 @05c149> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8593 @05c14d> : 73                         mul.f32
	<.main+8594 @05c14e> : 2e 68 9c 05                store.m32 <@059c68> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@05c152> - <@05c15f>): static f32Div: float32 := float32(f32A / f32B)
	<.main+8598 @05c152> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8602 @05c156> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8606 @05c15a> : 74                         div.f32
	<.main+8607 @05c15b> : 2e 70 9c 05                store.m32 <@059c70> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@05c15f> - <@05c16c>): static f32Mod: float32 := float32(f32A % f32B)
	<.main+8611 @05c15f> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8615 @05c163> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8619 @05c167> : 75                         mod.f32
	<.main+8620 @05c168> : 2e 78 9c 05                store.m32 <@059c78> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@05c16c> - <@05c178>): static f32Not: bool := bool(!(f32B))
	<.main+8624 @05c16c> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8628 @05c170> : 7c                         f32.2bool
	<.main+8629 @05c171> : 0b                         not.b32
	<.main+8630 @05c172> : 1f 80 9c 05 00             load.ref <@059c80> ;f32Not
	<.main+8635 @05c177> : 25                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@05c178> - <@05c187>): static f32Ceq: bool := bool(f32A == f32B)
	<.main+8636 @05c178> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8640 @05c17c> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8644 @05c180> : 77                         ceq.f32
	<.main+8645 @05c181> : 1f 88 9c 05 00             load.ref <@059c88> ;f32Ceq
	<.main+8650 @05c186> : 25                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@05c187> - <@05c197>): static f32Cne: bool := bool(f32A != f32B)
	<.main+8651 @05c187> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8655 @05c18b> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8659 @05c18f> : 77                         ceq.f32
	<.main+8660 @05c190> : 0b                         not.b32
	<.main+8661 @05c191> : 1f 90 9c 05 00             load.ref <@059c90> ;f32Cne
	<.main+8666 @05c196> : 25                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@05c197> - <@05c1a6>): static f32Clt: bool := bool(f32A < f32B)
	<.main+8667 @05c197> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8671 @05c19b> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8675 @05c19f> : 78                         clt.f32
	<.main+8676 @05c1a0> : 1f 98 9c 05 00             load.ref <@059c98> ;f32Clt
	<.main+8681 @05c1a5> : 25                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@05c1a6> - <@05c1b6>): static f32Cle: bool := bool(f32A <= f32B)
	<.main+8682 @05c1a6> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8686 @05c1aa> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8690 @05c1ae> : 79                         cgt.f32
	<.main+8691 @05c1af> : 0b                         not.b32
	<.main+8692 @05c1b0> : 1f a0 9c 05 00             load.ref <@059ca0> ;f32Cle
	<.main+8697 @05c1b5> : 25                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@05c1b6> - <@05c1c5>): static f32Cgt: bool := bool(f32A > f32B)
	<.main+8698 @05c1b6> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8702 @05c1ba> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8706 @05c1be> : 79                         cgt.f32
	<.main+8707 @05c1bf> : 1f a8 9c 05 00             load.ref <@059ca8> ;f32Cgt
	<.main+8712 @05c1c4> : 25                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@05c1c5> - <@05c1d5>): static f32Cge: bool := bool(f32A >= f32B)
	<.main+8713 @05c1c5> : 2a 38 9c 05                load.m32 <@059c38> ;f32A
	<.main+8717 @05c1c9> : 2a 40 9c 05                load.m32 <@059c40> ;f32B
	<.main+8721 @05c1cd> : 78                         clt.f32
	<.main+8722 @05c1ce> : 0b                         not.b32
	<.main+8723 @05c1cf> : 1f b0 9c 05 00             load.ref <@059cb0> ;f32Cge
	<.main+8728 @05c1d4> : 25                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@05c1d5> - <@05c1e2>): static f64A: float64 := a
	<.main+8729 @05c1d5> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8738 @05c1de> : 2d b8 9c 05                store.m64 <@059cb8> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@05c1e2> - <@05c1ef>): static f64B: float64 := b
	<.main+8742 @05c1e2> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8751 @05c1eb> : 2d c0 9c 05                store.m64 <@059cc0> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@05c1ef> - <@05c1f7>): static f64Pls: float64 := float64(+f64B)
	<.main+8755 @05c1ef> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8759 @05c1f3> : 2d c8 9c 05                store.m64 <@059cc8> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@05c1f7> - <@05c200>): static f64Neg: float64 := float64(-f64B)
	<.main+8763 @05c1f7> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8767 @05c1fb> : 80                         neg.f64
	<.main+8768 @05c1fc> : 2d d0 9c 05                store.m64 <@059cd0> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@05c200> - <@05c20d>): static f64Add: float64 := float64(f64A + f64B)
	<.main+8772 @05c200> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8776 @05c204> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8780 @05c208> : 81                         add.f64
	<.main+8781 @05c209> : 2d d8 9c 05                store.m64 <@059cd8> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@05c20d> - <@05c21a>): static f64Sub: float64 := float64(f64A - f64B)
	<.main+8785 @05c20d> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8789 @05c211> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8793 @05c215> : 82                         sub.f64
	<.main+8794 @05c216> : 2d e0 9c 05                store.m64 <@059ce0> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@05c21a> - <@05c227>): static f64Mul: float64 := float64(f64A * f64B)
	<.main+8798 @05c21a> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8802 @05c21e> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8806 @05c222> : 83                         mul.f64
	<.main+8807 @05c223> : 2d e8 9c 05                store.m64 <@059ce8> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@05c227> - <@05c234>): static f64Div: float64 := float64(f64A / f64B)
	<.main+8811 @05c227> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8815 @05c22b> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8819 @05c22f> : 84                         div.f64
	<.main+8820 @05c230> : 2d f0 9c 05                store.m64 <@059cf0> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@05c234> - <@05c241>): static f64Mod: float64 := float64(f64A % f64B)
	<.main+8824 @05c234> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8828 @05c238> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8832 @05c23c> : 85                         mod.f64
	<.main+8833 @05c23d> : 2d f8 9c 05                store.m64 <@059cf8> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@05c241> - <@05c24d>): static f64Not: bool := bool(!(f64B))
	<.main+8837 @05c241> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8841 @05c245> : 8d                         f64.2bool
	<.main+8842 @05c246> : 0b                         not.b32
	<.main+8843 @05c247> : 1f 00 9d 05 00             load.ref <@059d00> ;f64Not
	<.main+8848 @05c24c> : 25                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@05c24d> - <@05c25c>): static f64Ceq: bool := bool(f64A == f64B)
	<.main+8849 @05c24d> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8853 @05c251> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8857 @05c255> : 87                         ceq.f64
	<.main+8858 @05c256> : 1f 08 9d 05 00             load.ref <@059d08> ;f64Ceq
	<.main+8863 @05c25b> : 25                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@05c25c> - <@05c26c>): static f64Cne: bool := bool(f64A != f64B)
	<.main+8864 @05c25c> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8868 @05c260> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8872 @05c264> : 87                         ceq.f64
	<.main+8873 @05c265> : 0b                         not.b32
	<.main+8874 @05c266> : 1f 10 9d 05 00             load.ref <@059d10> ;f64Cne
	<.main+8879 @05c26b> : 25                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@05c26c> - <@05c27b>): static f64Clt: bool := bool(f64A < f64B)
	<.main+8880 @05c26c> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8884 @05c270> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8888 @05c274> : 88                         clt.f64
	<.main+8889 @05c275> : 1f 18 9d 05 00             load.ref <@059d18> ;f64Clt
	<.main+8894 @05c27a> : 25                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@05c27b> - <@05c28b>): static f64Cle: bool := bool(f64A <= f64B)
	<.main+8895 @05c27b> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8899 @05c27f> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8903 @05c283> : 89                         cgt.f64
	<.main+8904 @05c284> : 0b                         not.b32
	<.main+8905 @05c285> : 1f 20 9d 05 00             load.ref <@059d20> ;f64Cle
	<.main+8910 @05c28a> : 25                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@05c28b> - <@05c29a>): static f64Cgt: bool := bool(f64A > f64B)
	<.main+8911 @05c28b> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8915 @05c28f> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8919 @05c293> : 89                         cgt.f64
	<.main+8920 @05c294> : 1f 28 9d 05 00             load.ref <@059d28> ;f64Cgt
	<.main+8925 @05c299> : 25                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@05c29a> - <@05c2aa>): static f64Cge: bool := bool(f64A >= f64B)
	<.main+8926 @05c29a> : 2b b8 9c 05                load.m64 <@059cb8> ;f64A
	<.main+8930 @05c29e> : 2b c0 9c 05                load.m64 <@059cc0> ;f64B
	<.main+8934 @05c2a2> : 88                         clt.f64
	<.main+8935 @05c2a3> : 0b                         not.b32
	<.main+8936 @05c2a4> : 1f 30 9d 05 00             load.ref <@059d30> ;f64Cge
	<.main+8941 @05c2a9> : 25                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@05c2aa> - <@05c2b3>): static ptrA: pointer := null
	<.main+8942 @05c2aa> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8947 @05c2af> : 2e 38 9d 05                store.m32 <@059d38> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@05c2b3> - <@05c2bc>): static ptrB: pointer := pointer(shift)
	<.main+8951 @05c2b3> : 1f a0 95 05 00             load.ref <@0595a0> ;shift
	<.main+8956 @05c2b8> : 2e 40 9d 05                store.m32 <@059d40> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@05c2bc> - <@05c2cb>): static ptrCeq: bool := bool(ptrA == ptrB)
	<.main+8960 @05c2bc> : 2a 38 9d 05                load.m32 <@059d38> ;ptrA
	<.main+8964 @05c2c0> : 2a 40 9d 05                load.m32 <@059d40> ;ptrB
	<.main+8968 @05c2c4> : 57                         ceq.i32
	<.main+8969 @05c2c5> : 1f 48 9d 05 00             load.ref <@059d48> ;ptrCeq
	<.main+8974 @05c2ca> : 25                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@05c2cb> - <@05c2db>): static ptrCne: bool := bool(ptrA != ptrB)
	<.main+8975 @05c2cb> : 2a 38 9d 05                load.m32 <@059d38> ;ptrA
	<.main+8979 @05c2cf> : 2a 40 9d 05                load.m32 <@059d40> ;ptrB
	<.main+8983 @05c2d3> : 57                         ceq.i32
	<.main+8984 @05c2d4> : 0b                         not.b32
	<.main+8985 @05c2d5> : 1f 50 9d 05 00             load.ref <@059d50> ;ptrCne
	<.main+8990 @05c2da> : 25                         store.i8
	test/lang/statementIf.ci:26: (5 bytes: <@05c2db> - <@05c2e0>): static t: int32 := 0
	<.main+8991 @05c2db> : 19                         load.z32
	<.main+8992 @05c2dc> : 2e 58 9d 05                store.m32 <@059d58> ;t
	test/lang/statementFor.ci:12: (5 bytes: <@05c2e0> - <@05c2e5>): static forIdx: int32
	<.main+8996 @05c2e0> : 19                         load.z32
	<.main+8997 @05c2e1> : 2e 60 9d 05                store.m32 <@059d60> ;forIdx
	test/std/test.math.ci:3: (24 bytes: <@05c2e5> - <@05c2fd>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9001 @05c2e5> : 1a                         load.z64
	<.main+9002 @05c2e6> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9011 @05c2ef> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9016 @05c2f4> : 02                         call
	<.main+9017 @05c2f5> : 09 f8 ff ff                inc.sp(-8)
	<.main+9021 @05c2f9> : 2d 68 9d 05                store.m64 <@059d68> ;testMathFloor_1
	test/std/test.math.ci:4: (24 bytes: <@05c2fd> - <@05c315>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9025 @05c2fd> : 1a                         load.z64
	<.main+9026 @05c2fe> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9035 @05c307> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9040 @05c30c> : 02                         call
	<.main+9041 @05c30d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9045 @05c311> : 2d 70 9d 05                store.m64 <@059d70> ;testMathFloor_2
	test/std/test.math.ci:5: (24 bytes: <@05c315> - <@05c32d>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9049 @05c315> : 1a                         load.z64
	<.main+9050 @05c316> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9059 @05c31f> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9064 @05c324> : 02                         call
	<.main+9065 @05c325> : 09 f8 ff ff                inc.sp(-8)
	<.main+9069 @05c329> : 2d 78 9d 05                store.m64 <@059d78> ;testMathFloor_3
	test/std/test.math.ci:6: (24 bytes: <@05c32d> - <@05c345>): static testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+9073 @05c32d> : 1a                         load.z64
	<.main+9074 @05c32e> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9083 @05c337> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9088 @05c33c> : 02                         call
	<.main+9089 @05c33d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9093 @05c341> : 2d 80 9d 05                store.m64 <@059d80> ;testMathFloor_4
	test/std/test.math.ci:7: (24 bytes: <@05c345> - <@05c35d>): static testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+9097 @05c345> : 1a                         load.z64
	<.main+9098 @05c346> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9107 @05c34f> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9112 @05c354> : 02                         call
	<.main+9113 @05c355> : 09 f8 ff ff                inc.sp(-8)
	<.main+9117 @05c359> : 2d 88 9d 05                store.m64 <@059d88> ;testMathFloor_5
	test/std/test.math.ci:8: (24 bytes: <@05c35d> - <@05c375>): static testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+9121 @05c35d> : 1a                         load.z64
	<.main+9122 @05c35e> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9131 @05c367> : 1f 28 76 05 00             load.ref <@057628> ;Math.floor(x: float64): float64
	<.main+9136 @05c36c> : 02                         call
	<.main+9137 @05c36d> : 09 f8 ff ff                inc.sp(-8)
	<.main+9141 @05c371> : 2d 90 9d 05                store.m64 <@059d90> ;testMathFloor_6
	test/std/test.math.ci:10: (29 bytes: <@05c375> - <@05c392>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9145 @05c375> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9154 @05c37e> : 11 00                      dup.x64 sp(0)
	<.main+9156 @05c380> : 1a                         load.z64
	<.main+9157 @05c381> : 89                         cgt.f64
	<.main+9158 @05c382> : 11 01                      dup.x64 sp(1)
	<.main+9160 @05c384> : 1a                         load.z64
	<.main+9161 @05c385> : 88                         clt.f64
	<.main+9162 @05c386> : 52                         sub.i32
	<.main+9163 @05c387> : 13 02                      set.x32 sp(2)
	<.main+9165 @05c389> : 09 fc ff ff                inc.sp(-4)
	<.main+9169 @05c38d> : 5d                         i32.2f64
	<.main+9170 @05c38e> : 2d 98 9d 05                store.m64 <@059d98> ;testMathSign_1F
	test/std/test.math.ci:11: (21 bytes: <@05c392> - <@05c3a7>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9174 @05c392> : 1a                         load.z64
	<.main+9175 @05c393> : 11 00                      dup.x64 sp(0)
	<.main+9177 @05c395> : 1a                         load.z64
	<.main+9178 @05c396> : 89                         cgt.f64
	<.main+9179 @05c397> : 11 01                      dup.x64 sp(1)
	<.main+9181 @05c399> : 1a                         load.z64
	<.main+9182 @05c39a> : 88                         clt.f64
	<.main+9183 @05c39b> : 52                         sub.i32
	<.main+9184 @05c39c> : 13 02                      set.x32 sp(2)
	<.main+9186 @05c39e> : 09 fc ff ff                inc.sp(-4)
	<.main+9190 @05c3a2> : 5d                         i32.2f64
	<.main+9191 @05c3a3> : 2d a0 9d 05                store.m64 <@059da0> ;testMathSign_2F
	test/std/test.math.ci:12: (29 bytes: <@05c3a7> - <@05c3c4>): static testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+9195 @05c3a7> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9204 @05c3b0> : 11 00                      dup.x64 sp(0)
	<.main+9206 @05c3b2> : 1a                         load.z64
	<.main+9207 @05c3b3> : 89                         cgt.f64
	<.main+9208 @05c3b4> : 11 01                      dup.x64 sp(1)
	<.main+9210 @05c3b6> : 1a                         load.z64
	<.main+9211 @05c3b7> : 88                         clt.f64
	<.main+9212 @05c3b8> : 52                         sub.i32
	<.main+9213 @05c3b9> : 13 02                      set.x32 sp(2)
	<.main+9215 @05c3bb> : 09 fc ff ff                inc.sp(-4)
	<.main+9219 @05c3bf> : 5d                         i32.2f64
	<.main+9220 @05c3c0> : 2d a8 9d 05                store.m64 <@059da8> ;testMathSign_3F
	test/std/test.math.ci:13: (21 bytes: <@05c3c4> - <@05c3d9>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9224 @05c3c4> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9229 @05c3c9> : 10 00                      dup.x32 sp(0)
	<.main+9231 @05c3cb> : 19                         load.z32
	<.main+9232 @05c3cc> : 79                         cgt.f32
	<.main+9233 @05c3cd> : 10 01                      dup.x32 sp(1)
	<.main+9235 @05c3cf> : 19                         load.z32
	<.main+9236 @05c3d0> : 78                         clt.f32
	<.main+9237 @05c3d1> : 52                         sub.i32
	<.main+9238 @05c3d2> : 13 01                      set.x32 sp(1)
	<.main+9240 @05c3d4> : 5d                         i32.2f64
	<.main+9241 @05c3d5> : 2d b0 9d 05                store.m64 <@059db0> ;testMathSign_1f
	test/std/test.math.ci:14: (17 bytes: <@05c3d9> - <@05c3ea>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9245 @05c3d9> : 19                         load.z32
	<.main+9246 @05c3da> : 10 00                      dup.x32 sp(0)
	<.main+9248 @05c3dc> : 19                         load.z32
	<.main+9249 @05c3dd> : 79                         cgt.f32
	<.main+9250 @05c3de> : 10 01                      dup.x32 sp(1)
	<.main+9252 @05c3e0> : 19                         load.z32
	<.main+9253 @05c3e1> : 78                         clt.f32
	<.main+9254 @05c3e2> : 52                         sub.i32
	<.main+9255 @05c3e3> : 13 01                      set.x32 sp(1)
	<.main+9257 @05c3e5> : 5d                         i32.2f64
	<.main+9258 @05c3e6> : 2d b8 9d 05                store.m64 <@059db8> ;testMathSign_2f
	test/std/test.math.ci:15: (21 bytes: <@05c3ea> - <@05c3ff>): static testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+9262 @05c3ea> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9267 @05c3ef> : 10 00                      dup.x32 sp(0)
	<.main+9269 @05c3f1> : 19                         load.z32
	<.main+9270 @05c3f2> : 79                         cgt.f32
	<.main+9271 @05c3f3> : 10 01                      dup.x32 sp(1)
	<.main+9273 @05c3f5> : 19                         load.z32
	<.main+9274 @05c3f6> : 78                         clt.f32
	<.main+9275 @05c3f7> : 52                         sub.i32
	<.main+9276 @05c3f8> : 13 01                      set.x32 sp(1)
	<.main+9278 @05c3fa> : 5d                         i32.2f64
	<.main+9279 @05c3fb> : 2d c0 9d 05                store.m64 <@059dc0> ;testMathSign_3f
	test/std/test.math.ci:17: (24 bytes: <@05c3ff> - <@05c417>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9283 @05c3ff> : 1a                         load.z64
	<.main+9284 @05c400> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9293 @05c409> : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<.main+9298 @05c40e> : 02                         call
	<.main+9299 @05c40f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9303 @05c413> : 2d c8 9d 05                store.m64 <@059dc8> ;testMathAbs_1F
	test/std/test.math.ci:18: (15 bytes: <@05c417> - <@05c426>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9307 @05c417> : 1b                         load.z128
	<.main+9308 @05c418> : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<.main+9313 @05c41d> : 02                         call
	<.main+9314 @05c41e> : 09 f8 ff ff                inc.sp(-8)
	<.main+9318 @05c422> : 2d d0 9d 05                store.m64 <@059dd0> ;testMathAbs_2F
	test/std/test.math.ci:19: (24 bytes: <@05c426> - <@05c43e>): static testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+9322 @05c426> : 1a                         load.z64
	<.main+9323 @05c427> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9332 @05c430> : 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<.main+9337 @05c435> : 02                         call
	<.main+9338 @05c436> : 09 f8 ff ff                inc.sp(-8)
	<.main+9342 @05c43a> : 2d d8 9d 05                store.m64 <@059dd8> ;testMathAbs_3F
	test/std/test.math.ci:20: (21 bytes: <@05c43e> - <@05c453>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9346 @05c43e> : 19                         load.z32
	<.main+9347 @05c43f> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9352 @05c444> : 1f 40 76 05 00             load.ref <@057640> ;Math.abs(x: float32): float32
	<.main+9357 @05c449> : 02                         call
	<.main+9358 @05c44a> : 09 fc ff ff                inc.sp(-4)
	<.main+9362 @05c44e> : 7d                         f32.2f64
	<.main+9363 @05c44f> : 2d e0 9d 05                store.m64 <@059de0> ;testMathAbs_1f
	test/std/test.math.ci:21: (17 bytes: <@05c453> - <@05c464>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9367 @05c453> : 19                         load.z32
	<.main+9368 @05c454> : 19                         load.z32
	<.main+9369 @05c455> : 1f 40 76 05 00             load.ref <@057640> ;Math.abs(x: float32): float32
	<.main+9374 @05c45a> : 02                         call
	<.main+9375 @05c45b> : 09 fc ff ff                inc.sp(-4)
	<.main+9379 @05c45f> : 7d                         f32.2f64
	<.main+9380 @05c460> : 2d e8 9d 05                store.m64 <@059de8> ;testMathAbs_2f
	test/std/test.math.ci:22: (21 bytes: <@05c464> - <@05c479>): static testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+9384 @05c464> : 19                         load.z32
	<.main+9385 @05c465> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9390 @05c46a> : 1f 40 76 05 00             load.ref <@057640> ;Math.abs(x: float32): float32
	<.main+9395 @05c46f> : 02                         call
	<.main+9396 @05c470> : 09 fc ff ff                inc.sp(-4)
	<.main+9400 @05c474> : 7d                         f32.2f64
	<.main+9401 @05c475> : 2d f0 9d 05                store.m64 <@059df0> ;testMathAbs_3f
	test/std/test.math.ci:24: (26 bytes: <@05c479> - <@05c493>): static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9405 @05c479> : 19                         load.z32
	<.main+9406 @05c47a> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9411 @05c47f> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9416 @05c484> : 1f b0 76 05 00             load.ref <@0576b0> ;Math.min(a: float32, b: float32): float32
	<.main+9421 @05c489> : 02                         call
	<.main+9422 @05c48a> : 09 f8 ff ff                inc.sp(-8)
	<.main+9426 @05c48e> : 7d                         f32.2f64
	<.main+9427 @05c48f> : 2d f8 9d 05                store.m64 <@059df8> ;testMathMin_1f
	test/std/test.math.ci:25: (26 bytes: <@05c493> - <@05c4ad>): static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9431 @05c493> : 19                         load.z32
	<.main+9432 @05c494> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9437 @05c499> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9442 @05c49e> : 1f e0 76 05 00             load.ref <@0576e0> ;Math.max(a: float32, b: float32): float32
	<.main+9447 @05c4a3> : 02                         call
	<.main+9448 @05c4a4> : 09 f8 ff ff                inc.sp(-8)
	<.main+9452 @05c4a8> : 7d                         f32.2f64
	<.main+9453 @05c4a9> : 2d 00 9e 05                store.m64 <@059e00> ;testMathMax_2f
	test/std/test.math.ci:26: (33 bytes: <@05c4ad> - <@05c4ce>): static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9457 @05c4ad> : 1a                         load.z64
	<.main+9458 @05c4ae> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9467 @05c4b7> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9476 @05c4c0> : 1f c8 76 05 00             load.ref <@0576c8> ;Math.min(a: float64, b: float64): float64
	<.main+9481 @05c4c5> : 02                         call
	<.main+9482 @05c4c6> : 09 f0 ff ff                inc.sp(-16)
	<.main+9486 @05c4ca> : 2d 08 9e 05                store.m64 <@059e08> ;testMathMin_1F
	test/std/test.math.ci:27: (33 bytes: <@05c4ce> - <@05c4ef>): static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9490 @05c4ce> : 1a                         load.z64
	<.main+9491 @05c4cf> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9500 @05c4d8> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9509 @05c4e1> : 1f f8 76 05 00             load.ref <@0576f8> ;Math.max(a: float64, b: float64): float64
	<.main+9514 @05c4e6> : 02                         call
	<.main+9515 @05c4e7> : 09 f0 ff ff                inc.sp(-16)
	<.main+9519 @05c4eb> : 2d 10 9e 05                store.m64 <@059e10> ;testMathMax_2F
	test/std/test.math.ci:29: (27 bytes: <@05c4ef> - <@05c50a>): static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9523 @05c4ef> : 19                         load.z32
	<.main+9524 @05c4f0> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9529 @05c4f5> : 19                         load.z32
	<.main+9530 @05c4f6> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9535 @05c4fb> : 1f 10 77 05 00             load.ref <@057710> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9540 @05c500> : 02                         call
	<.main+9541 @05c501> : 09 f4 ff ff                inc.sp(-12)
	<.main+9545 @05c505> : 7d                         f32.2f64
	<.main+9546 @05c506> : 2d 18 9e 05                store.m64 <@059e18> ;testMathClamp_1f
	test/std/test.math.ci:30: (34 bytes: <@05c50a> - <@05c52c>): static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9550 @05c50a> : 1a                         load.z64
	<.main+9551 @05c50b> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9560 @05c514> : 1a                         load.z64
	<.main+9561 @05c515> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9570 @05c51e> : 1f 30 77 05 00             load.ref <@057730> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9575 @05c523> : 02                         call
	<.main+9576 @05c524> : 09 e8 ff ff                inc.sp(-24)
	<.main+9580 @05c528> : 2d 20 9e 05                store.m64 <@059e20> ;testMathClamp_1F
	test/std/test.math.ci:32: (25 bytes: <@05c52c> - <@05c545>): static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9584 @05c52c> : 19                         load.z32
	<.main+9585 @05c52d> : 10 00                      dup.x32 sp(0)
	<.main+9587 @05c52f> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9592 @05c534> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9597 @05c539> : 10 03                      dup.x32 sp(3)
	<.main+9599 @05c53b> : 72                         sub.f32
	<.main+9600 @05c53c> : 73                         mul.f32
	<.main+9601 @05c53d> : 71                         add.f32
	<.main+9602 @05c53e> : 13 01                      set.x32 sp(1)
	<.main+9604 @05c540> : 7d                         f32.2f64
	<.main+9605 @05c541> : 2d 28 9e 05                store.m64 <@059e28> ;testMathLerp_1f
	test/std/test.math.ci:33: (32 bytes: <@05c545> - <@05c565>): static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9609 @05c545> : 1a                         load.z64
	<.main+9610 @05c546> : 11 00                      dup.x64 sp(0)
	<.main+9612 @05c548> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9621 @05c551> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9630 @05c55a> : 11 06                      dup.x64 sp(6)
	<.main+9632 @05c55c> : 82                         sub.f64
	<.main+9633 @05c55d> : 83                         mul.f64
	<.main+9634 @05c55e> : 81                         add.f64
	<.main+9635 @05c55f> : 14 02                      set.x64 sp(2)
	<.main+9637 @05c561> : 2d 30 9e 05                store.m64 <@059e30> ;testMathLerp_1F
	test/std/test.math.ci:35: (64 bytes: <@05c565> - <@05c5a5>): static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9641 @05c565> : 19                         load.z32
	<.main+9642 @05c566> : 19                         load.z32
	<.main+9643 @05c567> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9648 @05c56c> : 10 02                      dup.x32 sp(2)
	<.main+9650 @05c56e> : 72                         sub.f32
	<.main+9651 @05c56f> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9656 @05c574> : 10 03                      dup.x32 sp(3)
	<.main+9658 @05c576> : 72                         sub.f32
	<.main+9659 @05c577> : 74                         div.f32
	<.main+9660 @05c578> : 19                         load.z32
	<.main+9661 @05c579> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9666 @05c57e> : 1f 10 77 05 00             load.ref <@057710> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9671 @05c583> : 02                         call
	<.main+9672 @05c584> : 09 f4 ff ff                inc.sp(-12)
	<.main+9676 @05c588> : 10 00                      dup.x32 sp(0)
	<.main+9678 @05c58a> : 10 01                      dup.x32 sp(1)
	<.main+9680 @05c58c> : 73                         mul.f32
	<.main+9681 @05c58d> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9686 @05c592> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9691 @05c597> : 10 03                      dup.x32 sp(3)
	<.main+9693 @05c599> : 73                         mul.f32
	<.main+9694 @05c59a> : 72                         sub.f32
	<.main+9695 @05c59b> : 73                         mul.f32
	<.main+9696 @05c59c> : 13 01                      set.x32 sp(1)
	<.main+9698 @05c59e> : 13 01                      set.x32 sp(1)
	<.main+9700 @05c5a0> : 7d                         f32.2f64
	<.main+9701 @05c5a1> : 2d 38 9e 05                store.m64 <@059e38> ;testMathSmooth_1f
	test/std/test.math.ci:36: (82 bytes: <@05c5a5> - <@05c5f7>): static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9705 @05c5a5> : 1b                         load.z128
	<.main+9706 @05c5a6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9715 @05c5af> : 11 04                      dup.x64 sp(4)
	<.main+9717 @05c5b1> : 82                         sub.f64
	<.main+9718 @05c5b2> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9727 @05c5bb> : 11 06                      dup.x64 sp(6)
	<.main+9729 @05c5bd> : 82                         sub.f64
	<.main+9730 @05c5be> : 84                         div.f64
	<.main+9731 @05c5bf> : 1a                         load.z64
	<.main+9732 @05c5c0> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9741 @05c5c9> : 1f 30 77 05 00             load.ref <@057730> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9746 @05c5ce> : 02                         call
	<.main+9747 @05c5cf> : 09 e8 ff ff                inc.sp(-24)
	<.main+9751 @05c5d3> : 11 00                      dup.x64 sp(0)
	<.main+9753 @05c5d5> : 11 02                      dup.x64 sp(2)
	<.main+9755 @05c5d7> : 83                         mul.f64
	<.main+9756 @05c5d8> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9765 @05c5e1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9774 @05c5ea> : 11 06                      dup.x64 sp(6)
	<.main+9776 @05c5ec> : 83                         mul.f64
	<.main+9777 @05c5ed> : 82                         sub.f64
	<.main+9778 @05c5ee> : 83                         mul.f64
	<.main+9779 @05c5ef> : 14 02                      set.x64 sp(2)
	<.main+9781 @05c5f1> : 14 02                      set.x64 sp(2)
	<.main+9783 @05c5f3> : 2d 40 9e 05                store.m64 <@059e40> ;testMathSmooth_1F
	test/std/test.math.ci:38: (25 bytes: <@05c5f7> - <@05c610>): static testMathMin_nan: float64 := Math.min()
	<.main+9787 @05c5f7> : 19                         load.z32
	<.main+9788 @05c5f8> : 0a 04 00 00                load.sp(+4)
	<.main+9792 @05c5fc> : 1a                         load.z64
	<.main+9793 @05c5fd> : 11 02                      dup.x64 sp(2)
	<.main+9795 @05c5ff> : 1f 50 77 05 00             load.ref <@057750> ;Math.min(data: float64[]): float64
	<.main+9800 @05c604> : 02                         call
	<.main+9801 @05c605> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9804 @05c608> : 09 f0 ff ff                inc.sp(-16)
	<.main+9808 @05c60c> : 2d 48 9e 05                store.m64 <@059e48> ;testMathMin_nan
	test/std/test.math.ci:39: (110 bytes: <@05c610> - <@05c67e>): static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9812 @05c610> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9821 @05c619> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9830 @05c622> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9839 @05c62b> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9848 @05c634> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9857 @05c63d> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9866 @05c646> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9875 @05c64f> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9884 @05c658> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9893 @05c661> : 1c 09 00 00 00             load.c32 9
	<.main+9898 @05c666> : 0a 04 00 00                load.sp(+4)
	<.main+9902 @05c66a> : 1a                         load.z64
	<.main+9903 @05c66b> : 11 02                      dup.x64 sp(2)
	<.main+9905 @05c66d> : 1f 50 77 05 00             load.ref <@057750> ;Math.min(data: float64[]): float64
	<.main+9910 @05c672> : 02                         call
	<.main+9911 @05c673> : 17 16 02                   mov.x64 sp(22, 2)
	<.main+9914 @05c676> : 09 a8 ff ff                inc.sp(-88)
	<.main+9918 @05c67a> : 2d 50 9e 05                store.m64 <@059e50> ;testMathMin_1
	test/std/test.math.ci:40: (25 bytes: <@05c67e> - <@05c697>): static testMathMax_nan: float64 := Math.max()
	<.main+9922 @05c67e> : 19                         load.z32
	<.main+9923 @05c67f> : 0a 04 00 00                load.sp(+4)
	<.main+9927 @05c683> : 1a                         load.z64
	<.main+9928 @05c684> : 11 02                      dup.x64 sp(2)
	<.main+9930 @05c686> : 1f a0 77 05 00             load.ref <@0577a0> ;Math.max(data: float64[]): float64
	<.main+9935 @05c68b> : 02                         call
	<.main+9936 @05c68c> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9939 @05c68f> : 09 f0 ff ff                inc.sp(-16)
	<.main+9943 @05c693> : 2d 58 9e 05                store.m64 <@059e58> ;testMathMax_nan
	test/std/test.math.ci:41: (110 bytes: <@05c697> - <@05c705>): static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9947 @05c697> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9956 @05c6a0> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9965 @05c6a9> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9974 @05c6b2> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9983 @05c6bb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9992 @05c6c4> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10001 @05c6cd>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10010 @05c6d6>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10019 @05c6df>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10028 @05c6e8>: 1c 09 00 00 00             load.c32 9
	<.main+10033 @05c6ed>: 0a 04 00 00                load.sp(+4)
	<.main+10037 @05c6f1>: 1a                         load.z64
	<.main+10038 @05c6f2>: 11 02                      dup.x64 sp(2)
	<.main+10040 @05c6f4>: 1f a0 77 05 00             load.ref <@0577a0> ;Math.max(data: float64[]): float64
	<.main+10045 @05c6f9>: 02                         call
	<.main+10046 @05c6fa>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10049 @05c6fd>: 09 a8 ff ff                inc.sp(-88)
	<.main+10053 @05c701>: 2d 60 9e 05                store.m64 <@059e60> ;testMathMax_9
	test/std/test.math.ci:43: (25 bytes: <@05c705> - <@05c71e>): static testMathSum_0: float64 := Math.sum()
	<.main+10057 @05c705>: 19                         load.z32
	<.main+10058 @05c706>: 0a 04 00 00                load.sp(+4)
	<.main+10062 @05c70a>: 1a                         load.z64
	<.main+10063 @05c70b>: 11 02                      dup.x64 sp(2)
	<.main+10065 @05c70d>: 1f f0 77 05 00             load.ref <@0577f0> ;Math.sum(data: float64[]): float64
	<.main+10070 @05c712>: 02                         call
	<.main+10071 @05c713>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10074 @05c716>: 09 f0 ff ff                inc.sp(-16)
	<.main+10078 @05c71a>: 2d 68 9e 05                store.m64 <@059e68> ;testMathSum_0
	test/std/test.math.ci:44: (38 bytes: <@05c71e> - <@05c744>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10082 @05c71e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10091 @05c727>: 1c 01 00 00 00             load.c32 1
	<.main+10096 @05c72c>: 0a 04 00 00                load.sp(+4)
	<.main+10100 @05c730>: 1a                         load.z64
	<.main+10101 @05c731>: 11 02                      dup.x64 sp(2)
	<.main+10103 @05c733>: 1f f0 77 05 00             load.ref <@0577f0> ;Math.sum(data: float64[]): float64
	<.main+10108 @05c738>: 02                         call
	<.main+10109 @05c739>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10112 @05c73c>: 09 e8 ff ff                inc.sp(-24)
	<.main+10116 @05c740>: 2d 70 9e 05                store.m64 <@059e70> ;testMathSum_1
	test/std/test.math.ci:45: (47 bytes: <@05c744> - <@05c773>): static testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+10120 @05c744>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10129 @05c74d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10138 @05c756>: 1c 02 00 00 00             load.c32 2
	<.main+10143 @05c75b>: 0a 04 00 00                load.sp(+4)
	<.main+10147 @05c75f>: 1a                         load.z64
	<.main+10148 @05c760>: 11 02                      dup.x64 sp(2)
	<.main+10150 @05c762>: 1f f0 77 05 00             load.ref <@0577f0> ;Math.sum(data: float64[]): float64
	<.main+10155 @05c767>: 02                         call
	<.main+10156 @05c768>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10159 @05c76b>: 09 e0 ff ff                inc.sp(-32)
	<.main+10163 @05c76f>: 2d 78 9e 05                store.m64 <@059e78> ;testMathSum_3
	test/std/test.math.ci:46: (119 bytes: <@05c773> - <@05c7ea>): static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+10167 @05c773>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10176 @05c77c>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10185 @05c785>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10194 @05c78e>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10203 @05c797>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10212 @05c7a0>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10221 @05c7a9>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10230 @05c7b2>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10239 @05c7bb>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10248 @05c7c4>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10257 @05c7cd>: 1c 0a 00 00 00             load.c32 10
	<.main+10262 @05c7d2>: 0a 04 00 00                load.sp(+4)
	<.main+10266 @05c7d6>: 1a                         load.z64
	<.main+10267 @05c7d7>: 11 02                      dup.x64 sp(2)
	<.main+10269 @05c7d9>: 1f f0 77 05 00             load.ref <@0577f0> ;Math.sum(data: float64[]): float64
	<.main+10274 @05c7de>: 02                         call
	<.main+10275 @05c7df>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10278 @05c7e2>: 09 a0 ff ff                inc.sp(-96)
	<.main+10282 @05c7e6>: 2d 80 9e 05                store.m64 <@059e80> ;testMathSum_55
	test/std/test.math.ci:48: (13 bytes: <@05c7ea> - <@05c7f7>): static testMathEval_x: float64 := 10
	<.main+10286 @05c7ea>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10295 @05c7f3>: 2d 88 9e 05                store.m64 <@059e88> ;testMathEval_x
	test/std/test.math.ci:49: (29 bytes: <@05c7f7> - <@05c814>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10299 @05c7f7>: 19                         load.z32
	<.main+10300 @05c7f8>: 0a 04 00 00                load.sp(+4)
	<.main+10304 @05c7fc>: 1a                         load.z64
	<.main+10305 @05c7fd>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10309 @05c801>: 11 04                      dup.x64 sp(4)
	<.main+10311 @05c803>: 1f 30 78 05 00             load.ref <@057830> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10316 @05c808>: 02                         call
	<.main+10317 @05c809>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10320 @05c80c>: 09 e8 ff ff                inc.sp(-24)
	<.main+10324 @05c810>: 2d 90 9e 05                store.m64 <@059e90> ;testMathEval_0
	test/std/test.math.ci:50: (13 bytes: <@05c814> - <@05c821>): static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+10328 @05c814>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10337 @05c81d>: 2d 98 9e 05                store.m64 <@059e98> ;testMathEval_1
	test/std/test.math.ci:51: (28 bytes: <@05c821> - <@05c83d>): static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+10341 @05c821>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10350 @05c82a>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10354 @05c82e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10363 @05c837>: 83                         mul.f64
	<.main+10364 @05c838>: 81                         add.f64
	<.main+10365 @05c839>: 2d a0 9e 05                store.m64 <@059ea0> ;testMathEval_2
	test/std/test.math.ci:52: (45 bytes: <@05c83d> - <@05c86a>): static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+10369 @05c83d>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10373 @05c841>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10382 @05c84a>: 11 02                      dup.x64 sp(2)
	<.main+10384 @05c84c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10393 @05c855>: 11 06                      dup.x64 sp(6)
	<.main+10395 @05c857>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10404 @05c860>: 83                         mul.f64
	<.main+10405 @05c861>: 81                         add.f64
	<.main+10406 @05c862>: 83                         mul.f64
	<.main+10407 @05c863>: 81                         add.f64
	<.main+10408 @05c864>: 14 02                      set.x64 sp(2)
	<.main+10410 @05c866>: 2d a8 9e 05                store.m64 <@059ea8> ;testMathEval_3
	test/std/test.math.ci:53: (62 bytes: <@05c86a> - <@05c8a8>): static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10414 @05c86a>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10418 @05c86e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10427 @05c877>: 11 02                      dup.x64 sp(2)
	<.main+10429 @05c879>: 11 04                      dup.x64 sp(4)
	<.main+10431 @05c87b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10440 @05c884>: 11 02                      dup.x64 sp(2)
	<.main+10442 @05c886>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10451 @05c88f>: 11 06                      dup.x64 sp(6)
	<.main+10453 @05c891>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10462 @05c89a>: 83                         mul.f64
	<.main+10463 @05c89b>: 81                         add.f64
	<.main+10464 @05c89c>: 83                         mul.f64
	<.main+10465 @05c89d>: 81                         add.f64
	<.main+10466 @05c89e>: 14 02                      set.x64 sp(2)
	<.main+10468 @05c8a0>: 83                         mul.f64
	<.main+10469 @05c8a1>: 81                         add.f64
	<.main+10470 @05c8a2>: 14 02                      set.x64 sp(2)
	<.main+10472 @05c8a4>: 2d b0 9e 05                store.m64 <@059eb0> ;testMathEval_4
	test/std/test.math.ci:54: (78 bytes: <@05c8a8> - <@05c8f6>): static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10476 @05c8a8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10485 @05c8b1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10494 @05c8ba>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10503 @05c8c3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10512 @05c8cc>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10521 @05c8d5>: 1c 05 00 00 00             load.c32 5
	<.main+10526 @05c8da>: 0a 04 00 00                load.sp(+4)
	<.main+10530 @05c8de>: 1a                         load.z64
	<.main+10531 @05c8df>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10535 @05c8e3>: 11 04                      dup.x64 sp(4)
	<.main+10537 @05c8e5>: 1f 30 78 05 00             load.ref <@057830> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10542 @05c8ea>: 02                         call
	<.main+10543 @05c8eb>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10546 @05c8ee>: 09 c0 ff ff                inc.sp(-64)
	<.main+10550 @05c8f2>: 2d b8 9e 05                store.m64 <@059eb8> ;testMathEval_5
	test/std/test.math.ci:55: (87 bytes: <@05c8f6> - <@05c94d>): static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10554 @05c8f6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10563 @05c8ff>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10572 @05c908>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10581 @05c911>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10590 @05c91a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10599 @05c923>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10608 @05c92c>: 1c 06 00 00 00             load.c32 6
	<.main+10613 @05c931>: 0a 04 00 00                load.sp(+4)
	<.main+10617 @05c935>: 1a                         load.z64
	<.main+10618 @05c936>: 2b 88 9e 05                load.m64 <@059e88> ;testMathEval_x
	<.main+10622 @05c93a>: 11 04                      dup.x64 sp(4)
	<.main+10624 @05c93c>: 1f 30 78 05 00             load.ref <@057830> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10629 @05c941>: 02                         call
	<.main+10630 @05c942>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10633 @05c945>: 09 b8 ff ff                inc.sp(-72)
	<.main+10637 @05c949>: 2d c0 9e 05                store.m64 <@059ec0> ;testMathEval_6
	test/std/test.math.ci:57: (35 bytes: <@05c94d> - <@05c970>): static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10641 @05c94d>: 1a                         load.z64
	<.main+10642 @05c94e>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10651 @05c957>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10660 @05c960>: 84                         div.f64
	<.main+10661 @05c961>: 19                         load.z32
	<.main+10662 @05c962>: 1f e0 78 05 00             load.ref <@0578e0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10667 @05c967>: 02                         call
	<.main+10668 @05c968>: 09 f4 ff ff                inc.sp(-12)
	<.main+10672 @05c96c>: 2d c8 9e 05                store.m64 <@059ec8> ;testMathSin_f64
	test/std/test.math.ci:58: (49 bytes: <@05c970> - <@05c9a1>): static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10676 @05c970>: 1b                         load.z128
	<.main+10677 @05c971>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10686 @05c97a>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10695 @05c983>: 84                         div.f64
	<.main+10696 @05c984>: 1f 58 76 05 00             load.ref <@057658> ;Math.abs(x: float64): float64
	<.main+10701 @05c989>: 02                         call
	<.main+10702 @05c98a>: 09 f8 ff ff                inc.sp(-8)
	<.main+10706 @05c98e>: 1c 01 00 00 00             load.c32 1
	<.main+10711 @05c993>: 1f e0 78 05 00             load.ref <@0578e0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10716 @05c998>: 02                         call
	<.main+10717 @05c999>: 09 f4 ff ff                inc.sp(-12)
	<.main+10721 @05c99d>: 2d d0 9e 05                store.m64 <@059ed0> ;testMathCos_f64
	test/std/test.math.ci:59: (34 bytes: <@05c9a1> - <@05c9c3>): static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10725 @05c9a1>: 1a                         load.z64
	<.main+10726 @05c9a2>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10735 @05c9ab>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10744 @05c9b4>: 84                         div.f64
	<.main+10745 @05c9b5>: 1f 30 7a 05 00             load.ref <@057a30> ;Math.tan(arg: float64): float64
	<.main+10750 @05c9ba>: 02                         call
	<.main+10751 @05c9bb>: 09 f8 ff ff                inc.sp(-8)
	<.main+10755 @05c9bf>: 2d d8 9e 05                store.m64 <@059ed8> ;testMathTan_f64
	test/std/test.math.ci:60: (34 bytes: <@05c9c3> - <@05c9e5>): static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10759 @05c9c3>: 1a                         load.z64
	<.main+10760 @05c9c4>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10769 @05c9cd>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10778 @05c9d6>: 84                         div.f64
	<.main+10779 @05c9d7>: 1f b0 7b 05 00             load.ref <@057bb0> ;Math.sinh(x: float64): float64
	<.main+10784 @05c9dc>: 02                         call
	<.main+10785 @05c9dd>: 09 f8 ff ff                inc.sp(-8)
	<.main+10789 @05c9e1>: 2d e0 9e 05                store.m64 <@059ee0> ;testMathSinh_f64
	test/std/test.math.ci:61: (34 bytes: <@05c9e5> - <@05ca07>): static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10793 @05c9e5>: 1a                         load.z64
	<.main+10794 @05c9e6>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10803 @05c9ef>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10812 @05c9f8>: 84                         div.f64
	<.main+10813 @05c9f9>: 1f a8 7c 05 00             load.ref <@057ca8> ;Math.cosh(x: float64): float64
	<.main+10818 @05c9fe>: 02                         call
	<.main+10819 @05c9ff>: 09 f8 ff ff                inc.sp(-8)
	<.main+10823 @05ca03>: 2d e8 9e 05                store.m64 <@059ee8> ;testMathCosh_f64
	test/std/test.math.ci:63: (24 bytes: <@05ca07> - <@05ca1f>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10827 @05ca07>: 1a                         load.z64
	<.main+10828 @05ca08>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10837 @05ca11>: 1f f8 7c 05 00             load.ref <@057cf8> ;Math.asin(x: float64): float64
	<.main+10842 @05ca16>: 02                         call
	<.main+10843 @05ca17>: 09 f8 ff ff                inc.sp(-8)
	<.main+10847 @05ca1b>: 2d f0 9e 05                store.m64 <@059ef0> ;testMathAsin_f64
	test/std/test.math.ci:64: (44 bytes: <@05ca1f> - <@05ca4b>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10851 @05ca1f>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10860 @05ca28>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10869 @05ca31>: 84                         div.f64
	<.main+10870 @05ca32>: 1a                         load.z64
	<.main+10871 @05ca33>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10880 @05ca3c>: 1f f8 7c 05 00             load.ref <@057cf8> ;Math.asin(x: float64): float64
	<.main+10885 @05ca41>: 02                         call
	<.main+10886 @05ca42>: 09 f8 ff ff                inc.sp(-8)
	<.main+10890 @05ca46>: 82                         sub.f64
	<.main+10891 @05ca47>: 2d f8 9e 05                store.m64 <@059ef8> ;testMathAcos_f64
	test/std/test.math.ci:67: (34 bytes: <@05ca4b> - <@05ca6d>): static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10895 @05ca4b>: 19                         load.z32
	<.main+10896 @05ca4c>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10901 @05ca51>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10906 @05ca56>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10911 @05ca5b>: 1f 60 78 05 00             load.ref <@057860> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10916 @05ca60>: 02                         call
	<.main+10917 @05ca61>: 09 f4 ff ff                inc.sp(-12)
	<.main+10921 @05ca65>: 19                         load.z32
	<.main+10922 @05ca66>: 57                         ceq.i32
	<.main+10923 @05ca67>: 1f 00 9f 05 00             load.ref <@059f00> ;testMathCmp_f32
	<.main+10928 @05ca6c>: 25                         store.i8
	test/std/test.math.ci:68: (46 bytes: <@05ca6d> - <@05ca9b>): static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10929 @05ca6d>: 19                         load.z32
	<.main+10930 @05ca6e>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10939 @05ca77>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10948 @05ca80>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10957 @05ca89>: 1f a0 78 05 00             load.ref <@0578a0> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10962 @05ca8e>: 02                         call
	<.main+10963 @05ca8f>: 09 e8 ff ff                inc.sp(-24)
	<.main+10967 @05ca93>: 19                         load.z32
	<.main+10968 @05ca94>: 57                         ceq.i32
	<.main+10969 @05ca95>: 1f 08 9f 05 00             load.ref <@059f08> ;testMathCmp_f64
	<.main+10974 @05ca9a>: 25                         store.i8
	test/std/test.math.ci:70: (33 bytes: <@05ca9b> - <@05cabc>): static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10975 @05ca9b>: 1a                         load.z64
	<.main+10976 @05ca9c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10985 @05caa5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10994 @05caae>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10999 @05cab3>: 02                         call
	<.main+11000 @05cab4>: 09 f0 ff ff                inc.sp(-16)
	<.main+11004 @05cab8>: 2d 10 9f 05                store.m64 <@059f10> ;testMathAbsMod_f64_0a
	test/std/test.math.ci:71: (24 bytes: <@05cabc> - <@05cad4>): static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+11008 @05cabc>: 1b                         load.z128
	<.main+11009 @05cabd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11018 @05cac6>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11023 @05cacb>: 02                         call
	<.main+11024 @05cacc>: 09 f0 ff ff                inc.sp(-16)
	<.main+11028 @05cad0>: 2d 18 9f 05                store.m64 <@059f18> ;testMathAbsMod_f64_0b
	test/std/test.math.ci:72: (33 bytes: <@05cad4> - <@05caf5>): static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+11032 @05cad4>: 1a                         load.z64
	<.main+11033 @05cad5>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11042 @05cade>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11051 @05cae7>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11056 @05caec>: 02                         call
	<.main+11057 @05caed>: 09 f0 ff ff                inc.sp(-16)
	<.main+11061 @05caf1>: 2d 20 9f 05                store.m64 <@059f20> ;testMathAbsMod_f64_0c
	test/std/test.math.ci:74: (33 bytes: <@05caf5> - <@05cb16>): static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+11065 @05caf5>: 1a                         load.z64
	<.main+11066 @05caf6>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11075 @05caff>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11084 @05cb08>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11089 @05cb0d>: 02                         call
	<.main+11090 @05cb0e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11094 @05cb12>: 2d 28 9f 05                store.m64 <@059f28> ;testMathAbsMod_f64_9a
	test/std/test.math.ci:75: (33 bytes: <@05cb16> - <@05cb37>): static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+11098 @05cb16>: 1a                         load.z64
	<.main+11099 @05cb17>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11108 @05cb20>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11117 @05cb29>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11122 @05cb2e>: 02                         call
	<.main+11123 @05cb2f>: 09 f0 ff ff                inc.sp(-16)
	<.main+11127 @05cb33>: 2d 30 9f 05                store.m64 <@059f30> ;testMathAbsMod_f64_9b
	test/std/test.math.ci:76: (33 bytes: <@05cb37> - <@05cb58>): static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+11131 @05cb37>: 1a                         load.z64
	<.main+11132 @05cb38>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11141 @05cb41>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11150 @05cb4a>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11155 @05cb4f>: 02                         call
	<.main+11156 @05cb50>: 09 f0 ff ff                inc.sp(-16)
	<.main+11160 @05cb54>: 2d 38 9f 05                store.m64 <@059f38> ;testMathAbsMod_f64_9c
	test/std/test.math.ci:77: (33 bytes: <@05cb58> - <@05cb79>): static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+11164 @05cb58>: 1a                         load.z64
	<.main+11165 @05cb59>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11174 @05cb62>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11183 @05cb6b>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11188 @05cb70>: 02                         call
	<.main+11189 @05cb71>: 09 f0 ff ff                inc.sp(-16)
	<.main+11193 @05cb75>: 2d 40 9f 05                store.m64 <@059f40> ;testMathAbsMod_f64_9d
	test/std/test.math.ci:79: (33 bytes: <@05cb79> - <@05cb9a>): static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+11197 @05cb79>: 1a                         load.z64
	<.main+11198 @05cb7a>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11207 @05cb83>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11216 @05cb8c>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11221 @05cb91>: 02                         call
	<.main+11222 @05cb92>: 09 f0 ff ff                inc.sp(-16)
	<.main+11226 @05cb96>: 2d 48 9f 05                store.m64 <@059f48> ;testMathAbsMod_f64_8a
	test/std/test.math.ci:80: (33 bytes: <@05cb9a> - <@05cbbb>): static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+11230 @05cb9a>: 1a                         load.z64
	<.main+11231 @05cb9b>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11240 @05cba4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11249 @05cbad>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11254 @05cbb2>: 02                         call
	<.main+11255 @05cbb3>: 09 f0 ff ff                inc.sp(-16)
	<.main+11259 @05cbb7>: 2d 50 9f 05                store.m64 <@059f50> ;testMathAbsMod_f64_8b
	test/std/test.math.ci:81: (33 bytes: <@05cbbb> - <@05cbdc>): static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+11263 @05cbbb>: 1a                         load.z64
	<.main+11264 @05cbbc>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11273 @05cbc5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11282 @05cbce>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11287 @05cbd3>: 02                         call
	<.main+11288 @05cbd4>: 09 f0 ff ff                inc.sp(-16)
	<.main+11292 @05cbd8>: 2d 58 9f 05                store.m64 <@059f58> ;testMathAbsMod_f64_8c
	test/std/test.math.ci:82: (33 bytes: <@05cbdc> - <@05cbfd>): static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+11296 @05cbdc>: 1a                         load.z64
	<.main+11297 @05cbdd>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11306 @05cbe6>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11315 @05cbef>: 1f 90 76 05 00             load.ref <@057690> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11320 @05cbf4>: 02                         call
	<.main+11321 @05cbf5>: 09 f0 ff ff                inc.sp(-16)
	<.main+11325 @05cbf9>: 2d 60 9f 05                store.m64 <@059f60> ;testMathAbsMod_f64_8d
	test/std/test.math.ci:84: (25 bytes: <@05cbfd> - <@05cc16>): static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+11329 @05cbfd>: 19                         load.z32
	<.main+11330 @05cbfe>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11335 @05cc03>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11340 @05cc08>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11345 @05cc0d>: 02                         call
	<.main+11346 @05cc0e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11350 @05cc12>: 2e 68 9f 05                store.m32 <@059f68> ;testMathAbsMod_f32_0a
	test/std/test.math.ci:85: (21 bytes: <@05cc16> - <@05cc2b>): static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+11354 @05cc16>: 19                         load.z32
	<.main+11355 @05cc17>: 19                         load.z32
	<.main+11356 @05cc18>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11361 @05cc1d>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11366 @05cc22>: 02                         call
	<.main+11367 @05cc23>: 09 f8 ff ff                inc.sp(-8)
	<.main+11371 @05cc27>: 2e 70 9f 05                store.m32 <@059f70> ;testMathAbsMod_f32_0b
	test/std/test.math.ci:86: (25 bytes: <@05cc2b> - <@05cc44>): static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+11375 @05cc2b>: 19                         load.z32
	<.main+11376 @05cc2c>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11381 @05cc31>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11386 @05cc36>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11391 @05cc3b>: 02                         call
	<.main+11392 @05cc3c>: 09 f8 ff ff                inc.sp(-8)
	<.main+11396 @05cc40>: 2e 78 9f 05                store.m32 <@059f78> ;testMathAbsMod_f32_0c
	test/std/test.math.ci:88: (25 bytes: <@05cc44> - <@05cc5d>): static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+11400 @05cc44>: 19                         load.z32
	<.main+11401 @05cc45>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11406 @05cc4a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11411 @05cc4f>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11416 @05cc54>: 02                         call
	<.main+11417 @05cc55>: 09 f8 ff ff                inc.sp(-8)
	<.main+11421 @05cc59>: 2e 80 9f 05                store.m32 <@059f80> ;testMathAbsMod_f32_9a
	test/std/test.math.ci:89: (25 bytes: <@05cc5d> - <@05cc76>): static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+11425 @05cc5d>: 19                         load.z32
	<.main+11426 @05cc5e>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11431 @05cc63>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11436 @05cc68>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11441 @05cc6d>: 02                         call
	<.main+11442 @05cc6e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11446 @05cc72>: 2e 88 9f 05                store.m32 <@059f88> ;testMathAbsMod_f32_9b
	test/std/test.math.ci:90: (25 bytes: <@05cc76> - <@05cc8f>): static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+11450 @05cc76>: 19                         load.z32
	<.main+11451 @05cc77>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11456 @05cc7c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11461 @05cc81>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11466 @05cc86>: 02                         call
	<.main+11467 @05cc87>: 09 f8 ff ff                inc.sp(-8)
	<.main+11471 @05cc8b>: 2e 90 9f 05                store.m32 <@059f90> ;testMathAbsMod_f32_9c
	test/std/test.math.ci:91: (25 bytes: <@05cc8f> - <@05cca8>): static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+11475 @05cc8f>: 19                         load.z32
	<.main+11476 @05cc90>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11481 @05cc95>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11486 @05cc9a>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11491 @05cc9f>: 02                         call
	<.main+11492 @05cca0>: 09 f8 ff ff                inc.sp(-8)
	<.main+11496 @05cca4>: 2e 98 9f 05                store.m32 <@059f98> ;testMathAbsMod_f32_9d
	test/std/test.math.ci:93: (25 bytes: <@05cca8> - <@05ccc1>): static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+11500 @05cca8>: 19                         load.z32
	<.main+11501 @05cca9>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11506 @05ccae>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11511 @05ccb3>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11516 @05ccb8>: 02                         call
	<.main+11517 @05ccb9>: 09 f8 ff ff                inc.sp(-8)
	<.main+11521 @05ccbd>: 2e a0 9f 05                store.m32 <@059fa0> ;testMathAbsMod_f32_8a
	test/std/test.math.ci:94: (25 bytes: <@05ccc1> - <@05ccda>): static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+11525 @05ccc1>: 19                         load.z32
	<.main+11526 @05ccc2>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11531 @05ccc7>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11536 @05cccc>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11541 @05ccd1>: 02                         call
	<.main+11542 @05ccd2>: 09 f8 ff ff                inc.sp(-8)
	<.main+11546 @05ccd6>: 2e a8 9f 05                store.m32 <@059fa8> ;testMathAbsMod_f32_8b
	test/std/test.math.ci:95: (25 bytes: <@05ccda> - <@05ccf3>): static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+11550 @05ccda>: 19                         load.z32
	<.main+11551 @05ccdb>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11556 @05cce0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11561 @05cce5>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11566 @05ccea>: 02                         call
	<.main+11567 @05cceb>: 09 f8 ff ff                inc.sp(-8)
	<.main+11571 @05ccef>: 2e b0 9f 05                store.m32 <@059fb0> ;testMathAbsMod_f32_8c
	test/std/test.math.ci:96: (25 bytes: <@05ccf3> - <@05cd0c>): static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+11575 @05ccf3>: 19                         load.z32
	<.main+11576 @05ccf4>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11581 @05ccf9>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11586 @05ccfe>: 1f 70 76 05 00             load.ref <@057670> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11591 @05cd03>: 02                         call
	<.main+11592 @05cd04>: 09 f8 ff ff                inc.sp(-8)
	<.main+11596 @05cd08>: 2e b8 9f 05                store.m32 <@059fb8> ;testMathAbsMod_f32_8d
	test/std/memory.ci:13: (18 bytes: <@05cd0c> - <@05cd1e>): pointer.fill(void(void(p1, 0), 1024));
	<.main+11600 @05cd0c>: 2a 20 92 05                load.m32 <@059220> ;p1
	<.main+11604 @05cd10>: 19                         load.z32
	<.main+11605 @05cd11>: 1c 00 04 00 00             load.c32 1024
	<.main+11610 @05cd16>: 01 0c 00 00                nfc(12) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11614 @05cd1a>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:14: (21 bytes: <@05cd1e> - <@05cd33>): pointer.copy(void(void(p1, p3), 160));
	<.main+11618 @05cd1e>: 2a 20 92 05                load.m32 <@059220> ;p1
	<.main+11622 @05cd22>: 2a 30 92 05                load.m32 <@059230> ;p3
	<.main+11626 @05cd26>: 1c a0 00 00 00             load.c32 160
	<.main+11631 @05cd2b>: 01 0d 00 00                nfc(13) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11635 @05cd2f>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:17: (13 bytes: <@05cd33> - <@05cd40>): free(p1);
	<.main+11639 @05cd33>: 2a 20 92 05                load.m32 <@059220> ;p1
	<.main+11643 @05cd37>: 19                         load.z32
	<.main+11644 @05cd38>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11648 @05cd3c>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:18: (13 bytes: <@05cd40> - <@05cd4d>): free(p2);
	<.main+11652 @05cd40>: 2a 28 92 05                load.m32 <@059228> ;p2
	<.main+11656 @05cd44>: 19                         load.z32
	<.main+11657 @05cd45>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11661 @05cd49>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:19: (13 bytes: <@05cd4d> - <@05cd5a>): free(p3);
	<.main+11665 @05cd4d>: 2a 30 92 05                load.m32 <@059230> ;p3
	<.main+11669 @05cd51>: 19                         load.z32
	<.main+11670 @05cd52>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11674 @05cd56>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:20: (13 bytes: <@05cd5a> - <@05cd67>): free(p4);
	<.main+11678 @05cd5a>: 2a 38 92 05                load.m32 <@059238> ;p4
	<.main+11682 @05cd5e>: 19                         load.z32
	<.main+11683 @05cd5f>: 01 0b 00 00                nfc(11) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11687 @05cd63>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:26: (35 bytes: <@05cd67> - <@05cd8a>): debug(void("val1", val1));
	<.main+11691 @05cd67>: 1f 00 17 04 00             load.ref <@041700> ;"test/std/memory.ci"
	<.main+11696 @05cd6c>: 1c 1a 00 00 00             load.c32 26
	<.main+11701 @05cd71>: 1c 0e 00 00 00             load.c32 14
	<.main+11706 @05cd76>: 19                         load.z32
	<.main+11707 @05cd77>: 1f 27 17 04 00             load.ref <@041727> ;"val1"
	<.main+11712 @05cd7c>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11717 @05cd81>: 1f 40 92 05 00             load.ref <@059240> ;val1
	<.main+11722 @05cd86>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:27: (35 bytes: <@05cd8a> - <@05cdad>): debug(void("val2", val2));
	<.main+11726 @05cd8a>: 1f 00 17 04 00             load.ref <@041700> ;"test/std/memory.ci"
	<.main+11731 @05cd8f>: 1c 1b 00 00 00             load.c32 27
	<.main+11736 @05cd94>: 1c 0e 00 00 00             load.c32 14
	<.main+11741 @05cd99>: 19                         load.z32
	<.main+11742 @05cd9a>: 1f 2c 17 04 00             load.ref <@04172c> ;"val2"
	<.main+11747 @05cd9f>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11752 @05cda4>: 1f 48 92 05 00             load.ref <@059248> ;val2
	<.main+11757 @05cda9>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:29: (22 bytes: <@05cdad> - <@05cdc3>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+11761 @05cdad>: 1f 48 92 05 00             load.ref <@059248> ;val2
	<.main+11766 @05cdb2>: 1f 40 92 05 00             load.ref <@059240> ;val1
	<.main+11771 @05cdb7>: 2a 90 04 00                load.m32 <@000490> ;int64+32
	<.main+11775 @05cdbb>: 01 0e 00 00                nfc(14) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+11779 @05cdbf>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:30: (18 bytes: <@05cdc3> - <@05cdd5>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+11783 @05cdc3>: 1f 40 92 05 00             load.ref <@059240> ;val1
	<.main+11788 @05cdc8>: 19                         load.z32
	<.main+11789 @05cdc9>: 2a 90 04 00                load.m32 <@000490> ;int64+32
	<.main+11793 @05cdcd>: 01 0c 00 00                nfc(12) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11797 @05cdd1>: 09 fc ff ff                inc.sp(-4)
	test/std/memory.ci:32: (35 bytes: <@05cdd5> - <@05cdf8>): debug(void("val1", val1));
	<.main+11801 @05cdd5>: 1f 00 17 04 00             load.ref <@041700> ;"test/std/memory.ci"
	<.main+11806 @05cdda>: 1c 20 00 00 00             load.c32 32
	<.main+11811 @05cddf>: 1c 0e 00 00 00             load.c32 14
	<.main+11816 @05cde4>: 19                         load.z32
	<.main+11817 @05cde5>: 1f 27 17 04 00             load.ref <@041727> ;"val1"
	<.main+11822 @05cdea>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11827 @05cdef>: 1f 40 92 05 00             load.ref <@059240> ;val1
	<.main+11832 @05cdf4>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/std/memory.ci:33: (35 bytes: <@05cdf8> - <@05ce1b>): debug(void("val2", val2));
	<.main+11836 @05cdf8>: 1f 00 17 04 00             load.ref <@041700> ;"test/std/memory.ci"
	<.main+11841 @05cdfd>: 1c 21 00 00 00             load.c32 33
	<.main+11846 @05ce02>: 1c 0e 00 00 00             load.c32 14
	<.main+11851 @05ce07>: 19                         load.z32
	<.main+11852 @05ce08>: 1f 2c 17 04 00             load.ref <@04172c> ;"val2"
	<.main+11857 @05ce0d>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11862 @05ce12>: 1f 48 92 05 00             load.ref <@059248> ;val2
	<.main+11867 @05ce17>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:54: (46 bytes: <@05ce1b> - <@05ce49>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+11871 @05ce1b>: 19                         load.z32
	<.main+11872 @05ce1c>: 04 1d 00 00                jmp <.main+11901 @05ce39>
	test/lang/array.ci:55: (21 bytes: <@05ce20> - <@05ce35>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+11876 @05ce20>: 1c 2a 00 00 00             load.c32 42
	<.main+11881 @05ce25>: 10 01                      dup.x32 sp(1)
	<.main+11883 @05ce27>: 51                         add.i32
	<.main+11884 @05ce28>: 5b                         i32.2i64
	<.main+11885 @05ce29>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+11890 @05ce2e>: 10 03                      dup.x32 sp(3)
	<.main+11892 @05ce30>: 0d 08 00 00                mad.u32 8
	<.main+11896 @05ce34>: 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@05ce35> - <@05ce39>): int32(i := int32(i + 1))
	<.main+11897 @05ce35>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@05ce39> - <@05ce45>): bool(i < arrFixedNoInit.length)
	<.main+11901 @05ce39>: 10 00                      dup.x32 sp(0)
	<.main+11903 @05ce3b>: 1c 07 00 00 00             load.c32 7
	<.main+11908 @05ce40>: 58                         clt.i32
	<.main+11909 @05ce41>: 05 df ff ff                jnz <.main+11876 @05ce20>
	<.main+11913 @05ce45>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:82: (23 bytes: <@05ce49> - <@05ce60>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+11917 @05ce49>: 1f 98 93 05 00             load.ref <@059398> ;strFixed
	<.main+11922 @05ce4e>: 1f bc 25 03 00             load.ref <@0325bc> ;"string"
	<.main+11927 @05ce53>: 1c 07 00 00 00             load.c32 7
	<.main+11932 @05ce58>: 01 0d 00 00                nfc(13) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11936 @05ce5c>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (35 bytes: <@05ce60> - <@05ce83>): debug(void("string as variant", strFixed));
	<.main+11940 @05ce60>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+11945 @05ce65>: 1c 53 00 00 00             load.c32 83
	<.main+11950 @05ce6a>: 1c 0e 00 00 00             load.c32 14
	<.main+11955 @05ce6f>: 19                         load.z32
	<.main+11956 @05ce70>: 1f 53 38 04 00             load.ref <@043853> ;"string as variant"
	<.main+11961 @05ce75>: 1f 60 46 04 00             load.ref <@044660>
	<.main+11966 @05ce7a>: 1f 98 93 05 00             load.ref <@059398> ;strFixed
	<.main+11971 @05ce7f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (35 bytes: <@05ce83> - <@05cea6>): debug(void("string to variant", variant(strFixed)));
	<.main+11975 @05ce83>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+11980 @05ce88>: 1c 54 00 00 00             load.c32 84
	<.main+11985 @05ce8d>: 1c 0e 00 00 00             load.c32 14
	<.main+11990 @05ce92>: 19                         load.z32
	<.main+11991 @05ce93>: 1f 65 38 04 00             load.ref <@043865> ;"string to variant"
	<.main+11996 @05ce98>: 1f 60 46 04 00             load.ref <@044660>
	<.main+12001 @05ce9d>: 1f 98 93 05 00             load.ref <@059398> ;strFixed
	<.main+12006 @05cea2>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:87: (34 bytes: <@05cea6> - <@05cec8>): debug(void("string as variant", strArray));
	<.main+12010 @05cea6>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12015 @05ceab>: 1c 57 00 00 00             load.c32 87
	<.main+12020 @05ceb0>: 1c 0e 00 00 00             load.c32 14
	<.main+12025 @05ceb5>: 19                         load.z32
	<.main+12026 @05ceb6>: 1f 53 38 04 00             load.ref <@043853> ;"string as variant"
	<.main+12031 @05cebb>: 1f 28 48 04 00             load.ref <@044828>
	<.main+12036 @05cec0>: 2a a0 93 05                load.m32 <@0593a0> ;strArray
	<.main+12040 @05cec4>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (34 bytes: <@05cec8> - <@05ceea>): debug(void("string to variant", variant(strArray)));
	<.main+12044 @05cec8>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12049 @05cecd>: 1c 58 00 00 00             load.c32 88
	<.main+12054 @05ced2>: 1c 0e 00 00 00             load.c32 14
	<.main+12059 @05ced7>: 19                         load.z32
	<.main+12060 @05ced8>: 1f 65 38 04 00             load.ref <@043865> ;"string to variant"
	<.main+12065 @05cedd>: 1f 28 48 04 00             load.ref <@044828>
	<.main+12070 @05cee2>: 2a a0 93 05                load.m32 <@0593a0> ;strArray
	<.main+12074 @05cee6>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:91: (34 bytes: <@05ceea> - <@05cf0c>): debug(void("string as variant", strSlice));
	<.main+12078 @05ceea>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12083 @05ceef>: 1c 5b 00 00 00             load.c32 91
	<.main+12088 @05cef4>: 1c 0e 00 00 00             load.c32 14
	<.main+12093 @05cef9>: 19                         load.z32
	<.main+12094 @05cefa>: 1f 53 38 04 00             load.ref <@043853> ;"string as variant"
	<.main+12099 @05ceff>: 1f 58 49 04 00             load.ref <@044958>
	<.main+12104 @05cf04>: 2a a8 93 05                load.m32 <@0593a8> ;strSlice
	<.main+12108 @05cf08>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (34 bytes: <@05cf0c> - <@05cf2e>): debug(void("string to variant", variant(strSlice)));
	<.main+12112 @05cf0c>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12117 @05cf11>: 1c 5c 00 00 00             load.c32 92
	<.main+12122 @05cf16>: 1c 0e 00 00 00             load.c32 14
	<.main+12127 @05cf1b>: 19                         load.z32
	<.main+12128 @05cf1c>: 1f 65 38 04 00             load.ref <@043865> ;"string to variant"
	<.main+12133 @05cf21>: 1f 58 49 04 00             load.ref <@044958>
	<.main+12138 @05cf26>: 2a a8 93 05                load.m32 <@0593a8> ;strSlice
	<.main+12142 @05cf2a>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (53 bytes: <@05cf2e> - <@05cf63>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+12146 @05cf2e>: 2a 5c 93 05                load.m32 <@05935c> ;arrSliceNoInit+4
	<.main+12150 @05cf32>: 19                         load.z32
	<.main+12151 @05cf33>: 38                         clt.u32
	<.main+12152 @05cf34>: 05 08 00 00                jnz <.main+12160 @05cf3c>
	<.main+12156 @05cf38>: 04 2b 00 00                jmp <.main+12199 @05cf63>
	<.main+12160 @05cf3c>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12165 @05cf41>: 1c 62 00 00 00             load.c32 98
	<.main+12170 @05cf46>: 1c fe ff ff ff             load.c32 -2
	<.main+12175 @05cf4b>: 1c 80 00 00 00             load.c32 128
	<.main+12180 @05cf50>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12185 @05cf55>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12190 @05cf5a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12195 @05cf5f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (53 bytes: <@05cf63> - <@05cf98>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+12199 @05cf63>: 2a 6c 93 05                load.m32 <@05936c> ;arrSliceInitNull+4
	<.main+12203 @05cf67>: 19                         load.z32
	<.main+12204 @05cf68>: 57                         ceq.i32
	<.main+12205 @05cf69>: 06 08 00 00                jz <.main+12213 @05cf71>
	<.main+12209 @05cf6d>: 04 2b 00 00                jmp <.main+12252 @05cf98>
	<.main+12213 @05cf71>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12218 @05cf76>: 1c 63 00 00 00             load.c32 99
	<.main+12223 @05cf7b>: 1c fe ff ff ff             load.c32 -2
	<.main+12228 @05cf80>: 1c 80 00 00 00             load.c32 128
	<.main+12233 @05cf85>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12238 @05cf8a>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12243 @05cf8f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12248 @05cf94>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (61 bytes: <@05cf98> - <@05cfd5>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+12252 @05cf98>: 2b 18 93 05                load.m64 <@059318> ;arrFixedNoInit
	<.main+12256 @05cf9c>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12265 @05cfa5>: 67                         ceq.i64
	<.main+12266 @05cfa6>: 06 08 00 00                jz <.main+12274 @05cfae>
	<.main+12270 @05cfaa>: 04 2b 00 00                jmp <.main+12313 @05cfd5>
	<.main+12274 @05cfae>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12279 @05cfb3>: 1c 65 00 00 00             load.c32 101
	<.main+12284 @05cfb8>: 1c fe ff ff ff             load.c32 -2
	<.main+12289 @05cfbd>: 1c 80 00 00 00             load.c32 128
	<.main+12294 @05cfc2>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12299 @05cfc7>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12304 @05cfcc>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12309 @05cfd1>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@05cfd5> - <@05cfee>): assertEq(void(7, arrFixedNoInit.length));
	<.main+12313 @05cfd5>: 1c 07 00 00 00             load.c32 7
	<.main+12318 @05cfda>: 1c 07 00 00 00             load.c32 7
	<.main+12323 @05cfdf>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12328 @05cfe4>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12333 @05cfe9>: 02                         call
	<.main+12334 @05cfea>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (24 bytes: <@05cfee> - <@05d006>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+12338 @05cfee>: 1c 07 00 00 00             load.c32 7
	<.main+12343 @05cff3>: 2a 7c 93 05                load.m32 <@05937c> ;arrSliceInitFixed+4
	<.main+12347 @05cff7>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12352 @05cffc>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12357 @05d001>: 02                         call
	<.main+12358 @05d002>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (24 bytes: <@05d006> - <@05d01e>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+12362 @05d006>: 1c 07 00 00 00             load.c32 7
	<.main+12367 @05d00b>: 2a 8c 93 05                load.m32 <@05938c> ;arrSliceInitSlice+4
	<.main+12371 @05d00f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12376 @05d014>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12381 @05d019>: 02                         call
	<.main+12382 @05d01a>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@05d01e> - <@05d03e>): assertEq(void(0, lenSlice(null)));
	<.main+12386 @05d01e>: 19                         load.z32
	<.main+12387 @05d01f>: 1a                         load.z64
	<.main+12388 @05d020>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12393 @05d025>: 1f b0 93 05 00             load.ref <@0593b0> ;lenSlice(values: int64[]): int32
	<.main+12398 @05d02a>: 02                         call
	<.main+12399 @05d02b>: 09 f8 ff ff                inc.sp(-8)
	<.main+12403 @05d02f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12408 @05d034>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12413 @05d039>: 02                         call
	<.main+12414 @05d03a>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (31 bytes: <@05d03e> - <@05d05d>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+12418 @05d03e>: 19                         load.z32
	<.main+12419 @05d03f>: 19                         load.z32
	<.main+12420 @05d040>: 2b 68 93 05                load.m64 <@059368> ;arrSliceInitNull
	<.main+12424 @05d044>: 1f b0 93 05 00             load.ref <@0593b0> ;lenSlice(values: int64[]): int32
	<.main+12429 @05d049>: 02                         call
	<.main+12430 @05d04a>: 09 f8 ff ff                inc.sp(-8)
	<.main+12434 @05d04e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12439 @05d053>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12444 @05d058>: 02                         call
	<.main+12445 @05d059>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (41 bytes: <@05d05d> - <@05d086>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+12449 @05d05d>: 1c 07 00 00 00             load.c32 7
	<.main+12454 @05d062>: 19                         load.z32
	<.main+12455 @05d063>: 1c 07 00 00 00             load.c32 7
	<.main+12460 @05d068>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+12465 @05d06d>: 1f b0 93 05 00             load.ref <@0593b0> ;lenSlice(values: int64[]): int32
	<.main+12470 @05d072>: 02                         call
	<.main+12471 @05d073>: 09 f8 ff ff                inc.sp(-8)
	<.main+12475 @05d077>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12480 @05d07c>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12485 @05d081>: 02                         call
	<.main+12486 @05d082>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (35 bytes: <@05d086> - <@05d0a9>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+12490 @05d086>: 1c 07 00 00 00             load.c32 7
	<.main+12495 @05d08b>: 19                         load.z32
	<.main+12496 @05d08c>: 2b 78 93 05                load.m64 <@059378> ;arrSliceInitFixed
	<.main+12500 @05d090>: 1f b0 93 05 00             load.ref <@0593b0> ;lenSlice(values: int64[]): int32
	<.main+12505 @05d095>: 02                         call
	<.main+12506 @05d096>: 09 f8 ff ff                inc.sp(-8)
	<.main+12510 @05d09a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12515 @05d09f>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12520 @05d0a4>: 02                         call
	<.main+12521 @05d0a5>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (35 bytes: <@05d0a9> - <@05d0cc>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+12525 @05d0a9>: 1c 07 00 00 00             load.c32 7
	<.main+12530 @05d0ae>: 19                         load.z32
	<.main+12531 @05d0af>: 2b 88 93 05                load.m64 <@059388> ;arrSliceInitSlice
	<.main+12535 @05d0b3>: 1f b0 93 05 00             load.ref <@0593b0> ;lenSlice(values: int64[]): int32
	<.main+12540 @05d0b8>: 02                         call
	<.main+12541 @05d0b9>: 09 f8 ff ff                inc.sp(-8)
	<.main+12545 @05d0bd>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12550 @05d0c2>: 1f 70 75 05 00             load.ref <@057570> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12555 @05d0c7>: 02                         call
	<.main+12556 @05d0c8>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (827 bytes: <@05d0cc> - <@05d407>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+12560 @05d0cc>: 19                         load.z32
	<.main+12561 @05d0cd>: 04 2a 03 00                jmp <.main+13371 @05d3f7>
	test/lang/array.ci:119: (9 bytes: <@05d0d1> - <@05d0da>): expected: int64 := int32(42 + i)
	<.main+12565 @05d0d1>: 1c 2a 00 00 00             load.c32 42
	<.main+12570 @05d0d6>: 10 01                      dup.x32 sp(1)
	<.main+12572 @05d0d8>: 51                         add.i32
	<.main+12573 @05d0d9>: 5b                         i32.2i64
	test/lang/array.ci:120: (62 bytes: <@05d0da> - <@05d118>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+12574 @05d0da>: 11 00                      dup.x64 sp(0)
	<.main+12576 @05d0dc>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+12581 @05d0e1>: 10 05                      dup.x32 sp(5)
	<.main+12583 @05d0e3>: 0d 08 00 00                mad.u32 8
	<.main+12587 @05d0e7>: 23                         load.i64
	<.main+12588 @05d0e8>: 67                         ceq.i64
	<.main+12589 @05d0e9>: 06 08 00 00                jz <.main+12597 @05d0f1>
	<.main+12593 @05d0ed>: 04 2b 00 00                jmp <.main+12636 @05d118>
	<.main+12597 @05d0f1>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12602 @05d0f6>: 1c 78 00 00 00             load.c32 120
	<.main+12607 @05d0fb>: 1c fe ff ff ff             load.c32 -2
	<.main+12612 @05d100>: 1c 80 00 00 00             load.c32 128
	<.main+12617 @05d105>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12622 @05d10a>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12627 @05d10f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12632 @05d114>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (61 bytes: <@05d118> - <@05d155>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+12636 @05d118>: 11 00                      dup.x64 sp(0)
	<.main+12638 @05d11a>: 2a 70 93 05                load.m32 <@059370> ;arrArrayInitFixed
	<.main+12642 @05d11e>: 10 05                      dup.x32 sp(5)
	<.main+12644 @05d120>: 0d 08 00 00                mad.u32 8
	<.main+12648 @05d124>: 23                         load.i64
	<.main+12649 @05d125>: 67                         ceq.i64
	<.main+12650 @05d126>: 06 08 00 00                jz <.main+12658 @05d12e>
	<.main+12654 @05d12a>: 04 2b 00 00                jmp <.main+12697 @05d155>
	<.main+12658 @05d12e>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12663 @05d133>: 1c 79 00 00 00             load.c32 121
	<.main+12668 @05d138>: 1c fe ff ff ff             load.c32 -2
	<.main+12673 @05d13d>: 1c 80 00 00 00             load.c32 128
	<.main+12678 @05d142>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12683 @05d147>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12688 @05d14c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12693 @05d151>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (61 bytes: <@05d155> - <@05d192>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+12697 @05d155>: 11 00                      dup.x64 sp(0)
	<.main+12699 @05d157>: 2a 78 93 05                load.m32 <@059378> ;arrSliceInitFixed
	<.main+12703 @05d15b>: 10 05                      dup.x32 sp(5)
	<.main+12705 @05d15d>: 0d 08 00 00                mad.u32 8
	<.main+12709 @05d161>: 23                         load.i64
	<.main+12710 @05d162>: 67                         ceq.i64
	<.main+12711 @05d163>: 06 08 00 00                jz <.main+12719 @05d16b>
	<.main+12715 @05d167>: 04 2b 00 00                jmp <.main+12758 @05d192>
	<.main+12719 @05d16b>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12724 @05d170>: 1c 7a 00 00 00             load.c32 122
	<.main+12729 @05d175>: 1c fe ff ff ff             load.c32 -2
	<.main+12734 @05d17a>: 1c 80 00 00 00             load.c32 128
	<.main+12739 @05d17f>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12744 @05d184>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12749 @05d189>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12754 @05d18e>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (68 bytes: <@05d192> - <@05d1d6>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+12758 @05d192>: 11 00                      dup.x64 sp(0)
	<.main+12760 @05d194>: 1a                         load.z64
	<.main+12761 @05d195>: 10 06                      dup.x32 sp(6)
	<.main+12763 @05d197>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+12768 @05d19c>: 1f b8 93 05 00             load.ref <@0593b8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12773 @05d1a1>: 02                         call
	<.main+12774 @05d1a2>: 09 f8 ff ff                inc.sp(-8)
	<.main+12778 @05d1a6>: 67                         ceq.i64
	<.main+12779 @05d1a7>: 06 08 00 00                jz <.main+12787 @05d1af>
	<.main+12783 @05d1ab>: 04 2b 00 00                jmp <.main+12826 @05d1d6>
	<.main+12787 @05d1af>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12792 @05d1b4>: 1c 7c 00 00 00             load.c32 124
	<.main+12797 @05d1b9>: 1c fe ff ff ff             load.c32 -2
	<.main+12802 @05d1be>: 1c 80 00 00 00             load.c32 128
	<.main+12807 @05d1c3>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12812 @05d1c8>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12817 @05d1cd>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12822 @05d1d2>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (67 bytes: <@05d1d6> - <@05d219>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+12826 @05d1d6>: 11 00                      dup.x64 sp(0)
	<.main+12828 @05d1d8>: 1a                         load.z64
	<.main+12829 @05d1d9>: 10 06                      dup.x32 sp(6)
	<.main+12831 @05d1db>: 2a 70 93 05                load.m32 <@059370> ;arrArrayInitFixed
	<.main+12835 @05d1df>: 1f b8 93 05 00             load.ref <@0593b8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12840 @05d1e4>: 02                         call
	<.main+12841 @05d1e5>: 09 f8 ff ff                inc.sp(-8)
	<.main+12845 @05d1e9>: 67                         ceq.i64
	<.main+12846 @05d1ea>: 06 08 00 00                jz <.main+12854 @05d1f2>
	<.main+12850 @05d1ee>: 04 2b 00 00                jmp <.main+12893 @05d219>
	<.main+12854 @05d1f2>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12859 @05d1f7>: 1c 7d 00 00 00             load.c32 125
	<.main+12864 @05d1fc>: 1c fe ff ff ff             load.c32 -2
	<.main+12869 @05d201>: 1c 80 00 00 00             load.c32 128
	<.main+12874 @05d206>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12879 @05d20b>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12884 @05d210>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12889 @05d215>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (67 bytes: <@05d219> - <@05d25c>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+12893 @05d219>: 11 00                      dup.x64 sp(0)
	<.main+12895 @05d21b>: 1a                         load.z64
	<.main+12896 @05d21c>: 10 06                      dup.x32 sp(6)
	<.main+12898 @05d21e>: 2a 78 93 05                load.m32 <@059378> ;arrSliceInitFixed
	<.main+12902 @05d222>: 1f b8 93 05 00             load.ref <@0593b8> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12907 @05d227>: 02                         call
	<.main+12908 @05d228>: 09 f8 ff ff                inc.sp(-8)
	<.main+12912 @05d22c>: 67                         ceq.i64
	<.main+12913 @05d22d>: 06 08 00 00                jz <.main+12921 @05d235>
	<.main+12917 @05d231>: 04 2b 00 00                jmp <.main+12960 @05d25c>
	<.main+12921 @05d235>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12926 @05d23a>: 1c 7e 00 00 00             load.c32 126
	<.main+12931 @05d23f>: 1c fe ff ff ff             load.c32 -2
	<.main+12936 @05d244>: 1c 80 00 00 00             load.c32 128
	<.main+12941 @05d249>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+12946 @05d24e>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12951 @05d253>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12956 @05d258>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (68 bytes: <@05d25c> - <@05d2a0>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+12960 @05d25c>: 11 00                      dup.x64 sp(0)
	<.main+12962 @05d25e>: 1a                         load.z64
	<.main+12963 @05d25f>: 10 06                      dup.x32 sp(6)
	<.main+12965 @05d261>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+12970 @05d266>: 1f c8 93 05 00             load.ref <@0593c8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+12975 @05d26b>: 02                         call
	<.main+12976 @05d26c>: 09 f8 ff ff                inc.sp(-8)
	<.main+12980 @05d270>: 67                         ceq.i64
	<.main+12981 @05d271>: 06 08 00 00                jz <.main+12989 @05d279>
	<.main+12985 @05d275>: 04 2b 00 00                jmp <.main+13028 @05d2a0>
	<.main+12989 @05d279>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+12994 @05d27e>: 1c 80 00 00 00             load.c32 128
	<.main+12999 @05d283>: 1c fe ff ff ff             load.c32 -2
	<.main+13004 @05d288>: 1c 80 00 00 00             load.c32 128
	<.main+13009 @05d28d>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13014 @05d292>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13019 @05d297>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13024 @05d29c>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (67 bytes: <@05d2a0> - <@05d2e3>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+13028 @05d2a0>: 11 00                      dup.x64 sp(0)
	<.main+13030 @05d2a2>: 1a                         load.z64
	<.main+13031 @05d2a3>: 10 06                      dup.x32 sp(6)
	<.main+13033 @05d2a5>: 2a 70 93 05                load.m32 <@059370> ;arrArrayInitFixed
	<.main+13037 @05d2a9>: 1f c8 93 05 00             load.ref <@0593c8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13042 @05d2ae>: 02                         call
	<.main+13043 @05d2af>: 09 f8 ff ff                inc.sp(-8)
	<.main+13047 @05d2b3>: 67                         ceq.i64
	<.main+13048 @05d2b4>: 06 08 00 00                jz <.main+13056 @05d2bc>
	<.main+13052 @05d2b8>: 04 2b 00 00                jmp <.main+13095 @05d2e3>
	<.main+13056 @05d2bc>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+13061 @05d2c1>: 1c 81 00 00 00             load.c32 129
	<.main+13066 @05d2c6>: 1c fe ff ff ff             load.c32 -2
	<.main+13071 @05d2cb>: 1c 80 00 00 00             load.c32 128
	<.main+13076 @05d2d0>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13081 @05d2d5>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13086 @05d2da>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13091 @05d2df>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (67 bytes: <@05d2e3> - <@05d326>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+13095 @05d2e3>: 11 00                      dup.x64 sp(0)
	<.main+13097 @05d2e5>: 1a                         load.z64
	<.main+13098 @05d2e6>: 10 06                      dup.x32 sp(6)
	<.main+13100 @05d2e8>: 2a 78 93 05                load.m32 <@059378> ;arrSliceInitFixed
	<.main+13104 @05d2ec>: 1f c8 93 05 00             load.ref <@0593c8> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13109 @05d2f1>: 02                         call
	<.main+13110 @05d2f2>: 09 f8 ff ff                inc.sp(-8)
	<.main+13114 @05d2f6>: 67                         ceq.i64
	<.main+13115 @05d2f7>: 06 08 00 00                jz <.main+13123 @05d2ff>
	<.main+13119 @05d2fb>: 04 2b 00 00                jmp <.main+13162 @05d326>
	<.main+13123 @05d2ff>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+13128 @05d304>: 1c 82 00 00 00             load.c32 130
	<.main+13133 @05d309>: 1c fe ff ff ff             load.c32 -2
	<.main+13138 @05d30e>: 1c 80 00 00 00             load.c32 128
	<.main+13143 @05d313>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13148 @05d318>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13153 @05d31d>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13158 @05d322>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (73 bytes: <@05d326> - <@05d36f>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+13162 @05d326>: 11 00                      dup.x64 sp(0)
	<.main+13164 @05d328>: 1a                         load.z64
	<.main+13165 @05d329>: 10 06                      dup.x32 sp(6)
	<.main+13167 @05d32b>: 1c 07 00 00 00             load.c32 7
	<.main+13172 @05d330>: 1f 18 93 05 00             load.ref <@059318> ;arrFixedNoInit
	<.main+13177 @05d335>: 1f d8 93 05 00             load.ref <@0593d8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13182 @05d33a>: 02                         call
	<.main+13183 @05d33b>: 09 f4 ff ff                inc.sp(-12)
	<.main+13187 @05d33f>: 67                         ceq.i64
	<.main+13188 @05d340>: 06 08 00 00                jz <.main+13196 @05d348>
	<.main+13192 @05d344>: 04 2b 00 00                jmp <.main+13235 @05d36f>
	<.main+13196 @05d348>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+13201 @05d34d>: 1c 84 00 00 00             load.c32 132
	<.main+13206 @05d352>: 1c fe ff ff ff             load.c32 -2
	<.main+13211 @05d357>: 1c 80 00 00 00             load.c32 128
	<.main+13216 @05d35c>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13221 @05d361>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13226 @05d366>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13231 @05d36b>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (67 bytes: <@05d36f> - <@05d3b2>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+13235 @05d36f>: 11 00                      dup.x64 sp(0)
	<.main+13237 @05d371>: 1a                         load.z64
	<.main+13238 @05d372>: 10 06                      dup.x32 sp(6)
	<.main+13240 @05d374>: 2b 78 93 05                load.m64 <@059378> ;arrSliceInitFixed
	<.main+13244 @05d378>: 1f d8 93 05 00             load.ref <@0593d8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13249 @05d37d>: 02                         call
	<.main+13250 @05d37e>: 09 f4 ff ff                inc.sp(-12)
	<.main+13254 @05d382>: 67                         ceq.i64
	<.main+13255 @05d383>: 06 08 00 00                jz <.main+13263 @05d38b>
	<.main+13259 @05d387>: 04 2b 00 00                jmp <.main+13302 @05d3b2>
	<.main+13263 @05d38b>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+13268 @05d390>: 1c 86 00 00 00             load.c32 134
	<.main+13273 @05d395>: 1c fe ff ff ff             load.c32 -2
	<.main+13278 @05d39a>: 1c 80 00 00 00             load.c32 128
	<.main+13283 @05d39f>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13288 @05d3a4>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13293 @05d3a9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13298 @05d3ae>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (61 bytes: <@05d3b2> - <@05d3ef>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+13302 @05d3b2>: 11 00                      dup.x64 sp(0)
	<.main+13304 @05d3b4>: 2a 88 93 05                load.m32 <@059388> ;arrSliceInitSlice
	<.main+13308 @05d3b8>: 10 05                      dup.x32 sp(5)
	<.main+13310 @05d3ba>: 0d 08 00 00                mad.u32 8
	<.main+13314 @05d3be>: 23                         load.i64
	<.main+13315 @05d3bf>: 67                         ceq.i64
	<.main+13316 @05d3c0>: 06 08 00 00                jz <.main+13324 @05d3c8>
	<.main+13320 @05d3c4>: 04 2b 00 00                jmp <.main+13363 @05d3ef>
	<.main+13324 @05d3c8>: 1f 90 37 04 00             load.ref <@043790> ;"test/lang/array.ci"
	<.main+13329 @05d3cd>: 1c 88 00 00 00             load.c32 136
	<.main+13334 @05d3d2>: 1c fe ff ff ff             load.c32 -2
	<.main+13339 @05d3d7>: 1c 80 00 00 00             load.c32 128
	<.main+13344 @05d3dc>: 1f cc d7 00 00             load.ref <@00d7cc> ;"assertion failed!"
	<.main+13349 @05d3e1>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13354 @05d3e6>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13359 @05d3eb>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13363 @05d3ef>: 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@05d3f3> - <@05d3f7>): int32(i := int32(i + 1))
	<.main+13367 @05d3f3>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@05d3f7> - <@05d403>): bool(i < arrFixedNoInit.length)
	<.main+13371 @05d3f7>: 10 00                      dup.x32 sp(0)
	<.main+13373 @05d3f9>: 1c 07 00 00 00             load.c32 7
	<.main+13378 @05d3fe>: 58                         clt.i32
	<.main+13379 @05d3ff>: 05 d2 fc ff                jnz <.main+12565 @05d0d1>
	<.main+13383 @05d403>: 09 fc ff ff                inc.sp(-4)
	test/lang/method.ci:78: (21 bytes: <@05d407> - <@05d41c>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+13387 @05d407>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13391 @05d40b>: 1c 01 00 00 00             load.c32 1
	<.main+13396 @05d410>: 13 04                      set.x32 sp(4)
	<.main+13398 @05d412>: 1f 38 94 05 00             load.ref <@059438> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13403 @05d417>: 02                         call
	<.main+13404 @05d418>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (20 bytes: <@05d41c> - <@05d430>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+13408 @05d41c>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13412 @05d420>: 1c 01 00 00 00             load.c32 1
	<.main+13417 @05d425>: 13 04                      set.x32 sp(4)
	<.main+13419 @05d427>: 2a e8 94 05                load.m32 <@0594e8> ;recordMethodTest+8
	<.main+13423 @05d42b>: 02                         call
	<.main+13424 @05d42c>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (19 bytes: <@05d430> - <@05d443>): staticMethod(void(recordMethodTest, 2));
	<.main+13428 @05d430>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13432 @05d434>: 1c 02 00 00 00             load.c32 2
	<.main+13437 @05d439>: 1f f0 94 05 00             load.ref <@0594f0> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13442 @05d43e>: 02                         call
	<.main+13443 @05d43f>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (19 bytes: <@05d443> - <@05d456>): virtualMethod(void(recordMethodTest, 2));
	<.main+13447 @05d443>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13451 @05d447>: 1c 02 00 00 00             load.c32 2
	<.main+13456 @05d44c>: 1f 38 95 05 00             load.ref <@059538> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13461 @05d451>: 02                         call
	<.main+13462 @05d452>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (21 bytes: <@05d456> - <@05d46b>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+13466 @05d456>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13470 @05d45a>: 1c 03 00 00 00             load.c32 3
	<.main+13475 @05d45f>: 13 04                      set.x32 sp(4)
	<.main+13477 @05d461>: 1f 38 94 05 00             load.ref <@059438> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13482 @05d466>: 02                         call
	<.main+13483 @05d467>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (21 bytes: <@05d46b> - <@05d480>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13487 @05d46b>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13491 @05d46f>: 1c 03 00 00 00             load.c32 3
	<.main+13496 @05d474>: 13 04                      set.x32 sp(4)
	<.main+13498 @05d476>: 1f 68 94 05 00             load.ref <@059468> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13503 @05d47b>: 02                         call
	<.main+13504 @05d47c>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (20 bytes: <@05d480> - <@05d494>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13508 @05d480>: 2c e0 94 05                load.m128 <@0594e0> ;recordMethodTest
	<.main+13512 @05d484>: 1c 03 00 00 00             load.c32 3
	<.main+13517 @05d489>: 13 04                      set.x32 sp(4)
	<.main+13519 @05d48b>: 2a e8 94 05                load.m32 <@0594e8> ;recordMethodTest+8
	<.main+13523 @05d48f>: 02                         call
	<.main+13524 @05d490>: 09 f0 ff ff                inc.sp(-16)
	test/lang/statementIf.ci:4: (39 bytes: <@05d494> - <@05d4bb>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+13528 @05d494>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13533 @05d499>: 1c 04 00 00 00             load.c32 4
	<.main+13538 @05d49e>: 1c 0e 00 00 00             load.c32 14
	<.main+13543 @05d4a3>: 1c 01 00 00 00             load.c32 1
	<.main+13548 @05d4a8>: 1f f9 3c 05 00             load.ref <@053cf9> ;"0 == 0"
	<.main+13553 @05d4ad>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13558 @05d4b2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13563 @05d4b7>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@05d4bb> - <@05d4e2>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+13567 @05d4bb>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13572 @05d4c0>: 1c 0c 00 00 00             load.c32 12
	<.main+13577 @05d4c5>: 1c 0e 00 00 00             load.c32 14
	<.main+13582 @05d4ca>: 1c 03 00 00 00             load.c32 3
	<.main+13587 @05d4cf>: 1f f9 3c 05 00             load.ref <@053cf9> ;"0 == 0"
	<.main+13592 @05d4d4>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13597 @05d4d9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13602 @05d4de>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@05d4e2> - <@05d509>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+13606 @05d4e2>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13611 @05d4e7>: 1c 16 00 00 00             load.c32 22
	<.main+13616 @05d4ec>: 1c 0e 00 00 00             load.c32 14
	<.main+13621 @05d4f1>: 1c 06 00 00 00             load.c32 6
	<.main+13626 @05d4f6>: 1f f9 3c 05 00             load.ref <@053cf9> ;"0 == 0"
	<.main+13631 @05d4fb>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13636 @05d500>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13641 @05d505>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:28: (49 bytes: <@05d509> - <@05d53a>): if (bool(t == 0))
	<.main+13645 @05d509>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13649 @05d50d>: 19                         load.z32
	<.main+13650 @05d50e>: 57                         ceq.i32
	<.main+13651 @05d50f>: 06 2b 00 00                jz <.main+13694 @05d53a>
	test/lang/statementIf.ci:29: (39 bytes: <@05d513> - <@05d53a>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+13655 @05d513>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13660 @05d518>: 1c 1d 00 00 00             load.c32 29
	<.main+13665 @05d51d>: 1c 0e 00 00 00             load.c32 14
	<.main+13670 @05d522>: 1c 07 00 00 00             load.c32 7
	<.main+13675 @05d527>: 1f 07 3d 05 00             load.ref <@053d07> ;"t == 0"
	<.main+13680 @05d52c>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13685 @05d531>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13690 @05d536>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (49 bytes: <@05d53a> - <@05d56b>): if (bool(t != 0))
	<.main+13694 @05d53a>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13698 @05d53e>: 19                         load.z32
	<.main+13699 @05d53f>: 57                         ceq.i32
	<.main+13700 @05d540>: 05 2b 00 00                jnz <.main+13743 @05d56b>
	test/lang/statementIf.ci:33: (39 bytes: <@05d544> - <@05d56b>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+13704 @05d544>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13709 @05d549>: 1c 21 00 00 00             load.c32 33
	<.main+13714 @05d54e>: 1c 0e 00 00 00             load.c32 14
	<.main+13719 @05d553>: 1c 08 00 00 00             load.c32 8
	<.main+13724 @05d558>: 1f 0e 3d 05 00             load.ref <@053d0e> ;"t != 0"
	<.main+13729 @05d55d>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13734 @05d562>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13739 @05d567>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (92 bytes: <@05d56b> - <@05d5c7>): if (bool(t == 0))
	<.main+13743 @05d56b>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13747 @05d56f>: 19                         load.z32
	<.main+13748 @05d570>: 57                         ceq.i32
	<.main+13749 @05d571>: 06 2f 00 00                jz <.main+13796 @05d5a0>
	test/lang/statementIf.ci:37: (39 bytes: <@05d575> - <@05d59c>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13753 @05d575>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13758 @05d57a>: 1c 25 00 00 00             load.c32 37
	<.main+13763 @05d57f>: 1c 0e 00 00 00             load.c32 14
	<.main+13768 @05d584>: 1c 09 00 00 00             load.c32 9
	<.main+13773 @05d589>: 1f 07 3d 05 00             load.ref <@053d07> ;"t == 0"
	<.main+13778 @05d58e>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13783 @05d593>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13788 @05d598>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13792 @05d59c>: 04 2b 00 00                jmp <.main+13835 @05d5c7>
	test/lang/statementIf.ci:40: (39 bytes: <@05d5a0> - <@05d5c7>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+13796 @05d5a0>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13801 @05d5a5>: 1c 28 00 00 00             load.c32 40
	<.main+13806 @05d5aa>: 1c 0e 00 00 00             load.c32 14
	<.main+13811 @05d5af>: 1c 0a 00 00 00             load.c32 10
	<.main+13816 @05d5b4>: 1f 0e 3d 05 00             load.ref <@053d0e> ;"t != 0"
	<.main+13821 @05d5b9>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13826 @05d5be>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13831 @05d5c3>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (92 bytes: <@05d5c7> - <@05d623>): if (bool(t != 0))
	<.main+13835 @05d5c7>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13839 @05d5cb>: 19                         load.z32
	<.main+13840 @05d5cc>: 57                         ceq.i32
	<.main+13841 @05d5cd>: 05 2f 00 00                jnz <.main+13888 @05d5fc>
	test/lang/statementIf.ci:44: (39 bytes: <@05d5d1> - <@05d5f8>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+13845 @05d5d1>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13850 @05d5d6>: 1c 2c 00 00 00             load.c32 44
	<.main+13855 @05d5db>: 1c 0e 00 00 00             load.c32 14
	<.main+13860 @05d5e0>: 1c 0b 00 00 00             load.c32 11
	<.main+13865 @05d5e5>: 1f 0e 3d 05 00             load.ref <@053d0e> ;"t != 0"
	<.main+13870 @05d5ea>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13875 @05d5ef>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13880 @05d5f4>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13884 @05d5f8>: 04 2b 00 00                jmp <.main+13927 @05d623>
	test/lang/statementIf.ci:47: (39 bytes: <@05d5fc> - <@05d623>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+13888 @05d5fc>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13893 @05d601>: 1c 2f 00 00 00             load.c32 47
	<.main+13898 @05d606>: 1c 0e 00 00 00             load.c32 14
	<.main+13903 @05d60b>: 1c 0c 00 00 00             load.c32 12
	<.main+13908 @05d610>: 1f 07 3d 05 00             load.ref <@053d07> ;"t == 0"
	<.main+13913 @05d615>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13918 @05d61a>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13923 @05d61f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (377 bytes: <@05d623> - <@05d79c>): if (bool(t == 0))
	<.main+13927 @05d623>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13931 @05d627>: 19                         load.z32
	<.main+13932 @05d628>: 57                         ceq.i32
	<.main+13933 @05d629>: 06 2f 00 00                jz <.main+13980 @05d658>
	test/lang/statementIf.ci:51: (39 bytes: <@05d62d> - <@05d654>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13937 @05d62d>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13942 @05d632>: 1c 33 00 00 00             load.c32 51
	<.main+13947 @05d637>: 1c 0e 00 00 00             load.c32 14
	<.main+13952 @05d63c>: 1c 09 00 00 00             load.c32 9
	<.main+13957 @05d641>: 1f 07 3d 05 00             load.ref <@053d07> ;"t == 0"
	<.main+13962 @05d646>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13967 @05d64b>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+13972 @05d650>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13976 @05d654>: 04 48 01 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:53: (324 bytes: <@05d658> - <@05d79c>): if (bool(t == 1))
	<.main+13980 @05d658>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+13984 @05d65c>: 1c 01 00 00 00             load.c32 1
	<.main+13989 @05d661>: 57                         ceq.i32
	<.main+13990 @05d662>: 06 2f 00 00                jz <.main+14037 @05d691>
	test/lang/statementIf.ci:54: (39 bytes: <@05d666> - <@05d68d>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+13994 @05d666>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+13999 @05d66b>: 1c 36 00 00 00             load.c32 54
	<.main+14004 @05d670>: 1c 0e 00 00 00             load.c32 14
	<.main+14009 @05d675>: 1c 0a 00 00 00             load.c32 10
	<.main+14014 @05d67a>: 1f 15 3d 05 00             load.ref <@053d15> ;"t == 1"
	<.main+14019 @05d67f>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14024 @05d684>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14029 @05d689>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14033 @05d68d>: 04 0f 01 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:56: (267 bytes: <@05d691> - <@05d79c>): if (bool(t == 2))
	<.main+14037 @05d691>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+14041 @05d695>: 1c 02 00 00 00             load.c32 2
	<.main+14046 @05d69a>: 57                         ceq.i32
	<.main+14047 @05d69b>: 06 2f 00 00                jz <.main+14094 @05d6ca>
	test/lang/statementIf.ci:57: (39 bytes: <@05d69f> - <@05d6c6>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+14051 @05d69f>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+14056 @05d6a4>: 1c 39 00 00 00             load.c32 57
	<.main+14061 @05d6a9>: 1c 0e 00 00 00             load.c32 14
	<.main+14066 @05d6ae>: 1c 0a 00 00 00             load.c32 10
	<.main+14071 @05d6b3>: 1f 1c 3d 05 00             load.ref <@053d1c> ;"t == 2"
	<.main+14076 @05d6b8>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14081 @05d6bd>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14086 @05d6c2>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14090 @05d6c6>: 04 d6 00 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:59: (210 bytes: <@05d6ca> - <@05d79c>): if (bool(t == 3))
	<.main+14094 @05d6ca>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+14098 @05d6ce>: 1c 03 00 00 00             load.c32 3
	<.main+14103 @05d6d3>: 57                         ceq.i32
	<.main+14104 @05d6d4>: 06 2f 00 00                jz <.main+14151 @05d703>
	test/lang/statementIf.ci:60: (39 bytes: <@05d6d8> - <@05d6ff>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+14108 @05d6d8>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+14113 @05d6dd>: 1c 3c 00 00 00             load.c32 60
	<.main+14118 @05d6e2>: 1c 0e 00 00 00             load.c32 14
	<.main+14123 @05d6e7>: 1c 0a 00 00 00             load.c32 10
	<.main+14128 @05d6ec>: 1f 23 3d 05 00             load.ref <@053d23> ;"t == 3"
	<.main+14133 @05d6f1>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14138 @05d6f6>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14143 @05d6fb>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14147 @05d6ff>: 04 9d 00 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:62: (153 bytes: <@05d703> - <@05d79c>): if (bool(t == 4))
	<.main+14151 @05d703>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+14155 @05d707>: 1c 04 00 00 00             load.c32 4
	<.main+14160 @05d70c>: 57                         ceq.i32
	<.main+14161 @05d70d>: 06 2f 00 00                jz <.main+14208 @05d73c>
	test/lang/statementIf.ci:63: (39 bytes: <@05d711> - <@05d738>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+14165 @05d711>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+14170 @05d716>: 1c 3f 00 00 00             load.c32 63
	<.main+14175 @05d71b>: 1c 0e 00 00 00             load.c32 14
	<.main+14180 @05d720>: 1c 0a 00 00 00             load.c32 10
	<.main+14185 @05d725>: 1f 2a 3d 05 00             load.ref <@053d2a> ;"t == 4"
	<.main+14190 @05d72a>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14195 @05d72f>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14200 @05d734>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14204 @05d738>: 04 64 00 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:65: (96 bytes: <@05d73c> - <@05d79c>): if (bool(t == 5))
	<.main+14208 @05d73c>: 2a 58 9d 05                load.m32 <@059d58> ;t
	<.main+14212 @05d740>: 1c 05 00 00 00             load.c32 5
	<.main+14217 @05d745>: 57                         ceq.i32
	<.main+14218 @05d746>: 06 2f 00 00                jz <.main+14265 @05d775>
	test/lang/statementIf.ci:66: (39 bytes: <@05d74a> - <@05d771>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+14222 @05d74a>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+14227 @05d74f>: 1c 42 00 00 00             load.c32 66
	<.main+14232 @05d754>: 1c 0e 00 00 00             load.c32 14
	<.main+14237 @05d759>: 1c 0a 00 00 00             load.c32 10
	<.main+14242 @05d75e>: 1f 31 3d 05 00             load.ref <@053d31> ;"t == 5"
	<.main+14247 @05d763>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14252 @05d768>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14257 @05d76d>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14261 @05d771>: 04 2b 00 00                jmp <.main+14304 @05d79c>
	test/lang/statementIf.ci:69: (39 bytes: <@05d775> - <@05d79c>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+14265 @05d775>: 1f e0 3c 05 00             load.ref <@053ce0> ;"test/lang/statementIf.ci"
	<.main+14270 @05d77a>: 1c 45 00 00 00             load.c32 69
	<.main+14275 @05d77f>: 1c 0e 00 00 00             load.c32 14
	<.main+14280 @05d784>: 1c 0a 00 00 00             load.c32 10
	<.main+14285 @05d789>: 1f 38 3d 05 00             load.ref <@053d38> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14290 @05d78e>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14295 @05d793>: 1f 58 9d 05 00             load.ref <@059d58> ;t
	<.main+14300 @05d798>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@05d79c> - <@05d7cb>): for ( ; ; )
	<.main+14304 @05d79c>: 04 2b 00 00                jmp <.main+14347 @05d7c7>
	test/lang/statementFor.ci:4: (35 bytes: <@05d7a0> - <@05d7c3>): debug("for ( ; ; )");
	<.main+14308 @05d7a0>: 1f 20 3e 05 00             load.ref <@053e20> ;"test/lang/statementFor.ci"
	<.main+14313 @05d7a5>: 1c 04 00 00 00             load.c32 4
	<.main+14318 @05d7aa>: 1c 0e 00 00 00             load.c32 14
	<.main+14323 @05d7af>: 19                         load.z32
	<.main+14324 @05d7b0>: 1f 3a 3e 05 00             load.ref <@053e3a> ;"for ( ; ; )"
	<.main+14329 @05d7b5>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14334 @05d7ba>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14339 @05d7bf>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@05d7c3> - <@05d7c7>): break;
	<.main+14343 @05d7c3>: 04 08 00 00                jmp <.main+14351 @05d7cb>
	:: (4 bytes: <@05d7c7> - <@05d7cb>)
	<.main+14347 @05d7c7>: 04 d9 ff ff                jmp <.main+14308 @05d7a0>
	test/lang/statementFor.ci:8: (59 bytes: <@05d7cb> - <@05d806>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+14351 @05d7cb>: 19                         load.z32
	<.main+14352 @05d7cc>: 04 2a 00 00                jmp <.main+14394 @05d7f6>
	test/lang/statementFor.ci:9: (34 bytes: <@05d7d0> - <@05d7f2>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+14356 @05d7d0>: 1f 20 3e 05 00             load.ref <@053e20> ;"test/lang/statementFor.ci"
	<.main+14361 @05d7d5>: 1c 09 00 00 00             load.c32 9
	<.main+14366 @05d7da>: 1c 0e 00 00 00             load.c32 14
	<.main+14371 @05d7df>: 19                         load.z32
	<.main+14372 @05d7e0>: 1f 46 3e 05 00             load.ref <@053e46> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14377 @05d7e5>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14382 @05d7ea>: 0a 18 00 00                load.sp(+24)
	<.main+14386 @05d7ee>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@05d7f2> - <@05d7f6>): int32(i := int32(i + 1))
	<.main+14390 @05d7f2>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@05d7f6> - <@05d802>): bool(i < 2)
	<.main+14394 @05d7f6>: 10 00                      dup.x32 sp(0)
	<.main+14396 @05d7f8>: 1c 02 00 00 00             load.c32 2
	<.main+14401 @05d7fd>: 58                         clt.i32
	<.main+14402 @05d7fe>: 05 d2 ff ff                jnz <.main+14356 @05d7d0>
	<.main+14406 @05d802>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:13: (70 bytes: <@05d806> - <@05d84c>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+14410 @05d806>: 19                         load.z32
	<.main+14411 @05d807>: 2e 60 9d 05                store.m32 <@059d60> ;forIdx
	<.main+14415 @05d80b>: 04 33 00 00                jmp <.main+14466 @05d83e>
	test/lang/statementFor.ci:14: (35 bytes: <@05d80f> - <@05d832>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+14419 @05d80f>: 1f 20 3e 05 00             load.ref <@053e20> ;"test/lang/statementFor.ci"
	<.main+14424 @05d814>: 1c 0e 00 00 00             load.c32 14
	<.main+14429 @05d819>: 1c 0e 00 00 00             load.c32 14
	<.main+14434 @05d81e>: 19                         load.z32
	<.main+14435 @05d81f>: 1f 6c 3e 05 00             load.ref <@053e6c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14440 @05d824>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14445 @05d829>: 1f 60 9d 05 00             load.ref <@059d60> ;forIdx
	<.main+14450 @05d82e>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (12 bytes: <@05d832> - <@05d83e>): int32(forIdx := int32(forIdx + 1))
	<.main+14454 @05d832>: 2a 60 9d 05                load.m32 <@059d60> ;forIdx
	<.main+14458 @05d836>: 0c 01 00 00                inc.i32(+1)
	<.main+14462 @05d83a>: 2e 60 9d 05                store.m32 <@059d60> ;forIdx
	test/lang/statementFor.ci:13: (14 bytes: <@05d83e> - <@05d84c>): bool(forIdx < 2)
	<.main+14466 @05d83e>: 2a 60 9d 05                load.m32 <@059d60> ;forIdx
	<.main+14470 @05d842>: 1c 02 00 00 00             load.c32 2
	<.main+14475 @05d847>: 58                         clt.i32
	<.main+14476 @05d848>: 05 c7 ff ff                jnz <.main+14419 @05d80f>
	test/lang/statementFor.ci:17: (75 bytes: <@05d84c> - <@05d897>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14480 @05d84c>: 19                         load.z32
	<.main+14481 @05d84d>: 04 3a 00 00                jmp <.main+14539 @05d887>
	test/lang/statementFor.ci:18: (16 bytes: <@05d851> - <@05d861>): if (bool(i < 2))
	<.main+14485 @05d851>: 10 00                      dup.x32 sp(0)
	<.main+14487 @05d853>: 1c 02 00 00 00             load.c32 2
	<.main+14492 @05d858>: 58                         clt.i32
	<.main+14493 @05d859>: 06 08 00 00                jz <.main+14501 @05d861>
	test/lang/statementFor.ci:19: (4 bytes: <@05d85d> - <@05d861>): continue;
	<.main+14497 @05d85d>: 04 26 00 00                jmp <.main+14535 @05d883>
	test/lang/statementFor.ci:21: (34 bytes: <@05d861> - <@05d883>): debug(void("for with continue", i));
	<.main+14501 @05d861>: 1f 20 3e 05 00             load.ref <@053e20> ;"test/lang/statementFor.ci"
	<.main+14506 @05d866>: 1c 15 00 00 00             load.c32 21
	<.main+14511 @05d86b>: 1c 0e 00 00 00             load.c32 14
	<.main+14516 @05d870>: 19                         load.z32
	<.main+14517 @05d871>: 1f 96 3e 05 00             load.ref <@053e96> ;"for with continue"
	<.main+14522 @05d876>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14527 @05d87b>: 0a 18 00 00                load.sp(+24)
	<.main+14531 @05d87f>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@05d883> - <@05d887>): int32(i := int32(i + 1))
	<.main+14535 @05d883>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@05d887> - <@05d893>): bool(i < 7)
	<.main+14539 @05d887>: 10 00                      dup.x32 sp(0)
	<.main+14541 @05d889>: 1c 07 00 00 00             load.c32 7
	<.main+14546 @05d88e>: 58                         clt.i32
	<.main+14547 @05d88f>: 05 c2 ff ff                jnz <.main+14485 @05d851>
	<.main+14551 @05d893>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@05d897> - <@05d8e2>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14555 @05d897>: 19                         load.z32
	<.main+14556 @05d898>: 04 3a 00 00                jmp <.main+14614 @05d8d2>
	test/lang/statementFor.ci:25: (16 bytes: <@05d89c> - <@05d8ac>): if (bool(i > 2))
	<.main+14560 @05d89c>: 10 00                      dup.x32 sp(0)
	<.main+14562 @05d89e>: 1c 02 00 00 00             load.c32 2
	<.main+14567 @05d8a3>: 59                         cgt.i32
	<.main+14568 @05d8a4>: 06 08 00 00                jz <.main+14576 @05d8ac>
	test/lang/statementFor.ci:26: (4 bytes: <@05d8a8> - <@05d8ac>): break;
	<.main+14572 @05d8a8>: 04 36 00 00                jmp <.main+14626 @05d8de>
	test/lang/statementFor.ci:28: (34 bytes: <@05d8ac> - <@05d8ce>): debug(void("for with break", i));
	<.main+14576 @05d8ac>: 1f 20 3e 05 00             load.ref <@053e20> ;"test/lang/statementFor.ci"
	<.main+14581 @05d8b1>: 1c 1c 00 00 00             load.c32 28
	<.main+14586 @05d8b6>: 1c 0e 00 00 00             load.c32 14
	<.main+14591 @05d8bb>: 19                         load.z32
	<.main+14592 @05d8bc>: 1f a8 3e 05 00             load.ref <@053ea8> ;"for with break"
	<.main+14597 @05d8c1>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14602 @05d8c6>: 0a 18 00 00                load.sp(+24)
	<.main+14606 @05d8ca>: 01 09 00 00                nfc(9) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@05d8ce> - <@05d8d2>): int32(i := int32(i + 1))
	<.main+14610 @05d8ce>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@05d8d2> - <@05d8de>): bool(i < 7)
	<.main+14614 @05d8d2>: 10 00                      dup.x32 sp(0)
	<.main+14616 @05d8d4>: 1c 07 00 00 00             load.c32 7
	<.main+14621 @05d8d9>: 58                         clt.i32
	<.main+14622 @05d8da>: 05 c2 ff ff                jnz <.main+14560 @05d89c>
	<.main+14626 @05d8de>: 09 fc ff ff                inc.sp(-4)
	<.main+14630 @05d8e2>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 346.67] > .main
[ 347.47]  > funAdd(x: int32, y: int32): int32
[ 347.49]  < return
[ 347.50]  > funAdd(x: int32, y: int32): int32
[ 347.52]  < return
[ 347.53]  > funMul(x: int32, y: int32): int32
[ 347.55]  < return
[ 347.56]  > funMul(x: int32, y: int32): int32
[ 347.58]  < return
[ 347.59]  > fib(n: uint32): uint32
[ 347.61]   > fib(n: uint32): uint32
[ 347.62]    > fib(n: uint32): uint32
[ 347.64]     > fib(n: uint32): uint32
[ 347.66]      > fib(n: uint32): uint32
[ 347.68]       > fib(n: uint32): uint32
[ 347.69]        > fib(n: uint32): uint32
[ 347.71]         > fib(n: uint32): uint32
[ 347.73]          > fib(n: uint32): uint32
[ 347.74]           > fib(n: uint32): uint32
[ 347.76]            > fib(n: uint32): uint32
[ 347.77]             > fib(n: uint32): uint32
[ 347.79]              > fib(n: uint32): uint32
[ 347.81]              < return
[ 347.82]              > fib(n: uint32): uint32
[ 347.83]              < return
[ 347.84]             < return
[ 347.85]             > fib(n: uint32): uint32
[ 347.86]             < return
[ 347.90]            < return
[ 347.91]            > fib(n: uint32): uint32
[ 347.92]             > fib(n: uint32): uint32
[ 347.95]             < return
[ 347.96]             > fib(n: uint32): uint32
[ 347.98]             < return
[ 347.99]            < return
[ 347.99]           < return
[ 348.00]           > fib(n: uint32): uint32
[ 348.02]            > fib(n: uint32): uint32
[ 348.04]             > fib(n: uint32): uint32
[ 348.05]             < return
[ 348.06]             > fib(n: uint32): uint32
[ 348.07]             < return
[ 348.08]            < return
[ 348.09]            > fib(n: uint32): uint32
[ 348.11]            < return
[ 348.12]           < return
[ 348.12]          < return
[ 348.13]          > fib(n: uint32): uint32
[ 348.15]           > fib(n: uint32): uint32
[ 348.17]            > fib(n: uint32): uint32
[ 348.18]             > fib(n: uint32): uint32
[ 348.20]             < return
[ 348.21]             > fib(n: uint32): uint32
[ 348.22]             < return
[ 348.23]            < return
[ 348.24]            > fib(n: uint32): uint32
[ 348.26]            < return
[ 348.26]           < return
[ 348.27]           > fib(n: uint32): uint32
[ 348.29]            > fib(n: uint32): uint32
[ 348.31]            < return
[ 348.32]            > fib(n: uint32): uint32
[ 348.35]            < return
[ 348.36]           < return
[ 348.37]          < return
[ 348.38]         < return
[ 348.40]         > fib(n: uint32): uint32
[ 348.42]          > fib(n: uint32): uint32
[ 348.44]           > fib(n: uint32): uint32
[ 348.45]            > fib(n: uint32): uint32
[ 348.47]             > fib(n: uint32): uint32
[ 348.48]             < return
[ 348.49]             > fib(n: uint32): uint32
[ 348.51]             < return
[ 348.52]            < return
[ 348.53]            > fib(n: uint32): uint32
[ 348.54]            < return
[ 348.55]           < return
[ 348.56]           > fib(n: uint32): uint32
[ 348.58]            > fib(n: uint32): uint32
[ 348.59]            < return
[ 348.60]            > fib(n: uint32): uint32
[ 348.62]            < return
[ 348.62]           < return
[ 348.63]          < return
[ 348.64]          > fib(n: uint32): uint32
[ 348.66]           > fib(n: uint32): uint32
[ 348.68]            > fib(n: uint32): uint32
[ 348.69]            < return
[ 348.70]            > fib(n: uint32): uint32
[ 348.71]            < return
[ 348.72]           < return
[ 348.73]           > fib(n: uint32): uint32
[ 348.75]           < return
[ 348.76]          < return
[ 348.76]         < return
[ 348.77]        < return
[ 348.78]        > fib(n: uint32): uint32
[ 348.82]         > fib(n: uint32): uint32
[ 348.84]          > fib(n: uint32): uint32
[ 348.87]           > fib(n: uint32): uint32
[ 348.89]            > fib(n: uint32): uint32
[ 348.90]             > fib(n: uint32): uint32
[ 348.92]             < return
[ 348.93]             > fib(n: uint32): uint32
[ 348.94]             < return
[ 348.95]            < return
[ 348.96]            > fib(n: uint32): uint32
[ 348.97]            < return
[ 348.98]           < return
[ 348.99]           > fib(n: uint32): uint32
[ 349.01]            > fib(n: uint32): uint32
[ 349.02]            < return
[ 349.03]            > fib(n: uint32): uint32
[ 349.05]            < return
[ 349.06]           < return
[ 349.07]          < return
[ 349.07]          > fib(n: uint32): uint32
[ 349.09]           > fib(n: uint32): uint32
[ 349.11]            > fib(n: uint32): uint32
[ 349.12]            < return
[ 349.13]            > fib(n: uint32): uint32
[ 349.15]            < return
[ 349.16]           < return
[ 349.17]           > fib(n: uint32): uint32
[ 349.18]           < return
[ 349.19]          < return
[ 349.20]         < return
[ 349.21]         > fib(n: uint32): uint32
[ 349.25]          > fib(n: uint32): uint32
[ 349.26]           > fib(n: uint32): uint32
[ 349.29]            > fib(n: uint32): uint32
[ 349.31]            < return
[ 349.32]            > fib(n: uint32): uint32
[ 349.33]            < return
[ 349.34]           < return
[ 349.35]           > fib(n: uint32): uint32
[ 349.37]           < return
[ 349.39]          < return
[ 349.40]          > fib(n: uint32): uint32
[ 349.42]           > fib(n: uint32): uint32
[ 349.43]           < return
[ 349.44]           > fib(n: uint32): uint32
[ 349.45]           < return
[ 349.46]          < return
[ 349.47]         < return
[ 349.48]        < return
[ 349.49]       < return
[ 349.50]       > fib(n: uint32): uint32
[ 349.51]        > fib(n: uint32): uint32
[ 349.53]         > fib(n: uint32): uint32
[ 349.55]          > fib(n: uint32): uint32
[ 349.56]           > fib(n: uint32): uint32
[ 349.58]            > fib(n: uint32): uint32
[ 349.60]             > fib(n: uint32): uint32
[ 349.61]             < return
[ 349.62]             > fib(n: uint32): uint32
[ 349.64]             < return
[ 349.65]            < return
[ 349.65]            > fib(n: uint32): uint32
[ 349.67]            < return
[ 349.68]           < return
[ 349.69]           > fib(n: uint32): uint32
[ 349.72]            > fib(n: uint32): uint32
[ 349.74]            < return
[ 349.75]            > fib(n: uint32): uint32
[ 349.76]            < return
[ 349.79]           < return
[ 349.80]          < return
[ 349.80]          > fib(n: uint32): uint32
[ 349.82]           > fib(n: uint32): uint32
[ 349.84]            > fib(n: uint32): uint32
[ 349.85]            < return
[ 349.86]            > fib(n: uint32): uint32
[ 349.88]            < return
[ 349.88]           < return
[ 349.89]           > fib(n: uint32): uint32
[ 349.91]           < return
[ 349.92]          < return
[ 349.93]         < return
[ 349.94]         > fib(n: uint32): uint32
[ 349.95]          > fib(n: uint32): uint32
[ 349.97]           > fib(n: uint32): uint32
[ 349.99]            > fib(n: uint32): uint32
[ 350.00]            < return
[ 350.01]            > fib(n: uint32): uint32
[ 350.02]            < return
[ 350.03]           < return
[ 350.04]           > fib(n: uint32): uint32
[ 350.06]           < return
[ 350.07]          < return
[ 350.07]          > fib(n: uint32): uint32
[ 350.09]           > fib(n: uint32): uint32
[ 350.11]           < return
[ 350.12]           > fib(n: uint32): uint32
[ 350.13]           < return
[ 350.14]          < return
[ 350.15]         < return
[ 350.18]        < return
[ 350.19]        > fib(n: uint32): uint32
[ 350.20]         > fib(n: uint32): uint32
[ 350.23]          > fib(n: uint32): uint32
[ 350.25]           > fib(n: uint32): uint32
[ 350.27]            > fib(n: uint32): uint32
[ 350.28]            < return
[ 350.31]            > fib(n: uint32): uint32
[ 350.32]            < return
[ 350.33]           < return
[ 350.34]           > fib(n: uint32): uint32
[ 350.36]           < return
[ 350.37]          < return
[ 350.38]          > fib(n: uint32): uint32
[ 350.39]           > fib(n: uint32): uint32
[ 350.41]           < return
[ 350.43]           > fib(n: uint32): uint32
[ 350.45]           < return
[ 350.46]          < return
[ 350.47]         < return
[ 350.48]         > fib(n: uint32): uint32
[ 350.49]          > fib(n: uint32): uint32
[ 350.51]           > fib(n: uint32): uint32
[ 350.52]           < return
[ 350.53]           > fib(n: uint32): uint32
[ 350.55]           < return
[ 350.56]          < return
[ 350.56]          > fib(n: uint32): uint32
[ 350.58]          < return
[ 350.59]         < return
[ 350.60]        < return
[ 350.61]       < return
[ 350.61]      < return
[ 350.62]      > fib(n: uint32): uint32
[ 350.64]       > fib(n: uint32): uint32
[ 350.68]        > fib(n: uint32): uint32
[ 350.69]         > fib(n: uint32): uint32
[ 350.71]          > fib(n: uint32): uint32
[ 350.74]           > fib(n: uint32): uint32
[ 350.76]            > fib(n: uint32): uint32
[ 350.78]             > fib(n: uint32): uint32
[ 350.79]             < return
[ 350.80]             > fib(n: uint32): uint32
[ 350.81]             < return
[ 350.82]            < return
[ 350.83]            > fib(n: uint32): uint32
[ 350.85]            < return
[ 350.86]           < return
[ 350.87]           > fib(n: uint32): uint32
[ 350.88]            > fib(n: uint32): uint32
[ 350.90]            < return
[ 350.91]            > fib(n: uint32): uint32
[ 350.92]            < return
[ 350.93]           < return
[ 350.94]          < return
[ 350.95]          > fib(n: uint32): uint32
[ 350.96]           > fib(n: uint32): uint32
[ 350.98]            > fib(n: uint32): uint32
[ 351.00]            < return
[ 351.00]            > fib(n: uint32): uint32
[ 351.02]            < return
[ 351.03]           < return
[ 351.04]           > fib(n: uint32): uint32
[ 351.05]           < return
[ 351.06]          < return
[ 351.07]         < return
[ 351.08]         > fib(n: uint32): uint32
[ 351.10]          > fib(n: uint32): uint32
[ 351.11]           > fib(n: uint32): uint32
[ 351.13]            > fib(n: uint32): uint32
[ 351.17]            < return
[ 351.18]            > fib(n: uint32): uint32
[ 351.19]            < return
[ 351.21]           < return
[ 351.22]           > fib(n: uint32): uint32
[ 351.24]           < return
[ 351.25]          < return
[ 351.26]          > fib(n: uint32): uint32
[ 351.27]           > fib(n: uint32): uint32
[ 351.29]           < return
[ 351.30]           > fib(n: uint32): uint32
[ 351.31]           < return
[ 351.32]          < return
[ 351.33]         < return
[ 351.34]        < return
[ 351.35]        > fib(n: uint32): uint32
[ 351.36]         > fib(n: uint32): uint32
[ 351.38]          > fib(n: uint32): uint32
[ 351.40]           > fib(n: uint32): uint32
[ 351.41]            > fib(n: uint32): uint32
[ 351.43]            < return
[ 351.44]            > fib(n: uint32): uint32
[ 351.48]            < return
[ 351.49]           < return
[ 351.50]           > fib(n: uint32): uint32
[ 351.52]           < return
[ 351.53]          < return
[ 351.55]          > fib(n: uint32): uint32
[ 351.57]           > fib(n: uint32): uint32
[ 351.58]           < return
[ 351.59]           > fib(n: uint32): uint32
[ 351.61]           < return
[ 351.62]          < return
[ 351.62]         < return
[ 351.65]         > fib(n: uint32): uint32
[ 351.67]          > fib(n: uint32): uint32
[ 351.71]           > fib(n: uint32): uint32
[ 351.73]           < return
[ 351.74]           > fib(n: uint32): uint32
[ 351.75]           < return
[ 351.76]          < return
[ 351.77]          > fib(n: uint32): uint32
[ 351.79]          < return
[ 351.80]         < return
[ 351.81]        < return
[ 351.81]       < return
[ 351.82]       > fib(n: uint32): uint32
[ 351.84]        > fib(n: uint32): uint32
[ 351.86]         > fib(n: uint32): uint32
[ 351.87]          > fib(n: uint32): uint32
[ 351.89]           > fib(n: uint32): uint32
[ 351.91]            > fib(n: uint32): uint32
[ 351.92]            < return
[ 351.93]            > fib(n: uint32): uint32
[ 351.94]            < return
[ 351.95]           < return
[ 351.96]           > fib(n: uint32): uint32
[ 351.98]           < return
[ 351.99]          < return
[ 352.00]          > fib(n: uint32): uint32
[ 352.01]           > fib(n: uint32): uint32
[ 352.03]           < return
[ 352.04]           > fib(n: uint32): uint32
[ 352.05]           < return
[ 352.06]          < return
[ 352.07]         < return
[ 352.08]         > fib(n: uint32): uint32
[ 352.10]          > fib(n: uint32): uint32
[ 352.11]           > fib(n: uint32): uint32
[ 352.13]           < return
[ 352.14]           > fib(n: uint32): uint32
[ 352.17]           < return
[ 352.18]          < return
[ 352.19]          > fib(n: uint32): uint32
[ 352.21]          < return
[ 352.23]         < return
[ 352.24]        < return
[ 352.25]        > fib(n: uint32): uint32
[ 352.27]         > fib(n: uint32): uint32
[ 352.28]          > fib(n: uint32): uint32
[ 352.30]           > fib(n: uint32): uint32
[ 352.31]           < return
[ 352.32]           > fib(n: uint32): uint32
[ 352.34]           < return
[ 352.35]          < return
[ 352.36]          > fib(n: uint32): uint32
[ 352.37]          < return
[ 352.38]         < return
[ 352.39]         > fib(n: uint32): uint32
[ 352.41]          > fib(n: uint32): uint32
[ 352.42]          < return
[ 352.43]          > fib(n: uint32): uint32
[ 352.45]          < return
[ 352.46]         < return
[ 352.46]        < return
[ 352.47]       < return
[ 352.48]      < return
[ 352.49]     < return
[ 352.50]     > fib(n: uint32): uint32
[ 352.52]      > fib(n: uint32): uint32
[ 352.53]       > fib(n: uint32): uint32
[ 352.55]        > fib(n: uint32): uint32
[ 352.57]         > fib(n: uint32): uint32
[ 352.58]          > fib(n: uint32): uint32
[ 352.60]           > fib(n: uint32): uint32
[ 352.64]            > fib(n: uint32): uint32
[ 352.65]             > fib(n: uint32): uint32
[ 352.67]             < return
[ 352.69]             > fib(n: uint32): uint32
[ 352.71]             < return
[ 352.72]            < return
[ 352.73]            > fib(n: uint32): uint32
[ 352.74]            < return
[ 352.75]           < return
[ 352.76]           > fib(n: uint32): uint32
[ 352.78]            > fib(n: uint32): uint32
[ 352.79]            < return
[ 352.80]            > fib(n: uint32): uint32
[ 352.81]            < return
[ 352.82]           < return
[ 352.83]          < return
[ 352.84]          > fib(n: uint32): uint32
[ 352.86]           > fib(n: uint32): uint32
[ 352.87]            > fib(n: uint32): uint32
[ 352.89]            < return
[ 352.90]            > fib(n: uint32): uint32
[ 352.91]            < return
[ 352.92]           < return
[ 352.93]           > fib(n: uint32): uint32
[ 352.95]           < return
[ 352.95]          < return
[ 352.96]         < return
[ 352.97]         > fib(n: uint32): uint32
[ 352.99]          > fib(n: uint32): uint32
[ 353.01]           > fib(n: uint32): uint32
[ 353.02]            > fib(n: uint32): uint32
[ 353.04]            < return
[ 353.05]            > fib(n: uint32): uint32
[ 353.06]            < return
[ 353.07]           < return
[ 353.10]           > fib(n: uint32): uint32
[ 353.12]           < return
[ 353.13]          < return
[ 353.14]          > fib(n: uint32): uint32
[ 353.17]           > fib(n: uint32): uint32
[ 353.18]           < return
[ 353.19]           > fib(n: uint32): uint32
[ 353.20]           < return
[ 353.21]          < return
[ 353.22]         < return
[ 353.23]        < return
[ 353.24]        > fib(n: uint32): uint32
[ 353.26]         > fib(n: uint32): uint32
[ 353.27]          > fib(n: uint32): uint32
[ 353.29]           > fib(n: uint32): uint32
[ 353.31]            > fib(n: uint32): uint32
[ 353.32]            < return
[ 353.33]            > fib(n: uint32): uint32
[ 353.35]            < return
[ 353.35]           < return
[ 353.36]           > fib(n: uint32): uint32
[ 353.38]           < return
[ 353.39]          < return
[ 353.40]          > fib(n: uint32): uint32
[ 353.41]           > fib(n: uint32): uint32
[ 353.43]           < return
[ 353.44]           > fib(n: uint32): uint32
[ 353.45]           < return
[ 353.46]          < return
[ 353.47]         < return
[ 353.48]         > fib(n: uint32): uint32
[ 353.50]          > fib(n: uint32): uint32
[ 353.51]           > fib(n: uint32): uint32
[ 353.53]           < return
[ 353.54]           > fib(n: uint32): uint32
[ 353.57]           < return
[ 353.58]          < return
[ 353.59]          > fib(n: uint32): uint32
[ 353.62]          < return
[ 353.63]         < return
[ 353.64]        < return
[ 353.65]       < return
[ 353.65]       > fib(n: uint32): uint32
[ 353.67]        > fib(n: uint32): uint32
[ 353.69]         > fib(n: uint32): uint32
[ 353.70]          > fib(n: uint32): uint32
[ 353.72]           > fib(n: uint32): uint32
[ 353.74]            > fib(n: uint32): uint32
[ 353.75]            < return
[ 353.76]            > fib(n: uint32): uint32
[ 353.78]            < return
[ 353.79]           < return
[ 353.80]           > fib(n: uint32): uint32
[ 353.81]           < return
[ 353.82]          < return
[ 353.83]          > fib(n: uint32): uint32
[ 353.85]           > fib(n: uint32): uint32
[ 353.86]           < return
[ 353.87]           > fib(n: uint32): uint32
[ 353.88]           < return
[ 353.89]          < return
[ 353.90]         < return
[ 353.91]         > fib(n: uint32): uint32
[ 353.93]          > fib(n: uint32): uint32
[ 353.94]           > fib(n: uint32): uint32
[ 353.96]           < return
[ 353.97]           > fib(n: uint32): uint32
[ 353.98]           < return
[ 353.99]          < return
[ 354.00]          > fib(n: uint32): uint32
[ 354.04]          < return
[ 354.05]         < return
[ 354.06]        < return
[ 354.08]        > fib(n: uint32): uint32
[ 354.10]         > fib(n: uint32): uint32
[ 354.11]          > fib(n: uint32): uint32
[ 354.13]           > fib(n: uint32): uint32
[ 354.14]           < return
[ 354.15]           > fib(n: uint32): uint32
[ 354.17]           < return
[ 354.18]          < return
[ 354.19]          > fib(n: uint32): uint32
[ 354.20]          < return
[ 354.21]         < return
[ 354.22]         > fib(n: uint32): uint32
[ 354.24]          > fib(n: uint32): uint32
[ 354.25]          < return
[ 354.26]          > fib(n: uint32): uint32
[ 354.27]          < return
[ 354.28]         < return
[ 354.29]        < return
[ 354.30]       < return
[ 354.31]      < return
[ 354.32]      > fib(n: uint32): uint32
[ 354.33]       > fib(n: uint32): uint32
[ 354.35]        > fib(n: uint32): uint32
[ 354.37]         > fib(n: uint32): uint32
[ 354.38]          > fib(n: uint32): uint32
[ 354.40]           > fib(n: uint32): uint32
[ 354.42]            > fib(n: uint32): uint32
[ 354.43]            < return
[ 354.44]            > fib(n: uint32): uint32
[ 354.46]            < return
[ 354.47]           < return
[ 354.50]           > fib(n: uint32): uint32
[ 354.53]           < return
[ 354.54]          < return
[ 354.55]          > fib(n: uint32): uint32
[ 354.56]           > fib(n: uint32): uint32
[ 354.58]           < return
[ 354.60]           > fib(n: uint32): uint32
[ 354.62]           < return
[ 354.62]          < return
[ 354.63]         < return
[ 354.64]         > fib(n: uint32): uint32
[ 354.66]          > fib(n: uint32): uint32
[ 354.68]           > fib(n: uint32): uint32
[ 354.69]           < return
[ 354.70]           > fib(n: uint32): uint32
[ 354.71]           < return
[ 354.72]          < return
[ 354.73]          > fib(n: uint32): uint32
[ 354.75]          < return
[ 354.76]         < return
[ 354.76]        < return
[ 354.77]        > fib(n: uint32): uint32
[ 354.79]         > fib(n: uint32): uint32
[ 354.81]          > fib(n: uint32): uint32
[ 354.82]           > fib(n: uint32): uint32
[ 354.84]           < return
[ 354.85]           > fib(n: uint32): uint32
[ 354.86]           < return
[ 354.87]          < return
[ 354.88]          > fib(n: uint32): uint32
[ 354.89]          < return
[ 354.90]         < return
[ 354.91]         > fib(n: uint32): uint32
[ 354.93]          > fib(n: uint32): uint32
[ 354.94]          < return
[ 354.99]          > fib(n: uint32): uint32
[ 355.02]          < return
[ 355.03]         < return
[ 355.05]        < return
[ 355.06]       < return
[ 355.07]       > fib(n: uint32): uint32
[ 355.09]        > fib(n: uint32): uint32
[ 355.10]         > fib(n: uint32): uint32
[ 355.12]          > fib(n: uint32): uint32
[ 355.14]           > fib(n: uint32): uint32
[ 355.15]           < return
[ 355.16]           > fib(n: uint32): uint32
[ 355.18]           < return
[ 355.18]          < return
[ 355.19]          > fib(n: uint32): uint32
[ 355.21]          < return
[ 355.22]         < return
[ 355.23]         > fib(n: uint32): uint32
[ 355.24]          > fib(n: uint32): uint32
[ 355.26]          < return
[ 355.27]          > fib(n: uint32): uint32
[ 355.28]          < return
[ 355.29]         < return
[ 355.30]        < return
[ 355.31]        > fib(n: uint32): uint32
[ 355.33]         > fib(n: uint32): uint32
[ 355.34]          > fib(n: uint32): uint32
[ 355.36]          < return
[ 355.37]          > fib(n: uint32): uint32
[ 355.38]          < return
[ 355.39]         < return
[ 355.40]         > fib(n: uint32): uint32
[ 355.42]         < return
[ 355.43]        < return
[ 355.44]       < return
[ 355.46]      < return
[ 355.48]     < return
[ 355.48]    < return
[ 355.49]    > fib(n: uint32): uint32
[ 355.51]     > fib(n: uint32): uint32
[ 355.54]      > fib(n: uint32): uint32
[ 355.56]       > fib(n: uint32): uint32
[ 355.57]        > fib(n: uint32): uint32
[ 355.59]         > fib(n: uint32): uint32
[ 355.61]          > fib(n: uint32): uint32
[ 355.62]           > fib(n: uint32): uint32
[ 355.64]            > fib(n: uint32): uint32
[ 355.66]             > fib(n: uint32): uint32
[ 355.67]             < return
[ 355.68]             > fib(n: uint32): uint32
[ 355.69]             < return
[ 355.70]            < return
[ 355.71]            > fib(n: uint32): uint32
[ 355.73]            < return
[ 355.74]           < return
[ 355.75]           > fib(n: uint32): uint32
[ 355.76]            > fib(n: uint32): uint32
[ 355.78]            < return
[ 355.79]            > fib(n: uint32): uint32
[ 355.80]            < return
[ 355.81]           < return
[ 355.82]          < return
[ 355.83]          > fib(n: uint32): uint32
[ 355.85]           > fib(n: uint32): uint32
[ 355.86]            > fib(n: uint32): uint32
[ 355.88]            < return
[ 355.89]            > fib(n: uint32): uint32
[ 355.90]            < return
[ 355.93]           < return
[ 355.94]           > fib(n: uint32): uint32
[ 355.96]           < return
[ 355.97]          < return
[ 355.99]         < return
[ 356.00]         > fib(n: uint32): uint32
[ 356.02]          > fib(n: uint32): uint32
[ 356.04]           > fib(n: uint32): uint32
[ 356.05]            > fib(n: uint32): uint32
[ 356.06]            < return
[ 356.07]            > fib(n: uint32): uint32
[ 356.09]            < return
[ 356.10]           < return
[ 356.11]           > fib(n: uint32): uint32
[ 356.12]           < return
[ 356.13]          < return
[ 356.14]          > fib(n: uint32): uint32
[ 356.16]           > fib(n: uint32): uint32
[ 356.17]           < return
[ 356.18]           > fib(n: uint32): uint32
[ 356.20]           < return
[ 356.20]          < return
[ 356.21]         < return
[ 356.22]        < return
[ 356.23]        > fib(n: uint32): uint32
[ 356.25]         > fib(n: uint32): uint32
[ 356.26]          > fib(n: uint32): uint32
[ 356.28]           > fib(n: uint32): uint32
[ 356.30]            > fib(n: uint32): uint32
[ 356.31]            < return
[ 356.32]            > fib(n: uint32): uint32
[ 356.34]            < return
[ 356.35]           < return
[ 356.36]           > fib(n: uint32): uint32
[ 356.37]           < return
[ 356.40]          < return
[ 356.41]          > fib(n: uint32): uint32
[ 356.43]           > fib(n: uint32): uint32
[ 356.46]           < return
[ 356.47]           > fib(n: uint32): uint32
[ 356.48]           < return
[ 356.49]          < return
[ 356.50]         < return
[ 356.51]         > fib(n: uint32): uint32
[ 356.52]          > fib(n: uint32): uint32
[ 356.54]           > fib(n: uint32): uint32
[ 356.56]           < return
[ 356.57]           > fib(n: uint32): uint32
[ 356.58]           < return
[ 356.59]          < return
[ 356.60]          > fib(n: uint32): uint32
[ 356.61]          < return
[ 356.62]         < return
[ 356.63]        < return
[ 356.64]       < return
[ 356.65]       > fib(n: uint32): uint32
[ 356.67]        > fib(n: uint32): uint32
[ 356.68]         > fib(n: uint32): uint32
[ 356.70]          > fib(n: uint32): uint32
[ 356.71]           > fib(n: uint32): uint32
[ 356.73]            > fib(n: uint32): uint32
[ 356.75]            < return
[ 356.75]            > fib(n: uint32): uint32
[ 356.77]            < return
[ 356.78]           < return
[ 356.79]           > fib(n: uint32): uint32
[ 356.80]           < return
[ 356.81]          < return
[ 356.82]          > fib(n: uint32): uint32
[ 356.86]           > fib(n: uint32): uint32
[ 356.91]           < return
[ 356.92]           > fib(n: uint32): uint32
[ 356.94]           < return
[ 356.95]          < return
[ 356.96]         < return
[ 356.97]         > fib(n: uint32): uint32
[ 356.99]          > fib(n: uint32): uint32
[ 357.01]           > fib(n: uint32): uint32
[ 357.02]           < return
[ 357.03]           > fib(n: uint32): uint32
[ 357.05]           < return
[ 357.05]          < return
[ 357.06]          > fib(n: uint32): uint32
[ 357.08]          < return
[ 357.09]         < return
[ 357.10]        < return
[ 357.11]        > fib(n: uint32): uint32
[ 357.12]         > fib(n: uint32): uint32
[ 357.14]          > fib(n: uint32): uint32
[ 357.15]           > fib(n: uint32): uint32
[ 357.17]           < return
[ 357.18]           > fib(n: uint32): uint32
[ 357.19]           < return
[ 357.20]          < return
[ 357.21]          > fib(n: uint32): uint32
[ 357.23]          < return
[ 357.24]         < return
[ 357.25]         > fib(n: uint32): uint32
[ 357.26]          > fib(n: uint32): uint32
[ 357.27]          < return
[ 357.29]          > fib(n: uint32): uint32
[ 357.30]          < return
[ 357.31]         < return
[ 357.32]        < return
[ 357.35]       < return
[ 357.36]      < return
[ 357.37]      > fib(n: uint32): uint32
[ 357.40]       > fib(n: uint32): uint32
[ 357.42]        > fib(n: uint32): uint32
[ 357.43]         > fib(n: uint32): uint32
[ 357.45]          > fib(n: uint32): uint32
[ 357.47]           > fib(n: uint32): uint32
[ 357.48]            > fib(n: uint32): uint32
[ 357.50]            < return
[ 357.51]            > fib(n: uint32): uint32
[ 357.52]            < return
[ 357.53]           < return
[ 357.54]           > fib(n: uint32): uint32
[ 357.55]           < return
[ 357.56]          < return
[ 357.57]          > fib(n: uint32): uint32
[ 357.59]           > fib(n: uint32): uint32
[ 357.60]           < return
[ 357.61]           > fib(n: uint32): uint32
[ 357.63]           < return
[ 357.64]          < return
[ 357.64]         < return
[ 357.65]         > fib(n: uint32): uint32
[ 357.67]          > fib(n: uint32): uint32
[ 357.69]           > fib(n: uint32): uint32
[ 357.70]           < return
[ 357.71]           > fib(n: uint32): uint32
[ 357.73]           < return
[ 357.74]          < return
[ 357.74]          > fib(n: uint32): uint32
[ 357.76]          < return
[ 357.77]         < return
[ 357.78]        < return
[ 357.81]        > fib(n: uint32): uint32
[ 357.84]         > fib(n: uint32): uint32
[ 357.86]          > fib(n: uint32): uint32
[ 357.87]           > fib(n: uint32): uint32
[ 357.89]           < return
[ 357.90]           > fib(n: uint32): uint32
[ 357.93]           < return
[ 357.94]          < return
[ 357.95]          > fib(n: uint32): uint32
[ 357.96]          < return
[ 357.97]         < return
[ 357.98]         > fib(n: uint32): uint32
[ 358.00]          > fib(n: uint32): uint32
[ 358.01]          < return
[ 358.02]          > fib(n: uint32): uint32
[ 358.03]          < return
[ 358.04]         < return
[ 358.05]        < return
[ 358.06]       < return
[ 358.07]       > fib(n: uint32): uint32
[ 358.09]        > fib(n: uint32): uint32
[ 358.10]         > fib(n: uint32): uint32
[ 358.12]          > fib(n: uint32): uint32
[ 358.13]           > fib(n: uint32): uint32
[ 358.15]           < return
[ 358.16]           > fib(n: uint32): uint32
[ 358.17]           < return
[ 358.18]          < return
[ 358.19]          > fib(n: uint32): uint32
[ 358.21]          < return
[ 358.22]         < return
[ 358.23]         > fib(n: uint32): uint32
[ 358.24]          > fib(n: uint32): uint32
[ 358.26]          < return
[ 358.29]          > fib(n: uint32): uint32
[ 358.30]          < return
[ 358.31]         < return
[ 358.32]        < return
[ 358.34]        > fib(n: uint32): uint32
[ 358.36]         > fib(n: uint32): uint32
[ 358.38]          > fib(n: uint32): uint32
[ 358.39]          < return
[ 358.40]          > fib(n: uint32): uint32
[ 358.42]          < return
[ 358.43]         < return
[ 358.43]         > fib(n: uint32): uint32
[ 358.45]         < return
[ 358.46]        < return
[ 358.47]       < return
[ 358.48]      < return
[ 358.49]     < return
[ 358.50]     > fib(n: uint32): uint32
[ 358.51]      > fib(n: uint32): uint32
[ 358.53]       > fib(n: uint32): uint32
[ 358.55]        > fib(n: uint32): uint32
[ 358.56]         > fib(n: uint32): uint32
[ 358.58]          > fib(n: uint32): uint32
[ 358.60]           > fib(n: uint32): uint32
[ 358.61]            > fib(n: uint32): uint32
[ 358.63]            < return
[ 358.64]            > fib(n: uint32): uint32
[ 358.65]            < return
[ 358.66]           < return
[ 358.67]           > fib(n: uint32): uint32
[ 358.68]           < return
[ 358.69]          < return
[ 358.70]          > fib(n: uint32): uint32
[ 358.72]           > fib(n: uint32): uint32
[ 358.76]           < return
[ 358.77]           > fib(n: uint32): uint32
[ 358.78]           < return
[ 358.80]          < return
[ 358.81]         < return
[ 358.82]         > fib(n: uint32): uint32
[ 358.84]          > fib(n: uint32): uint32
[ 358.86]           > fib(n: uint32): uint32
[ 358.87]           < return
[ 358.88]           > fib(n: uint32): uint32
[ 358.89]           < return
[ 358.90]          < return
[ 358.91]          > fib(n: uint32): uint32
[ 358.93]          < return
[ 358.94]         < return
[ 358.94]        < return
[ 358.95]        > fib(n: uint32): uint32
[ 358.97]         > fib(n: uint32): uint32
[ 358.99]          > fib(n: uint32): uint32
[ 359.00]           > fib(n: uint32): uint32
[ 359.02]           < return
[ 359.03]           > fib(n: uint32): uint32
[ 359.04]           < return
[ 359.05]          < return
[ 359.06]          > fib(n: uint32): uint32
[ 359.07]          < return
[ 359.08]         < return
[ 359.09]         > fib(n: uint32): uint32
[ 359.11]          > fib(n: uint32): uint32
[ 359.12]          < return
[ 359.13]          > fib(n: uint32): uint32
[ 359.15]          < return
[ 359.16]         < return
[ 359.17]        < return
[ 359.18]       < return
[ 359.18]       > fib(n: uint32): uint32
[ 359.22]        > fib(n: uint32): uint32
[ 359.24]         > fib(n: uint32): uint32
[ 359.27]          > fib(n: uint32): uint32
[ 359.29]           > fib(n: uint32): uint32
[ 359.30]           < return
[ 359.31]           > fib(n: uint32): uint32
[ 359.33]           < return
[ 359.33]          < return
[ 359.35]          > fib(n: uint32): uint32
[ 359.36]          < return
[ 359.37]         < return
[ 359.38]         > fib(n: uint32): uint32
[ 359.39]          > fib(n: uint32): uint32
[ 359.41]          < return
[ 359.42]          > fib(n: uint32): uint32
[ 359.44]          < return
[ 359.44]         < return
[ 359.45]        < return
[ 359.46]        > fib(n: uint32): uint32
[ 359.48]         > fib(n: uint32): uint32
[ 359.51]          > fib(n: uint32): uint32
[ 359.53]          < return
[ 359.55]          > fib(n: uint32): uint32
[ 359.57]          < return
[ 359.57]         < return
[ 359.58]         > fib(n: uint32): uint32
[ 359.60]         < return
[ 359.61]        < return
[ 359.62]       < return
[ 359.62]      < return
[ 359.63]      > fib(n: uint32): uint32
[ 359.65]       > fib(n: uint32): uint32
[ 359.67]        > fib(n: uint32): uint32
[ 359.68]         > fib(n: uint32): uint32
[ 359.72]          > fib(n: uint32): uint32
[ 359.74]           > fib(n: uint32): uint32
[ 359.76]           < return
[ 359.77]           > fib(n: uint32): uint32
[ 359.79]           < return
[ 359.80]          < return
[ 359.81]          > fib(n: uint32): uint32
[ 359.82]          < return
[ 359.83]         < return
[ 359.84]         > fib(n: uint32): uint32
[ 359.86]          > fib(n: uint32): uint32
[ 359.87]          < return
[ 359.88]          > fib(n: uint32): uint32
[ 359.90]          < return
[ 359.91]         < return
[ 359.92]        < return
[ 359.92]        > fib(n: uint32): uint32
[ 359.94]         > fib(n: uint32): uint32
[ 359.96]          > fib(n: uint32): uint32
[ 359.97]          < return
[ 359.98]          > fib(n: uint32): uint32
[ 360.00]          < return
[ 360.00]         < return
[ 360.01]         > fib(n: uint32): uint32
[ 360.04]         < return
[ 360.05]        < return
[ 360.06]       < return
[ 360.07]       > fib(n: uint32): uint32
[ 360.09]        > fib(n: uint32): uint32
[ 360.10]         > fib(n: uint32): uint32
[ 360.12]          > fib(n: uint32): uint32
[ 360.13]          < return
[ 360.14]          > fib(n: uint32): uint32
[ 360.18]          < return
[ 360.19]         < return
[ 360.20]         > fib(n: uint32): uint32
[ 360.21]         < return
[ 360.24]        < return
[ 360.25]        > fib(n: uint32): uint32
[ 360.26]         > fib(n: uint32): uint32
[ 360.28]         < return
[ 360.29]         > fib(n: uint32): uint32
[ 360.30]         < return
[ 360.31]        < return
[ 360.32]       < return
[ 360.33]      < return
[ 360.34]     < return
[ 360.34]    < return
[ 360.35]   < return
[ 360.36]   > fib(n: uint32): uint32
[ 360.38]    > fib(n: uint32): uint32
[ 360.39]     > fib(n: uint32): uint32
[ 360.41]      > fib(n: uint32): uint32
[ 360.43]       > fib(n: uint32): uint32
[ 360.44]        > fib(n: uint32): uint32
[ 360.46]         > fib(n: uint32): uint32
[ 360.48]          > fib(n: uint32): uint32
[ 360.49]           > fib(n: uint32): uint32
[ 360.51]            > fib(n: uint32): uint32
[ 360.53]             > fib(n: uint32): uint32
[ 360.54]             < return
[ 360.55]             > fib(n: uint32): uint32
[ 360.56]             < return
[ 360.57]            < return
[ 360.58]            > fib(n: uint32): uint32
[ 360.60]            < return
[ 360.61]           < return
[ 360.62]           > fib(n: uint32): uint32
[ 360.66]            > fib(n: uint32): uint32
[ 360.67]            < return
[ 360.69]            > fib(n: uint32): uint32
[ 360.71]            < return
[ 360.72]           < return
[ 360.73]          < return
[ 360.74]          > fib(n: uint32): uint32
[ 360.75]           > fib(n: uint32): uint32
[ 360.77]            > fib(n: uint32): uint32
[ 360.78]            < return
[ 360.79]            > fib(n: uint32): uint32
[ 360.81]            < return
[ 360.82]           < return
[ 360.83]           > fib(n: uint32): uint32
[ 360.84]           < return
[ 360.85]          < return
[ 360.86]         < return
[ 360.87]         > fib(n: uint32): uint32
[ 360.88]          > fib(n: uint32): uint32
[ 360.90]           > fib(n: uint32): uint32
[ 360.92]            > fib(n: uint32): uint32
[ 360.93]            < return
[ 360.94]            > fib(n: uint32): uint32
[ 360.95]            < return
[ 360.96]           < return
[ 360.97]           > fib(n: uint32): uint32
[ 360.99]           < return
[ 361.00]          < return
[ 361.01]          > fib(n: uint32): uint32
[ 361.02]           > fib(n: uint32): uint32
[ 361.04]           < return
[ 361.05]           > fib(n: uint32): uint32
[ 361.06]           < return
[ 361.07]          < return
[ 361.08]         < return
[ 361.09]        < return
[ 361.10]        > fib(n: uint32): uint32
[ 361.14]         > fib(n: uint32): uint32
[ 361.15]          > fib(n: uint32): uint32
[ 361.18]           > fib(n: uint32): uint32
[ 361.20]            > fib(n: uint32): uint32
[ 361.21]            < return
[ 361.22]            > fib(n: uint32): uint32
[ 361.24]            < return
[ 361.25]           < return
[ 361.26]           > fib(n: uint32): uint32
[ 361.27]           < return
[ 361.28]          < return
[ 361.29]          > fib(n: uint32): uint32
[ 361.31]           > fib(n: uint32): uint32
[ 361.32]           < return
[ 361.33]           > fib(n: uint32): uint32
[ 361.35]           < return
[ 361.36]          < return
[ 361.36]         < return
[ 361.37]         > fib(n: uint32): uint32
[ 361.39]          > fib(n: uint32): uint32
[ 361.41]           > fib(n: uint32): uint32
[ 361.42]           < return
[ 361.43]           > fib(n: uint32): uint32
[ 361.44]           < return
[ 361.45]          < return
[ 361.46]          > fib(n: uint32): uint32
[ 361.48]          < return
[ 361.49]         < return
[ 361.50]        < return
[ 361.50]       < return
[ 361.51]       > fib(n: uint32): uint32
[ 361.53]        > fib(n: uint32): uint32
[ 361.55]         > fib(n: uint32): uint32
[ 361.57]          > fib(n: uint32): uint32
[ 361.61]           > fib(n: uint32): uint32
[ 361.62]            > fib(n: uint32): uint32
[ 361.65]            < return
[ 361.66]            > fib(n: uint32): uint32
[ 361.68]            < return
[ 361.69]           < return
[ 361.69]           > fib(n: uint32): uint32
[ 361.71]           < return
[ 361.72]          < return
[ 361.73]          > fib(n: uint32): uint32
[ 361.74]           > fib(n: uint32): uint32
[ 361.76]           < return
[ 361.77]           > fib(n: uint32): uint32
[ 361.78]           < return
[ 361.79]          < return
[ 361.80]         < return
[ 361.81]         > fib(n: uint32): uint32
[ 361.83]          > fib(n: uint32): uint32
[ 361.84]           > fib(n: uint32): uint32
[ 361.86]           < return
[ 361.87]           > fib(n: uint32): uint32
[ 361.88]           < return
[ 361.89]          < return
[ 361.90]          > fib(n: uint32): uint32
[ 361.91]          < return
[ 361.92]         < return
[ 361.93]        < return
[ 361.94]        > fib(n: uint32): uint32
[ 361.96]         > fib(n: uint32): uint32
[ 361.97]          > fib(n: uint32): uint32
[ 361.99]           > fib(n: uint32): uint32
[ 362.00]           < return
[ 362.01]           > fib(n: uint32): uint32
[ 362.05]           < return
[ 362.06]          < return
[ 362.07]          > fib(n: uint32): uint32
[ 362.10]          < return
[ 362.11]         < return
[ 362.12]         > fib(n: uint32): uint32
[ 362.13]          > fib(n: uint32): uint32
[ 362.15]          < return
[ 362.16]          > fib(n: uint32): uint32
[ 362.17]          < return
[ 362.18]         < return
[ 362.19]        < return
[ 362.20]       < return
[ 362.21]      < return
[ 362.22]      > fib(n: uint32): uint32
[ 362.23]       > fib(n: uint32): uint32
[ 362.25]        > fib(n: uint32): uint32
[ 362.27]         > fib(n: uint32): uint32
[ 362.28]          > fib(n: uint32): uint32
[ 362.30]           > fib(n: uint32): uint32
[ 362.31]            > fib(n: uint32): uint32
[ 362.33]            < return
[ 362.34]            > fib(n: uint32): uint32
[ 362.35]            < return
[ 362.36]           < return
[ 362.37]           > fib(n: uint32): uint32
[ 362.39]           < return
[ 362.40]          < return
[ 362.40]          > fib(n: uint32): uint32
[ 362.42]           > fib(n: uint32): uint32
[ 362.44]           < return
[ 362.45]           > fib(n: uint32): uint32
[ 362.46]           < return
[ 362.47]          < return
[ 362.48]         < return
[ 362.49]         > fib(n: uint32): uint32
[ 362.53]          > fib(n: uint32): uint32
[ 362.55]           > fib(n: uint32): uint32
[ 362.57]           < return
[ 362.58]           > fib(n: uint32): uint32
[ 362.60]           < return
[ 362.61]          < return
[ 362.62]          > fib(n: uint32): uint32
[ 362.63]          < return
[ 362.64]         < return
[ 362.65]        < return
[ 362.66]        > fib(n: uint32): uint32
[ 362.67]         > fib(n: uint32): uint32
[ 362.69]          > fib(n: uint32): uint32
[ 362.71]           > fib(n: uint32): uint32
[ 362.72]           < return
[ 362.73]           > fib(n: uint32): uint32
[ 362.75]           < return
[ 362.75]          < return
[ 362.76]          > fib(n: uint32): uint32
[ 362.78]          < return
[ 362.79]         < return
[ 362.80]         > fib(n: uint32): uint32
[ 362.81]          > fib(n: uint32): uint32
[ 362.83]          < return
[ 362.84]          > fib(n: uint32): uint32
[ 362.85]          < return
[ 362.86]         < return
[ 362.87]        < return
[ 362.88]       < return
[ 362.89]       > fib(n: uint32): uint32
[ 362.90]        > fib(n: uint32): uint32
[ 362.92]         > fib(n: uint32): uint32
[ 362.94]          > fib(n: uint32): uint32
[ 362.98]           > fib(n: uint32): uint32
[ 363.00]           < return
[ 363.03]           > fib(n: uint32): uint32
[ 363.06]           < return
[ 363.07]          < return
[ 363.08]          > fib(n: uint32): uint32
[ 363.09]          < return
[ 363.10]         < return
[ 363.11]         > fib(n: uint32): uint32
[ 363.13]          > fib(n: uint32): uint32
[ 363.14]          < return
[ 363.15]          > fib(n: uint32): uint32
[ 363.17]          < return
[ 363.18]         < return
[ 363.19]        < return
[ 363.19]        > fib(n: uint32): uint32
[ 363.21]         > fib(n: uint32): uint32
[ 363.23]          > fib(n: uint32): uint32
[ 363.24]          < return
[ 363.25]          > fib(n: uint32): uint32
[ 363.27]          < return
[ 363.28]         < return
[ 363.29]         > fib(n: uint32): uint32
[ 363.30]         < return
[ 363.31]        < return
[ 363.32]       < return
[ 363.33]      < return
[ 363.33]     < return
[ 363.34]     > fib(n: uint32): uint32
[ 363.36]      > fib(n: uint32): uint32
[ 363.38]       > fib(n: uint32): uint32
[ 363.39]        > fib(n: uint32): uint32
[ 363.41]         > fib(n: uint32): uint32
[ 363.43]          > fib(n: uint32): uint32
[ 363.45]           > fib(n: uint32): uint32
[ 363.49]            > fib(n: uint32): uint32
[ 363.51]            < return
[ 363.52]            > fib(n: uint32): uint32
[ 363.54]            < return
[ 363.55]           < return
[ 363.56]           > fib(n: uint32): uint32
[ 363.58]           < return
[ 363.59]          < return
[ 363.60]          > fib(n: uint32): uint32
[ 363.61]           > fib(n: uint32): uint32
[ 363.63]           < return
[ 363.64]           > fib(n: uint32): uint32
[ 363.65]           < return
[ 363.66]          < return
[ 363.67]         < return
[ 363.68]         > fib(n: uint32): uint32
[ 363.69]          > fib(n: uint32): uint32
[ 363.71]           > fib(n: uint32): uint32
[ 363.73]           < return
[ 363.74]           > fib(n: uint32): uint32
[ 363.75]           < return
[ 363.76]          < return
[ 363.77]          > fib(n: uint32): uint32
[ 363.78]          < return
[ 363.79]         < return
[ 363.80]        < return
[ 363.81]        > fib(n: uint32): uint32
[ 363.83]         > fib(n: uint32): uint32
[ 363.84]          > fib(n: uint32): uint32
[ 363.86]           > fib(n: uint32): uint32
[ 363.87]           < return
[ 363.88]           > fib(n: uint32): uint32
[ 363.90]           < return
[ 363.91]          < return
[ 363.92]          > fib(n: uint32): uint32
[ 363.95]          < return
[ 363.96]         < return
[ 363.97]         > fib(n: uint32): uint32
[ 364.00]          > fib(n: uint32): uint32
[ 364.02]          < return
[ 364.03]          > fib(n: uint32): uint32
[ 364.04]          < return
[ 364.05]         < return
[ 364.06]        < return
[ 364.07]       < return
[ 364.08]       > fib(n: uint32): uint32
[ 364.09]        > fib(n: uint32): uint32
[ 364.11]         > fib(n: uint32): uint32
[ 364.12]          > fib(n: uint32): uint32
[ 364.14]           > fib(n: uint32): uint32
[ 364.15]           < return
[ 364.17]           > fib(n: uint32): uint32
[ 364.18]           < return
[ 364.19]          < return
[ 364.20]          > fib(n: uint32): uint32
[ 364.21]          < return
[ 364.22]         < return
[ 364.23]         > fib(n: uint32): uint32
[ 364.25]          > fib(n: uint32): uint32
[ 364.26]          < return
[ 364.27]          > fib(n: uint32): uint32
[ 364.29]          < return
[ 364.30]         < return
[ 364.30]        < return
[ 364.31]        > fib(n: uint32): uint32
[ 364.33]         > fib(n: uint32): uint32
[ 364.35]          > fib(n: uint32): uint32
[ 364.36]          < return
[ 364.37]          > fib(n: uint32): uint32
[ 364.41]          < return
[ 364.42]         < return
[ 364.43]         > fib(n: uint32): uint32
[ 364.46]         < return
[ 364.46]        < return
[ 364.47]       < return
[ 364.48]      < return
[ 364.49]      > fib(n: uint32): uint32
[ 364.51]       > fib(n: uint32): uint32
[ 364.52]        > fib(n: uint32): uint32
[ 364.54]         > fib(n: uint32): uint32
[ 364.56]          > fib(n: uint32): uint32
[ 364.57]           > fib(n: uint32): uint32
[ 364.59]           < return
[ 364.60]           > fib(n: uint32): uint32
[ 364.61]           < return
[ 364.62]          < return
[ 364.63]          > fib(n: uint32): uint32
[ 364.64]          < return
[ 364.65]         < return
[ 364.66]         > fib(n: uint32): uint32
[ 364.68]          > fib(n: uint32): uint32
[ 364.70]          < return
[ 364.71]          > fib(n: uint32): uint32
[ 364.72]          < return
[ 364.73]         < return
[ 364.74]        < return
[ 364.75]        > fib(n: uint32): uint32
[ 364.76]         > fib(n: uint32): uint32
[ 364.78]          > fib(n: uint32): uint32
[ 364.80]          < return
[ 364.81]          > fib(n: uint32): uint32
[ 364.82]          < return
[ 364.83]         < return
[ 364.84]         > fib(n: uint32): uint32
[ 364.89]         < return
[ 364.92]        < return
[ 364.94]       < return
[ 364.95]       > fib(n: uint32): uint32
[ 364.96]        > fib(n: uint32): uint32
[ 364.98]         > fib(n: uint32): uint32
[ 365.00]          > fib(n: uint32): uint32
[ 365.01]          < return
[ 365.02]          > fib(n: uint32): uint32
[ 365.04]          < return
[ 365.05]         < return
[ 365.06]         > fib(n: uint32): uint32
[ 365.07]         < return
[ 365.08]        < return
[ 365.09]        > fib(n: uint32): uint32
[ 365.10]         > fib(n: uint32): uint32
[ 365.12]         < return
[ 365.13]         > fib(n: uint32): uint32
[ 365.14]         < return
[ 365.15]        < return
[ 365.16]       < return
[ 365.17]      < return
[ 365.18]     < return
[ 365.19]    < return
[ 365.19]    > fib(n: uint32): uint32
[ 365.21]     > fib(n: uint32): uint32
[ 365.23]      > fib(n: uint32): uint32
[ 365.24]       > fib(n: uint32): uint32
[ 365.26]        > fib(n: uint32): uint32
[ 365.28]         > fib(n: uint32): uint32
[ 365.29]          > fib(n: uint32): uint32
[ 365.33]           > fib(n: uint32): uint32
[ 365.35]            > fib(n: uint32): uint32
[ 365.36]            < return
[ 365.38]            > fib(n: uint32): uint32
[ 365.40]            < return
[ 365.41]           < return
[ 365.42]           > fib(n: uint32): uint32
[ 365.43]           < return
[ 365.44]          < return
[ 365.45]          > fib(n: uint32): uint32
[ 365.47]           > fib(n: uint32): uint32
[ 365.48]           < return
[ 365.49]           > fib(n: uint32): uint32
[ 365.51]           < return
[ 365.52]          < return
[ 365.52]         < return
[ 365.53]         > fib(n: uint32): uint32
[ 365.55]          > fib(n: uint32): uint32
[ 365.57]           > fib(n: uint32): uint32
[ 365.58]           < return
[ 365.59]           > fib(n: uint32): uint32
[ 365.61]           < return
[ 365.61]          < return
[ 365.62]          > fib(n: uint32): uint32
[ 365.64]          < return
[ 365.65]         < return
[ 365.65]        < return
[ 365.67]        > fib(n: uint32): uint32
[ 365.68]         > fib(n: uint32): uint32
[ 365.70]          > fib(n: uint32): uint32
[ 365.71]           > fib(n: uint32): uint32
[ 365.73]           < return
[ 365.74]           > fib(n: uint32): uint32
[ 365.75]           < return
[ 365.78]          < return
[ 365.79]          > fib(n: uint32): uint32
[ 365.82]          < return
[ 365.83]         < return
[ 365.84]         > fib(n: uint32): uint32
[ 365.86]          > fib(n: uint32): uint32
[ 365.87]          < return
[ 365.90]          > fib(n: uint32): uint32
[ 365.91]          < return
[ 365.92]         < return
[ 365.93]        < return
[ 365.94]       < return
[ 365.95]       > fib(n: uint32): uint32
[ 365.96]        > fib(n: uint32): uint32
[ 365.98]         > fib(n: uint32): uint32
[ 366.00]          > fib(n: uint32): uint32
[ 366.01]           > fib(n: uint32): uint32
[ 366.03]           < return
[ 366.04]           > fib(n: uint32): uint32
[ 366.05]           < return
[ 366.06]          < return
[ 366.07]          > fib(n: uint32): uint32
[ 366.08]          < return
[ 366.10]         < return
[ 366.10]         > fib(n: uint32): uint32
[ 366.12]          > fib(n: uint32): uint32
[ 366.14]          < return
[ 366.15]          > fib(n: uint32): uint32
[ 366.16]          < return
[ 366.17]         < return
[ 366.18]        < return
[ 366.19]        > fib(n: uint32): uint32
[ 366.20]         > fib(n: uint32): uint32
[ 366.22]          > fib(n: uint32): uint32
[ 366.24]          < return
[ 366.26]          > fib(n: uint32): uint32
[ 366.28]          < return
[ 366.29]         < return
[ 366.30]         > fib(n: uint32): uint32
[ 366.33]         < return
[ 366.34]        < return
[ 366.35]       < return
[ 366.36]      < return
[ 366.37]      > fib(n: uint32): uint32
[ 366.38]       > fib(n: uint32): uint32
[ 366.40]        > fib(n: uint32): uint32
[ 366.42]         > fib(n: uint32): uint32
[ 366.43]          > fib(n: uint32): uint32
[ 366.45]           > fib(n: uint32): uint32
[ 366.46]           < return
[ 366.47]           > fib(n: uint32): uint32
[ 366.49]           < return
[ 366.50]          < return
[ 366.51]          > fib(n: uint32): uint32
[ 366.52]          < return
[ 366.53]         < return
[ 366.54]         > fib(n: uint32): uint32
[ 366.56]          > fib(n: uint32): uint32
[ 366.57]          < return
[ 366.58]          > fib(n: uint32): uint32
[ 366.59]          < return
[ 366.60]         < return
[ 366.61]        < return
[ 366.62]        > fib(n: uint32): uint32
[ 366.64]         > fib(n: uint32): uint32
[ 366.65]          > fib(n: uint32): uint32
[ 366.67]          < return
[ 366.68]          > fib(n: uint32): uint32
[ 366.71]          < return
[ 366.72]         < return
[ 366.73]         > fib(n: uint32): uint32
[ 366.75]         < return
[ 366.75]        < return
[ 366.78]       < return
[ 366.79]       > fib(n: uint32): uint32
[ 366.80]        > fib(n: uint32): uint32
[ 366.82]         > fib(n: uint32): uint32
[ 366.84]          > fib(n: uint32): uint32
[ 366.85]          < return
[ 366.86]          > fib(n: uint32): uint32
[ 366.87]          < return
[ 366.88]         < return
[ 366.89]         > fib(n: uint32): uint32
[ 366.91]         < return
[ 366.92]        < return
[ 366.93]        > fib(n: uint32): uint32
[ 366.94]         > fib(n: uint32): uint32
[ 366.96]         < return
[ 366.97]         > fib(n: uint32): uint32
[ 366.98]         < return
[ 366.99]        < return
[ 367.00]       < return
[ 367.01]      < return
[ 367.02]     < return
[ 367.02]     > fib(n: uint32): uint32
[ 367.04]      > fib(n: uint32): uint32
[ 367.06]       > fib(n: uint32): uint32
[ 367.07]        > fib(n: uint32): uint32
[ 367.09]         > fib(n: uint32): uint32
[ 367.11]          > fib(n: uint32): uint32
[ 367.12]           > fib(n: uint32): uint32
[ 367.14]           < return
[ 367.15]           > fib(n: uint32): uint32
[ 367.16]           < return
[ 367.19]          < return
[ 367.20]          > fib(n: uint32): uint32
[ 367.22]          < return
[ 367.23]         < return
[ 367.25]         > fib(n: uint32): uint32
[ 367.27]          > fib(n: uint32): uint32
[ 367.28]          < return
[ 367.29]          > fib(n: uint32): uint32
[ 367.31]          < return
[ 367.32]         < return
[ 367.32]        < return
[ 367.33]        > fib(n: uint32): uint32
[ 367.35]         > fib(n: uint32): uint32
[ 367.37]          > fib(n: uint32): uint32
[ 367.38]          < return
[ 367.39]          > fib(n: uint32): uint32
[ 367.41]          < return
[ 367.42]         < return
[ 367.42]         > fib(n: uint32): uint32
[ 367.44]         < return
[ 367.45]        < return
[ 367.46]       < return
[ 367.47]       > fib(n: uint32): uint32
[ 367.52]        > fib(n: uint32): uint32
[ 367.57]         > fib(n: uint32): uint32
[ 367.58]          > fib(n: uint32): uint32
[ 367.60]          < return
[ 367.61]          > fib(n: uint32): uint32
[ 367.62]          < return
[ 367.63]         < return
[ 367.64]         > fib(n: uint32): uint32
[ 367.66]         < return
[ 367.67]        < return
[ 367.68]        > fib(n: uint32): uint32
[ 367.71]         > fib(n: uint32): uint32
[ 367.74]         < return
[ 367.75]         > fib(n: uint32): uint32
[ 367.77]         < return
[ 367.77]        < return
[ 367.78]       < return
[ 367.79]      < return
[ 367.80]      > fib(n: uint32): uint32
[ 367.83]       > fib(n: uint32): uint32
[ 367.85]        > fib(n: uint32): uint32
[ 367.87]         > fib(n: uint32): uint32
[ 367.88]          > fib(n: uint32): uint32
[ 367.90]          < return
[ 367.91]          > fib(n: uint32): uint32
[ 367.92]          < return
[ 367.93]         < return
[ 367.94]         > fib(n: uint32): uint32
[ 367.96]         < return
[ 367.97]        < return
[ 367.98]        > fib(n: uint32): uint32
[ 367.99]         > fib(n: uint32): uint32
[ 368.01]         < return
[ 368.02]         > fib(n: uint32): uint32
[ 368.03]         < return
[ 368.04]        < return
[ 368.05]       < return
[ 368.06]       > fib(n: uint32): uint32
[ 368.07]        > fib(n: uint32): uint32
[ 368.09]         > fib(n: uint32): uint32
[ 368.11]         < return
[ 368.12]         > fib(n: uint32): uint32
[ 368.13]         < return
[ 368.14]        < return
[ 368.15]        > fib(n: uint32): uint32
[ 368.16]        < return
[ 368.17]       < return
[ 368.18]      < return
[ 368.19]     < return
[ 368.20]    < return
[ 368.21]   < return
[ 368.24]  < return
[ 368.31]  > typename.name(type: typename): .cstr
[ 368.34]  < return
[ 368.36]  > typename.file(type: typename): .cstr
[ 368.38]  < return
[ 368.39]  > typename.line(type: typename): int32
[ 368.41]  < return
[ 368.42]  > typename.base(type: typename): typename
[ 368.44]  < return
[ 368.45]  > typename.name(type: typename): .cstr
[ 368.47]  < return
[ 368.49]  > typename.file(type: typename): .cstr
[ 368.50]  < return
[ 368.51]  > typename.line(type: typename): int32
[ 368.53]  < return
[ 368.54]  > typename.base(type: typename): typename
[ 368.56]  < return
[ 368.58]  > typename.base(type: typename): typename
[ 368.60]  < return
[ 368.66]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.68]  < return
[ 368.70]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.72]  < return
[ 368.75]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.76]  < return
[ 368.77]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 368.79]  < return
[ 368.80]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 368.82]  < return
[ 368.83]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 368.85]  < return
[ 368.86]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.87]  < return
[ 368.88]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.90]  < return
[ 368.91]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 368.93]  < return
[ 368.94]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 368.95]  < return
[ 368.97]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 368.98]  < return
[ 368.99]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.01]  < return
[ 369.02]  > float64.sin(x: float64): float64
[ 369.05]  < return
[ 369.07]  > float64.cos(x: float64): float64
[ 369.09]  < return
[ 369.10]  > float64.tan(x: float64): float64
[ 369.12]  < return
[ 369.13]  > float64.log(x: float64): float64
[ 369.17]  < return
[ 369.18]  > float64.exp(x: float64): float64
[ 369.20]  < return
[ 369.22]  > float64.pow(x: float64, y: float64): float64
[ 369.24]  < return
[ 369.25]  > float64.sqrt(x: float64): float64
[ 369.27]  < return
[ 369.28]  > float64.atan2(x: float64, y: float64): float64
[ 369.30]  < return
[ 369.31]  > float32.sin(x: float32): float32
[ 369.33]  < return
[ 369.34]  > float32.cos(x: float32): float32
[ 369.35]  < return
[ 369.37]  > float32.tan(x: float32): float32
[ 369.38]  < return
[ 369.40]  > float32.log(x: float32): float32
[ 369.41]  < return
[ 369.43]  > float32.exp(x: float32): float32
[ 369.44]  < return
[ 369.45]  > float32.pow(x: float32, y: float32): float32
[ 369.47]  < return
[ 369.48]  > float32.sqrt(x: float32): float32
[ 369.50]  < return
[ 369.51]  > float32.atan2(x: float32, y: float32): float32
[ 369.52]  < return
[ 369.54]  > uint32.pop(value: int32): int32
[ 369.55]  < return
[ 369.56]  > uint32.swap(value: int32): int32
[ 369.58]  < return
[ 369.59]  > uint32.bsr(value: int32): int32
[ 369.64]  < return
[ 369.65]  > uint32.bsf(value: int32): int32
[ 369.67]  < return
[ 369.68]  > uint32.hib(value: int32): int32
[ 369.70]  < return
[ 369.71]  > uint32.lob(value: int32): int32
[ 369.74]  < return
[ 369.75]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 369.76]  < return
[ 369.77]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 369.79]  < return
[ 369.81]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 369.82]  < return
[ 369.83]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 369.85]  < return
[ 369.86]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 369.88]  < return
[ 369.89]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 369.91]  < return
[ 369.92]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 369.93]  < return
[ 369.94]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 369.96]  < return
[ 369.98]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.00]   > noError(ptr: pointer): void
[ 370.01]   < return
[ 370.02]   > halt(): void
[ 370.03]   < return
[ 370.04]  < return
[ 370.05]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.06]  < return
[ 370.10]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 370.11]   > stackOverflow(ptr: pointer): void
[ 370.13]    > stackOverflow(ptr: pointer): void
[ 370.16]     > stackOverflow(ptr: pointer): void
[ 370.17]      > stackOverflow(ptr: pointer): void
[ 370.19]       > stackOverflow(ptr: pointer): void
[ 370.20]        > stackOverflow(ptr: pointer): void
[ 370.22]         > stackOverflow(ptr: pointer): void
[ 370.23]          > stackOverflow(ptr: pointer): void
[ 370.25]           > stackOverflow(ptr: pointer): void
[ 370.27]            > stackOverflow(ptr: pointer): void
[ 370.29]             > stackOverflow(ptr: pointer): void
[ 370.30]              > stackOverflow(ptr: pointer): void
[ 370.32]               > stackOverflow(ptr: pointer): void
[ 370.33]                > stackOverflow(ptr: pointer): void
[ 370.35]                 > stackOverflow(ptr: pointer): void
[ 370.36]                  > stackOverflow(ptr: pointer): void
[ 370.38]                   > stackOverflow(ptr: pointer): void
[ 370.39]                    > stackOverflow(ptr: pointer): void
[ 370.41]                     > stackOverflow(ptr: pointer): void
[ 370.42]                      > stackOverflow(ptr: pointer): void
[ 370.44]                       > stackOverflow(ptr: pointer): void
[ 370.45]                        > stackOverflow(ptr: pointer): void
[ 370.47]                         > stackOverflow(ptr: pointer): void
[ 370.49]                          > stackOverflow(ptr: pointer): void
[ 370.50]                           > stackOverflow(ptr: pointer): void
[ 370.52]                            > stackOverflow(ptr: pointer): void
[ 370.53]                             > stackOverflow(ptr: pointer): void
[ 370.57]                              > stackOverflow(ptr: pointer): void
[ 370.60]                               > stackOverflow(ptr: pointer): void
[ 370.62]                                > stackOverflow(ptr: pointer): void
[ 370.63]                                 > stackOverflow(ptr: pointer): void
[ 370.65]                                  > stackOverflow(ptr: pointer): void
[ 370.68]                                   > stackOverflow(ptr: pointer): void
[ 370.69]                                    > stackOverflow(ptr: pointer): void
[ 370.71]                                     > stackOverflow(ptr: pointer): void
[ 370.72]                                      > stackOverflow(ptr: pointer): void
[ 370.74]                                       > stackOverflow(ptr: pointer): void
[ 370.75]                                        > stackOverflow(ptr: pointer): void
[ 370.77]                                         > stackOverflow(ptr: pointer): void
[ 370.78]                                          > stackOverflow(ptr: pointer): void
[ 370.80]                                           > stackOverflow(ptr: pointer): void
[ 370.81]                                            > stackOverflow(ptr: pointer): void
[ 370.83]                                             > stackOverflow(ptr: pointer): void
[ 370.84]                                              > stackOverflow(ptr: pointer): void
[ 370.86]                                               > stackOverflow(ptr: pointer): void
[ 370.88]                                                > stackOverflow(ptr: pointer): void
[ 370.89]                                                 > stackOverflow(ptr: pointer): void
[ 370.91]                                                  > stackOverflow(ptr: pointer): void
[ 370.92]                                                   > stackOverflow(ptr: pointer): void
[ 370.94]                                                    > stackOverflow(ptr: pointer): void
[ 370.95]                                                     > stackOverflow(ptr: pointer): void
[ 370.97]                                                      > stackOverflow(ptr: pointer): void
[ 370.99]                                                       > stackOverflow(ptr: pointer): void
[ 371.00]                                                        > stackOverflow(ptr: pointer): void
[ 371.04]                                                         > stackOverflow(ptr: pointer): void
[ 371.06]                                                          > stackOverflow(ptr: pointer): void
[ 371.07]                                                           > stackOverflow(ptr: pointer): void
[ 371.10]                                                            > stackOverflow(ptr: pointer): void
[ 371.12]                                                             > stackOverflow(ptr: pointer): void
[ 371.13]                                                              > stackOverflow(ptr: pointer): void
[ 371.15]                                                               > stackOverflow(ptr: pointer): void
[ 371.16]                                                                > stackOverflow(ptr: pointer): void
[ 371.18]                                                                 > stackOverflow(ptr: pointer): void
[ 371.19]                                                                  > stackOverflow(ptr: pointer): void
[ 371.21]                                                                   > stackOverflow(ptr: pointer): void
[ 371.22]                                                                    > stackOverflow(ptr: pointer): void
[ 371.24]                                                                     > stackOverflow(ptr: pointer): void
[ 371.25]                                                                      > stackOverflow(ptr: pointer): void
[ 371.27]                                                                       > stackOverflow(ptr: pointer): void
[ 371.28]                                                                        > stackOverflow(ptr: pointer): void
[ 371.30]                                                                         > stackOverflow(ptr: pointer): void
[ 371.31]                                                                          > stackOverflow(ptr: pointer): void
[ 371.33]                                                                           > stackOverflow(ptr: pointer): void
[ 371.35]                                                                            > stackOverflow(ptr: pointer): void
[ 371.36]                                                                             > stackOverflow(ptr: pointer): void
[ 371.38]                                                                              > stackOverflow(ptr: pointer): void
[ 371.39]                                                                               > stackOverflow(ptr: pointer): void
[ 371.41]                                                                                > stackOverflow(ptr: pointer): void
[ 371.42]                                                                                 > stackOverflow(ptr: pointer): void
[ 371.44]                                                                                  > stackOverflow(ptr: pointer): void
[ 371.46]                                                                                   > stackOverflow(ptr: pointer): void
[ 371.50]                                                                                    > stackOverflow(ptr: pointer): void
[ 371.51]                                                                                     > stackOverflow(ptr: pointer): void
[ 371.55]                                                                                      > stackOverflow(ptr: pointer): void
[ 371.56]                                                                                       > stackOverflow(ptr: pointer): void
[ 371.58]                                                                                        > stackOverflow(ptr: pointer): void
[ 371.59]                                                                                         > stackOverflow(ptr: pointer): void
[ 371.62]                                                                                          > stackOverflow(ptr: pointer): void
[ 371.64]                                                                                           > stackOverflow(ptr: pointer): void
[ 371.65]                                                                                            > stackOverflow(ptr: pointer): void
[ 371.67]                                                                                             > stackOverflow(ptr: pointer): void
[ 371.68]                                                                                              > stackOverflow(ptr: pointer): void
[ 371.70]                                                                                               > stackOverflow(ptr: pointer): void
[ 371.71]                                                                                                > stackOverflow(ptr: pointer): void
[ 371.73]                                                                                                 > stackOverflow(ptr: pointer): void
[ 371.75]                                                                                                  > stackOverflow(ptr: pointer): void
[ 371.76]                                                                                                   > stackOverflow(ptr: pointer): void
[ 371.78]                                                                                                    > stackOverflow(ptr: pointer): void
[ 371.79]                                                                                                     > stackOverflow(ptr: pointer): void
[ 371.81]                                                                                                      > stackOverflow(ptr: pointer): void
[ 371.82]                                                                                                       > stackOverflow(ptr: pointer): void
[ 371.84]                                                                                                        > stackOverflow(ptr: pointer): void
[ 371.85]                                                                                                         > stackOverflow(ptr: pointer): void
[ 371.87]                                                                                                          > stackOverflow(ptr: pointer): void
[ 371.88]                                                                                                           > stackOverflow(ptr: pointer): void
[ 371.90]                                                                                                            > stackOverflow(ptr: pointer): void
[ 371.92]                                                                                                             > stackOverflow(ptr: pointer): void
[ 371.93]                                                                                                              > stackOverflow(ptr: pointer): void
[ 371.95]                                                                                                               > stackOverflow(ptr: pointer): void
[ 371.96]                                                                                                                > stackOverflow(ptr: pointer): void
[ 371.98]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 372.03]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 372.05]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 372.06]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 372.08]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 372.10]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 372.11]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 372.13]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 372.16]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 372.17]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 372.19]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 372.20]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 372.22]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 372.24]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 372.25]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 372.27]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 372.28]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 372.30]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 372.31]                                                                                                                                  < return
[ 372.32]                                                                                                                                 < return
[ 372.33]                                                                                                                                < return
[ 372.33]                                                                                                                               < return
[ 372.34]                                                                                                                              < return
[ 372.35]                                                                                                                             < return
[ 372.36]                                                                                                                            < return
[ 372.37]                                                                                                                           < return
[ 372.38]                                                                                                                          < return
[ 372.38]                                                                                                                         < return
[ 372.39]                                                                                                                        < return
[ 372.40]                                                                                                                       < return
[ 372.41]                                                                                                                      < return
[ 372.42]                                                                                                                     < return
[ 372.42]                                                                                                                    < return
[ 372.43]                                                                                                                   < return
[ 372.44]                                                                                                                  < return
[ 372.45]                                                                                                                 < return
[ 372.46]                                                                                                                < return
[ 372.49]                                                                                                               < return
[ 372.49]                                                                                                              < return
[ 372.50]                                                                                                             < return
[ 372.51]                                                                                                            < return
[ 372.52]                                                                                                           < return
[ 372.53]                                                                                                          < return
[ 372.54]                                                                                                         < return
[ 372.54]                                                                                                        < return
[ 372.55]                                                                                                       < return
[ 372.56]                                                                                                      < return
[ 372.57]                                                                                                     < return
[ 372.57]                                                                                                    < return
[ 372.58]                                                                                                   < return
[ 372.59]                                                                                                  < return
[ 372.60]                                                                                                 < return
[ 372.61]                                                                                                < return
[ 372.62]                                                                                               < return
[ 372.62]                                                                                              < return
[ 372.63]                                                                                             < return
[ 372.64]                                                                                            < return
[ 372.65]                                                                                           < return
[ 372.66]                                                                                          < return
[ 372.68]                                                                                         < return
[ 372.69]                                                                                        < return
[ 372.70]                                                                                       < return
[ 372.71]                                                                                      < return
[ 372.71]                                                                                     < return
[ 372.73]                                                                                    < return
[ 372.74]                                                                                   < return
[ 372.75]                                                                                  < return
[ 372.76]                                                                                 < return
[ 372.77]                                                                                < return
[ 372.78]                                                                               < return
[ 372.79]                                                                              < return
[ 372.79]                                                                             < return
[ 372.80]                                                                            < return
[ 372.81]                                                                           < return
[ 372.82]                                                                          < return
[ 372.82]                                                                         < return
[ 372.83]                                                                        < return
[ 372.84]                                                                       < return
[ 372.85]                                                                      < return
[ 372.86]                                                                     < return
[ 372.86]                                                                    < return
[ 372.87]                                                                   < return
[ 372.88]                                                                  < return
[ 372.89]                                                                 < return
[ 372.89]                                                                < return
[ 372.90]                                                               < return
[ 372.91]                                                              < return
[ 372.92]                                                             < return
[ 372.93]                                                            < return
[ 372.96]                                                           < return
[ 372.98]                                                          < return
[ 372.99]                                                         < return
[ 372.99]                                                        < return
[ 373.00]                                                       < return
[ 373.01]                                                      < return
[ 373.02]                                                     < return
[ 373.03]                                                    < return
[ 373.03]                                                   < return
[ 373.04]                                                  < return
[ 373.05]                                                 < return
[ 373.06]                                                < return
[ 373.06]                                               < return
[ 373.07]                                              < return
[ 373.08]                                             < return
[ 373.09]                                            < return
[ 373.11]                                           < return
[ 373.12]                                          < return
[ 373.13]                                         < return
[ 373.13]                                        < return
[ 373.14]                                       < return
[ 373.15]                                      < return
[ 373.16]                                     < return
[ 373.17]                                    < return
[ 373.18]                                   < return
[ 373.18]                                  < return
[ 373.19]                                 < return
[ 373.20]                                < return
[ 373.20]                               < return
[ 373.21]                              < return
[ 373.22]                             < return
[ 373.23]                            < return
[ 373.24]                           < return
[ 373.24]                          < return
[ 373.25]                         < return
[ 373.26]                        < return
[ 373.27]                       < return
[ 373.27]                      < return
[ 373.28]                     < return
[ 373.29]                    < return
[ 373.30]                   < return
[ 373.31]                  < return
[ 373.31]                 < return
[ 373.32]                < return
[ 373.33]               < return
[ 373.34]              < return
[ 373.34]             < return
[ 373.35]            < return
[ 373.36]           < return
[ 373.37]          < return
[ 373.38]         < return
[ 373.38]        < return
[ 373.39]       < return
[ 373.40]      < return
[ 373.40]     < return
[ 373.41]    < return
[ 373.44]   < return
[ 373.45]  < return
[ 373.46]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 373.48]   > divisionByZero(args: pointer): void
[ 373.51]   < return
[ 373.51]  < return
[ 373.52]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 373.54]   > invalidInstruction(args: pointer): void
[ 373.55]   < return
[ 373.56]  < return
[ 373.57]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 373.58]   > invalidMemoryAccess(args: pointer): void
[ 373.60]   < return
[ 373.61]  < return
[ 373.62]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 373.63]   > abortExecution(args: pointer): void
[ 373.65]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	test/std/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 373.77]    < return
[ 373.78]   < return
[ 373.79]  < return
[ 375.49]  > Math.floor(x: float64): float64
[ 375.50]   > Math.modf(x: float64, intPart: float64): float64
[ 375.52]   < return
[ 375.52]  < return
[ 375.54]  > Math.floor(x: float64): float64
[ 375.55]   > Math.modf(x: float64, intPart: float64): float64
[ 375.56]   < return
[ 375.57]  < return
[ 375.58]  > Math.floor(x: float64): float64
[ 375.59]   > Math.modf(x: float64, intPart: float64): float64
[ 375.61]   < return
[ 375.61]  < return
[ 375.63]  > Math.floor(x: float64): float64
[ 375.64]   > Math.modf(x: float64, intPart: float64): float64
[ 375.65]    > Math.modf(x: float64, intPart: float64): float64
[ 375.66]    < return
[ 375.67]   < return
[ 375.68]  < return
[ 375.69]  > Math.floor(x: float64): float64
[ 375.70]   > Math.modf(x: float64, intPart: float64): float64
[ 375.71]    > Math.modf(x: float64, intPart: float64): float64
[ 375.72]    < return
[ 375.73]   < return
[ 375.74]  < return
[ 375.75]  > Math.floor(x: float64): float64
[ 375.76]   > Math.modf(x: float64, intPart: float64): float64
[ 375.77]    > Math.modf(x: float64, intPart: float64): float64
[ 375.78]    < return
[ 375.79]   < return
[ 375.80]  < return
[ 375.94]  > Math.abs(x: float64): float64
[ 375.95]  < return
[ 375.97]  > Math.abs(x: float64): float64
[ 375.98]  < return
[ 376.00]  > Math.abs(x: float64): float64
[ 376.02]  < return
[ 376.04]  > Math.abs(x: float32): float32
[ 376.05]  < return
[ 376.06]  > Math.abs(x: float32): float32
[ 376.07]  < return
[ 376.09]  > Math.abs(x: float32): float32
[ 376.10]  < return
[ 376.12]  > Math.min(a: float32, b: float32): float32
[ 376.13]  < return
[ 376.15]  > Math.max(a: float32, b: float32): float32
[ 376.16]  < return
[ 376.18]  > Math.min(a: float64, b: float64): float64
[ 376.19]  < return
[ 376.20]  > Math.max(a: float64, b: float64): float64
[ 376.21]  < return
[ 376.23]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 376.24]  < return
[ 376.26]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 376.27]  < return
[ 376.33]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 376.34]  < return
[ 376.40]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 376.41]  < return
[ 376.46]  > Math.min(data: float64[]): float64
[ 376.47]  < return
[ 376.50]  > Math.min(data: float64[]): float64
[ 376.56]  < return
[ 376.58]  > Math.max(data: float64[]): float64
[ 376.59]  < return
[ 376.62]  > Math.max(data: float64[]): float64
[ 376.67]  < return
[ 376.69]  > Math.sum(data: float64[]): float64
[ 376.71]  < return
[ 376.73]  > Math.sum(data: float64[]): float64
[ 376.75]  < return
[ 376.77]  > Math.sum(data: float64[]): float64
[ 376.79]  < return
[ 376.83]  > Math.sum(data: float64[]): float64
[ 376.93]  < return
[ 376.95]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 376.96]  < return
[ 377.04]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 377.08]  < return
[ 377.11]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 377.15]  < return
[ 377.17]  > Math.sinCos(arg: float64, quad: int32): float64
[ 377.21]  < return
[ 377.23]  > Math.abs(x: float64): float64
[ 377.24]  < return
[ 377.25]  > Math.sinCos(arg: float64, quad: int32): float64
[ 377.29]  < return
[ 377.31]  > Math.tan(arg: float64): float64
[ 377.34]   > Math.modf(x: float64, intPart: float64): float64
[ 377.35]   < return
[ 377.38]  < return
[ 377.40]  > Math.sinh(x: float64): float64
[ 377.42]   > float64.exp(x: float64): float64
[ 377.44]   < return
[ 377.45]   > float64.exp(x: float64): float64
[ 377.47]   < return
[ 377.50]  < return
[ 377.52]  > Math.cosh(x: float64): float64
[ 377.53]   > float64.exp(x: float64): float64
[ 377.55]   < return
[ 377.55]   > float64.exp(x: float64): float64
[ 377.57]   < return
[ 377.57]  < return
[ 377.59]  > Math.asin(x: float64): float64
[ 377.61]   > float64.sqrt(x: float64): float64
[ 377.62]   < return
[ 377.63]   > float64.atan2(x: float64, y: float64): float64
[ 377.65]   < return
[ 377.66]  < return
[ 377.68]  > Math.asin(x: float64): float64
[ 377.69]   > float64.sqrt(x: float64): float64
[ 377.71]   < return
[ 377.72]   > float64.atan2(x: float64, y: float64): float64
[ 377.73]   < return
[ 377.74]  < return
[ 377.76]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 377.80]  < return
[ 377.83]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 377.85]  < return
[ 377.87]  > Math.absMod(val: float64, mod: float64): float64
[ 377.88]  < return
[ 377.91]  > Math.absMod(val: float64, mod: float64): float64
[ 377.92]  < return
[ 377.95]  > Math.absMod(val: float64, mod: float64): float64
[ 377.96]  < return
[ 377.98]  > Math.absMod(val: float64, mod: float64): float64
[ 377.99]  < return
[ 378.02]  > Math.absMod(val: float64, mod: float64): float64
[ 378.03]  < return
[ 378.04]  > Math.absMod(val: float64, mod: float64): float64
[ 378.05]  < return
[ 378.07]  > Math.absMod(val: float64, mod: float64): float64
[ 378.08]  < return
[ 378.11]  > Math.absMod(val: float64, mod: float64): float64
[ 378.13]  < return
[ 378.17]  > Math.absMod(val: float64, mod: float64): float64
[ 378.18]  < return
[ 378.19]  > Math.absMod(val: float64, mod: float64): float64
[ 378.20]  < return
[ 378.22]  > Math.absMod(val: float64, mod: float64): float64
[ 378.23]  < return
[ 378.24]  > Math.absMod(val: float32, mod: float32): float32
[ 378.25]  < return
[ 378.27]  > Math.absMod(val: float32, mod: float32): float32
[ 378.30]  < return
[ 378.32]  > Math.absMod(val: float32, mod: float32): float32
[ 378.36]  < return
[ 378.38]  > Math.absMod(val: float32, mod: float32): float32
[ 378.38]  < return
[ 378.40]  > Math.absMod(val: float32, mod: float32): float32
[ 378.42]  < return
[ 378.45]  > Math.absMod(val: float32, mod: float32): float32
[ 378.46]  < return
[ 378.49]  > Math.absMod(val: float32, mod: float32): float32
[ 378.50]  < return
[ 378.51]  > Math.absMod(val: float32, mod: float32): float32
[ 378.54]  < return
[ 378.57]  > Math.absMod(val: float32, mod: float32): float32
[ 378.58]  < return
[ 378.60]  > Math.absMod(val: float32, mod: float32): float32
[ 378.61]  < return
[ 378.62]  > Math.absMod(val: float32, mod: float32): float32
[ 378.65]  < return
[ 378.66]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 378.69]  < return
[ 378.71]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 378.74]  < return
[ 378.75]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 378.77]  < return
[ 378.78]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 378.80]  < return
[ 378.81]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 378.83]  < return
[ 378.86]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 378.89]  < return
[ 378.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:26: debug: val1: int64(42)
[ 378.95]  < return
[ 378.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:27: debug: val2: int64(96)
[ 379.01]  < return
[ 379.02]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 379.06]  < return
[ 379.07]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 379.10]  < return
[ 379.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:32: debug: val1: int64(0)
[ 379.16]  < return
[ 379.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/std/memory.ci:33: debug: val2: int64(42)
[ 379.20]  < return
[ 379.39]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 379.44]  < return
[ 379.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 379.57]  < return
[ 379.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 379.69]  < return
[ 379.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 379.75]  < return
[ 379.77]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 379.81]  < return
[ 379.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 379.87]  < return
[ 379.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 379.92]  < return
[ 379.95]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 379.96]  < return
[ 380.01]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.04]  < return
[ 380.06]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.08]  < return
[ 380.10]  > lenSlice(values: int64[]): int32
[ 380.13]  < return
[ 380.15]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.17]  < return
[ 380.18]  > lenSlice(values: int64[]): int32
[ 380.21]  < return
[ 380.22]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.25]  < return
[ 380.28]  > lenSlice(values: int64[]): int32
[ 380.29]  < return
[ 380.31]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.32]  < return
[ 380.35]  > lenSlice(values: int64[]): int32
[ 380.37]  < return
[ 380.38]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.40]  < return
[ 380.42]  > lenSlice(values: int64[]): int32
[ 380.45]  < return
[ 380.46]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 380.47]  < return
[ 380.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.57]  < return
[ 380.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.65]  < return
[ 380.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 380.71]  < return
[ 380.73]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.76]  < return
[ 380.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.80]  < return
[ 380.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 380.87]  < return
[ 380.89]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.91]  < return
[ 380.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 380.97]  < return
[ 381.07]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.09]  < return
[ 381.11]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.13]  < return
[ 381.17]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.21]  < return
[ 381.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.25]  < return
[ 381.28]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.29]  < return
[ 381.33]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.35]  < return
[ 381.38]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.40]  < return
[ 381.44]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.45]  < return
[ 381.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.58]  < return
[ 381.60]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.62]  < return
[ 381.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 381.66]  < return
[ 381.70]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.74]  < return
[ 381.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.81]  < return
[ 381.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 381.85]  < return
[ 381.90]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.92]  < return
[ 381.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 381.95]  < return
[ 382.05]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.08]  < return
[ 382.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.12]  < return
[ 382.14]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.16]  < return
[ 382.18]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.20]  < return
[ 382.22]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.27]  < return
[ 382.30]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.33]  < return
[ 382.37]  > nthSlice(idx: int32, values: int64[]): int64
[ 382.38]  < return
[ 382.40]  > nthSlice(idx: int32, values: int64[]): int64
[ 382.42]  < return
[ 382.53]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.55]  < return
[ 382.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.59]  < return
[ 382.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 382.63]  < return
[ 382.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.67]  < return
[ 382.69]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.71]  < return
[ 382.73]  > nthArray(idx: int32, values: int64[*]): int64
[ 382.77]  < return
[ 382.81]  > nthSlice(idx: int32, values: int64[]): int64
[ 382.82]  < return
[ 382.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 382.87]  < return
[ 383.00]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.03]  < return
[ 383.06]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.07]  < return
[ 383.09]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.12]  < return
[ 383.15]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.18]  < return
[ 383.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.22]  < return
[ 383.24]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.25]  < return
[ 383.30]  > nthSlice(idx: int32, values: int64[]): int64
[ 383.33]  < return
[ 383.38]  > nthSlice(idx: int32, values: int64[]): int64
[ 383.41]  < return
[ 383.55]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.57]  < return
[ 383.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.65]  < return
[ 383.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 383.70]  < return
[ 383.73]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.76]  < return
[ 383.78]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.80]  < return
[ 383.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 383.85]  < return
[ 383.89]  > nthSlice(idx: int32, values: int64[]): int64
[ 383.91]  < return
[ 383.93]  > nthSlice(idx: int32, values: int64[]): int64
[ 383.95]  < return
[ 384.03]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 384.05]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 384.17]   < return
[ 384.18]  < return
[ 384.20]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 384.22]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 384.35]   < return
[ 384.36]  < return
[ 384.38]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 384.39]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 384.41]   < return
[ 384.42]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 384.44]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 384.65]    < return
[ 384.66]   < return
[ 384.67]  < return
[ 384.68]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 384.70]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 384.73]   < return
[ 384.76]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 384.77]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 384.93]    < return
[ 384.94]   < return
[ 384.95]  < return
[ 384.96]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 384.98]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 385.13]   < return
[ 385.14]  < return
[ 385.16]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 385.18]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 385.28]   < return
[ 385.29]  < return
[ 385.31]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 385.33]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 385.45]   < return
[ 385.46]  < return
[ 385.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 385.50]  < return
[ 385.52]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 385.54]  < return
[ 385.58]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 385.63]  < return
[ 385.66]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 385.69]  < return
[ 385.73]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 385.76]  < return
[ 385.79]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 385.82]  < return
[ 385.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 385.89]  < return
[ 385.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 385.96]  < return
[ 385.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 386.03]  < return
[ 386.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 386.08]  < return
[ 386.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 386.19]  < return
[ 386.22]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 386.25]  < return
[ 386.36]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 386.39]  < return
[ 386.43]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 386.45]  < return
[ 386.50]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 386.53]  < return
[ 386.57]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 386.59]  < return
[ 386.65]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 386.68]  < return
[ 386.77]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 386.80]  < return
[ 386.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 386.88]  < return
[ 386.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 386.97]  < return
[ 387.00]  > halt(): void
[ 387.00]  < return
[ 387.01] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
lib/std/debug.ci:48: NotEquals: typename(<NotEquals>)
lib/std/debug.ci:64: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:238: Math.mean: function(<Math.mean>)
lib/std/math.ci:255: Math.eval: function(<Math.eval>)
lib/std/math.ci:264: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:279: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:294: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:351: Math.tan: function(<Math.tan>)
lib/std/math.ci:408: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:447: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:462: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math/Complex.ci:2: Complex: typename(<Complex>)
lib/std/math/Complex.ci:24: Complex: function(<Complex>)
lib/std/math/Complex.ci:31: Complex: function(<Complex>)
lib/std/math/Complex.ci:86: div: function(<div>)
lib/std/math/Complex.ci:117: inv: function(<inv>)
lib/std/math/Complex.ci:135: pow: function(<pow>)
lib/std/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
lib/std/math/Vector4f.ci:26: vec4f: function(<vec4f>)
lib/std/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
lib/std/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
lib/std/math/Matrix4f.ci:87: transpose: function(<transpose>)
lib/std/math/Matrix4f.ci:97: mul: function(<mul>)
lib/std/math/Matrix4f.ci:111: rotation: function(<rotation>)
lib/std/math/Matrix4f.ci:163: translation: function(<translation>)
lib/std/math/Matrix4f.ci:173: scale: function(<scale>)
lib/std/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
lib/std/math/Vector2d.ci:14: vec2d: function(<vec2d>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:112: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:127: append: function(<append>)
lib/std/string.ci:144: append: function(<append>)
lib/std/string.ci:234: append: function(<append>)
lib/std/string.ci:262: append: function(<append>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(255048)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(254744)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/std/number.ci:3: pi64: float64(3.141593)
test/std/number.ci:4: e64: float64(2.718282)
test/std/number.ci:6: pi32: float32(3.141593)
test/std/number.ci:7: e32: float32(2.718282)
test/std/number.ci:14: r_comp: int32(112)
test/std/number.ci:15: g_comp: int32(252)
test/std/number.ci:16: b_comp: int32(248)
test/std/number.ci:18: r5g6b5: int32(30719)
test/std/number.ci:19: r8g8b8: int32(7404792)
test/std/number.ci:21: zxtR5: int32(14)
test/std/number.ci:22: zxtG6: int32(63)
test/std/number.ci:23: zxtB5: int32(31)
test/std/number.ci:25: sxtR5: int32(14)
test/std/number.ci:26: sxtG6: int32(-1)
test/std/number.ci:27: sxtB5: int32(-1)
test/std/number.ci:29: zxtR8: int32(112)
test/std/number.ci:30: zxtG8: int32(252)
test/std/number.ci:31: zxtB8: int32(248)
test/std/number.ci:33: sxtR8: int32(112)
test/std/number.ci:34: sxtG8: int32(-4)
test/std/number.ci:35: sxtB8: int32(-8)
test/std/number.ci:37: testSin_f64: float64(1.000000)
test/std/number.ci:38: testCos_f64: float64(0.000000)
test/std/number.ci:39: testTan_f64: float64(1.000000)
test/std/number.ci:40: testLog_f64: float64(3.000000)
test/std/number.ci:41: testExp_f64: float64(2.718282)
test/std/number.ci:42: testPow_f64: float64(3.141593)
test/std/number.ci:43: testSqrt_f64: float64(3.141593)
test/std/number.ci:44: testAtan_f64: float64(1.262627)
test/std/number.ci:46: testSin_f32: float32(1.000000)
test/std/number.ci:47: testCos_f32: float32(-0.000000)
test/std/number.ci:48: testTan_f32: float32(1.000000)
test/std/number.ci:49: testLog_f32: float32(3.000000)
test/std/number.ci:50: testExp_f32: float32(2.718282)
test/std/number.ci:51: testPow_f32: float32(3.141593)
test/std/number.ci:52: testSqrt_f32: float32(3.141593)
test/std/number.ci:53: testAtan_f32: float32(1.262627)
test/std/number.ci:55: testPopulation_u32: int32(14)
test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/std/number.ci:57: testBitScanReverse_u32: int32(14)
test/std/number.ci:58: testBitScanForward_u32: int32(0)
test/std/number.ci:59: testHighBit_u32: int32(16384)
test/std/number.ci:60: testLowBit_u32: int32(1)
test/std/number.ci:62: testZeroExtend_u32: int32(31)
test/std/number.ci:63: testSignExtend_u32: int32(-1)
test/std/number.ci:65: testZeroExtend_u64: int32(31)
test/std/number.ci:66: testSignExtend_u64: int32(-1)
test/std/memory.ci:7: p1: pointer(<?>)
test/std/memory.ci:8: p2: pointer(<?>)
test/std/memory.ci:9: p3: pointer(<?>)
test/std/memory.ci:10: p4: pointer(<?>)
test/std/memory.ci:23: val1: int64(0)
test/std/memory.ci:24: val2: int64(42)
test/std/tryExec.ci:11: noError: function(<noError>)
test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/std/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/std/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/std/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/std/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/std/tryExec.ci:46: tryExecErr0: int32(0)
test/std/tryExec.ci:47: tryExecErr1: int32(1)
test/std/tryExec.ci:48: tryExecErr2: int32(2)
test/std/tryExec.ci:49: tryExecErr3: int32(3)
test/std/tryExec.ci:50: tryExecErr4: int32(4)
test/std/tryExec.ci:51: tryExecErr5: int32(5)
test/std/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(0)
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(255),
		r: uint8(0)
	})
})
test/lang/recUnion.ci:31: blue: color({
	col: uint32(255),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(0),
		r: uint8(0)
	})
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/std/test.math.ci:67: testMathCmp_f32: bool(1)
test/std/test.math.ci:68: testMathCmp_f64: bool(1)
test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194024(4.0 Mb)
memory[used] @000000; size: 383206(374.2 Kb)
memory[heap] @05d8e6; size: 2762264(2.6 Mb)
memory[stack] @1fff44; size: 1048506(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 357744(349.4 Kb)
memory[code] @000000; size: 20292(19.8 Kb)
memory[data] @000000; size: 2674(2.6 Kb)

---------- heap memory:
memory[free] @05d8f8; size: 2762224(2.6 Mb)

---------- Profile functions: 79/121, coverage: 65.29%
::[.005a38, .005a38): exec(2), time(0.017 ms): halt(): void
::[.005cd8, .005cd8): exec(0), time(0.000 ms): variant.is(var: variant, type: typename): bool
::[.005f70, .005f70): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.0062b0, .0062b0): exec(3), time(0.052 ms): typename.base(type: typename): typename
::[.0064b0, .0064b0): exec(2), time(0.036 ms): typename.file(type: typename): .cstr
::[.0066b0, .0066b0): exec(2), time(0.037 ms): typename.line(type: typename): int32
::[.0068b0, .0068b0): exec(2), time(0.044 ms): typename.name(type: typename): .cstr
::[.006b50, .006b50): exec(0), time(0.000 ms): object.create(type: typename): pointer
::[.006de8, .006de8): exec(0), time(0.000 ms): object.as(obj: object, type: typename): pointer
::[.0075a8, .0075a8): exec(40), time(2.244 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.007e88, .007e88): exec(7), time(3.733 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.008128, .008128): exec(8), time(0.127 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008460, .008460): exec(2), time(0.047 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.008798, .008798): exec(2), time(0.083 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008ac8, .008ac8): exec(1), time(0.030 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.008d70, .008d70): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.008f78, .008f78): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.0090e0, .0090e0): exec(0), time(0.000 ms): System.rand(): int32
::[.009248, .009248): exec(0), time(0.000 ms): System.time(): int32
::[.0093b0, .0093b0): exec(0), time(0.000 ms): System.clock(): int32
::[.009518, .009518): exec(0), time(0.000 ms): System.millis(): int64
::[.009718, .009718): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.009a50, .009a50): exec(7), time(0.108 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.009d80, .009d80): exec(7), time(0.108 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.009f80, .009f80): exec(1), time(0.015 ms): uint32.pop(value: int32): int32
::[.00a180, .00a180): exec(1), time(0.015 ms): uint32.swap(value: int32): int32
::[.00a380, .00a380): exec(1), time(0.039 ms): uint32.bsr(value: int32): int32
::[.00a580, .00a580): exec(1), time(0.016 ms): uint32.bsf(value: int32): int32
::[.00a780, .00a780): exec(1), time(0.016 ms): uint32.hib(value: int32): int32
::[.00a980, .00a980): exec(1), time(0.028 ms): uint32.lob(value: int32): int32
::[.00aca8, .00aca8): exec(1), time(0.016 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00afd0, .00afd0): exec(1), time(0.015 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00b1d0, .00b1d0): exec(1), time(0.016 ms): float32.sin(x: float32): float32
::[.00b3d0, .00b3d0): exec(1), time(0.015 ms): float32.cos(x: float32): float32
::[.00b5d0, .00b5d0): exec(1), time(0.018 ms): float32.tan(x: float32): float32
::[.00b7d0, .00b7d0): exec(1), time(0.015 ms): float32.log(x: float32): float32
::[.00b9d0, .00b9d0): exec(1), time(0.015 ms): float32.exp(x: float32): float32
::[.00bc68, .00bc68): exec(1), time(0.016 ms): float32.pow(x: float32, y: float32): float32
::[.00be68, .00be68): exec(1), time(0.015 ms): float32.sqrt(x: float32): float32
::[.00c100, .00c100): exec(1), time(0.018 ms): float32.atan2(x: float32, y: float32): float32
::[.00c2f8, .00c2f8): exec(1), time(0.032 ms): float64.sin(x: float64): float64
::[.00c4f0, .00c4f0): exec(1), time(0.021 ms): float64.cos(x: float64): float64
::[.00c6e8, .00c6e8): exec(1), time(0.016 ms): float64.tan(x: float64): float64
::[.00c8e0, .00c8e0): exec(1), time(0.038 ms): float64.log(x: float64): float64
::[.00cad8, .00cad8): exec(5), time(0.086 ms): float64.exp(x: float64): float64
::[.00cd68, .00cd68): exec(1), time(0.018 ms): float64.pow(x: float64, y: float64): float64
::[.00cf60, .00cf60): exec(3), time(0.043 ms): float64.sqrt(x: float64): float64
::[.00d1f0, .00d1f0): exec(3), time(0.047 ms): float64.atan2(x: float64, y: float64): float64
lib/std/debug.ci:64:[.057570, .0575ce): exec(8), time(0.153 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.0575d0, .057626): exec(10), time(0.136 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.057628, .057640): exec(6), time(0.234-0.123 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.057640, .057652): exec(3), time(0.030 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.057658, .05766a): exec(4), time(0.057 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.057670, .05768b): exec(11), time(0.181 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.057690, .0576ab): exec(11), time(0.117 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.0576b0, .0576c1): exec(1), time(0.011 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.0576c8, .0576d9): exec(1), time(0.010 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.0576e0, .0576f1): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.0576f8, .057709): exec(1), time(0.011 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.057710, .05772e): exec(2), time(0.025 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.057730, .05774e): exec(2), time(0.025 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.057750, .05779f): exec(2), time(0.068 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.0577a0, .0577ef): exec(2), time(0.067 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.0577f0, .057818): exec(4), time(0.162 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:238:[.057818, .05782c): exec(0), time(0.000 ms): Math.mean(data: float64[]): float64
lib/std/math.ci:255:[.057830, .05785f): exec(3), time(0.100 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:264:[.057860, .057899): exec(1), time(0.036 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:279:[.0578a0, .0578d9): exec(1), time(0.014 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:294:[.0578e0, .057a2f): exec(2), time(0.073 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:351:[.057a30, .057baa): exec(1), time(0.078-0.013 ms): Math.tan(arg: float64): float64
lib/std/math.ci:408:[.057bb0, .057ca1): exec(1), time(0.094-0.041 ms): Math.sinh(x: float64): float64
lib/std/math.ci:447:[.057ca8, .057cf3): exec(1), time(0.058-0.029 ms): Math.cosh(x: float64): float64
lib/std/math.ci:462:[.057cf8, .057da5): exec(2), time(0.131-0.057 ms): Math.asin(x: float64): float64
lib/std/math/Complex.ci:24:[.057da8, .057daf): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math/Complex.ci:31:[.057db0, .057db7): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math/Complex.ci:86:[.057db8, .057e33): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math/Complex.ci:117:[.057e38, .057e57): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math/Complex.ci:135:[.057e58, .057ebc): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/math/Vector4f.ci:26:[.057ec0, .057ecd): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/std/math/Matrix4f.ci:62:[.057ed0, .057f01): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/std/math/Matrix4f.ci:75:[.057f08, .057f1d): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/std/math/Matrix4f.ci:87:[.057f20, .057f51): exec(0), time(0.000 ms): transpose(mat: mat4f): mat4f
lib/std/math/Matrix4f.ci:97:[.057f58, .058085): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
lib/std/math/Matrix4f.ci:111:[.058088, .058294): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
lib/std/math/Matrix4f.ci:163:[.058298, .0582f0): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
lib/std/math/Matrix4f.ci:173:[.0582f0, .0583c9): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
lib/std/math/Vector2d.ci:14:[.0583d0, .0583d7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/std/string.ci:4:[.0583d8, .0583fe): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.058400, .058432): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.058438, .05846a): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.058470, .0584b9): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.0584c0, .05853e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.058540, .05857f): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.058580, .0585c7): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.0585c8, .0585ec): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.0585f0, .0585fe): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:127:[.058600, .058654): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:144:[.058668, .05892b): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
lib/std/string.ci:234:[.058930, .058a13): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
lib/std/string.ci:262:[.058a28, .058a67): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
test/lang/function.ci:4:[.058ef8, .058ef9): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.058f00, .058f08): exec(2), time(0.034 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.058f40, .058f48): exec(2), time(0.028 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.058f48, .058f7e): exec(753), time(20.646 ms): fib(n: uint32): uint32
test/std/tryExec.ci:11:[.059250, .059251): exec(1), time(0.016 ms): noError(ptr: pointer): void
test/std/tryExec.ci:14:[.059258, .059270): exec(128-128), time(3.311 ms): stackOverflow(ptr: pointer): void
test/std/tryExec.ci:19:[.059270, .05927c): exec(1-1), time(0.030 ms): divisionByZero(args: pointer): void
test/std/tryExec.ci:23:[.059280, .0592c4): exec(1-1), time(0.150-0.117 ms): abortExecution(args: pointer): void
test/std/tryExec.ci:37:[.0592c8, .0592d5): exec(1-1), time(0.017 ms): invalidMemoryAccess(args: pointer): void
test/std/tryExec.ci:42:[.0592d8, .0592da): exec(1-1), time(0.015 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.0593b0, .0593b4): exec(5), time(0.124 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.0593b8, .0593c4): exec(21), time(0.504 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.0593c8, .0593d4): exec(21), time(0.523 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.0593d8, .0593e4): exec(14), time(0.341 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.059438, .05945f): exec(3), time(0.564-0.486 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.059468, .05948f): exec(4), time(0.614-0.510 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.059490, .0594b7): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.0594b8, .0594df): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.0594f0, .059532): exec(1), time(0.289-0.249 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.059538, .059577): exec(1), time(0.265-0.211 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.059fbc, .05d8e6): exec(1), time(40.346-31.232 ms): .main

---------- Profile statements: 875/1209, coverage: 72.37%
lib/std/debug.ci:66:[.057579, .05757a) exec(8), time(0.084-0.084 ms): <assertEq+9>
lib/std/debug.ci:65:[.057570, .05757a) exec(8-8), time(0.000 ms): <assertEq+0>
lib/std/debug.ci:69:[.05757e, .057589) exec(0), time(0.000 ms): <assertEq+14>
lib/std/debug.ci:70:[.057589, .057594) exec(0), time(0.000 ms): <assertEq+25>
lib/std/debug.ci:71:[.057594, .057597) exec(0), time(0.000 ms): <assertEq+36>
::[.057597, .0575a3) exec(0), time(0.000 ms): <assertEq+39>
lib/std/debug.ci:68:[.05757a, .0575a3) exec(0), time(0.000 ms): <assertEq+10>
lib/std/debug.ci:73:[.0575a3, .0575c9) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.0575e8, .0575f9) exec(3), time(0.056-0.056 ms): <modf+24>
lib/std/math.ci:26:[.0575f9, .057600) exec(3), time(0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.057600, .057603) exec(3), time(0.019-0.019 ms): <modf+48>
lib/std/math.ci:24:[.0575e0, .057607) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.057607, .05760b) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.05760b, .05760f) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.0575d0, .05760f) exec(10-3), time(0.006-0.006 ms): <modf+0>
lib/std/math.ci:32:[.05760f, .05761b) exec(7), time(0.004-0.004 ms): <modf+63>
lib/std/math.ci:33:[.05761b, .057623) exec(7), time(0.007-0.007 ms): <modf+75>
lib/std/math.ci:34:[.057623, .057626) exec(7), time(0.047-0.047 ms): <modf+83>
lib/std/math.ci:48:[.057628, .057629) exec(6), time(0.004-0.004 ms): <floor+0>
lib/std/math.ci:49:[.057629, .05763d) exec(6), time(0.167-0.167 ms): <floor+1>
lib/std/math.ci:50:[.05763d, .057640) exec(6), time(0.039-0.039 ms): <floor+21>
lib/std/math.ci:79:[.057648, .05764e) exec(1), time(0.011-0.011 ms): <abs+8>
lib/std/math.ci:78:[.057640, .05764e) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.05764e, .057652) exec(2), time(0.012-0.012 ms): <abs+14>
lib/std/math.ci:87:[.057660, .057666) exec(1), time(0.007-0.007 ms): <abs+8>
lib/std/math.ci:86:[.057658, .057666) exec(4-1), time(0.003-0.003 ms): <abs+0>
lib/std/math.ci:89:[.057666, .05766a) exec(3), time(0.019-0.019 ms): <abs+14>
lib/std/math.ci:95:[.05767f, .057687) exec(4), time(0.038-0.038 ms): <absMod+15>
lib/std/math.ci:94:[.057670, .057687) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:97:[.057687, .05768b) exec(7), time(0.096-0.096 ms): <absMod+23>
lib/std/math.ci:103:[.05769f, .0576a7) exec(4), time(0.026-0.026 ms): <absMod+15>
lib/std/math.ci:102:[.057690, .0576a7) exec(11-4), time(0.008-0.008 ms): <absMod+0>
lib/std/math.ci:105:[.0576a7, .0576ab) exec(7), time(0.061-0.061 ms): <absMod+23>
lib/std/math.ci:117:[.0576b9, .0576bd) exec(1), time(0.007-0.007 ms): <min+9>
lib/std/math.ci:116:[.0576b0, .0576bd) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.0576bd, .0576c1) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.0576d1, .0576d5) exec(1), time(0.007-0.007 ms): <min+9>
lib/std/math.ci:124:[.0576c8, .0576d5) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.0576d5, .0576d9) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.0576e9, .0576ed) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.0576e0, .0576ed) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.0576ed, .0576f1) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:147:[.057701, .057705) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.0576f8, .057705) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.057705, .057709) exec(1), time(0.007-0.007 ms): <max+13>
lib/std/math.ci:161:[.057719, .05771d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.057710, .05771d) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:164:[.057726, .05772a) exec(1), time(0.007-0.007 ms): <clamp+22>
lib/std/math.ci:163:[.05771d, .05772a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.05772a, .05772e) exec(1), time(0.007-0.007 ms): <clamp+26>
lib/std/math.ci:172:[.057739, .05773d) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.057730, .05773d) exec(2), time(0.002-0.002 ms): <clamp+0>
lib/std/math.ci:175:[.057746, .05774a) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:174:[.05773d, .05774a) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:177:[.05774a, .05774e) exec(1), time(0.007-0.007 ms): <clamp+26>
lib/std/math.ci:203:[.057758, .057764) exec(1), time(0.007-0.007 ms): <min+8>
lib/std/math.ci:202:[.057750, .057764) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.057764, .057767) exec(1), time(0.001-0.001 ms): <min+20>
lib/std/math.ci:208:[.057780, .05778b) exec(2), time(0.002-0.002 ms): <min+48>
lib/std/math.ci:207:[.057770, .05778b) exec(8-2), time(0.006-0.006 ms): <min+32>
lib/std/math.ci:206:[.05778b, .05778f) exec(8), time(0.004-0.004 ms): <min+59>
lib/std/math.ci:206:[.05778f, .057798) exec(9), time(0.008-0.008 ms): <min+63>
lib/std/math.ci:206:[.057767, .05779c) exec(1), time(0.002-0.002 ms): <min+23>
lib/std/math.ci:211:[.05779c, .05779f) exec(1), time(0.007-0.007 ms): <min+76>
lib/std/math.ci:217:[.0577a8, .0577b4) exec(1), time(0.007-0.007 ms): <max+8>
lib/std/math.ci:216:[.0577a0, .0577b4) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.0577b4, .0577b7) exec(1), time(0.001-0.001 ms): <max+20>
lib/std/math.ci:222:[.0577d0, .0577db) exec(2), time(0.002-0.002 ms): <max+48>
lib/std/math.ci:221:[.0577c0, .0577db) exec(8-2), time(0.006-0.006 ms): <max+32>
lib/std/math.ci:220:[.0577db, .0577df) exec(8), time(0.004-0.004 ms): <max+59>
lib/std/math.ci:220:[.0577df, .0577e8) exec(9), time(0.007-0.007 ms): <max+63>
lib/std/math.ci:220:[.0577b7, .0577ec) exec(1), time(0.002-0.002 ms): <max+23>
lib/std/math.ci:225:[.0577ec, .0577ef) exec(1), time(0.007-0.007 ms): <max+76>
lib/std/math.ci:230:[.0577f0, .0577f1) exec(4), time(0.001-0.001 ms): <sum+0>
lib/std/math.ci:232:[.0577f6, .057804) exec(13), time(0.017-0.017 ms): <sum+6>
lib/std/math.ci:231:[.057804, .057808) exec(13), time(0.023-0.023 ms): <sum+20>
lib/std/math.ci:231:[.057808, .057811) exec(17), time(0.015-0.015 ms): <sum+24>
lib/std/math.ci:231:[.0577f1, .057815) exec(4), time(0.006-0.006 ms): <sum+1>
lib/std/math.ci:234:[.057815, .057818) exec(4), time(0.027-0.027 ms): <sum+37>
lib/std/math.ci:239:[.057818, .05782c) exec(0), time(0.000 ms): <mean+0>
lib/std/math.ci:256:[.057830, .057831) exec(3), time(0.003-0.003 ms): <eval+0>
lib/std/math.ci:258:[.05783b, .05784c) exec(11), time(0.013-0.013 ms): <eval+11>
lib/std/math.ci:257:[.05784c, .057850) exec(11), time(0.004-0.004 ms): <eval+28>
lib/std/math.ci:257:[.057850, .057858) exec(14), time(0.014-0.014 ms): <eval+32>
lib/std/math.ci:257:[.057831, .05785c) exec(3), time(0.004-0.004 ms): <eval+1>
lib/std/math.ci:260:[.05785c, .05785f) exec(3), time(0.021-0.021 ms): <eval+44>
lib/std/math.ci:267:[.057875, .05787d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:266:[.057869, .05787d) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:272:[.05788d, .057895) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:271:[.057881, .057895) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:265:[.057860, .057895) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:275:[.057895, .057899) exec(1), time(0.021-0.021 ms): <cmp+53>
lib/std/math.ci:282:[.0578b5, .0578bd) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:281:[.0578a9, .0578bd) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:287:[.0578cd, .0578d5) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:286:[.0578c1, .0578d5) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:280:[.0578a0, .0578d5) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:290:[.0578d5, .0578d9) exec(1), time(0.007-0.007 ms): <cmp+53>
lib/std/math.ci:308:[.0578e0, .0578e2) exec(2), time(0.002-0.002 ms): <sinCos+0>
lib/std/math.ci:310:[.0578ea, .0578eb) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:311:[.0578eb, .0578f3) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:309:[.0578e2, .0578f3) exec(2), time(0.001-0.001 ms): <sinCos+2>
lib/std/math.ci:314:[.0578f3, .0578f4) exec(2), time(0.002-0.002 ms): <sinCos+19>
lib/std/math.ci:315:[.0578f4, .05790c) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:317:[.05791c, .05791d) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:318:[.05791d, .05792f) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:319:[.05792f, .057933) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:321:[.057933, .057934) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:322:[.057934, .057952) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:323:[.057952, .057964) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:326:[.05796c, .05796f) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:327:[.05796f, .057977) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:328:[.057977, .05797e) exec(2), time(0.002-0.002 ms): <sinCos+151>
lib/std/math.ci:329:[.05797e, .057984) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:316:[.05790c, .057988) exec(2), time(0.004-0.004 ms): <sinCos+44>
lib/std/math.ci:332:[.057990, .05799e) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:331:[.057988, .05799e) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:335:[.0579aa, .0579ab) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:334:[.05799e, .0579ab) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:338:[.0579ab, .0579b0) exec(2), time(0.002-0.002 ms): <sinCos+203>
lib/std/math.ci:339:[.0579b0, .0579f0) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:340:[.0579f0, .057a23) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:341:[.057a23, .057a2f) exec(2), time(0.015-0.015 ms): <sinCos+323>
lib/std/math.ci:364:[.057a30, .057a31) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:365:[.057a31, .057a32) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:368:[.057a3a, .057a3f) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:369:[.057a3f, .057a49) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:367:[.057a32, .057a49) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:371:[.057a49, .057a61) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:373:[.057a61, .057a62) exec(1), time(0.001-0.001 ms): <tan+49>
lib/std/math.ci:374:[.057a62, .057a72) exec(1), time(0.021-0.021 ms): <tan+50>
lib/std/math.ci:375:[.057a72, .057a7b) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:379:[.057a8f, .057a9d) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:380:[.057a9d, .057aa7) exec(1), time(0.000 ms): <tan+109>
lib/std/math.ci:383:[.057ab7, .057ac2) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:384:[.057ac2, .057acc) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:387:[.057adc, .057aea) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:388:[.057aea, .057af5) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:386:[.057ad0, .057af5) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:382:[.057aab, .057af5) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:378:[.057a83, .057af5) exec(1), time(0.001-0.001 ms): <tan+83>
lib/std/math.ci:377:[.057a7b, .057af5) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:391:[.057af5, .057afa) exec(1), time(0.001-0.001 ms): <tan+197>
lib/std/math.ci:392:[.057afa, .057b3a) exec(1), time(0.003-0.003 ms): <tan+202>
lib/std/math.ci:393:[.057b3a, .057b61) exec(1), time(0.002-0.002 ms): <tan+266>
lib/std/math.ci:397:[.057b72, .057b82) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:396:[.057b6a, .057b82) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:399:[.057b82, .057b90) exec(1), time(0.001-0.001 ms): <tan+338>
lib/std/math.ci:395:[.057b61, .057b90) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:402:[.057b99, .057ba3) exec(0), time(0.000 ms): <tan+361>
lib/std/math.ci:401:[.057b90, .057ba3) exec(1), time(0.001-0.001 ms): <tan+352>
lib/std/math.ci:404:[.057ba3, .057baa) exec(1), time(0.007-0.007 ms): <tan+371>
lib/std/math.ci:420:[.057bb0, .057bb1) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:422:[.057bb9, .057bbe) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:423:[.057bbe, .057bc8) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:421:[.057bb1, .057bc8) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:427:[.057bd8, .057bef) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:426:[.057bc8, .057bef) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:430:[.057bef, .057bf0) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:432:[.057c00, .057c1a) exec(1), time(0.072-0.072 ms): <sinh+80>
lib/std/math.ci:435:[.057c1e, .057c23) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:436:[.057c23, .057c58) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:437:[.057c58, .057c83) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:431:[.057bf0, .057c87) exec(1), time(0.073-0.073 ms): <sinh+64>
lib/std/math.ci:441:[.057c90, .057c9a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:440:[.057c87, .057c9a) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:443:[.057c9a, .057ca1) exec(1), time(0.010-0.010 ms): <sinh+234>
lib/std/math.ci:449:[.057cb0, .057cb5) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:448:[.057ca8, .057cb5) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:452:[.057cc5, .057cd8) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:451:[.057cb5, .057cd8) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:454:[.057cd8, .057cf3) exec(1), time(0.051-0.051 ms): <cosh+48>
lib/std/math.ci:465:[.057d00, .057d04) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:463:[.057cf8, .057d04) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:468:[.057d04, .057d05) exec(2), time(0.002-0.002 ms): <asin+12>
lib/std/math.ci:470:[.057d0d, .057d17) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:471:[.057d17, .057d1c) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:469:[.057d05, .057d1c) exec(2), time(0.002-0.002 ms): <asin+13>
lib/std/math.ci:476:[.057d2c, .057d3c) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:474:[.057d1c, .057d3c) exec(2), time(0.003-0.003 ms): <asin+36>
lib/std/math.ci:479:[.057d3c, .057d4f) exec(2), time(0.044-0.044 ms): <asin+68>
lib/std/math.ci:481:[.057d5f, .057d7d) exec(0), time(0.000 ms): <asin+103>
lib/std/math.ci:484:[.057d81, .057d8b) exec(2), time(0.044-0.044 ms): <asin+137>
lib/std/math.ci:480:[.057d4f, .057d8b) exec(2-2), time(0.000 ms): <asin+87>
lib/std/math.ci:488:[.057d94, .057d9e) exec(0), time(0.000 ms): <asin+156>
lib/std/math.ci:487:[.057d8b, .057d9e) exec(2), time(0.002-0.002 ms): <asin+147>
lib/std/math.ci:490:[.057d9e, .057da5) exec(2), time(0.014-0.014 ms): <asin+166>
::[.057dab, .057dae) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:25:[.057da8, .057daf) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:34:[.057db3, .057db6) exec(0), time(0.000 ms): <Complex+3>
lib/std/math/Complex.ci:32:[.057db0, .057db7) exec(0), time(0.000 ms): <Complex+0>
lib/std/math/Complex.ci:91:[.057dd7, .057ddc) exec(0), time(0.000 ms): <div+31>
lib/std/math/Complex.ci:92:[.057ddc, .057de4) exec(0), time(0.000 ms): <div+36>
lib/std/math/Complex.ci:95:[.057df1, .057dfe) exec(0), time(0.000 ms): <div+57>
lib/std/math/Complex.ci:93:[.057de4, .057e03) exec(0), time(0.000 ms): <div+44>
lib/std/math/Complex.ci:90:[.057db8, .057e07) exec(0), time(0.000 ms): <div+0>
lib/std/math/Complex.ci:98:[.057e07, .057e0c) exec(0), time(0.000 ms): <div+79>
lib/std/math/Complex.ci:99:[.057e0c, .057e14) exec(0), time(0.000 ms): <div+84>
lib/std/math/Complex.ci:102:[.057e21, .057e2e) exec(0), time(0.000 ms): <div+105>
lib/std/math/Complex.ci:100:[.057e14, .057e33) exec(0), time(0.000 ms): <div+92>
lib/std/math/Complex.ci:118:[.057e38, .057e43) exec(0), time(0.000 ms): <inv+0>
lib/std/math/Complex.ci:121:[.057e4a, .057e52) exec(0), time(0.000 ms): <inv+18>
lib/std/math/Complex.ci:119:[.057e43, .057e57) exec(0), time(0.000 ms): <inv+11>
lib/std/math/Complex.ci:136:[.057e58, .057e6f) exec(0), time(0.000 ms): <pow+0>
lib/std/math/Complex.ci:137:[.057e6f, .057e7f) exec(0), time(0.000 ms): <pow+23>
lib/std/math/Complex.ci:138:[.057e7f, .057e8e) exec(0), time(0.000 ms): <pow+39>
lib/std/math/Complex.ci:139:[.057e8e, .057ea1) exec(0), time(0.000 ms): <pow+54>
lib/std/math/Complex.ci:142:[.057eac, .057eb7) exec(0), time(0.000 ms): <pow+84>
lib/std/math/Complex.ci:140:[.057ea1, .057ebc) exec(0), time(0.000 ms): <pow+73>
lib/std/math/Vector4f.ci:27:[.057ec3, .057ec6) exec(0), time(0.000 ms): <vec4f+3>
lib/std/math/Vector4f.ci:27:[.057ec6, .057ec9) exec(0), time(0.000 ms): <vec4f+6>
lib/std/math/Vector4f.ci:27:[.057ec9, .057ecc) exec(0), time(0.000 ms): <vec4f+9>
lib/std/math/Vector4f.ci:27:[.057ec0, .057ecd) exec(0), time(0.000 ms): <vec4f+0>
lib/std/math/Matrix4f.ci:67:[.057ed3, .057ed6) exec(0), time(0.000 ms): <mat4f+3>
lib/std/math/Matrix4f.ci:67:[.057ed6, .057ed9) exec(0), time(0.000 ms): <mat4f+6>
lib/std/math/Matrix4f.ci:67:[.057ed9, .057edc) exec(0), time(0.000 ms): <mat4f+9>
lib/std/math/Matrix4f.ci:68:[.057edc, .057edf) exec(0), time(0.000 ms): <mat4f+12>
lib/std/math/Matrix4f.ci:68:[.057edf, .057ee2) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:68:[.057ee2, .057ee5) exec(0), time(0.000 ms): <mat4f+18>
lib/std/math/Matrix4f.ci:68:[.057ee5, .057ee8) exec(0), time(0.000 ms): <mat4f+21>
lib/std/math/Matrix4f.ci:69:[.057ee8, .057eeb) exec(0), time(0.000 ms): <mat4f+24>
lib/std/math/Matrix4f.ci:69:[.057eeb, .057eee) exec(0), time(0.000 ms): <mat4f+27>
lib/std/math/Matrix4f.ci:69:[.057eee, .057ef1) exec(0), time(0.000 ms): <mat4f+30>
lib/std/math/Matrix4f.ci:69:[.057ef1, .057ef4) exec(0), time(0.000 ms): <mat4f+33>
lib/std/math/Matrix4f.ci:70:[.057ef4, .057ef7) exec(0), time(0.000 ms): <mat4f+36>
lib/std/math/Matrix4f.ci:70:[.057ef7, .057efa) exec(0), time(0.000 ms): <mat4f+39>
lib/std/math/Matrix4f.ci:70:[.057efa, .057efd) exec(0), time(0.000 ms): <mat4f+42>
lib/std/math/Matrix4f.ci:70:[.057efd, .057f00) exec(0), time(0.000 ms): <mat4f+45>
lib/std/math/Matrix4f.ci:66:[.057ed0, .057f01) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:76:[.057f0d, .057f12) exec(0), time(0.000 ms): <mat4f+5>
lib/std/math/Matrix4f.ci:76:[.057f12, .057f17) exec(0), time(0.000 ms): <mat4f+10>
lib/std/math/Matrix4f.ci:76:[.057f17, .057f1c) exec(0), time(0.000 ms): <mat4f+15>
lib/std/math/Matrix4f.ci:76:[.057f08, .057f1d) exec(0), time(0.000 ms): <mat4f+0>
lib/std/math/Matrix4f.ci:89:[.057f23, .057f26) exec(0), time(0.000 ms): <transpose+3>
lib/std/math/Matrix4f.ci:89:[.057f26, .057f29) exec(0), time(0.000 ms): <transpose+6>
lib/std/math/Matrix4f.ci:89:[.057f29, .057f2c) exec(0), time(0.000 ms): <transpose+9>
lib/std/math/Matrix4f.ci:90:[.057f2c, .057f2f) exec(0), time(0.000 ms): <transpose+12>
lib/std/math/Matrix4f.ci:90:[.057f2f, .057f32) exec(0), time(0.000 ms): <transpose+15>
lib/std/math/Matrix4f.ci:90:[.057f32, .057f35) exec(0), time(0.000 ms): <transpose+18>
lib/std/math/Matrix4f.ci:90:[.057f35, .057f38) exec(0), time(0.000 ms): <transpose+21>
lib/std/math/Matrix4f.ci:91:[.057f38, .057f3b) exec(0), time(0.000 ms): <transpose+24>
lib/std/math/Matrix4f.ci:91:[.057f3b, .057f3e) exec(0), time(0.000 ms): <transpose+27>
lib/std/math/Matrix4f.ci:91:[.057f3e, .057f41) exec(0), time(0.000 ms): <transpose+30>
lib/std/math/Matrix4f.ci:91:[.057f41, .057f44) exec(0), time(0.000 ms): <transpose+33>
lib/std/math/Matrix4f.ci:92:[.057f44, .057f47) exec(0), time(0.000 ms): <transpose+36>
lib/std/math/Matrix4f.ci:92:[.057f47, .057f4a) exec(0), time(0.000 ms): <transpose+39>
lib/std/math/Matrix4f.ci:92:[.057f4a, .057f4d) exec(0), time(0.000 ms): <transpose+42>
lib/std/math/Matrix4f.ci:92:[.057f4d, .057f50) exec(0), time(0.000 ms): <transpose+45>
lib/std/math/Matrix4f.ci:88:[.057f20, .057f51) exec(0), time(0.000 ms): <transpose+0>
lib/std/math/Matrix4f.ci:98:[.057f58, .057f74) exec(0), time(0.000 ms): <mul+0>
lib/std/math/Matrix4f.ci:101:[.057fb4, .057ff8) exec(0), time(0.000 ms): <mul+92>
lib/std/math/Matrix4f.ci:102:[.057ff8, .05803c) exec(0), time(0.000 ms): <mul+160>
lib/std/math/Matrix4f.ci:103:[.05803c, .058080) exec(0), time(0.000 ms): <mul+228>
lib/std/math/Matrix4f.ci:99:[.057f74, .058085) exec(0), time(0.000 ms): <mul+28>
lib/std/math/Matrix4f.ci:112:[.058088, .05809a) exec(0), time(0.000 ms): <rotation+0>
lib/std/math/Matrix4f.ci:114:[.0580ab, .0580cf) exec(0), time(0.000 ms): <rotation+35>
lib/std/math/Matrix4f.ci:117:[.0580e3, .0580f7) exec(0), time(0.000 ms): <rotation+91>
lib/std/math/Matrix4f.ci:118:[.0580f7, .05810b) exec(0), time(0.000 ms): <rotation+111>
lib/std/math/Matrix4f.ci:119:[.05810b, .05811f) exec(0), time(0.000 ms): <rotation+131>
lib/std/math/Matrix4f.ci:115:[.0580cf, .058124) exec(0), time(0.000 ms): <rotation+71>
lib/std/math/Matrix4f.ci:113:[.05809a, .058124) exec(0), time(0.000 ms): <rotation+18>
lib/std/math/Matrix4f.ci:122:[.058124, .05812a) exec(0), time(0.000 ms): <rotation+156>
lib/std/math/Matrix4f.ci:123:[.05812a, .058134) exec(0), time(0.000 ms): <rotation+162>
lib/std/math/Matrix4f.ci:124:[.058134, .05813e) exec(0), time(0.000 ms): <rotation+172>
lib/std/math/Matrix4f.ci:125:[.05813e, .058141) exec(0), time(0.000 ms): <rotation+182>
lib/std/math/Matrix4f.ci:126:[.058141, .058148) exec(0), time(0.000 ms): <rotation+185>
lib/std/math/Matrix4f.ci:127:[.058148, .05814f) exec(0), time(0.000 ms): <rotation+192>
lib/std/math/Matrix4f.ci:128:[.05814f, .058154) exec(0), time(0.000 ms): <rotation+199>
lib/std/math/Matrix4f.ci:129:[.058154, .058159) exec(0), time(0.000 ms): <rotation+204>
lib/std/math/Matrix4f.ci:130:[.058159, .05815e) exec(0), time(0.000 ms): <rotation+209>
lib/std/math/Matrix4f.ci:131:[.05815e, .058163) exec(0), time(0.000 ms): <rotation+214>
lib/std/math/Matrix4f.ci:132:[.058163, .058168) exec(0), time(0.000 ms): <rotation+219>
lib/std/math/Matrix4f.ci:133:[.058168, .05816d) exec(0), time(0.000 ms): <rotation+224>
lib/std/math/Matrix4f.ci:135:[.05816d, .058173) exec(0), time(0.000 ms): <rotation+229>
lib/std/math/Matrix4f.ci:136:[.058173, .058179) exec(0), time(0.000 ms): <rotation+235>
lib/std/math/Matrix4f.ci:137:[.058179, .058181) exec(0), time(0.000 ms): <rotation+241>
lib/std/math/Matrix4f.ci:141:[.05818e, .05819b) exec(0), time(0.000 ms): <rotation+262>
lib/std/math/Matrix4f.ci:142:[.05819b, .0581a8) exec(0), time(0.000 ms): <rotation+275>
lib/std/math/Matrix4f.ci:143:[.0581a8, .0581d3) exec(0), time(0.000 ms): <rotation+288>
lib/std/math/Matrix4f.ci:145:[.0581d3, .0581e0) exec(0), time(0.000 ms): <rotation+331>
lib/std/math/Matrix4f.ci:146:[.0581e0, .0581ed) exec(0), time(0.000 ms): <rotation+344>
lib/std/math/Matrix4f.ci:147:[.0581ed, .0581fa) exec(0), time(0.000 ms): <rotation+357>
lib/std/math/Matrix4f.ci:148:[.0581fa, .058225) exec(0), time(0.000 ms): <rotation+370>
lib/std/math/Matrix4f.ci:150:[.058225, .058232) exec(0), time(0.000 ms): <rotation+413>
lib/std/math/Matrix4f.ci:151:[.058232, .05823f) exec(0), time(0.000 ms): <rotation+426>
lib/std/math/Matrix4f.ci:152:[.05823f, .05824c) exec(0), time(0.000 ms): <rotation+439>
lib/std/math/Matrix4f.ci:153:[.05824c, .058277) exec(0), time(0.000 ms): <rotation+452>
lib/std/math/Matrix4f.ci:155:[.058277, .05828f) exec(0), time(0.000 ms): <rotation+495>
lib/std/math/Matrix4f.ci:139:[.058181, .058294) exec(0), time(0.000 ms): <rotation+249>
lib/std/math/Matrix4f.ci:165:[.05829f, .0582a2) exec(0), time(0.000 ms): <translation+7>
lib/std/math/Matrix4f.ci:165:[.0582a2, .0582a5) exec(0), time(0.000 ms): <translation+10>
lib/std/math/Matrix4f.ci:165:[.0582a5, .0582ad) exec(0), time(0.000 ms): <translation+13>
lib/std/math/Matrix4f.ci:166:[.0582ad, .0582b0) exec(0), time(0.000 ms): <translation+21>
lib/std/math/Matrix4f.ci:166:[.0582b0, .0582b7) exec(0), time(0.000 ms): <translation+24>
lib/std/math/Matrix4f.ci:166:[.0582b7, .0582ba) exec(0), time(0.000 ms): <translation+31>
lib/std/math/Matrix4f.ci:166:[.0582ba, .0582c6) exec(0), time(0.000 ms): <translation+34>
lib/std/math/Matrix4f.ci:167:[.0582c6, .0582c9) exec(0), time(0.000 ms): <translation+46>
lib/std/math/Matrix4f.ci:167:[.0582c9, .0582cc) exec(0), time(0.000 ms): <translation+49>
lib/std/math/Matrix4f.ci:167:[.0582cc, .0582d3) exec(0), time(0.000 ms): <translation+52>
lib/std/math/Matrix4f.ci:167:[.0582d3, .0582df) exec(0), time(0.000 ms): <translation+59>
lib/std/math/Matrix4f.ci:168:[.0582df, .0582e2) exec(0), time(0.000 ms): <translation+71>
lib/std/math/Matrix4f.ci:168:[.0582e2, .0582e5) exec(0), time(0.000 ms): <translation+74>
lib/std/math/Matrix4f.ci:168:[.0582e5, .0582e8) exec(0), time(0.000 ms): <translation+77>
lib/std/math/Matrix4f.ci:168:[.0582e8, .0582ef) exec(0), time(0.000 ms): <translation+80>
lib/std/math/Matrix4f.ci:164:[.058298, .0582f0) exec(0), time(0.000 ms): <translation+0>
lib/std/math/Matrix4f.ci:176:[.058327, .05832a) exec(0), time(0.000 ms): <scale+55>
lib/std/math/Matrix4f.ci:176:[.05832a, .05832d) exec(0), time(0.000 ms): <scale+58>
lib/std/math/Matrix4f.ci:176:[.05832d, .058330) exec(0), time(0.000 ms): <scale+61>
lib/std/math/Matrix4f.ci:177:[.058330, .058333) exec(0), time(0.000 ms): <scale+64>
lib/std/math/Matrix4f.ci:177:[.058333, .05836e) exec(0), time(0.000 ms): <scale+67>
lib/std/math/Matrix4f.ci:177:[.05836e, .058371) exec(0), time(0.000 ms): <scale+126>
lib/std/math/Matrix4f.ci:177:[.058371, .058374) exec(0), time(0.000 ms): <scale+129>
lib/std/math/Matrix4f.ci:178:[.058374, .058377) exec(0), time(0.000 ms): <scale+132>
lib/std/math/Matrix4f.ci:178:[.058377, .05837a) exec(0), time(0.000 ms): <scale+135>
lib/std/math/Matrix4f.ci:178:[.05837a, .0583b5) exec(0), time(0.000 ms): <scale+138>
lib/std/math/Matrix4f.ci:178:[.0583b5, .0583b8) exec(0), time(0.000 ms): <scale+197>
lib/std/math/Matrix4f.ci:179:[.0583b8, .0583bb) exec(0), time(0.000 ms): <scale+200>
lib/std/math/Matrix4f.ci:179:[.0583bb, .0583be) exec(0), time(0.000 ms): <scale+203>
lib/std/math/Matrix4f.ci:179:[.0583be, .0583c1) exec(0), time(0.000 ms): <scale+206>
lib/std/math/Matrix4f.ci:179:[.0583c1, .0583c8) exec(0), time(0.000 ms): <scale+209>
lib/std/math/Matrix4f.ci:175:[.0582f0, .0583c9) exec(0), time(0.000 ms): <scale+0>
lib/std/math/Vector2d.ci:17:[.0583d3, .0583d6) exec(0), time(0.000 ms): <vec2d+3>
lib/std/math/Vector2d.ci:15:[.0583d0, .0583d7) exec(0), time(0.000 ms): <vec2d+0>
lib/std/string.ci:6:[.0583e4, .0583e8) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.0583d8, .0583e8) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.0583e8, .0583e9) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.0583ed, .0583f1) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.0583f1, .0583fb) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.0583e9, .0583fb) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.0583fb, .0583fe) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.058415, .058418) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.058405, .058418) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.058418, .05841c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.05841c, .058426) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.058400, .05842a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.05842a, .058432) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.058438, .05843d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.058452, .058455) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.058442, .058455) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.058455, .058459) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.058459, .058463) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.05843d, .058467) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.058467, .05846a) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.05848f, .05849a) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.058475, .05849a) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.05849a, .05849e) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.05849e, .0584aa) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.058470, .0584ae) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.0584ae, .0584b9) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.0584c0, .0584cd) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.0584cd, .0584da) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.0584e3, .0584ee) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.0584da, .0584ee) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.058513, .05851e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.0584f3, .05851e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.05851e, .058522) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.058522, .05852b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.0584ee, .05852f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.05852f, .05853e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.058540, .058541) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.058546, .05855c) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.058568, .05856c) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.05855c, .05856c) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.05856c, .058570) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.058570, .058578) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.058541, .05857c) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.05857c, .05857f) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.05858f, .05859a) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.058580, .05859a) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.0585a9, .0585b4) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.05859a, .0585b4) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.0585b4, .0585c7) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.0585c8, .0585ec) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.0585f0, .0585fe) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:130:[.05860e, .058612) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:129:[.058605, .058612) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:132:[.058612, .05861e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:133:[.05861e, .058626) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:128:[.058626, .05862a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:128:[.05862a, .058634) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:128:[.058600, .058638) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:137:[.058641, .058649) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:136:[.058638, .058649) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:139:[.058649, .058650) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:140:[.058650, .058654) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:148:[.058668, .058669) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:149:[.058669, .05866d) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:153:[.05867f, .058689) exec(0), time(0.000 ms): <append+23>
lib/std/string.ci:152:[.058674, .058689) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:151:[.05866d, .058689) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:157:[.058689, .058690) exec(0), time(0.000 ms): <append+33>
lib/std/string.ci:159:[.058698, .05869f) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:158:[.058690, .05869f) exec(0), time(0.000 ms): <append+40>
lib/std/string.ci:161:[.05869f, .0586d5) exec(0), time(0.000 ms): <append+55>
lib/std/string.ci:162:[.0586d5, .05870a) exec(0), time(0.000 ms): <append+109>
lib/std/string.ci:166:[.05870e, .05872b) exec(0), time(0.000 ms): <append+166>
lib/std/string.ci:165:[.05872b, .058733) exec(0), time(0.000 ms): <append+195>
lib/std/string.ci:165:[.058733, .05873b) exec(0), time(0.000 ms): <append+203>
lib/std/string.ci:165:[.05870a, .05873b) exec(0), time(0.000 ms): <append+162>
lib/std/string.ci:169:[.058743, .058758) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:168:[.05873b, .058758) exec(0), time(0.000 ms): <append+211>
lib/std/string.ci:172:[.058758, .058762) exec(0), time(0.000 ms): <append+240>
lib/std/string.ci:174:[.058762, .058769) exec(0), time(0.000 ms): <append+250>
lib/std/string.ci:176:[.058774, .05877e) exec(0), time(0.000 ms): <append+268>
lib/std/string.ci:175:[.058769, .05877e) exec(0), time(0.000 ms): <append+257>
lib/std/string.ci:181:[.058789, .058791) exec(0), time(0.000 ms): <append+289>
lib/std/string.ci:185:[.0587af, .0587e3) exec(0), time(0.000 ms): <append+327>
lib/std/string.ci:186:[.0587e3, .0587ee) exec(0), time(0.000 ms): <append+379>
lib/std/string.ci:187:[.0587ee, .0587f6) exec(0), time(0.000 ms): <append+390>
lib/std/string.ci:184:[.0587f6, .0587fe) exec(0), time(0.000 ms): <append+398>
lib/std/string.ci:184:[.0587fe, .058806) exec(0), time(0.000 ms): <append+406>
lib/std/string.ci:184:[.0587ab, .058806) exec(0), time(0.000 ms): <append+323>
lib/std/string.ci:182:[.058791, .058806) exec(0), time(0.000 ms): <append+297>
lib/std/string.ci:190:[.058806, .05883a) exec(0), time(0.000 ms): <append+414>
lib/std/string.ci:191:[.05883a, .058845) exec(0), time(0.000 ms): <append+466>
lib/std/string.ci:192:[.058845, .05884d) exec(0), time(0.000 ms): <append+477>
lib/std/string.ci:180:[.05877e, .05884d) exec(0), time(0.000 ms): <append+278>
lib/std/string.ci:197:[.058851, .058885) exec(0), time(0.000 ms): <append+489>
lib/std/string.ci:198:[.058885, .058890) exec(0), time(0.000 ms): <append+541>
lib/std/string.ci:199:[.058890, .058898) exec(0), time(0.000 ms): <append+552>
lib/std/string.ci:196:[.058898, .0588a0) exec(0), time(0.000 ms): <append+560>
lib/std/string.ci:196:[.0588a0, .0588a8) exec(0), time(0.000 ms): <append+568>
lib/std/string.ci:196:[.05884d, .0588a8) exec(0), time(0.000 ms): <append+485>
lib/std/string.ci:204:[.0588ad, .0588e1) exec(0), time(0.000 ms): <append+581>
lib/std/string.ci:205:[.0588e1, .0588f2) exec(0), time(0.000 ms): <append+633>
lib/std/string.ci:206:[.0588f2, .0588fa) exec(0), time(0.000 ms): <append+650>
lib/std/string.ci:203:[.0588fa, .0588fe) exec(0), time(0.000 ms): <append+658>
lib/std/string.ci:203:[.0588fe, .058907) exec(0), time(0.000 ms): <append+662>
lib/std/string.ci:203:[.0588a8, .05890b) exec(0), time(0.000 ms): <append+576>
lib/std/string.ci:210:[.058914, .05891c) exec(0), time(0.000 ms): <append+684>
lib/std/string.ci:209:[.05890b, .05891c) exec(0), time(0.000 ms): <append+675>
lib/std/string.ci:212:[.05891c, .058923) exec(0), time(0.000 ms): <append+692>
lib/std/string.ci:213:[.058923, .05892b) exec(0), time(0.000 ms): <append+699>
lib/std/string.ci:236:[.058934, .05893c) exec(0), time(0.000 ms): <append+4>
lib/std/string.ci:237:[.05893c, .05893f) exec(0), time(0.000 ms): <append+12>
lib/std/string.ci:238:[.05893f, .05894b) exec(0), time(0.000 ms): <append+15>
lib/std/string.ci:239:[.05894b, .05895c) exec(0), time(0.000 ms): <append+27>
lib/std/string.ci:235:[.058930, .05895c) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:242:[.058960, .058966) exec(0), time(0.000 ms): <append+48>
lib/std/string.ci:243:[.058966, .058969) exec(0), time(0.000 ms): <append+54>
lib/std/string.ci:244:[.058969, .058973) exec(0), time(0.000 ms): <append+57>
lib/std/string.ci:245:[.058973, .05897c) exec(0), time(0.000 ms): <append+67>
lib/std/string.ci:241:[.05895c, .05897c) exec(0), time(0.000 ms): <append+44>
lib/std/string.ci:248:[.05897c, .05898e) exec(0), time(0.000 ms): <append+76>
lib/std/string.ci:249:[.05898e, .0589a9) exec(0), time(0.000 ms): <append+94>
lib/std/string.ci:250:[.0589a9, .0589c6) exec(0), time(0.000 ms): <append+121>
lib/std/string.ci:252:[.0589c6, .0589dc) exec(0), time(0.000 ms): <append+150>
lib/std/string.ci:253:[.0589dc, .0589f2) exec(0), time(0.000 ms): <append+172>
lib/std/string.ci:254:[.0589f2, .058a0b) exec(0), time(0.000 ms): <append+194>
lib/std/string.ci:255:[.058a0b, .058a13) exec(0), time(0.000 ms): <append+219>
lib/std/string.ci:264:[.058a28, .058a67) exec(0), time(0.000 ms): <append+0>
test/lang/function.ci:8:[.058f00, .058f08) exec(2), time(0.019-0.019 ms): <funAdd+0>
test/lang/function.ci:34:[.058f40, .058f48) exec(2), time(0.019-0.019 ms): <funMul+0>
test/lang/function.ci:40:[.058f54, .058f58) exec(377), time(3.318-3.318 ms): <fib+12>
test/lang/function.ci:39:[.058f48, .058f58) exec(753-377), time(0.909-0.909 ms): <fib+0>
test/lang/function.ci:42:[.058f58, .058f7e) exec(376-375), time(20.639-20.639 ms): <fib+16>
test/std/tryExec.ci:15:[.059258, .05925c) exec(128-1), time(0.083-0.083 ms): <stackOverflow+0>
test/std/tryExec.ci:16:[.05925c, .05926b) exec(127-127), time(0.000 ms): <stackOverflow+4>
test/std/tryExec.ci:20:[.059270, .059277) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/std/tryExec.ci:30:[.059284, .05928b) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/std/tryExec.ci:31:[.05928b, .059292) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/std/tryExec.ci:32:[.059292, .059299) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/std/tryExec.ci:29:[.059280, .059299) exec(1-1), time(0.000 ms): <abortExecution+0>
test/std/tryExec.ci:34:[.059299, .0592bf) exec(1-1), time(0.000 ms): <abortExecution+25>
test/std/tryExec.ci:38:[.0592c8, .0592cd) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/std/tryExec.ci:39:[.0592cd, .0592d0) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/std/tryExec.ci:43:[.0592d8, .0592da) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.0593b0, .0593b4) exec(5), time(0.067-0.067 ms): <lenSlice+0>
test/lang/array.ci:104:[.0593b8, .0593c4) exec(21), time(0.295-0.295 ms): <nthFixed+0>
test/lang/array.ci:105:[.0593c8, .0593d4) exec(21), time(0.332-0.332 ms): <nthArray+0>
test/lang/array.ci:106:[.0593d8, .0593e4) exec(14), time(0.222-0.222 ms): <nthSlice+0>
test/lang/method.ci:11:[.059438, .05945e) exec(3), time(0.519-0.519 ms): <staticMethod+0>
test/lang/method.ci:41:[.059468, .05948e) exec(4), time(0.554-0.554 ms): <virtualMethod+0>
test/lang/method.ci:48:[.059490, .0594b6) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.0594b8, .0594de) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.0594f0, .059513) exec(1), time(0.027-0.027 ms): <staticMethod+0>
test/lang/method.ci:87:[.059521, .059531) exec(1), time(0.243-0.243 ms): <staticMethod+49>
test/lang/method.ci:86:[.059513, .059531) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.059538, .05955b) exec(1), time(0.054-0.054 ms): <virtualMethod+0>
test/lang/method.ci:93:[.059569, .059576) exec(1), time(0.191-0.191 ms): <virtualMethod+49>
test/lang/method.ci:92:[.05955b, .059576) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:145:[.059fbc, .059fca) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:146:[.059fca, .059fd8) exec(1), time(0.002-0.002 ms): <.main+14>
::[.059fdf, .059fe4) exec(1), time(0.002-0.002 ms): <.main+35>
::[.059fe4, .059feb) exec(1), time(0.002-0.002 ms): <.main+40>
::[.059feb, .059ff0) exec(1), time(0.001-0.001 ms): <.main+47>
lib/std/string.ci:263:[.059fd8, .059ff0) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.059ff0, .059ff5) exec(1), time(0.002-0.002 ms): <.main+52>
test/lang/emit.ci:4:[.059ff5, .059ffa) exec(1), time(0.001-0.001 ms): <.main+57>
test/lang/emit.ci:6:[.059ffa, .05a003) exec(1), time(0.001-0.001 ms): <.main+62>
test/lang/emit.ci:7:[.05a003, .05a00c) exec(1), time(0.001-0.001 ms): <.main+71>
test/lang/emit.ci:9:[.05a00c, .05a019) exec(1), time(0.002-0.002 ms): <.main+80>
test/lang/emit.ci:10:[.05a019, .05a028) exec(1), time(0.002-0.002 ms): <.main+93>
test/lang/emit.ci:17:[.05a028, .05a031) exec(1), time(0.001-0.001 ms): <.main+108>
test/lang/emit.ci:18:[.05a031, .05a03b) exec(1), time(0.001-0.001 ms): <.main+117>
test/lang/emit.ci:19:[.05a03b, .05a049) exec(1), time(0.002-0.002 ms): <.main+127>
test/lang/emit.ci:20:[.05a049, .05a056) exec(1), time(0.001-0.001 ms): <.main+141>
test/lang/emit.ci:23:[.05a056, .05a064) exec(1), time(0.002-0.002 ms): <.main+154>
test/lang/inlineMacros.ci:10:[.05a064, .05a06d) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/inlineMacros.ci:11:[.05a06d, .05a076) exec(1), time(0.002-0.002 ms): <.main+177>
test/lang/inlineMacros.ci:12:[.05a076, .05a07f) exec(1), time(0.001-0.001 ms): <.main+186>
test/lang/inlineMacros.ci:13:[.05a07f, .05a088) exec(1), time(0.002-0.002 ms): <.main+195>
test/lang/inlineMacros.ci:15:[.05a088, .05a08d) exec(1), time(0.001-0.001 ms): <.main+204>
test/lang/inlineMacros.ci:16:[.05a08d, .05a092) exec(1), time(0.001-0.001 ms): <.main+209>
test/lang/inlineMacros.ci:17:[.05a092, .05a097) exec(1), time(0.001-0.001 ms): <.main+214>
test/lang/inlineMacros.ci:19:[.05a097, .05a0a0) exec(1), time(0.001-0.001 ms): <.main+219>
test/lang/inlineMacros.ci:20:[.05a0a0, .05a0a8) exec(1), time(0.002-0.002 ms): <.main+228>
test/lang/inlineMacros.ci:21:[.05a0a8, .05a0b8) exec(1), time(0.002-0.002 ms): <.main+236>
test/lang/inlineMacros.ci:23:[.05a0b8, .05a0c5) exec(1), time(0.002-0.002 ms): <.main+252>
test/lang/inlineMacros.ci:24:[.05a0c5, .05a0d2) exec(1), time(0.002-0.002 ms): <.main+265>
test/lang/inlineMacros.ci:25:[.05a0d2, .05a0eb) exec(1), time(0.004-0.004 ms): <.main+278>
test/lang/inlineMacros.ci:27:[.05a0eb, .05a107) exec(1), time(0.004-0.004 ms): <.main+303>
test/lang/inlineMacros.ci:28:[.05a107, .05a121) exec(1), time(0.004-0.004 ms): <.main+331>
test/lang/inlineMacros.ci:29:[.05a121, .05a147) exec(1), time(0.005-0.005 ms): <.main+357>
test/lang/inlineMacros.ci:31:[.05a147, .05a16c) exec(1), time(0.006-0.006 ms): <.main+395>
test/lang/inlineMacros.ci:32:[.05a16c, .05a18f) exec(1), time(0.006-0.006 ms): <.main+432>
test/lang/inlineMacros.ci:33:[.05a18f, .05a1be) exec(1), time(0.008-0.008 ms): <.main+467>
test/lang/inlineMacros.ci:35:[.05a1be, .05a1e3) exec(1), time(0.006-0.006 ms): <.main+514>
test/lang/inlineMacros.ci:36:[.05a1e3, .05a206) exec(1), time(0.020-0.020 ms): <.main+551>
test/lang/inlineMacros.ci:37:[.05a206, .05a235) exec(1), time(0.008-0.008 ms): <.main+586>
test/lang/inlineMacros.ci:41:[.05a235, .05a24e) exec(1), time(0.004-0.004 ms): <.main+633>
test/lang/inlineMacros.ci:42:[.05a24e, .05a263) exec(1), time(0.003-0.003 ms): <.main+658>
test/lang/inlineMacros.ci:43:[.05a263, .05a27a) exec(1), time(0.004-0.004 ms): <.main+679>
test/lang/inlineMacros.ci:44:[.05a27a, .05a291) exec(1), time(0.005-0.005 ms): <.main+702>
test/lang/inlineMacros.ci:45:[.05a291, .05a2bc) exec(1), time(0.007-0.007 ms): <.main+725>
test/lang/inlineMacros.ci:46:[.05a2bc, .05a2e7) exec(1), time(0.007-0.007 ms): <.main+768>
test/lang/inlineMacros.ci:50:[.05a2e7, .05a329) exec(1), time(0.005-0.005 ms): <.main+811>
test/lang/inlineMacros.ci:51:[.05a329, .05a36b) exec(1), time(0.023-0.023 ms): <.main+877>
test/lang/inlineMacros.ci:52:[.05a36b, .05a3a9) exec(1), time(0.004-0.004 ms): <.main+943>
test/lang/inlineMacros.ci:53:[.05a3a9, .05a3e7) exec(1), time(0.010-0.010 ms): <.main+1005>
test/lang/inlineMacros.ci:54:[.05a3e7, .05a439) exec(1), time(0.005-0.005 ms): <.main+1067>
test/lang/inlineMacros.ci:55:[.05a439, .05a48b) exec(1), time(0.010-0.010 ms): <.main+1149>
test/lang/inlineMacros.ci:59:[.05a48b, .05a4e8) exec(1), time(0.015-0.015 ms): <.main+1231>
test/lang/inlineMacros.ci:60:[.05a4e8, .05a545) exec(1), time(0.016-0.016 ms): <.main+1324>
test/lang/inlineMacros.ci:61:[.05a545, .05a59e) exec(1), time(0.015-0.015 ms): <.main+1417>
test/lang/inlineMacros.ci:62:[.05a59e, .05a5f7) exec(1), time(0.015-0.015 ms): <.main+1506>
test/lang/inlineMacros.ci:63:[.05a5f7, .05a664) exec(1), time(0.018-0.018 ms): <.main+1595>
test/lang/inlineMacros.ci:64:[.05a664, .05a6d1) exec(1), time(0.018-0.018 ms): <.main+1704>
test/lang/inlineMacros.ci:68:[.05a6d1, .05a72e) exec(1), time(0.014-0.014 ms): <.main+1813>
test/lang/inlineMacros.ci:69:[.05a72e, .05a78b) exec(1), time(0.015-0.015 ms): <.main+1906>
test/lang/inlineMacros.ci:70:[.05a78b, .05a7e4) exec(1), time(0.015-0.015 ms): <.main+1999>
test/lang/inlineMacros.ci:71:[.05a7e4, .05a83d) exec(1), time(0.015-0.015 ms): <.main+2088>
test/lang/inlineMacros.ci:72:[.05a83d, .05a8aa) exec(1), time(0.018-0.018 ms): <.main+2177>
test/lang/inlineMacros.ci:73:[.05a8aa, .05a917) exec(1), time(0.018-0.018 ms): <.main+2286>
test/lang/overload.inline.ci:9:[.05a917, .05a920) exec(1), time(0.001-0.001 ms): <.main+2395>
test/lang/overload.inline.ci:10:[.05a920, .05a929) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/overload.inline.ci:11:[.05a929, .05a932) exec(1), time(0.001-0.001 ms): <.main+2413>
test/lang/overload.inline.ci:12:[.05a932, .05a93b) exec(1), time(0.001-0.001 ms): <.main+2422>
test/lang/overload.inline.ci:13:[.05a93b, .05a944) exec(1), time(0.001-0.001 ms): <.main+2431>
test/lang/overload.inline.ci:28:[.05a944, .05a951) exec(1), time(0.001-0.001 ms): <.main+2440>
test/lang/overload.inline.ci:29:[.05a951, .05a96d) exec(1), time(0.004-0.004 ms): <.main+2453>
test/lang/initByRef.ci:7:[.05a96d, .05a97a) exec(1), time(0.002-0.002 ms): <.main+2481>
test/lang/initByRef.ci:8:[.05a97a, .05a983) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:9:[.05a983, .05a98c) exec(1), time(0.002-0.002 ms): <.main+2503>
test/lang/initByRef.ci:10:[.05a98c, .05a99a) exec(1), time(0.002-0.002 ms): <.main+2512>
test/lang/initByRef.ci:12:[.05a99a, .05a9a3) exec(1), time(0.002-0.002 ms): <.main+2526>
test/lang/initByRef.ci:13:[.05a9a3, .05a9ab) exec(1), time(0.002-0.002 ms): <.main+2535>
test/lang/initByRef.ci:14:[.05a9ab, .05a9b3) exec(1), time(0.001-0.001 ms): <.main+2543>
test/lang/initByRef.ci:16:[.05a9b3, .05a9bc) exec(1), time(0.002-0.002 ms): <.main+2551>
test/lang/initByRef.ci:17:[.05a9bc, .05a9c5) exec(1), time(0.001-0.001 ms): <.main+2560>
test/lang/initByRef.ci:18:[.05a9c5, .05a9d3) exec(1), time(0.002-0.002 ms): <.main+2569>
test/lang/initByRef.ci:19:[.05a9d3, .05a9dc) exec(1), time(0.001-0.001 ms): <.main+2583>
test/lang/initByRef.ci:20:[.05a9dc, .05a9e5) exec(1), time(0.001-0.001 ms): <.main+2592>
test/lang/initByRef.ci:21:[.05a9e5, .05a9ee) exec(1), time(0.001-0.001 ms): <.main+2601>
test/lang/initByRef.ci:23:[.05a9ee, .05a9f7) exec(1), time(0.002-0.002 ms): <.main+2610>
test/lang/initByRef.ci:24:[.05a9f7, .05aa05) exec(1), time(0.002-0.002 ms): <.main+2619>
test/lang/initByRef.ci:25:[.05aa05, .05aa0e) exec(1), time(0.001-0.001 ms): <.main+2633>
test/lang/initByRef.ci:27:[.05aa0e, .05aa16) exec(1), time(0.001-0.001 ms): <.main+2642>
test/lang/initByRef.ci:28:[.05aa16, .05aa1e) exec(1), time(0.002-0.002 ms): <.main+2650>
test/lang/initByRef.ci:29:[.05aa1e, .05aa26) exec(1), time(0.001-0.001 ms): <.main+2658>
test/lang/initByRef.ci:30:[.05aa26, .05aa2e) exec(1), time(0.002-0.002 ms): <.main+2666>
test/lang/initByRef.ci:31:[.05aa2e, .05aa36) exec(1), time(0.020-0.020 ms): <.main+2674>
test/lang/initByRef.ci:32:[.05aa36, .05aa3e) exec(1), time(0.001-0.001 ms): <.main+2682>
test/lang/initByRef.ci:35:[.05aa3e, .05aa47) exec(1), time(0.002-0.002 ms): <.main+2690>
test/lang/initByRef.ci:36:[.05aa47, .05aa50) exec(1), time(0.001-0.001 ms): <.main+2699>
test/lang/initByRef.ci:37:[.05aa50, .05aa59) exec(1), time(0.001-0.001 ms): <.main+2708>
test/lang/initByRef.ci:38:[.05aa59, .05aa62) exec(1), time(0.002-0.002 ms): <.main+2717>
test/lang/initByRef.ci:39:[.05aa62, .05aa6b) exec(1), time(0.001-0.001 ms): <.main+2726>
test/lang/initByRef.ci:40:[.05aa6b, .05aa74) exec(1), time(0.001-0.001 ms): <.main+2735>
test/lang/initByRef.ci:41:[.05aa74, .05aa7d) exec(1), time(0.002-0.002 ms): <.main+2744>
test/lang/initByRef.ci:42:[.05aa7d, .05aa86) exec(1), time(0.001-0.001 ms): <.main+2753>
test/lang/initByRef.ci:43:[.05aa86, .05aa8f) exec(1), time(0.001-0.001 ms): <.main+2762>
test/lang/initByRef.ci:44:[.05aa8f, .05aa98) exec(1), time(0.002-0.002 ms): <.main+2771>
test/lang/initByRef.ci:45:[.05aa98, .05aaa1) exec(1), time(0.001-0.001 ms): <.main+2780>
test/lang/initByRef.ci:46:[.05aaa1, .05aaaa) exec(1), time(0.001-0.001 ms): <.main+2789>
test/lang/initByRef.ci:47:[.05aaaa, .05aab3) exec(1), time(0.002-0.002 ms): <.main+2798>
test/lang/initByRef.ci:48:[.05aab3, .05aabc) exec(1), time(0.001-0.001 ms): <.main+2807>
test/lang/initByRef.ci:49:[.05aabc, .05aac5) exec(1), time(0.001-0.001 ms): <.main+2816>
test/lang/initByRef.ci:50:[.05aac5, .05aace) exec(1), time(0.002-0.002 ms): <.main+2825>
test/lang/initByRef.ci:51:[.05aace, .05aad7) exec(1), time(0.002-0.002 ms): <.main+2834>
test/lang/initByRef.ci:52:[.05aad7, .05aae0) exec(1), time(0.001-0.001 ms): <.main+2843>
test/lang/initByRef.ci:55:[.05aae0, .05aaee) exec(1), time(0.002-0.002 ms): <.main+2852>
test/lang/initByRef.ci:56:[.05aaee, .05aafc) exec(1), time(0.002-0.002 ms): <.main+2866>
test/lang/initByRef.ci:57:[.05aafc, .05ab0a) exec(1), time(0.002-0.002 ms): <.main+2880>
test/lang/initByRef.ci:58:[.05ab0a, .05ab18) exec(1), time(0.002-0.002 ms): <.main+2894>
test/lang/initByRef.ci:59:[.05ab18, .05ab26) exec(1), time(0.002-0.002 ms): <.main+2908>
test/lang/initByRef.ci:60:[.05ab26, .05ab34) exec(1), time(0.002-0.002 ms): <.main+2922>
test/lang/initByRef.ci:61:[.05ab34, .05ab42) exec(1), time(0.002-0.002 ms): <.main+2936>
test/lang/initByRef.ci:62:[.05ab42, .05ab50) exec(1), time(0.001-0.001 ms): <.main+2950>
test/lang/initByRef.ci:63:[.05ab50, .05ab5e) exec(1), time(0.002-0.002 ms): <.main+2964>
test/lang/initByRef.ci:64:[.05ab5e, .05ab6c) exec(1), time(0.002-0.002 ms): <.main+2978>
test/lang/initByRef.ci:65:[.05ab6c, .05ab7a) exec(1), time(0.002-0.002 ms): <.main+2992>
test/lang/initByRef.ci:66:[.05ab7a, .05ab88) exec(1), time(0.002-0.002 ms): <.main+3006>
test/lang/initByRef.ci:67:[.05ab88, .05ab96) exec(1), time(0.002-0.002 ms): <.main+3020>
test/lang/initByRef.ci:68:[.05ab96, .05aba4) exec(1), time(0.002-0.002 ms): <.main+3034>
test/lang/initByRef.ci:69:[.05aba4, .05abb2) exec(1), time(0.001-0.001 ms): <.main+3048>
test/lang/initByRef.ci:70:[.05abb2, .05abc0) exec(1), time(0.002-0.002 ms): <.main+3062>
test/lang/initByRef.ci:71:[.05abc0, .05abce) exec(1), time(0.002-0.002 ms): <.main+3076>
test/lang/initByRef.ci:72:[.05abce, .05abdc) exec(1), time(0.002-0.002 ms): <.main+3090>
test/lang/initByRef.ci:75:[.05abdc, .05abe5) exec(1), time(0.001-0.001 ms): <.main+3104>
test/lang/initByRef.ci:76:[.05abe5, .05abee) exec(1), time(0.002-0.002 ms): <.main+3113>
test/lang/initByRef.ci:77:[.05abee, .05abf7) exec(1), time(0.001-0.001 ms): <.main+3122>
test/lang/initByRef.ci:78:[.05abf7, .05ac00) exec(1), time(0.001-0.001 ms): <.main+3131>
test/lang/initByRef.ci:79:[.05ac00, .05ac09) exec(1), time(0.002-0.002 ms): <.main+3140>
test/lang/initByRef.ci:80:[.05ac09, .05ac12) exec(1), time(0.001-0.001 ms): <.main+3149>
test/lang/initByRef.ci:81:[.05ac12, .05ac1b) exec(1), time(0.002-0.002 ms): <.main+3158>
test/lang/initByRef.ci:82:[.05ac1b, .05ac24) exec(1), time(0.001-0.001 ms): <.main+3167>
test/lang/initByRef.ci:83:[.05ac24, .05ac2d) exec(1), time(0.001-0.001 ms): <.main+3176>
test/lang/initByRef.ci:84:[.05ac2d, .05ac36) exec(1), time(0.002-0.002 ms): <.main+3185>
test/lang/initByRef.ci:85:[.05ac36, .05ac3f) exec(1), time(0.001-0.001 ms): <.main+3194>
test/lang/initByRef.ci:86:[.05ac3f, .05ac48) exec(1), time(0.001-0.001 ms): <.main+3203>
test/lang/initByRef.ci:87:[.05ac48, .05ac51) exec(1), time(0.002-0.002 ms): <.main+3212>
test/lang/initByRef.ci:88:[.05ac51, .05ac5a) exec(1), time(0.004-0.004 ms): <.main+3221>
test/lang/initByRef.ci:89:[.05ac5a, .05ac63) exec(1), time(0.001-0.001 ms): <.main+3230>
test/lang/initByRef.ci:90:[.05ac63, .05ac6c) exec(1), time(0.001-0.001 ms): <.main+3239>
test/lang/initByRef.ci:91:[.05ac6c, .05ac75) exec(1), time(0.001-0.001 ms): <.main+3248>
test/lang/initByRef.ci:92:[.05ac75, .05ac7e) exec(1), time(0.001-0.001 ms): <.main+3257>
test/lang/initByRef.ci:95:[.05ac7e, .05ac87) exec(1), time(0.001-0.001 ms): <.main+3266>
test/lang/initByRef.ci:96:[.05ac87, .05ac95) exec(1), time(0.002-0.002 ms): <.main+3275>
test/lang/initByRef.ci:97:[.05ac95, .05ac9e) exec(1), time(0.001-0.001 ms): <.main+3289>
test/lang/initByRef.ci:99:[.05ac9e, .05aca7) exec(1), time(0.002-0.002 ms): <.main+3298>
test/lang/initByRef.ci:105:[.05aca7, .05acb4) exec(1), time(0.002-0.002 ms): <.main+3307>
test/lang/initByRef.ci:108:[.05acb4, .05acbc) exec(1), time(0.002-0.002 ms): <.main+3320>
test/lang/function.ci:12:[.05acbc, .05acd5) exec(1), time(0.031-0.031 ms): <.main+3328>
test/lang/function.ci:15:[.05acd5, .05acde) exec(1), time(0.001-0.001 ms): <.main+3353>
test/lang/function.ci:18:[.05acde, .05acf6) exec(1), time(0.026-0.026 ms): <.main+3362>
test/lang/function.ci:21:[.05acf6, .05acff) exec(1), time(0.001-0.001 ms): <.main+3386>
test/lang/function.ci:24:[.05acff, .05ad17) exec(1), time(0.026-0.026 ms): <.main+3395>
test/lang/function.ci:27:[.05ad17, .05ad1f) exec(1), time(0.002-0.002 ms): <.main+3419>
test/lang/function.ci:30:[.05ad1f, .05ad37) exec(1), time(0.026-0.026 ms): <.main+3427>
test/lang/function.ci:46:[.05ad37, .05ad4b) exec(1), time(20.659-20.659 ms): <.main+3451>
test/lang/reflect.ci:3:[.05ad4b, .05ad53) exec(1), time(0.001-0.001 ms): <.main+3471>
test/lang/reflect.ci:4:[.05ad53, .05ad5b) exec(1), time(0.001-0.001 ms): <.main+3479>
test/lang/reflect.ci:5:[.05ad5b, .05ad63) exec(1), time(0.002-0.002 ms): <.main+3487>
test/lang/reflect.ci:6:[.05ad63, .05ad6b) exec(1), time(0.001-0.001 ms): <.main+3495>
test/lang/reflect.ci:7:[.05ad6b, .05ad73) exec(1), time(0.001-0.001 ms): <.main+3503>
test/lang/reflect.ci:8:[.05ad73, .05ad7b) exec(1), time(0.002-0.002 ms): <.main+3511>
test/lang/reflect.ci:9:[.05ad7b, .05ad83) exec(1), time(0.001-0.001 ms): <.main+3519>
test/lang/reflect.ci:10:[.05ad83, .05ad8b) exec(1), time(0.001-0.001 ms): <.main+3527>
test/lang/reflect.ci:11:[.05ad8b, .05ad93) exec(1), time(0.001-0.001 ms): <.main+3535>
test/lang/reflect.ci:12:[.05ad93, .05ad9b) exec(1), time(0.002-0.002 ms): <.main+3543>
test/lang/reflect.ci:13:[.05ad9b, .05ada3) exec(1), time(0.001-0.001 ms): <.main+3551>
test/lang/reflect.ci:14:[.05ada3, .05adab) exec(1), time(0.001-0.001 ms): <.main+3559>
test/lang/reflect.ci:15:[.05adab, .05adb3) exec(1), time(0.002-0.002 ms): <.main+3567>
test/lang/reflect.ci:16:[.05adb3, .05adbb) exec(1), time(0.001-0.001 ms): <.main+3575>
test/lang/reflect.ci:17:[.05adbb, .05adc3) exec(1), time(0.002-0.002 ms): <.main+3583>
test/lang/reflect.ci:18:[.05adc3, .05adcb) exec(1), time(0.001-0.001 ms): <.main+3591>
test/lang/reflect.ci:19:[.05adcb, .05add3) exec(1), time(0.001-0.001 ms): <.main+3599>
test/lang/reflect.ci:20:[.05add3, .05addb) exec(1), time(0.002-0.002 ms): <.main+3607>
test/lang/reflect.ci:30:[.05addb, .05ade4) exec(1), time(0.001-0.001 ms): <.main+3615>
test/lang/reflect.ci:31:[.05ade4, .05adf0) exec(1), time(0.037-0.037 ms): <.main+3624>
test/lang/reflect.ci:32:[.05adf0, .05adfd) exec(1), time(0.003-0.003 ms): <.main+3636>
test/lang/reflect.ci:33:[.05adfd, .05ae0a) exec(1), time(0.003-0.003 ms): <.main+3649>
test/lang/reflect.ci:34:[.05ae0a, .05ae16) exec(1), time(0.029-0.029 ms): <.main+3662>
test/lang/reflect.ci:35:[.05ae16, .05ae22) exec(1), time(0.029-0.029 ms): <.main+3674>
test/lang/reflect.ci:37:[.05ae22, .05ae2e) exec(1), time(0.028-0.028 ms): <.main+3686>
test/lang/reflect.ci:38:[.05ae2e, .05ae3a) exec(1), time(0.028-0.028 ms): <.main+3698>
test/lang/reflect.ci:39:[.05ae3a, .05ae47) exec(1), time(0.003-0.003 ms): <.main+3710>
test/lang/reflect.ci:40:[.05ae47, .05ae54) exec(1), time(0.002-0.002 ms): <.main+3723>
test/lang/reflect.ci:41:[.05ae54, .05ae60) exec(1), time(0.028-0.028 ms): <.main+3736>
test/lang/reflect.ci:42:[.05ae60, .05ae6c) exec(1), time(0.028-0.028 ms): <.main+3748>
test/lang/reflect.ci:44:[.05ae6c, .05ae78) exec(1), time(0.028-0.028 ms): <.main+3760>
test/lang/reflect.ci:45:[.05ae78, .05ae85) exec(1), time(0.002-0.002 ms): <.main+3772>
test/lang/reflect.ci:46:[.05ae85, .05ae92) exec(1), time(0.003-0.003 ms): <.main+3785>
test/lang/reflect.ci:48:[.05ae92, .05ae9e) exec(1), time(0.025-0.025 ms): <.main+3798>
test/lang/reflect.ci:49:[.05ae9e, .05aeab) exec(1), time(0.003-0.003 ms): <.main+3810>
test/lang/reflect.ci:50:[.05aeab, .05aeb8) exec(1), time(0.003-0.003 ms): <.main+3823>
test/std/number.ci:3:[.05aeb8, .05aec5) exec(1), time(0.002-0.002 ms): <.main+3836>
test/std/number.ci:4:[.05aec5, .05aed2) exec(1), time(0.002-0.002 ms): <.main+3849>
test/std/number.ci:6:[.05aed2, .05aedb) exec(1), time(0.002-0.002 ms): <.main+3862>
test/std/number.ci:7:[.05aedb, .05aee4) exec(1), time(0.002-0.002 ms): <.main+3871>
test/std/number.ci:14:[.05aee4, .05aeef) exec(1), time(0.002-0.002 ms): <.main+3880>
test/std/number.ci:15:[.05aeef, .05aefa) exec(1), time(0.002-0.002 ms): <.main+3891>
test/std/number.ci:16:[.05aefa, .05af05) exec(1), time(0.002-0.002 ms): <.main+3902>
test/std/number.ci:18:[.05af05, .05af2b) exec(1), time(0.010-0.010 ms): <.main+3913>
test/std/number.ci:19:[.05af2b, .05af4f) exec(1), time(0.009-0.009 ms): <.main+3951>
test/std/number.ci:21:[.05af4f, .05af65) exec(1), time(0.043-0.043 ms): <.main+3987>
test/std/number.ci:22:[.05af65, .05af7b) exec(1), time(0.028-0.028 ms): <.main+4009>
test/std/number.ci:23:[.05af7b, .05af8d) exec(1), time(0.039-0.039 ms): <.main+4031>
test/std/number.ci:25:[.05af8d, .05afa3) exec(1), time(0.026-0.026 ms): <.main+4049>
test/std/number.ci:26:[.05afa3, .05afb9) exec(1), time(0.026-0.026 ms): <.main+4071>
test/std/number.ci:27:[.05afb9, .05afcb) exec(1), time(0.025-0.025 ms): <.main+4093>
test/std/number.ci:29:[.05afcb, .05afe1) exec(1), time(0.026-0.026 ms): <.main+4111>
test/std/number.ci:30:[.05afe1, .05aff7) exec(1), time(0.026-0.026 ms): <.main+4133>
test/std/number.ci:31:[.05aff7, .05b009) exec(1), time(0.026-0.026 ms): <.main+4155>
test/std/number.ci:33:[.05b009, .05b01f) exec(1), time(0.026-0.026 ms): <.main+4173>
test/std/number.ci:34:[.05b01f, .05b035) exec(1), time(0.026-0.026 ms): <.main+4195>
test/std/number.ci:35:[.05b035, .05b047) exec(1), time(0.026-0.026 ms): <.main+4217>
test/std/number.ci:37:[.05b047, .05b05d) exec(1), time(0.044-0.044 ms): <.main+4235>
test/std/number.ci:38:[.05b05d, .05b073) exec(1), time(0.032-0.032 ms): <.main+4257>
test/std/number.ci:39:[.05b073, .05b089) exec(1), time(0.026-0.026 ms): <.main+4279>
test/std/number.ci:40:[.05b089, .05b09f) exec(1), time(0.051-0.051 ms): <.main+4301>
test/std/number.ci:41:[.05b09f, .05b0b0) exec(1), time(0.040-0.040 ms): <.main+4323>
test/std/number.ci:42:[.05b0b0, .05b0ca) exec(1), time(0.030-0.030 ms): <.main+4340>
test/std/number.ci:43:[.05b0ca, .05b0db) exec(1), time(0.026-0.026 ms): <.main+4366>
test/std/number.ci:44:[.05b0db, .05b0f0) exec(1), time(0.028-0.028 ms): <.main+4383>
test/std/number.ci:46:[.05b0f0, .05b102) exec(1), time(0.027-0.027 ms): <.main+4404>
test/std/number.ci:47:[.05b102, .05b114) exec(1), time(0.026-0.026 ms): <.main+4422>
test/std/number.ci:48:[.05b114, .05b126) exec(1), time(0.029-0.029 ms): <.main+4440>
test/std/number.ci:49:[.05b126, .05b13c) exec(1), time(0.027-0.027 ms): <.main+4458>
test/std/number.ci:50:[.05b13c, .05b149) exec(1), time(0.024-0.024 ms): <.main+4480>
test/std/number.ci:51:[.05b149, .05b15f) exec(1), time(0.027-0.027 ms): <.main+4493>
test/std/number.ci:52:[.05b15f, .05b170) exec(1), time(0.026-0.026 ms): <.main+4515>
test/std/number.ci:53:[.05b170, .05b181) exec(1), time(0.028-0.028 ms): <.main+4532>
test/std/number.ci:55:[.05b181, .05b18d) exec(1), time(0.025-0.025 ms): <.main+4549>
test/std/number.ci:56:[.05b18d, .05b199) exec(1), time(0.025-0.025 ms): <.main+4561>
test/std/number.ci:57:[.05b199, .05b1a5) exec(1), time(0.062-0.062 ms): <.main+4573>
test/std/number.ci:58:[.05b1a5, .05b1b1) exec(1), time(0.025-0.025 ms): <.main+4585>
test/std/number.ci:59:[.05b1b1, .05b1bd) exec(1), time(0.025-0.025 ms): <.main+4597>
test/std/number.ci:60:[.05b1bd, .05b1c9) exec(1), time(0.038-0.038 ms): <.main+4609>
test/std/number.ci:62:[.05b1c9, .05b1db) exec(1), time(0.026-0.026 ms): <.main+4621>
test/std/number.ci:63:[.05b1db, .05b1ed) exec(1), time(0.029-0.029 ms): <.main+4639>
test/std/number.ci:65:[.05b1ed, .05b201) exec(1), time(0.028-0.028 ms): <.main+4657>
test/std/number.ci:66:[.05b201, .05b215) exec(1), time(0.028-0.028 ms): <.main+4677>
test/std/memory.ci:7:[.05b215, .05b227) exec(1), time(0.027-0.027 ms): <.main+4697>
test/std/memory.ci:8:[.05b227, .05b239) exec(1), time(0.026-0.026 ms): <.main+4715>
test/std/memory.ci:9:[.05b239, .05b24b) exec(1), time(0.026-0.026 ms): <.main+4733>
test/std/memory.ci:10:[.05b24b, .05b25d) exec(1), time(0.028-0.028 ms): <.main+4751>
test/std/memory.ci:23:[.05b25d, .05b26a) exec(1), time(0.001-0.001 ms): <.main+4769>
test/std/memory.ci:24:[.05b26a, .05b277) exec(1), time(0.001-0.001 ms): <.main+4782>
test/std/tryExec.ci:46:[.05b277, .05b289) exec(1), time(0.064-0.064 ms): <.main+4795>
test/std/tryExec.ci:47:[.05b289, .05b29b) exec(1), time(0.028-0.028 ms): <.main+4813>
test/std/tryExec.ci:48:[.05b29b, .05b2ad) exec(1), time(3.383-3.383 ms): <.main+4831>
test/std/tryExec.ci:49:[.05b2ad, .05b2bf) exec(1), time(0.063-0.063 ms): <.main+4849>
test/std/tryExec.ci:50:[.05b2bf, .05b2d1) exec(1), time(0.044-0.044 ms): <.main+4867>
test/std/tryExec.ci:51:[.05b2d1, .05b2e3) exec(1), time(0.046-0.046 ms): <.main+4885>
test/std/tryExec.ci:52:[.05b2e3, .05b2f5) exec(1), time(0.179-0.179 ms): <.main+4903>
test/lang/array.ci:59:[.05b2f5, .05b2fe) exec(1), time(0.001-0.001 ms): <.main+4921>
test/lang/array.ci:60:[.05b2fe, .05b308) exec(1), time(0.003-0.003 ms): <.main+4930>
test/lang/array.ci:63:[.05b308, .05b311) exec(1), time(0.002-0.002 ms): <.main+4940>
test/lang/array.ci:64:[.05b311, .05b31f) exec(1), time(0.002-0.002 ms): <.main+4949>
test/lang/array.ci:67:[.05b31f, .05b327) exec(1), time(0.001-0.001 ms): <.main+4963>
test/lang/array.ci:68:[.05b327, .05b32f) exec(1), time(0.001-0.001 ms): <.main+4971>
test/lang/array.ci:71:[.05b32f, .05b337) exec(1), time(0.002-0.002 ms): <.main+4979>
test/lang/array.ci:86:[.05b337, .05b340) exec(1), time(0.002-0.002 ms): <.main+4987>
test/lang/array.ci:90:[.05b340, .05b34e) exec(1), time(0.002-0.002 ms): <.main+4996>
test/lang/member.ci:35:[.05b34e, .05b353) exec(1), time(0.001-0.001 ms): <.main+5010>
test/lang/member.ci:38:[.05b353, .05b35c) exec(1), time(0.001-0.001 ms): <.main+5015>
test/lang/member.ci:41:[.05b35c, .05b365) exec(1), time(0.001-0.001 ms): <.main+5024>
test/lang/member.ci:47:[.05b36e, .05b377) exec(1), time(0.001-0.001 ms): <.main+5042>
test/lang/member.ci:47:[.05b365, .05b377) exec(1-1), time(0.000 ms): <.main+5033>
test/lang/member.ci:50:[.05b380, .05b389) exec(1), time(0.001-0.001 ms): <.main+5060>
test/lang/member.ci:50:[.05b377, .05b389) exec(1-1), time(0.000 ms): <.main+5051>
test/lang/member.ci:55:[.05b392, .05b39b) exec(1), time(0.001-0.001 ms): <.main+5078>
test/lang/member.ci:56:[.05b39b, .05b3a4) exec(1), time(0.001-0.001 ms): <.main+5087>
test/lang/member.ci:57:[.05b3a4, .05b3ad) exec(1), time(0.001-0.001 ms): <.main+5096>
test/lang/member.ci:60:[.05b3ad, .05b3b6) exec(1), time(0.001-0.001 ms): <.main+5105>
test/lang/member.ci:61:[.05b3b6, .05b3bf) exec(1), time(0.001-0.001 ms): <.main+5114>
test/lang/member.ci:65:[.05b3bf, .05b3c8) exec(1), time(0.002-0.002 ms): <.main+5123>
test/lang/member.ci:66:[.05b3c8, .05b3d1) exec(1), time(0.002-0.002 ms): <.main+5132>
test/lang/member.ci:53:[.05b389, .05b3d1) exec(1-1), time(0.000 ms): <.main+5069>
test/lang/method.ci:18:[.05b3d1, .05b3da) exec(1), time(0.002-0.002 ms): <.main+5141>
::[.05b3e3, .05b3eb) exec(1), time(0.002-0.002 ms): <.main+5159>
::[.05b3eb, .05b3f4) exec(1), time(0.002-0.002 ms): <.main+5167>
test/lang/method.ci:62:[.05b3da, .05b3f4) exec(1-1), time(0.000 ms): <.main+5150>
test/lang/recUnion.ci:26:[.05b3fb, .05b402) exec(1), time(0.025-0.025 ms): <.main+5183>
test/lang/recUnion.ci:26:[.05b402, .05b409) exec(1), time(0.002-0.002 ms): <.main+5190>
test/lang/recUnion.ci:26:[.05b3f4, .05b409) exec(1-1), time(0.000 ms): <.main+5176>
test/lang/recUnion.ci:27:[.05b410, .05b41b) exec(1), time(0.002-0.002 ms): <.main+5204>
test/lang/recUnion.ci:27:[.05b41b, .05b422) exec(1), time(0.002-0.002 ms): <.main+5215>
test/lang/recUnion.ci:27:[.05b409, .05b422) exec(1-1), time(0.000 ms): <.main+5197>
test/lang/recUnion.ci:28:[.05b42d, .05b438) exec(1), time(0.002-0.002 ms): <.main+5233>
test/lang/recUnion.ci:28:[.05b438, .05b443) exec(1), time(0.002-0.002 ms): <.main+5244>
test/lang/recUnion.ci:28:[.05b422, .05b443) exec(1-1), time(0.000 ms): <.main+5222>
test/lang/recUnion.ci:30:[.05b443, .05b44c) exec(1), time(0.001-0.001 ms): <.main+5255>
test/lang/recUnion.ci:31:[.05b453, .05b45a) exec(1), time(0.002-0.002 ms): <.main+5271>
test/lang/recUnion.ci:31:[.05b45a, .05b465) exec(1), time(0.003-0.003 ms): <.main+5278>
test/lang/recUnion.ci:31:[.05b44c, .05b465) exec(1-1), time(0.000 ms): <.main+5264>
test/lang/useOperator.ci:5:[.05b465, .05b46e) exec(1), time(0.002-0.002 ms): <.main+5289>
test/lang/useOperator.ci:7:[.05b46e, .05b479) exec(1), time(0.002-0.002 ms): <.main+5298>
test/lang/useOperator.ci:8:[.05b479, .05b484) exec(1), time(0.002-0.002 ms): <.main+5309>
test/lang/useOperator.ci:17:[.05b484, .05b497) exec(1), time(0.006-0.006 ms): <.main+5320>
test/lang/useOperator.ci:18:[.05b497, .05b4aa) exec(1), time(0.006-0.006 ms): <.main+5339>
test/lang/useOperator.ci:19:[.05b4aa, .05b4bd) exec(1), time(0.005-0.005 ms): <.main+5358>
test/lang/useOperator.ci:22:[.05b4bd, .05b4ca) exec(1), time(0.004-0.004 ms): <.main+5377>
test/lang/useOperator.ci:23:[.05b4ca, .05b4dd) exec(1), time(0.006-0.006 ms): <.main+5390>
test/lang/useOperator.ci:24:[.05b4dd, .05b4f1) exec(1), time(0.006-0.006 ms): <.main+5409>
test/lang/useOperator.ci:25:[.05b4f1, .05b504) exec(1), time(0.005-0.005 ms): <.main+5429>
test/lang/useOperator.ci:26:[.05b504, .05b518) exec(1), time(0.006-0.006 ms): <.main+5448>
test/lang/useOperator.ci:27:[.05b518, .05b52b) exec(1), time(0.005-0.005 ms): <.main+5468>
test/lang/useOperator.ci:28:[.05b52b, .05b53f) exec(1), time(0.006-0.006 ms): <.main+5487>
test/lang/useOperator.ci:30:[.05b53f, .05b54a) exec(1), time(0.003-0.003 ms): <.main+5507>
test/lang/useOperator.ci:31:[.05b54a, .05b555) exec(1), time(0.002-0.002 ms): <.main+5518>
test/lang/useOperator.ci:32:[.05b555, .05b561) exec(1), time(0.003-0.003 ms): <.main+5529>
test/lang/useOperator.ci:33:[.05b561, .05b56e) exec(1), time(0.004-0.004 ms): <.main+5541>
test/lang/useOperator.ci:34:[.05b56e, .05b57b) exec(1), time(0.004-0.004 ms): <.main+5554>
test/lang/useOperator.ci:35:[.05b57b, .05b58e) exec(1), time(0.006-0.006 ms): <.main+5567>
test/lang/useOperator.ci:36:[.05b58e, .05b5a1) exec(1), time(0.005-0.005 ms): <.main+5586>
test/lang/useOperator.ci:37:[.05b5a1, .05b5b4) exec(1), time(0.006-0.006 ms): <.main+5605>
test/lang/useOperator.ci:38:[.05b5b4, .05b5c7) exec(1), time(0.006-0.006 ms): <.main+5624>
test/lang/useOperator.ci:39:[.05b5c7, .05b5da) exec(1), time(0.006-0.006 ms): <.main+5643>
test/lang/useOperator.ci:40:[.05b5da, .05b5ed) exec(1), time(0.005-0.005 ms): <.main+5662>
test/lang/useOperator.ci:41:[.05b5ed, .05b600) exec(1), time(0.005-0.005 ms): <.main+5681>
test/lang/useOperator.ci:42:[.05b600, .05b613) exec(1), time(0.005-0.005 ms): <.main+5700>
test/lang/useOperator.ci:43:[.05b613, .05b624) exec(1), time(0.004-0.004 ms): <.main+5719>
test/lang/useOperator.ci:44:[.05b624, .05b635) exec(1), time(0.004-0.004 ms): <.main+5736>
test/lang/useOperator.ci:45:[.05b635, .05b643) exec(1), time(0.005-0.005 ms): <.main+5753>
test/lang/useOperator.ci:46:[.05b643, .05b656) exec(1), time(0.006-0.006 ms): <.main+5767>
test/lang/useOperator.ci:47:[.05b656, .05b66a) exec(1), time(0.006-0.006 ms): <.main+5786>
test/lang/useOperator.ci:48:[.05b66a, .05b67d) exec(1), time(0.005-0.005 ms): <.main+5806>
test/lang/useOperator.ci:49:[.05b67d, .05b691) exec(1), time(0.006-0.006 ms): <.main+5825>
test/lang/useOperator.ci:50:[.05b691, .05b6a4) exec(1), time(0.006-0.006 ms): <.main+5845>
test/lang/useOperator.ci:51:[.05b6a4, .05b6b8) exec(1), time(0.006-0.006 ms): <.main+5864>
test/lang/useOperator.ci:53:[.05b6b8, .05b6c3) exec(1), time(0.002-0.002 ms): <.main+5884>
test/lang/useOperator.ci:54:[.05b6c3, .05b6ce) exec(1), time(0.002-0.002 ms): <.main+5895>
test/lang/useOperator.ci:55:[.05b6ce, .05b6da) exec(1), time(0.003-0.003 ms): <.main+5906>
test/lang/useOperator.ci:56:[.05b6da, .05b6e7) exec(1), time(0.004-0.004 ms): <.main+5918>
test/lang/useOperator.ci:57:[.05b6e7, .05b6f4) exec(1), time(0.004-0.004 ms): <.main+5931>
test/lang/useOperator.ci:58:[.05b6f4, .05b707) exec(1), time(0.006-0.006 ms): <.main+5944>
test/lang/useOperator.ci:59:[.05b707, .05b71a) exec(1), time(0.006-0.006 ms): <.main+5963>
test/lang/useOperator.ci:60:[.05b71a, .05b72d) exec(1), time(0.005-0.005 ms): <.main+5982>
test/lang/useOperator.ci:61:[.05b72d, .05b740) exec(1), time(0.006-0.006 ms): <.main+6001>
test/lang/useOperator.ci:62:[.05b740, .05b753) exec(1), time(0.006-0.006 ms): <.main+6020>
test/lang/useOperator.ci:63:[.05b753, .05b766) exec(1), time(0.006-0.006 ms): <.main+6039>
test/lang/useOperator.ci:64:[.05b766, .05b779) exec(1), time(0.006-0.006 ms): <.main+6058>
test/lang/useOperator.ci:65:[.05b779, .05b78c) exec(1), time(0.006-0.006 ms): <.main+6077>
test/lang/useOperator.ci:66:[.05b78c, .05b79d) exec(1), time(0.005-0.005 ms): <.main+6096>
test/lang/useOperator.ci:67:[.05b79d, .05b7ae) exec(1), time(0.005-0.005 ms): <.main+6113>
test/lang/useOperator.ci:68:[.05b7ae, .05b7bc) exec(1), time(0.004-0.004 ms): <.main+6130>
test/lang/useOperator.ci:69:[.05b7bc, .05b7cf) exec(1), time(0.005-0.005 ms): <.main+6144>
test/lang/useOperator.ci:70:[.05b7cf, .05b7e3) exec(1), time(0.006-0.006 ms): <.main+6163>
test/lang/useOperator.ci:71:[.05b7e3, .05b7f6) exec(1), time(0.005-0.005 ms): <.main+6183>
test/lang/useOperator.ci:72:[.05b7f6, .05b80a) exec(1), time(0.006-0.006 ms): <.main+6202>
test/lang/useOperator.ci:73:[.05b80a, .05b81d) exec(1), time(0.006-0.006 ms): <.main+6222>
test/lang/useOperator.ci:74:[.05b81d, .05b831) exec(1), time(0.006-0.006 ms): <.main+6241>
test/lang/useOperator.ci:76:[.05b831, .05b83c) exec(1), time(0.003-0.003 ms): <.main+6261>
test/lang/useOperator.ci:77:[.05b83c, .05b847) exec(1), time(0.003-0.003 ms): <.main+6272>
test/lang/useOperator.ci:78:[.05b847, .05b853) exec(1), time(0.003-0.003 ms): <.main+6283>
test/lang/useOperator.ci:79:[.05b853, .05b860) exec(1), time(0.004-0.004 ms): <.main+6295>
test/lang/useOperator.ci:80:[.05b860, .05b86d) exec(1), time(0.004-0.004 ms): <.main+6308>
test/lang/useOperator.ci:81:[.05b86d, .05b880) exec(1), time(0.027-0.027 ms): <.main+6321>
test/lang/useOperator.ci:82:[.05b880, .05b893) exec(1), time(0.006-0.006 ms): <.main+6340>
test/lang/useOperator.ci:83:[.05b893, .05b8a6) exec(1), time(0.006-0.006 ms): <.main+6359>
test/lang/useOperator.ci:84:[.05b8a6, .05b8b9) exec(1), time(0.006-0.006 ms): <.main+6378>
test/lang/useOperator.ci:85:[.05b8b9, .05b8cc) exec(1), time(0.006-0.006 ms): <.main+6397>
test/lang/useOperator.ci:86:[.05b8cc, .05b8df) exec(1), time(0.019-0.019 ms): <.main+6416>
test/lang/useOperator.ci:87:[.05b8df, .05b8f2) exec(1), time(0.006-0.006 ms): <.main+6435>
test/lang/useOperator.ci:88:[.05b8f2, .05b905) exec(1), time(0.006-0.006 ms): <.main+6454>
test/lang/useOperator.ci:89:[.05b905, .05b916) exec(1), time(0.004-0.004 ms): <.main+6473>
test/lang/useOperator.ci:90:[.05b916, .05b927) exec(1), time(0.005-0.005 ms): <.main+6490>
test/lang/useOperator.ci:91:[.05b927, .05b935) exec(1), time(0.005-0.005 ms): <.main+6507>
test/lang/useOperator.ci:92:[.05b935, .05b948) exec(1), time(0.005-0.005 ms): <.main+6521>
test/lang/useOperator.ci:93:[.05b948, .05b95c) exec(1), time(0.006-0.006 ms): <.main+6540>
test/lang/useOperator.ci:94:[.05b95c, .05b96f) exec(1), time(0.005-0.005 ms): <.main+6560>
test/lang/useOperator.ci:95:[.05b96f, .05b983) exec(1), time(0.006-0.006 ms): <.main+6579>
test/lang/useOperator.ci:96:[.05b983, .05b996) exec(1), time(0.005-0.005 ms): <.main+6599>
test/lang/useOperator.ci:97:[.05b996, .05b9aa) exec(1), time(0.006-0.006 ms): <.main+6618>
test/lang/useOperator.ci:99:[.05b9aa, .05b9b5) exec(1), time(0.002-0.002 ms): <.main+6638>
test/lang/useOperator.ci:100:[.05b9b5, .05b9c0) exec(1), time(0.002-0.002 ms): <.main+6649>
test/lang/useOperator.ci:101:[.05b9c0, .05b9cc) exec(1), time(0.003-0.003 ms): <.main+6660>
test/lang/useOperator.ci:102:[.05b9cc, .05b9d9) exec(1), time(0.004-0.004 ms): <.main+6672>
test/lang/useOperator.ci:103:[.05b9d9, .05b9e6) exec(1), time(0.004-0.004 ms): <.main+6685>
test/lang/useOperator.ci:104:[.05b9e6, .05b9f9) exec(1), time(0.005-0.005 ms): <.main+6698>
test/lang/useOperator.ci:105:[.05b9f9, .05ba0c) exec(1), time(0.005-0.005 ms): <.main+6717>
test/lang/useOperator.ci:106:[.05ba0c, .05ba1f) exec(1), time(0.006-0.006 ms): <.main+6736>
test/lang/useOperator.ci:107:[.05ba1f, .05ba32) exec(1), time(0.006-0.006 ms): <.main+6755>
test/lang/useOperator.ci:108:[.05ba32, .05ba45) exec(1), time(0.006-0.006 ms): <.main+6774>
test/lang/useOperator.ci:109:[.05ba45, .05ba58) exec(1), time(0.005-0.005 ms): <.main+6793>
test/lang/useOperator.ci:110:[.05ba58, .05ba6b) exec(1), time(0.006-0.006 ms): <.main+6812>
test/lang/useOperator.ci:111:[.05ba6b, .05ba7e) exec(1), time(0.006-0.006 ms): <.main+6831>
test/lang/useOperator.ci:112:[.05ba7e, .05ba8f) exec(1), time(0.005-0.005 ms): <.main+6850>
test/lang/useOperator.ci:113:[.05ba8f, .05baa0) exec(1), time(0.005-0.005 ms): <.main+6867>
test/lang/useOperator.ci:114:[.05baa0, .05baae) exec(1), time(0.005-0.005 ms): <.main+6884>
test/lang/useOperator.ci:115:[.05baae, .05bac1) exec(1), time(0.006-0.006 ms): <.main+6898>
test/lang/useOperator.ci:116:[.05bac1, .05bad5) exec(1), time(0.007-0.007 ms): <.main+6917>
test/lang/useOperator.ci:117:[.05bad5, .05bae8) exec(1), time(0.006-0.006 ms): <.main+6937>
test/lang/useOperator.ci:118:[.05bae8, .05bafc) exec(1), time(0.006-0.006 ms): <.main+6956>
test/lang/useOperator.ci:119:[.05bafc, .05bb0f) exec(1), time(0.005-0.005 ms): <.main+6976>
test/lang/useOperator.ci:120:[.05bb0f, .05bb23) exec(1), time(0.007-0.007 ms): <.main+6995>
test/lang/useOperator.ci:122:[.05bb23, .05bb2e) exec(1), time(0.003-0.003 ms): <.main+7015>
test/lang/useOperator.ci:123:[.05bb2e, .05bb39) exec(1), time(0.003-0.003 ms): <.main+7026>
test/lang/useOperator.ci:124:[.05bb39, .05bb45) exec(1), time(0.003-0.003 ms): <.main+7037>
test/lang/useOperator.ci:125:[.05bb45, .05bb52) exec(1), time(0.004-0.004 ms): <.main+7049>
test/lang/useOperator.ci:126:[.05bb52, .05bb5f) exec(1), time(0.004-0.004 ms): <.main+7062>
test/lang/useOperator.ci:127:[.05bb5f, .05bb72) exec(1), time(0.006-0.006 ms): <.main+7075>
test/lang/useOperator.ci:128:[.05bb72, .05bb85) exec(1), time(0.006-0.006 ms): <.main+7094>
test/lang/useOperator.ci:129:[.05bb85, .05bb98) exec(1), time(0.006-0.006 ms): <.main+7113>
test/lang/useOperator.ci:130:[.05bb98, .05bbab) exec(1), time(0.005-0.005 ms): <.main+7132>
test/lang/useOperator.ci:131:[.05bbab, .05bbbe) exec(1), time(0.006-0.006 ms): <.main+7151>
test/lang/useOperator.ci:132:[.05bbbe, .05bbd1) exec(1), time(0.006-0.006 ms): <.main+7170>
test/lang/useOperator.ci:133:[.05bbd1, .05bbe4) exec(1), time(0.006-0.006 ms): <.main+7189>
test/lang/useOperator.ci:134:[.05bbe4, .05bbf7) exec(1), time(0.006-0.006 ms): <.main+7208>
test/lang/useOperator.ci:135:[.05bbf7, .05bc08) exec(1), time(0.005-0.005 ms): <.main+7227>
test/lang/useOperator.ci:136:[.05bc08, .05bc19) exec(1), time(0.005-0.005 ms): <.main+7244>
test/lang/useOperator.ci:137:[.05bc19, .05bc27) exec(1), time(0.005-0.005 ms): <.main+7261>
test/lang/useOperator.ci:138:[.05bc27, .05bc3a) exec(1), time(0.006-0.006 ms): <.main+7275>
test/lang/useOperator.ci:139:[.05bc3a, .05bc4e) exec(1), time(0.006-0.006 ms): <.main+7294>
test/lang/useOperator.ci:140:[.05bc4e, .05bc61) exec(1), time(0.006-0.006 ms): <.main+7314>
test/lang/useOperator.ci:141:[.05bc61, .05bc75) exec(1), time(0.007-0.007 ms): <.main+7333>
test/lang/useOperator.ci:142:[.05bc75, .05bc88) exec(1), time(0.006-0.006 ms): <.main+7353>
test/lang/useOperator.ci:143:[.05bc88, .05bc9c) exec(1), time(0.007-0.007 ms): <.main+7372>
test/lang/useOperator.ci:145:[.05bc9c, .05bca5) exec(1), time(0.001-0.001 ms): <.main+7392>
test/lang/useOperator.ci:146:[.05bca5, .05bcae) exec(1), time(0.001-0.001 ms): <.main+7401>
test/lang/useOperator.ci:147:[.05bcae, .05bcb6) exec(1), time(0.002-0.002 ms): <.main+7410>
test/lang/useOperator.ci:148:[.05bcb6, .05bcbf) exec(1), time(0.003-0.003 ms): <.main+7418>
test/lang/useOperator.ci:149:[.05bcbf, .05bcc8) exec(1), time(0.002-0.002 ms): <.main+7427>
test/lang/useOperator.ci:150:[.05bcc8, .05bcd5) exec(1), time(0.003-0.003 ms): <.main+7436>
test/lang/useOperator.ci:151:[.05bcd5, .05bce2) exec(1), time(0.003-0.003 ms): <.main+7449>
test/lang/useOperator.ci:152:[.05bce2, .05bcef) exec(1), time(0.003-0.003 ms): <.main+7462>
test/lang/useOperator.ci:153:[.05bcef, .05bcfc) exec(1), time(0.004-0.004 ms): <.main+7475>
test/lang/useOperator.ci:154:[.05bcfc, .05bd09) exec(1), time(0.004-0.004 ms): <.main+7488>
test/lang/useOperator.ci:155:[.05bd09, .05bd16) exec(1), time(0.004-0.004 ms): <.main+7501>
test/lang/useOperator.ci:156:[.05bd16, .05bd23) exec(1), time(0.003-0.003 ms): <.main+7514>
test/lang/useOperator.ci:157:[.05bd23, .05bd30) exec(1), time(0.003-0.003 ms): <.main+7527>
test/lang/useOperator.ci:158:[.05bd30, .05bd3d) exec(1), time(0.003-0.003 ms): <.main+7540>
test/lang/useOperator.ci:159:[.05bd3d, .05bd4a) exec(1), time(0.004-0.004 ms): <.main+7553>
test/lang/useOperator.ci:160:[.05bd4a, .05bd56) exec(1), time(0.005-0.005 ms): <.main+7566>
test/lang/useOperator.ci:161:[.05bd56, .05bd65) exec(1), time(0.004-0.004 ms): <.main+7578>
test/lang/useOperator.ci:162:[.05bd65, .05bd75) exec(1), time(0.005-0.005 ms): <.main+7593>
test/lang/useOperator.ci:163:[.05bd75, .05bd84) exec(1), time(0.004-0.004 ms): <.main+7609>
test/lang/useOperator.ci:164:[.05bd84, .05bd94) exec(1), time(0.005-0.005 ms): <.main+7624>
test/lang/useOperator.ci:165:[.05bd94, .05bda3) exec(1), time(0.005-0.005 ms): <.main+7640>
test/lang/useOperator.ci:166:[.05bda3, .05bdb3) exec(1), time(0.006-0.006 ms): <.main+7655>
test/lang/useOperator.ci:168:[.05bdb3, .05bdbc) exec(1), time(0.001-0.001 ms): <.main+7671>
test/lang/useOperator.ci:169:[.05bdbc, .05bdc5) exec(1), time(0.002-0.002 ms): <.main+7680>
test/lang/useOperator.ci:170:[.05bdc5, .05bdcd) exec(1), time(0.002-0.002 ms): <.main+7689>
test/lang/useOperator.ci:171:[.05bdcd, .05bdd6) exec(1), time(0.002-0.002 ms): <.main+7697>
test/lang/useOperator.ci:172:[.05bdd6, .05bddf) exec(1), time(0.003-0.003 ms): <.main+7706>
test/lang/useOperator.ci:173:[.05bddf, .05bdec) exec(1), time(0.004-0.004 ms): <.main+7715>
test/lang/useOperator.ci:174:[.05bdec, .05bdf9) exec(1), time(0.003-0.003 ms): <.main+7728>
test/lang/useOperator.ci:175:[.05bdf9, .05be06) exec(1), time(0.004-0.004 ms): <.main+7741>
test/lang/useOperator.ci:176:[.05be06, .05be13) exec(1), time(0.004-0.004 ms): <.main+7754>
test/lang/useOperator.ci:177:[.05be13, .05be20) exec(1), time(0.003-0.003 ms): <.main+7767>
test/lang/useOperator.ci:178:[.05be20, .05be2d) exec(1), time(0.004-0.004 ms): <.main+7780>
test/lang/useOperator.ci:179:[.05be2d, .05be3a) exec(1), time(0.004-0.004 ms): <.main+7793>
test/lang/useOperator.ci:180:[.05be3a, .05be47) exec(1), time(0.003-0.003 ms): <.main+7806>
test/lang/useOperator.ci:181:[.05be47, .05be54) exec(1), time(0.004-0.004 ms): <.main+7819>
test/lang/useOperator.ci:182:[.05be54, .05be61) exec(1), time(0.004-0.004 ms): <.main+7832>
test/lang/useOperator.ci:183:[.05be61, .05be6d) exec(1), time(0.004-0.004 ms): <.main+7845>
test/lang/useOperator.ci:184:[.05be6d, .05be7c) exec(1), time(0.005-0.005 ms): <.main+7857>
test/lang/useOperator.ci:185:[.05be7c, .05be8c) exec(1), time(0.005-0.005 ms): <.main+7872>
test/lang/useOperator.ci:186:[.05be8c, .05be9b) exec(1), time(0.005-0.005 ms): <.main+7888>
test/lang/useOperator.ci:187:[.05be9b, .05beab) exec(1), time(0.006-0.006 ms): <.main+7903>
test/lang/useOperator.ci:188:[.05beab, .05beba) exec(1), time(0.004-0.004 ms): <.main+7919>
test/lang/useOperator.ci:189:[.05beba, .05beca) exec(1), time(0.006-0.006 ms): <.main+7934>
test/lang/useOperator.ci:191:[.05beca, .05bed7) exec(1), time(0.001-0.001 ms): <.main+7950>
test/lang/useOperator.ci:192:[.05bed7, .05bee4) exec(1), time(0.002-0.002 ms): <.main+7963>
test/lang/useOperator.ci:193:[.05bee4, .05beec) exec(1), time(0.002-0.002 ms): <.main+7976>
test/lang/useOperator.ci:194:[.05beec, .05bef5) exec(1), time(0.002-0.002 ms): <.main+7984>
test/lang/useOperator.ci:195:[.05bef5, .05befe) exec(1), time(0.002-0.002 ms): <.main+7993>
test/lang/useOperator.ci:196:[.05befe, .05bf0b) exec(1), time(0.003-0.003 ms): <.main+8002>
test/lang/useOperator.ci:197:[.05bf0b, .05bf18) exec(1), time(0.004-0.004 ms): <.main+8015>
test/lang/useOperator.ci:198:[.05bf18, .05bf25) exec(1), time(0.004-0.004 ms): <.main+8028>
test/lang/useOperator.ci:199:[.05bf25, .05bf32) exec(1), time(0.004-0.004 ms): <.main+8041>
test/lang/useOperator.ci:200:[.05bf32, .05bf3f) exec(1), time(0.004-0.004 ms): <.main+8054>
test/lang/useOperator.ci:201:[.05bf3f, .05bf4c) exec(1), time(0.003-0.003 ms): <.main+8067>
test/lang/useOperator.ci:202:[.05bf4c, .05bf59) exec(1), time(0.003-0.003 ms): <.main+8080>
test/lang/useOperator.ci:203:[.05bf59, .05bf66) exec(1), time(0.003-0.003 ms): <.main+8093>
test/lang/useOperator.ci:204:[.05bf66, .05bf73) exec(1), time(0.004-0.004 ms): <.main+8106>
test/lang/useOperator.ci:205:[.05bf73, .05bf80) exec(1), time(0.004-0.004 ms): <.main+8119>
test/lang/useOperator.ci:206:[.05bf80, .05bf8c) exec(1), time(0.005-0.005 ms): <.main+8132>
test/lang/useOperator.ci:207:[.05bf8c, .05bf9b) exec(1), time(0.004-0.004 ms): <.main+8144>
test/lang/useOperator.ci:208:[.05bf9b, .05bfab) exec(1), time(0.005-0.005 ms): <.main+8159>
test/lang/useOperator.ci:209:[.05bfab, .05bfba) exec(1), time(0.004-0.004 ms): <.main+8175>
test/lang/useOperator.ci:210:[.05bfba, .05bfca) exec(1), time(0.005-0.005 ms): <.main+8190>
test/lang/useOperator.ci:211:[.05bfca, .05bfd9) exec(1), time(0.004-0.004 ms): <.main+8206>
test/lang/useOperator.ci:212:[.05bfd9, .05bfe9) exec(1), time(0.005-0.005 ms): <.main+8221>
test/lang/useOperator.ci:214:[.05bfe9, .05bff6) exec(1), time(0.002-0.002 ms): <.main+8237>
test/lang/useOperator.ci:215:[.05bff6, .05c003) exec(1), time(0.002-0.002 ms): <.main+8250>
test/lang/useOperator.ci:216:[.05c003, .05c00b) exec(1), time(0.001-0.001 ms): <.main+8263>
test/lang/useOperator.ci:217:[.05c00b, .05c014) exec(1), time(0.002-0.002 ms): <.main+8271>
test/lang/useOperator.ci:218:[.05c014, .05c01d) exec(1), time(0.003-0.003 ms): <.main+8280>
test/lang/useOperator.ci:219:[.05c01d, .05c02a) exec(1), time(0.004-0.004 ms): <.main+8289>
test/lang/useOperator.ci:220:[.05c02a, .05c037) exec(1), time(0.003-0.003 ms): <.main+8302>
test/lang/useOperator.ci:221:[.05c037, .05c044) exec(1), time(0.003-0.003 ms): <.main+8315>
test/lang/useOperator.ci:222:[.05c044, .05c051) exec(1), time(0.003-0.003 ms): <.main+8328>
test/lang/useOperator.ci:223:[.05c051, .05c05e) exec(1), time(0.004-0.004 ms): <.main+8341>
test/lang/useOperator.ci:224:[.05c05e, .05c06b) exec(1), time(0.004-0.004 ms): <.main+8354>
test/lang/useOperator.ci:225:[.05c06b, .05c078) exec(1), time(0.003-0.003 ms): <.main+8367>
test/lang/useOperator.ci:226:[.05c078, .05c085) exec(1), time(0.003-0.003 ms): <.main+8380>
test/lang/useOperator.ci:227:[.05c085, .05c092) exec(1), time(0.004-0.004 ms): <.main+8393>
test/lang/useOperator.ci:228:[.05c092, .05c09f) exec(1), time(0.004-0.004 ms): <.main+8406>
test/lang/useOperator.ci:229:[.05c09f, .05c0ab) exec(1), time(0.004-0.004 ms): <.main+8419>
test/lang/useOperator.ci:230:[.05c0ab, .05c0ba) exec(1), time(0.004-0.004 ms): <.main+8431>
test/lang/useOperator.ci:231:[.05c0ba, .05c0ca) exec(1), time(0.005-0.005 ms): <.main+8446>
test/lang/useOperator.ci:232:[.05c0ca, .05c0d9) exec(1), time(0.005-0.005 ms): <.main+8462>
test/lang/useOperator.ci:233:[.05c0d9, .05c0e9) exec(1), time(0.006-0.006 ms): <.main+8477>
test/lang/useOperator.ci:234:[.05c0e9, .05c0f8) exec(1), time(0.005-0.005 ms): <.main+8493>
test/lang/useOperator.ci:235:[.05c0f8, .05c108) exec(1), time(0.005-0.005 ms): <.main+8508>
test/lang/useOperator.ci:237:[.05c108, .05c111) exec(1), time(0.001-0.001 ms): <.main+8524>
test/lang/useOperator.ci:238:[.05c111, .05c11a) exec(1), time(0.002-0.002 ms): <.main+8533>
test/lang/useOperator.ci:239:[.05c11a, .05c122) exec(1), time(0.002-0.002 ms): <.main+8542>
test/lang/useOperator.ci:240:[.05c122, .05c12b) exec(1), time(0.002-0.002 ms): <.main+8550>
test/lang/useOperator.ci:242:[.05c12b, .05c138) exec(1), time(0.004-0.004 ms): <.main+8559>
test/lang/useOperator.ci:243:[.05c138, .05c145) exec(1), time(0.004-0.004 ms): <.main+8572>
test/lang/useOperator.ci:244:[.05c145, .05c152) exec(1), time(0.003-0.003 ms): <.main+8585>
test/lang/useOperator.ci:245:[.05c152, .05c15f) exec(1), time(0.004-0.004 ms): <.main+8598>
test/lang/useOperator.ci:246:[.05c15f, .05c16c) exec(1), time(0.004-0.004 ms): <.main+8611>
test/lang/useOperator.ci:252:[.05c16c, .05c178) exec(1), time(0.005-0.005 ms): <.main+8624>
test/lang/useOperator.ci:253:[.05c178, .05c187) exec(1), time(0.004-0.004 ms): <.main+8636>
test/lang/useOperator.ci:254:[.05c187, .05c197) exec(1), time(0.005-0.005 ms): <.main+8651>
test/lang/useOperator.ci:255:[.05c197, .05c1a6) exec(1), time(0.005-0.005 ms): <.main+8667>
test/lang/useOperator.ci:256:[.05c1a6, .05c1b6) exec(1), time(0.006-0.006 ms): <.main+8682>
test/lang/useOperator.ci:257:[.05c1b6, .05c1c5) exec(1), time(0.004-0.004 ms): <.main+8698>
test/lang/useOperator.ci:258:[.05c1c5, .05c1d5) exec(1), time(0.005-0.005 ms): <.main+8713>
test/lang/useOperator.ci:260:[.05c1d5, .05c1e2) exec(1), time(0.002-0.002 ms): <.main+8729>
test/lang/useOperator.ci:261:[.05c1e2, .05c1ef) exec(1), time(0.002-0.002 ms): <.main+8742>
test/lang/useOperator.ci:262:[.05c1ef, .05c1f7) exec(1), time(0.002-0.002 ms): <.main+8755>
test/lang/useOperator.ci:263:[.05c1f7, .05c200) exec(1), time(0.003-0.003 ms): <.main+8763>
test/lang/useOperator.ci:265:[.05c200, .05c20d) exec(1), time(0.003-0.003 ms): <.main+8772>
test/lang/useOperator.ci:266:[.05c20d, .05c21a) exec(1), time(0.004-0.004 ms): <.main+8785>
test/lang/useOperator.ci:267:[.05c21a, .05c227) exec(1), time(0.004-0.004 ms): <.main+8798>
test/lang/useOperator.ci:268:[.05c227, .05c234) exec(1), time(0.003-0.003 ms): <.main+8811>
test/lang/useOperator.ci:269:[.05c234, .05c241) exec(1), time(0.004-0.004 ms): <.main+8824>
test/lang/useOperator.ci:275:[.05c241, .05c24d) exec(1), time(0.004-0.004 ms): <.main+8837>
test/lang/useOperator.ci:276:[.05c24d, .05c25c) exec(1), time(0.005-0.005 ms): <.main+8849>
test/lang/useOperator.ci:277:[.05c25c, .05c26c) exec(1), time(0.006-0.006 ms): <.main+8864>
test/lang/useOperator.ci:278:[.05c26c, .05c27b) exec(1), time(0.004-0.004 ms): <.main+8880>
test/lang/useOperator.ci:279:[.05c27b, .05c28b) exec(1), time(0.009-0.009 ms): <.main+8895>
test/lang/useOperator.ci:280:[.05c28b, .05c29a) exec(1), time(0.005-0.005 ms): <.main+8911>
test/lang/useOperator.ci:281:[.05c29a, .05c2aa) exec(1), time(0.007-0.007 ms): <.main+8926>
test/lang/useOperator.ci:283:[.05c2aa, .05c2b3) exec(1), time(0.002-0.002 ms): <.main+8942>
test/lang/useOperator.ci:284:[.05c2b3, .05c2bc) exec(1), time(0.002-0.002 ms): <.main+8951>
test/lang/useOperator.ci:299:[.05c2bc, .05c2cb) exec(1), time(0.005-0.005 ms): <.main+8960>
test/lang/useOperator.ci:300:[.05c2cb, .05c2db) exec(1), time(0.007-0.007 ms): <.main+8975>
test/lang/statementIf.ci:26:[.05c2db, .05c2e0) exec(1), time(0.002-0.002 ms): <.main+8991>
test/lang/statementFor.ci:12:[.05c2e0, .05c2e5) exec(1), time(0.002-0.002 ms): <.main+8996>
test/std/test.math.ci:3:[.05c2e5, .05c2fd) exec(1), time(0.048-0.048 ms): <.main+9001>
test/std/test.math.ci:4:[.05c2fd, .05c315) exec(1), time(0.043-0.043 ms): <.main+9025>
test/std/test.math.ci:5:[.05c315, .05c32d) exec(1), time(0.042-0.042 ms): <.main+9049>
test/std/test.math.ci:6:[.05c32d, .05c345) exec(1), time(0.062-0.062 ms): <.main+9073>
test/std/test.math.ci:7:[.05c345, .05c35d) exec(1), time(0.061-0.061 ms): <.main+9097>
test/std/test.math.ci:8:[.05c35d, .05c375) exec(1), time(0.062-0.062 ms): <.main+9121>
test/std/test.math.ci:10:[.05c375, .05c392) exec(1), time(0.015-0.015 ms): <.main+9145>
test/std/test.math.ci:11:[.05c392, .05c3a7) exec(1), time(0.013-0.013 ms): <.main+9174>
test/std/test.math.ci:12:[.05c3a7, .05c3c4) exec(1), time(0.014-0.014 ms): <.main+9195>
test/std/test.math.ci:13:[.05c3c4, .05c3d9) exec(1), time(0.012-0.012 ms): <.main+9224>
test/std/test.math.ci:14:[.05c3d9, .05c3ea) exec(1), time(0.012-0.012 ms): <.main+9245>
test/std/test.math.ci:15:[.05c3ea, .05c3ff) exec(1), time(0.049-0.049 ms): <.main+9262>
test/std/test.math.ci:17:[.05c3ff, .05c417) exec(1), time(0.025-0.025 ms): <.main+9283>
test/std/test.math.ci:18:[.05c417, .05c426) exec(1), time(0.023-0.023 ms): <.main+9307>
test/std/test.math.ci:19:[.05c426, .05c43e) exec(1), time(0.037-0.037 ms): <.main+9322>
test/std/test.math.ci:20:[.05c43e, .05c453) exec(1), time(0.025-0.025 ms): <.main+9346>
test/std/test.math.ci:21:[.05c453, .05c464) exec(1), time(0.025-0.025 ms): <.main+9367>
test/std/test.math.ci:22:[.05c464, .05c479) exec(1), time(0.028-0.028 ms): <.main+9384>
test/std/test.math.ci:24:[.05c479, .05c493) exec(1), time(0.026-0.026 ms): <.main+9405>
test/std/test.math.ci:25:[.05c493, .05c4ad) exec(1), time(0.027-0.027 ms): <.main+9431>
test/std/test.math.ci:26:[.05c4ad, .05c4ce) exec(1), time(0.025-0.025 ms): <.main+9457>
test/std/test.math.ci:27:[.05c4ce, .05c4ef) exec(1), time(0.025-0.025 ms): <.main+9490>
test/std/test.math.ci:29:[.05c4ef, .05c50a) exec(1), time(0.028-0.028 ms): <.main+9523>
test/std/test.math.ci:30:[.05c50a, .05c52c) exec(1), time(0.028-0.028 ms): <.main+9550>
test/std/test.math.ci:32:[.05c52c, .05c545) exec(1), time(0.012-0.012 ms): <.main+9584>
test/std/test.math.ci:33:[.05c545, .05c565) exec(1), time(0.012-0.012 ms): <.main+9609>
test/std/test.math.ci:35:[.05c565, .05c5a5) exec(1), time(0.050-0.050 ms): <.main+9641>
test/std/test.math.ci:36:[.05c5a5, .05c5f7) exec(1), time(0.086-0.086 ms): <.main+9705>
test/std/test.math.ci:38:[.05c5f7, .05c610) exec(1), time(0.029-0.029 ms): <.main+9787>
test/std/test.math.ci:39:[.05c610, .05c67e) exec(1), time(0.082-0.082 ms): <.main+9812>
test/std/test.math.ci:40:[.05c67e, .05c697) exec(1), time(0.029-0.029 ms): <.main+9922>
test/std/test.math.ci:41:[.05c697, .05c705) exec(1), time(0.084-0.084 ms): <.main+9947>
test/std/test.math.ci:43:[.05c705, .05c71e) exec(1), time(0.034-0.034 ms): <.main+10057>
test/std/test.math.ci:44:[.05c71e, .05c744) exec(1), time(0.038-0.038 ms): <.main+10082>
test/std/test.math.ci:45:[.05c744, .05c773) exec(1), time(0.044-0.044 ms): <.main+10120>
test/std/test.math.ci:46:[.05c773, .05c7ea) exec(1), time(0.128-0.128 ms): <.main+10167>
test/std/test.math.ci:48:[.05c7ea, .05c7f7) exec(1), time(0.002-0.002 ms): <.main+10286>
test/std/test.math.ci:49:[.05c7f7, .05c814) exec(1), time(0.034-0.034 ms): <.main+10299>
test/std/test.math.ci:50:[.05c814, .05c821) exec(1), time(0.002-0.002 ms): <.main+10328>
test/std/test.math.ci:51:[.05c821, .05c83d) exec(1), time(0.006-0.006 ms): <.main+10341>
test/std/test.math.ci:52:[.05c83d, .05c86a) exec(1), time(0.014-0.014 ms): <.main+10369>
test/std/test.math.ci:53:[.05c86a, .05c8a8) exec(1), time(0.021-0.021 ms): <.main+10414>
test/std/test.math.ci:54:[.05c8a8, .05c8f6) exec(1), time(0.064-0.064 ms): <.main+10476>
test/std/test.math.ci:55:[.05c8f6, .05c94d) exec(1), time(0.069-0.069 ms): <.main+10554>
test/std/test.math.ci:57:[.05c94d, .05c970) exec(1), time(0.054-0.054 ms): <.main+10641>
test/std/test.math.ci:58:[.05c970, .05c9a1) exec(1), time(0.075-0.075 ms): <.main+10676>
test/std/test.math.ci:59:[.05c9a1, .05c9c3) exec(1), time(0.095-0.095 ms): <.main+10725>
test/std/test.math.ci:60:[.05c9c3, .05c9e5) exec(1), time(0.114-0.114 ms): <.main+10759>
test/std/test.math.ci:61:[.05c9e5, .05ca07) exec(1), time(0.074-0.074 ms): <.main+10793>
test/std/test.math.ci:63:[.05ca07, .05ca1f) exec(1), time(0.080-0.080 ms): <.main+10827>
test/std/test.math.ci:64:[.05ca1f, .05ca4b) exec(1), time(0.083-0.083 ms): <.main+10851>
test/std/test.math.ci:67:[.05ca4b, .05ca6d) exec(1), time(0.070-0.070 ms): <.main+10895>
test/std/test.math.ci:68:[.05ca6d, .05ca9b) exec(1), time(0.033-0.033 ms): <.main+10929>
test/std/test.math.ci:70:[.05ca9b, .05cabc) exec(1), time(0.040-0.040 ms): <.main+10975>
test/std/test.math.ci:71:[.05cabc, .05cad4) exec(1), time(0.024-0.024 ms): <.main+11008>
test/std/test.math.ci:72:[.05cad4, .05caf5) exec(1), time(0.039-0.039 ms): <.main+11032>
test/std/test.math.ci:74:[.05caf5, .05cb16) exec(1), time(0.026-0.026 ms): <.main+11065>
test/std/test.math.ci:75:[.05cb16, .05cb37) exec(1), time(0.038-0.038 ms): <.main+11098>
test/std/test.math.ci:76:[.05cb37, .05cb58) exec(1), time(0.024-0.024 ms): <.main+11131>
test/std/test.math.ci:77:[.05cb58, .05cb79) exec(1), time(0.024-0.024 ms): <.main+11164>
test/std/test.math.ci:79:[.05cb79, .05cb9a) exec(1), time(0.067-0.067 ms): <.main+11197>
test/std/test.math.ci:80:[.05cb9a, .05cbbb) exec(1), time(0.025-0.025 ms): <.main+11230>
test/std/test.math.ci:81:[.05cbbb, .05cbdc) exec(1), time(0.025-0.025 ms): <.main+11263>
test/std/test.math.ci:82:[.05cbdc, .05cbfd) exec(1), time(0.025-0.025 ms): <.main+11296>
test/std/test.math.ci:84:[.05cbfd, .05cc16) exec(1), time(0.025-0.025 ms): <.main+11329>
test/std/test.math.ci:85:[.05cc16, .05cc2b) exec(1), time(0.044-0.044 ms): <.main+11354>
test/std/test.math.ci:86:[.05cc2b, .05cc44) exec(1), time(0.056-0.056 ms): <.main+11375>
test/std/test.math.ci:88:[.05cc44, .05cc5d) exec(1), time(0.026-0.026 ms): <.main+11400>
test/std/test.math.ci:89:[.05cc5d, .05cc76) exec(1), time(0.045-0.045 ms): <.main+11425>
test/std/test.math.ci:90:[.05cc76, .05cc8f) exec(1), time(0.038-0.038 ms): <.main+11450>
test/std/test.math.ci:91:[.05cc8f, .05cca8) exec(1), time(0.024-0.024 ms): <.main+11475>
test/std/test.math.ci:93:[.05cca8, .05ccc1) exec(1), time(0.052-0.052 ms): <.main+11500>
test/std/test.math.ci:94:[.05ccc1, .05ccda) exec(1), time(0.025-0.025 ms): <.main+11525>
test/std/test.math.ci:95:[.05ccda, .05ccf3) exec(1), time(0.026-0.026 ms): <.main+11550>
test/std/test.math.ci:96:[.05ccf3, .05cd0c) exec(1), time(0.038-0.038 ms): <.main+11575>
test/std/memory.ci:13:[.05cd0c, .05cd1e) exec(1), time(0.046-0.046 ms): <.main+11600>
test/std/memory.ci:14:[.05cd1e, .05cd33) exec(1), time(0.043-0.043 ms): <.main+11618>
test/std/memory.ci:17:[.05cd33, .05cd40) exec(1), time(0.029-0.029 ms): <.main+11639>
test/std/memory.ci:18:[.05cd40, .05cd4d) exec(1), time(0.028-0.028 ms): <.main+11652>
test/std/memory.ci:19:[.05cd4d, .05cd5a) exec(1), time(0.028-0.028 ms): <.main+11665>
test/std/memory.ci:20:[.05cd5a, .05cd67) exec(1), time(0.061-0.061 ms): <.main+11678>
test/std/memory.ci:26:[.05cd67, .05cd8a) exec(1), time(0.043-0.043 ms): <.main+11691>
test/std/memory.ci:27:[.05cd8a, .05cdad) exec(1), time(0.055-0.055 ms): <.main+11726>
test/std/memory.ci:29:[.05cdad, .05cdc3) exec(1), time(0.043-0.043 ms): <.main+11761>
test/std/memory.ci:30:[.05cdc3, .05cdd5) exec(1), time(0.044-0.044 ms): <.main+11783>
test/std/memory.ci:32:[.05cdd5, .05cdf8) exec(1), time(0.053-0.053 ms): <.main+11801>
test/std/memory.ci:33:[.05cdf8, .05ce1b) exec(1), time(0.039-0.039 ms): <.main+11836>
test/lang/array.ci:55:[.05ce20, .05ce35) exec(7), time(0.077-0.077 ms): <.main+11876>
test/lang/array.ci:54:[.05ce35, .05ce39) exec(7), time(0.004-0.004 ms): <.main+11897>
test/lang/array.ci:54:[.05ce39, .05ce45) exec(8), time(0.036-0.036 ms): <.main+11901>
test/lang/array.ci:54:[.05ce1b, .05ce49) exec(1), time(0.006-0.006 ms): <.main+11871>
test/lang/array.ci:82:[.05ce49, .05ce60) exec(1), time(0.082-0.082 ms): <.main+11917>
test/lang/array.ci:83:[.05ce60, .05ce83) exec(1), time(0.108-0.108 ms): <.main+11940>
test/lang/array.ci:84:[.05ce83, .05cea6) exec(1), time(0.118-0.118 ms): <.main+11975>
test/lang/array.ci:87:[.05cea6, .05cec8) exec(1), time(0.059-0.059 ms): <.main+12010>
test/lang/array.ci:88:[.05cec8, .05ceea) exec(1), time(0.058-0.058 ms): <.main+12044>
test/lang/array.ci:91:[.05ceea, .05cf0c) exec(1), time(0.056-0.056 ms): <.main+12078>
test/lang/array.ci:92:[.05cf0c, .05cf2e) exec(1), time(0.043-0.043 ms): <.main+12112>
test/lang/array.ci:98:[.05cf2e, .05cf63) exec(1), time(0.005-0.005 ms): <.main+12146>
test/lang/array.ci:99:[.05cf63, .05cf98) exec(1), time(0.006-0.006 ms): <.main+12199>
test/lang/array.ci:101:[.05cf98, .05cfd5) exec(1), time(0.006-0.006 ms): <.main+12252>
test/lang/array.ci:108:[.05cfd5, .05cfee) exec(1), time(0.044-0.044 ms): <.main+12313>
test/lang/array.ci:109:[.05cfee, .05d006) exec(1), time(0.054-0.054 ms): <.main+12338>
test/lang/array.ci:110:[.05d006, .05d01e) exec(1), time(0.040-0.040 ms): <.main+12362>
test/lang/array.ci:112:[.05d01e, .05d03e) exec(1), time(0.083-0.083 ms): <.main+12386>
test/lang/array.ci:113:[.05d03e, .05d05d) exec(1), time(0.080-0.080 ms): <.main+12418>
test/lang/array.ci:114:[.05d05d, .05d086) exec(1), time(0.058-0.058 ms): <.main+12449>
test/lang/array.ci:115:[.05d086, .05d0a9) exec(1), time(0.080-0.080 ms): <.main+12490>
test/lang/array.ci:116:[.05d0a9, .05d0cc) exec(1), time(0.066-0.066 ms): <.main+12525>
test/lang/array.ci:119:[.05d0d1, .05d0da) exec(7), time(0.042-0.042 ms): <.main+12565>
test/lang/array.ci:120:[.05d0da, .05d118) exec(7), time(0.064-0.064 ms): <.main+12574>
test/lang/array.ci:121:[.05d118, .05d155) exec(7), time(0.076-0.076 ms): <.main+12636>
test/lang/array.ci:122:[.05d155, .05d192) exec(7), time(0.077-0.077 ms): <.main+12697>
test/lang/array.ci:124:[.05d192, .05d1d6) exec(7), time(0.324-0.324 ms): <.main+12758>
test/lang/array.ci:125:[.05d1d6, .05d219) exec(7), time(0.371-0.371 ms): <.main+12826>
test/lang/array.ci:126:[.05d219, .05d25c) exec(7), time(0.326-0.326 ms): <.main+12893>
test/lang/array.ci:128:[.05d25c, .05d2a0) exec(7), time(0.345-0.345 ms): <.main+12960>
test/lang/array.ci:129:[.05d2a0, .05d2e3) exec(7), time(0.349-0.349 ms): <.main+13028>
test/lang/array.ci:130:[.05d2e3, .05d326) exec(7), time(0.352-0.352 ms): <.main+13095>
test/lang/array.ci:132:[.05d326, .05d36f) exec(7), time(0.378-0.378 ms): <.main+13162>
test/lang/array.ci:134:[.05d36f, .05d3b2) exec(7), time(0.370-0.370 ms): <.main+13235>
test/lang/array.ci:136:[.05d3b2, .05d3ef) exec(7), time(0.119-0.119 ms): <.main+13302>
test/lang/array.ci:118:[.05d3f3, .05d3f7) exec(7), time(0.004-0.004 ms): <.main+13367>
test/lang/array.ci:118:[.05d3f7, .05d403) exec(8), time(0.051-0.051 ms): <.main+13371>
test/lang/array.ci:118:[.05d0cc, .05d407) exec(1), time(0.007-0.007 ms): <.main+12560>
test/lang/method.ci:78:[.05d407, .05d41c) exec(1), time(0.182-0.182 ms): <.main+13387>
test/lang/method.ci:79:[.05d41c, .05d430) exec(1), time(0.177-0.177 ms): <.main+13408>
test/lang/method.ci:97:[.05d430, .05d443) exec(1), time(0.302-0.302 ms): <.main+13428>
test/lang/method.ci:98:[.05d443, .05d456) exec(1), time(0.279-0.279 ms): <.main+13447>
test/lang/method.ci:101:[.05d456, .05d46b) exec(1), time(0.195-0.195 ms): <.main+13466>
test/lang/method.ci:102:[.05d46b, .05d480) exec(1), time(0.153-0.153 ms): <.main+13487>
test/lang/method.ci:103:[.05d480, .05d494) exec(1), time(0.160-0.160 ms): <.main+13508>
test/lang/statementIf.ci:4:[.05d494, .05d4bb) exec(1), time(0.038-0.038 ms): <.main+13528>
test/lang/statementIf.ci:12:[.05d4bb, .05d4e2) exec(1), time(0.040-0.040 ms): <.main+13567>
test/lang/statementIf.ci:22:[.05d4e2, .05d509) exec(1), time(0.089-0.089 ms): <.main+13606>
test/lang/statementIf.ci:29:[.05d513, .05d53a) exec(1), time(0.045-0.045 ms): <.main+13655>
test/lang/statementIf.ci:28:[.05d509, .05d53a) exec(1-1), time(0.000 ms): <.main+13645>
test/lang/statementIf.ci:33:[.05d544, .05d56b) exec(0), time(0.000 ms): <.main+13704>
test/lang/statementIf.ci:32:[.05d53a, .05d56b) exec(1), time(0.005-0.005 ms): <.main+13694>
test/lang/statementIf.ci:37:[.05d575, .05d59c) exec(1), time(0.060-0.060 ms): <.main+13753>
test/lang/statementIf.ci:40:[.05d5a0, .05d5c7) exec(0), time(0.000 ms): <.main+13796>
test/lang/statementIf.ci:36:[.05d56b, .05d5c7) exec(1), time(0.062-0.062 ms): <.main+13743>
test/lang/statementIf.ci:44:[.05d5d1, .05d5f8) exec(0), time(0.000 ms): <.main+13845>
test/lang/statementIf.ci:47:[.05d5fc, .05d623) exec(1), time(0.046-0.046 ms): <.main+13888>
test/lang/statementIf.ci:43:[.05d5c7, .05d623) exec(1-1), time(0.000 ms): <.main+13835>
test/lang/statementIf.ci:51:[.05d62d, .05d654) exec(1), time(0.059-0.059 ms): <.main+13937>
test/lang/statementIf.ci:54:[.05d666, .05d68d) exec(0), time(0.000 ms): <.main+13994>
test/lang/statementIf.ci:57:[.05d69f, .05d6c6) exec(0), time(0.000 ms): <.main+14051>
test/lang/statementIf.ci:60:[.05d6d8, .05d6ff) exec(0), time(0.000 ms): <.main+14108>
test/lang/statementIf.ci:63:[.05d711, .05d738) exec(0), time(0.000 ms): <.main+14165>
test/lang/statementIf.ci:66:[.05d74a, .05d771) exec(0), time(0.000 ms): <.main+14222>
test/lang/statementIf.ci:69:[.05d775, .05d79c) exec(0), time(0.000 ms): <.main+14265>
test/lang/statementIf.ci:65:[.05d73c, .05d79c) exec(0), time(0.000 ms): <.main+14208>
test/lang/statementIf.ci:62:[.05d703, .05d79c) exec(0), time(0.000 ms): <.main+14151>
test/lang/statementIf.ci:59:[.05d6ca, .05d79c) exec(0), time(0.000 ms): <.main+14094>
test/lang/statementIf.ci:56:[.05d691, .05d79c) exec(0), time(0.000 ms): <.main+14037>
test/lang/statementIf.ci:53:[.05d658, .05d79c) exec(0), time(0.000 ms): <.main+13980>
test/lang/statementIf.ci:50:[.05d623, .05d79c) exec(1), time(0.061-0.061 ms): <.main+13927>
test/lang/statementFor.ci:4:[.05d7a0, .05d7c3) exec(1), time(0.062-0.062 ms): <.main+14308>
test/lang/statementFor.ci:5:[.05d7c3, .05d7c7) exec(1), time(0.001-0.001 ms): <.main+14343>
::[.05d7c7, .05d7cb) exec(1), time(0.001-0.001 ms): <.main+14347>
test/lang/statementFor.ci:3:[.05d79c, .05d7cb) exec(1-1), time(0.000 ms): <.main+14304>
test/lang/statementFor.ci:9:[.05d7d0, .05d7f2) exec(2), time(0.093-0.093 ms): <.main+14356>
test/lang/statementFor.ci:8:[.05d7f2, .05d7f6) exec(2), time(0.002-0.002 ms): <.main+14390>
test/lang/statementFor.ci:8:[.05d7f6, .05d802) exec(3), time(0.014-0.014 ms): <.main+14394>
test/lang/statementFor.ci:8:[.05d7cb, .05d806) exec(1), time(0.007-0.007 ms): <.main+14351>
test/lang/statementFor.ci:14:[.05d80f, .05d832) exec(2), time(0.113-0.113 ms): <.main+14419>
test/lang/statementFor.ci:13:[.05d832, .05d83e) exec(2), time(0.006-0.006 ms): <.main+14454>
test/lang/statementFor.ci:13:[.05d83e, .05d84c) exec(3), time(0.013-0.013 ms): <.main+14466>
test/lang/statementFor.ci:13:[.05d806, .05d84c) exec(1-1), time(0.000 ms): <.main+14410>
test/lang/statementFor.ci:19:[.05d85d, .05d861) exec(2), time(0.002-0.002 ms): <.main+14497>
test/lang/statementFor.ci:18:[.05d851, .05d861) exec(7-2), time(0.024-0.024 ms): <.main+14485>
test/lang/statementFor.ci:21:[.05d861, .05d883) exec(5), time(0.274-0.274 ms): <.main+14501>
test/lang/statementFor.ci:17:[.05d883, .05d887) exec(7), time(0.005-0.005 ms): <.main+14535>
test/lang/statementFor.ci:17:[.05d887, .05d893) exec(8), time(0.063-0.063 ms): <.main+14539>
test/lang/statementFor.ci:17:[.05d84c, .05d897) exec(1), time(0.020-0.020 ms): <.main+14480>
test/lang/statementFor.ci:26:[.05d8a8, .05d8ac) exec(1), time(0.000 ms): <.main+14572>
test/lang/statementFor.ci:25:[.05d89c, .05d8ac) exec(4-1), time(0.027-0.027 ms): <.main+14560>
test/lang/statementFor.ci:28:[.05d8ac, .05d8ce) exec(3), time(0.134-0.134 ms): <.main+14576>
test/lang/statementFor.ci:24:[.05d8ce, .05d8d2) exec(3), time(0.016-0.016 ms): <.main+14610>
test/lang/statementFor.ci:24:[.05d8d2, .05d8de) exec(4), time(0.032-0.032 ms): <.main+14614>
test/lang/statementFor.ci:24:[.05d897, .05d8e2) exec(1), time(0.002-0.002 ms): <.main+14555>

---------- Exitcode: 0, time: 40.355 ms
