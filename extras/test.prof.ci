
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:44: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:45: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:46: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:43: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:34: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:56: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:59: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:62: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:68: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:71: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:84: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:90: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:163: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:163: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:164: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:164: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:173: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:177: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:185: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:189: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:199: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:217: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:265: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:271: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:272: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:275: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:279: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:279: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:283: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:288: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:323: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:327: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:335: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:343: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:342: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:338: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:334: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:352: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:355: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:377: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:382: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:383: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:404: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:407: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:408: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:410: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:420: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:426: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:431: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:436: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:438: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:477: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:478: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:485: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:57: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:109: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:115: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:122: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:123: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:123: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:125: warn: adding implicit cast char(0: int32)
lib/std/string.ci:138: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:141: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:141: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:142: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:166: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:173: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:186: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:186: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:188: warn: adding implicit cast char(0: int32)
lib/std/string.ci:199: warn: adding implicit cast int32('-': char)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:108: warn: adding implicit cast char(0: int32)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:59: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:60: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:61: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.print(this: RecordMethodTest): void := print
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.delegateMethod(x: int32, y: int32): int32 := forwardMethod
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:59: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:62: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:63: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:47: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:270: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:273: warn: using default type initializer: e := 0
lib/std/math.ci:277: warn: using default type initializer: f := 0
lib/std/math.ci:329: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:386: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang/method.ci:73: warn: accessing static member using instance variable `RecordMethodTest.printStatic(this: RecordMethodTest): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+24>, cast: const variable)
.field offset: int32 (size: 4, offs: <+32>, cast: const variable)
.field base: function (size: 0, offs: <@0055a8>, cast: static const inline)
.field file: function (size: 0, offs: <@005778>, cast: static const inline)
.field line: function (size: 0, offs: <@005948>, cast: static const inline)
.field name: function (size: 0, offs: <@005b18>, cast: static const inline)
.references:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:54: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal references: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+24>
.name: 'size'
.owner: typename
.references:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:54: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'offset'
.print: '@%06x'
.owner: typename
.references:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0055a8>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.references:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal references: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005778>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.references:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal references: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005948>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.references:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal references: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005b18>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.references:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal references: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000a0>
.name: 'void'
.references:
	test/lang/method.ci:79: referenced as `void`
	test/lang/method.ci:75: referenced as `void`
	test/lang/method.ci:59: referenced as `void`
	test/lang/method.ci:44: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:39: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	internal references: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000130>
.name: 'bool'
.print: '%d'
.value: 0
.references:
	test/stdc/test.math.ci:70: referenced as `bool`
	test/stdc/test.math.ci:69: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:44: referenced as `bool`
	lib/std/string.ci:35: referenced as `bool`
	lib/std/math.ci:425: referenced as `bool`
	lib/std/math.ci:376: referenced as `bool`
	lib/std/math.ci:321: referenced as `bool`
	lib/std/math.ci:320: referenced as `bool`
	lib/stdlib.ci:29: referenced as `bool`
	lib/stdlib.ci:28: referenced as `bool`
	lib/stdlib.ci:27: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001c0>
.name: 'char'
.print: '%c'
.value: 0
.references:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:205: referenced as `char`
	lib/std/string.ci:196: referenced as `char`
	lib/std/string.ci:192: referenced as `char`
	lib/std/string.ci:150: referenced as `char`
	lib/std/string.ci:134: referenced as `char`
	lib/std/string.ci:131: referenced as `char`
	lib/std/string.ci:130: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:108: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:3: referenced as `char`
	lib/stdlib.ci:39: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:24: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	lib/stdlib.ci:14: referenced as `char`
	lib/stdlib.ci:12: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:9: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	lib/stdlib.ci:5: referenced as `char`
	internal references: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000250>
.name: 'int8'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@0002e0>
.name: 'int16'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000370>
.name: 'int32'
.print: '%d'
.value: 0
.references:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:197: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:179: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:136: referenced as `int32`
	lib/std/string.ci:133: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:114: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:110: referenced as `int32`
	lib/std/string.ci:109: referenced as `int32`
	lib/std/string.ci:107: referenced as `int32`
	lib/std/string.ci:84: referenced as `int32`
	lib/std/string.ci:70: referenced as `int32`
	lib/std/string.ci:60: referenced as `int32`
	lib/std/string.ci:59: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:50: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:45: referenced as `int32`
	lib/std/string.ci:44: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:35: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:24: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:14: referenced as `int32`
	lib/std/string.ci:7: referenced as `int32`
	lib/std/string.ci:3: referenced as `int32`
	lib/std/math.ci:331: referenced as `int32`
	lib/std/math.ci:331: referenced as `int32`
	lib/std/math.ci:282: referenced as `int32`
	lib/std/math.ci:250: referenced as `int32`
	lib/std/math.ci:236: referenced as `int32`
	lib/std/math.ci:223: referenced as `int32`
	lib/std/math.ci:217: referenced as `int32`
	lib/std/math.ci:199: referenced as `int32`
	lib/std/math.ci:189: referenced as `int32`
	lib/std/math.ci:177: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:58: referenced as `int32`
	lib/stdlib.ci:54: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	internal references: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000400>
.name: 'int64'
.print: '%D'
.value: 0
.references:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal references: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000490>
.name: 'uint8'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@000520>
.name: 'uint16'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0005b0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@008328>, cast: static const inline)
.field sxt: function (size: 0, offs: <@008608>, cast: static const inline)
.field pop: function (size: 0, offs: <@0087d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0089a8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@008b78>, cast: static const inline)
.field bsf: function (size: 0, offs: <@008d48>, cast: static const inline)
.field hib: function (size: 0, offs: <@008f18>, cast: static const inline)
.field lob: function (size: 0, offs: <@0090e8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:205: referenced as `uint32`
	lib/std/string.ci:192: referenced as `uint32`
	lib/std/string.ci:129: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008328>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.references:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal references: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008608>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.references:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal references: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0087d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.references:
	test/stdc/number.ci:55: referenced as `pop`
	internal references: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.references:
	test/stdc/number.ci:56: referenced as `swap`
	internal references: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b78>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.references:
	test/stdc/number.ci:57: referenced as `bsr`
	internal references: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d48>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.references:
	test/stdc/number.ci:58: referenced as `bsf`
	internal references: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.references:
	test/stdc/number.ci:59: referenced as `hib`
	internal references: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0090e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.references:
	test/stdc/number.ci:60: referenced as `lob`
	internal references: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000640>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@0093c0>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009698>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093c0>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.references:
	test/stdc/number.ci:65: referenced as `zxt`
	internal references: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009698>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.references:
	test/stdc/number.ci:66: referenced as `sxt`
	internal references: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0006d0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@009870>, cast: static const inline)
.field cos: function (size: 0, offs: <@009a40>, cast: static const inline)
.field tan: function (size: 0, offs: <@009c10>, cast: static const inline)
.field log: function (size: 0, offs: <@009de0>, cast: static const inline)
.field exp: function (size: 0, offs: <@009fb0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00a210>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00a3e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00a638>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:4: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:74: referenced as `float32`
	lib/vec/vec4f.ci:70: referenced as `float32`
	lib/vec/vec4f.ci:69: referenced as `float32`
	lib/vec/vec4f.ci:68: referenced as `float32`
	lib/vec/vec4f.ci:63: referenced as `float32`
	lib/vec/vec4f.ci:62: referenced as `float32`
	lib/vec/vec4f.ci:26: referenced as `float32`
	lib/vec/vec4f.ci:25: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:8: referenced as `float32`
	lib/vec/vec4f.ci:7: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:4: referenced as `float32`
	lib/std/math.ci:223: referenced as `float32`
	lib/std/math.ci:223: referenced as `float32`
	lib/std/math.ci:223: referenced as `float32`
	lib/std/math.ci:165: referenced as `float32`
	lib/std/math.ci:165: referenced as `float32`
	lib/std/math.ci:165: referenced as `float32`
	lib/std/math.ci:165: referenced as `float32`
	lib/std/math.ci:165: referenced as `float32`
	lib/std/math.ci:163: referenced as `float32`
	lib/std/math.ci:160: referenced as `float32`
	lib/std/math.ci:160: referenced as `float32`
	lib/std/math.ci:160: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:119: referenced as `float32`
	lib/std/math.ci:119: referenced as `float32`
	lib/std/math.ci:119: referenced as `float32`
	lib/std/math.ci:101: referenced as `float32`
	lib/std/math.ci:101: referenced as `float32`
	lib/std/math.ci:101: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:58: referenced as `float32`
	internal references: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009870>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.references:
	test/stdc/number.ci:46: referenced as `sin`
	internal references: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a40>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.references:
	test/stdc/number.ci:47: referenced as `cos`
	internal references: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c10>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.references:
	test/stdc/number.ci:48: referenced as `tan`
	internal references: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009de0>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.references:
	test/stdc/number.ci:49: referenced as `log`
	internal references: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009fb0>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.references:
	test/stdc/number.ci:50: referenced as `exp`
	internal references: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a210>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.references:
	test/stdc/number.ci:51: referenced as `pow`
	internal references: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a3e0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.references:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:74: referenced as `sqrt`
	internal references: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a638>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.references:
	test/stdc/number.ci:53: referenced as `atan2`
	internal references: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000760>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00a800>, cast: static const inline)
.field cos: function (size: 0, offs: <@00a9c8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ab90>, cast: static const inline)
.field log: function (size: 0, offs: <@00ad58>, cast: static const inline)
.field exp: function (size: 0, offs: <@00af20>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b170>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b338>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b588>, cast: static const inline)
.value: 0
.references:
	test/stdc/test.math.ci:66: referenced as `float64`
	test/stdc/test.math.ci:65: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:62: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:56: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:47: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:42: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:37: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:5: referenced as `float64`
	lib/vec/vec2d.ci:4: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:117: referenced as `float64`
	lib/std/math.Complex.ci:114: referenced as `float64`
	lib/std/math.Complex.ci:113: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:108: referenced as `float64`
	lib/std/math.Complex.ci:105: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:94: referenced as `float64`
	lib/std/math.Complex.ci:90: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:87: referenced as `float64`
	lib/std/math.Complex.ci:86: referenced as `float64`
	lib/std/math.Complex.ci:79: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:72: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:63: referenced as `float64`
	lib/std/math.Complex.ci:60: referenced as `float64`
	lib/std/math.Complex.ci:59: referenced as `float64`
	lib/std/math.Complex.ci:56: referenced as `float64`
	lib/std/math.Complex.ci:55: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:20: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.Complex.ci:4: referenced as `float64`
	lib/std/math.ci:478: referenced as `float64`
	lib/std/math.ci:478: referenced as `float64`
	lib/std/math.ci:477: referenced as `float64`
	lib/std/math.ci:477: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:441: referenced as `float64`
	lib/std/math.ci:438: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:410: referenced as `float64`
	lib/std/math.ci:410: referenced as `float64`
	lib/std/math.ci:408: referenced as `float64`
	lib/std/math.ci:403: referenced as `float64`
	lib/std/math.ci:403: referenced as `float64`
	lib/std/math.ci:391: referenced as `float64`
	lib/std/math.ci:388: referenced as `float64`
	lib/std/math.ci:388: referenced as `float64`
	lib/std/math.ci:386: referenced as `float64`
	lib/std/math.ci:383: referenced as `float64`
	lib/std/math.ci:366: referenced as `float64`
	lib/std/math.ci:364: referenced as `float64`
	lib/std/math.ci:364: referenced as `float64`
	lib/std/math.ci:348: referenced as `float64`
	lib/std/math.ci:347: referenced as `float64`
	lib/std/math.ci:330: referenced as `float64`
	lib/std/math.ci:329: referenced as `float64`
	lib/std/math.ci:308: referenced as `float64`
	lib/std/math.ci:307: referenced as `float64`
	lib/std/math.ci:307: referenced as `float64`
	lib/std/math.ci:304: referenced as `float64`
	lib/std/math.ci:301: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:294: referenced as `float64`
	lib/std/math.ci:277: referenced as `float64`
	lib/std/math.ci:273: referenced as `float64`
	lib/std/math.ci:270: referenced as `float64`
	lib/std/math.ci:264: referenced as `float64`
	lib/std/math.ci:251: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:236: referenced as `float64`
	lib/std/math.ci:236: referenced as `float64`
	lib/std/math.ci:236: referenced as `float64`
	lib/std/math.ci:216: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:214: referenced as `float64`
	lib/std/math.ci:214: referenced as `float64`
	lib/std/math.ci:214: referenced as `float64`
	lib/std/math.ci:214: referenced as `float64`
	lib/std/math.ci:214: referenced as `float64`
	lib/std/math.ci:213: referenced as `float64`
	lib/std/math.ci:213: referenced as `float64`
	lib/std/math.ci:213: referenced as `float64`
	lib/std/math.ci:213: referenced as `float64`
	lib/std/math.ci:212: referenced as `float64`
	lib/std/math.ci:212: referenced as `float64`
	lib/std/math.ci:212: referenced as `float64`
	lib/std/math.ci:211: referenced as `float64`
	lib/std/math.ci:211: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:188: referenced as `float64`
	lib/std/math.ci:184: referenced as `float64`
	lib/std/math.ci:184: referenced as `float64`
	lib/std/math.ci:176: referenced as `float64`
	lib/std/math.ci:172: referenced as `float64`
	lib/std/math.ci:172: referenced as `float64`
	lib/std/math.ci:166: referenced as `float64`
	lib/std/math.ci:166: referenced as `float64`
	lib/std/math.ci:166: referenced as `float64`
	lib/std/math.ci:166: referenced as `float64`
	lib/std/math.ci:166: referenced as `float64`
	lib/std/math.ci:164: referenced as `float64`
	lib/std/math.ci:161: referenced as `float64`
	lib/std/math.ci:161: referenced as `float64`
	lib/std/math.ci:161: referenced as `float64`
	lib/std/math.ci:146: referenced as `float64`
	lib/std/math.ci:146: referenced as `float64`
	lib/std/math.ci:146: referenced as `float64`
	lib/std/math.ci:146: referenced as `float64`
	lib/std/math.ci:125: referenced as `float64`
	lib/std/math.ci:125: referenced as `float64`
	lib/std/math.ci:125: referenced as `float64`
	lib/std/math.ci:107: referenced as `float64`
	lib/std/math.ci:107: referenced as `float64`
	lib/std/math.ci:107: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:52: referenced as `float64`
	lib/std/math.ci:51: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:6: referenced as `float64`
	internal references: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a800>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.references:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:145: referenced as `sin`
	lib/std/math.Complex.ci:120: referenced as `sin`
	lib/std/math.Complex.ci:119: referenced as `sin`
	lib/std/math.Complex.ci:114: referenced as `sin`
	lib/std/math.Complex.ci:103: referenced as `sin`
	internal references: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a9c8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.references:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:145: referenced as `cos`
	lib/std/math.Complex.ci:120: referenced as `cos`
	lib/std/math.Complex.ci:119: referenced as `cos`
	lib/std/math.Complex.ci:113: referenced as `cos`
	lib/std/math.Complex.ci:103: referenced as `cos`
	internal references: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab90>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.references:
	test/stdc/number.ci:39: referenced as `tan`
	internal references: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad58>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.references:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:110: referenced as `log`
	lib/std/math.Complex.ci:105: referenced as `log`
	internal references: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af20>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.references:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:111: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.ci:410: referenced as `exp`
	lib/std/math.ci:410: referenced as `exp`
	lib/std/math.ci:408: referenced as `exp`
	lib/std/math.ci:388: referenced as `exp`
	lib/std/math.ci:388: referenced as `exp`
	lib/std/math.ci:383: referenced as `exp`
	internal references: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b170>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.references:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:111: referenced as `pow`
	internal references: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.references:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:89: referenced as `sqrt`
	lib/std/math.ci:436: referenced as `sqrt`
	internal references: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b588>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.references:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:90: referenced as `atan2`
	lib/std/math.ci:441: referenced as `atan2`
	lib/std/math.ci:438: referenced as `atan2`
	internal references: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@006c50>, cast: static const inline)
.field fill: function (size: 0, offs: <@006f40>, cast: static const inline)
.field copy: function (size: 0, offs: <@007228>, cast: static const inline)
.field move: function (size: 0, offs: <@007508>, cast: static const inline)
.references:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal references: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006c50>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.references:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal references: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f40>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.references:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal references: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007228>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.references:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal references: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007508>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.references:
	test/stdc/memory.ci:29: referenced as `move`
	internal references: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000880>
.name: 'variant'
.references:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:34: referenced as `variant`
	lib/stdlib.ci:33: referenced as `variant`
	lib/stdlib.ci:32: referenced as `variant`
	lib/stdlib.ci:27: referenced as `variant`
	lib/stdlib.ci:23: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:17: referenced as `variant`
	lib/stdlib.ci:14: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:8: referenced as `variant`
	lib/stdlib.ci:5: referenced as `variant`
	internal references: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000910>
.name: 'function'
.references:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0009a8>
.name: 'object'
.references:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.references:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:4: referenced as `null`
	lib/stdlib.ci:50: referenced as `null`
	lib/stdlib.ci:35: referenced as `null`
	lib/stdlib.ci:34: referenced as `null`
	lib/stdlib.ci:25: referenced as `null`
	lib/stdlib.ci:24: referenced as `null`
	lib/stdlib.ci:21: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:15: referenced as `null`
	lib/stdlib.ci:12: referenced as `null`
	lib/stdlib.ci:9: referenced as `null`
	lib/stdlib.ci:6: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.references:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:55: referenced as `true`
	lib/std/string.ci:41: referenced as `true`
	lib/std/math.ci:427: referenced as `true`
	lib/std/math.ci:379: referenced as `true`
	lib/std/math.ci:340: referenced as `true`
	lib/std/math.ci:336: referenced as `true`
	lib/std/math.ci:325: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.references:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:52: referenced as `false`
	lib/std/string.ci:48: referenced as `false`
	lib/std/string.ci:38: referenced as `false`
	lib/std/math.ci:425: referenced as `false`
	lib/std/math.ci:376: referenced as `false`
	lib/std/math.ci:321: referenced as `false`
	lib/std/math.ci:320: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.references:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.references:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.references:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.references:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000eb8>
.name: '.cstr'
.print: '%s'
.references:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000f48>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0012a8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001338>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@001578>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a88>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001dc0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@0022b0>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002450>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@0025f0>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@0028a0>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002c80>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003040>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003400>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@0038d0>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@003da0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004160>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004520>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@0048e0>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@004ca0>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@004e40>, cast: static const typename(void))
.references:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:70: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:68: referenced as `emit`
	lib/vec/vec4f.ci:63: referenced as `emit`
	lib/vec/vec4f.ci:62: referenced as `emit`
	lib/vec/vec4f.ci:60: referenced as `emit`
	lib/vec/vec4f.ci:59: referenced as `emit`
	lib/vec/vec4f.ci:58: referenced as `emit`
	lib/vec/vec4f.ci:57: referenced as `emit`
	lib/vec/vec4f.ci:56: referenced as `emit`
	lib/vec/vec2d.ci:15: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.references:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.references:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.references:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.references:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.references:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0012a8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:70: referenced as `p4x`
	lib/vec/vec4f.ci:69: referenced as `p4x`
	lib/vec/vec4f.ci:68: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.references:
	lib/vec/vec4f.ci:68: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.references:
	lib/vec/vec4f.ci:70: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.references:
	lib/vec/vec4f.ci:69: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001338>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.references:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.references:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.references:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001578>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.references:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.references:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.references:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.references:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.references:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.references:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.references:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.references:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a88>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.references:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.references:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.references:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.references:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.references:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001dc0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.references:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.references:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.references:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.references:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.references:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.references:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022b0>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.references:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.references:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002450>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.references:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.references:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0025f0>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.references:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.references:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.references:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.references:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0028a0>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.references:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.references:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.references:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.references:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.references:
	lib/vec/vec4f.ci:56: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.references:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c80>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:57: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.references:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.references:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.references:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.references:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.references:
	lib/vec/vec4f.ci:57: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.references:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003040>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:58: referenced as `sub`
	lib/vec/vec2d.ci:15: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.references:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.references:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.references:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.references:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.references:
	lib/vec/vec4f.ci:58: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.references:
	lib/vec/vec2d.ci:15: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003400>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:59: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.references:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.references:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.references:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.references:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.references:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.references:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.references:
	lib/vec/vec4f.ci:59: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.references:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0038d0>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:60: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.references:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.references:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.references:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.references:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.references:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.references:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.references:
	lib/vec/vec4f.ci:60: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.references:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003da0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.references:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.references:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.references:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.references:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.references:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.references:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004160>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.references:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.references:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.references:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.references:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.references:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.references:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004520>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.references:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.references:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.references:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.references:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.references:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.references:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048e0>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.references:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.references:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.references:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.references:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.references:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.references:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004ca0>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:62: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.references:
	lib/vec/vec4f.ci:62: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.references:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e40>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:63: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.references:
	lib/vec/vec4f.ci:63: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.references:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0052b0>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.references:
	internal references: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.references:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.references:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0061f0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.value: nfc(5)
.references:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal references: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.references:
	lib/stdlib.ci:48: referenced as `abort`
	lib/stdlib.ci:25: referenced as `abort`
	lib/stdlib.ci:24: referenced as `abort`
	lib/stdlib.ci:23: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.references:
	lib/stdlib.ci:21: referenced as `error`
	lib/stdlib.ci:20: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.references:
	lib/stdlib.ci:18: referenced as `warn`
	lib/stdlib.ci:17: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.references:
	lib/stdlib.ci:15: referenced as `info`
	lib/stdlib.ci:14: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.references:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:12: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
	lib/stdlib.ci:9: referenced as `debug`
	lib/stdlib.ci:8: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.references:
	lib/stdlib.ci:6: referenced as `verbose`
	lib/stdlib.ci:5: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.references:
	lib/stdlib.ci:18: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
	lib/stdlib.ci:14: referenced as `noTrace`
	lib/stdlib.ci:12: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
	lib/stdlib.ci:5: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.references:
	lib/stdlib.ci:48: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
	lib/stdlib.ci:24: referenced as `defTrace`
	lib/stdlib.ci:23: referenced as `defTrace`
	lib/stdlib.ci:21: referenced as `defTrace`
	lib/stdlib.ci:20: referenced as `defTrace`
	lib/stdlib.ci:9: referenced as `defTrace`
	lib/stdlib.ci:8: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0069f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.references:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal references: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@007538>
.name: 'System'
.field exit: function (size: 0, offs: <@007770>, cast: static const inline)
.field srand: function (size: 0, offs: <@007948>, cast: static const inline)
.field rand: function (size: 0, offs: <@007a90>, cast: static const inline)
.field time: function (size: 0, offs: <@007bd8>, cast: static const inline)
.field clock: function (size: 0, offs: <@007d20>, cast: static const inline)
.field millis: function (size: 0, offs: <@007e68>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008038>, cast: static const inline)
.references:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007770>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.references:
	internal references: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007948>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.references:
	internal references: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.references:
	internal references: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bd8>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.references:
	internal references: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d20>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.references:
	internal references: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e68>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.references:
	internal references: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008038>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.references:
	internal references: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:5: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:6: defined as `verbose(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:8: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.references:
	test/lang/method.ci:80: referenced as `trace`
	test/lang/method.ci:76: referenced as `trace`
	test/lang/method.ci:60: referenced as `trace`
	test/lang/method.ci:45: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	lib/stdlib.ci:9: defined as `trace(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.references:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.references:
	test/lang/statementFor.ci:4: referenced as `debug`
	lib/stdlib.ci:12: defined as `debug(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:14: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:15: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:17: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:18: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:20: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.references:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:21: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.references:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:27: referenced as `abort`
	lib/stdlib.ci:23: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:29: referenced as `abort`
	lib/stdlib.ci:28: referenced as `abort`
	lib/stdlib.ci:24: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.references:
	lib/stdlib.ci:25: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.value: void(condition ? void(0) : abort(void(message, inspect)))
.references:
	lib/std/string.ci:138: referenced as `assert`
	lib/std/string.ci:137: referenced as `assert`
	lib/stdlib.ci:27: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.value: void(condition ? void(0) : abort(message))
.references:
	lib/stdlib.ci:28: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
.references:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:173: referenced as `assert`
	lib/std/string.ci:166: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/stdlib.ci:29: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00e088>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.references:
	lib/stdlib.ci:43: referenced as `NotEquals`
	lib/stdlib.ci:31: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
.references:
	lib/stdlib.ci:44: referenced as `expected`
	lib/stdlib.ci:32: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
.references:
	lib/stdlib.ci:45: referenced as `returned`
	lib/stdlib.ci:33: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:34: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:35'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:46: referenced as `message`
	lib/stdlib.ci:35: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@045958>
.name: 'assertEq'
.file: 'lib/stdlib.ci:39'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@045958> - <@0459b6>)
	lib/stdlib.ci:40: (10 bytes: <@045958> - <@045962>): if (bool(returned == expected))
	<assertEq @045958>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @04595a>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @04595c>    : 57                         ceq.i32
	<assertEq+5 @04595d>    : 06 05 00 00                jz <assertEq+10 @045962>
	lib/stdlib.ci:41: (1 byte: <@045961> - <@045962>): return;
	<assertEq+9 @045961>    : 03                         ret
	lib/stdlib.ci:43: (41 bytes: <@045962> - <@04598b>): details: NotEquals := {...}
	<assertEq+10 @045962>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:44: (11 bytes: <@045966> - <@045971>): void(details.expected := (expected));
	<assertEq+14 @045966>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+19 @04596b>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @04596f>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:45: (11 bytes: <@045971> - <@04597c>): void(details.returned := (returned));
	<assertEq+25 @045971>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+30 @045976>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @04597a>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:46: (3 bytes: <@04597c> - <@04597f>): void(details.message := (message));
	<assertEq+36 @04597c>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@04597f> - <@04598b>): void(details.argument := (null))
	<assertEq+39 @04597f>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<assertEq+44 @045984>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @045989>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:48: (38 bytes: <@04598b> - <@0459b1>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @04598b>   : 1f b8 b5 00 00             load.ref <@00b5b8> ;"lib/stdlib.ci"
	<assertEq+56 @045990>   : 1c 30 00 00 00             load.c32 48
	<assertEq+61 @045995>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @04599a>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @04599f>   : 1f 32 b6 00 00             load.ref <@00b632> ;"assertion failed"
	<assertEq+76 @0459a4>   : 1f 88 e0 00 00             load.ref <@00e088> ;NotEquals
	<assertEq+81 @0459a9>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @0459ad>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @0459b1>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @0459b5>   : 03                         ret
.references:
	lib/stdlib.ci:50: referenced as `assertEq`
	lib/stdlib.ci:39: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:50'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.value: assertEq(void(void(expected, returned), null))
.references:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:50: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:54'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.value: int32(type.size)
.references:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:54: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@00eca0>
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@0459b8>, cast: static const function)
.field floor: function (size: 24, offs: <@045a10>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 36, offs: <@045a28>, cast: static const function)
.field sign: function (size: 36, offs: <@045a50>, cast: static const function)
.field abs: function (size: 18, offs: <@045a78>, cast: static const function)
.field abs: function (size: 18, offs: <@045a90>, cast: static const function)
.field min: function (size: 17, offs: <@045aa8>, cast: static const function)
.field min: function (size: 17, offs: <@045ac0>, cast: static const function)
.field max: function (size: 17, offs: <@045ad8>, cast: static const function)
.field max: function (size: 17, offs: <@045af0>, cast: static const function)
.field clamp: function (size: 30, offs: <@045b08>, cast: static const function)
.field clamp: function (size: 30, offs: <@045b28>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@045b48>, cast: static const function)
.field max: function (size: 72, offs: <@045b90>, cast: static const function)
.field sum: function (size: 40, offs: <@045bd8>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@045c00>, cast: static const function)
.field cmp: function (size: 57, offs: <@045c30>, cast: static const function)
.field cmp: function (size: 57, offs: <@045c70>, cast: static const function)
.field sinCos: function (size: 335, offs: <@045cb0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@045e00>, cast: static const function)
.field sinh: function (size: 241, offs: <@045f78>, cast: static const function)
.field cosh: function (size: 75, offs: <@046070>, cast: static const function)
.field asin: function (size: 166, offs: <@0460c0>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field deg2rad: function (size: 0, offs: <@000000>, cast: static inline)
.field rad2deg: function (size: 0, offs: <@000000>, cast: static inline)
.references:
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:69: referenced as `Math`
	test/stdc/test.math.ci:66: referenced as `Math`
	test/stdc/test.math.ci:65: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:56: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:48: referenced as `Math`
	test/stdc/test.math.ci:47: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:42: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:37: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.ci:3: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
.references:
	test/stdc/test.math.ci:63: referenced as `pi`
	test/stdc/test.math.ci:62: referenced as `pi`
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	lib/std/math.ci:478: referenced as `pi`
	lib/std/math.ci:477: referenced as `pi`
	lib/std/math.ci:454: referenced as `pi`
	lib/std/math.ci:438: referenced as `pi`
	lib/std/math.ci:7: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
.references:
	lib/std/math.ci:8: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
.references:
	lib/std/math.ci:10: referenced as `ln2`
	lib/std/math.ci:9: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: float64(1.000000 / ln2)
.references:
	lib/std/math.ci:10: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
.references:
	lib/std/math.ci:12: referenced as `ln10`
	lib/std/math.ci:11: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: float64(1.000000 / ln10)
.references:
	lib/std/math.ci:12: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
.references:
	lib/std/math.ci:13: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
.references:
	lib/std/math.ci:14: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
.references:
	lib/std/math.ci:15: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
.references:
	lib/std/math.ci:16: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
.references:
	lib/std/math.ci:17: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: float64((0) / 0.000000)
.references:
	lib/std/math.ci:433: referenced as `nan`
	lib/std/math.ci:353: referenced as `nan`
	lib/std/math.ci:186: referenced as `nan`
	lib/std/math.ci:174: referenced as `nan`
	lib/std/math.ci:18: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: float64((1) / 0.000000)
.references:
	lib/std/math.ci:19: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@0459b8>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@0459b8> - <@045a0e>)
	lib/std/math.ci:23: (63 bytes: <@0459b8> - <@0459f7>): if (bool(x < (1)))
	<modf @0459b8>      : 11 02                      dup.x2 sp(2)
	<modf+2 @0459ba>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0459c3>   : 88                         clt.f64
	<modf+12 @0459c4>   : 06 33 00 00                jz <modf+63 @0459f7>
	lib/std/math.ci:24: (39 bytes: <@0459c8> - <@0459ef>): if (bool(x < (0)))
	<modf+16 @0459c8>   : 11 02                      dup.x2 sp(2)
	<modf+18 @0459ca>   : 1a                         load.z64
	<modf+19 @0459cb>   : 88                         clt.f64
	<modf+20 @0459cc>   : 06 23 00 00                jz <modf+55 @0459ef>
	lib/std/math.ci:25: (17 bytes: <@0459d0> - <@0459e1>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @0459d0>   : 1a                         load.z64
	<modf+25 @0459d1>   : 11 04                      dup.x2 sp(4)
	<modf+27 @0459d3>   : 80                         neg.f64
	<modf+28 @0459d4>   : 10 05                      dup.x1 sp(5)
	<modf+30 @0459d6>   : 1f b8 59 04 00             load.ref <@0459b8> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @0459db>   : 02                         call
	<modf+36 @0459dc>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @0459e0>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@0459e1> - <@0459e8>): float64(intPart := float64(-intPart));
	<modf+41 @0459e1>   : 10 03                      dup.x1 sp(3)
	<modf+43 @0459e3>   : 23                         load.i64
	<modf+44 @0459e4>   : 80                         neg.f64
	<modf+45 @0459e5>   : 10 05                      dup.x1 sp(5)
	<modf+47 @0459e7>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0459e8> - <@0459eb>): return float64(.result := result);
	<modf+48 @0459e8>   : 14 06                      set.x2 sp(6)
	<modf+50 @0459ea>   : 03                         ret
	<modf+51 @0459eb>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0459ef> - <@0459f3>): float64(intPart := (0));
	<modf+55 @0459ef>   : 1a                         load.z64
	<modf+56 @0459f0>   : 10 03                      dup.x1 sp(3)
	<modf+58 @0459f2>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0459f3> - <@0459f7>): return float64(.result := x);
	<modf+59 @0459f3>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @0459f6>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0459f7> - <@045a03>): result: float64 := float64(x % (1))
	<modf+63 @0459f7>   : 11 02                      dup.x2 sp(2)
	<modf+65 @0459f9>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @045a02>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@045a03> - <@045a0b>): float64(intPart := float64(x - result));
	<modf+75 @045a03>   : 11 04                      dup.x2 sp(4)
	<modf+77 @045a05>   : 11 02                      dup.x2 sp(2)
	<modf+79 @045a07>   : 82                         sub.f64
	<modf+80 @045a08>   : 10 05                      dup.x1 sp(5)
	<modf+82 @045a0a>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@045a0b> - <@045a0e>): return float64(.result := result);
	<modf+83 @045a0b>   : 14 06                      set.x2 sp(6)
	<modf+85 @045a0d>   : 03                         ret
.references:
	lib/std/math.ci:330: referenced as `modf`
	lib/std/math.ci:278: referenced as `modf`
	lib/std/math.ci:274: referenced as `modf`
	lib/std/math.ci:48: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@045a10>
.name: 'floor'
.file: 'lib/std/math.ci:46'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@045a10> - <@045a28>)
	lib/std/math.ci:47: (1 byte: <@045a10> - <@045a11>): result: float64
	<floor @045a10>      : 1b                         load.z128
	lib/std/math.ci:48: (20 bytes: <@045a11> - <@045a25>): modf(void(x, result));
	<floor+1 @045a11>    : 11 05                      dup.x2 sp(5)
	<floor+3 @045a13>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @045a17>    : 1f b8 59 04 00             load.ref <@0459b8> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @045a1c>   : 02                         call
	<floor+13 @045a1d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @045a21>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:49: (3 bytes: <@045a25> - <@045a28>): return float64(.result := result);
	<floor+21 @045a25>   : 14 05                      set.x2 sp(5)
	<floor+23 @045a27>   : 03                         ret
.references:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:52: referenced as `floor`
	lib/std/math.ci:51: referenced as `floor`
	lib/std/math.ci:46: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:51'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(-floor(float64(-x)))
.references:
	lib/std/math.ci:51: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:52'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: floor(float64(x + 0.500000))
.references:
	lib/std/math.ci:52: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@045a28>
.name: 'sign'
.file: 'lib/std/math.ci:58'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@045a28> - <@045a4c>)
	lib/std/math.ci:59: (12 bytes: <@045a28> - <@045a34>): if (bool(x == (0)))
	<sign @045a28>      : 10 01                      dup.x1 sp(1)
	<sign+2 @045a2a>    : 19                         load.z32
	<sign+3 @045a2b>    : 77                         ceq.f32
	<sign+4 @045a2c>    : 06 08 00 00                jz <sign+12 @045a34>
	lib/std/math.ci:60: (4 bytes: <@045a30> - <@045a34>): return int32(.result := 0);
	<sign+8 @045a30>    : 19                         load.z32
	<sign+9 @045a31>    : 13 03                      set.x1 sp(3)
	<sign+11 @045a33>   : 03                         ret
	lib/std/math.ci:62: (16 bytes: <@045a34> - <@045a44>): if (bool(x < (0)))
	<sign+12 @045a34>   : 10 01                      dup.x1 sp(1)
	<sign+14 @045a36>   : 19                         load.z32
	<sign+15 @045a37>   : 78                         clt.f32
	<sign+16 @045a38>   : 06 0c 00 00                jz <sign+28 @045a44>
	lib/std/math.ci:63: (8 bytes: <@045a3c> - <@045a44>): return int32(.result := int32(-1));
	<sign+20 @045a3c>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @045a41>   : 13 03                      set.x1 sp(3)
	<sign+27 @045a43>   : 03                         ret
	lib/std/math.ci:65: (8 bytes: <@045a44> - <@045a4c>): return int32(.result := 1);
	<sign+28 @045a44>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @045a49>   : 13 03                      set.x1 sp(3)
	<sign+35 @045a4b>   : 03                         ret
.references:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:58: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@045a50>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float64 (size: 8, offs: <+12>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@045a50> - <@045a74>)
	lib/std/math.ci:68: (12 bytes: <@045a50> - <@045a5c>): if (bool(x == (0)))
	<sign @045a50>      : 11 01                      dup.x2 sp(1)
	<sign+2 @045a52>    : 1a                         load.z64
	<sign+3 @045a53>    : 87                         ceq.f64
	<sign+4 @045a54>    : 06 08 00 00                jz <sign+12 @045a5c>
	lib/std/math.ci:69: (4 bytes: <@045a58> - <@045a5c>): return int32(.result := 0);
	<sign+8 @045a58>    : 19                         load.z32
	<sign+9 @045a59>    : 13 04                      set.x1 sp(4)
	<sign+11 @045a5b>   : 03                         ret
	lib/std/math.ci:71: (16 bytes: <@045a5c> - <@045a6c>): if (bool(x < (0)))
	<sign+12 @045a5c>   : 11 01                      dup.x2 sp(1)
	<sign+14 @045a5e>   : 1a                         load.z64
	<sign+15 @045a5f>   : 88                         clt.f64
	<sign+16 @045a60>   : 06 0c 00 00                jz <sign+28 @045a6c>
	lib/std/math.ci:72: (8 bytes: <@045a64> - <@045a6c>): return int32(.result := int32(-1));
	<sign+20 @045a64>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @045a69>   : 13 04                      set.x1 sp(4)
	<sign+27 @045a6b>   : 03                         ret
	lib/std/math.ci:74: (8 bytes: <@045a6c> - <@045a74>): return int32(.result := 1);
	<sign+28 @045a6c>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @045a71>   : 13 04                      set.x1 sp(4)
	<sign+35 @045a73>   : 03                         ret
.references:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@045a78>
.name: 'abs'
.file: 'lib/std/math.ci:83'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@045a78> - <@045a8a>)
	lib/std/math.ci:84: (14 bytes: <@045a78> - <@045a86>): if (bool(x < (0)))
	<abs @045a78>      : 10 01                      dup.x1 sp(1)
	<abs+2 @045a7a>    : 19                         load.z32
	<abs+3 @045a7b>    : 78                         clt.f32
	<abs+4 @045a7c>    : 06 0a 00 00                jz <abs+14 @045a86>
	lib/std/math.ci:85: (6 bytes: <@045a80> - <@045a86>): return float32(.result := float32(-x));
	<abs+8 @045a80>    : 10 01                      dup.x1 sp(1)
	<abs+10 @045a82>   : 70                         neg.f32
	<abs+11 @045a83>   : 13 03                      set.x1 sp(3)
	<abs+13 @045a85>   : 03                         ret
	lib/std/math.ci:87: (4 bytes: <@045a86> - <@045a8a>): return float32(.result := x);
	<abs+14 @045a86>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @045a89>   : 03                         ret
.references:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:83: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@045a90>
.name: 'abs'
.file: 'lib/std/math.ci:89'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@045a90> - <@045aa2>)
	lib/std/math.ci:90: (14 bytes: <@045a90> - <@045a9e>): if (bool(x < (0)))
	<abs @045a90>      : 11 01                      dup.x2 sp(1)
	<abs+2 @045a92>    : 1a                         load.z64
	<abs+3 @045a93>    : 88                         clt.f64
	<abs+4 @045a94>    : 06 0a 00 00                jz <abs+14 @045a9e>
	lib/std/math.ci:91: (6 bytes: <@045a98> - <@045a9e>): return float64(.result := float64(-x));
	<abs+8 @045a98>    : 11 01                      dup.x2 sp(1)
	<abs+10 @045a9a>   : 80                         neg.f64
	<abs+11 @045a9b>   : 14 05                      set.x2 sp(5)
	<abs+13 @045a9d>   : 03                         ret
	lib/std/math.ci:93: (4 bytes: <@045a9e> - <@045aa2>): return float64(.result := x);
	<abs+14 @045a9e>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @045aa1>   : 03                         ret
.references:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.ci:304: referenced as `abs`
	lib/std/math.ci:89: defined as `abs(x: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@045aa8>
.name: 'min'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@045aa8> - <@045ab9>)
	lib/std/math.ci:102: (13 bytes: <@045aa8> - <@045ab5>): if (bool(a < b))
	<min @045aa8>      : 10 02                      dup.x1 sp(2)
	<min+2 @045aaa>    : 10 02                      dup.x1 sp(2)
	<min+4 @045aac>    : 78                         clt.f32
	<min+5 @045aad>    : 06 08 00 00                jz <min+13 @045ab5>
	lib/std/math.ci:103: (4 bytes: <@045ab1> - <@045ab5>): return float32(.result := a);
	<min+9 @045ab1>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @045ab4>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@045ab5> - <@045ab9>): return float32(.result := b);
	<min+13 @045ab5>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @045ab8>   : 03                         ret
.references:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:101: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@045ac0>
.name: 'min'
.file: 'lib/std/math.ci:107'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@045ac0> - <@045ad1>)
	lib/std/math.ci:108: (13 bytes: <@045ac0> - <@045acd>): if (bool(a < b))
	<min @045ac0>      : 11 03                      dup.x2 sp(3)
	<min+2 @045ac2>    : 11 03                      dup.x2 sp(3)
	<min+4 @045ac4>    : 88                         clt.f64
	<min+5 @045ac5>    : 06 08 00 00                jz <min+13 @045acd>
	lib/std/math.ci:109: (4 bytes: <@045ac9> - <@045acd>): return float64(.result := a);
	<min+9 @045ac9>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @045acc>   : 03                         ret
	lib/std/math.ci:111: (4 bytes: <@045acd> - <@045ad1>): return float64(.result := b);
	<min+13 @045acd>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @045ad0>   : 03                         ret
.references:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:107: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@045ad8>
.name: 'max'
.file: 'lib/std/math.ci:119'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@045ad8> - <@045ae9>)
	lib/std/math.ci:120: (13 bytes: <@045ad8> - <@045ae5>): if (bool(a > b))
	<max @045ad8>      : 10 02                      dup.x1 sp(2)
	<max+2 @045ada>    : 10 02                      dup.x1 sp(2)
	<max+4 @045adc>    : 79                         cgt.f32
	<max+5 @045add>    : 06 08 00 00                jz <max+13 @045ae5>
	lib/std/math.ci:121: (4 bytes: <@045ae1> - <@045ae5>): return float32(.result := a);
	<max+9 @045ae1>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @045ae4>   : 03                         ret
	lib/std/math.ci:123: (4 bytes: <@045ae5> - <@045ae9>): return float32(.result := b);
	<max+13 @045ae5>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @045ae8>   : 03                         ret
.references:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:119: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@045af0>
.name: 'max'
.file: 'lib/std/math.ci:125'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@045af0> - <@045b01>)
	lib/std/math.ci:126: (13 bytes: <@045af0> - <@045afd>): if (bool(a > b))
	<max @045af0>      : 11 03                      dup.x2 sp(3)
	<max+2 @045af2>    : 11 03                      dup.x2 sp(3)
	<max+4 @045af4>    : 89                         cgt.f64
	<max+5 @045af5>    : 06 08 00 00                jz <max+13 @045afd>
	lib/std/math.ci:127: (4 bytes: <@045af9> - <@045afd>): return float64(.result := a);
	<max+9 @045af9>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @045afc>   : 03                         ret
	lib/std/math.ci:129: (4 bytes: <@045afd> - <@045b01>): return float64(.result := b);
	<max+13 @045afd>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @045b00>   : 03                         ret
.references:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:125: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@045b08>
.name: 'clamp'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@045b08> - <@045b26>)
	lib/std/math.ci:138: (13 bytes: <@045b08> - <@045b15>): if (bool(t < a))
	<clamp @045b08>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @045b0a>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @045b0c>    : 78                         clt.f32
	<clamp+5 @045b0d>    : 06 08 00 00                jz <clamp+13 @045b15>
	lib/std/math.ci:139: (4 bytes: <@045b11> - <@045b15>): return float32(.result := a);
	<clamp+9 @045b11>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @045b14>   : 03                         ret
	lib/std/math.ci:141: (13 bytes: <@045b15> - <@045b22>): if (bool(t > b))
	<clamp+13 @045b15>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @045b17>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @045b19>   : 79                         cgt.f32
	<clamp+18 @045b1a>   : 06 08 00 00                jz <clamp+26 @045b22>
	lib/std/math.ci:142: (4 bytes: <@045b1e> - <@045b22>): return float32(.result := b);
	<clamp+22 @045b1e>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @045b21>   : 03                         ret
	lib/std/math.ci:144: (4 bytes: <@045b22> - <@045b26>): return float32(.result := t);
	<clamp+26 @045b22>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @045b25>   : 03                         ret
.references:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:165: referenced as `clamp`
	lib/std/math.ci:137: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@045b28>
.name: 'clamp'
.file: 'lib/std/math.ci:146'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@045b28> - <@045b46>)
	lib/std/math.ci:147: (13 bytes: <@045b28> - <@045b35>): if (bool(t < a))
	<clamp @045b28>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @045b2a>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @045b2c>    : 88                         clt.f64
	<clamp+5 @045b2d>    : 06 08 00 00                jz <clamp+13 @045b35>
	lib/std/math.ci:148: (4 bytes: <@045b31> - <@045b35>): return float64(.result := a);
	<clamp+9 @045b31>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @045b34>   : 03                         ret
	lib/std/math.ci:150: (13 bytes: <@045b35> - <@045b42>): if (bool(t > b))
	<clamp+13 @045b35>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @045b37>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @045b39>   : 89                         cgt.f64
	<clamp+18 @045b3a>   : 06 08 00 00                jz <clamp+26 @045b42>
	lib/std/math.ci:151: (4 bytes: <@045b3e> - <@045b42>): return float64(.result := b);
	<clamp+22 @045b3e>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @045b41>   : 03                         ret
	lib/std/math.ci:153: (4 bytes: <@045b42> - <@045b46>): return float64(.result := t);
	<clamp+26 @045b42>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @045b45>   : 03                         ret
.references:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:166: referenced as `clamp`
	lib/std/math.ci:146: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:160'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: float32(a + float32(t * (float32(b - a))))
.references:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:160: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:161'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: float64(a + float64(t * (float64(b - a))))
.references:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:161: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:163'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.references:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:165: referenced as `smooth`
	lib/std/math.ci:163: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:164'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.references:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:166: referenced as `smooth`
	lib/std/math.ci:164: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:165'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.references:
	test/stdc/test.math.ci:37: referenced as `smooth`
	lib/std/math.ci:165: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:166'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.references:
	test/stdc/test.math.ci:38: referenced as `smooth`
	lib/std/math.ci:166: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@045b48>
.name: 'min'
.file: 'lib/std/math.ci:172'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@045b48> - <@045b90>)
	lib/std/math.ci:173: (13 bytes: <@045b48> - <@045b55>): if (bool(data.length == (0)))
	<min @045b48>      : 10 02                      dup.x1 sp(2)
	<min+2 @045b4a>    : 19                         load.z32
	<min+3 @045b4b>    : 57                         ceq.i32
	<min+4 @045b4c>    : 06 09 00 00                jz <min+13 @045b55>
	lib/std/math.ci:174: (5 bytes: <@045b50> - <@045b55>): return float64(.result := nan);
	<min+8 @045b50>    : 1b                         load.z128
	<min+9 @045b51>    : 84                         div.f64
	<min+10 @045b52>   : 14 05                      set.x2 sp(5)
	<min+12 @045b54>   : 03                         ret
	lib/std/math.ci:176: (3 bytes: <@045b55> - <@045b58>): result: float64 := data[0]
	<min+13 @045b55>   : 10 01                      dup.x1 sp(1)
	<min+15 @045b57>   : 23                         load.i64
	lib/std/math.ci:177: (53 bytes: <@045b58> - <@045b8d>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @045b58>   : 1c 01 00 00 00             load.c32 1
	<min+21 @045b5d>   : 04 23 00 00                jmp <min+56 @045b80>
	lib/std/math.ci:178: (27 bytes: <@045b61> - <@045b7c>): if (bool(result > data[i]))
	<min+25 @045b61>   : 11 01                      dup.x2 sp(1)
	<min+27 @045b63>   : 10 06                      dup.x1 sp(6)
	<min+29 @045b65>   : 10 03                      dup.x1 sp(3)
	<min+31 @045b67>   : 0d 08 00 00                mad.u32 8
	<min+35 @045b6b>   : 23                         load.i64
	<min+36 @045b6c>   : 89                         cgt.f64
	<min+37 @045b6d>   : 06 0f 00 00                jz <min+52 @045b7c>
	lib/std/math.ci:179: (11 bytes: <@045b71> - <@045b7c>): float64(result := data[i]);
	<min+41 @045b71>   : 10 04                      dup.x1 sp(4)
	<min+43 @045b73>   : 10 01                      dup.x1 sp(1)
	<min+45 @045b75>   : 0d 08 00 00                mad.u32 8
	<min+49 @045b79>   : 23                         load.i64
	<min+50 @045b7a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:177: (4 bytes: <@045b7c> - <@045b80>): int32(i := int32(i + 1))
	<min+52 @045b7c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:177: (9 bytes: <@045b80> - <@045b89>): bool(i < (data.length))
	<min+56 @045b80>   : 10 00                      dup.x1 sp(0)
	<min+58 @045b82>   : 10 06                      dup.x1 sp(6)
	<min+60 @045b84>   : 58                         clt.i32
	<min+61 @045b85>   : 05 dc ff ff                jnz <min+25 @045b61>
	<min+65 @045b89>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:182: (3 bytes: <@045b8d> - <@045b90>): return float64(.result := result);
	<min+69 @045b8d>   : 14 05                      set.x2 sp(5)
	<min+71 @045b8f>   : 03                         ret
.references:
	test/stdc/test.math.ci:41: referenced as `min`
	test/stdc/test.math.ci:40: referenced as `min`
	lib/std/math.ci:172: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@045b90>
.name: 'max'
.file: 'lib/std/math.ci:184'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@045b90> - <@045bd8>)
	lib/std/math.ci:185: (13 bytes: <@045b90> - <@045b9d>): if (bool(data.length == (0)))
	<max @045b90>      : 10 02                      dup.x1 sp(2)
	<max+2 @045b92>    : 19                         load.z32
	<max+3 @045b93>    : 57                         ceq.i32
	<max+4 @045b94>    : 06 09 00 00                jz <max+13 @045b9d>
	lib/std/math.ci:186: (5 bytes: <@045b98> - <@045b9d>): return float64(.result := nan);
	<max+8 @045b98>    : 1b                         load.z128
	<max+9 @045b99>    : 84                         div.f64
	<max+10 @045b9a>   : 14 05                      set.x2 sp(5)
	<max+12 @045b9c>   : 03                         ret
	lib/std/math.ci:188: (3 bytes: <@045b9d> - <@045ba0>): result: float64 := data[0]
	<max+13 @045b9d>   : 10 01                      dup.x1 sp(1)
	<max+15 @045b9f>   : 23                         load.i64
	lib/std/math.ci:189: (53 bytes: <@045ba0> - <@045bd5>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @045ba0>   : 1c 01 00 00 00             load.c32 1
	<max+21 @045ba5>   : 04 23 00 00                jmp <max+56 @045bc8>
	lib/std/math.ci:190: (27 bytes: <@045ba9> - <@045bc4>): if (bool(result < data[i]))
	<max+25 @045ba9>   : 11 01                      dup.x2 sp(1)
	<max+27 @045bab>   : 10 06                      dup.x1 sp(6)
	<max+29 @045bad>   : 10 03                      dup.x1 sp(3)
	<max+31 @045baf>   : 0d 08 00 00                mad.u32 8
	<max+35 @045bb3>   : 23                         load.i64
	<max+36 @045bb4>   : 88                         clt.f64
	<max+37 @045bb5>   : 06 0f 00 00                jz <max+52 @045bc4>
	lib/std/math.ci:191: (11 bytes: <@045bb9> - <@045bc4>): float64(result := data[i]);
	<max+41 @045bb9>   : 10 04                      dup.x1 sp(4)
	<max+43 @045bbb>   : 10 01                      dup.x1 sp(1)
	<max+45 @045bbd>   : 0d 08 00 00                mad.u32 8
	<max+49 @045bc1>   : 23                         load.i64
	<max+50 @045bc2>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:189: (4 bytes: <@045bc4> - <@045bc8>): int32(i := int32(i + 1))
	<max+52 @045bc4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:189: (9 bytes: <@045bc8> - <@045bd1>): bool(i < (data.length))
	<max+56 @045bc8>   : 10 00                      dup.x1 sp(0)
	<max+58 @045bca>   : 10 06                      dup.x1 sp(6)
	<max+60 @045bcc>   : 58                         clt.i32
	<max+61 @045bcd>   : 05 dc ff ff                jnz <max+25 @045ba9>
	<max+65 @045bd1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:194: (3 bytes: <@045bd5> - <@045bd8>): return float64(.result := result);
	<max+69 @045bd5>   : 14 05                      set.x2 sp(5)
	<max+71 @045bd7>   : 03                         ret
.references:
	test/stdc/test.math.ci:43: referenced as `max`
	test/stdc/test.math.ci:42: referenced as `max`
	lib/std/math.ci:184: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@045bd8>
.name: 'sum'
.file: 'lib/std/math.ci:197'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@045bd8> - <@045c00>)
	lib/std/math.ci:198: (1 byte: <@045bd8> - <@045bd9>): result: float64 := 0
	<sum @045bd8>      : 1b                         load.z128
	lib/std/math.ci:199: (36 bytes: <@045bd9> - <@045bfd>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @045bd9>    : 6a                         i64.2i32
	<sum+2 @045bda>    : 04 16 00 00                jmp <sum+24 @045bf0>
	lib/std/math.ci:200: (14 bytes: <@045bde> - <@045bec>): float64(result := float64(result + data[i]));
	<sum+6 @045bde>    : 11 01                      dup.x2 sp(1)
	<sum+8 @045be0>    : 10 06                      dup.x1 sp(6)
	<sum+10 @045be2>   : 10 03                      dup.x1 sp(3)
	<sum+12 @045be4>   : 0d 08 00 00                mad.u32 8
	<sum+16 @045be8>   : 23                         load.i64
	<sum+17 @045be9>   : 81                         add.f64
	<sum+18 @045bea>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:199: (4 bytes: <@045bec> - <@045bf0>): int32(i := int32(i + 1))
	<sum+20 @045bec>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:199: (9 bytes: <@045bf0> - <@045bf9>): bool(i < (data.length))
	<sum+24 @045bf0>   : 10 00                      dup.x1 sp(0)
	<sum+26 @045bf2>   : 10 06                      dup.x1 sp(6)
	<sum+28 @045bf4>   : 58                         clt.i32
	<sum+29 @045bf5>   : 05 e9 ff ff                jnz <sum+6 @045bde>
	<sum+33 @045bf9>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:202: (3 bytes: <@045bfd> - <@045c00>): return float64(.result := result);
	<sum+37 @045bfd>   : 14 05                      set.x2 sp(5)
	<sum+39 @045bff>   : 03                         ret
.references:
	test/stdc/test.math.ci:48: referenced as `sum`
	test/stdc/test.math.ci:47: referenced as `sum`
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	lib/std/math.ci:197: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:211'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.value: (a0)
.references:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:211: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:212'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.value: (float64(a0 + float64(x * a1)))
.references:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:213: referenced as `eval`
	lib/std/math.ci:212: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:213'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.references:
	test/stdc/test.math.ci:54: referenced as `eval`
	lib/std/math.ci:214: referenced as `eval`
	lib/std/math.ci:213: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:214'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.references:
	test/stdc/test.math.ci:55: referenced as `eval`
	lib/std/math.ci:214: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@045c00>
.name: 'eval'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@045c00> - <@045c2f>)
	lib/std/math.ci:216: (1 byte: <@045c00> - <@045c01>): result: float64 := 0
	<eval @045c00>      : 1a                         load.z64
	lib/std/math.ci:217: (43 bytes: <@045c01> - <@045c2c>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @045c01>    : 10 04                      dup.x1 sp(4)
	<eval+3 @045c03>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @045c07>    : 04 19 00 00                jmp <eval+32 @045c20>
	lib/std/math.ci:218: (17 bytes: <@045c0b> - <@045c1c>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @045c0b>   : 11 01                      dup.x2 sp(1)
	<eval+13 @045c0d>   : 11 08                      dup.x2 sp(8)
	<eval+15 @045c0f>   : 83                         mul.f64
	<eval+16 @045c10>   : 10 06                      dup.x1 sp(6)
	<eval+18 @045c12>   : 10 03                      dup.x1 sp(3)
	<eval+20 @045c14>   : 0d 08 00 00                mad.u32 8
	<eval+24 @045c18>   : 23                         load.i64
	<eval+25 @045c19>   : 81                         add.f64
	<eval+26 @045c1a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:217: (4 bytes: <@045c1c> - <@045c20>): int32(i := int32(i - 1))
	<eval+28 @045c1c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:217: (8 bytes: <@045c20> - <@045c28>): bool(i >= 0)
	<eval+32 @045c20>   : 10 00                      dup.x1 sp(0)
	<eval+34 @045c22>   : 19                         load.z32
	<eval+35 @045c23>   : 58                         clt.i32
	<eval+36 @045c24>   : 06 e7 ff ff                jz <eval+11 @045c0b>
	<eval+40 @045c28>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:220: (3 bytes: <@045c2c> - <@045c2f>): return float64(.result := result);
	<eval+44 @045c2c>   : 14 07                      set.x2 sp(7)
	<eval+46 @045c2e>   : 03                         ret
.references:
	test/stdc/test.math.ci:57: referenced as `eval`
	test/stdc/test.math.ci:56: referenced as `eval`
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:215: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@045c30>
.name: 'cmp'
.file: 'lib/std/math.ci:223'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@045c30> - <@045c69>)
	lib/std/math.ci:224: (53 bytes: <@045c30> - <@045c65>): if (bool(a < b))
	<cmp @045c30>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @045c32>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @045c34>    : 78                         clt.f32
	<cmp+5 @045c35>    : 06 1c 00 00                jz <cmp+33 @045c51>
	lib/std/math.ci:225: (20 bytes: <@045c39> - <@045c4d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @045c39>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @045c3b>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @045c3d>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @045c3f>   : 72                         sub.f32
	<cmp+16 @045c40>   : 78                         clt.f32
	<cmp+17 @045c41>   : 06 0c 00 00                jz <cmp+29 @045c4d>
	lib/std/math.ci:226: (8 bytes: <@045c45> - <@045c4d>): return int32(.result := int32(-1));
	<cmp+21 @045c45>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @045c4a>   : 13 05                      set.x1 sp(5)
	<cmp+28 @045c4c>   : 03                         ret
	<cmp+29 @045c4d>   : 04 18 00 00                jmp <cmp+53 @045c65>
	lib/std/math.ci:230: (20 bytes: <@045c51> - <@045c65>): if (bool(eps < (float32(a - b))))
	<cmp+33 @045c51>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @045c53>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @045c55>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @045c57>   : 72                         sub.f32
	<cmp+40 @045c58>   : 78                         clt.f32
	<cmp+41 @045c59>   : 06 0c 00 00                jz <cmp+53 @045c65>
	lib/std/math.ci:231: (8 bytes: <@045c5d> - <@045c65>): return int32(.result := int32(+1));
	<cmp+45 @045c5d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @045c62>   : 13 05                      set.x1 sp(5)
	<cmp+52 @045c64>   : 03                         ret
	lib/std/math.ci:234: (4 bytes: <@045c65> - <@045c69>): return int32(.result := 0);
	<cmp+53 @045c65>   : 19                         load.z32
	<cmp+54 @045c66>   : 13 05                      set.x1 sp(5)
	<cmp+56 @045c68>   : 03                         ret
.references:
	test/stdc/test.math.ci:69: referenced as `cmp`
	lib/std/math.ci:223: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@045c70>
.name: 'cmp'
.file: 'lib/std/math.ci:236'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@045c70> - <@045ca9>)
	lib/std/math.ci:237: (53 bytes: <@045c70> - <@045ca5>): if (bool(a < b))
	<cmp @045c70>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @045c72>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @045c74>    : 88                         clt.f64
	<cmp+5 @045c75>    : 06 1c 00 00                jz <cmp+33 @045c91>
	lib/std/math.ci:238: (20 bytes: <@045c79> - <@045c8d>): if (bool(eps < (float64(b - a))))
	<cmp+9 @045c79>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @045c7b>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @045c7d>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @045c7f>   : 82                         sub.f64
	<cmp+16 @045c80>   : 88                         clt.f64
	<cmp+17 @045c81>   : 06 0c 00 00                jz <cmp+29 @045c8d>
	lib/std/math.ci:239: (8 bytes: <@045c85> - <@045c8d>): return int32(.result := int32(-1));
	<cmp+21 @045c85>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @045c8a>   : 13 08                      set.x1 sp(8)
	<cmp+28 @045c8c>   : 03                         ret
	<cmp+29 @045c8d>   : 04 18 00 00                jmp <cmp+53 @045ca5>
	lib/std/math.ci:243: (20 bytes: <@045c91> - <@045ca5>): if (bool(eps < (float64(a - b))))
	<cmp+33 @045c91>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @045c93>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @045c95>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @045c97>   : 82                         sub.f64
	<cmp+40 @045c98>   : 88                         clt.f64
	<cmp+41 @045c99>   : 06 0c 00 00                jz <cmp+53 @045ca5>
	lib/std/math.ci:244: (8 bytes: <@045c9d> - <@045ca5>): return int32(.result := int32(+1));
	<cmp+45 @045c9d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @045ca2>   : 13 08                      set.x1 sp(8)
	<cmp+52 @045ca4>   : 03                         ret
	lib/std/math.ci:247: (4 bytes: <@045ca5> - <@045ca9>): return int32(.result := 0);
	<cmp+53 @045ca5>   : 19                         load.z32
	<cmp+54 @045ca6>   : 13 08                      set.x1 sp(8)
	<cmp+56 @045ca8>   : 03                         ret
.references:
	test/stdc/test.math.ci:70: referenced as `cmp`
	lib/std/math.ci:236: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@045cb0>
.name: 'sinCos'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@045cb0> - <@045dff>)
	lib/std/math.ci:264: (2 bytes: <@045cb0> - <@045cb2>): x: float64 := arg
	<sinCos @045cb0>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:265: (17 bytes: <@045cb2> - <@045cc3>): if (bool(x < (0)))
	<sinCos+2 @045cb2>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @045cb4>    : 1a                         load.z64
	<sinCos+5 @045cb5>    : 88                         clt.f64
	<sinCos+6 @045cb6>    : 06 0d 00 00                jz <sinCos+19 @045cc3>
	lib/std/math.ci:266: (1 byte: <@045cba> - <@045cbb>): float64(x := float64(-x));
	<sinCos+10 @045cba>   : 80                         neg.f64
	lib/std/math.ci:267: (8 bytes: <@045cbb> - <@045cc3>): int32(quad := int32(quad + 2));
	<sinCos+11 @045cbb>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @045cbd>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @045cc1>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:270: (1 byte: <@045cc3> - <@045cc4>): y: float64
	<sinCos+19 @045cc3>   : 1a                         load.z64
	lib/std/math.ci:271: (24 bytes: <@045cc4> - <@045cdc>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @045cc4>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @045cc6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @045ccf>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @045cd8>   : 84                         div.f64
	<sinCos+41 @045cd9>   : 83                         mul.f64
	<sinCos+42 @045cda>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:272: (124 bytes: <@045cdc> - <@045d58>): if (bool(x > (32764)))
	<sinCos+44 @045cdc>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @045cde>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @045ce7>   : 89                         cgt.f64
	<sinCos+56 @045ce8>   : 06 54 00 00                jz <sinCos+140 @045d3c>
	lib/std/math.ci:273: (1 byte: <@045cec> - <@045ced>): e: float64
	<sinCos+60 @045cec>   : 1b                         load.z128
	lib/std/math.ci:274: (18 bytes: <@045ced> - <@045cff>): float64(y := modf(void(x, e)));
	<sinCos+61 @045ced>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @045cef>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @045cf3>   : 1f b8 59 04 00             load.ref <@0459b8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @045cf8>   : 02                         call
	<sinCos+73 @045cf9>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @045cfd>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:275: (4 bytes: <@045cff> - <@045d03>): float64(e := float64(e + (quad)));
	<sinCos+79 @045cff>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @045d01>   : 5d                         i32.2f64
	<sinCos+82 @045d02>   : 81                         add.f64
	lib/std/math.ci:277: (1 byte: <@045d03> - <@045d04>): f: float64
	<sinCos+83 @045d03>   : 1b                         load.z128
	lib/std/math.ci:278: (30 bytes: <@045d04> - <@045d22>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @045d04>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @045d0d>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @045d0f>   : 83                         mul.f64
	<sinCos+96 @045d10>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @045d14>  : 1f b8 59 04 00             load.ref <@0459b8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @045d19>  : 02                         call
	<sinCos+106 @045d1a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @045d1e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:279: (18 bytes: <@045d22> - <@045d34>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @045d22>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @045d24>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @045d2d>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @045d2f>  : 83                         mul.f64
	<sinCos+128 @045d30>  : 82                         sub.f64
	<sinCos+129 @045d31>  : 8a                         f64.2i32
	<sinCos+130 @045d32>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @045d34>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @045d38>  : 04 20 00 00                jmp <sinCos+168 @045d58>
	lib/std/math.ci:282: (3 bytes: <@045d3c> - <@045d3f>): k: int32 := x
	<sinCos+140 @045d3c>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @045d3e>  : 8a                         f64.2i32
	lib/std/math.ci:283: (8 bytes: <@045d3f> - <@045d47>): float64(y := float64(x - (k)));
	<sinCos+143 @045d3f>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @045d41>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @045d43>  : 5d                         i32.2f64
	<sinCos+148 @045d44>  : 82                         sub.f64
	<sinCos+149 @045d45>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:284: (7 bytes: <@045d47> - <@045d4e>): int32(quad := int32(quad + k));
	<sinCos+151 @045d47>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @045d49>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @045d4b>  : 51                         add.i32
	<sinCos+156 @045d4c>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:285: (6 bytes: <@045d4e> - <@045d54>): int32(quad := int32(quad & 3));
	<sinCos+158 @045d4e>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @045d50>  : 3f 02                      b32.and 0x003
	<sinCos+162 @045d52>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @045d54>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:287: (22 bytes: <@045d58> - <@045d6e>): if (int32(quad & 1))
	<sinCos+168 @045d58>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @045d5a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @045d5c>  : 06 12 00 00                jz <sinCos+190 @045d6e>
	lib/std/math.ci:288: (14 bytes: <@045d60> - <@045d6e>): float64(y := float64((1) - y));
	<sinCos+176 @045d60>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @045d69>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @045d6b>  : 82                         sub.f64
	<sinCos+188 @045d6c>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:290: (13 bytes: <@045d6e> - <@045d7b>): if (bool(quad > 1))
	<sinCos+190 @045d6e>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @045d70>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @045d75>  : 59                         cgt.i32
	<sinCos+198 @045d76>  : 06 05 00 00                jz <sinCos+203 @045d7b>
	lib/std/math.ci:291: (1 byte: <@045d7a> - <@045d7b>): float64(y := float64(-y));
	<sinCos+202 @045d7a>  : 80                         neg.f64
	lib/std/math.ci:294: (5 bytes: <@045d7b> - <@045d80>): ysq: float64 := float64(y * y)
	<sinCos+203 @045d7b>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @045d7d>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @045d7f>  : 83                         mul.f64
	lib/std/math.ci:295: (64 bytes: <@045d80> - <@045dc0>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @045d80>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @045d89>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @045d8b>  : 83                         mul.f64
	<sinCos+220 @045d8c>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @045d95>  : 81                         add.f64
	<sinCos+230 @045d96>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @045d98>  : 83                         mul.f64
	<sinCos+233 @045d99>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @045da2>  : 81                         add.f64
	<sinCos+243 @045da3>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @045da5>  : 83                         mul.f64
	<sinCos+246 @045da6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @045daf>  : 81                         add.f64
	<sinCos+256 @045db0>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @045db2>  : 83                         mul.f64
	<sinCos+259 @045db3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @045dbc>  : 81                         add.f64
	<sinCos+269 @045dbd>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @045dbf>  : 83                         mul.f64
	lib/std/math.ci:296: (51 bytes: <@045dc0> - <@045df3>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @045dc0>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @045dc2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @045dcb>  : 81                         add.f64
	<sinCos+284 @045dcc>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @045dce>  : 83                         mul.f64
	<sinCos+287 @045dcf>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @045dd8>  : 81                         add.f64
	<sinCos+297 @045dd9>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @045ddb>  : 83                         mul.f64
	<sinCos+300 @045ddc>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @045de5>  : 81                         add.f64
	<sinCos+310 @045de6>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @045de8>  : 83                         mul.f64
	<sinCos+313 @045de9>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @045df2>  : 81                         add.f64
	lib/std/math.ci:297: (12 bytes: <@045df3> - <@045dff>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @045df3>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @045df5>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @045df7>  : 84                         div.f64
	<sinCos+328 @045df8>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @045dfa>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @045dfe>  : 03                         ret
.references:
	lib/std/math.ci:304: referenced as `sinCos`
	lib/std/math.ci:301: referenced as `sinCos`
	lib/std/math.ci:250: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:301'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(arg, 0))
.references:
	test/stdc/test.math.ci:59: referenced as `sin`
	lib/std/math.ci:301: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:304'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(abs(arg), 1))
.references:
	test/stdc/test.math.ci:60: referenced as `cos`
	lib/std/math.ci:304: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@045e00>
.name: 'tan'
.file: 'lib/std/math.ci:307'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@045e00> - <@045f73>)
	lib/std/math.ci:320: (1 byte: <@045e00> - <@045e01>): complement: bool := false
	<tan @045e00>      : 19                         load.z32
	lib/std/math.ci:321: (1 byte: <@045e01> - <@045e02>): negate: bool := false
	<tan+1 @045e01>    : 19                         load.z32
	lib/std/math.ci:323: (23 bytes: <@045e02> - <@045e19>): if (bool(arg < (0)))
	<tan+2 @045e02>    : 11 03                      dup.x2 sp(3)
	<tan+4 @045e04>    : 1a                         load.z64
	<tan+5 @045e05>    : 88                         clt.f64
	<tan+6 @045e06>    : 06 13 00 00                jz <tan+25 @045e19>
	lib/std/math.ci:324: (5 bytes: <@045e0a> - <@045e0f>): float64(arg := float64(-arg));
	<tan+10 @045e0a>   : 11 03                      dup.x2 sp(3)
	<tan+12 @045e0c>   : 80                         neg.f64
	<tan+13 @045e0d>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:325: (10 bytes: <@045e0f> - <@045e19>): bool(negate := true);
	<tan+15 @045e0f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @045e14>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @045e18>   : 25                         store.i8
	lib/std/math.ci:327: (24 bytes: <@045e19> - <@045e31>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @045e19>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @045e22>   : 11 05                      dup.x2 sp(5)
	<tan+36 @045e24>   : 83                         mul.f64
	<tan+37 @045e25>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @045e2e>   : 84                         div.f64
	<tan+47 @045e2f>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:329: (1 byte: <@045e31> - <@045e32>): e: float64
	<tan+49 @045e31>   : 1b                         load.z128
	lib/std/math.ci:330: (16 bytes: <@045e32> - <@045e42>): x: float64 := modf(void(arg, e))
	<tan+50 @045e32>   : 11 07                      dup.x2 sp(7)
	<tan+52 @045e34>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @045e38>   : 1f b8 59 04 00             load.ref <@0459b8> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @045e3d>   : 02                         call
	<tan+62 @045e3e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:331: (9 bytes: <@045e42> - <@045e4b>): i: int32 := int32(int32(e) % 4)
	<tan+66 @045e42>   : 11 02                      dup.x2 sp(2)
	<tan+68 @045e44>   : 8a                         f64.2i32
	<tan+69 @045e45>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @045e4a>   : 55                         mod.i32
	lib/std/math.ci:333: (122 bytes: <@045e4b> - <@045ec5>): if (bool(i == 0))
	<tan+75 @045e4b>   : 10 00                      dup.x1 sp(0)
	<tan+77 @045e4d>   : 19                         load.z32
	<tan+78 @045e4e>   : 57                         ceq.i32
	<tan+79 @045e4f>   : 05 76 00 00                jnz <tan+197 @045ec5>
	lib/std/math.ci:334: (114 bytes: <@045e53> - <@045ec5>): if (bool(i == 1))
	<tan+83 @045e53>   : 10 00                      dup.x1 sp(0)
	<tan+85 @045e55>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @045e5a>   : 57                         ceq.i32
	<tan+91 @045e5b>   : 06 20 00 00                jz <tan+123 @045e7b>
	lib/std/math.ci:335: (14 bytes: <@045e5f> - <@045e6d>): float64(x := float64((1) - x));
	<tan+95 @045e5f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @045e68>  : 11 03                      dup.x2 sp(3)
	<tan+106 @045e6a>  : 82                         sub.f64
	<tan+107 @045e6b>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:336: (10 bytes: <@045e6d> - <@045e77>): bool(complement := true);
	<tan+109 @045e6d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @045e72>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @045e76>  : 25                         store.i8
	<tan+119 @045e77>  : 04 4e 00 00                jmp <tan+197 @045ec5>
	lib/std/math.ci:338: (74 bytes: <@045e7b> - <@045ec5>): if (bool(i == 2))
	<tan+123 @045e7b>  : 10 00                      dup.x1 sp(0)
	<tan+125 @045e7d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @045e82>  : 57                         ceq.i32
	<tan+131 @045e83>  : 06 1d 00 00                jz <tan+160 @045ea0>
	lib/std/math.ci:339: (11 bytes: <@045e87> - <@045e92>): bool(negate := bool(!negate));
	<tan+135 @045e87>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @045e8b>  : 20                         load.i8
	<tan+140 @045e8c>  : 0b                         not.b32
	<tan+141 @045e8d>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @045e91>  : 25                         store.i8
	lib/std/math.ci:340: (10 bytes: <@045e92> - <@045e9c>): bool(complement := true);
	<tan+146 @045e92>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @045e97>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @045e9b>  : 25                         store.i8
	<tan+156 @045e9c>  : 04 29 00 00                jmp <tan+197 @045ec5>
	lib/std/math.ci:342: (37 bytes: <@045ea0> - <@045ec5>): if (bool(i == 3))
	<tan+160 @045ea0>  : 10 00                      dup.x1 sp(0)
	<tan+162 @045ea2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @045ea7>  : 57                         ceq.i32
	<tan+168 @045ea8>  : 06 1d 00 00                jz <tan+197 @045ec5>
	lib/std/math.ci:343: (14 bytes: <@045eac> - <@045eba>): float64(x := float64((1) - x));
	<tan+172 @045eac>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @045eb5>  : 11 03                      dup.x2 sp(3)
	<tan+183 @045eb7>  : 82                         sub.f64
	<tan+184 @045eb8>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:344: (11 bytes: <@045eba> - <@045ec5>): bool(negate := bool(!negate));
	<tan+186 @045eba>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @045ebe>  : 20                         load.i8
	<tan+191 @045ebf>  : 0b                         not.b32
	<tan+192 @045ec0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @045ec4>  : 25                         store.i8
	lib/std/math.ci:347: (5 bytes: <@045ec5> - <@045eca>): xsq: float64 := float64(x * x)
	<tan+197 @045ec5>  : 11 01                      dup.x2 sp(1)
	<tan+199 @045ec7>  : 11 03                      dup.x2 sp(3)
	<tan+201 @045ec9>  : 83                         mul.f64
	lib/std/math.ci:348: (64 bytes: <@045eca> - <@045f0a>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @045eca>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @045ed3>  : 11 02                      dup.x2 sp(2)
	<tan+213 @045ed5>  : 83                         mul.f64
	<tan+214 @045ed6>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @045edf>  : 81                         add.f64
	<tan+224 @045ee0>  : 11 02                      dup.x2 sp(2)
	<tan+226 @045ee2>  : 83                         mul.f64
	<tan+227 @045ee3>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @045eec>  : 81                         add.f64
	<tan+237 @045eed>  : 11 02                      dup.x2 sp(2)
	<tan+239 @045eef>  : 83                         mul.f64
	<tan+240 @045ef0>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @045ef9>  : 81                         add.f64
	<tan+250 @045efa>  : 11 02                      dup.x2 sp(2)
	<tan+252 @045efc>  : 83                         mul.f64
	<tan+253 @045efd>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @045f06>  : 81                         add.f64
	<tan+263 @045f07>  : 11 05                      dup.x2 sp(5)
	<tan+265 @045f09>  : 83                         mul.f64
	lib/std/math.ci:349: (39 bytes: <@045f0a> - <@045f31>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @045f0a>  : 11 02                      dup.x2 sp(2)
	<tan+268 @045f0c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @045f15>  : 81                         add.f64
	<tan+278 @045f16>  : 11 04                      dup.x2 sp(4)
	<tan+280 @045f18>  : 83                         mul.f64
	<tan+281 @045f19>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @045f22>  : 81                         add.f64
	<tan+291 @045f23>  : 11 04                      dup.x2 sp(4)
	<tan+293 @045f25>  : 83                         mul.f64
	<tan+294 @045f26>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @045f2f>  : 81                         add.f64
	<tan+304 @045f30>  : 84                         div.f64
	lib/std/math.ci:351: (40 bytes: <@045f31> - <@045f59>): if (complement)
	<tan+305 @045f31>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @045f35>  : 20                         load.i8
	<tan+310 @045f36>  : 06 23 00 00                jz <tan+345 @045f59>
	lib/std/math.ci:352: (17 bytes: <@045f3a> - <@045f4b>): if (bool(result == (0)))
	<tan+314 @045f3a>  : 11 00                      dup.x2 sp(0)
	<tan+316 @045f3c>  : 1a                         load.z64
	<tan+317 @045f3d>  : 87                         ceq.f64
	<tan+318 @045f3e>  : 06 0d 00 00                jz <tan+331 @045f4b>
	lib/std/math.ci:353: (9 bytes: <@045f42> - <@045f4b>): return float64(.result := nan);
	<tan+322 @045f42>  : 1b                         load.z128
	<tan+323 @045f43>  : 84                         div.f64
	<tan+324 @045f44>  : 14 10                      set.x2 sp(16)
	<tan+326 @045f46>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @045f4a>  : 03                         ret
	lib/std/math.ci:355: (14 bytes: <@045f4b> - <@045f59>): float64(result := float64((1) / result));
	<tan+331 @045f4b>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @045f54>  : 11 02                      dup.x2 sp(2)
	<tan+342 @045f56>  : 84                         div.f64
	<tan+343 @045f57>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:357: (19 bytes: <@045f59> - <@045f6c>): if (negate)
	<tan+345 @045f59>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @045f5d>  : 20                         load.i8
	<tan+350 @045f5e>  : 06 0e 00 00                jz <tan+364 @045f6c>
	lib/std/math.ci:358: (10 bytes: <@045f62> - <@045f6c>): return float64(.result := float64(-result));
	<tan+354 @045f62>  : 11 00                      dup.x2 sp(0)
	<tan+356 @045f64>  : 80                         neg.f64
	<tan+357 @045f65>  : 14 10                      set.x2 sp(16)
	<tan+359 @045f67>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @045f6b>  : 03                         ret
	lib/std/math.ci:360: (7 bytes: <@045f6c> - <@045f73>): return float64(.result := result);
	<tan+364 @045f6c>  : 14 0e                      set.x2 sp(14)
	<tan+366 @045f6e>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @045f72>  : 03                         ret
.references:
	test/stdc/test.math.ci:61: referenced as `tan`
	lib/std/math.ci:307: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@045f78>
.name: 'sinh'
.file: 'lib/std/math.ci:364'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@045f78> - <@046069>)
	lib/std/math.ci:376: (1 byte: <@045f78> - <@045f79>): negate: bool := false
	<sinh @045f78>      : 19                         load.z32
	lib/std/math.ci:377: (23 bytes: <@045f79> - <@045f90>): if (bool(x < (0)))
	<sinh+1 @045f79>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @045f7b>    : 1a                         load.z64
	<sinh+4 @045f7c>    : 88                         clt.f64
	<sinh+5 @045f7d>    : 06 13 00 00                jz <sinh+24 @045f90>
	lib/std/math.ci:378: (5 bytes: <@045f81> - <@045f86>): float64(x := float64(-x));
	<sinh+9 @045f81>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @045f83>   : 80                         neg.f64
	<sinh+12 @045f84>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:379: (10 bytes: <@045f86> - <@045f90>): bool(negate := true);
	<sinh+14 @045f86>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @045f8b>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @045f8f>   : 25                         store.i8
	lib/std/math.ci:382: (39 bytes: <@045f90> - <@045fb7>): if (bool(x > (21)))
	<sinh+24 @045f90>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @045f92>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @045f9b>   : 89                         cgt.f64
	<sinh+36 @045f9c>   : 06 1b 00 00                jz <sinh+63 @045fb7>
	lib/std/math.ci:383: (23 bytes: <@045fa0> - <@045fb7>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @045fa0>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @045fa2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @045fa6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @045faf>   : 84                         div.f64
	<sinh+56 @045fb0>   : 14 06                      set.x2 sp(6)
	<sinh+58 @045fb2>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @045fb6>   : 03                         ret
	lib/std/math.ci:386: (1 byte: <@045fb7> - <@045fb8>): result: float64
	<sinh+63 @045fb7>   : 1a                         load.z64
	lib/std/math.ci:387: (151 bytes: <@045fb8> - <@04604f>): if (bool(x > 0.500000))
	<sinh+64 @045fb8>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @045fba>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @045fc3>   : 89                         cgt.f64
	<sinh+76 @045fc4>   : 06 22 00 00                jz <sinh+110 @045fe6>
	lib/std/math.ci:388: (26 bytes: <@045fc8> - <@045fe2>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @045fc8>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @045fca>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @045fce>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @045fd0>   : 80                         neg.f64
	<sinh+89 @045fd1>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @045fd5>   : 82                         sub.f64
	<sinh+94 @045fd6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @045fdf>  : 84                         div.f64
	<sinh+104 @045fe0>  : 14 02                      set.x2 sp(2)
	<sinh+106 @045fe2>  : 04 6d 00 00                jmp <sinh+215 @04604f>
	lib/std/math.ci:391: (5 bytes: <@045fe6> - <@045feb>): sq: float64 := float64(x * x)
	<sinh+110 @045fe6>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @045fe8>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @045fea>  : 83                         mul.f64
	lib/std/math.ci:392: (53 bytes: <@045feb> - <@046020>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @045feb>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @045ff4>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @045ff6>  : 83                         mul.f64
	<sinh+127 @045ff7>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @046000>  : 81                         add.f64
	<sinh+137 @046001>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @046003>  : 83                         mul.f64
	<sinh+140 @046004>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @04600d>  : 81                         add.f64
	<sinh+150 @04600e>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @046010>  : 83                         mul.f64
	<sinh+153 @046011>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @04601a>  : 81                         add.f64
	<sinh+163 @04601b>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @04601d>  : 83                         mul.f64
	<sinh+166 @04601e>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:393: (43 bytes: <@046020> - <@04604b>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @046020>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @046022>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @046024>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @04602d>  : 81                         add.f64
	<sinh+182 @04602e>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @046030>  : 83                         mul.f64
	<sinh+185 @046031>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @04603a>  : 81                         add.f64
	<sinh+195 @04603b>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @04603d>  : 83                         mul.f64
	<sinh+198 @04603e>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @046047>  : 81                         add.f64
	<sinh+208 @046048>  : 84                         div.f64
	<sinh+209 @046049>  : 14 04                      set.x2 sp(4)
	<sinh+211 @04604b>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:396: (19 bytes: <@04604f> - <@046062>): if (negate)
	<sinh+215 @04604f>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @046053>  : 20                         load.i8
	<sinh+220 @046054>  : 06 0e 00 00                jz <sinh+234 @046062>
	lib/std/math.ci:397: (10 bytes: <@046058> - <@046062>): return float64(.result := float64(-result));
	<sinh+224 @046058>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @04605a>  : 80                         neg.f64
	<sinh+227 @04605b>  : 14 08                      set.x2 sp(8)
	<sinh+229 @04605d>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @046061>  : 03                         ret
	lib/std/math.ci:399: (7 bytes: <@046062> - <@046069>): return float64(.result := result);
	<sinh+234 @046062>  : 14 06                      set.x2 sp(6)
	<sinh+236 @046064>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @046068>  : 03                         ret
.references:
	test/stdc/test.math.ci:62: referenced as `sinh`
	lib/std/math.Complex.ci:120: referenced as `sinh`
	lib/std/math.Complex.ci:119: referenced as `sinh`
	lib/std/math.ci:364: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@046070>
.name: 'cosh'
.file: 'lib/std/math.ci:403'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@046070> - <@0460bb>)
	lib/std/math.ci:404: (13 bytes: <@046070> - <@04607d>): if (bool(x < (0)))
	<cosh @046070>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @046072>    : 1a                         load.z64
	<cosh+3 @046073>    : 88                         clt.f64
	<cosh+4 @046074>    : 06 09 00 00                jz <cosh+13 @04607d>
	lib/std/math.ci:405: (5 bytes: <@046078> - <@04607d>): float64(x := float64(-x));
	<cosh+8 @046078>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @04607a>   : 80                         neg.f64
	<cosh+11 @04607b>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:407: (35 bytes: <@04607d> - <@0460a0>): if (bool(x > (21)))
	<cosh+13 @04607d>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @04607f>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @046088>   : 89                         cgt.f64
	<cosh+25 @046089>   : 06 17 00 00                jz <cosh+48 @0460a0>
	lib/std/math.ci:408: (19 bytes: <@04608d> - <@0460a0>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @04608d>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @04608f>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @046093>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @04609c>   : 84                         div.f64
	<cosh+45 @04609d>   : 14 05                      set.x2 sp(5)
	<cosh+47 @04609f>   : 03                         ret
	lib/std/math.ci:410: (27 bytes: <@0460a0> - <@0460bb>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @0460a0>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @0460a2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @0460a6>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @0460a8>   : 80                         neg.f64
	<cosh+57 @0460a9>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @0460ad>   : 81                         add.f64
	<cosh+62 @0460ae>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @0460b7>   : 84                         div.f64
	<cosh+72 @0460b8>   : 14 05                      set.x2 sp(5)
	<cosh+74 @0460ba>   : 03                         ret
.references:
	test/stdc/test.math.ci:63: referenced as `cosh`
	lib/std/math.Complex.ci:120: referenced as `cosh`
	lib/std/math.Complex.ci:119: referenced as `cosh`
	lib/std/math.ci:403: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@0460c0>
.name: 'asin'
.file: 'lib/std/math.ci:419'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@0460c0> - <@046166>)
	lib/std/math.ci:420: (12 bytes: <@0460c0> - <@0460cc>): if (bool(x == (0)))
	<asin @0460c0>      : 11 01                      dup.x2 sp(1)
	<asin+2 @0460c2>    : 1a                         load.z64
	<asin+3 @0460c3>    : 87                         ceq.f64
	<asin+4 @0460c4>    : 06 08 00 00                jz <asin+12 @0460cc>
	lib/std/math.ci:422: (4 bytes: <@0460c8> - <@0460cc>): return float64(.result := x);
	<asin+8 @0460c8>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @0460cb>   : 03                         ret
	lib/std/math.ci:425: (1 byte: <@0460cc> - <@0460cd>): negate: bool := false
	<asin+12 @0460cc>   : 19                         load.z32
	lib/std/math.ci:426: (23 bytes: <@0460cd> - <@0460e4>): if (bool(x < (0)))
	<asin+13 @0460cd>   : 11 02                      dup.x2 sp(2)
	<asin+15 @0460cf>   : 1a                         load.z64
	<asin+16 @0460d0>   : 88                         clt.f64
	<asin+17 @0460d1>   : 06 13 00 00                jz <asin+36 @0460e4>
	lib/std/math.ci:427: (10 bytes: <@0460d5> - <@0460df>): bool(negate := true);
	<asin+21 @0460d5>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @0460da>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @0460de>   : 25                         store.i8
	lib/std/math.ci:428: (5 bytes: <@0460df> - <@0460e4>): float64(x := float64(-x));
	<asin+31 @0460df>   : 11 02                      dup.x2 sp(2)
	<asin+33 @0460e1>   : 80                         neg.f64
	<asin+34 @0460e2>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:431: (25 bytes: <@0460e4> - <@0460fd>): if (bool(x > (1)))
	<asin+36 @0460e4>   : 11 02                      dup.x2 sp(2)
	<asin+38 @0460e6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @0460ef>   : 89                         cgt.f64
	<asin+48 @0460f0>   : 06 0d 00 00                jz <asin+61 @0460fd>
	lib/std/math.ci:433: (9 bytes: <@0460f4> - <@0460fd>): return float64(.result := nan);
	<asin+52 @0460f4>   : 1b                         load.z128
	<asin+53 @0460f5>   : 84                         div.f64
	<asin+54 @0460f6>   : 14 06                      set.x2 sp(6)
	<asin+56 @0460f8>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @0460fc>   : 03                         ret
	lib/std/math.ci:436: (19 bytes: <@0460fd> - <@046110>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @0460fd>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @046106>   : 11 04                      dup.x2 sp(4)
	<asin+72 @046108>   : 11 06                      dup.x2 sp(6)
	<asin+74 @04610a>   : 83                         mul.f64
	<asin+75 @04610b>   : 82                         sub.f64
	<asin+76 @04610c>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:437: (60 bytes: <@046110> - <@04614c>): if (bool(x > 0.700000))
	<asin+80 @046110>   : 11 04                      dup.x2 sp(4)
	<asin+82 @046112>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @04611b>   : 89                         cgt.f64
	<asin+92 @04611c>   : 06 26 00 00                jz <asin+130 @046142>
	lib/std/math.ci:438: (30 bytes: <@046120> - <@04613e>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @046120>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @046129>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @046132>  : 84                         div.f64
	<asin+115 @046133>  : 11 02                      dup.x2 sp(2)
	<asin+117 @046135>  : 11 08                      dup.x2 sp(8)
	<asin+119 @046137>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @04613b>  : 82                         sub.f64
	<asin+124 @04613c>  : 14 02                      set.x2 sp(2)
	<asin+126 @04613e>  : 04 0e 00 00                jmp <asin+140 @04614c>
	lib/std/math.ci:441: (10 bytes: <@046142> - <@04614c>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @046142>  : 11 04                      dup.x2 sp(4)
	<asin+132 @046144>  : 11 02                      dup.x2 sp(2)
	<asin+134 @046146>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @04614a>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:444: (19 bytes: <@04614c> - <@04615f>): if (negate)
	<asin+140 @04614c>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @046150>  : 20                         load.i8
	<asin+145 @046151>  : 06 0e 00 00                jz <asin+159 @04615f>
	lib/std/math.ci:445: (10 bytes: <@046155> - <@04615f>): return float64(.result := float64(-result));
	<asin+149 @046155>  : 11 00                      dup.x2 sp(0)
	<asin+151 @046157>  : 80                         neg.f64
	<asin+152 @046158>  : 14 08                      set.x2 sp(8)
	<asin+154 @04615a>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @04615e>  : 03                         ret
	lib/std/math.ci:447: (7 bytes: <@04615f> - <@046166>): return float64(.result := result);
	<asin+159 @04615f>  : 14 06                      set.x2 sp(6)
	<asin+161 @046161>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @046165>  : 03                         ret
.references:
	test/stdc/test.math.ci:65: referenced as `asin`
	lib/std/math.ci:454: referenced as `asin`
	lib/std/math.ci:419: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:454'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: (float64(float64(pi / (2)) - asin(x)))
.references:
	test/stdc/test.math.ci:66: referenced as `acos`
	lib/std/math.ci:454: defined as `acos(x: float64): float64`
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'deg2rad'
.file: 'lib/std/math.ci:477'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * pi) / (180)))
.references:
	lib/std/math.ci:477: defined as `deg2rad(x: float64): float64`
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rad2deg'
.file: 'lib/std/math.ci:478'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * (180)) / pi))
.references:
	lib/std/math.ci:478: defined as `rad2deg(x: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@016630>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:142: referenced as `Complex`
	lib/std/math.Complex.ci:141: referenced as `Complex`
	lib/std/math.Complex.ci:140: referenced as `Complex`
	lib/std/math.Complex.ci:138: referenced as `Complex`
	lib/std/math.Complex.ci:137: referenced as `Complex`
	lib/std/math.Complex.ci:136: referenced as `Complex`
	lib/std/math.Complex.ci:135: referenced as `Complex`
	lib/std/math.Complex.ci:133: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:90: referenced as `Complex`
	lib/std/math.Complex.ci:89: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: referenced as `Complex`
	lib/std/math.Complex.ci:20: referenced as `Complex`
	lib/std/math.Complex.ci:3: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
.references:
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:113: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:110: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:101: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:90: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:82: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:79: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:75: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:72: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:70: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:63: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:60: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:56: referenced as `re`
	lib/std/math.Complex.ci:55: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:52: referenced as `re`
	lib/std/math.Complex.ci:27: referenced as `re`
	lib/std/math.Complex.ci:22: referenced as `re`
	lib/std/math.Complex.ci:4: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
.references:
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:114: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:110: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:101: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:90: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:81: referenced as `im`
	lib/std/math.Complex.ci:79: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:74: referenced as `im`
	lib/std/math.Complex.ci:72: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:70: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:63: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:60: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:56: referenced as `im`
	lib/std/math.Complex.ci:55: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:52: referenced as `im`
	lib/std/math.Complex.ci:28: referenced as `im`
	lib/std/math.Complex.ci:5: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@046168>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@046168> - <@04616f>)
	lib/std/math.Complex.ci:21: (7 bytes: <@046168> - <@04616f>): return void(.result := {...});
	<Complex @046168>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@04616b> - <@04616e>): void(.result.im := (0))
	<Complex+3 @04616b>    : 1a                         load.z64
	<Complex+4 @04616c>    : 14 07                      set.x2 sp(7)
	<Complex+6 @04616e>    : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:20: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@046170>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@046170> - <@046177>)
	lib/std/math.Complex.ci:26: (7 bytes: <@046170> - <@046177>): return void(.result := {...});
	<Complex @046170>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:28: (3 bytes: <@046173> - <@046176>): void(.result.im := im);
	<Complex+3 @046173>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @046176>    : 03                         ret
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(-a.re), float64(-a.im)))
.references:
	lib/vec/vec4f.ci:56: referenced as `neg`
	lib/std/math.Complex.ci:136: referenced as `neg`
	lib/std/math.Complex.ci:135: referenced as `neg`
	lib/std/math.Complex.ci:52: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `add`
	lib/std/math.Complex.ci:54: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re + b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `add`
	lib/std/math.Complex.ci:137: referenced as `add`
	lib/std/math.Complex.ci:55: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a + b.re), b.im))
.references:
	lib/std/math.Complex.ci:56: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.references:
	lib/std/math.Complex.ci:135: referenced as `sub`
	lib/std/math.Complex.ci:58: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re - b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `sub`
	lib/std/math.Complex.ci:137: referenced as `sub`
	lib/std/math.Complex.ci:59: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a - b.re), b.im))
.references:
	lib/std/math.Complex.ci:60: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.references:
	lib/std/math.Complex.ci:62: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.references:
	lib/std/math.Complex.ci:63: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.references:
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:64: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@046178>
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@046178> - <@0461f3>)
	lib/std/math.Complex.ci:70: (79 bytes: <@046178> - <@0461c7>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @046178>      : 1a                         load.z64
	<div+1 @046179>    : 11 03                      dup.x2 sp(3)
	<div+3 @04617b>    : 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<div+8 @046180>    : 02                         call
	<div+9 @046181>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @046185>   : 1a                         load.z64
	<div+14 @046186>   : 11 07                      dup.x2 sp(7)
	<div+16 @046188>   : 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<div+21 @04618d>   : 02                         call
	<div+22 @04618e>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @046192>   : 88                         clt.f64
	<div+27 @046193>   : 05 34 00 00                jnz <div+79 @0461c7>
	lib/std/math.Complex.ci:71: (5 bytes: <@046197> - <@04619c>): r: float64 := float64(b.im / b.re)
	<div+31 @046197>   : 11 03                      dup.x2 sp(3)
	<div+33 @046199>   : 11 03                      dup.x2 sp(3)
	<div+35 @04619b>   : 84                         div.f64
	lib/std/math.Complex.ci:72: (8 bytes: <@04619c> - <@0461a4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @04619c>   : 11 03                      dup.x2 sp(3)
	<div+38 @04619e>   : 11 02                      dup.x2 sp(2)
	<div+40 @0461a0>   : 11 09                      dup.x2 sp(9)
	<div+42 @0461a2>   : 83                         mul.f64
	<div+43 @0461a3>   : 81                         add.f64
	lib/std/math.Complex.ci:73: (31 bytes: <@0461a4> - <@0461c3>): return void(.result := {...});
	<div+44 @0461a4>   : 11 09                      dup.x2 sp(9)
	<div+46 @0461a6>   : 11 04                      dup.x2 sp(4)
	<div+48 @0461a8>   : 11 0f                      dup.x2 sp(15)
	<div+50 @0461aa>   : 83                         mul.f64
	<div+51 @0461ab>   : 81                         add.f64
	<div+52 @0461ac>   : 11 02                      dup.x2 sp(2)
	<div+54 @0461ae>   : 84                         div.f64
	<div+55 @0461af>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes: <@0461b1> - <@0461be>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @0461b1>   : 11 0b                      dup.x2 sp(11)
	<div+59 @0461b3>   : 11 04                      dup.x2 sp(4)
	<div+61 @0461b5>   : 11 0d                      dup.x2 sp(13)
	<div+63 @0461b7>   : 83                         mul.f64
	<div+64 @0461b8>   : 82                         sub.f64
	<div+65 @0461b9>   : 11 02                      dup.x2 sp(2)
	<div+67 @0461bb>   : 84                         div.f64
	<div+68 @0461bc>   : 14 11                      set.x2 sp(17)
	<div+70 @0461be>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @0461c2>   : 03                         ret
	<div+75 @0461c3>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes: <@0461c7> - <@0461cc>): r: float64 := float64(b.re / b.im)
	<div+79 @0461c7>   : 11 01                      dup.x2 sp(1)
	<div+81 @0461c9>   : 11 05                      dup.x2 sp(5)
	<div+83 @0461cb>   : 84                         div.f64
	lib/std/math.Complex.ci:79: (8 bytes: <@0461cc> - <@0461d4>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @0461cc>   : 11 05                      dup.x2 sp(5)
	<div+86 @0461ce>   : 11 02                      dup.x2 sp(2)
	<div+88 @0461d0>   : 11 07                      dup.x2 sp(7)
	<div+90 @0461d2>   : 83                         mul.f64
	<div+91 @0461d3>   : 81                         add.f64
	lib/std/math.Complex.ci:80: (31 bytes: <@0461d4> - <@0461f3>): return void(.result := {...});
	<div+92 @0461d4>   : 11 09                      dup.x2 sp(9)
	<div+94 @0461d6>   : 11 04                      dup.x2 sp(4)
	<div+96 @0461d8>   : 83                         mul.f64
	<div+97 @0461d9>   : 11 0d                      dup.x2 sp(13)
	<div+99 @0461db>   : 81                         add.f64
	<div+100 @0461dc>  : 11 02                      dup.x2 sp(2)
	<div+102 @0461de>  : 84                         div.f64
	<div+103 @0461df>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes: <@0461e1> - <@0461ee>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @0461e1>  : 11 0b                      dup.x2 sp(11)
	<div+107 @0461e3>  : 11 04                      dup.x2 sp(4)
	<div+109 @0461e5>  : 83                         mul.f64
	<div+110 @0461e6>  : 11 0b                      dup.x2 sp(11)
	<div+112 @0461e8>  : 82                         sub.f64
	<div+113 @0461e9>  : 11 02                      dup.x2 sp(2)
	<div+115 @0461eb>  : 84                         div.f64
	<div+116 @0461ec>  : 14 11                      set.x2 sp(17)
	<div+118 @0461ee>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @0461f2>  : 03                         ret
.references:
	lib/std/math.Complex.ci:138: referenced as `div`
	lib/std/math.Complex.ci:137: referenced as `div`
	lib/std/math.Complex.ci:133: referenced as `div`
	lib/std/math.Complex.ci:132: referenced as `div`
	lib/std/math.Complex.ci:87: referenced as `div`
	lib/std/math.Complex.ci:86: referenced as `div`
	lib/std/math.Complex.ci:66: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: div(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:136: referenced as `div`
	lib/std/math.Complex.ci:135: referenced as `div`
	lib/std/math.Complex.ci:86: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.value: div(void(Complex(a), b))
.references:
	lib/std/math.Complex.ci:87: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.references:
	lib/std/math.Complex.ci:146: referenced as `abs`
	lib/std/math.Complex.ci:108: referenced as `abs`
	lib/std/math.Complex.ci:105: referenced as `abs`
	lib/std/math.Complex.ci:89: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.atan2(void(a.re, a.im))
.references:
	lib/std/math.Complex.ci:146: referenced as `arg`
	lib/std/math.Complex.ci:109: referenced as `arg`
	lib/std/math.Complex.ci:105: referenced as `arg`
	lib/std/math.Complex.ci:90: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@0461f8>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@0461f8> - <@046217>)
	lib/std/math.Complex.ci:94: (11 bytes: <@0461f8> - <@046203>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @0461f8>      : 11 01                      dup.x2 sp(1)
	<inv+2 @0461fa>    : 11 03                      dup.x2 sp(3)
	<inv+4 @0461fc>    : 83                         mul.f64
	<inv+5 @0461fd>    : 11 05                      dup.x2 sp(5)
	<inv+7 @0461ff>    : 11 07                      dup.x2 sp(7)
	<inv+9 @046201>    : 83                         mul.f64
	<inv+10 @046202>   : 81                         add.f64
	lib/std/math.Complex.ci:95: (20 bytes: <@046203> - <@046217>): return void(.result := {...});
	<inv+11 @046203>   : 11 03                      dup.x2 sp(3)
	<inv+13 @046205>   : 11 02                      dup.x2 sp(2)
	<inv+15 @046207>   : 84                         div.f64
	<inv+16 @046208>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes: <@04620a> - <@046212>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @04620a>   : 11 05                      dup.x2 sp(5)
	<inv+20 @04620c>   : 80                         neg.f64
	<inv+21 @04620d>   : 11 02                      dup.x2 sp(2)
	<inv+23 @04620f>   : 84                         div.f64
	<inv+24 @046210>   : 14 0b                      set.x2 sp(11)
	<inv+26 @046212>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @046216>   : 03                         ret
.references:
	lib/std/math.Complex.ci:143: referenced as `inv`
	lib/std/math.Complex.ci:142: referenced as `inv`
	lib/std/math.Complex.ci:141: referenced as `inv`
	lib/std/math.Complex.ci:140: referenced as `inv`
	lib/std/math.Complex.ci:93: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(a.re, float64(-a.im)))
.references:
	lib/std/math.Complex.ci:101: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.references:
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:103: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64.log(abs(a)), arg(a)))
.references:
	lib/std/math.Complex.ci:105: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@046218>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@046218> - <@04627c>)
	lib/std/math.Complex.ci:108: (23 bytes: <@046218> - <@04622f>): r: float64 := abs(a)
	<pow @046218>      : 12 05                      dup.x4 sp(5)
	<pow+2 @04621a>    : 11 00                      dup.x2 sp(0)
	<pow+4 @04621c>    : 11 02                      dup.x2 sp(2)
	<pow+6 @04621e>    : 83                         mul.f64
	<pow+7 @04621f>    : 11 04                      dup.x2 sp(4)
	<pow+9 @046221>    : 11 06                      dup.x2 sp(6)
	<pow+11 @046223>   : 83                         mul.f64
	<pow+12 @046224>   : 81                         add.f64
	<pow+13 @046225>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @046229>   : 14 04                      set.x2 sp(4)
	<pow+19 @04622b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes: <@04622f> - <@04623f>): t: float64 := arg(a)
	<pow+23 @04622f>   : 12 07                      dup.x4 sp(7)
	<pow+25 @046231>   : 11 00                      dup.x2 sp(0)
	<pow+27 @046233>   : 11 04                      dup.x2 sp(4)
	<pow+29 @046235>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @046239>   : 14 04                      set.x2 sp(4)
	<pow+35 @04623b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes: <@04623f> - <@04624e>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @04623f>   : 11 05                      dup.x2 sp(5)
	<pow+41 @046241>   : 11 02                      dup.x2 sp(2)
	<pow+43 @046243>   : 83                         mul.f64
	<pow+44 @046244>   : 11 09                      dup.x2 sp(9)
	<pow+46 @046246>   : 11 06                      dup.x2 sp(6)
	<pow+48 @046248>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @04624c>   : 83                         mul.f64
	<pow+53 @04624d>   : 81                         add.f64
	lib/std/math.Complex.ci:111: (19 bytes: <@04624e> - <@046261>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @04624e>   : 11 04                      dup.x2 sp(4)
	<pow+56 @046250>   : 11 09                      dup.x2 sp(9)
	<pow+58 @046252>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @046256>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @046258>   : 80                         neg.f64
	<pow+65 @046259>   : 11 06                      dup.x2 sp(6)
	<pow+67 @04625b>   : 83                         mul.f64
	<pow+68 @04625c>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @046260>   : 83                         mul.f64
	lib/std/math.Complex.ci:112: (27 bytes: <@046261> - <@04627c>): return void(.result := {...});
	<pow+73 @046261>   : 11 00                      dup.x2 sp(0)
	<pow+75 @046263>   : 11 04                      dup.x2 sp(4)
	<pow+77 @046265>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @046269>   : 83                         mul.f64
	<pow+82 @04626a>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes: <@04626c> - <@046277>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @04626c>   : 11 00                      dup.x2 sp(0)
	<pow+86 @04626e>   : 11 04                      dup.x2 sp(4)
	<pow+88 @046270>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @046274>   : 83                         mul.f64
	<pow+93 @046275>   : 14 15                      set.x2 sp(21)
	<pow+95 @046277>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @04627b>   : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `pow`
	lib/std/math.Complex.ci:107: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: pow(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:117: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:141: referenced as `sin`
	lib/std/math.Complex.ci:133: referenced as `sin`
	lib/std/math.Complex.ci:132: referenced as `sin`
	lib/std/math.Complex.ci:119: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:140: referenced as `cos`
	lib/std/math.Complex.ci:133: referenced as `cos`
	lib/std/math.Complex.ci:132: referenced as `cos`
	lib/std/math.Complex.ci:120: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sin(a), cos(a)))
.references:
	lib/std/math.Complex.ci:132: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(cos(a), sin(a)))
.references:
	lib/std/math.Complex.ci:133: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:143: referenced as `sinh`
	lib/std/math.Complex.ci:135: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:142: referenced as `cosh`
	lib/std/math.Complex.ci:136: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:137: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:138: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cos(a))
.references:
	lib/std/math.Complex.ci:140: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sin(a))
.references:
	lib/std/math.Complex.ci:141: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cosh(a))
.references:
	lib/std/math.Complex.ci:142: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sinh(a))
.references:
	lib/std/math.Complex.ci:143: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.references:
	lib/std/math.Complex.ci:145: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(abs(x), arg(x)))
.references:
	lib/std/math.Complex.ci:146: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@046280>
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@046280> - <@0462a6>)
	lib/std/string.ci:4: (16 bytes: <@046280> - <@046290>): if (bool((str) == null))
	<length @046280>      : 10 01                      dup.x1 sp(1)
	<length+2 @046282>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @046287>    : 57                         ceq.i32
	<length+8 @046288>    : 06 08 00 00                jz <length+16 @046290>
	lib/std/string.ci:5: (4 bytes: <@04628c> - <@046290>): return int32(.result := 0);
	<length+12 @04628c>   : 19                         load.z32
	<length+13 @04628d>   : 13 03                      set.x1 sp(3)
	<length+15 @04628f>   : 03                         ret
	lib/std/string.ci:7: (1 byte: <@046290> - <@046291>): result: int32 := 0
	<length+16 @046290>   : 19                         load.z32
	lib/std/string.ci:8: (18 bytes: <@046291> - <@0462a3>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @046291>   : 04 08 00 00                jmp <length+25 @046299>
	lib/std/string.ci:8: (4 bytes: <@046295> - <@046299>): int32(result := int32(result + 1))
	<length+21 @046295>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:8: (10 bytes: <@046299> - <@0462a3>): str[result]
	<length+25 @046299>   : 10 02                      dup.x1 sp(2)
	<length+27 @04629b>   : 10 01                      dup.x1 sp(1)
	<length+29 @04629d>   : 51                         add.i32
	<length+30 @04629e>   : 20                         load.i8
	<length+31 @04629f>   : 05 f6 ff ff                jnz <length+21 @046295>
	lib/std/string.ci:10: (3 bytes: <@0462a3> - <@0462a6>): return int32(.result := result);
	<length+35 @0462a3>   : 13 03                      set.x1 sp(3)
	<length+37 @0462a5>   : 03                         ret
.references:
	lib/std/string.ci:46: referenced as `length`
	lib/std/string.ci:45: referenced as `length`
	lib/std/string.ci:3: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@0462a8>
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@0462a8> - <@0462da>)
	lib/std/string.ci:15: (42 bytes: <@0462a8> - <@0462d2>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @0462a8>      : 19                         load.z32
	<indexOf+1 @0462a9>    : 04 1b 00 00                jmp <indexOf+28 @0462c4>
	lib/std/string.ci:16: (19 bytes: <@0462ad> - <@0462c0>): if (bool(str[i] == chr))
	<indexOf+5 @0462ad>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @0462af>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @0462b1>    : 51                         add.i32
	<indexOf+10 @0462b2>   : 20                         load.i8
	<indexOf+11 @0462b3>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @0462b7>   : 20                         load.i8
	<indexOf+16 @0462b8>   : 57                         ceq.i32
	<indexOf+17 @0462b9>   : 06 07 00 00                jz <indexOf+24 @0462c0>
	lib/std/string.ci:17: (3 bytes: <@0462bd> - <@0462c0>): return int32(.result := i);
	<indexOf+21 @0462bd>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @0462bf>   : 03                         ret
	lib/std/string.ci:15: (4 bytes: <@0462c0> - <@0462c4>): int32(i := int32(i + 1))
	<indexOf+24 @0462c0>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:15: (10 bytes: <@0462c4> - <@0462ce>): str[i]
	<indexOf+28 @0462c4>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @0462c6>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @0462c8>   : 51                         add.i32
	<indexOf+33 @0462c9>   : 20                         load.i8
	<indexOf+34 @0462ca>   : 05 e3 ff ff                jnz <indexOf+5 @0462ad>
	<indexOf+38 @0462ce>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:20: (8 bytes: <@0462d2> - <@0462da>): return int32(.result := int32(-1));
	<indexOf+42 @0462d2>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @0462d7>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @0462d9>   : 03                         ret
.references:
	lib/std/string.ci:92: referenced as `indexOf`
	lib/std/string.ci:14: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@0462e0>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@0462e0> - <@046312>)
	lib/std/string.ci:25: (5 bytes: <@0462e0> - <@0462e5>): result: int32 := int32(-1)
	<lastIndexOf @0462e0>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:26: (42 bytes: <@0462e5> - <@04630f>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @0462e5>    : 19                         load.z32
	<lastIndexOf+6 @0462e6>    : 04 1b 00 00                jmp <lastIndexOf+33 @046301>
	lib/std/string.ci:27: (19 bytes: <@0462ea> - <@0462fd>): if (bool(str[i] == chr))
	<lastIndexOf+10 @0462ea>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @0462ec>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @0462ee>   : 51                         add.i32
	<lastIndexOf+15 @0462ef>   : 20                         load.i8
	<lastIndexOf+16 @0462f0>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @0462f4>   : 20                         load.i8
	<lastIndexOf+21 @0462f5>   : 57                         ceq.i32
	<lastIndexOf+22 @0462f6>   : 06 07 00 00                jz <lastIndexOf+29 @0462fd>
	lib/std/string.ci:28: (3 bytes: <@0462fa> - <@0462fd>): int32(result := i);
	<lastIndexOf+26 @0462fa>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:26: (4 bytes: <@0462fd> - <@046301>): int32(i := int32(i + 1))
	<lastIndexOf+29 @0462fd>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:26: (10 bytes: <@046301> - <@04630b>): str[i]
	<lastIndexOf+33 @046301>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @046303>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @046305>   : 51                         add.i32
	<lastIndexOf+38 @046306>   : 20                         load.i8
	<lastIndexOf+39 @046307>   : 05 e3 ff ff                jnz <lastIndexOf+10 @0462ea>
	<lastIndexOf+43 @04630b>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:31: (3 bytes: <@04630f> - <@046312>): return int32(.result := result);
	<lastIndexOf+47 @04630f>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @046311>   : 03                         ret
.references:
	lib/std/string.ci:24: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@046318>
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@046318> - <@046361>)
	lib/std/string.ci:36: (62 bytes: <@046318> - <@046356>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @046318>      : 19                         load.z32
	<startsWith+1 @046319>    : 04 2d 00 00                jmp <startsWith+46 @046346>
	lib/std/string.ci:37: (37 bytes: <@04631d> - <@046342>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @04631d>    : 19                         load.z32
	<startsWith+6 @04631e>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @046320>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @046322>   : 51                         add.i32
	<startsWith+11 @046323>   : 20                         load.i8
	<startsWith+12 @046324>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @046326>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @046328>   : 51                         add.i32
	<startsWith+17 @046329>   : 20                         load.i8
	<startsWith+18 @04632a>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @04632c>   : 02                         call
	<startsWith+21 @04632d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @046331>   : 19                         load.z32
	<startsWith+26 @046332>   : 57                         ceq.i32
	<startsWith+27 @046333>   : 05 0f 00 00                jnz <startsWith+42 @046342>
	lib/std/string.ci:38: (11 bytes: <@046337> - <@046342>): return bool(.result := false);
	<startsWith+31 @046337>   : 19                         load.z32
	<startsWith+32 @046338>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @04633c>   : 25                         store.i8
	<startsWith+37 @04633d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @046341>   : 03                         ret
	lib/std/string.ci:36: (4 bytes: <@046342> - <@046346>): int32(i := int32(i + 1))
	<startsWith+42 @046342>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:36: (12 bytes: <@046346> - <@046352>): bool((with[i]) != 0)
	<startsWith+46 @046346>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @046348>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @04634a>   : 51                         add.i32
	<startsWith+51 @04634b>   : 20                         load.i8
	<startsWith+52 @04634c>   : 19                         load.z32
	<startsWith+53 @04634d>   : 57                         ceq.i32
	<startsWith+54 @04634e>   : 06 cf ff ff                jz <startsWith+5 @04631d>
	<startsWith+58 @046352>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:41: (11 bytes: <@046356> - <@046361>): return bool(.result := true);
	<startsWith+62 @046356>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @04635b>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @04635f>   : 25                         store.i8
	<startsWith+72 @046360>   : 03                         ret
.references:
	lib/std/string.ci:88: referenced as `startsWith`
	lib/std/string.ci:35: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@046368>
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@046368> - <@0463e6>)
	lib/std/string.ci:45: (13 bytes: <@046368> - <@046375>): withLen: int32 := length(with)
	<endsWith @046368>      : 19                         load.z32
	<endsWith+1 @046369>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @04636b>    : 1f 80 62 04 00             load.ref <@046280> ;length(str: char[*]): int32
	<endsWith+8 @046370>    : 02                         call
	<endsWith+9 @046371>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:46: (13 bytes: <@046375> - <@046382>): strLen: int32 := length(str)
	<endsWith+13 @046375>   : 19                         load.z32
	<endsWith+14 @046376>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @046378>   : 1f 80 62 04 00             load.ref <@046280> ;length(str: char[*]): int32
	<endsWith+21 @04637d>   : 02                         call
	<endsWith+22 @04637e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:47: (20 bytes: <@046382> - <@046396>): if (bool(strLen < withLen))
	<endsWith+26 @046382>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @046384>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @046386>   : 58                         clt.i32
	<endsWith+31 @046387>   : 06 0f 00 00                jz <endsWith+46 @046396>
	lib/std/string.ci:48: (11 bytes: <@04638b> - <@046396>): return bool(.result := false);
	<endsWith+35 @04638b>   : 19                         load.z32
	<endsWith+36 @04638c>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @046390>   : 25                         store.i8
	<endsWith+41 @046391>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @046395>   : 03                         ret
	lib/std/string.ci:50: (65 bytes: <@046396> - <@0463d7>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @046396>   : 19                         load.z32
	<endsWith+47 @046397>   : 04 33 00 00                jmp <endsWith+98 @0463ca>
	lib/std/string.ci:51: (43 bytes: <@04639b> - <@0463c6>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @04639b>   : 19                         load.z32
	<endsWith+52 @04639c>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @04639e>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @0463a0>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @0463a2>   : 52                         sub.i32
	<endsWith+59 @0463a3>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @0463a5>   : 51                         add.i32
	<endsWith+62 @0463a6>   : 51                         add.i32
	<endsWith+63 @0463a7>   : 20                         load.i8
	<endsWith+64 @0463a8>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @0463aa>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @0463ac>   : 51                         add.i32
	<endsWith+69 @0463ad>   : 20                         load.i8
	<endsWith+70 @0463ae>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @0463b0>   : 02                         call
	<endsWith+73 @0463b1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @0463b5>   : 19                         load.z32
	<endsWith+78 @0463b6>   : 57                         ceq.i32
	<endsWith+79 @0463b7>   : 05 0f 00 00                jnz <endsWith+94 @0463c6>
	lib/std/string.ci:52: (11 bytes: <@0463bb> - <@0463c6>): return bool(.result := false);
	<endsWith+83 @0463bb>   : 19                         load.z32
	<endsWith+84 @0463bc>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @0463c0>   : 25                         store.i8
	<endsWith+89 @0463c1>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @0463c5>   : 03                         ret
	lib/std/string.ci:50: (4 bytes: <@0463c6> - <@0463ca>): int32(i := int32(i + 1))
	<endsWith+94 @0463c6>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:50: (9 bytes: <@0463ca> - <@0463d3>): bool(i < withLen)
	<endsWith+98 @0463ca>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @0463cc>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @0463ce>  : 58                         clt.i32
	<endsWith+103 @0463cf>  : 05 cc ff ff                jnz <endsWith+51 @04639b>
	<endsWith+107 @0463d3>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:55: (15 bytes: <@0463d7> - <@0463e6>): return bool(.result := true);
	<endsWith+111 @0463d7>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @0463dc>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @0463e0>  : 25                         store.i8
	<endsWith+121 @0463e1>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @0463e5>  : 03                         ret
.references:
	lib/std/string.ci:89: referenced as `endsWith`
	lib/std/string.ci:44: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@0463e8>
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@0463e8> - <@046427>)
	lib/std/string.ci:59: (1 byte: <@0463e8> - <@0463e9>): result: int32 := 0
	<compare @0463e8>      : 19                         load.z32
	lib/std/string.ci:60: (59 bytes: <@0463e9> - <@046424>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @0463e9>    : 19                         load.z32
	<compare+2 @0463ea>    : 04 2e 00 00                jmp <compare+48 @046418>
	lib/std/string.ci:61: (22 bytes: <@0463ee> - <@046404>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @0463ee>    : 19                         load.z32
	<compare+7 @0463ef>    : 10 06                      dup.x1 sp(6)
	<compare+9 @0463f1>    : 10 02                      dup.x1 sp(2)
	<compare+11 @0463f3>   : 51                         add.i32
	<compare+12 @0463f4>   : 20                         load.i8
	<compare+13 @0463f5>   : 10 06                      dup.x1 sp(6)
	<compare+15 @0463f7>   : 10 03                      dup.x1 sp(3)
	<compare+17 @0463f9>   : 51                         add.i32
	<compare+18 @0463fa>   : 20                         load.i8
	<compare+19 @0463fb>   : 10 06                      dup.x1 sp(6)
	<compare+21 @0463fd>   : 02                         call
	<compare+22 @0463fe>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @046402>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes: <@046404> - <@046414>): if (bool((str[i]) == 0))
	<compare+28 @046404>   : 10 05                      dup.x1 sp(5)
	<compare+30 @046406>   : 10 01                      dup.x1 sp(1)
	<compare+32 @046408>   : 51                         add.i32
	<compare+33 @046409>   : 20                         load.i8
	<compare+34 @04640a>   : 19                         load.z32
	<compare+35 @04640b>   : 57                         ceq.i32
	<compare+36 @04640c>   : 06 08 00 00                jz <compare+44 @046414>
	lib/std/string.ci:63: (4 bytes: <@046410> - <@046414>): break;
	<compare+40 @046410>   : 04 10 00 00                jmp <compare+56 @046420>
	lib/std/string.ci:60: (4 bytes: <@046414> - <@046418>): int32(i := int32(i + 1))
	<compare+44 @046414>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:60: (8 bytes: <@046418> - <@046420>): bool(result == 0)
	<compare+48 @046418>   : 10 01                      dup.x1 sp(1)
	<compare+50 @04641a>   : 19                         load.z32
	<compare+51 @04641b>   : 57                         ceq.i32
	<compare+52 @04641c>   : 05 d2 ff ff                jnz <compare+6 @0463ee>
	<compare+56 @046420>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:66: (3 bytes: <@046424> - <@046427>): return int32(.result := result);
	<compare+60 @046424>   : 13 05                      set.x1 sp(5)
	<compare+62 @046426>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `compare`
	lib/std/string.ci:58: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@046470>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@046470> - <@046494>)
	lib/std/string.ci:81: (36 bytes: <@046470> - <@046494>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @046470>      : 19                         load.z32
	<ignCaseCmp+1 @046471>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @046475>    : 20                         load.i8
	<ignCaseCmp+6 @046476>    : 1f 28 64 04 00             load.ref <@046428> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @04647b>   : 02                         call
	<ignCaseCmp+12 @04647c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @046480>   : 19                         load.z32
	<ignCaseCmp+17 @046481>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @046485>   : 20                         load.i8
	<ignCaseCmp+22 @046486>   : 1f 28 64 04 00             load.ref <@046428> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @04648b>   : 02                         call
	<ignCaseCmp+28 @04648c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @046490>   : 52                         sub.i32
	<ignCaseCmp+33 @046491>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @046493>   : 03                         ret
.references:
	lib/std/string.ci:70: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@046498>
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@046498> - <@0464a6>)
	lib/std/string.ci:85: (14 bytes: <@046498> - <@0464a6>): return char(.result := char(chr - with));
	<caseCmp @046498>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @04649c>    : 20                         load.i8
	<caseCmp+5 @04649d>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @0464a1>    : 20                         load.i8
	<caseCmp+10 @0464a2>   : 52                         sub.i32
	<caseCmp+11 @0464a3>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @0464a5>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `caseCmp`
	lib/std/string.ci:89: referenced as `caseCmp`
	lib/std/string.ci:88: referenced as `caseCmp`
	lib/std/string.ci:84: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:88: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:89: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:90: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.value: bool(indexOf(void(str, chr)) >= 0)
.references:
	lib/std/string.ci:158: referenced as `contains`
	lib/std/string.ci:92: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01df80>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.references:
	lib/std/string.ci:206: referenced as `FormatFlags`
	lib/std/string.ci:196: referenced as `FormatFlags`
	lib/std/string.ci:192: referenced as `FormatFlags`
	lib/std/string.ci:129: referenced as `FormatFlags`
	lib/std/string.ci:106: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
.references:
	lib/std/string.ci:136: referenced as `radix`
	lib/std/string.ci:107: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:150: referenced as `padChr`
	lib/std/string.ci:108: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:148: referenced as `padLen`
	lib/std/string.ci:109: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:110: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@0464a8>
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@0464a8> - <@0464fc>)
	lib/std/string.ci:114: (56 bytes: <@0464a8> - <@0464e0>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @0464a8>      : 19                         load.z32
	<append+1 @0464a9>    : 04 29 00 00                jmp <append+42 @0464d2>
	lib/std/string.ci:115: (13 bytes: <@0464ad> - <@0464ba>): if (bool(pos >= (output.length)))
	<append+5 @0464ad>    : 10 03                      dup.x1 sp(3)
	<append+7 @0464af>    : 10 06                      dup.x1 sp(6)
	<append+9 @0464b1>    : 58                         clt.i32
	<append+10 @0464b2>   : 05 08 00 00                jnz <append+18 @0464ba>
	lib/std/string.ci:116: (4 bytes: <@0464b6> - <@0464ba>): break;
	<append+14 @0464b6>   : 04 26 00 00                jmp <append+52 @0464dc>
	lib/std/string.ci:118: (12 bytes: <@0464ba> - <@0464c6>): char(output[pos] := value[i]);
	<append+18 @0464ba>   : 10 02                      dup.x1 sp(2)
	<append+20 @0464bc>   : 10 01                      dup.x1 sp(1)
	<append+22 @0464be>   : 51                         add.i32
	<append+23 @0464bf>   : 20                         load.i8
	<append+24 @0464c0>   : 10 05                      dup.x1 sp(5)
	<append+26 @0464c2>   : 10 05                      dup.x1 sp(5)
	<append+28 @0464c4>   : 51                         add.i32
	<append+29 @0464c5>   : 25                         store.i8
	lib/std/string.ci:119: (8 bytes: <@0464c6> - <@0464ce>): int32(pos := int32(pos + 1));
	<append+30 @0464c6>   : 10 03                      dup.x1 sp(3)
	<append+32 @0464c8>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @0464cc>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes: <@0464ce> - <@0464d2>): int32(i := int32(i + 1))
	<append+38 @0464ce>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:114: (10 bytes: <@0464d2> - <@0464dc>): value[i]
	<append+42 @0464d2>   : 10 02                      dup.x1 sp(2)
	<append+44 @0464d4>   : 10 01                      dup.x1 sp(1)
	<append+46 @0464d6>   : 51                         add.i32
	<append+47 @0464d7>   : 20                         load.i8
	<append+48 @0464d8>   : 05 d5 ff ff                jnz <append+5 @0464ad>
	<append+52 @0464dc>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:122: (17 bytes: <@0464e0> - <@0464f1>): if (bool(pos >= (output.length)))
	<append+56 @0464e0>   : 10 02                      dup.x1 sp(2)
	<append+58 @0464e2>   : 10 05                      dup.x1 sp(5)
	<append+60 @0464e4>   : 58                         clt.i32
	<append+61 @0464e5>   : 05 0c 00 00                jnz <append+73 @0464f1>
	lib/std/string.ci:123: (8 bytes: <@0464e9> - <@0464f1>): int32(pos := (uint32(output.length - (1))));
	<append+65 @0464e9>   : 10 04                      dup.x1 sp(4)
	<append+67 @0464eb>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @0464ef>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes: <@0464f1> - <@0464f8>): char(output[pos] := (0));
	<append+73 @0464f1>   : 19                         load.z32
	<append+74 @0464f2>   : 10 04                      dup.x1 sp(4)
	<append+76 @0464f4>   : 10 04                      dup.x1 sp(4)
	<append+78 @0464f6>   : 51                         add.i32
	<append+79 @0464f7>   : 25                         store.i8
	lib/std/string.ci:126: (4 bytes: <@0464f8> - <@0464fc>): return int32(.result := pos);
	<append+80 @0464f8>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @0464fb>   : 03                         ret
.references:
	lib/std/string.ci:113: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@046510>
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@046510> - <@0467a1>)
	lib/std/string.ci:133: (1 byte: <@046510> - <@046511>): len: int32 := 0
	<append @046510>      : 19                         load.z32
	lib/std/string.ci:134: (4 bytes: <@046511> - <@046515>): digits: char[80]
	<append+1 @046511>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:136: (3 bytes: <@046515> - <@046518>): radix: int32 := format.radix
	<append+5 @046515>    : 10 16                      dup.x1 sp(22)
	<append+7 @046517>    : 22                         load.i32
	lib/std/string.ci:137: (54 bytes: <@046518> - <@04654e>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @046518>    : 10 00                      dup.x1 sp(0)
	<append+10 @04651a>   : 1c 01 00 00 00             load.c32 1
	<append+15 @04651f>   : 59                         cgt.i32
	<append+16 @046520>   : 06 08 00 00                jz <append+24 @046528>
	<append+20 @046524>   : 04 2a 00 00                jmp <append+62 @04654e>
	<append+24 @046528>   : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+29 @04652d>   : 1c 89 00 00 00             load.c32 137
	<append+34 @046532>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @046537>   : 1c 80 00 00 00             load.c32 128
	<append+44 @04653c>   : 1f 91 b0 01 00             load.ref <@01b091> ;"radix is too small"
	<append+49 @046541>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+54 @046546>   : 0a 18 00 00                load.sp(+24)
	<append+58 @04654a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes: <@04654e> - <@046583>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @04654e>   : 10 00                      dup.x1 sp(0)
	<append+64 @046550>   : 2a 0c 65 04                load.m32 <@04650c> ;append.radixDigits+4
	<append+68 @046554>   : 58                         clt.i32
	<append+69 @046555>   : 06 08 00 00                jz <append+77 @04655d>
	<append+73 @046559>   : 04 2a 00 00                jmp <append+115 @046583>
	<append+77 @04655d>   : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+82 @046562>   : 1c 8a 00 00 00             load.c32 138
	<append+87 @046567>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @04656c>   : 1c 80 00 00 00             load.c32 128
	<append+97 @046571>   : 1f a4 b0 01 00             load.ref <@01b0a4> ;"radix is too big"
	<append+102 @046576>  : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+107 @04657b>  : 0a 18 00 00                load.sp(+24)
	<append+111 @04657f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes: <@046583> - <@0465b1>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @046583>  : 04 26 00 00                jmp <append+153 @0465a9>
	lib/std/string.ci:142: (27 bytes: <@046587> - <@0465a2>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @046587>  : 2a 08 65 04                load.m32 <@046508> ;append.radixDigits
	<append+123 @04658b>  : 10 19                      dup.x1 sp(25)
	<append+125 @04658d>  : 10 02                      dup.x1 sp(2)
	<append+127 @04658f>  : 35                         mod.u32
	<append+128 @046590>  : 51                         add.i32
	<append+129 @046591>  : 20                         load.i8
	<append+130 @046592>  : 0a 08 00 00                load.sp(+8)
	<append+134 @046596>  : 10 17                      dup.x1 sp(23)
	<append+136 @046598>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @04659c>  : 10 00                      dup.x1 sp(0)
	<append+142 @04659e>  : 13 19                      set.x1 sp(25)
	<append+144 @0465a0>  : 51                         add.i32
	<append+145 @0465a1>  : 25                         store.i8
	lib/std/string.ci:141: (7 bytes: <@0465a2> - <@0465a9>): uint32(value := uint32(value / (radix)))
	<append+146 @0465a2>  : 10 18                      dup.x1 sp(24)
	<append+148 @0465a4>  : 10 01                      dup.x1 sp(1)
	<append+150 @0465a6>  : 34                         div.u32
	<append+151 @0465a7>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes: <@0465a9> - <@0465b1>): bool(value > (0))
	<append+153 @0465a9>  : 10 18                      dup.x1 sp(24)
	<append+155 @0465ab>  : 19                         load.z32
	<append+156 @0465ac>  : 39                         cgt.u32
	<append+157 @0465ad>  : 05 da ff ff                jnz <append+119 @046587>
	lib/std/string.ci:144: (29 bytes: <@0465b1> - <@0465ce>): if (bool(len == 0))
	<append+161 @0465b1>  : 10 15                      dup.x1 sp(21)
	<append+163 @0465b3>  : 19                         load.z32
	<append+164 @0465b4>  : 57                         ceq.i32
	<append+165 @0465b5>  : 06 19 00 00                jz <append+190 @0465ce>
	lib/std/string.ci:145: (21 bytes: <@0465b9> - <@0465ce>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @0465b9>  : 1c 30 00 00 00             load.c32 48
	<append+174 @0465be>  : 0a 08 00 00                load.sp(+8)
	<append+178 @0465c2>  : 10 17                      dup.x1 sp(23)
	<append+180 @0465c4>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @0465c8>  : 10 00                      dup.x1 sp(0)
	<append+186 @0465ca>  : 13 19                      set.x1 sp(25)
	<append+188 @0465cc>  : 51                         add.i32
	<append+189 @0465cd>  : 25                         store.i8
	lib/std/string.ci:148: (10 bytes: <@0465ce> - <@0465d8>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @0465ce>  : 10 17                      dup.x1 sp(23)
	<append+192 @0465d0>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @0465d4>  : 22                         load.i32
	<append+197 @0465d5>  : 10 16                      dup.x1 sp(22)
	<append+199 @0465d7>  : 52                         sub.i32
	lib/std/string.ci:150: (7 bytes: <@0465d8> - <@0465df>): padChr: char := format.padChr
	<append+200 @0465d8>  : 10 18                      dup.x1 sp(24)
	<append+202 @0465da>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @0465de>  : 20                         load.i8
	lib/std/string.ci:151: (21 bytes: <@0465df> - <@0465f4>): if (bool(padChr == ''))
	<append+207 @0465df>  : 0a 00 00 00                load.sp(+0)
	<append+211 @0465e3>  : 20                         load.i8
	<append+212 @0465e4>  : 19                         load.z32
	<append+213 @0465e5>  : 57                         ceq.i32
	<append+214 @0465e6>  : 06 0e 00 00                jz <append+228 @0465f4>
	lib/std/string.ci:152: (10 bytes: <@0465ea> - <@0465f4>): char(padChr := ' ');
	<append+218 @0465ea>  : 1c 20 00 00 00             load.c32 32
	<append+223 @0465ef>  : 0a 04 00 00                load.sp(+4)
	<append+227 @0465f3>  : 25                         store.i8
	lib/std/string.ci:156: (207 bytes: <@0465f4> - <@0466c3>): if (bool((sign) != 0))
	<append+228 @0465f4>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @0465f8>  : 20                         load.i8
	<append+233 @0465f9>  : 19                         load.z32
	<append+234 @0465fa>  : 57                         ceq.i32
	<append+235 @0465fb>  : 05 c8 00 00                jnz <append+435 @0466c3>
	lib/std/string.ci:157: (8 bytes: <@0465ff> - <@046607>): int32(maxLen := int32(maxLen - 1));
	<append+239 @0465ff>  : 10 01                      dup.x1 sp(1)
	<append+241 @046601>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @046605>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes: <@046607> - <@04667c>): if (contains(void(whiteSpace, padChr)))
	<append+247 @046607>  : 19                         load.z32
	<append+248 @046608>  : 2a 00 65 04                load.m32 <@046500> ;append.whiteSpace
	<append+252 @04660c>  : 0a 08 00 00                load.sp(+8)
	<append+256 @046610>  : 20                         load.i8
	<append+257 @046611>  : 1f a8 62 04 00             load.ref <@0462a8> ;indexOf(str: char[*], chr: char): int32
	<append+262 @046616>  : 02                         call
	<append+263 @046617>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @04661b>  : 19                         load.z32
	<append+268 @04661c>  : 58                         clt.i32
	<append+269 @04661d>  : 05 5f 00 00                jnz <append+364 @04667c>
	lib/std/string.ci:160: (91 bytes: <@046621> - <@04667c>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @046621>  : 04 53 00 00                jmp <append+356 @046674>
	lib/std/string.ci:161: (52 bytes: <@046625> - <@046659>): assert(bool(pos < (output.length)));
	<append+277 @046625>  : 10 1c                      dup.x1 sp(28)
	<append+279 @046627>  : 10 1f                      dup.x1 sp(31)
	<append+281 @046629>  : 58                         clt.i32
	<append+282 @04662a>  : 06 08 00 00                jz <append+290 @046632>
	<append+286 @04662e>  : 04 2b 00 00                jmp <append+329 @046659>
	<append+290 @046632>  : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+295 @046637>  : 1c a1 00 00 00             load.c32 161
	<append+300 @04663c>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @046641>  : 1c 80 00 00 00             load.c32 128
	<append+310 @046646>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+315 @04664b>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+320 @046650>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @046655>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes: <@046659> - <@046664>): char(output[pos] := padChr);
	<append+329 @046659>  : 0a 00 00 00                load.sp(+0)
	<append+333 @04665d>  : 20                         load.i8
	<append+334 @04665e>  : 10 1e                      dup.x1 sp(30)
	<append+336 @046660>  : 10 1e                      dup.x1 sp(30)
	<append+338 @046662>  : 51                         add.i32
	<append+339 @046663>  : 25                         store.i8
	lib/std/string.ci:163: (8 bytes: <@046664> - <@04666c>): int32(pos := int32(pos + 1));
	<append+340 @046664>  : 10 1c                      dup.x1 sp(28)
	<append+342 @046666>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @04666a>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes: <@04666c> - <@046674>): int32(maxLen := int32(maxLen - 1))
	<append+348 @04666c>  : 10 01                      dup.x1 sp(1)
	<append+350 @04666e>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @046672>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes: <@046674> - <@04667c>): bool(maxLen > 0)
	<append+356 @046674>  : 10 01                      dup.x1 sp(1)
	<append+358 @046676>  : 19                         load.z32
	<append+359 @046677>  : 59                         cgt.i32
	<append+360 @046678>  : 05 ad ff ff                jnz <append+277 @046625>
	lib/std/string.ci:166: (52 bytes: <@04667c> - <@0466b0>): assert(bool(pos < (output.length)));
	<append+364 @04667c>  : 10 1c                      dup.x1 sp(28)
	<append+366 @04667e>  : 10 1f                      dup.x1 sp(31)
	<append+368 @046680>  : 58                         clt.i32
	<append+369 @046681>  : 06 08 00 00                jz <append+377 @046689>
	<append+373 @046685>  : 04 2b 00 00                jmp <append+416 @0466b0>
	<append+377 @046689>  : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+382 @04668e>  : 1c a6 00 00 00             load.c32 166
	<append+387 @046693>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @046698>  : 1c 80 00 00 00             load.c32 128
	<append+397 @04669d>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+402 @0466a2>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+407 @0466a7>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @0466ac>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes: <@0466b0> - <@0466bb>): char(output[pos] := sign);
	<append+416 @0466b0>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @0466b4>  : 20                         load.i8
	<append+421 @0466b5>  : 10 1e                      dup.x1 sp(30)
	<append+423 @0466b7>  : 10 1e                      dup.x1 sp(30)
	<append+425 @0466b9>  : 51                         add.i32
	<append+426 @0466ba>  : 25                         store.i8
	lib/std/string.ci:168: (8 bytes: <@0466bb> - <@0466c3>): int32(pos := int32(pos + 1));
	<append+427 @0466bb>  : 10 1c                      dup.x1 sp(28)
	<append+429 @0466bd>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @0466c1>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes: <@0466c3> - <@04671e>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @0466c3>  : 04 53 00 00                jmp <append+518 @046716>
	lib/std/string.ci:173: (52 bytes: <@0466c7> - <@0466fb>): assert(bool(pos < (output.length)));
	<append+439 @0466c7>  : 10 1c                      dup.x1 sp(28)
	<append+441 @0466c9>  : 10 1f                      dup.x1 sp(31)
	<append+443 @0466cb>  : 58                         clt.i32
	<append+444 @0466cc>  : 06 08 00 00                jz <append+452 @0466d4>
	<append+448 @0466d0>  : 04 2b 00 00                jmp <append+491 @0466fb>
	<append+452 @0466d4>  : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+457 @0466d9>  : 1c ad 00 00 00             load.c32 173
	<append+462 @0466de>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @0466e3>  : 1c 80 00 00 00             load.c32 128
	<append+472 @0466e8>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+477 @0466ed>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+482 @0466f2>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @0466f7>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes: <@0466fb> - <@046706>): char(output[pos] := padChr);
	<append+491 @0466fb>  : 0a 00 00 00                load.sp(+0)
	<append+495 @0466ff>  : 20                         load.i8
	<append+496 @046700>  : 10 1e                      dup.x1 sp(30)
	<append+498 @046702>  : 10 1e                      dup.x1 sp(30)
	<append+500 @046704>  : 51                         add.i32
	<append+501 @046705>  : 25                         store.i8
	lib/std/string.ci:175: (8 bytes: <@046706> - <@04670e>): int32(pos := int32(pos + 1));
	<append+502 @046706>  : 10 1c                      dup.x1 sp(28)
	<append+504 @046708>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @04670c>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes: <@04670e> - <@046716>): int32(maxLen := int32(maxLen - 1))
	<append+510 @04670e>  : 10 01                      dup.x1 sp(1)
	<append+512 @046710>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @046714>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes: <@046716> - <@04671e>): bool(maxLen > 0)
	<append+518 @046716>  : 10 01                      dup.x1 sp(1)
	<append+520 @046718>  : 19                         load.z32
	<append+521 @046719>  : 59                         cgt.i32
	<append+522 @04671a>  : 05 ad ff ff                jnz <append+439 @0466c7>
	lib/std/string.ci:179: (99 bytes: <@04671e> - <@046781>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @04671e>  : 19                         load.z32
	<append+527 @04671f>  : 04 55 00 00                jmp <append+612 @046774>
	lib/std/string.ci:180: (52 bytes: <@046723> - <@046757>): assert(bool(i < (output.length)));
	<append+531 @046723>  : 10 00                      dup.x1 sp(0)
	<append+533 @046725>  : 10 20                      dup.x1 sp(32)
	<append+535 @046727>  : 58                         clt.i32
	<append+536 @046728>  : 06 08 00 00                jz <append+544 @046730>
	<append+540 @04672c>  : 04 2b 00 00                jmp <append+583 @046757>
	<append+544 @046730>  : 1f 80 af 01 00             load.ref <@01af80> ;"lib/std/string.ci"
	<append+549 @046735>  : 1c b4 00 00 00             load.c32 180
	<append+554 @04673a>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @04673f>  : 1c 80 00 00 00             load.c32 128
	<append+564 @046744>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+569 @046749>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+574 @04674e>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @046753>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes: <@046757> - <@046768>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @046757>  : 0a 10 00 00                load.sp(+16)
	<append+587 @04675b>  : 10 19                      dup.x1 sp(25)
	<append+589 @04675d>  : 10 02                      dup.x1 sp(2)
	<append+591 @04675f>  : 52                         sub.i32
	<append+592 @046760>  : 51                         add.i32
	<append+593 @046761>  : 20                         load.i8
	<append+594 @046762>  : 10 1f                      dup.x1 sp(31)
	<append+596 @046764>  : 10 1f                      dup.x1 sp(31)
	<append+598 @046766>  : 51                         add.i32
	<append+599 @046767>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@046768> - <@046770>): int32(pos := int32(pos + 1));
	<append+600 @046768>  : 10 1d                      dup.x1 sp(29)
	<append+602 @04676a>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @04676e>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes: <@046770> - <@046774>): int32(i := int32(i + 1))
	<append+608 @046770>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:179: (9 bytes: <@046774> - <@04677d>): bool(i < len)
	<append+612 @046774>  : 10 00                      dup.x1 sp(0)
	<append+614 @046776>  : 10 19                      dup.x1 sp(25)
	<append+616 @046778>  : 58                         clt.i32
	<append+617 @046779>  : 05 aa ff ff                jnz <append+531 @046723>
	<append+621 @04677d>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:185: (17 bytes: <@046781> - <@046792>): if (bool(pos >= (output.length)))
	<append+625 @046781>  : 10 1c                      dup.x1 sp(28)
	<append+627 @046783>  : 10 1f                      dup.x1 sp(31)
	<append+629 @046785>  : 58                         clt.i32
	<append+630 @046786>  : 05 0c 00 00                jnz <append+642 @046792>
	lib/std/string.ci:186: (8 bytes: <@04678a> - <@046792>): int32(pos := (uint32(output.length - (1))));
	<append+634 @04678a>  : 10 1e                      dup.x1 sp(30)
	<append+636 @04678c>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @046790>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes: <@046792> - <@046799>): char(output[pos] := (0));
	<append+642 @046792>  : 19                         load.z32
	<append+643 @046793>  : 10 1e                      dup.x1 sp(30)
	<append+645 @046795>  : 10 1e                      dup.x1 sp(30)
	<append+647 @046797>  : 51                         add.i32
	<append+648 @046798>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@046799> - <@0467a1>): return int32(.result := pos);
	<append+649 @046799>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @04679c>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @0467a0>  : 03                         ret
.references:
	lib/std/string.ci:202: referenced as `append`
	lib/std/string.ci:193: referenced as `append`
	lib/std/string.ci:129: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@0467a8>
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@0467a8> - <@0467bf>)
	lib/std/string.ci:193: (23 bytes: <@0467a8> - <@0467bf>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @0467a8>      : 19                         load.z32
	<append+1 @0467a9>    : 11 05                      dup.x2 sp(5)
	<append+3 @0467ab>    : 10 06                      dup.x1 sp(6)
	<append+5 @0467ad>    : 19                         load.z32
	<append+6 @0467ae>    : 10 07                      dup.x1 sp(7)
	<append+8 @0467b0>    : 10 07                      dup.x1 sp(7)
	<append+10 @0467b2>   : 1f 10 65 04 00             load.ref <@046510> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @0467b7>   : 02                         call
	<append+16 @0467b8>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @0467bc>   : 13 07                      set.x1 sp(7)
	<append+22 @0467be>   : 03                         ret
.references:
	lib/std/string.ci:207: referenced as `append`
	lib/std/string.ci:192: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0467c0>
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@0467c0> - <@0467f1>)
	lib/std/string.ci:197: (1 byte: <@0467c0> - <@0467c1>): sign: int32 := 0
	<append @0467c0>      : 19                         load.z32
	lib/std/string.ci:198: (20 bytes: <@0467c1> - <@0467d5>): if (bool(value < 0))
	<append+1 @0467c1>    : 10 03                      dup.x1 sp(3)
	<append+3 @0467c3>    : 19                         load.z32
	<append+4 @0467c4>    : 58                         clt.i32
	<append+5 @0467c5>    : 06 10 00 00                jz <append+21 @0467d5>
	lib/std/string.ci:199: (7 bytes: <@0467c9> - <@0467d0>): int32(sign := ('-'));
	<append+9 @0467c9>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @0467ce>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes: <@0467d0> - <@0467d5>): int32(value := int32(-value));
	<append+16 @0467d0>   : 10 03                      dup.x1 sp(3)
	<append+18 @0467d2>   : 50                         neg.i32
	<append+19 @0467d3>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes: <@0467d5> - <@0467f1>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @0467d5>   : 19                         load.z32
	<append+22 @0467d6>   : 11 06                      dup.x2 sp(6)
	<append+24 @0467d8>   : 10 07                      dup.x1 sp(7)
	<append+26 @0467da>   : 10 04                      dup.x1 sp(4)
	<append+28 @0467dc>   : 10 08                      dup.x1 sp(8)
	<append+30 @0467de>   : 10 08                      dup.x1 sp(8)
	<append+32 @0467e0>   : 1f 10 65 04 00             load.ref <@046510> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @0467e5>   : 02                         call
	<append+38 @0467e6>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @0467ea>   : 13 08                      set.x1 sp(8)
	<append+44 @0467ec>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @0467f0>   : 03                         ret
.references:
	lib/std/string.ci:196: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@046808>
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@046808> - <@046821>)
	lib/std/string.ci:207: (25 bytes: <@046808> - <@046821>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @046808>      : 19                         load.z32
	<append+1 @046809>    : 11 04                      dup.x2 sp(4)
	<append+3 @04680b>    : 10 05                      dup.x1 sp(5)
	<append+5 @04680d>    : 10 05                      dup.x1 sp(5)
	<append+7 @04680f>    : 1f f8 67 04 00             load.ref <@0467f8> ;append.format
	<append+12 @046814>   : 1f a8 67 04 00             load.ref <@0467a8> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @046819>   : 02                         call
	<append+18 @04681a>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @04681e>   : 13 06                      set.x1 sp(6)
	<append+24 @046820>   : 03                         ret
.references:
	lib/std/string.ci:205: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01fcd8>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:3'
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.references:
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:8: referenced as `vec2d`
	lib/vec/vec2d.ci:3: defined as `vec2d`
}
vec2d.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:4'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:10: referenced as `x`
	lib/vec/vec2d.ci:4: defined as `x`
}
vec2d.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:5'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:11: referenced as `y`
	lib/vec/vec2d.ci:5: defined as `y`
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@046828>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:8'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@046828> - <@04682f>)
	lib/vec/vec2d.ci:9: (7 bytes: <@046828> - <@04682f>): return void(.result := {...});
	<vec2d @046828>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:11: (3 bytes: <@04682b> - <@04682e>): void(.result.y := y);
	<vec2d+3 @04682b>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @04682e>    : 03                         ret
.references:
	lib/vec/vec2d.ci:8: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:15'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.references:
	lib/vec/vec2d.ci:15: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:16'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.references:
	lib/vec/vec2d.ci:16: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020510>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:3'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field .anonymous: vec4f..anonymous (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:9: referenced as `vec4f`
	lib/vec/mat4f.ci:8: referenced as `vec4f`
	lib/vec/mat4f.ci:7: referenced as `vec4f`
	lib/vec/mat4f.ci:6: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:74: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:21: referenced as `vec4f`
	lib/vec/vec4f.ci:3: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:4'
.owner: vec4f
.references:
	lib/vec/vec4f.ci:4: defined as `data`
}
vec4f..anonymous: vec4f..anonymous {
.kind: variable(val)
.base: `vec4f..anonymous`
.size: 16
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/vec4f.ci:84'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.references:
	lib/vec/vec4f.ci:84: defined as `.anonymous`
}
vec4f..anonymous.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:21: referenced as `x`
	lib/vec/mat4f.ci:20: referenced as `x`
	lib/vec/mat4f.ci:19: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/vec4f.ci:77: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:25: referenced as `x`
	lib/vec/vec4f.ci:22: referenced as `x`
	lib/vec/vec4f.ci:6: defined as `x`
}
vec4f..anonymous.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:21: referenced as `y`
	lib/vec/mat4f.ci:20: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:18: referenced as `y`
	lib/vec/vec4f.ci:77: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:25: referenced as `y`
	lib/vec/vec4f.ci:22: referenced as `y`
	lib/vec/vec4f.ci:7: defined as `y`
}
vec4f..anonymous.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:21: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:19: referenced as `z`
	lib/vec/mat4f.ci:18: referenced as `z`
	lib/vec/vec4f.ci:77: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:25: referenced as `z`
	lib/vec/vec4f.ci:22: referenced as `z`
	lib/vec/vec4f.ci:8: defined as `z`
}
vec4f..anonymous.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:20: referenced as `w`
	lib/vec/mat4f.ci:19: referenced as `w`
	lib/vec/mat4f.ci:18: referenced as `w`
	lib/vec/vec4f.ci:77: referenced as `w`
	lib/vec/vec4f.ci:22: referenced as `w`
	lib/vec/vec4f.ci:9: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.value: x: float32
.references:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f
.value: y: float32
.references:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f
.value: z: float32
.references:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.value: w: float32
.references:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@046830>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:21'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@046830> - <@04683d>)
	lib/vec/vec4f.ci:22: (13 bytes: <@046830> - <@04683d>): return void(.result := {...});
	<vec4f @046830>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:22: (3 bytes: <@046833> - <@046836>): void(.result.y := y);
	<vec4f+3 @046833>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:22: (3 bytes: <@046836> - <@046839>): void(.result.z := z);
	<vec4f+6 @046836>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:22: (3 bytes: <@046839> - <@04683c>): void(.result.w := w);
	<vec4f+9 @046839>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @04683c>   : 03                         ret
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/vec4f.ci:26: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:24: referenced as `vec4f`
	lib/vec/vec4f.ci:21: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:24'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.value: vec4f(void(void(void(x, y), z), 0.000000))
.references:
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:24: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:25'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.references:
	lib/vec/vec4f.ci:25: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: vec4f(void(void(void(val, val), val), val))
.references:
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:26: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:56'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.references:
	lib/vec/vec4f.ci:56: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:57'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.references:
	lib/vec/vec4f.ci:57: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:58'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.references:
	lib/vec/vec4f.ci:58: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:59'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.references:
	lib/vec/vec4f.ci:59: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:60'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.references:
	lib/vec/vec4f.ci:75: referenced as `div`
	lib/vec/vec4f.ci:60: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:62'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.references:
	lib/vec/vec4f.ci:62: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:63'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.references:
	lib/vec/vec4f.ci:63: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:68'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.references:
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/vec4f.ci:74: referenced as `dp3`
	lib/vec/vec4f.ci:68: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:69'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.references:
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/vec4f.ci:69: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:70'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.references:
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/vec4f.ci:70: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:72'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.references:
	lib/vec/vec4f.ci:72: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:74'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.value: float32.sqrt(dp3(void(v, v)))
.references:
	lib/vec/vec4f.ci:75: referenced as `len`
	lib/vec/vec4f.ci:74: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.value: div(void(v, vec4f(len(v))))
.references:
	lib/vec/vec4f.ci:75: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:77'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.references:
	lib/vec/vec4f.ci:77: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@023220>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:3'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field .anonymous: mat4f..anonymous (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:34: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:31: referenced as `mat4f`
	lib/vec/mat4f.ci:30: referenced as `mat4f`
	lib/vec/mat4f.ci:29: referenced as `mat4f`
	lib/vec/mat4f.ci:25: referenced as `mat4f`
	lib/vec/mat4f.ci:13: referenced as `mat4f`
	lib/vec/mat4f.ci:3: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:4'
.owner: mat4f
.references:
	lib/vec/mat4f.ci:4: defined as `data`
}
mat4f..anonymous: mat4f..anonymous {
.kind: variable(val)
.base: `mat4f..anonymous`
.size: 64
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.references:
	lib/vec/mat4f.ci:59: defined as `.anonymous`
}
mat4f..anonymous.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:31: referenced as `x`
	lib/vec/mat4f.ci:30: referenced as `x`
	lib/vec/mat4f.ci:29: referenced as `x`
	lib/vec/mat4f.ci:26: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/mat4f.ci:6: defined as `x`
}
mat4f..anonymous.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:31: referenced as `y`
	lib/vec/mat4f.ci:30: referenced as `y`
	lib/vec/mat4f.ci:29: referenced as `y`
	lib/vec/mat4f.ci:26: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:7: defined as `y`
}
mat4f..anonymous.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:31: referenced as `z`
	lib/vec/mat4f.ci:30: referenced as `z`
	lib/vec/mat4f.ci:29: referenced as `z`
	lib/vec/mat4f.ci:26: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:8: defined as `z`
}
mat4f..anonymous.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:31: referenced as `w`
	lib/vec/mat4f.ci:30: referenced as `w`
	lib/vec/mat4f.ci:26: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:9: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.value: x: vec4f
.references:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f
.value: y: vec4f
.references:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f
.value: z: vec4f
.references:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.value: w: vec4f
.references:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@046840>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:13'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@046840> - <@046871>)
	lib/vec/mat4f.ci:17: (49 bytes: <@046840> - <@046871>): return void(.result := {...});
	<mat4f @046840>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:18: (3 bytes: <@046843> - <@046846>): void(.result.x.y := xy);
	<mat4f+3 @046843>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:18: (3 bytes: <@046846> - <@046849>): void(.result.x.z := xz);
	<mat4f+6 @046846>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:18: (3 bytes: <@046849> - <@04684c>): void(.result.x.w := xw);
	<mat4f+9 @046849>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:19: (3 bytes: <@04684c> - <@04684f>): void(.result.y.x := yx);
	<mat4f+12 @04684c>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:19: (3 bytes: <@04684f> - <@046852>): void(.result.y.y := yy);
	<mat4f+15 @04684f>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:19: (3 bytes: <@046852> - <@046855>): void(.result.y.z := yz);
	<mat4f+18 @046852>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:19: (3 bytes: <@046855> - <@046858>): void(.result.y.w := yw);
	<mat4f+21 @046855>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:20: (3 bytes: <@046858> - <@04685b>): void(.result.z.x := zx);
	<mat4f+24 @046858>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:20: (3 bytes: <@04685b> - <@04685e>): void(.result.z.y := zy);
	<mat4f+27 @04685b>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:20: (3 bytes: <@04685e> - <@046861>): void(.result.z.z := zz);
	<mat4f+30 @04685e>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:20: (3 bytes: <@046861> - <@046864>): void(.result.z.w := zw);
	<mat4f+33 @046861>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:21: (3 bytes: <@046864> - <@046867>): void(.result.w.x := wx);
	<mat4f+36 @046864>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:21: (3 bytes: <@046867> - <@04686a>): void(.result.w.y := wy);
	<mat4f+39 @046867>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:21: (3 bytes: <@04686a> - <@04686d>): void(.result.w.z := wz);
	<mat4f+42 @04686a>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:21: (3 bytes: <@04686d> - <@046870>): void(.result.w.w := ww);
	<mat4f+45 @04686d>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @046870>   : 03                         ret
.references:
	lib/vec/mat4f.ci:13: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@046878>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:25'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@046878> - <@04688d>)
	lib/vec/mat4f.ci:26: (21 bytes: <@046878> - <@04688d>): return void(.result := {...});
	<mat4f @046878>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @04687a>    : 24                         load.i128
	<mat4f+3 @04687b>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:26: (5 bytes: <@04687d> - <@046882>): void(.result.y := y);
	<mat4f+5 @04687d>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @04687f>    : 24                         load.i128
	<mat4f+8 @046880>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:26: (5 bytes: <@046882> - <@046887>): void(.result.z := z);
	<mat4f+10 @046882>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @046884>   : 24                         load.i128
	<mat4f+13 @046885>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:26: (5 bytes: <@046887> - <@04688c>): void(.result.w := w);
	<mat4f+15 @046887>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @046889>   : 24                         load.i128
	<mat4f+18 @04688a>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @04688c>   : 03                         ret
.references:
	lib/vec/mat4f.ci:25: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.references:
	lib/vec/mat4f.ci:29: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:30'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:45: referenced as `dp4`
	lib/vec/mat4f.ci:44: referenced as `dp4`
	lib/vec/mat4f.ci:43: referenced as `dp4`
	lib/vec/mat4f.ci:42: referenced as `dp4`
	lib/vec/mat4f.ci:30: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:31'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:31: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@046890>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:33'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@046890> - <@046a31>)
	lib/vec/mat4f.ci:34: (144 bytes: <@046890> - <@046920>): transposed: mat4f := {...}
	<mul @046890>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:35: (5 bytes: <@046894> - <@046899>): void(transposed.x.x := rhs.x.x);
	<mul+4 @046894>    : 10 11                      dup.x1 sp(17)
	<mul+6 @046896>    : 22                         load.i32
	<mul+7 @046897>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:35: (9 bytes: <@046899> - <@0468a2>): void(transposed.x.y := rhs.y.x);
	<mul+9 @046899>    : 10 11                      dup.x1 sp(17)
	<mul+11 @04689b>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @04689f>   : 22                         load.i32
	<mul+16 @0468a0>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:35: (9 bytes: <@0468a2> - <@0468ab>): void(transposed.x.z := rhs.z.x);
	<mul+18 @0468a2>   : 10 11                      dup.x1 sp(17)
	<mul+20 @0468a4>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @0468a8>   : 22                         load.i32
	<mul+25 @0468a9>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:35: (9 bytes: <@0468ab> - <@0468b4>): void(transposed.x.w := rhs.w.x);
	<mul+27 @0468ab>   : 10 11                      dup.x1 sp(17)
	<mul+29 @0468ad>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @0468b1>   : 22                         load.i32
	<mul+34 @0468b2>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:36: (9 bytes: <@0468b4> - <@0468bd>): void(transposed.y.x := rhs.x.y);
	<mul+36 @0468b4>   : 10 11                      dup.x1 sp(17)
	<mul+38 @0468b6>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @0468ba>   : 22                         load.i32
	<mul+43 @0468bb>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:36: (9 bytes: <@0468bd> - <@0468c6>): void(transposed.y.y := rhs.y.y);
	<mul+45 @0468bd>   : 10 11                      dup.x1 sp(17)
	<mul+47 @0468bf>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @0468c3>   : 22                         load.i32
	<mul+52 @0468c4>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:36: (9 bytes: <@0468c6> - <@0468cf>): void(transposed.y.z := rhs.z.y);
	<mul+54 @0468c6>   : 10 11                      dup.x1 sp(17)
	<mul+56 @0468c8>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @0468cc>   : 22                         load.i32
	<mul+61 @0468cd>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:36: (9 bytes: <@0468cf> - <@0468d8>): void(transposed.y.w := rhs.w.y);
	<mul+63 @0468cf>   : 10 11                      dup.x1 sp(17)
	<mul+65 @0468d1>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @0468d5>   : 22                         load.i32
	<mul+70 @0468d6>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:37: (9 bytes: <@0468d8> - <@0468e1>): void(transposed.z.x := rhs.x.z);
	<mul+72 @0468d8>   : 10 11                      dup.x1 sp(17)
	<mul+74 @0468da>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @0468de>   : 22                         load.i32
	<mul+79 @0468df>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:37: (9 bytes: <@0468e1> - <@0468ea>): void(transposed.z.y := rhs.y.z);
	<mul+81 @0468e1>   : 10 11                      dup.x1 sp(17)
	<mul+83 @0468e3>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @0468e7>   : 22                         load.i32
	<mul+88 @0468e8>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:37: (9 bytes: <@0468ea> - <@0468f3>): void(transposed.z.z := rhs.z.z);
	<mul+90 @0468ea>   : 10 11                      dup.x1 sp(17)
	<mul+92 @0468ec>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @0468f0>   : 22                         load.i32
	<mul+97 @0468f1>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:37: (9 bytes: <@0468f3> - <@0468fc>): void(transposed.z.w := rhs.w.z);
	<mul+99 @0468f3>   : 10 11                      dup.x1 sp(17)
	<mul+101 @0468f5>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @0468f9>  : 22                         load.i32
	<mul+106 @0468fa>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:38: (9 bytes: <@0468fc> - <@046905>): void(transposed.w.x := rhs.x.w);
	<mul+108 @0468fc>  : 10 11                      dup.x1 sp(17)
	<mul+110 @0468fe>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @046902>  : 22                         load.i32
	<mul+115 @046903>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:38: (9 bytes: <@046905> - <@04690e>): void(transposed.w.y := rhs.y.w);
	<mul+117 @046905>  : 10 11                      dup.x1 sp(17)
	<mul+119 @046907>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @04690b>  : 22                         load.i32
	<mul+124 @04690c>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:38: (9 bytes: <@04690e> - <@046917>): void(transposed.w.z := rhs.z.w);
	<mul+126 @04690e>  : 10 11                      dup.x1 sp(17)
	<mul+128 @046910>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @046914>  : 22                         load.i32
	<mul+133 @046915>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:38: (9 bytes: <@046917> - <@046920>): void(transposed.w.w := rhs.w.w);
	<mul+135 @046917>  : 10 11                      dup.x1 sp(17)
	<mul+137 @046919>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @04691d>  : 22                         load.i32
	<mul+142 @04691e>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:41: (273 bytes: <@046920> - <@046a31>): return void(.result := {...});
	<mul+144 @046920>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @046924>  : 10 13                      dup.x1 sp(19)
	<mul+150 @046926>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @04692a>  : 10 04                      dup.x1 sp(4)
	<mul+156 @04692c>  : 24                         load.i128
	<mul+157 @04692d>  : 10 09                      dup.x1 sp(9)
	<mul+159 @04692f>  : 24                         load.i128
	<mul+160 @046930>  : 9b                         dp4.v4f
	<mul+161 @046931>  : 10 05                      dup.x1 sp(5)
	<mul+163 @046933>  : 24                         load.i128
	<mul+164 @046934>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @046936>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @04693a>  : 24                         load.i128
	<mul+171 @04693b>  : 9b                         dp4.v4f
	<mul+172 @04693c>  : 10 06                      dup.x1 sp(6)
	<mul+174 @04693e>  : 24                         load.i128
	<mul+175 @04693f>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @046941>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @046945>  : 24                         load.i128
	<mul+182 @046946>  : 9b                         dp4.v4f
	<mul+183 @046947>  : 10 07                      dup.x1 sp(7)
	<mul+185 @046949>  : 24                         load.i128
	<mul+186 @04694a>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @04694c>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @046950>  : 24                         load.i128
	<mul+193 @046951>  : 9b                         dp4.v4f
	<mul+194 @046952>  : 1f 30 68 04 00             load.ref <@046830> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @046957>  : 02                         call
	<mul+200 @046958>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @04695c>  : 15 02                      set.x4 sp(2)
	<mul+206 @04695e>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:43: (68 bytes: <@046960> - <@0469a4>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @046960>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @046964>  : 10 13                      dup.x1 sp(19)
	<mul+214 @046966>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @04696a>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @04696e>  : 10 04                      dup.x1 sp(4)
	<mul+224 @046970>  : 24                         load.i128
	<mul+225 @046971>  : 10 09                      dup.x1 sp(9)
	<mul+227 @046973>  : 24                         load.i128
	<mul+228 @046974>  : 9b                         dp4.v4f
	<mul+229 @046975>  : 10 05                      dup.x1 sp(5)
	<mul+231 @046977>  : 24                         load.i128
	<mul+232 @046978>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @04697a>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @04697e>  : 24                         load.i128
	<mul+239 @04697f>  : 9b                         dp4.v4f
	<mul+240 @046980>  : 10 06                      dup.x1 sp(6)
	<mul+242 @046982>  : 24                         load.i128
	<mul+243 @046983>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @046985>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @046989>  : 24                         load.i128
	<mul+250 @04698a>  : 9b                         dp4.v4f
	<mul+251 @04698b>  : 10 07                      dup.x1 sp(7)
	<mul+253 @04698d>  : 24                         load.i128
	<mul+254 @04698e>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @046990>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @046994>  : 24                         load.i128
	<mul+261 @046995>  : 9b                         dp4.v4f
	<mul+262 @046996>  : 1f 30 68 04 00             load.ref <@046830> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @04699b>  : 02                         call
	<mul+268 @04699c>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @0469a0>  : 15 02                      set.x4 sp(2)
	<mul+274 @0469a2>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:44: (68 bytes: <@0469a4> - <@0469e8>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @0469a4>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @0469a8>  : 10 13                      dup.x1 sp(19)
	<mul+282 @0469aa>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @0469ae>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @0469b2>  : 10 04                      dup.x1 sp(4)
	<mul+292 @0469b4>  : 24                         load.i128
	<mul+293 @0469b5>  : 10 09                      dup.x1 sp(9)
	<mul+295 @0469b7>  : 24                         load.i128
	<mul+296 @0469b8>  : 9b                         dp4.v4f
	<mul+297 @0469b9>  : 10 05                      dup.x1 sp(5)
	<mul+299 @0469bb>  : 24                         load.i128
	<mul+300 @0469bc>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @0469be>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @0469c2>  : 24                         load.i128
	<mul+307 @0469c3>  : 9b                         dp4.v4f
	<mul+308 @0469c4>  : 10 06                      dup.x1 sp(6)
	<mul+310 @0469c6>  : 24                         load.i128
	<mul+311 @0469c7>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @0469c9>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @0469cd>  : 24                         load.i128
	<mul+318 @0469ce>  : 9b                         dp4.v4f
	<mul+319 @0469cf>  : 10 07                      dup.x1 sp(7)
	<mul+321 @0469d1>  : 24                         load.i128
	<mul+322 @0469d2>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @0469d4>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @0469d8>  : 24                         load.i128
	<mul+329 @0469d9>  : 9b                         dp4.v4f
	<mul+330 @0469da>  : 1f 30 68 04 00             load.ref <@046830> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @0469df>  : 02                         call
	<mul+336 @0469e0>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @0469e4>  : 15 02                      set.x4 sp(2)
	<mul+342 @0469e6>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:45: (68 bytes: <@0469e8> - <@046a2c>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @0469e8>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @0469ec>  : 10 13                      dup.x1 sp(19)
	<mul+350 @0469ee>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @0469f2>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @0469f6>  : 10 04                      dup.x1 sp(4)
	<mul+360 @0469f8>  : 24                         load.i128
	<mul+361 @0469f9>  : 10 09                      dup.x1 sp(9)
	<mul+363 @0469fb>  : 24                         load.i128
	<mul+364 @0469fc>  : 9b                         dp4.v4f
	<mul+365 @0469fd>  : 10 05                      dup.x1 sp(5)
	<mul+367 @0469ff>  : 24                         load.i128
	<mul+368 @046a00>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @046a02>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @046a06>  : 24                         load.i128
	<mul+375 @046a07>  : 9b                         dp4.v4f
	<mul+376 @046a08>  : 10 06                      dup.x1 sp(6)
	<mul+378 @046a0a>  : 24                         load.i128
	<mul+379 @046a0b>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @046a0d>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @046a11>  : 24                         load.i128
	<mul+386 @046a12>  : 9b                         dp4.v4f
	<mul+387 @046a13>  : 10 07                      dup.x1 sp(7)
	<mul+389 @046a15>  : 24                         load.i128
	<mul+390 @046a16>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @046a18>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @046a1c>  : 24                         load.i128
	<mul+397 @046a1d>  : 9b                         dp4.v4f
	<mul+398 @046a1e>  : 1f 30 68 04 00             load.ref <@046830> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @046a23>  : 02                         call
	<mul+404 @046a24>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @046a28>  : 15 02                      set.x4 sp(2)
	<mul+410 @046a2a>  : 15 23                      set.x4 sp(35)
	<mul+412 @046a2c>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @046a30>  : 03                         ret
.references:
	lib/vec/mat4f.ci:33: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.references:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.references:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.references:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.references:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.references:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.references:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.references:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.references:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.references:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.references:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.references:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.references:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.references:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.references:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.references:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.references:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.references:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.references:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.references:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.references:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.references:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.references:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.references:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.references:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.references:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.references:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.references:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.references:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.references:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.references:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.references:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.references:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.references:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.references:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.references:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.references:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.references:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.references:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02a580>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.references:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02a690>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.references:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.references:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.references:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.references:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@046a38>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.references:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.references:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.references:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.references:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.references:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.references:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.references:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.references:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.references:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.references:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.references:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.references:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.references:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.references:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.references:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.references:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.references:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.references:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.references:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.references:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.references:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.references:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.references:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.references:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.references:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.references:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.references:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.references:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.references:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.references:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.references:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.references:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.references:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.references:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.references:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.references:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.references:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.references:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.references:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.references:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.references:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.references:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.references:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.references:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.references:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.references:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.references:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.references:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.references:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.references:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.references:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.references:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.references:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.references:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.references:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.references:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.references:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.references:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.references:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.references:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.references:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.references:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.references:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.references:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.references:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.references:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.references:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.references:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.references:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.references:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.references:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.references:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.references:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.references:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.references:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.references:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.references:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.references:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.references:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.references:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.references:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.references:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@046a40>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@046a40> - <@046a41>)
	<empty @046a40>      : 03                         ret
.references:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046a48>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@046a48> - <@046a50>)
	test/lang/function.ci:7: (8 bytes: <@046a48> - <@046a50>): return int32(.result := int32(x + y));
	<funAdd @046a48>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @046a4a>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @046a4c>    : 51                         add.i32
	<funAdd+5 @046a4d>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @046a4f>    : 03                         ret
.references:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.references:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.references:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.references:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.references:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.references:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046a50>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@046a50> - <@046a58>)
	test/lang/function.ci:33: (8 bytes: <@046a50> - <@046a58>): return int32(.result := int32(x * y));
	<funMul @046a50>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @046a52>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @046a54>    : 53                         mul.i32
	<funMul+5 @046a55>    : 13 04                      set.x1 sp(4)
	<funMul+7 @046a57>    : 03                         ret
.references:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@046a58>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@046a58> - <@046a8e>)
	test/lang/function.ci:38: (16 bytes: <@046a58> - <@046a68>): if (bool(n <= (1)))
	<fib @046a58>      : 10 01                      dup.x1 sp(1)
	<fib+2 @046a5a>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @046a5f>    : 39                         cgt.u32
	<fib+8 @046a60>    : 05 08 00 00                jnz <fib+16 @046a68>
	test/lang/function.ci:39: (4 bytes: <@046a64> - <@046a68>): return uint32(.result := n);
	<fib+12 @046a64>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @046a67>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@046a68> - <@046a8e>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @046a68>   : 19                         load.z32
	<fib+17 @046a69>   : 10 02                      dup.x1 sp(2)
	<fib+19 @046a6b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @046a6f>   : 1f 58 6a 04 00             load.ref <@046a58> ;fib(n: uint32): uint32
	<fib+28 @046a74>   : 02                         call
	<fib+29 @046a75>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @046a79>   : 19                         load.z32
	<fib+34 @046a7a>   : 10 03                      dup.x1 sp(3)
	<fib+36 @046a7c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @046a80>   : 1f 58 6a 04 00             load.ref <@046a58> ;fib(n: uint32): uint32
	<fib+45 @046a85>   : 02                         call
	<fib+46 @046a86>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @046a8a>   : 51                         add.i32
	<fib+51 @046a8b>   : 13 03                      set.x1 sp(3)
	<fib+53 @046a8d>   : 03                         ret
.references:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.references:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.references:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.references:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.references:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.references:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.references:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.references:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.references:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.references:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.references:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.references:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.references:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.references:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.references:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.references:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.references:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.references:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.references:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.references:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@02fa50>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.references:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.references:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@02fb60>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.references:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.references:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.references:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.references:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.references:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.references:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.references:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.references:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.references:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.references:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.references:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.references:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.references:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.references:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.references:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.references:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.references:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.references:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.references:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.references:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.references:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.references:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.references:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.references:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.references:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.references:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.references:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.references:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.references:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.references:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.references:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.references:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.references:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.references:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.references:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.references:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.references:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.references:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.references:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.references:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.references:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.references:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.references:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.references:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.references:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.references:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.references:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.references:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.references:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.references:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.references:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.references:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.references:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.references:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.references:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@046a90>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@046a90> - <@046a91>)
	<noError @046a90>      : 03                         ret
.references:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@046a98>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@046a98> - <@046ab0>)
	test/stdc/tryExec.ci:15: (4 bytes: <@046a98> - <@046a9c>): data: uint8[8192]
	<stackOverflow @046a98>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@046a9c> - <@046aab>): stackOverflow(ptr);
	<stackOverflow+4 @046a9c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @046aa0>    : 22                         load.i32
	<stackOverflow+9 @046aa1>    : 1f 98 6a 04 00             load.ref <@046a98> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @046aa6>   : 02                         call
	<stackOverflow+15 @046aa7>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @046aab>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @046aaf>   : 03                         ret
.references:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@046ab0>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@046ab0> - <@046abc>)
	test/stdc/tryExec.ci:20: (7 bytes: <@046ab0> - <@046ab7>): value: int32 := int32(3 / 0)
	<divisionByZero @046ab0>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @046ab5>    : 19                         load.z32
	<divisionByZero+6 @046ab6>    : 54                         div.i32
	<divisionByZero+7 @046ab7>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @046abb>   : 03                         ret
.references:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@046ac0>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@046ac0> - <@046b04>)
	test/stdc/tryExec.ci:29: (25 bytes: <@046ac0> - <@046ad9>): details: NotEquals := {...}
	<abortExecution @046ac0>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@046ac4> - <@046acb>): void(details.message := ("assertion failed"));
	<abortExecution+4 @046ac4>    : 1f 32 b6 00 00             load.ref <@00b632> ;"assertion failed"
	<abortExecution+9 @046ac9>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@046acb> - <@046ad2>): void(details.expected := 97);
	<abortExecution+11 @046acb>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @046ad0>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@046ad2> - <@046ad9>): void(details.returned := 77);
	<abortExecution+18 @046ad2>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @046ad7>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@046ad9> - <@046aff>): abort(void("fatal error", details));
	<abortExecution+25 @046ad9>   : 1f 48 31 03 00             load.ref <@033148> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @046ade>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @046ae3>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @046ae8>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @046aed>   : 1f 91 31 03 00             load.ref <@033191> ;"fatal error"
	<abortExecution+50 @046af2>   : 1f a8 3a 03 00             load.ref <@033aa8> ;abortExecution.NotEquals
	<abortExecution+55 @046af7>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @046afb>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @046aff>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @046b03>   : 03                         ret
.references:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@046b08>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@046b08> - <@046b15>)
	test/stdc/tryExec.ci:38: (5 bytes: <@046b08> - <@046b0d>): i32Ref: int32 := null
	<invalidMemoryAccess @046b08>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@046b0d> - <@046b10>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @046b0d>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @046b0f>    : 22                         load.i32
	<invalidMemoryAccess+8 @046b10>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @046b14>   : 03                         ret
.references:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@046b18>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@046b18> - <@046b1a>)
	test/stdc/tryExec.ci:43: (2 bytes: <@046b18> - <@046b1a>): emit(void(load.z32, ret));
	<invalidInstruction @046b18>      : 19                         load.z32
	<invalidInstruction+1 @046b19>    : 03                         ret
.references:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.references:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.references:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.references:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.references:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.references:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.references:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.references:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.references:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.references:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.references:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.references:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.references:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.references:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.references:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.references:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.references:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@046b20>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@046b20> - <@046b24>)
	test/lang/array.ci:103: (4 bytes: <@046b20> - <@046b24>): return uint32(.result := values.length);
	<lenSlice @046b20>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @046b23>    : 03                         ret
.references:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@046b28>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@046b28> - <@046b34>)
	test/lang/array.ci:104: (12 bytes: <@046b28> - <@046b34>): return int64(.result := values[idx]);
	<nthFixed @046b28>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @046b2a>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @046b2c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @046b30>    : 23                         load.i64
	<nthFixed+9 @046b31>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @046b33>   : 03                         ret
.references:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@046b38>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@046b38> - <@046b44>)
	test/lang/array.ci:105: (12 bytes: <@046b38> - <@046b44>): return int64(.result := values[idx]);
	<nthArray @046b38>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @046b3a>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @046b3c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @046b40>    : 23                         load.i64
	<nthArray+9 @046b41>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @046b43>   : 03                         ret
.references:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@046b48>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@046b48> - <@046b54>)
	test/lang/array.ci:106: (12 bytes: <@046b48> - <@046b54>): return int64(.result := values[idx]);
	<nthSlice @046b48>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @046b4a>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @046b4c>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @046b50>    : 23                         load.i64
	<nthSlice+9 @046b51>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @046b53>   : 03                         ret
.references:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@036360>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@0363e8>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@046b58>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@046b60>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@046b68>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@046b70>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@046b78>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@046b80>, cast: static const variable(val))
.references:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0363e8>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.references:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.references:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@046b58>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@046b60>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 5
.references:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@046b68>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 6
.references:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@046b70>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@046b78>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 51);
	void(globalRecInit.constant := 52);
}
.references:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@046b80>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 61);
	void(globalConstantRec.constant := 62);
}
.references:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 6);
	void(recordMemberTest.constant := 7);
	void(recordMemberTest.memberInit := 8);
	void(recordMemberTest.constantInit := 9);
	void(recordMemberTest.memberRec.member := 61);
	void(recordMemberTest.memberRec.constant := 62);
	void(recordMemberTest.constantRec.member := 71);
	void(recordMemberTest.constantRec.constant := 72);
}
.references:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@036d58>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 8, offs: <@046b88>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@046b90>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 8, offs: <@046b98>, cast: static const function)
.field forwardMethod: function (size: 8, offs: <@046ba0>, cast: static const function)
.field print: function (size: 4, offs: <+12>, cast: const variable(ref))
.field print: function (size: 40, offs: <@046ba8>, cast: static const function)
.field printStatic: function (size: 40, offs: <@046bd0>, cast: static const function)
.references:
	test/lang/method.ci:91: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:89: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:75: referenced as `RecordMethodTest`
	test/lang/method.ci:63: referenced as `RecordMethodTest`
	test/lang/method.ci:59: referenced as `RecordMethodTest`
	test/lang/method.ci:55: referenced as `RecordMethodTest`
	test/lang/method.ci:53: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046b88>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@046b88> - <@046b90>)
	test/lang/method.ci:7: (8 bytes: <@046b88> - <@046b90>): return int32(.result := int32(x + y));
	<staticMethod @046b88>      : 10 02                      dup.x1 sp(2)
	<staticMethod+2 @046b8a>    : 10 02                      dup.x1 sp(2)
	<staticMethod+4 @046b8c>    : 51                         add.i32
	<staticMethod+5 @046b8d>    : 13 04                      set.x1 sp(4)
	<staticMethod+7 @046b8f>    : 03                         ret
.references:
	test/lang/method.ci:55: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@046b90>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:12'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:20: referenced as `forwardMethod`
	test/lang/method.ci:12: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.abstractMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:16'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:55: referenced as `abstractMethod`
	test/lang/method.ci:16: defined as `abstractMethod(x: int32, y: int32): int32`
}
RecordMethodTest.delegateMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:20'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:54: referenced as `delegateMethod`
	test/lang/method.ci:20: defined as `delegateMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: virtualMethod
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046b98>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@046b98> - <@046ba0>)
	test/lang/method.ci:27: (8 bytes: <@046b98> - <@046ba0>): return int32(.result := int32(x * y));
	<virtualMethod @046b98>      : 10 02                      dup.x1 sp(2)
	<virtualMethod+2 @046b9a>    : 10 02                      dup.x1 sp(2)
	<virtualMethod+4 @046b9c>    : 53                         mul.i32
	<virtualMethod+5 @046b9d>    : 13 04                      set.x1 sp(4)
	<virtualMethod+7 @046b9f>    : 03                         ret
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046ba0>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:31'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@046ba0> - <@046ba8>)
	test/lang/method.ci:32: (8 bytes: <@046ba0> - <@046ba8>): return int32(.result := int32(x * y));
	<forwardMethod @046ba0>      : 10 02                      dup.x1 sp(2)
	<forwardMethod+2 @046ba2>    : 10 02                      dup.x1 sp(2)
	<forwardMethod+4 @046ba4>    : 53                         mul.i32
	<forwardMethod+5 @046ba5>    : 13 04                      set.x1 sp(4)
	<forwardMethod+7 @046ba7>    : 03                         ret
.references:
	test/lang/method.ci:31: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+12>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: print
.references:
	test/lang/method.ci:70: referenced as `print`
	test/lang/method.ci:69: referenced as `print`
	test/lang/method.ci:65: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@046ba8>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("virtual");
}
.instructions: (40 bytes: <@046ba8> - <@046bd0>)
	test/lang/method.ci:41: (39 bytes: <@046ba8> - <@046bcf>): trace("virtual");
	<print @046ba8>      : 1f 68 6c 03 00             load.ref <@036c68> ;"test/lang/method.ci"
	<print+5 @046bad>    : 1c 29 00 00 00             load.c32 41
	<print+10 @046bb2>   : 1c 0e 00 00 00             load.c32 14
	<print+15 @046bb7>   : 1c 80 00 00 00             load.c32 128
	<print+20 @046bbc>   : 1f df 6c 03 00             load.ref <@036cdf> ;"virtual"
	<print+25 @046bc1>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @046bc6>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @046bcb>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @046bcf>   : 03                         ret
.references:
	test/lang/method.ci:91: referenced as `print`
	test/lang/method.ci:89: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@046bd0>
.name: 'printStatic'
.file: 'test/lang/method.ci:44'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("static");
}
.instructions: (40 bytes: <@046bd0> - <@046bf8>)
	test/lang/method.ci:45: (39 bytes: <@046bd0> - <@046bf7>): trace("static");
	<printStatic @046bd0>      : 1f 68 6c 03 00             load.ref <@036c68> ;"test/lang/method.ci"
	<printStatic+5 @046bd5>    : 1c 2d 00 00 00             load.c32 45
	<printStatic+10 @046bda>   : 1c 0e 00 00 00             load.c32 14
	<printStatic+15 @046bdf>   : 1c 80 00 00 00             load.c32 128
	<printStatic+20 @046be4>   : 1f f3 6c 03 00             load.ref <@036cf3> ;"static"
	<printStatic+25 @046be9>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @046bee>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @046bf3>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @046bf7>   : 03                         ret
.references:
	test/lang/method.ci:90: referenced as `printStatic`
	test/lang/method.ci:73: referenced as `printStatic`
	test/lang/method.ci:44: defined as `printStatic(this: RecordMethodTest): void`
}
globalFunction(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@046bf8>
.name: 'globalFunction'
.file: 'test/lang/method.ci:49'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@046bf8> - <@046c00>)
	test/lang/method.ci:50: (8 bytes: <@046bf8> - <@046c00>): return int32(.result := int32(x * y));
	<globalFunction @046bf8>      : 10 02                      dup.x1 sp(2)
	<globalFunction+2 @046bfa>    : 10 02                      dup.x1 sp(2)
	<globalFunction+4 @046bfc>    : 53                         mul.i32
	<globalFunction+5 @046bfd>    : 13 04                      set.x1 sp(4)
	<globalFunction+7 @046bff>    : 03                         ret
.references:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:54: referenced as `globalFunction`
	test/lang/method.ci:49: defined as `globalFunction(x: int32, y: int32): int32`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:53'
.value: {
	void(recordMethodTest.delegateMethod := globalFunction);
	void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
	void(recordMethodTest.print := print);
}
.references:
	test/lang/method.ci:90: referenced as `recordMethodTest`
	test/lang/method.ci:89: referenced as `recordMethodTest`
	test/lang/method.ci:85: referenced as `recordMethodTest`
	test/lang/method.ci:84: referenced as `recordMethodTest`
	test/lang/method.ci:73: referenced as `recordMethodTest`
	test/lang/method.ci:69: referenced as `recordMethodTest`
	test/lang/method.ci:53: defined as `recordMethodTest`
}
customPrint(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@046c00>
.name: 'customPrint'
.file: 'test/lang/method.ci:59'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("override");
}
.instructions: (40 bytes: <@046c00> - <@046c28>)
	test/lang/method.ci:60: (39 bytes: <@046c00> - <@046c27>): trace("override");
	<customPrint @046c00>      : 1f 68 6c 03 00             load.ref <@036c68> ;"test/lang/method.ci"
	<customPrint+5 @046c05>    : 1c 3c 00 00 00             load.c32 60
	<customPrint+10 @046c0a>   : 1c 0e 00 00 00             load.c32 14
	<customPrint+15 @046c0f>   : 1c 80 00 00 00             load.c32 128
	<customPrint+20 @046c14>   : 1f 26 6d 03 00             load.ref <@036d26> ;"override"
	<customPrint+25 @046c19>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<customPrint+30 @046c1e>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<customPrint+35 @046c23>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<customPrint+39 @046c27>   : 03                         ret
.references:
	test/lang/method.ci:65: referenced as `customPrint`
	test/lang/method.ci:59: defined as `customPrint(this: RecordMethodTest): void`
}
recordMethodTestCustomPrint: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1368>
.name: 'recordMethodTestCustomPrint'
.file: 'test/lang/method.ci:63'
.value: {
	void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	void(recordMethodTestCustomPrint.print := customPrint);
	void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
	void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
}
.references:
	test/lang/method.ci:91: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:86: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:70: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:63: defined as `recordMethodTestCustomPrint`
}
print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@046c28>
.name: 'print'
.file: 'test/lang/method.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@046c28> - <@046c50>)
	test/lang/method.ci:76: (39 bytes: <@046c28> - <@046c4f>): trace("extension");
	<print @046c28>      : 1f 68 6c 03 00             load.ref <@036c68> ;"test/lang/method.ci"
	<print+5 @046c2d>    : 1c 4c 00 00 00             load.c32 76
	<print+10 @046c32>   : 1c 0e 00 00 00             load.c32 14
	<print+15 @046c37>   : 1c 80 00 00 00             load.c32 128
	<print+20 @046c3c>   : 1f 4b 6d 03 00             load.ref <@036d4b> ;"extension"
	<print+25 @046c41>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @046c46>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @046c4b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @046c4f>   : 03                         ret
.references:
	test/lang/method.ci:86: referenced as `print`
	test/lang/method.ci:84: referenced as `print`
	test/lang/method.ci:75: defined as `print(this: RecordMethodTest): void`
}
printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@046c50>
.name: 'printStatic'
.file: 'test/lang/method.ci:79'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@046c50> - <@046c78>)
	test/lang/method.ci:80: (39 bytes: <@046c50> - <@046c77>): trace("extension");
	<printStatic @046c50>      : 1f 68 6c 03 00             load.ref <@036c68> ;"test/lang/method.ci"
	<printStatic+5 @046c55>    : 1c 50 00 00 00             load.c32 80
	<printStatic+10 @046c5a>   : 1c 0e 00 00 00             load.c32 14
	<printStatic+15 @046c5f>   : 1c 80 00 00 00             load.c32 128
	<printStatic+20 @046c64>   : 1f 4b 6d 03 00             load.ref <@036d4b> ;"extension"
	<printStatic+25 @046c69>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @046c6e>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @046c73>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @046c77>   : 03                         ret
.references:
	test/lang/method.ci:85: referenced as `printStatic`
	test/lang/method.ci:79: defined as `printStatic(this: RecordMethodTest): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@038730>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.references:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@038950>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.references:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@038b70>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.references:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.references:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.references:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@038d08>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.references:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.references:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1372>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.references:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1376>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.references:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1380>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.references:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1384>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.references:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1388>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.references:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@039138>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@0394f0>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0398a8>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@039c60>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03a018>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03a3d0>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.references:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.references:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1392>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.references:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.references:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.references:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.references:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.references:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.references:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.references:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.references:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.references:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1428>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.references:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1432>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.references:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1436>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.references:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1440>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.references:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.references:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.references:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.references:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.references:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.references:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.references:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.references:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.references:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.references:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.references:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.references:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1488>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.references:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1492>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.references:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1496>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.references:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1500>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.references:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.references:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.references:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.references:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1516>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.references:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1520>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.references:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1524>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.references:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1528>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.references:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.references:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.references:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.references:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.references:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.references:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.references:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.references:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.references:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.references:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.references:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.references:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1576>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.references:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1580>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.references:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1584>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.references:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1588>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.references:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.references:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.references:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.references:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1604>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.references:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1608>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.references:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1612>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.references:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1616>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.references:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.references:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.references:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.references:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.references:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.references:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.references:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.references:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.references:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.references:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.references:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.references:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1664>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.references:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1668>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.references:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1672>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.references:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1676>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.references:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.references:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.references:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.references:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1692>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.references:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1696>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.references:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1700>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.references:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1704>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.references:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.references:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.references:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.references:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.references:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.references:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.references:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.references:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.references:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.references:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.references:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.references:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1752>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.references:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1756>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.references:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1760>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.references:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1764>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.references:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.references:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.references:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.references:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1780>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.references:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1784>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.references:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1788>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.references:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1792>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.references:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.references:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.references:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.references:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.references:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.references:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.references:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.references:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.references:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.references:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.references:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.references:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1840>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.references:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1844>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.references:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1848>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.references:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1852>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.references:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.references:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.references:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.references:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1868>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.references:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1872>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.references:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1876>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.references:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1880>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.references:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.references:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.references:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.references:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.references:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.references:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.references:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.references:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.references:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.references:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.references:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.references:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1928>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.references:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1932>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.references:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1936>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.references:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1940>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.references:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.references:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.references:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.references:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1956>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.references:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1960>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.references:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1964>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.references:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1968>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.references:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.references:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.references:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.references:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.references:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.references:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.references:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.references:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.references:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.references:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.references:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.references:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2016>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.references:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2020>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.references:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2024>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.references:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2028>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.references:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.references:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.references:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.references:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2044>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.references:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2048>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.references:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2052>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.references:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2056>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.references:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.references:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.references:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.references:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.references:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.references:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.references:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.references:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.references:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.references:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.references:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.references:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.references:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.references:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2168>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.references:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2176>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.references:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.references:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.references:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.references:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2192>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.references:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2196>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.references:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2200>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.references:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2204>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.references:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.references:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.references:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.references:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.references:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.references:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.references:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.references:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.references:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.references:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.references:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.references:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.references:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.references:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2316>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.references:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2324>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.references:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.references:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.references:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.references:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2340>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.references:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2344>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.references:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2348>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.references:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2352>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.references:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.references:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.references:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.references:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.references:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.references:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2376>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.references:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2380>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.references:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2384>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.references:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2388>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.references:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.references:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.references:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.references:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2404>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.references:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2408>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.references:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2412>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.references:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2416>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.references:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.references:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.references:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.references:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.references:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.references:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.references:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.references:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2480>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.references:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2488>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.references:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.references:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.references:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.references:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2504>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.references:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2508>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.references:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.references:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.references:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2520>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.references:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2524>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.references:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2528>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.references:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2532>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.references:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2536>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.references:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2540>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.references:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.references:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.references:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.references:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.references:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.references:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.references:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.references:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.references:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.references:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.references:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_0f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathSmooth_0f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_0f`
}
testMathSmooth_0F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathSmooth_0F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_0F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:37'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:37: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:38'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:38: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.min()
.references:
	test/stdc/test.math.ci:40: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:41'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:41: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:42'
.value: Math.max()
.references:
	test/stdc/test.math.ci:42: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:43'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:43: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum()
.references:
	test/stdc/test.math.ci:45: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(1)
.references:
	test/stdc/test.math.ci:46: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:47'
.value: Math.sum(void(1, 2))
.references:
	test/stdc/test.math.ci:47: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:48'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.references:
	test/stdc/test.math.ci:48: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:50'
.value: 10
.references:
	test/stdc/test.math.ci:57: referenced as `testMathEval_x`
	test/stdc/test.math.ci:56: referenced as `testMathEval_x`
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(testMathEval_x)
.references:
	test/stdc/test.math.ci:51: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(testMathEval_x, 1.000000))
.references:
	test/stdc/test.math.ci:52: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:53: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:54: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:55: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:56'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:56: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:57'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:57: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.sin(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:59: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.cos(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:60: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.tan(float64(Math.pi / (4)))
.references:
	test/stdc/test.math.ci:61: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2940>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:62'
.value: Math.sinh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:62: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.cosh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:63: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2956>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:65'
.value: Math.asin(0.200000)
.references:
	test/stdc/test.math.ci:65: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:66'
.value: Math.acos(0.200000)
.references:
	test/stdc/test.math.ci:66: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2968>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:69'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:69: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2972>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:70'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:70: defined as `testMathCmp_f64`
}
.main: function {
.kind: static function
.base: `function`
.size: 10408
.offset: <@046c78>
.name: '.main'
.print: '.main'
.field typename: typename (size: 136, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000a0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000130>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001c0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000250>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@0002e0>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000370>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000400>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000490>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@000520>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0005b0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000640>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0006d0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000760>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0007f0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000880>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000910>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@0009a8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000eb8>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000f48>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@0052b0>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0061f0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0069f0>, cast: static const inline)
.field System: typename (size: 0, offs: <@007538>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00e088>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@045958>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@00eca0>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@016630>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@046168>, cast: static const function)
.field Complex: function (size: 7, offs: <@046170>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@046178>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@0461f8>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@046218>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@046280>, cast: static const function)
.field indexOf: function (size: 50, offs: <@0462a8>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@0462e0>, cast: static const function)
.field startsWith: function (size: 73, offs: <@046318>, cast: static const function)
.field endsWith: function (size: 126, offs: <@046368>, cast: static const function)
.field compare: function (size: 63, offs: <@0463e8>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@046470>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@046498>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@01df80>, cast: static const typename(val))
.field append: function (size: 84, offs: <@0464a8>, cast: static const function)
.field append: function (size: 657, offs: <@046510>, cast: static const function)
.field append: function (size: 23, offs: <@0467a8>, cast: static const function)
.field append: function (size: 49, offs: <@0467c0>, cast: static const function)
.field append: function (size: 25, offs: <@046808>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@01fcd8>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@046828>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@020510>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@046830>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@023220>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@046840>, cast: static const function)
.field mat4f: function (size: 21, offs: <@046878>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@046890>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@02a580>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@02a690>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@046a38>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@046a40>, cast: static const function)
.field funAdd: function (size: 8, offs: <@046a48>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@046a50>, cast: static const function)
.field fib: function (size: 54, offs: <@046a58>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@02fa50>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@02fb60>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@046a90>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@046a98>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@046ab0>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@046ac0>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@046b08>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@046b18>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@046b20>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@046b28>, cast: static const function)
.field nthArray: function (size: 12, offs: <@046b38>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@046b48>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@036360>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@036d58>, cast: static const typename(val))
.field globalFunction: function (size: 8, offs: <@046bf8>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field customPrint: function (size: 40, offs: <@046c00>, cast: static const function)
.field recordMethodTestCustomPrint: RecordMethodTest (size: 16, offs: <+1368>, cast: variable(val))
.field print: function (size: 40, offs: <@046c28>, cast: static const function)
.field printStatic: function (size: 40, offs: <@046c50>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@038730>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@038950>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@038b70>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@038d08>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1372>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1376>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1380>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1384>, cast: variable(val))
.field blue: color (size: 4, offs: <+1388>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@039138>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@0394f0>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0398a8>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@039c60>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@03a018>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@03a3d0>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1392>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1428>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1432>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1436>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1440>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1488>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1492>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1496>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1500>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1516>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1520>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1524>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1528>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1576>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1580>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1584>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1588>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1604>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1608>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1612>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1616>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1664>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1668>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1672>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1676>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1692>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1696>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1700>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1704>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1752>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1756>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1760>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1764>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1780>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1784>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1788>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1792>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1840>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1844>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1848>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1852>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1868>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1872>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1876>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1880>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1928>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1932>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1936>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1940>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1956>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1960>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1964>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1968>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2016>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2020>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2024>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2028>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2044>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2048>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2052>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2056>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2168>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2176>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2192>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2196>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2200>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2204>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2316>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2324>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2340>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2344>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2348>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2352>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2376>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2380>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2384>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2388>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2404>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2408>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2412>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2416>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2480>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2488>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2504>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2508>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2520>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2524>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2528>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2532>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2536>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2540>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathSmooth_0f: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathSmooth_0F: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2940>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2956>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2968>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2972>, cast: variable(bool))
.field .main: function (size: 10408, offs: <@046c78>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static const sign(x: float32): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const sign(x: float64): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static deg2rad(x: float64): float64 := float64(float64(float64(x * pi) / (180)));
			static rad2deg(x: float64): float64 := float64(float64(float64(x * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				x: float64;
				y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				.anonymous: .anonymous;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				data: float32[16];
				.anonymous: .anonymous;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 5;
			static const globalConstant: int32 := 6;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 51);
				void(globalRecInit.constant := 52);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 61);
				void(globalConstantRec.constant := 62);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 6);
			void(recordMemberTest.constant := 7);
			void(recordMemberTest.memberInit := 8);
			void(recordMemberTest.constantInit := 9);
			void(recordMemberTest.memberRec.member := 61);
			void(recordMemberTest.memberRec.constant := 62);
			void(recordMemberTest.constantRec.member := 71);
			void(recordMemberTest.constantRec.constant := 72);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x + y));
			};
			static forwardMethod(x: int32, y: int32): int32 := forwardMethod;
			abstractMethod(x: int32, y: int32): int32;
			delegateMethod(x: int32, y: int32): int32 := forwardMethod;
			const virtualMethod(x: int32, y: int32): int32 := virtualMethod;
			static const virtualMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			static const forwardMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			const print(this: RecordMethodTest): void := print;
			static const print(this: RecordMethodTest): void := {
				trace("virtual");
			};
			static const printStatic(this: RecordMethodTest): void := {
				trace("static");
			};
		};
		static const globalFunction(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.delegateMethod := globalFunction);
			void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
			void(recordMethodTest.print := print);
		};
		static const customPrint(this: RecordMethodTest): void := {
			trace("override");
		};
		recordMethodTestCustomPrint: RecordMethodTest := {
			void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
			void(recordMethodTestCustomPrint.print := customPrint);
			void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
			void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
		};
		recordMethodTest.print(recordMethodTest);
		recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
		recordMethodTest.printStatic(recordMethodTest);
		static const print(this: RecordMethodTest): void := {
			trace("extension");
		};
		static const printStatic(this: RecordMethodTest): void := {
			trace("extension");
		};
		print(recordMethodTest);
		printStatic(recordMethodTest);
		print(recordMethodTestCustomPrint);
		RecordMethodTest.print(recordMethodTest);
		RecordMethodTest.printStatic(recordMethodTest);
		RecordMethodTest.print(recordMethodTestCustomPrint);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_0f: float64 := Math.smooth(0.000000);
		testMathSmooth_0F: float64 := Math.smooth(0.000000);
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
	}
}
.instructions: (10408 bytes: <@046c78> - <@049520>)
	lib/std/string.ci:130: (14 bytes: <@046c78> - <@046c86>): static const whiteSpace: char[] := " \t\n\r"
	<.main @046c78>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @046c7d>    : 1f 50 b0 01 00             load.ref <@01b050> ;" \t\n\r"
	<.main+10 @046c82>   : 2d 00 65 04                store.m64 <@046500> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes: <@046c86> - <@046c94>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @046c86>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @046c8b>   : 1f 61 b0 01 00             load.ref <@01b061> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @046c90>   : 2d 08 65 04                store.m64 <@046508> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes: <@046c94> - <@046cae>): static const format: FormatFlags := {...}
	<.main+28 @046c94>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @046c99>   : 2e f8 67 04                store.m32 <@0467f8> ;append.format
	:: (7 bytes: <@046c9d> - <@046ca4>): void(format.padChr := (0))
	<.main+37 @046c9d>   : 19                         load.z32
	<.main+38 @046c9e>   : 1f fc 67 04 00             load.ref <@0467fc> ;append.format+4
	<.main+43 @046ca3>   : 25                         store.i8
	:: (5 bytes: <@046ca4> - <@046ca9>): void(format.padLen := 0)
	<.main+44 @046ca4>   : 19                         load.z32
	<.main+45 @046ca5>   : 2e 00 68 04                store.m32 <@046800> ;append.format+8
	:: (5 bytes: <@046ca9> - <@046cae>): void(format.precision := 0)
	<.main+49 @046ca9>   : 19                         load.z32
	<.main+50 @046caa>   : 2e 04 68 04                store.m32 <@046804> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@046cae> - <@046cbb>): static value: int64 := 42
	<.main+54 @046cae>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @046cb7>   : 2d 38 6a 04                store.m64 <@046a38> ;value
	test/lang/member.ci:35: (5 bytes: <@046cbb> - <@046cc0>): static global: int32
	<.main+67 @046cbb>   : 19                         load.z32
	<.main+68 @046cbc>   : 2e 58 6b 04                store.m32 <@046b58> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@046cc0> - <@046cc9>): static globalInit: int32 := 5
	<.main+72 @046cc0>   : 1c 05 00 00 00             load.c32 5
	<.main+77 @046cc5>   : 2e 60 6b 04                store.m32 <@046b60> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@046cc9> - <@046cd2>): static const globalConstant: int32 := 6
	<.main+81 @046cc9>   : 1c 06 00 00 00             load.c32 6
	<.main+86 @046cce>   : 2e 68 6b 04                store.m32 <@046b68> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@046cd2> - <@046ce4>): static globalRecInit: Inner := {...}
	<.main+90 @046cd2>   : 1c 33 00 00 00             load.c32 51
	<.main+95 @046cd7>   : 2e 78 6b 04                store.m32 <@046b78> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@046cdb> - <@046ce4>): void(globalRecInit.constant := 52);
	<.main+99 @046cdb>   : 1c 34 00 00 00             load.c32 52
	<.main+104 @046ce0>  : 2e 7c 6b 04                store.m32 <@046b7c> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@046ce4> - <@046cf6>): static const globalConstantRec: Inner := {...}
	<.main+108 @046ce4>  : 1c 3d 00 00 00             load.c32 61
	<.main+113 @046ce9>  : 2e 80 6b 04                store.m32 <@046b80> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@046ced> - <@046cf6>): void(globalConstantRec.constant := 62);
	<.main+117 @046ced>  : 1c 3e 00 00 00             load.c32 62
	<.main+122 @046cf2>  : 2e 84 6b 04                store.m32 <@046b84> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:12: (9 bytes: <@046cf6> - <@046cff>): static forwardMethod(x: int32, y: int32): int32 := forwardMethod
	<.main+126 @046cf6>  : 1f a0 6b 04 00             load.ref <@046ba0> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+131 @046cfb>  : 2e 90 6b 04                store.m32 <@046b90> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	test/lang/emit.ci:3: (1 byte: <@046cff> - <@046d00>): emitldz32: int32 := emit(load.z32)
	<.main+135 @046cff>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@046d00> - <@046d01>): emitldz64: int64 := emit(load.z64)
	<.main+136 @046d00>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@046d01> - <@046d06>): emitA: int32 := 42
	<.main+137 @046d01>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@046d06> - <@046d0b>): emitB: int32 := 96
	<.main+142 @046d06>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@046d0b> - <@046d10>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @046d0b>  : 10 01                      dup.x1 sp(1)
	<.main+149 @046d0d>  : 10 01                      dup.x1 sp(1)
	<.main+151 @046d0f>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@046d10> - <@046d1b>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @046d10>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @046d15>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @046d1a>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@046d1b> - <@046d20>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @046d1b>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@046d20> - <@046d26>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @046d20>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @046d25>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@046d26> - <@046d30>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @046d26>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @046d2f>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@046d30> - <@046d39>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @046d30>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@046d39> - <@046d43>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @046d39>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @046d3e>  : 1f 54 51 02 00             load.ref <@025154> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@046d43> - <@046d48>): i3: int32 := 3
	<.main+203 @046d43>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@046d48> - <@046d4d>): i6: int32 := 6
	<.main+208 @046d48>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@046d4d> - <@046d52>): i2: int32 := 2
	<.main+213 @046d4d>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@046d52> - <@046d57>): i8: int32 := 8
	<.main+218 @046d52>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@046d57> - <@046d58>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @046d57>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@046d58> - <@046d59>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @046d58>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@046d59> - <@046d5a>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @046d59>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@046d5a> - <@046d5f>): lastVal: int32 := last(void(3, 6))
	<.main+226 @046d5a>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@046d5f> - <@046d61>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @046d5f>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@046d61> - <@046d6b>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @046d61>  : 10 07                      dup.x1 sp(7)
	<.main+235 @046d63>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @046d67>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@046d6b> - <@046d74>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @046d6b>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @046d70>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@046d74> - <@046d79>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @046d74>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @046d76>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @046d78>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@046d79> - <@046d8a>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @046d79>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @046d7b>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @046d7f>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @046d81>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @046d85>  : 51                         add.i32
	<.main+270 @046d86>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@046d8a> - <@046da2>): any2Val: int32 := any(void(3, 6))
	<.main+274 @046d8a>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @046d8f>  : 10 00                      dup.x1 sp(0)
	<.main+281 @046d91>  : 06 0a 00 00                jz <.main+291 @046d9b>
	<.main+285 @046d95>  : 10 00                      dup.x1 sp(0)
	<.main+287 @046d97>  : 04 09 00 00                jmp <.main+296 @046da0>
	<.main+291 @046d9b>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @046da0>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@046da2> - <@046db4>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @046da2>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @046da4>  : 10 00                      dup.x1 sp(0)
	<.main+302 @046da6>  : 06 0a 00 00                jz <.main+312 @046db0>
	<.main+306 @046daa>  : 10 00                      dup.x1 sp(0)
	<.main+308 @046dac>  : 04 06 00 00                jmp <.main+314 @046db2>
	<.main+312 @046db0>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @046db2>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@046db4> - <@046dd2>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @046db4>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @046db6>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @046dba>  : 10 00                      dup.x1 sp(0)
	<.main+324 @046dbc>  : 06 0a 00 00                jz <.main+334 @046dc6>
	<.main+328 @046dc0>  : 10 00                      dup.x1 sp(0)
	<.main+330 @046dc2>  : 04 0a 00 00                jmp <.main+340 @046dcc>
	<.main+334 @046dc6>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @046dc8>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @046dcc>  : 13 01                      set.x1 sp(1)
	<.main+342 @046dce>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@046dd2> - <@046df3>): min2Val: int32 := min(void(3, 6))
	<.main+346 @046dd2>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @046dd7>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @046ddc>  : 10 01                      dup.x1 sp(1)
	<.main+358 @046dde>  : 10 01                      dup.x1 sp(1)
	<.main+360 @046de0>  : 58                         clt.i32
	<.main+361 @046de1>  : 06 0a 00 00                jz <.main+371 @046deb>
	<.main+365 @046de5>  : 10 01                      dup.x1 sp(1)
	<.main+367 @046de7>  : 04 06 00 00                jmp <.main+373 @046ded>
	<.main+371 @046deb>  : 10 00                      dup.x1 sp(0)
	<.main+373 @046ded>  : 13 02                      set.x1 sp(2)
	<.main+375 @046def>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@046df3> - <@046e0e>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @046df3>  : 10 10                      dup.x1 sp(16)
	<.main+381 @046df5>  : 10 10                      dup.x1 sp(16)
	<.main+383 @046df7>  : 10 01                      dup.x1 sp(1)
	<.main+385 @046df9>  : 10 01                      dup.x1 sp(1)
	<.main+387 @046dfb>  : 58                         clt.i32
	<.main+388 @046dfc>  : 06 0a 00 00                jz <.main+398 @046e06>
	<.main+392 @046e00>  : 10 01                      dup.x1 sp(1)
	<.main+394 @046e02>  : 04 06 00 00                jmp <.main+400 @046e08>
	<.main+398 @046e06>  : 10 00                      dup.x1 sp(0)
	<.main+400 @046e08>  : 13 02                      set.x1 sp(2)
	<.main+402 @046e0a>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@046e0e> - <@046e35>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @046e0e>  : 10 11                      dup.x1 sp(17)
	<.main+408 @046e10>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @046e14>  : 10 11                      dup.x1 sp(17)
	<.main+414 @046e16>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @046e1a>  : 10 01                      dup.x1 sp(1)
	<.main+420 @046e1c>  : 10 01                      dup.x1 sp(1)
	<.main+422 @046e1e>  : 58                         clt.i32
	<.main+423 @046e1f>  : 06 0a 00 00                jz <.main+433 @046e29>
	<.main+427 @046e23>  : 10 01                      dup.x1 sp(1)
	<.main+429 @046e25>  : 04 06 00 00                jmp <.main+435 @046e2b>
	<.main+433 @046e29>  : 10 00                      dup.x1 sp(0)
	<.main+435 @046e2b>  : 13 02                      set.x1 sp(2)
	<.main+437 @046e2d>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @046e31>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@046e35> - <@046e56>): max2Val: int32 := max(void(3, 6))
	<.main+445 @046e35>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @046e3a>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @046e3f>  : 10 01                      dup.x1 sp(1)
	<.main+457 @046e41>  : 10 01                      dup.x1 sp(1)
	<.main+459 @046e43>  : 59                         cgt.i32
	<.main+460 @046e44>  : 06 0a 00 00                jz <.main+470 @046e4e>
	<.main+464 @046e48>  : 10 01                      dup.x1 sp(1)
	<.main+466 @046e4a>  : 04 06 00 00                jmp <.main+472 @046e50>
	<.main+470 @046e4e>  : 10 00                      dup.x1 sp(0)
	<.main+472 @046e50>  : 13 02                      set.x1 sp(2)
	<.main+474 @046e52>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@046e56> - <@046e71>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @046e56>  : 10 13                      dup.x1 sp(19)
	<.main+480 @046e58>  : 10 13                      dup.x1 sp(19)
	<.main+482 @046e5a>  : 10 01                      dup.x1 sp(1)
	<.main+484 @046e5c>  : 10 01                      dup.x1 sp(1)
	<.main+486 @046e5e>  : 59                         cgt.i32
	<.main+487 @046e5f>  : 06 0a 00 00                jz <.main+497 @046e69>
	<.main+491 @046e63>  : 10 01                      dup.x1 sp(1)
	<.main+493 @046e65>  : 04 06 00 00                jmp <.main+499 @046e6b>
	<.main+497 @046e69>  : 10 00                      dup.x1 sp(0)
	<.main+499 @046e6b>  : 13 02                      set.x1 sp(2)
	<.main+501 @046e6d>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@046e71> - <@046e98>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @046e71>  : 10 14                      dup.x1 sp(20)
	<.main+507 @046e73>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @046e77>  : 10 14                      dup.x1 sp(20)
	<.main+513 @046e79>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @046e7d>  : 10 01                      dup.x1 sp(1)
	<.main+519 @046e7f>  : 10 01                      dup.x1 sp(1)
	<.main+521 @046e81>  : 59                         cgt.i32
	<.main+522 @046e82>  : 06 0a 00 00                jz <.main+532 @046e8c>
	<.main+526 @046e86>  : 10 01                      dup.x1 sp(1)
	<.main+528 @046e88>  : 04 06 00 00                jmp <.main+534 @046e8e>
	<.main+532 @046e8c>  : 10 00                      dup.x1 sp(0)
	<.main+534 @046e8e>  : 13 02                      set.x1 sp(2)
	<.main+536 @046e90>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @046e94>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@046e98> - <@046ead>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @046e98>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @046e9d>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @046ea2>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @046ea7>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @046eab>  : 51                         add.i32
	<.main+564 @046eac>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@046ead> - <@046ebe>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @046ead>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @046eb2>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @046eb6>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @046eba>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@046ebe> - <@046ec9>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @046ebe>  : 10 17                      dup.x1 sp(23)
	<.main+584 @046ec0>  : 10 17                      dup.x1 sp(23)
	<.main+586 @046ec2>  : 10 17                      dup.x1 sp(23)
	<.main+588 @046ec4>  : 10 17                      dup.x1 sp(23)
	<.main+590 @046ec6>  : 51                         add.i32
	<.main+591 @046ec7>  : 51                         add.i32
	<.main+592 @046ec8>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@046ec9> - <@046ed4>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @046ec9>  : 10 18                      dup.x1 sp(24)
	<.main+595 @046ecb>  : 10 18                      dup.x1 sp(24)
	<.main+597 @046ecd>  : 51                         add.i32
	<.main+598 @046ece>  : 10 17                      dup.x1 sp(23)
	<.main+600 @046ed0>  : 51                         add.i32
	<.main+601 @046ed1>  : 10 16                      dup.x1 sp(22)
	<.main+603 @046ed3>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@046ed4> - <@046ef3>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @046ed4>  : 10 19                      dup.x1 sp(25)
	<.main+606 @046ed6>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @046eda>  : 10 19                      dup.x1 sp(25)
	<.main+612 @046edc>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @046ee0>  : 10 19                      dup.x1 sp(25)
	<.main+618 @046ee2>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @046ee6>  : 10 19                      dup.x1 sp(25)
	<.main+624 @046ee8>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @046eec>  : 51                         add.i32
	<.main+629 @046eed>  : 51                         add.i32
	<.main+630 @046eee>  : 51                         add.i32
	<.main+631 @046eef>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@046ef3> - <@046f12>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @046ef3>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @046ef5>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @046ef9>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @046efb>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @046eff>  : 51                         add.i32
	<.main+648 @046f00>  : 10 19                      dup.x1 sp(25)
	<.main+650 @046f02>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @046f06>  : 51                         add.i32
	<.main+655 @046f07>  : 10 18                      dup.x1 sp(24)
	<.main+657 @046f09>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @046f0d>  : 51                         add.i32
	<.main+662 @046f0e>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@046f12> - <@046f50>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @046f12>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @046f17>  : 10 00                      dup.x1 sp(0)
	<.main+673 @046f19>  : 06 0a 00 00                jz <.main+683 @046f23>
	<.main+677 @046f1d>  : 10 00                      dup.x1 sp(0)
	<.main+679 @046f1f>  : 04 2f 00 00                jmp <.main+726 @046f4e>
	<.main+683 @046f23>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @046f28>  : 10 00                      dup.x1 sp(0)
	<.main+690 @046f2a>  : 06 0a 00 00                jz <.main+700 @046f34>
	<.main+694 @046f2e>  : 10 00                      dup.x1 sp(0)
	<.main+696 @046f30>  : 04 1c 00 00                jmp <.main+724 @046f4c>
	<.main+700 @046f34>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @046f39>  : 10 00                      dup.x1 sp(0)
	<.main+707 @046f3b>  : 06 0a 00 00                jz <.main+717 @046f45>
	<.main+711 @046f3f>  : 10 00                      dup.x1 sp(0)
	<.main+713 @046f41>  : 04 09 00 00                jmp <.main+722 @046f4a>
	<.main+717 @046f45>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @046f4a>  : 13 01                      set.x1 sp(1)
	<.main+724 @046f4c>  : 13 01                      set.x1 sp(1)
	<.main+726 @046f4e>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@046f50> - <@046f8e>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @046f50>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @046f55>  : 10 00                      dup.x1 sp(0)
	<.main+735 @046f57>  : 06 0a 00 00                jz <.main+745 @046f61>
	<.main+739 @046f5b>  : 10 00                      dup.x1 sp(0)
	<.main+741 @046f5d>  : 04 09 00 00                jmp <.main+750 @046f66>
	<.main+745 @046f61>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @046f66>  : 13 01                      set.x1 sp(1)
	<.main+752 @046f68>  : 10 00                      dup.x1 sp(0)
	<.main+754 @046f6a>  : 06 0a 00 00                jz <.main+764 @046f74>
	<.main+758 @046f6e>  : 10 00                      dup.x1 sp(0)
	<.main+760 @046f70>  : 04 09 00 00                jmp <.main+769 @046f79>
	<.main+764 @046f74>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @046f79>  : 13 01                      set.x1 sp(1)
	<.main+771 @046f7b>  : 10 00                      dup.x1 sp(0)
	<.main+773 @046f7d>  : 06 0a 00 00                jz <.main+783 @046f87>
	<.main+777 @046f81>  : 10 00                      dup.x1 sp(0)
	<.main+779 @046f83>  : 04 09 00 00                jmp <.main+788 @046f8c>
	<.main+783 @046f87>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @046f8c>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@046f8e> - <@046fc0>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @046f8e>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @046f90>  : 10 00                      dup.x1 sp(0)
	<.main+794 @046f92>  : 06 0a 00 00                jz <.main+804 @046f9c>
	<.main+798 @046f96>  : 10 00                      dup.x1 sp(0)
	<.main+800 @046f98>  : 04 26 00 00                jmp <.main+838 @046fbe>
	<.main+804 @046f9c>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @046f9e>  : 10 00                      dup.x1 sp(0)
	<.main+808 @046fa0>  : 06 0a 00 00                jz <.main+818 @046faa>
	<.main+812 @046fa4>  : 10 00                      dup.x1 sp(0)
	<.main+814 @046fa6>  : 04 16 00 00                jmp <.main+836 @046fbc>
	<.main+818 @046faa>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @046fac>  : 10 00                      dup.x1 sp(0)
	<.main+822 @046fae>  : 06 0a 00 00                jz <.main+832 @046fb8>
	<.main+826 @046fb2>  : 10 00                      dup.x1 sp(0)
	<.main+828 @046fb4>  : 04 06 00 00                jmp <.main+834 @046fba>
	<.main+832 @046fb8>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @046fba>  : 13 01                      set.x1 sp(1)
	<.main+836 @046fbc>  : 13 01                      set.x1 sp(1)
	<.main+838 @046fbe>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@046fc0> - <@046ff2>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @046fc0>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @046fc2>  : 10 00                      dup.x1 sp(0)
	<.main+844 @046fc4>  : 06 0a 00 00                jz <.main+854 @046fce>
	<.main+848 @046fc8>  : 10 00                      dup.x1 sp(0)
	<.main+850 @046fca>  : 04 06 00 00                jmp <.main+856 @046fd0>
	<.main+854 @046fce>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @046fd0>  : 13 01                      set.x1 sp(1)
	<.main+858 @046fd2>  : 10 00                      dup.x1 sp(0)
	<.main+860 @046fd4>  : 06 0a 00 00                jz <.main+870 @046fde>
	<.main+864 @046fd8>  : 10 00                      dup.x1 sp(0)
	<.main+866 @046fda>  : 04 06 00 00                jmp <.main+872 @046fe0>
	<.main+870 @046fde>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @046fe0>  : 13 01                      set.x1 sp(1)
	<.main+874 @046fe2>  : 10 00                      dup.x1 sp(0)
	<.main+876 @046fe4>  : 06 0a 00 00                jz <.main+886 @046fee>
	<.main+880 @046fe8>  : 10 00                      dup.x1 sp(0)
	<.main+882 @046fea>  : 04 06 00 00                jmp <.main+888 @046ff0>
	<.main+886 @046fee>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @046ff0>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@046ff2> - <@047038>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @046ff2>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @046ff4>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @046ff8>  : 10 00                      dup.x1 sp(0)
	<.main+898 @046ffa>  : 06 0a 00 00                jz <.main+908 @047004>
	<.main+902 @046ffe>  : 10 00                      dup.x1 sp(0)
	<.main+904 @047000>  : 04 32 00 00                jmp <.main+954 @047032>
	<.main+908 @047004>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @047006>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @04700a>  : 10 00                      dup.x1 sp(0)
	<.main+916 @04700c>  : 06 0a 00 00                jz <.main+926 @047016>
	<.main+920 @047010>  : 10 00                      dup.x1 sp(0)
	<.main+922 @047012>  : 04 1e 00 00                jmp <.main+952 @047030>
	<.main+926 @047016>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @047018>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @04701c>  : 10 00                      dup.x1 sp(0)
	<.main+934 @04701e>  : 06 0a 00 00                jz <.main+944 @047028>
	<.main+938 @047022>  : 10 00                      dup.x1 sp(0)
	<.main+940 @047024>  : 04 0a 00 00                jmp <.main+950 @04702e>
	<.main+944 @047028>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @04702a>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @04702e>  : 13 01                      set.x1 sp(1)
	<.main+952 @047030>  : 13 01                      set.x1 sp(1)
	<.main+954 @047032>  : 13 01                      set.x1 sp(1)
	<.main+956 @047034>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@047038> - <@04707e>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @047038>  : 10 20                      dup.x1 sp(32)
	<.main+962 @04703a>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @04703e>  : 10 00                      dup.x1 sp(0)
	<.main+968 @047040>  : 06 0a 00 00                jz <.main+978 @04704a>
	<.main+972 @047044>  : 10 00                      dup.x1 sp(0)
	<.main+974 @047046>  : 04 0a 00 00                jmp <.main+984 @047050>
	<.main+978 @04704a>  : 10 20                      dup.x1 sp(32)
	<.main+980 @04704c>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @047050>  : 13 01                      set.x1 sp(1)
	<.main+986 @047052>  : 10 00                      dup.x1 sp(0)
	<.main+988 @047054>  : 06 0a 00 00                jz <.main+998 @04705e>
	<.main+992 @047058>  : 10 00                      dup.x1 sp(0)
	<.main+994 @04705a>  : 04 0a 00 00                jmp <.main+1004 @047064>
	<.main+998 @04705e>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @047060> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @047064> : 13 01                      set.x1 sp(1)
	<.main+1006 @047066> : 10 00                      dup.x1 sp(0)
	<.main+1008 @047068> : 06 0a 00 00                jz <.main+1018 @047072>
	<.main+1012 @04706c> : 10 00                      dup.x1 sp(0)
	<.main+1014 @04706e> : 04 0a 00 00                jmp <.main+1024 @047078>
	<.main+1018 @047072> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @047074> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @047078> : 13 01                      set.x1 sp(1)
	<.main+1026 @04707a> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@04707e> - <@0470d7>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @04707e> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @047083> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @047088> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @04708d> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @047092> : 10 01                      dup.x1 sp(1)
	<.main+1052 @047094> : 10 01                      dup.x1 sp(1)
	<.main+1054 @047096> : 58                         clt.i32
	<.main+1055 @047097> : 06 0a 00 00                jz <.main+1065 @0470a1>
	<.main+1059 @04709b> : 10 01                      dup.x1 sp(1)
	<.main+1061 @04709d> : 04 06 00 00                jmp <.main+1067 @0470a3>
	<.main+1065 @0470a1> : 10 00                      dup.x1 sp(0)
	<.main+1067 @0470a3> : 13 02                      set.x1 sp(2)
	<.main+1069 @0470a5> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @0470a9> : 10 01                      dup.x1 sp(1)
	<.main+1075 @0470ab> : 10 01                      dup.x1 sp(1)
	<.main+1077 @0470ad> : 58                         clt.i32
	<.main+1078 @0470ae> : 06 0a 00 00                jz <.main+1088 @0470b8>
	<.main+1082 @0470b2> : 10 01                      dup.x1 sp(1)
	<.main+1084 @0470b4> : 04 06 00 00                jmp <.main+1090 @0470ba>
	<.main+1088 @0470b8> : 10 00                      dup.x1 sp(0)
	<.main+1090 @0470ba> : 13 02                      set.x1 sp(2)
	<.main+1092 @0470bc> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @0470c0> : 10 01                      dup.x1 sp(1)
	<.main+1098 @0470c2> : 10 01                      dup.x1 sp(1)
	<.main+1100 @0470c4> : 58                         clt.i32
	<.main+1101 @0470c5> : 06 0a 00 00                jz <.main+1111 @0470cf>
	<.main+1105 @0470c9> : 10 01                      dup.x1 sp(1)
	<.main+1107 @0470cb> : 04 06 00 00                jmp <.main+1113 @0470d1>
	<.main+1111 @0470cf> : 10 00                      dup.x1 sp(0)
	<.main+1113 @0470d1> : 13 02                      set.x1 sp(2)
	<.main+1115 @0470d3> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@0470d7> - <@047130>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @0470d7> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @0470dc> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @0470e1> : 10 01                      dup.x1 sp(1)
	<.main+1131 @0470e3> : 10 01                      dup.x1 sp(1)
	<.main+1133 @0470e5> : 58                         clt.i32
	<.main+1134 @0470e6> : 06 0a 00 00                jz <.main+1144 @0470f0>
	<.main+1138 @0470ea> : 10 01                      dup.x1 sp(1)
	<.main+1140 @0470ec> : 04 06 00 00                jmp <.main+1146 @0470f2>
	<.main+1144 @0470f0> : 10 00                      dup.x1 sp(0)
	<.main+1146 @0470f2> : 13 02                      set.x1 sp(2)
	<.main+1148 @0470f4> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @0470f8> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @0470fd> : 10 01                      dup.x1 sp(1)
	<.main+1159 @0470ff> : 10 01                      dup.x1 sp(1)
	<.main+1161 @047101> : 58                         clt.i32
	<.main+1162 @047102> : 06 0a 00 00                jz <.main+1172 @04710c>
	<.main+1166 @047106> : 10 01                      dup.x1 sp(1)
	<.main+1168 @047108> : 04 06 00 00                jmp <.main+1174 @04710e>
	<.main+1172 @04710c> : 10 00                      dup.x1 sp(0)
	<.main+1174 @04710e> : 13 02                      set.x1 sp(2)
	<.main+1176 @047110> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @047114> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @047119> : 10 01                      dup.x1 sp(1)
	<.main+1187 @04711b> : 10 01                      dup.x1 sp(1)
	<.main+1189 @04711d> : 58                         clt.i32
	<.main+1190 @04711e> : 06 0a 00 00                jz <.main+1200 @047128>
	<.main+1194 @047122> : 10 01                      dup.x1 sp(1)
	<.main+1196 @047124> : 04 06 00 00                jmp <.main+1202 @04712a>
	<.main+1200 @047128> : 10 00                      dup.x1 sp(0)
	<.main+1202 @04712a> : 13 02                      set.x1 sp(2)
	<.main+1204 @04712c> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@047130> - <@04717d>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @047130> : 10 23                      dup.x1 sp(35)
	<.main+1210 @047132> : 10 23                      dup.x1 sp(35)
	<.main+1212 @047134> : 10 23                      dup.x1 sp(35)
	<.main+1214 @047136> : 10 23                      dup.x1 sp(35)
	<.main+1216 @047138> : 10 01                      dup.x1 sp(1)
	<.main+1218 @04713a> : 10 01                      dup.x1 sp(1)
	<.main+1220 @04713c> : 58                         clt.i32
	<.main+1221 @04713d> : 06 0a 00 00                jz <.main+1231 @047147>
	<.main+1225 @047141> : 10 01                      dup.x1 sp(1)
	<.main+1227 @047143> : 04 06 00 00                jmp <.main+1233 @047149>
	<.main+1231 @047147> : 10 00                      dup.x1 sp(0)
	<.main+1233 @047149> : 13 02                      set.x1 sp(2)
	<.main+1235 @04714b> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @04714f> : 10 01                      dup.x1 sp(1)
	<.main+1241 @047151> : 10 01                      dup.x1 sp(1)
	<.main+1243 @047153> : 58                         clt.i32
	<.main+1244 @047154> : 06 0a 00 00                jz <.main+1254 @04715e>
	<.main+1248 @047158> : 10 01                      dup.x1 sp(1)
	<.main+1250 @04715a> : 04 06 00 00                jmp <.main+1256 @047160>
	<.main+1254 @04715e> : 10 00                      dup.x1 sp(0)
	<.main+1256 @047160> : 13 02                      set.x1 sp(2)
	<.main+1258 @047162> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @047166> : 10 01                      dup.x1 sp(1)
	<.main+1264 @047168> : 10 01                      dup.x1 sp(1)
	<.main+1266 @04716a> : 58                         clt.i32
	<.main+1267 @04716b> : 06 0a 00 00                jz <.main+1277 @047175>
	<.main+1271 @04716f> : 10 01                      dup.x1 sp(1)
	<.main+1273 @047171> : 04 06 00 00                jmp <.main+1279 @047177>
	<.main+1277 @047175> : 10 00                      dup.x1 sp(0)
	<.main+1279 @047177> : 13 02                      set.x1 sp(2)
	<.main+1281 @047179> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@04717d> - <@0471ca>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @04717d> : 10 24                      dup.x1 sp(36)
	<.main+1287 @04717f> : 10 24                      dup.x1 sp(36)
	<.main+1289 @047181> : 10 01                      dup.x1 sp(1)
	<.main+1291 @047183> : 10 01                      dup.x1 sp(1)
	<.main+1293 @047185> : 58                         clt.i32
	<.main+1294 @047186> : 06 0a 00 00                jz <.main+1304 @047190>
	<.main+1298 @04718a> : 10 01                      dup.x1 sp(1)
	<.main+1300 @04718c> : 04 06 00 00                jmp <.main+1306 @047192>
	<.main+1304 @047190> : 10 00                      dup.x1 sp(0)
	<.main+1306 @047192> : 13 02                      set.x1 sp(2)
	<.main+1308 @047194> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @047198> : 10 23                      dup.x1 sp(35)
	<.main+1314 @04719a> : 10 01                      dup.x1 sp(1)
	<.main+1316 @04719c> : 10 01                      dup.x1 sp(1)
	<.main+1318 @04719e> : 58                         clt.i32
	<.main+1319 @04719f> : 06 0a 00 00                jz <.main+1329 @0471a9>
	<.main+1323 @0471a3> : 10 01                      dup.x1 sp(1)
	<.main+1325 @0471a5> : 04 06 00 00                jmp <.main+1331 @0471ab>
	<.main+1329 @0471a9> : 10 00                      dup.x1 sp(0)
	<.main+1331 @0471ab> : 13 02                      set.x1 sp(2)
	<.main+1333 @0471ad> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @0471b1> : 10 22                      dup.x1 sp(34)
	<.main+1339 @0471b3> : 10 01                      dup.x1 sp(1)
	<.main+1341 @0471b5> : 10 01                      dup.x1 sp(1)
	<.main+1343 @0471b7> : 58                         clt.i32
	<.main+1344 @0471b8> : 06 0a 00 00                jz <.main+1354 @0471c2>
	<.main+1348 @0471bc> : 10 01                      dup.x1 sp(1)
	<.main+1350 @0471be> : 04 06 00 00                jmp <.main+1356 @0471c4>
	<.main+1354 @0471c2> : 10 00                      dup.x1 sp(0)
	<.main+1356 @0471c4> : 13 02                      set.x1 sp(2)
	<.main+1358 @0471c6> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@0471ca> - <@04722b>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @0471ca> : 10 25                      dup.x1 sp(37)
	<.main+1364 @0471cc> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @0471d0> : 10 25                      dup.x1 sp(37)
	<.main+1370 @0471d2> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @0471d6> : 10 25                      dup.x1 sp(37)
	<.main+1376 @0471d8> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @0471dc> : 10 25                      dup.x1 sp(37)
	<.main+1382 @0471de> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @0471e2> : 10 01                      dup.x1 sp(1)
	<.main+1388 @0471e4> : 10 01                      dup.x1 sp(1)
	<.main+1390 @0471e6> : 58                         clt.i32
	<.main+1391 @0471e7> : 06 0a 00 00                jz <.main+1401 @0471f1>
	<.main+1395 @0471eb> : 10 01                      dup.x1 sp(1)
	<.main+1397 @0471ed> : 04 06 00 00                jmp <.main+1403 @0471f3>
	<.main+1401 @0471f1> : 10 00                      dup.x1 sp(0)
	<.main+1403 @0471f3> : 13 02                      set.x1 sp(2)
	<.main+1405 @0471f5> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @0471f9> : 10 01                      dup.x1 sp(1)
	<.main+1411 @0471fb> : 10 01                      dup.x1 sp(1)
	<.main+1413 @0471fd> : 58                         clt.i32
	<.main+1414 @0471fe> : 06 0a 00 00                jz <.main+1424 @047208>
	<.main+1418 @047202> : 10 01                      dup.x1 sp(1)
	<.main+1420 @047204> : 04 06 00 00                jmp <.main+1426 @04720a>
	<.main+1424 @047208> : 10 00                      dup.x1 sp(0)
	<.main+1426 @04720a> : 13 02                      set.x1 sp(2)
	<.main+1428 @04720c> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @047210> : 10 01                      dup.x1 sp(1)
	<.main+1434 @047212> : 10 01                      dup.x1 sp(1)
	<.main+1436 @047214> : 58                         clt.i32
	<.main+1437 @047215> : 06 0a 00 00                jz <.main+1447 @04721f>
	<.main+1441 @047219> : 10 01                      dup.x1 sp(1)
	<.main+1443 @04721b> : 04 06 00 00                jmp <.main+1449 @047221>
	<.main+1447 @04721f> : 10 00                      dup.x1 sp(0)
	<.main+1449 @047221> : 13 02                      set.x1 sp(2)
	<.main+1451 @047223> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @047227> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@04722b> - <@04728c>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @04722b> : 10 26                      dup.x1 sp(38)
	<.main+1461 @04722d> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @047231> : 10 26                      dup.x1 sp(38)
	<.main+1467 @047233> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @047237> : 10 01                      dup.x1 sp(1)
	<.main+1473 @047239> : 10 01                      dup.x1 sp(1)
	<.main+1475 @04723b> : 58                         clt.i32
	<.main+1476 @04723c> : 06 0a 00 00                jz <.main+1486 @047246>
	<.main+1480 @047240> : 10 01                      dup.x1 sp(1)
	<.main+1482 @047242> : 04 06 00 00                jmp <.main+1488 @047248>
	<.main+1486 @047246> : 10 00                      dup.x1 sp(0)
	<.main+1488 @047248> : 13 02                      set.x1 sp(2)
	<.main+1490 @04724a> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @04724e> : 10 25                      dup.x1 sp(37)
	<.main+1496 @047250> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @047254> : 10 01                      dup.x1 sp(1)
	<.main+1502 @047256> : 10 01                      dup.x1 sp(1)
	<.main+1504 @047258> : 58                         clt.i32
	<.main+1505 @047259> : 06 0a 00 00                jz <.main+1515 @047263>
	<.main+1509 @04725d> : 10 01                      dup.x1 sp(1)
	<.main+1511 @04725f> : 04 06 00 00                jmp <.main+1517 @047265>
	<.main+1515 @047263> : 10 00                      dup.x1 sp(0)
	<.main+1517 @047265> : 13 02                      set.x1 sp(2)
	<.main+1519 @047267> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @04726b> : 10 24                      dup.x1 sp(36)
	<.main+1525 @04726d> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @047271> : 10 01                      dup.x1 sp(1)
	<.main+1531 @047273> : 10 01                      dup.x1 sp(1)
	<.main+1533 @047275> : 58                         clt.i32
	<.main+1534 @047276> : 06 0a 00 00                jz <.main+1544 @047280>
	<.main+1538 @04727a> : 10 01                      dup.x1 sp(1)
	<.main+1540 @04727c> : 04 06 00 00                jmp <.main+1546 @047282>
	<.main+1544 @047280> : 10 00                      dup.x1 sp(0)
	<.main+1546 @047282> : 13 02                      set.x1 sp(2)
	<.main+1548 @047284> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @047288> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@04728c> - <@0472e5>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @04728c> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @047291> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @047296> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @04729b> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @0472a0> : 10 01                      dup.x1 sp(1)
	<.main+1578 @0472a2> : 10 01                      dup.x1 sp(1)
	<.main+1580 @0472a4> : 59                         cgt.i32
	<.main+1581 @0472a5> : 06 0a 00 00                jz <.main+1591 @0472af>
	<.main+1585 @0472a9> : 10 01                      dup.x1 sp(1)
	<.main+1587 @0472ab> : 04 06 00 00                jmp <.main+1593 @0472b1>
	<.main+1591 @0472af> : 10 00                      dup.x1 sp(0)
	<.main+1593 @0472b1> : 13 02                      set.x1 sp(2)
	<.main+1595 @0472b3> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @0472b7> : 10 01                      dup.x1 sp(1)
	<.main+1601 @0472b9> : 10 01                      dup.x1 sp(1)
	<.main+1603 @0472bb> : 59                         cgt.i32
	<.main+1604 @0472bc> : 06 0a 00 00                jz <.main+1614 @0472c6>
	<.main+1608 @0472c0> : 10 01                      dup.x1 sp(1)
	<.main+1610 @0472c2> : 04 06 00 00                jmp <.main+1616 @0472c8>
	<.main+1614 @0472c6> : 10 00                      dup.x1 sp(0)
	<.main+1616 @0472c8> : 13 02                      set.x1 sp(2)
	<.main+1618 @0472ca> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @0472ce> : 10 01                      dup.x1 sp(1)
	<.main+1624 @0472d0> : 10 01                      dup.x1 sp(1)
	<.main+1626 @0472d2> : 59                         cgt.i32
	<.main+1627 @0472d3> : 06 0a 00 00                jz <.main+1637 @0472dd>
	<.main+1631 @0472d7> : 10 01                      dup.x1 sp(1)
	<.main+1633 @0472d9> : 04 06 00 00                jmp <.main+1639 @0472df>
	<.main+1637 @0472dd> : 10 00                      dup.x1 sp(0)
	<.main+1639 @0472df> : 13 02                      set.x1 sp(2)
	<.main+1641 @0472e1> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@0472e5> - <@04733e>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @0472e5> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @0472ea> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @0472ef> : 10 01                      dup.x1 sp(1)
	<.main+1657 @0472f1> : 10 01                      dup.x1 sp(1)
	<.main+1659 @0472f3> : 59                         cgt.i32
	<.main+1660 @0472f4> : 06 0a 00 00                jz <.main+1670 @0472fe>
	<.main+1664 @0472f8> : 10 01                      dup.x1 sp(1)
	<.main+1666 @0472fa> : 04 06 00 00                jmp <.main+1672 @047300>
	<.main+1670 @0472fe> : 10 00                      dup.x1 sp(0)
	<.main+1672 @047300> : 13 02                      set.x1 sp(2)
	<.main+1674 @047302> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @047306> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @04730b> : 10 01                      dup.x1 sp(1)
	<.main+1685 @04730d> : 10 01                      dup.x1 sp(1)
	<.main+1687 @04730f> : 59                         cgt.i32
	<.main+1688 @047310> : 06 0a 00 00                jz <.main+1698 @04731a>
	<.main+1692 @047314> : 10 01                      dup.x1 sp(1)
	<.main+1694 @047316> : 04 06 00 00                jmp <.main+1700 @04731c>
	<.main+1698 @04731a> : 10 00                      dup.x1 sp(0)
	<.main+1700 @04731c> : 13 02                      set.x1 sp(2)
	<.main+1702 @04731e> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @047322> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @047327> : 10 01                      dup.x1 sp(1)
	<.main+1713 @047329> : 10 01                      dup.x1 sp(1)
	<.main+1715 @04732b> : 59                         cgt.i32
	<.main+1716 @04732c> : 06 0a 00 00                jz <.main+1726 @047336>
	<.main+1720 @047330> : 10 01                      dup.x1 sp(1)
	<.main+1722 @047332> : 04 06 00 00                jmp <.main+1728 @047338>
	<.main+1726 @047336> : 10 00                      dup.x1 sp(0)
	<.main+1728 @047338> : 13 02                      set.x1 sp(2)
	<.main+1730 @04733a> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@04733e> - <@04738b>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @04733e> : 10 29                      dup.x1 sp(41)
	<.main+1736 @047340> : 10 29                      dup.x1 sp(41)
	<.main+1738 @047342> : 10 29                      dup.x1 sp(41)
	<.main+1740 @047344> : 10 29                      dup.x1 sp(41)
	<.main+1742 @047346> : 10 01                      dup.x1 sp(1)
	<.main+1744 @047348> : 10 01                      dup.x1 sp(1)
	<.main+1746 @04734a> : 59                         cgt.i32
	<.main+1747 @04734b> : 06 0a 00 00                jz <.main+1757 @047355>
	<.main+1751 @04734f> : 10 01                      dup.x1 sp(1)
	<.main+1753 @047351> : 04 06 00 00                jmp <.main+1759 @047357>
	<.main+1757 @047355> : 10 00                      dup.x1 sp(0)
	<.main+1759 @047357> : 13 02                      set.x1 sp(2)
	<.main+1761 @047359> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @04735d> : 10 01                      dup.x1 sp(1)
	<.main+1767 @04735f> : 10 01                      dup.x1 sp(1)
	<.main+1769 @047361> : 59                         cgt.i32
	<.main+1770 @047362> : 06 0a 00 00                jz <.main+1780 @04736c>
	<.main+1774 @047366> : 10 01                      dup.x1 sp(1)
	<.main+1776 @047368> : 04 06 00 00                jmp <.main+1782 @04736e>
	<.main+1780 @04736c> : 10 00                      dup.x1 sp(0)
	<.main+1782 @04736e> : 13 02                      set.x1 sp(2)
	<.main+1784 @047370> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @047374> : 10 01                      dup.x1 sp(1)
	<.main+1790 @047376> : 10 01                      dup.x1 sp(1)
	<.main+1792 @047378> : 59                         cgt.i32
	<.main+1793 @047379> : 06 0a 00 00                jz <.main+1803 @047383>
	<.main+1797 @04737d> : 10 01                      dup.x1 sp(1)
	<.main+1799 @04737f> : 04 06 00 00                jmp <.main+1805 @047385>
	<.main+1803 @047383> : 10 00                      dup.x1 sp(0)
	<.main+1805 @047385> : 13 02                      set.x1 sp(2)
	<.main+1807 @047387> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@04738b> - <@0473d8>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @04738b> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @04738d> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @04738f> : 10 01                      dup.x1 sp(1)
	<.main+1817 @047391> : 10 01                      dup.x1 sp(1)
	<.main+1819 @047393> : 59                         cgt.i32
	<.main+1820 @047394> : 06 0a 00 00                jz <.main+1830 @04739e>
	<.main+1824 @047398> : 10 01                      dup.x1 sp(1)
	<.main+1826 @04739a> : 04 06 00 00                jmp <.main+1832 @0473a0>
	<.main+1830 @04739e> : 10 00                      dup.x1 sp(0)
	<.main+1832 @0473a0> : 13 02                      set.x1 sp(2)
	<.main+1834 @0473a2> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @0473a6> : 10 29                      dup.x1 sp(41)
	<.main+1840 @0473a8> : 10 01                      dup.x1 sp(1)
	<.main+1842 @0473aa> : 10 01                      dup.x1 sp(1)
	<.main+1844 @0473ac> : 59                         cgt.i32
	<.main+1845 @0473ad> : 06 0a 00 00                jz <.main+1855 @0473b7>
	<.main+1849 @0473b1> : 10 01                      dup.x1 sp(1)
	<.main+1851 @0473b3> : 04 06 00 00                jmp <.main+1857 @0473b9>
	<.main+1855 @0473b7> : 10 00                      dup.x1 sp(0)
	<.main+1857 @0473b9> : 13 02                      set.x1 sp(2)
	<.main+1859 @0473bb> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @0473bf> : 10 28                      dup.x1 sp(40)
	<.main+1865 @0473c1> : 10 01                      dup.x1 sp(1)
	<.main+1867 @0473c3> : 10 01                      dup.x1 sp(1)
	<.main+1869 @0473c5> : 59                         cgt.i32
	<.main+1870 @0473c6> : 06 0a 00 00                jz <.main+1880 @0473d0>
	<.main+1874 @0473ca> : 10 01                      dup.x1 sp(1)
	<.main+1876 @0473cc> : 04 06 00 00                jmp <.main+1882 @0473d2>
	<.main+1880 @0473d0> : 10 00                      dup.x1 sp(0)
	<.main+1882 @0473d2> : 13 02                      set.x1 sp(2)
	<.main+1884 @0473d4> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@0473d8> - <@047439>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @0473d8> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @0473da> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @0473de> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @0473e0> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @0473e4> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @0473e6> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @0473ea> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @0473ec> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @0473f0> : 10 01                      dup.x1 sp(1)
	<.main+1914 @0473f2> : 10 01                      dup.x1 sp(1)
	<.main+1916 @0473f4> : 59                         cgt.i32
	<.main+1917 @0473f5> : 06 0a 00 00                jz <.main+1927 @0473ff>
	<.main+1921 @0473f9> : 10 01                      dup.x1 sp(1)
	<.main+1923 @0473fb> : 04 06 00 00                jmp <.main+1929 @047401>
	<.main+1927 @0473ff> : 10 00                      dup.x1 sp(0)
	<.main+1929 @047401> : 13 02                      set.x1 sp(2)
	<.main+1931 @047403> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @047407> : 10 01                      dup.x1 sp(1)
	<.main+1937 @047409> : 10 01                      dup.x1 sp(1)
	<.main+1939 @04740b> : 59                         cgt.i32
	<.main+1940 @04740c> : 06 0a 00 00                jz <.main+1950 @047416>
	<.main+1944 @047410> : 10 01                      dup.x1 sp(1)
	<.main+1946 @047412> : 04 06 00 00                jmp <.main+1952 @047418>
	<.main+1950 @047416> : 10 00                      dup.x1 sp(0)
	<.main+1952 @047418> : 13 02                      set.x1 sp(2)
	<.main+1954 @04741a> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @04741e> : 10 01                      dup.x1 sp(1)
	<.main+1960 @047420> : 10 01                      dup.x1 sp(1)
	<.main+1962 @047422> : 59                         cgt.i32
	<.main+1963 @047423> : 06 0a 00 00                jz <.main+1973 @04742d>
	<.main+1967 @047427> : 10 01                      dup.x1 sp(1)
	<.main+1969 @047429> : 04 06 00 00                jmp <.main+1975 @04742f>
	<.main+1973 @04742d> : 10 00                      dup.x1 sp(0)
	<.main+1975 @04742f> : 13 02                      set.x1 sp(2)
	<.main+1977 @047431> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @047435> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@047439> - <@04749a>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @047439> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @04743b> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @04743f> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @047441> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @047445> : 10 01                      dup.x1 sp(1)
	<.main+1999 @047447> : 10 01                      dup.x1 sp(1)
	<.main+2001 @047449> : 59                         cgt.i32
	<.main+2002 @04744a> : 06 0a 00 00                jz <.main+2012 @047454>
	<.main+2006 @04744e> : 10 01                      dup.x1 sp(1)
	<.main+2008 @047450> : 04 06 00 00                jmp <.main+2014 @047456>
	<.main+2012 @047454> : 10 00                      dup.x1 sp(0)
	<.main+2014 @047456> : 13 02                      set.x1 sp(2)
	<.main+2016 @047458> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @04745c> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @04745e> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @047462> : 10 01                      dup.x1 sp(1)
	<.main+2028 @047464> : 10 01                      dup.x1 sp(1)
	<.main+2030 @047466> : 59                         cgt.i32
	<.main+2031 @047467> : 06 0a 00 00                jz <.main+2041 @047471>
	<.main+2035 @04746b> : 10 01                      dup.x1 sp(1)
	<.main+2037 @04746d> : 04 06 00 00                jmp <.main+2043 @047473>
	<.main+2041 @047471> : 10 00                      dup.x1 sp(0)
	<.main+2043 @047473> : 13 02                      set.x1 sp(2)
	<.main+2045 @047475> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @047479> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @04747b> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @04747f> : 10 01                      dup.x1 sp(1)
	<.main+2057 @047481> : 10 01                      dup.x1 sp(1)
	<.main+2059 @047483> : 59                         cgt.i32
	<.main+2060 @047484> : 06 0a 00 00                jz <.main+2070 @04748e>
	<.main+2064 @047488> : 10 01                      dup.x1 sp(1)
	<.main+2066 @04748a> : 04 06 00 00                jmp <.main+2072 @047490>
	<.main+2070 @04748e> : 10 00                      dup.x1 sp(0)
	<.main+2072 @047490> : 13 02                      set.x1 sp(2)
	<.main+2074 @047492> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @047496> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@04749a> - <@04749f>): overload1: float32 := overload
	<.main+2082 @04749a> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@04749f> - <@0474a4>): overload2: float32 := overload()
	<.main+2087 @04749f> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@0474a4> - <@0474a9>): overload3: float32 := overload(0)
	<.main+2092 @0474a4> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@0474a9> - <@0474ae>): overload4: float32 := overload(0.000000)
	<.main+2097 @0474a9> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@0474ae> - <@0474b3>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @0474ae> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@0474b3> - <@0474bc>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @0474b3> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@0474bc> - <@0474d2>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @0474bc> : 11 00                      dup.x2 sp(0)
	<.main+2118 @0474be> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @0474c7> : 83                         mul.f64
	<.main+2128 @0474c8> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @0474d1> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@0474d2> - <@0474d7>): valueRef: int64 := value
	<.main+2138 @0474d2> : 1f 38 6a 04 00             load.ref <@046a38> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@0474d7> - <@0474dc>): valuePtr: pointer := value
	<.main+2143 @0474d7> : 1f 38 6a 04 00             load.ref <@046a38> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@0474dc> - <@0474e6>): valueVar: variant := value
	<.main+2148 @0474dc> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2153 @0474e1> : 1f 38 6a 04 00             load.ref <@046a38> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@0474e6> - <@0474e9>): fromRef: int64 := valueRef
	<.main+2158 @0474e6> : 10 03                      dup.x1 sp(3)
	<.main+2160 @0474e8> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@0474e9> - <@0474eb>): fromPtr: int64 := valuePtr
	<.main+2161 @0474e9> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@0474eb> - <@0474ed>): fromVar: int64 := valueVar
	<.main+2163 @0474eb> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@0474ed> - <@0474f2>): nullRef: int64 := null
	<.main+2165 @0474ed> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@0474f2> - <@0474f7>): nullPtr: pointer := null
	<.main+2170 @0474f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@0474f7> - <@047501>): nullVar: variant := null
	<.main+2175 @0474f7> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2180 @0474fc> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@047501> - <@047506>): nullTyp: typename := null
	<.main+2185 @047501> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@047506> - <@04750b>): nullFun: function := null
	<.main+2190 @047506> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@04750b> - <@047510>): nullObj: object := null
	<.main+2195 @04750b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@047510> - <@047515>): typePtr: pointer := int64
	<.main+2200 @047510> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@047515> - <@04751f>): typeVar: variant := int64
	<.main+2205 @047515> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @04751a> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@04751f> - <@047524>): typeTyp: typename := int64
	<.main+2215 @04751f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@047524> - <@047528>): local: int64 := value
	<.main+2220 @047524> : 2b 38 6a 04                load.m64 <@046a38> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@047528> - <@04752a>): copyVal: int64 := local
	<.main+2224 @047528> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@04752a> - <@04752c>): copyRef: int64 := valueRef
	<.main+2226 @04752a> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@04752c> - <@04752e>): copyPtr: pointer := valuePtr
	<.main+2228 @04752c> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@04752e> - <@047530>): copyVar: variant := valueVar
	<.main+2230 @04752e> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@047530> - <@047532>): copyTyp: typename := typeTyp
	<.main+2232 @047530> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@047532> - <@047537>): ptrVoid: pointer := void
	<.main+2234 @047532> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@047537> - <@04753c>): ptrBool: pointer := bool
	<.main+2239 @047537> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@04753c> - <@047541>): ptrChar: pointer := char
	<.main+2244 @04753c> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@047541> - <@047546>): ptrInt8: pointer := int8
	<.main+2249 @047541> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@047546> - <@04754b>): ptrInt16: pointer := int16
	<.main+2254 @047546> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@04754b> - <@047550>): ptrInt32: pointer := int32
	<.main+2259 @04754b> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@047550> - <@047555>): ptrInt64: pointer := int64
	<.main+2264 @047550> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@047555> - <@04755a>): ptrUint8: pointer := uint8
	<.main+2269 @047555> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@04755a> - <@04755f>): ptrUint16: pointer := uint16
	<.main+2274 @04755a> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@04755f> - <@047564>): ptrUint32: pointer := uint32
	<.main+2279 @04755f> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@047564> - <@047569>): ptrUint64: pointer := uint64
	<.main+2284 @047564> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@047569> - <@04756e>): ptrFloat32: pointer := float32
	<.main+2289 @047569> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@04756e> - <@047573>): ptrFloat64: pointer := float64
	<.main+2294 @04756e> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@047573> - <@047578>): ptrTypename: pointer := typename
	<.main+2299 @047573> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@047578> - <@04757d>): ptrFunction: pointer := function
	<.main+2304 @047578> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@04757d> - <@047582>): ptrPointer: pointer := pointer
	<.main+2309 @04757d> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@047582> - <@047587>): ptrVariant: pointer := variant
	<.main+2314 @047582> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@047587> - <@04758c>): ptrObject: pointer := object
	<.main+2319 @047587> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@04758c> - <@047596>): varVoid: variant := void
	<.main+2324 @04758c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @047591> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@047596> - <@0475a0>): varBool: variant := bool
	<.main+2334 @047596> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @04759b> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@0475a0> - <@0475aa>): varChar: variant := char
	<.main+2344 @0475a0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @0475a5> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@0475aa> - <@0475b4>): varInt8: variant := int8
	<.main+2354 @0475aa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @0475af> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@0475b4> - <@0475be>): varInt16: variant := int16
	<.main+2364 @0475b4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @0475b9> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@0475be> - <@0475c8>): varInt32: variant := int32
	<.main+2374 @0475be> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @0475c3> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@0475c8> - <@0475d2>): varInt64: variant := int64
	<.main+2384 @0475c8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @0475cd> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@0475d2> - <@0475dc>): varUint8: variant := uint8
	<.main+2394 @0475d2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @0475d7> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@0475dc> - <@0475e6>): varUint16: variant := uint16
	<.main+2404 @0475dc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @0475e1> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@0475e6> - <@0475f0>): varUint32: variant := uint32
	<.main+2414 @0475e6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @0475eb> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@0475f0> - <@0475fa>): varUint64: variant := uint64
	<.main+2424 @0475f0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @0475f5> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@0475fa> - <@047604>): varFloat32: variant := float32
	<.main+2434 @0475fa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @0475ff> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@047604> - <@04760e>): varFloat64: variant := float64
	<.main+2444 @047604> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @047609> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@04760e> - <@047618>): varTypename: variant := typename
	<.main+2454 @04760e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @047613> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@047618> - <@047622>): varFunction: variant := function
	<.main+2464 @047618> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @04761d> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@047622> - <@04762c>): varPointer: variant := pointer
	<.main+2474 @047622> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @047627> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@04762c> - <@047636>): varVariant: variant := variant
	<.main+2484 @04762c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @047631> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@047636> - <@047640>): varObject: variant := object
	<.main+2494 @047636> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @04763b> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@047640> - <@047645>): typVoid: typename := void
	<.main+2504 @047640> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@047645> - <@04764a>): typBool: typename := bool
	<.main+2509 @047645> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@04764a> - <@04764f>): typChar: typename := char
	<.main+2514 @04764a> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@04764f> - <@047654>): typInt8: typename := int8
	<.main+2519 @04764f> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@047654> - <@047659>): typInt16: typename := int16
	<.main+2524 @047654> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@047659> - <@04765e>): typInt32: typename := int32
	<.main+2529 @047659> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@04765e> - <@047663>): typInt64: typename := int64
	<.main+2534 @04765e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@047663> - <@047668>): typUint8: typename := uint8
	<.main+2539 @047663> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@047668> - <@04766d>): typUint16: typename := uint16
	<.main+2544 @047668> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@04766d> - <@047672>): typUint32: typename := uint32
	<.main+2549 @04766d> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@047672> - <@047677>): typUint64: typename := uint64
	<.main+2554 @047672> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@047677> - <@04767c>): typFloat32: typename := float32
	<.main+2559 @047677> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@04767c> - <@047681>): typFloat64: typename := float64
	<.main+2564 @04767c> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@047681> - <@047686>): typTypename: typename := typename
	<.main+2569 @047681> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@047686> - <@04768b>): typFunction: typename := function
	<.main+2574 @047686> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@04768b> - <@047690>): typPointer: typename := pointer
	<.main+2579 @04768b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@047690> - <@047695>): typVariant: typename := variant
	<.main+2584 @047690> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@047695> - <@04769a>): typObject: typename := object
	<.main+2589 @047695> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@04769a> - <@04769f>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @04769a> : 1f 38 6a 04 00             load.ref <@046a38> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@04769f> - <@0476a9>): valueOfVar: variant := variant(value)
	<.main+2599 @04769f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2604 @0476a4> : 1f 38 6a 04 00             load.ref <@046a38> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@0476a9> - <@0476ae>): valueOfTyp: typename := typename(value)
	<.main+2609 @0476a9> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@0476ae> - <@0476b3>): typeOfValue: typename := typename(value)
	<.main+2614 @0476ae> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@0476b3> - <@0476ba>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @0476b3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2624 @0476b8> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@0476ba> - <@0476bc>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @0476ba> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@0476bc> - <@0476d1>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @0476bc> : 19                         load.z32
	<.main+2629 @0476bd> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @0476c2> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @0476c7> : 1f 48 6a 04 00             load.ref <@046a48> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @0476cc> : 02                         call
	<.main+2645 @0476cd> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@0476d1> - <@0476d6>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @0476d1> : 1f 48 6a 04 00             load.ref <@046a48> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@0476d6> - <@0476e8>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @0476d6> : 19                         load.z32
	<.main+2655 @0476d7> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @0476dc> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @0476e1> : 10 03                      dup.x1 sp(3)
	<.main+2667 @0476e3> : 02                         call
	<.main+2668 @0476e4> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@0476e8> - <@0476ed>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @0476e8> : 1f 50 6a 04 00             load.ref <@046a50> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@0476ed> - <@0476ff>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @0476ed> : 19                         load.z32
	<.main+2678 @0476ee> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @0476f3> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @0476f8> : 10 03                      dup.x1 sp(3)
	<.main+2690 @0476fa> : 02                         call
	<.main+2691 @0476fb> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@0476ff> - <@047701>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @0476ff> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@047701> - <@047713>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @047701> : 19                         load.z32
	<.main+2698 @047702> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @047707> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @04770c> : 10 03                      dup.x1 sp(3)
	<.main+2710 @04770e> : 02                         call
	<.main+2711 @04770f> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@047713> - <@047723>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @047713> : 19                         load.z32
	<.main+2716 @047714> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @047719> : 1f 58 6a 04 00             load.ref <@046a58> ;fib(n: uint32): uint32
	<.main+2726 @04771e> : 02                         call
	<.main+2727 @04771f> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@047723> - <@047727>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @047723> : 2a b8 00 00                load.m32 <@0000b8>
	test/lang/reflect.ci:4: (4 bytes: <@047727> - <@04772b>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @047727> : 2a 48 01 00                load.m32 <@000148>
	test/lang/reflect.ci:5: (4 bytes: <@04772b> - <@04772f>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @04772b> : 2a d8 01 00                load.m32 <@0001d8>
	test/lang/reflect.ci:6: (4 bytes: <@04772f> - <@047733>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @04772f> : 2a 68 02 00                load.m32 <@000268>
	test/lang/reflect.ci:7: (4 bytes: <@047733> - <@047737>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @047733> : 2a f8 02 00                load.m32 <@0002f8>
	test/lang/reflect.ci:8: (4 bytes: <@047737> - <@04773b>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @047737> : 2a 88 03 00                load.m32 <@000388>
	test/lang/reflect.ci:9: (4 bytes: <@04773b> - <@04773f>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @04773b> : 2a 18 04 00                load.m32 <@000418>
	test/lang/reflect.ci:10: (4 bytes: <@04773f> - <@047743>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @04773f> : 2a a8 04 00                load.m32 <@0004a8>
	test/lang/reflect.ci:11: (4 bytes: <@047743> - <@047747>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @047743> : 2a 38 05 00                load.m32 <@000538>
	test/lang/reflect.ci:12: (4 bytes: <@047747> - <@04774b>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @047747> : 2a c8 05 00                load.m32 <@0005c8>
	test/lang/reflect.ci:13: (4 bytes: <@04774b> - <@04774f>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @04774b> : 2a 58 06 00                load.m32 <@000658>
	test/lang/reflect.ci:14: (4 bytes: <@04774f> - <@047753>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @04774f> : 2a e8 06 00                load.m32 <@0006e8>
	test/lang/reflect.ci:15: (4 bytes: <@047753> - <@047757>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @047753> : 2a 78 07 00                load.m32 <@000778>
	test/lang/reflect.ci:16: (4 bytes: <@047757> - <@04775b>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @047757> : 2a 08 08 00                load.m32 <@000808>
	test/lang/reflect.ci:17: (4 bytes: <@04775b> - <@04775f>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @04775b> : 2a 98 08 00                load.m32 <@000898>
	test/lang/reflect.ci:18: (4 bytes: <@04775f> - <@047763>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @04775f> : 2a 20 00 00                load.m32 <@000020> ;typename+24
	test/lang/reflect.ci:19: (4 bytes: <@047763> - <@047767>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @047763> : 2a 28 09 00                load.m32 <@000928>
	test/lang/reflect.ci:20: (4 bytes: <@047767> - <@04776b>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @047767> : 2a c0 09 00                load.m32 <@0009c0>
	test/lang/reflect.ci:30: (5 bytes: <@04776b> - <@047770>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @04776b> : 1f 60 fb 02 00             load.ref <@02fb60> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@047770> - <@047776>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @047770> : 10 00                      dup.x1 sp(0)
	<.main+2810 @047772> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@047776> - <@04777d>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @047776> : 10 01                      dup.x1 sp(1)
	<.main+2816 @047778> : 0c 20 00 00                inc.i32(+32)
	<.main+2820 @04777c> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@04777d> - <@047784>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @04777d> : 10 02                      dup.x1 sp(2)
	<.main+2823 @04777f> : 0c 18 00 00                inc.i32(+24)
	<.main+2827 @047783> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@047784> - <@04778a>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @047784> : 10 03                      dup.x1 sp(3)
	<.main+2830 @047786> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@04778a> - <@047790>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @04778a> : 10 04                      dup.x1 sp(4)
	<.main+2836 @04778c> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@047790> - <@047796>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @047790> : 10 05                      dup.x1 sp(5)
	<.main+2842 @047792> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@047796> - <@04779c>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @047796> : 10 00                      dup.x1 sp(0)
	<.main+2848 @047798> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@04779c> - <@0477a3>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @04779c> : 10 01                      dup.x1 sp(1)
	<.main+2854 @04779e> : 0c 20 00 00                inc.i32(+32)
	<.main+2858 @0477a2> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@0477a3> - <@0477aa>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @0477a3> : 10 02                      dup.x1 sp(2)
	<.main+2861 @0477a5> : 0c 18 00 00                inc.i32(+24)
	<.main+2865 @0477a9> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@0477aa> - <@0477b0>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @0477aa> : 10 03                      dup.x1 sp(3)
	<.main+2868 @0477ac> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@0477b0> - <@0477b6>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @0477b0> : 10 04                      dup.x1 sp(4)
	<.main+2874 @0477b2> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@0477b6> - <@0477bc>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @0477b6> : 10 05                      dup.x1 sp(5)
	<.main+2880 @0477b8> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@0477bc> - <@0477c3>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @0477bc> : 10 00                      dup.x1 sp(0)
	<.main+2886 @0477be> : 0c 20 00 00                inc.i32(+32)
	<.main+2890 @0477c2> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@0477c3> - <@0477ca>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @0477c3> : 10 01                      dup.x1 sp(1)
	<.main+2893 @0477c5> : 0c 18 00 00                inc.i32(+24)
	<.main+2897 @0477c9> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@0477ca> - <@0477d0>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @0477ca> : 10 02                      dup.x1 sp(2)
	<.main+2900 @0477cc> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@0477d0> - <@0477d7>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @0477d0> : 10 00                      dup.x1 sp(0)
	<.main+2906 @0477d2> : 0c 20 00 00                inc.i32(+32)
	<.main+2910 @0477d6> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@0477d7> - <@0477de>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @0477d7> : 10 01                      dup.x1 sp(1)
	<.main+2913 @0477d9> : 0c 18 00 00                inc.i32(+24)
	<.main+2917 @0477dd> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@0477de> - <@0477e7>): pi64: float64 := 3.141593
	<.main+2918 @0477de> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@0477e7> - <@0477f0>): e64: float64 := 2.718282
	<.main+2927 @0477e7> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@0477f0> - <@0477f3>): pi32: float32 := pi64
	<.main+2936 @0477f0> : 11 02                      dup.x2 sp(2)
	<.main+2938 @0477f2> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@0477f3> - <@0477f6>): e32: float32 := e64
	<.main+2939 @0477f3> : 11 01                      dup.x2 sp(1)
	<.main+2941 @0477f5> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@0477f6> - <@0477fd>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @0477f6> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @0477fb> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@0477fd> - <@047804>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @0477fd> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @047802> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@047804> - <@04780b>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @047804> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @047809> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@04780b> - <@047827>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @04780b> : 10 02                      dup.x1 sp(2)
	<.main+2965 @04780d> : 3f 48                      b32.shl 0x008
	<.main+2967 @04780f> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @047814> : 31                         and.b32
	<.main+2973 @047815> : 10 02                      dup.x1 sp(2)
	<.main+2975 @047817> : 3f 43                      b32.shl 0x003
	<.main+2977 @047819> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @04781e> : 31                         and.b32
	<.main+2983 @04781f> : 32                         or.b32
	<.main+2984 @047820> : 10 01                      dup.x1 sp(1)
	<.main+2986 @047822> : 3f c3                      b32.sar 0x003
	<.main+2988 @047824> : 3f 05                      b32.and 0x01f
	<.main+2990 @047826> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@047827> - <@047841>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @047827> : 10 03                      dup.x1 sp(3)
	<.main+2993 @047829> : 3f 50                      b32.shl 0x010
	<.main+2995 @04782b> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @047830> : 31                         and.b32
	<.main+3001 @047831> : 10 03                      dup.x1 sp(3)
	<.main+3003 @047833> : 3f 48                      b32.shl 0x008
	<.main+3005 @047835> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @04783a> : 31                         and.b32
	<.main+3011 @04783b> : 32                         or.b32
	<.main+3012 @04783c> : 10 02                      dup.x1 sp(2)
	<.main+3014 @04783e> : 3f 08                      b32.and 0x0ff
	<.main+3016 @047840> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@047841> - <@047851>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @047841> : 10 01                      dup.x1 sp(1)
	<.main+3019 @047843> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @047848> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @04784d> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@047851> - <@047861>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @047851> : 10 02                      dup.x1 sp(2)
	<.main+3035 @047853> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @047858> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @04785d> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@047861> - <@04786d>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @047861> : 10 03                      dup.x1 sp(3)
	<.main+3051 @047863> : 19                         load.z32
	<.main+3052 @047864> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @047869> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@04786d> - <@04787d>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @04786d> : 10 04                      dup.x1 sp(4)
	<.main+3063 @04786f> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @047874> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @047879> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@04787d> - <@04788d>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @04787d> : 10 05                      dup.x1 sp(5)
	<.main+3079 @04787f> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @047884> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @047889> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@04788d> - <@047899>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @04788d> : 10 06                      dup.x1 sp(6)
	<.main+3095 @04788f> : 19                         load.z32
	<.main+3096 @047890> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @047895> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@047899> - <@0478a9>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @047899> : 10 06                      dup.x1 sp(6)
	<.main+3107 @04789b> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @0478a0> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @0478a5> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@0478a9> - <@0478b9>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @0478a9> : 10 07                      dup.x1 sp(7)
	<.main+3123 @0478ab> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @0478b0> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @0478b5> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@0478b9> - <@0478c5>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @0478b9> : 10 08                      dup.x1 sp(8)
	<.main+3139 @0478bb> : 19                         load.z32
	<.main+3140 @0478bc> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @0478c1> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@0478c5> - <@0478d5>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @0478c5> : 10 09                      dup.x1 sp(9)
	<.main+3151 @0478c7> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @0478cc> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @0478d1> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@0478d5> - <@0478e5>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @0478d5> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @0478d7> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @0478dc> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @0478e1> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@0478e5> - <@0478f1>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @0478e5> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @0478e7> : 19                         load.z32
	<.main+3184 @0478e8> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @0478ed> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@0478f1> - <@047901>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @0478f1> : 11 15                      dup.x2 sp(21)
	<.main+3195 @0478f3> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @0478fc> : 84                         div.f64
	<.main+3205 @0478fd> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@047901> - <@047911>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @047901> : 11 17                      dup.x2 sp(23)
	<.main+3211 @047903> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @04790c> : 84                         div.f64
	<.main+3221 @04790d> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@047911> - <@047921>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @047911> : 11 19                      dup.x2 sp(25)
	<.main+3227 @047913> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @04791c> : 84                         div.f64
	<.main+3237 @04791d> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@047921> - <@04792d>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @047921> : 11 19                      dup.x2 sp(25)
	<.main+3243 @047923> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @047925> : 83                         mul.f64
	<.main+3246 @047926> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @047928> : 83                         mul.f64
	<.main+3249 @047929> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@04792d> - <@04793a>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @04792d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @047936> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@04793a> - <@04794c>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @04793a> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @04793c> : 11 21                      dup.x2 sp(33)
	<.main+3270 @04793e> : 83                         mul.f64
	<.main+3271 @04793f> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @047948> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@04794c> - <@047955>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @04794c> : 11 21                      dup.x2 sp(33)
	<.main+3286 @04794e> : 11 23                      dup.x2 sp(35)
	<.main+3288 @047950> : 83                         mul.f64
	<.main+3289 @047951> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@047955> - <@047964>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @047955> : 11 23                      dup.x2 sp(35)
	<.main+3295 @047957> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @047960> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@047964> - <@047970>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @047964> : 10 22                      dup.x1 sp(34)
	<.main+3310 @047966> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @04796b> : 74                         div.f32
	<.main+3316 @04796c> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@047970> - <@04797c>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @047970> : 10 23                      dup.x1 sp(35)
	<.main+3322 @047972> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @047977> : 74                         div.f32
	<.main+3328 @047978> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@04797c> - <@047988>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @04797c> : 10 24                      dup.x1 sp(36)
	<.main+3334 @04797e> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @047983> : 74                         div.f32
	<.main+3340 @047984> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@047988> - <@047994>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @047988> : 10 24                      dup.x1 sp(36)
	<.main+3346 @04798a> : 10 25                      dup.x1 sp(37)
	<.main+3348 @04798c> : 73                         mul.f32
	<.main+3349 @04798d> : 10 25                      dup.x1 sp(37)
	<.main+3351 @04798f> : 73                         mul.f32
	<.main+3352 @047990> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@047994> - <@04799d>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @047994> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @047999> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@04799d> - <@0479ab>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @04799d> : 10 27                      dup.x1 sp(39)
	<.main+3367 @04799f> : 10 28                      dup.x1 sp(40)
	<.main+3369 @0479a1> : 73                         mul.f32
	<.main+3370 @0479a2> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @0479a7> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@0479ab> - <@0479b4>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @0479ab> : 10 28                      dup.x1 sp(40)
	<.main+3381 @0479ad> : 10 29                      dup.x1 sp(41)
	<.main+3383 @0479af> : 73                         mul.f32
	<.main+3384 @0479b0> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@0479b4> - <@0479bf>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @0479b4> : 10 29                      dup.x1 sp(41)
	<.main+3390 @0479b6> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @0479bb> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@0479bf> - <@0479c5>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @0479bf> : 10 25                      dup.x1 sp(37)
	<.main+3401 @0479c1> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@0479c5> - <@0479cb>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @0479c5> : 10 26                      dup.x1 sp(38)
	<.main+3407 @0479c7> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@0479cb> - <@0479d1>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @0479cb> : 10 27                      dup.x1 sp(39)
	<.main+3413 @0479cd> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@0479d1> - <@0479d7>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @0479d1> : 10 28                      dup.x1 sp(40)
	<.main+3419 @0479d3> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@0479d7> - <@0479dd>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @0479d7> : 10 29                      dup.x1 sp(41)
	<.main+3425 @0479d9> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@0479dd> - <@0479e3>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @0479dd> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @0479df> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@0479e3> - <@0479ef>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @0479e3> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @0479e5> : 19                         load.z32
	<.main+3438 @0479e6> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @0479eb> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@0479ef> - <@0479fb>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @0479ef> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @0479f1> : 19                         load.z32
	<.main+3450 @0479f2> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @0479f7> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@0479fb> - <@047a09>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @0479fb> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @0479fd> : 5c                         i32.2i64
	<.main+3462 @0479fe> : 19                         load.z32
	<.main+3463 @0479ff> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @047a04> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @047a08> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@047a09> - <@047a17>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @047a09> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @047a0b> : 5c                         i32.2i64
	<.main+3476 @047a0c> : 19                         load.z32
	<.main+3477 @047a0d> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @047a12> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @047a16> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@047a17> - <@047a25>): p1: pointer := malloc(1024)
	<.main+3487 @047a17> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @047a1c> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @047a21> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@047a25> - <@047a33>): p2: pointer := malloc(80)
	<.main+3501 @047a25> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @047a2a> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @047a2f> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@047a33> - <@047a41>): p3: pointer := malloc(160)
	<.main+3515 @047a33> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @047a38> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @047a3d> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@047a41> - <@047a4f>): p4: pointer := malloc(820)
	<.main+3529 @047a41> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @047a46> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @047a4b> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@047a4f> - <@047a5f>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @047a4f> : 10 03                      dup.x1 sp(3)
	<.main+3545 @047a51> : 19                         load.z32
	<.main+3546 @047a52> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @047a57> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @047a5b> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@047a5f> - <@047a70>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @047a5f> : 10 03                      dup.x1 sp(3)
	<.main+3561 @047a61> : 10 02                      dup.x1 sp(2)
	<.main+3563 @047a63> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @047a68> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @047a6c> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@047a70> - <@047a7b>): free(p1);
	<.main+3576 @047a70> : 10 03                      dup.x1 sp(3)
	<.main+3578 @047a72> : 19                         load.z32
	<.main+3579 @047a73> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @047a77> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@047a7b> - <@047a86>): free(p2);
	<.main+3587 @047a7b> : 10 02                      dup.x1 sp(2)
	<.main+3589 @047a7d> : 19                         load.z32
	<.main+3590 @047a7e> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @047a82> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@047a86> - <@047a91>): free(p3);
	<.main+3598 @047a86> : 10 01                      dup.x1 sp(1)
	<.main+3600 @047a88> : 19                         load.z32
	<.main+3601 @047a89> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @047a8d> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@047a91> - <@047a9c>): free(p4);
	<.main+3609 @047a91> : 10 00                      dup.x1 sp(0)
	<.main+3611 @047a93> : 19                         load.z32
	<.main+3612 @047a94> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @047a98> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@047a9c> - <@047aa5>): val1: int64 := 42
	<.main+3620 @047a9c> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@047aa5> - <@047aae>): val2: int64 := 96
	<.main+3629 @047aa5> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@047aae> - <@047ad0>): debug(void("val1", val1));
	<.main+3638 @047aae> : 1f 90 28 03 00             load.ref <@032890> ;"test/stdc/memory.ci"
	<.main+3643 @047ab3> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @047ab8> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @047abd> : 19                         load.z32
	<.main+3654 @047abe> : 1f b8 28 03 00             load.ref <@0328b8> ;"val1"
	<.main+3659 @047ac3> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3664 @047ac8> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @047acc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@047ad0> - <@047af2>): debug(void("val2", val2));
	<.main+3672 @047ad0> : 1f 90 28 03 00             load.ref <@032890> ;"test/stdc/memory.ci"
	<.main+3677 @047ad5> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @047ada> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @047adf> : 19                         load.z32
	<.main+3688 @047ae0> : 1f bd 28 03 00             load.ref <@0328bd> ;"val2"
	<.main+3693 @047ae5> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3698 @047aea> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @047aee> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@047af2> - <@047b06>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @047af2> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @047af6> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @047afa> : 2a 18 04 00                load.m32 <@000418>
	<.main+3718 @047afe> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @047b02> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@047b06> - <@047b17>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @047b06> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @047b0a> : 19                         load.z32
	<.main+3731 @047b0b> : 2a 18 04 00                load.m32 <@000418>
	<.main+3735 @047b0f> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @047b13> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@047b17> - <@047b39>): debug(void("val1", val1));
	<.main+3743 @047b17> : 1f 90 28 03 00             load.ref <@032890> ;"test/stdc/memory.ci"
	<.main+3748 @047b1c> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @047b21> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @047b26> : 19                         load.z32
	<.main+3759 @047b27> : 1f b8 28 03 00             load.ref <@0328b8> ;"val1"
	<.main+3764 @047b2c> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3769 @047b31> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @047b35> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@047b39> - <@047b5b>): debug(void("val2", val2));
	<.main+3777 @047b39> : 1f 90 28 03 00             load.ref <@032890> ;"test/stdc/memory.ci"
	<.main+3782 @047b3e> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @047b43> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @047b48> : 19                         load.z32
	<.main+3793 @047b49> : 1f bd 28 03 00             load.ref <@0328bd> ;"val2"
	<.main+3798 @047b4e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3803 @047b53> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @047b57> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@047b5b> - <@047b69>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @047b5b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @047b60> : 1f 90 6a 04 00             load.ref <@046a90> ;noError(ptr: pointer): void
	<.main+3821 @047b65> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@047b69> - <@047b77>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @047b69> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @047b6e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @047b73> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@047b77> - <@047b85>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @047b77> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @047b7c> : 1f 98 6a 04 00             load.ref <@046a98> ;stackOverflow(ptr: pointer): void
	<.main+3849 @047b81> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@047b85> - <@047b93>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @047b85> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @047b8a> : 1f b0 6a 04 00             load.ref <@046ab0> ;divisionByZero(args: pointer): void
	<.main+3863 @047b8f> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@047b93> - <@047ba1>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @047b93> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @047b98> : 1f 18 6b 04 00             load.ref <@046b18> ;invalidInstruction(args: pointer): void
	<.main+3877 @047b9d> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@047ba1> - <@047baf>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @047ba1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @047ba6> : 1f 08 6b 04 00             load.ref <@046b08> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @047bab> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@047baf> - <@047bbd>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @047baf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @047bb4> : 1f c0 6a 04 00             load.ref <@046ac0> ;abortExecution(args: pointer): void
	<.main+3905 @047bb9> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@047bbd> - <@047bc1>): arrFixedNoInit: int64[7]
	<.main+3909 @047bbd> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@047bc1> - <@047bc5>): arrArrayNoInit: int64[*]
	<.main+3913 @047bc1> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@047bc5> - <@047bc9>): arrSliceNoInit: int64[]
	<.main+3917 @047bc5> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@047bc9> - <@047bf6>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @047bc9> : 19                         load.z32
	<.main+3922 @047bca> : 04 1c 00 00                jmp <.main+3950 @047be6>
	test/lang/array.ci:55: (20 bytes: <@047bce> - <@047be2>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @047bce> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @047bd3> : 10 01                      dup.x1 sp(1)
	<.main+3933 @047bd5> : 51                         add.i32
	<.main+3934 @047bd6> : 5c                         i32.2i64
	<.main+3935 @047bd7> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @047bdb> : 10 03                      dup.x1 sp(3)
	<.main+3941 @047bdd> : 0d 08 00 00                mad.u32 8
	<.main+3945 @047be1> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@047be2> - <@047be6>): int32(i := int32(i + 1))
	<.main+3946 @047be2> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@047be6> - <@047bf2>): bool(i < arrFixedNoInit.length)
	<.main+3950 @047be6> : 10 00                      dup.x1 sp(0)
	<.main+3952 @047be8> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @047bed> : 58                         clt.i32
	<.main+3958 @047bee> : 05 e0 ff ff                jnz <.main+3926 @047bce>
	<.main+3962 @047bf2> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@047bf6> - <@047bfb>): arrArrayInitNull: int64[*] := null
	<.main+3966 @047bf6> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@047bfb> - <@047c01>): arrSliceInitNull: int64[] := null
	<.main+3971 @047bfb> : 19                         load.z32
	<.main+3972 @047bfc> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@047c01> - <@047c05>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @047c01> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@047c05> - <@047c0e>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @047c05> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @047c0a> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@047c0e> - <@047c10>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @047c0e> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@047c10> - <@047c12>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @047c10> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@047c12> - <@047c14>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @047c12> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@047c14> - <@047c18>): strFixed: char[7]
	<.main+3996 @047c14> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@047c18> - <@047c2e>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @047c18> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @047c1c> : 1f 54 51 02 00             load.ref <@025154> ;"string"
	<.main+4009 @047c21> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @047c26> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @047c2a> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@047c2e> - <@047c50>): debug(void("string as variant", strFixed));
	<.main+4022 @047c2e> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4027 @047c33> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @047c38> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @047c3d> : 19                         load.z32
	<.main+4038 @047c3e> : 1f 93 46 03 00             load.ref <@034693> ;"string as variant"
	<.main+4043 @047c43> : 1f 30 53 03 00             load.ref <@035330>
	<.main+4048 @047c48> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @047c4c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@047c50> - <@047c72>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @047c50> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4061 @047c55> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @047c5a> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @047c5f> : 19                         load.z32
	<.main+4072 @047c60> : 1f a5 46 03 00             load.ref <@0346a5> ;"string to variant"
	<.main+4077 @047c65> : 1f 30 53 03 00             load.ref <@035330>
	<.main+4082 @047c6a> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @047c6e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@047c72> - <@047c77>): strArray: char[*] := "string"
	<.main+4090 @047c72> : 1f 54 51 02 00             load.ref <@025154> ;"string"
	test/lang/array.ci:87: (32 bytes: <@047c77> - <@047c97>): debug(void("string as variant", strArray));
	<.main+4095 @047c77> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4100 @047c7c> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @047c81> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @047c86> : 19                         load.z32
	<.main+4111 @047c87> : 1f 93 46 03 00             load.ref <@034693> ;"string as variant"
	<.main+4116 @047c8c> : 1f c8 54 03 00             load.ref <@0354c8>
	<.main+4121 @047c91> : 10 06                      dup.x1 sp(6)
	<.main+4123 @047c93> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@047c97> - <@047cb7>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @047c97> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4132 @047c9c> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @047ca1> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @047ca6> : 19                         load.z32
	<.main+4143 @047ca7> : 1f a5 46 03 00             load.ref <@0346a5> ;"string to variant"
	<.main+4148 @047cac> : 1f c8 54 03 00             load.ref <@0354c8>
	<.main+4153 @047cb1> : 10 06                      dup.x1 sp(6)
	<.main+4155 @047cb3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@047cb7> - <@047cc1>): strSlice: char[] := "string"
	<.main+4159 @047cb7> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @047cbc> : 1f 54 51 02 00             load.ref <@025154> ;"string"
	test/lang/array.ci:91: (32 bytes: <@047cc1> - <@047ce1>): debug(void("string as variant", strSlice));
	<.main+4169 @047cc1> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4174 @047cc6> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @047ccb> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @047cd0> : 19                         load.z32
	<.main+4185 @047cd1> : 1f 93 46 03 00             load.ref <@034693> ;"string as variant"
	<.main+4190 @047cd6> : 1f d8 55 03 00             load.ref <@0355d8>
	<.main+4195 @047cdb> : 10 06                      dup.x1 sp(6)
	<.main+4197 @047cdd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@047ce1> - <@047d01>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @047ce1> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4206 @047ce6> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @047ceb> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @047cf0> : 19                         load.z32
	<.main+4217 @047cf1> : 1f a5 46 03 00             load.ref <@0346a5> ;"string to variant"
	<.main+4222 @047cf6> : 1f d8 55 03 00             load.ref <@0355d8>
	<.main+4227 @047cfb> : 10 06                      dup.x1 sp(6)
	<.main+4229 @047cfd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@047d01> - <@047d34>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @047d01> : 10 10                      dup.x1 sp(16)
	<.main+4235 @047d03> : 19                         load.z32
	<.main+4236 @047d04> : 38                         clt.u32
	<.main+4237 @047d05> : 05 08 00 00                jnz <.main+4245 @047d0d>
	<.main+4241 @047d09> : 04 2b 00 00                jmp <.main+4284 @047d34>
	<.main+4245 @047d0d> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4250 @047d12> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @047d17> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @047d1c> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @047d21> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4270 @047d26> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4275 @047d2b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @047d30> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@047d34> - <@047d67>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @047d34> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @047d36> : 19                         load.z32
	<.main+4287 @047d37> : 57                         ceq.i32
	<.main+4288 @047d38> : 06 08 00 00                jz <.main+4296 @047d40>
	<.main+4292 @047d3c> : 04 2b 00 00                jmp <.main+4335 @047d67>
	<.main+4296 @047d40> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4301 @047d45> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @047d4a> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @047d4f> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @047d54> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4321 @047d59> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4326 @047d5e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @047d63> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@047d67> - <@047da2>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @047d67> : 11 12                      dup.x2 sp(18)
	<.main+4337 @047d69> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @047d72> : 67                         ceq.i64
	<.main+4347 @047d73> : 06 08 00 00                jz <.main+4355 @047d7b>
	<.main+4351 @047d77> : 04 2b 00 00                jmp <.main+4394 @047da2>
	<.main+4355 @047d7b> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4360 @047d80> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @047d85> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @047d8a> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @047d8f> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4380 @047d94> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4385 @047d99> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @047d9e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@047da2> - <@047dbb>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @047da2> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @047da7> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @047dac> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @047db1> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @047db6> : 02                         call
	<.main+4415 @047db7> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@047dbb> - <@047dd1>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @047dbb> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @047dc0> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @047dc2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @047dc7> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @047dcc> : 02                         call
	<.main+4437 @047dcd> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@047dd1> - <@047de7>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @047dd1> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @047dd6> : 10 08                      dup.x1 sp(8)
	<.main+4448 @047dd8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @047ddd> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @047de2> : 02                         call
	<.main+4459 @047de3> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@047de7> - <@047e07>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @047de7> : 19                         load.z32
	<.main+4464 @047de8> : 1a                         load.z64
	<.main+4465 @047de9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @047dee> : 1f 20 6b 04 00             load.ref <@046b20> ;lenSlice(values: int64[]): int32
	<.main+4475 @047df3> : 02                         call
	<.main+4476 @047df4> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @047df8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @047dfd> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @047e02> : 02                         call
	<.main+4491 @047e03> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@047e07> - <@047e24>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @047e07> : 19                         load.z32
	<.main+4496 @047e08> : 19                         load.z32
	<.main+4497 @047e09> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @047e0b> : 1f 20 6b 04 00             load.ref <@046b20> ;lenSlice(values: int64[]): int32
	<.main+4504 @047e10> : 02                         call
	<.main+4505 @047e11> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @047e15> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @047e1a> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @047e1f> : 02                         call
	<.main+4520 @047e20> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@047e24> - <@047e4c>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @047e24> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @047e29> : 19                         load.z32
	<.main+4530 @047e2a> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @047e2f> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @047e33> : 1f 20 6b 04 00             load.ref <@046b20> ;lenSlice(values: int64[]): int32
	<.main+4544 @047e38> : 02                         call
	<.main+4545 @047e39> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @047e3d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @047e42> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @047e47> : 02                         call
	<.main+4560 @047e48> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@047e4c> - <@047e6d>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @047e4c> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @047e51> : 19                         load.z32
	<.main+4570 @047e52> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @047e54> : 1f 20 6b 04 00             load.ref <@046b20> ;lenSlice(values: int64[]): int32
	<.main+4577 @047e59> : 02                         call
	<.main+4578 @047e5a> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @047e5e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @047e63> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @047e68> : 02                         call
	<.main+4593 @047e69> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@047e6d> - <@047e8e>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @047e6d> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @047e72> : 19                         load.z32
	<.main+4603 @047e73> : 11 08                      dup.x2 sp(8)
	<.main+4605 @047e75> : 1f 20 6b 04 00             load.ref <@046b20> ;lenSlice(values: int64[]): int32
	<.main+4610 @047e7a> : 02                         call
	<.main+4611 @047e7b> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @047e7f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @047e84> : 1f 58 59 04 00             load.ref <@045958> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @047e89> : 02                         call
	<.main+4626 @047e8a> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@047e8e> - <@0481b5>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @047e8e> : 19                         load.z32
	<.main+4631 @047e8f> : 04 16 03 00                jmp <.main+5421 @0481a5>
	test/lang/array.ci:119: (9 bytes: <@047e93> - <@047e9c>): expected: int64 := int32(42 + i)
	<.main+4635 @047e93> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @047e98> : 10 01                      dup.x1 sp(1)
	<.main+4642 @047e9a> : 51                         add.i32
	<.main+4643 @047e9b> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@047e9c> - <@047ed9>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @047e9c> : 11 00                      dup.x2 sp(0)
	<.main+4646 @047e9e> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @047ea2> : 10 05                      dup.x1 sp(5)
	<.main+4652 @047ea4> : 0d 08 00 00                mad.u32 8
	<.main+4656 @047ea8> : 23                         load.i64
	<.main+4657 @047ea9> : 67                         ceq.i64
	<.main+4658 @047eaa> : 06 08 00 00                jz <.main+4666 @047eb2>
	<.main+4662 @047eae> : 04 2b 00 00                jmp <.main+4705 @047ed9>
	<.main+4666 @047eb2> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4671 @047eb7> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @047ebc> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @047ec1> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @047ec6> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4691 @047ecb> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4696 @047ed0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @047ed5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@047ed9> - <@047f14>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @047ed9> : 11 00                      dup.x2 sp(0)
	<.main+4707 @047edb> : 10 10                      dup.x1 sp(16)
	<.main+4709 @047edd> : 10 05                      dup.x1 sp(5)
	<.main+4711 @047edf> : 0d 08 00 00                mad.u32 8
	<.main+4715 @047ee3> : 23                         load.i64
	<.main+4716 @047ee4> : 67                         ceq.i64
	<.main+4717 @047ee5> : 06 08 00 00                jz <.main+4725 @047eed>
	<.main+4721 @047ee9> : 04 2b 00 00                jmp <.main+4764 @047f14>
	<.main+4725 @047eed> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4730 @047ef2> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @047ef7> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @047efc> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @047f01> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4750 @047f06> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4755 @047f0b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @047f10> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@047f14> - <@047f4f>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @047f14> : 11 00                      dup.x2 sp(0)
	<.main+4766 @047f16> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @047f18> : 10 05                      dup.x1 sp(5)
	<.main+4770 @047f1a> : 0d 08 00 00                mad.u32 8
	<.main+4774 @047f1e> : 23                         load.i64
	<.main+4775 @047f1f> : 67                         ceq.i64
	<.main+4776 @047f20> : 06 08 00 00                jz <.main+4784 @047f28>
	<.main+4780 @047f24> : 04 2b 00 00                jmp <.main+4823 @047f4f>
	<.main+4784 @047f28> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4789 @047f2d> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @047f32> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @047f37> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @047f3c> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4809 @047f41> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4814 @047f46> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @047f4b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@047f4f> - <@047f92>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @047f4f> : 11 00                      dup.x2 sp(0)
	<.main+4825 @047f51> : 1a                         load.z64
	<.main+4826 @047f52> : 10 06                      dup.x1 sp(6)
	<.main+4828 @047f54> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @047f58> : 1f 28 6b 04 00             load.ref <@046b28> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @047f5d> : 02                         call
	<.main+4838 @047f5e> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @047f62> : 67                         ceq.i64
	<.main+4843 @047f63> : 06 08 00 00                jz <.main+4851 @047f6b>
	<.main+4847 @047f67> : 04 2b 00 00                jmp <.main+4890 @047f92>
	<.main+4851 @047f6b> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4856 @047f70> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @047f75> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @047f7a> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @047f7f> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4876 @047f84> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4881 @047f89> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @047f8e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@047f92> - <@047fd3>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @047f92> : 11 00                      dup.x2 sp(0)
	<.main+4892 @047f94> : 1a                         load.z64
	<.main+4893 @047f95> : 10 06                      dup.x1 sp(6)
	<.main+4895 @047f97> : 10 13                      dup.x1 sp(19)
	<.main+4897 @047f99> : 1f 28 6b 04 00             load.ref <@046b28> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @047f9e> : 02                         call
	<.main+4903 @047f9f> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @047fa3> : 67                         ceq.i64
	<.main+4908 @047fa4> : 06 08 00 00                jz <.main+4916 @047fac>
	<.main+4912 @047fa8> : 04 2b 00 00                jmp <.main+4955 @047fd3>
	<.main+4916 @047fac> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4921 @047fb1> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @047fb6> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @047fbb> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @047fc0> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4941 @047fc5> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4946 @047fca> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @047fcf> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@047fd3> - <@048014>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @047fd3> : 11 00                      dup.x2 sp(0)
	<.main+4957 @047fd5> : 1a                         load.z64
	<.main+4958 @047fd6> : 10 06                      dup.x1 sp(6)
	<.main+4960 @047fd8> : 10 11                      dup.x1 sp(17)
	<.main+4962 @047fda> : 1f 28 6b 04 00             load.ref <@046b28> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @047fdf> : 02                         call
	<.main+4968 @047fe0> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @047fe4> : 67                         ceq.i64
	<.main+4973 @047fe5> : 06 08 00 00                jz <.main+4981 @047fed>
	<.main+4977 @047fe9> : 04 2b 00 00                jmp <.main+5020 @048014>
	<.main+4981 @047fed> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+4986 @047ff2> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @047ff7> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @047ffc> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @048001> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5006 @048006> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5011 @04800b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @048010> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@048014> - <@048057>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @048014> : 11 00                      dup.x2 sp(0)
	<.main+5022 @048016> : 1a                         load.z64
	<.main+5023 @048017> : 10 06                      dup.x1 sp(6)
	<.main+5025 @048019> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @04801d> : 1f 38 6b 04 00             load.ref <@046b38> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @048022> : 02                         call
	<.main+5035 @048023> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @048027> : 67                         ceq.i64
	<.main+5040 @048028> : 06 08 00 00                jz <.main+5048 @048030>
	<.main+5044 @04802c> : 04 2b 00 00                jmp <.main+5087 @048057>
	<.main+5048 @048030> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5053 @048035> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @04803a> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @04803f> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @048044> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5073 @048049> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5078 @04804e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @048053> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@048057> - <@048098>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @048057> : 11 00                      dup.x2 sp(0)
	<.main+5089 @048059> : 1a                         load.z64
	<.main+5090 @04805a> : 10 06                      dup.x1 sp(6)
	<.main+5092 @04805c> : 10 13                      dup.x1 sp(19)
	<.main+5094 @04805e> : 1f 38 6b 04 00             load.ref <@046b38> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @048063> : 02                         call
	<.main+5100 @048064> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @048068> : 67                         ceq.i64
	<.main+5105 @048069> : 06 08 00 00                jz <.main+5113 @048071>
	<.main+5109 @04806d> : 04 2b 00 00                jmp <.main+5152 @048098>
	<.main+5113 @048071> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5118 @048076> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @04807b> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @048080> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @048085> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5138 @04808a> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5143 @04808f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @048094> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@048098> - <@0480d9>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @048098> : 11 00                      dup.x2 sp(0)
	<.main+5154 @04809a> : 1a                         load.z64
	<.main+5155 @04809b> : 10 06                      dup.x1 sp(6)
	<.main+5157 @04809d> : 10 11                      dup.x1 sp(17)
	<.main+5159 @04809f> : 1f 38 6b 04 00             load.ref <@046b38> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @0480a4> : 02                         call
	<.main+5165 @0480a5> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @0480a9> : 67                         ceq.i64
	<.main+5170 @0480aa> : 06 08 00 00                jz <.main+5178 @0480b2>
	<.main+5174 @0480ae> : 04 2b 00 00                jmp <.main+5217 @0480d9>
	<.main+5178 @0480b2> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5183 @0480b7> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @0480bc> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @0480c1> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @0480c6> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5203 @0480cb> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5208 @0480d0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @0480d5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@0480d9> - <@048121>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @0480d9> : 11 00                      dup.x2 sp(0)
	<.main+5219 @0480db> : 1a                         load.z64
	<.main+5220 @0480dc> : 10 06                      dup.x1 sp(6)
	<.main+5222 @0480de> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @0480e3> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @0480e7> : 1f 48 6b 04 00             load.ref <@046b48> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @0480ec> : 02                         call
	<.main+5237 @0480ed> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @0480f1> : 67                         ceq.i64
	<.main+5242 @0480f2> : 06 08 00 00                jz <.main+5250 @0480fa>
	<.main+5246 @0480f6> : 04 2b 00 00                jmp <.main+5289 @048121>
	<.main+5250 @0480fa> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5255 @0480ff> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @048104> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @048109> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @04810e> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5275 @048113> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5280 @048118> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @04811d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@048121> - <@048162>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @048121> : 11 00                      dup.x2 sp(0)
	<.main+5291 @048123> : 1a                         load.z64
	<.main+5292 @048124> : 10 06                      dup.x1 sp(6)
	<.main+5294 @048126> : 11 11                      dup.x2 sp(17)
	<.main+5296 @048128> : 1f 48 6b 04 00             load.ref <@046b48> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @04812d> : 02                         call
	<.main+5302 @04812e> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @048132> : 67                         ceq.i64
	<.main+5307 @048133> : 06 08 00 00                jz <.main+5315 @04813b>
	<.main+5311 @048137> : 04 2b 00 00                jmp <.main+5354 @048162>
	<.main+5315 @04813b> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5320 @048140> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @048145> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @04814a> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @04814f> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5340 @048154> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5345 @048159> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @04815e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@048162> - <@04819d>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @048162> : 11 00                      dup.x2 sp(0)
	<.main+5356 @048164> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @048166> : 10 05                      dup.x1 sp(5)
	<.main+5360 @048168> : 0d 08 00 00                mad.u32 8
	<.main+5364 @04816c> : 23                         load.i64
	<.main+5365 @04816d> : 67                         ceq.i64
	<.main+5366 @04816e> : 06 08 00 00                jz <.main+5374 @048176>
	<.main+5370 @048172> : 04 2b 00 00                jmp <.main+5413 @04819d>
	<.main+5374 @048176> : 1f d0 45 03 00             load.ref <@0345d0> ;"test/lang/array.ci"
	<.main+5379 @04817b> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @048180> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @048185> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @04818a> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5399 @04818f> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5404 @048194> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @048199> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @04819d> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@0481a1> - <@0481a5>): int32(i := int32(i + 1))
	<.main+5417 @0481a1> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@0481a5> - <@0481b1>): bool(i < arrFixedNoInit.length)
	<.main+5421 @0481a5> : 10 00                      dup.x1 sp(0)
	<.main+5423 @0481a7> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @0481ac> : 58                         clt.i32
	<.main+5429 @0481ad> : 05 e6 fc ff                jnz <.main+4635 @047e93>
	<.main+5433 @0481b1> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@0481b5> - <@0481f1>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @0481b5> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@0481b9> - <@0481c0>): void(recordMemberTest.member := 6);
	<.main+5441 @0481b9> : 1c 06 00 00 00             load.c32 6
	<.main+5446 @0481be> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@0481c0> - <@0481c7>): void(recordMemberTest.constant := 7);
	<.main+5448 @0481c0> : 1c 07 00 00 00             load.c32 7
	<.main+5453 @0481c5> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@0481c7> - <@0481ce>): void(recordMemberTest.memberInit := 8);
	<.main+5455 @0481c7> : 1c 08 00 00 00             load.c32 8
	<.main+5460 @0481cc> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@0481ce> - <@0481d5>): void(recordMemberTest.constantInit := 9);
	<.main+5462 @0481ce> : 1c 09 00 00 00             load.c32 9
	<.main+5467 @0481d3> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@0481d5> - <@0481dc>): void(recordMemberTest.memberRec.member := 61);
	<.main+5469 @0481d5> : 1c 3d 00 00 00             load.c32 61
	<.main+5474 @0481da> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@0481dc> - <@0481e3>): void(recordMemberTest.memberRec.constant := 62);
	<.main+5476 @0481dc> : 1c 3e 00 00 00             load.c32 62
	<.main+5481 @0481e1> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@0481e3> - <@0481ea>): void(recordMemberTest.constantRec.member := 71);
	<.main+5483 @0481e3> : 1c 47 00 00 00             load.c32 71
	<.main+5488 @0481e8> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@0481ea> - <@0481f1>): void(recordMemberTest.constantRec.constant := 72);
	<.main+5490 @0481ea> : 1c 48 00 00 00             load.c32 72
	<.main+5495 @0481ef> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:53: (32 bytes: <@0481f1> - <@048211>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @0481f1> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:54: (7 bytes: <@0481f5> - <@0481fc>): void(recordMethodTest.delegateMethod := globalFunction);
	<.main+5501 @0481f5> : 1f f8 6b 04 00             load.ref <@046bf8> ;globalFunction(x: int32, y: int32): int32
	<.main+5506 @0481fa> : 13 02                      set.x1 sp(2)
	test/lang/method.ci:55: (7 bytes: <@0481fc> - <@048203>): void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	<.main+5508 @0481fc> : 1f 88 6b 04 00             load.ref <@046b88> ;RecordMethodTest.staticMethod(x: int32, y: int32): int32
	<.main+5513 @048201> : 13 01                      set.x1 sp(1)
	:: (7 bytes: <@048203> - <@04820a>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5515 @048203> : 1f 98 6b 04 00             load.ref <@046b98> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5520 @048208> : 13 03                      set.x1 sp(3)
	:: (7 bytes: <@04820a> - <@048211>): void(recordMethodTest.print := print)
	<.main+5522 @04820a> : 1f a8 6b 04 00             load.ref <@046ba8> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5527 @04820f> : 13 04                      set.x1 sp(4)
	test/lang/method.ci:63: (31 bytes: <@048211> - <@048230>): recordMethodTestCustomPrint: RecordMethodTest := {...}
	<.main+5529 @048211> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:64: (7 bytes: <@048215> - <@04821c>): void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	<.main+5533 @048215> : 1f f8 6b 04 00             load.ref <@046bf8> ;globalFunction(x: int32, y: int32): int32
	<.main+5538 @04821a> : 13 01                      set.x1 sp(1)
	test/lang/method.ci:65: (7 bytes: <@04821c> - <@048223>): void(recordMethodTestCustomPrint.print := customPrint);
	<.main+5540 @04821c> : 1f 00 6c 04 00             load.ref <@046c00> ;customPrint(this: RecordMethodTest): void
	<.main+5545 @048221> : 13 04                      set.x1 sp(4)
	:: (6 bytes: <@048223> - <@048229>): void(recordMethodTestCustomPrint.delegateMethod := forwardMethod)
	<.main+5547 @048223> : 2a 90 6b 04                load.m32 <@046b90> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+5551 @048227> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@048229> - <@048230>): void(recordMethodTestCustomPrint.virtualMethod := virtualMethod)
	<.main+5553 @048229> : 1f 98 6b 04 00             load.ref <@046b98> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5558 @04822e> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:69: (9 bytes: <@048230> - <@048239>): recordMethodTest.print(recordMethodTest);
	<.main+5560 @048230> : 12 04                      dup.x4 sp(4)
	<.main+5562 @048232> : 10 0b                      dup.x1 sp(11)
	<.main+5564 @048234> : 02                         call
	<.main+5565 @048235> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:70: (9 bytes: <@048239> - <@048242>): recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
	<.main+5569 @048239> : 12 00                      dup.x4 sp(0)
	<.main+5571 @04823b> : 10 07                      dup.x1 sp(7)
	<.main+5573 @04823d> : 02                         call
	<.main+5574 @04823e> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:73: (12 bytes: <@048242> - <@04824e>): recordMethodTest.printStatic(recordMethodTest);
	<.main+5578 @048242> : 12 04                      dup.x4 sp(4)
	<.main+5580 @048244> : 1f d0 6b 04 00             load.ref <@046bd0> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5585 @048249> : 02                         call
	<.main+5586 @04824a> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:84: (12 bytes: <@04824e> - <@04825a>): print(recordMethodTest);
	<.main+5590 @04824e> : 12 04                      dup.x4 sp(4)
	<.main+5592 @048250> : 1f 28 6c 04 00             load.ref <@046c28> ;print(this: RecordMethodTest): void
	<.main+5597 @048255> : 02                         call
	<.main+5598 @048256> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:85: (12 bytes: <@04825a> - <@048266>): printStatic(recordMethodTest);
	<.main+5602 @04825a> : 12 04                      dup.x4 sp(4)
	<.main+5604 @04825c> : 1f 50 6c 04 00             load.ref <@046c50> ;printStatic(this: RecordMethodTest): void
	<.main+5609 @048261> : 02                         call
	<.main+5610 @048262> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:86: (12 bytes: <@048266> - <@048272>): print(recordMethodTestCustomPrint);
	<.main+5614 @048266> : 12 00                      dup.x4 sp(0)
	<.main+5616 @048268> : 1f 28 6c 04 00             load.ref <@046c28> ;print(this: RecordMethodTest): void
	<.main+5621 @04826d> : 02                         call
	<.main+5622 @04826e> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:89: (12 bytes: <@048272> - <@04827e>): RecordMethodTest.print(recordMethodTest);
	<.main+5626 @048272> : 12 04                      dup.x4 sp(4)
	<.main+5628 @048274> : 1f a8 6b 04 00             load.ref <@046ba8> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5633 @048279> : 02                         call
	<.main+5634 @04827a> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:90: (12 bytes: <@04827e> - <@04828a>): RecordMethodTest.printStatic(recordMethodTest);
	<.main+5638 @04827e> : 12 04                      dup.x4 sp(4)
	<.main+5640 @048280> : 1f d0 6b 04 00             load.ref <@046bd0> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5645 @048285> : 02                         call
	<.main+5646 @048286> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:91: (12 bytes: <@04828a> - <@048296>): RecordMethodTest.print(recordMethodTestCustomPrint);
	<.main+5650 @04828a> : 12 00                      dup.x4 sp(0)
	<.main+5652 @04828c> : 1f a8 6b 04 00             load.ref <@046ba8> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5657 @048291> : 02                         call
	<.main+5658 @048292> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@048296> - <@0482ac>): black: rgbU8 := {...}
	<.main+5662 @048296> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@04829a> - <@0482a0>): void(black.r := (0));
	<.main+5666 @04829a> : 19                         load.z32
	<.main+5667 @04829b> : 0a 06 00 00                load.sp(+6)
	<.main+5671 @04829f> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@0482a0> - <@0482a6>): void(black.g := (0));
	<.main+5672 @0482a0> : 19                         load.z32
	<.main+5673 @0482a1> : 0a 05 00 00                load.sp(+5)
	<.main+5677 @0482a5> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@0482a6> - <@0482ac>): void(black.b := (0));
	<.main+5678 @0482a6> : 19                         load.z32
	<.main+5679 @0482a7> : 0a 04 00 00                load.sp(+4)
	<.main+5683 @0482ab> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@0482ac> - <@0482c6>): green: rgbU8 := {...}
	<.main+5684 @0482ac> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@0482b0> - <@0482b6>): void(green.r := (0));
	<.main+5688 @0482b0> : 19                         load.z32
	<.main+5689 @0482b1> : 0a 06 00 00                load.sp(+6)
	<.main+5693 @0482b5> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@0482b6> - <@0482c0>): void(green.g := (255));
	<.main+5694 @0482b6> : 1c ff 00 00 00             load.c32 255
	<.main+5699 @0482bb> : 0a 05 00 00                load.sp(+5)
	<.main+5703 @0482bf> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@0482c0> - <@0482c6>): void(green.b := (0));
	<.main+5704 @0482c0> : 19                         load.z32
	<.main+5705 @0482c1> : 0a 04 00 00                load.sp(+4)
	<.main+5709 @0482c5> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@0482c6> - <@0482e8>): white: rgbU8 := {...}
	<.main+5710 @0482c6> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@0482ca> - <@0482d4>): void(white.r := (255));
	<.main+5714 @0482ca> : 1c ff 00 00 00             load.c32 255
	<.main+5719 @0482cf> : 0a 06 00 00                load.sp(+6)
	<.main+5723 @0482d3> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@0482d4> - <@0482de>): void(white.g := (255));
	<.main+5724 @0482d4> : 1c ff 00 00 00             load.c32 255
	<.main+5729 @0482d9> : 0a 05 00 00                load.sp(+5)
	<.main+5733 @0482dd> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@0482de> - <@0482e8>): void(white.b := (255));
	<.main+5734 @0482de> : 1c ff 00 00 00             load.c32 255
	<.main+5739 @0482e3> : 0a 04 00 00                load.sp(+4)
	<.main+5743 @0482e7> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@0482e8> - <@0482f3>): cyan: color := {...}
	<.main+5744 @0482e8> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@0482ec> - <@0482f3>): void(cyan.col := (65535));
	<.main+5748 @0482ec> : 1c ff ff 00 00             load.c32 65535
	<.main+5753 @0482f1> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@0482f3> - <@04830d>): blue: color := {...}
	<.main+5755 @0482f3> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@0482f7> - <@0482fd>): void(blue.rgb.r := (0));
	<.main+5759 @0482f7> : 19                         load.z32
	<.main+5760 @0482f8> : 0a 06 00 00                load.sp(+6)
	<.main+5764 @0482fc> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@0482fd> - <@048303>): void(blue.rgb.g := (0));
	<.main+5765 @0482fd> : 19                         load.z32
	<.main+5766 @0482fe> : 0a 05 00 00                load.sp(+5)
	<.main+5770 @048302> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@048303> - <@04830d>): void(blue.rgb.b := (255));
	<.main+5771 @048303> : 1c ff 00 00 00             load.c32 255
	<.main+5776 @048308> : 0a 04 00 00                load.sp(+4)
	<.main+5780 @04830c> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@04830d> - <@048312>): shift: int32 := 2
	<.main+5781 @04830d> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@048312> - <@048317>): boolA: bool := true
	<.main+5786 @048312> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@048317> - <@04831c>): boolB: bool := bool(!false)
	<.main+5791 @048317> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@04831c> - <@048327>): boolAnd: bool := bool(boolA & boolB)
	<.main+5796 @04831c> : 0a 04 00 00                load.sp(+4)
	<.main+5800 @048320> : 20                         load.i8
	<.main+5801 @048321> : 0a 04 00 00                load.sp(+4)
	<.main+5805 @048325> : 20                         load.i8
	<.main+5806 @048326> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@048327> - <@048332>): boolIor: bool := bool(boolA | boolB)
	<.main+5807 @048327> : 0a 08 00 00                load.sp(+8)
	<.main+5811 @04832b> : 20                         load.i8
	<.main+5812 @04832c> : 0a 08 00 00                load.sp(+8)
	<.main+5816 @048330> : 20                         load.i8
	<.main+5817 @048331> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@048332> - <@04833d>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5818 @048332> : 0a 0c 00 00                load.sp(+12)
	<.main+5822 @048336> : 20                         load.i8
	<.main+5823 @048337> : 0a 0c 00 00                load.sp(+12)
	<.main+5827 @04833b> : 20                         load.i8
	<.main+5828 @04833c> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@04833d> - <@048343>): boolNot: bool := bool(!boolB)
	<.main+5829 @04833d> : 0a 0c 00 00                load.sp(+12)
	<.main+5833 @048341> : 20                         load.i8
	<.main+5834 @048342> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@048343> - <@04834e>): boolCeq: bool := bool(boolA == boolB)
	<.main+5835 @048343> : 0a 14 00 00                load.sp(+20)
	<.main+5839 @048347> : 20                         load.i8
	<.main+5840 @048348> : 0a 14 00 00                load.sp(+20)
	<.main+5844 @04834c> : 20                         load.i8
	<.main+5845 @04834d> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@04834e> - <@04835a>): boolCne: bool := bool(boolA != boolB)
	<.main+5846 @04834e> : 0a 18 00 00                load.sp(+24)
	<.main+5850 @048352> : 20                         load.i8
	<.main+5851 @048353> : 0a 18 00 00                load.sp(+24)
	<.main+5855 @048357> : 20                         load.i8
	<.main+5856 @048358> : 57                         ceq.i32
	<.main+5857 @048359> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@04835a> - <@048365>): boolClt: bool := bool(boolA < boolB)
	<.main+5858 @04835a> : 0a 1c 00 00                load.sp(+28)
	<.main+5862 @04835e> : 20                         load.i8
	<.main+5863 @04835f> : 0a 1c 00 00                load.sp(+28)
	<.main+5867 @048363> : 20                         load.i8
	<.main+5868 @048364> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@048365> - <@048371>): boolCle: bool := bool(boolA <= boolB)
	<.main+5869 @048365> : 0a 20 00 00                load.sp(+32)
	<.main+5873 @048369> : 20                         load.i8
	<.main+5874 @04836a> : 0a 20 00 00                load.sp(+32)
	<.main+5878 @04836e> : 20                         load.i8
	<.main+5879 @04836f> : 59                         cgt.i32
	<.main+5880 @048370> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@048371> - <@04837c>): boolCgt: bool := bool(boolA > boolB)
	<.main+5881 @048371> : 0a 24 00 00                load.sp(+36)
	<.main+5885 @048375> : 20                         load.i8
	<.main+5886 @048376> : 0a 24 00 00                load.sp(+36)
	<.main+5890 @04837a> : 20                         load.i8
	<.main+5891 @04837b> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@04837c> - <@048388>): boolCge: bool := bool(boolA >= boolB)
	<.main+5892 @04837c> : 0a 28 00 00                load.sp(+40)
	<.main+5896 @048380> : 20                         load.i8
	<.main+5897 @048381> : 0a 28 00 00                load.sp(+40)
	<.main+5901 @048385> : 20                         load.i8
	<.main+5902 @048386> : 58                         clt.i32
	<.main+5903 @048387> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@048388> - <@04838d>): chrA: char := 'a'
	<.main+5904 @048388> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@04838d> - <@048392>): chrB: char := 'b'
	<.main+5909 @04838d> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@048392> - <@048397>): chrPls: char := char(+chrB)
	<.main+5914 @048392> : 0a 00 00 00                load.sp(+0)
	<.main+5918 @048396> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@048397> - <@04839d>): chrNeg: char := char(-chrB)
	<.main+5919 @048397> : 0a 04 00 00                load.sp(+4)
	<.main+5923 @04839b> : 20                         load.i8
	<.main+5924 @04839c> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@04839d> - <@0483a3>): chrCmt: char := char(~chrB)
	<.main+5925 @04839d> : 0a 08 00 00                load.sp(+8)
	<.main+5929 @0483a1> : 20                         load.i8
	<.main+5930 @0483a2> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@0483a3> - <@0483ae>): chrAdd: char := char(chrA + chrB)
	<.main+5931 @0483a3> : 0a 10 00 00                load.sp(+16)
	<.main+5935 @0483a7> : 20                         load.i8
	<.main+5936 @0483a8> : 0a 10 00 00                load.sp(+16)
	<.main+5940 @0483ac> : 20                         load.i8
	<.main+5941 @0483ad> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@0483ae> - <@0483b9>): chrSub: char := char(chrA - chrB)
	<.main+5942 @0483ae> : 0a 14 00 00                load.sp(+20)
	<.main+5946 @0483b2> : 20                         load.i8
	<.main+5947 @0483b3> : 0a 14 00 00                load.sp(+20)
	<.main+5951 @0483b7> : 20                         load.i8
	<.main+5952 @0483b8> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@0483b9> - <@0483c4>): chrMul: char := char(chrA * chrB)
	<.main+5953 @0483b9> : 0a 18 00 00                load.sp(+24)
	<.main+5957 @0483bd> : 20                         load.i8
	<.main+5958 @0483be> : 0a 18 00 00                load.sp(+24)
	<.main+5962 @0483c2> : 20                         load.i8
	<.main+5963 @0483c3> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@0483c4> - <@0483cf>): chrDiv: char := char(chrA / chrB)
	<.main+5964 @0483c4> : 0a 1c 00 00                load.sp(+28)
	<.main+5968 @0483c8> : 20                         load.i8
	<.main+5969 @0483c9> : 0a 1c 00 00                load.sp(+28)
	<.main+5973 @0483cd> : 20                         load.i8
	<.main+5974 @0483ce> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@0483cf> - <@0483da>): chrMod: char := char(chrA % chrB)
	<.main+5975 @0483cf> : 0a 20 00 00                load.sp(+32)
	<.main+5979 @0483d3> : 20                         load.i8
	<.main+5980 @0483d4> : 0a 20 00 00                load.sp(+32)
	<.main+5984 @0483d8> : 20                         load.i8
	<.main+5985 @0483d9> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@0483da> - <@0483e5>): chrAnd: char := char(chrA & chrB)
	<.main+5986 @0483da> : 0a 24 00 00                load.sp(+36)
	<.main+5990 @0483de> : 20                         load.i8
	<.main+5991 @0483df> : 0a 24 00 00                load.sp(+36)
	<.main+5995 @0483e3> : 20                         load.i8
	<.main+5996 @0483e4> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@0483e5> - <@0483f0>): chrIor: char := char(chrA | chrB)
	<.main+5997 @0483e5> : 0a 28 00 00                load.sp(+40)
	<.main+6001 @0483e9> : 20                         load.i8
	<.main+6002 @0483ea> : 0a 28 00 00                load.sp(+40)
	<.main+6006 @0483ee> : 20                         load.i8
	<.main+6007 @0483ef> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@0483f0> - <@0483fb>): chrXor: char := char(chrA ^ chrB)
	<.main+6008 @0483f0> : 0a 2c 00 00                load.sp(+44)
	<.main+6012 @0483f4> : 20                         load.i8
	<.main+6013 @0483f5> : 0a 2c 00 00                load.sp(+44)
	<.main+6017 @0483f9> : 20                         load.i8
	<.main+6018 @0483fa> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@0483fb> - <@048403>): chrShl: char := int32((chrA) << shift)
	<.main+6019 @0483fb> : 0a 30 00 00                load.sp(+48)
	<.main+6023 @0483ff> : 20                         load.i8
	<.main+6024 @048400> : 10 1a                      dup.x1 sp(26)
	<.main+6026 @048402> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@048403> - <@04840b>): chrShr: char := int32((chrA) >> shift)
	<.main+6027 @048403> : 0a 34 00 00                load.sp(+52)
	<.main+6031 @048407> : 20                         load.i8
	<.main+6032 @048408> : 10 1b                      dup.x1 sp(27)
	<.main+6034 @04840a> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@04840b> - <@048412>): chrNot: bool := bool(!(chrB))
	<.main+6035 @04840b> : 0a 34 00 00                load.sp(+52)
	<.main+6039 @04840f> : 20                         load.i8
	<.main+6040 @048410> : 5a                         i32.2bool
	<.main+6041 @048411> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@048412> - <@04841d>): chrCeq: bool := bool(chrA == chrB)
	<.main+6042 @048412> : 0a 3c 00 00                load.sp(+60)
	<.main+6046 @048416> : 20                         load.i8
	<.main+6047 @048417> : 0a 3c 00 00                load.sp(+60)
	<.main+6051 @04841b> : 20                         load.i8
	<.main+6052 @04841c> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@04841d> - <@048429>): chrCne: bool := bool(chrA != chrB)
	<.main+6053 @04841d> : 0a 40 00 00                load.sp(+64)
	<.main+6057 @048421> : 20                         load.i8
	<.main+6058 @048422> : 0a 40 00 00                load.sp(+64)
	<.main+6062 @048426> : 20                         load.i8
	<.main+6063 @048427> : 57                         ceq.i32
	<.main+6064 @048428> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@048429> - <@048434>): chrClt: bool := bool(chrA < chrB)
	<.main+6065 @048429> : 0a 44 00 00                load.sp(+68)
	<.main+6069 @04842d> : 20                         load.i8
	<.main+6070 @04842e> : 0a 44 00 00                load.sp(+68)
	<.main+6074 @048432> : 20                         load.i8
	<.main+6075 @048433> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@048434> - <@048440>): chrCle: bool := bool(chrA <= chrB)
	<.main+6076 @048434> : 0a 48 00 00                load.sp(+72)
	<.main+6080 @048438> : 20                         load.i8
	<.main+6081 @048439> : 0a 48 00 00                load.sp(+72)
	<.main+6085 @04843d> : 20                         load.i8
	<.main+6086 @04843e> : 59                         cgt.i32
	<.main+6087 @04843f> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@048440> - <@04844b>): chrCgt: bool := bool(chrA > chrB)
	<.main+6088 @048440> : 0a 4c 00 00                load.sp(+76)
	<.main+6092 @048444> : 20                         load.i8
	<.main+6093 @048445> : 0a 4c 00 00                load.sp(+76)
	<.main+6097 @048449> : 20                         load.i8
	<.main+6098 @04844a> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@04844b> - <@048457>): chrCge: bool := bool(chrA >= chrB)
	<.main+6099 @04844b> : 0a 50 00 00                load.sp(+80)
	<.main+6103 @04844f> : 20                         load.i8
	<.main+6104 @048450> : 0a 50 00 00                load.sp(+80)
	<.main+6108 @048454> : 20                         load.i8
	<.main+6109 @048455> : 58                         clt.i32
	<.main+6110 @048456> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@048457> - <@04845c>): i8A: int8 := a
	<.main+6111 @048457> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@04845c> - <@048461>): i8B: int8 := b
	<.main+6116 @04845c> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@048461> - <@048466>): i8Pls: int8 := int8(+i8B)
	<.main+6121 @048461> : 0a 00 00 00                load.sp(+0)
	<.main+6125 @048465> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@048466> - <@04846c>): i8Neg: int8 := int8(-i8B)
	<.main+6126 @048466> : 0a 04 00 00                load.sp(+4)
	<.main+6130 @04846a> : 20                         load.i8
	<.main+6131 @04846b> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@04846c> - <@048472>): i8Cmt: int8 := int8(~i8B)
	<.main+6132 @04846c> : 0a 08 00 00                load.sp(+8)
	<.main+6136 @048470> : 20                         load.i8
	<.main+6137 @048471> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@048472> - <@04847d>): i8Add: int8 := int8(i8A + i8B)
	<.main+6138 @048472> : 0a 10 00 00                load.sp(+16)
	<.main+6142 @048476> : 20                         load.i8
	<.main+6143 @048477> : 0a 10 00 00                load.sp(+16)
	<.main+6147 @04847b> : 20                         load.i8
	<.main+6148 @04847c> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@04847d> - <@048488>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6149 @04847d> : 0a 14 00 00                load.sp(+20)
	<.main+6153 @048481> : 20                         load.i8
	<.main+6154 @048482> : 0a 14 00 00                load.sp(+20)
	<.main+6158 @048486> : 20                         load.i8
	<.main+6159 @048487> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@048488> - <@048493>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6160 @048488> : 0a 18 00 00                load.sp(+24)
	<.main+6164 @04848c> : 20                         load.i8
	<.main+6165 @04848d> : 0a 18 00 00                load.sp(+24)
	<.main+6169 @048491> : 20                         load.i8
	<.main+6170 @048492> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@048493> - <@04849e>): i8Div: int8 := int8(i8A / i8B)
	<.main+6171 @048493> : 0a 1c 00 00                load.sp(+28)
	<.main+6175 @048497> : 20                         load.i8
	<.main+6176 @048498> : 0a 1c 00 00                load.sp(+28)
	<.main+6180 @04849c> : 20                         load.i8
	<.main+6181 @04849d> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@04849e> - <@0484a9>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6182 @04849e> : 0a 20 00 00                load.sp(+32)
	<.main+6186 @0484a2> : 20                         load.i8
	<.main+6187 @0484a3> : 0a 20 00 00                load.sp(+32)
	<.main+6191 @0484a7> : 20                         load.i8
	<.main+6192 @0484a8> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@0484a9> - <@0484b4>): i8And: int8 := int8(i8A & i8B)
	<.main+6193 @0484a9> : 0a 24 00 00                load.sp(+36)
	<.main+6197 @0484ad> : 20                         load.i8
	<.main+6198 @0484ae> : 0a 24 00 00                load.sp(+36)
	<.main+6202 @0484b2> : 20                         load.i8
	<.main+6203 @0484b3> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@0484b4> - <@0484bf>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6204 @0484b4> : 0a 28 00 00                load.sp(+40)
	<.main+6208 @0484b8> : 20                         load.i8
	<.main+6209 @0484b9> : 0a 28 00 00                load.sp(+40)
	<.main+6213 @0484bd> : 20                         load.i8
	<.main+6214 @0484be> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@0484bf> - <@0484ca>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6215 @0484bf> : 0a 2c 00 00                load.sp(+44)
	<.main+6219 @0484c3> : 20                         load.i8
	<.main+6220 @0484c4> : 0a 2c 00 00                load.sp(+44)
	<.main+6224 @0484c8> : 20                         load.i8
	<.main+6225 @0484c9> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@0484ca> - <@0484d2>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6226 @0484ca> : 0a 30 00 00                load.sp(+48)
	<.main+6230 @0484ce> : 20                         load.i8
	<.main+6231 @0484cf> : 10 30                      dup.x1 sp(48)
	<.main+6233 @0484d1> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@0484d2> - <@0484da>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6234 @0484d2> : 0a 34 00 00                load.sp(+52)
	<.main+6238 @0484d6> : 20                         load.i8
	<.main+6239 @0484d7> : 10 31                      dup.x1 sp(49)
	<.main+6241 @0484d9> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@0484da> - <@0484e1>): i8Not: bool := bool(!(i8B))
	<.main+6242 @0484da> : 0a 34 00 00                load.sp(+52)
	<.main+6246 @0484de> : 20                         load.i8
	<.main+6247 @0484df> : 5a                         i32.2bool
	<.main+6248 @0484e0> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@0484e1> - <@0484ec>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6249 @0484e1> : 0a 3c 00 00                load.sp(+60)
	<.main+6253 @0484e5> : 20                         load.i8
	<.main+6254 @0484e6> : 0a 3c 00 00                load.sp(+60)
	<.main+6258 @0484ea> : 20                         load.i8
	<.main+6259 @0484eb> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@0484ec> - <@0484f8>): i8Cne: bool := bool(i8A != i8B)
	<.main+6260 @0484ec> : 0a 40 00 00                load.sp(+64)
	<.main+6264 @0484f0> : 20                         load.i8
	<.main+6265 @0484f1> : 0a 40 00 00                load.sp(+64)
	<.main+6269 @0484f5> : 20                         load.i8
	<.main+6270 @0484f6> : 57                         ceq.i32
	<.main+6271 @0484f7> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@0484f8> - <@048503>): i8Clt: bool := bool(i8A < i8B)
	<.main+6272 @0484f8> : 0a 44 00 00                load.sp(+68)
	<.main+6276 @0484fc> : 20                         load.i8
	<.main+6277 @0484fd> : 0a 44 00 00                load.sp(+68)
	<.main+6281 @048501> : 20                         load.i8
	<.main+6282 @048502> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@048503> - <@04850f>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6283 @048503> : 0a 48 00 00                load.sp(+72)
	<.main+6287 @048507> : 20                         load.i8
	<.main+6288 @048508> : 0a 48 00 00                load.sp(+72)
	<.main+6292 @04850c> : 20                         load.i8
	<.main+6293 @04850d> : 59                         cgt.i32
	<.main+6294 @04850e> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@04850f> - <@04851a>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6295 @04850f> : 0a 4c 00 00                load.sp(+76)
	<.main+6299 @048513> : 20                         load.i8
	<.main+6300 @048514> : 0a 4c 00 00                load.sp(+76)
	<.main+6304 @048518> : 20                         load.i8
	<.main+6305 @048519> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@04851a> - <@048526>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6306 @04851a> : 0a 50 00 00                load.sp(+80)
	<.main+6310 @04851e> : 20                         load.i8
	<.main+6311 @04851f> : 0a 50 00 00                load.sp(+80)
	<.main+6315 @048523> : 20                         load.i8
	<.main+6316 @048524> : 58                         clt.i32
	<.main+6317 @048525> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@048526> - <@04852b>): u8A: uint8 := a
	<.main+6318 @048526> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@04852b> - <@048530>): u8B: uint8 := b
	<.main+6323 @04852b> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@048530> - <@048535>): u8Pls: uint8 := uint8(+u8B)
	<.main+6328 @048530> : 0a 00 00 00                load.sp(+0)
	<.main+6332 @048534> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@048535> - <@04853b>): u8Neg: uint8 := uint8(-u8B)
	<.main+6333 @048535> : 0a 04 00 00                load.sp(+4)
	<.main+6337 @048539> : 20                         load.i8
	<.main+6338 @04853a> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@04853b> - <@048541>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6339 @04853b> : 0a 08 00 00                load.sp(+8)
	<.main+6343 @04853f> : 20                         load.i8
	<.main+6344 @048540> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@048541> - <@04854c>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6345 @048541> : 0a 10 00 00                load.sp(+16)
	<.main+6349 @048545> : 20                         load.i8
	<.main+6350 @048546> : 0a 10 00 00                load.sp(+16)
	<.main+6354 @04854a> : 20                         load.i8
	<.main+6355 @04854b> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@04854c> - <@048557>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6356 @04854c> : 0a 14 00 00                load.sp(+20)
	<.main+6360 @048550> : 20                         load.i8
	<.main+6361 @048551> : 0a 14 00 00                load.sp(+20)
	<.main+6365 @048555> : 20                         load.i8
	<.main+6366 @048556> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@048557> - <@048562>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6367 @048557> : 0a 18 00 00                load.sp(+24)
	<.main+6371 @04855b> : 20                         load.i8
	<.main+6372 @04855c> : 0a 18 00 00                load.sp(+24)
	<.main+6376 @048560> : 20                         load.i8
	<.main+6377 @048561> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@048562> - <@04856d>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6378 @048562> : 0a 1c 00 00                load.sp(+28)
	<.main+6382 @048566> : 20                         load.i8
	<.main+6383 @048567> : 0a 1c 00 00                load.sp(+28)
	<.main+6387 @04856b> : 20                         load.i8
	<.main+6388 @04856c> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@04856d> - <@048578>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6389 @04856d> : 0a 20 00 00                load.sp(+32)
	<.main+6393 @048571> : 20                         load.i8
	<.main+6394 @048572> : 0a 20 00 00                load.sp(+32)
	<.main+6398 @048576> : 20                         load.i8
	<.main+6399 @048577> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@048578> - <@048583>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6400 @048578> : 0a 24 00 00                load.sp(+36)
	<.main+6404 @04857c> : 20                         load.i8
	<.main+6405 @04857d> : 0a 24 00 00                load.sp(+36)
	<.main+6409 @048581> : 20                         load.i8
	<.main+6410 @048582> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@048583> - <@04858e>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6411 @048583> : 0a 28 00 00                load.sp(+40)
	<.main+6415 @048587> : 20                         load.i8
	<.main+6416 @048588> : 0a 28 00 00                load.sp(+40)
	<.main+6420 @04858c> : 20                         load.i8
	<.main+6421 @04858d> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@04858e> - <@048599>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6422 @04858e> : 0a 2c 00 00                load.sp(+44)
	<.main+6426 @048592> : 20                         load.i8
	<.main+6427 @048593> : 0a 2c 00 00                load.sp(+44)
	<.main+6431 @048597> : 20                         load.i8
	<.main+6432 @048598> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@048599> - <@0485a1>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6433 @048599> : 0a 30 00 00                load.sp(+48)
	<.main+6437 @04859d> : 20                         load.i8
	<.main+6438 @04859e> : 10 46                      dup.x1 sp(70)
	<.main+6440 @0485a0> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@0485a1> - <@0485a9>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6441 @0485a1> : 0a 34 00 00                load.sp(+52)
	<.main+6445 @0485a5> : 20                         load.i8
	<.main+6446 @0485a6> : 10 47                      dup.x1 sp(71)
	<.main+6448 @0485a8> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@0485a9> - <@0485b0>): u8Not: bool := bool(!(u8B))
	<.main+6449 @0485a9> : 0a 34 00 00                load.sp(+52)
	<.main+6453 @0485ad> : 20                         load.i8
	<.main+6454 @0485ae> : 5a                         i32.2bool
	<.main+6455 @0485af> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@0485b0> - <@0485bb>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6456 @0485b0> : 0a 3c 00 00                load.sp(+60)
	<.main+6460 @0485b4> : 20                         load.i8
	<.main+6461 @0485b5> : 0a 3c 00 00                load.sp(+60)
	<.main+6465 @0485b9> : 20                         load.i8
	<.main+6466 @0485ba> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@0485bb> - <@0485c7>): u8Cne: bool := bool(u8A != u8B)
	<.main+6467 @0485bb> : 0a 40 00 00                load.sp(+64)
	<.main+6471 @0485bf> : 20                         load.i8
	<.main+6472 @0485c0> : 0a 40 00 00                load.sp(+64)
	<.main+6476 @0485c4> : 20                         load.i8
	<.main+6477 @0485c5> : 57                         ceq.i32
	<.main+6478 @0485c6> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@0485c7> - <@0485d2>): u8Clt: bool := bool(u8A < u8B)
	<.main+6479 @0485c7> : 0a 44 00 00                load.sp(+68)
	<.main+6483 @0485cb> : 20                         load.i8
	<.main+6484 @0485cc> : 0a 44 00 00                load.sp(+68)
	<.main+6488 @0485d0> : 20                         load.i8
	<.main+6489 @0485d1> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@0485d2> - <@0485de>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6490 @0485d2> : 0a 48 00 00                load.sp(+72)
	<.main+6494 @0485d6> : 20                         load.i8
	<.main+6495 @0485d7> : 0a 48 00 00                load.sp(+72)
	<.main+6499 @0485db> : 20                         load.i8
	<.main+6500 @0485dc> : 39                         cgt.u32
	<.main+6501 @0485dd> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@0485de> - <@0485e9>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6502 @0485de> : 0a 4c 00 00                load.sp(+76)
	<.main+6506 @0485e2> : 20                         load.i8
	<.main+6507 @0485e3> : 0a 4c 00 00                load.sp(+76)
	<.main+6511 @0485e7> : 20                         load.i8
	<.main+6512 @0485e8> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@0485e9> - <@0485f5>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6513 @0485e9> : 0a 50 00 00                load.sp(+80)
	<.main+6517 @0485ed> : 20                         load.i8
	<.main+6518 @0485ee> : 0a 50 00 00                load.sp(+80)
	<.main+6522 @0485f2> : 20                         load.i8
	<.main+6523 @0485f3> : 38                         clt.u32
	<.main+6524 @0485f4> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@0485f5> - <@0485fa>): i16A: int16 := a
	<.main+6525 @0485f5> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@0485fa> - <@0485ff>): i16B: int16 := b
	<.main+6530 @0485fa> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@0485ff> - <@048604>): i16Pls: int16 := int16(+i16B)
	<.main+6535 @0485ff> : 0a 00 00 00                load.sp(+0)
	<.main+6539 @048603> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@048604> - <@04860a>): i16Neg: int16 := int16(-i16B)
	<.main+6540 @048604> : 0a 04 00 00                load.sp(+4)
	<.main+6544 @048608> : 21                         load.i16
	<.main+6545 @048609> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@04860a> - <@048610>): i16Cmt: int16 := int16(~i16B)
	<.main+6546 @04860a> : 0a 08 00 00                load.sp(+8)
	<.main+6550 @04860e> : 21                         load.i16
	<.main+6551 @04860f> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@048610> - <@04861b>): i16Add: int16 := int16(i16A + i16B)
	<.main+6552 @048610> : 0a 10 00 00                load.sp(+16)
	<.main+6556 @048614> : 21                         load.i16
	<.main+6557 @048615> : 0a 10 00 00                load.sp(+16)
	<.main+6561 @048619> : 21                         load.i16
	<.main+6562 @04861a> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@04861b> - <@048626>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6563 @04861b> : 0a 14 00 00                load.sp(+20)
	<.main+6567 @04861f> : 21                         load.i16
	<.main+6568 @048620> : 0a 14 00 00                load.sp(+20)
	<.main+6572 @048624> : 21                         load.i16
	<.main+6573 @048625> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@048626> - <@048631>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6574 @048626> : 0a 18 00 00                load.sp(+24)
	<.main+6578 @04862a> : 21                         load.i16
	<.main+6579 @04862b> : 0a 18 00 00                load.sp(+24)
	<.main+6583 @04862f> : 21                         load.i16
	<.main+6584 @048630> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@048631> - <@04863c>): i16Div: int16 := int16(i16A / i16B)
	<.main+6585 @048631> : 0a 1c 00 00                load.sp(+28)
	<.main+6589 @048635> : 21                         load.i16
	<.main+6590 @048636> : 0a 1c 00 00                load.sp(+28)
	<.main+6594 @04863a> : 21                         load.i16
	<.main+6595 @04863b> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@04863c> - <@048647>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6596 @04863c> : 0a 20 00 00                load.sp(+32)
	<.main+6600 @048640> : 21                         load.i16
	<.main+6601 @048641> : 0a 20 00 00                load.sp(+32)
	<.main+6605 @048645> : 21                         load.i16
	<.main+6606 @048646> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@048647> - <@048652>): i16And: int16 := int16(i16A & i16B)
	<.main+6607 @048647> : 0a 24 00 00                load.sp(+36)
	<.main+6611 @04864b> : 21                         load.i16
	<.main+6612 @04864c> : 0a 24 00 00                load.sp(+36)
	<.main+6616 @048650> : 21                         load.i16
	<.main+6617 @048651> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@048652> - <@04865d>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6618 @048652> : 0a 28 00 00                load.sp(+40)
	<.main+6622 @048656> : 21                         load.i16
	<.main+6623 @048657> : 0a 28 00 00                load.sp(+40)
	<.main+6627 @04865b> : 21                         load.i16
	<.main+6628 @04865c> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@04865d> - <@048668>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6629 @04865d> : 0a 2c 00 00                load.sp(+44)
	<.main+6633 @048661> : 21                         load.i16
	<.main+6634 @048662> : 0a 2c 00 00                load.sp(+44)
	<.main+6638 @048666> : 21                         load.i16
	<.main+6639 @048667> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@048668> - <@048670>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6640 @048668> : 0a 30 00 00                load.sp(+48)
	<.main+6644 @04866c> : 21                         load.i16
	<.main+6645 @04866d> : 10 5c                      dup.x1 sp(92)
	<.main+6647 @04866f> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@048670> - <@048678>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6648 @048670> : 0a 34 00 00                load.sp(+52)
	<.main+6652 @048674> : 21                         load.i16
	<.main+6653 @048675> : 10 5d                      dup.x1 sp(93)
	<.main+6655 @048677> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@048678> - <@04867f>): i16Not: bool := bool(!(i16B))
	<.main+6656 @048678> : 0a 34 00 00                load.sp(+52)
	<.main+6660 @04867c> : 21                         load.i16
	<.main+6661 @04867d> : 5a                         i32.2bool
	<.main+6662 @04867e> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@04867f> - <@04868a>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6663 @04867f> : 0a 3c 00 00                load.sp(+60)
	<.main+6667 @048683> : 21                         load.i16
	<.main+6668 @048684> : 0a 3c 00 00                load.sp(+60)
	<.main+6672 @048688> : 21                         load.i16
	<.main+6673 @048689> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@04868a> - <@048696>): i16Cne: bool := bool(i16A != i16B)
	<.main+6674 @04868a> : 0a 40 00 00                load.sp(+64)
	<.main+6678 @04868e> : 21                         load.i16
	<.main+6679 @04868f> : 0a 40 00 00                load.sp(+64)
	<.main+6683 @048693> : 21                         load.i16
	<.main+6684 @048694> : 57                         ceq.i32
	<.main+6685 @048695> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@048696> - <@0486a1>): i16Clt: bool := bool(i16A < i16B)
	<.main+6686 @048696> : 0a 44 00 00                load.sp(+68)
	<.main+6690 @04869a> : 21                         load.i16
	<.main+6691 @04869b> : 0a 44 00 00                load.sp(+68)
	<.main+6695 @04869f> : 21                         load.i16
	<.main+6696 @0486a0> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@0486a1> - <@0486ad>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6697 @0486a1> : 0a 48 00 00                load.sp(+72)
	<.main+6701 @0486a5> : 21                         load.i16
	<.main+6702 @0486a6> : 0a 48 00 00                load.sp(+72)
	<.main+6706 @0486aa> : 21                         load.i16
	<.main+6707 @0486ab> : 59                         cgt.i32
	<.main+6708 @0486ac> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@0486ad> - <@0486b8>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6709 @0486ad> : 0a 4c 00 00                load.sp(+76)
	<.main+6713 @0486b1> : 21                         load.i16
	<.main+6714 @0486b2> : 0a 4c 00 00                load.sp(+76)
	<.main+6718 @0486b6> : 21                         load.i16
	<.main+6719 @0486b7> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@0486b8> - <@0486c4>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6720 @0486b8> : 0a 50 00 00                load.sp(+80)
	<.main+6724 @0486bc> : 21                         load.i16
	<.main+6725 @0486bd> : 0a 50 00 00                load.sp(+80)
	<.main+6729 @0486c1> : 21                         load.i16
	<.main+6730 @0486c2> : 58                         clt.i32
	<.main+6731 @0486c3> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@0486c4> - <@0486c9>): u16A: uint16 := a
	<.main+6732 @0486c4> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@0486c9> - <@0486ce>): u16B: uint16 := b
	<.main+6737 @0486c9> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@0486ce> - <@0486d3>): u16Pls: uint16 := uint16(+u16B)
	<.main+6742 @0486ce> : 0a 00 00 00                load.sp(+0)
	<.main+6746 @0486d2> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@0486d3> - <@0486d9>): u16Neg: uint16 := uint16(-u16B)
	<.main+6747 @0486d3> : 0a 04 00 00                load.sp(+4)
	<.main+6751 @0486d7> : 21                         load.i16
	<.main+6752 @0486d8> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@0486d9> - <@0486df>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6753 @0486d9> : 0a 08 00 00                load.sp(+8)
	<.main+6757 @0486dd> : 21                         load.i16
	<.main+6758 @0486de> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@0486df> - <@0486ea>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6759 @0486df> : 0a 10 00 00                load.sp(+16)
	<.main+6763 @0486e3> : 21                         load.i16
	<.main+6764 @0486e4> : 0a 10 00 00                load.sp(+16)
	<.main+6768 @0486e8> : 21                         load.i16
	<.main+6769 @0486e9> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@0486ea> - <@0486f5>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6770 @0486ea> : 0a 14 00 00                load.sp(+20)
	<.main+6774 @0486ee> : 21                         load.i16
	<.main+6775 @0486ef> : 0a 14 00 00                load.sp(+20)
	<.main+6779 @0486f3> : 21                         load.i16
	<.main+6780 @0486f4> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@0486f5> - <@048700>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6781 @0486f5> : 0a 18 00 00                load.sp(+24)
	<.main+6785 @0486f9> : 21                         load.i16
	<.main+6786 @0486fa> : 0a 18 00 00                load.sp(+24)
	<.main+6790 @0486fe> : 21                         load.i16
	<.main+6791 @0486ff> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@048700> - <@04870b>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6792 @048700> : 0a 1c 00 00                load.sp(+28)
	<.main+6796 @048704> : 21                         load.i16
	<.main+6797 @048705> : 0a 1c 00 00                load.sp(+28)
	<.main+6801 @048709> : 21                         load.i16
	<.main+6802 @04870a> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@04870b> - <@048716>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6803 @04870b> : 0a 20 00 00                load.sp(+32)
	<.main+6807 @04870f> : 21                         load.i16
	<.main+6808 @048710> : 0a 20 00 00                load.sp(+32)
	<.main+6812 @048714> : 21                         load.i16
	<.main+6813 @048715> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@048716> - <@048721>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6814 @048716> : 0a 24 00 00                load.sp(+36)
	<.main+6818 @04871a> : 21                         load.i16
	<.main+6819 @04871b> : 0a 24 00 00                load.sp(+36)
	<.main+6823 @04871f> : 21                         load.i16
	<.main+6824 @048720> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@048721> - <@04872c>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6825 @048721> : 0a 28 00 00                load.sp(+40)
	<.main+6829 @048725> : 21                         load.i16
	<.main+6830 @048726> : 0a 28 00 00                load.sp(+40)
	<.main+6834 @04872a> : 21                         load.i16
	<.main+6835 @04872b> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@04872c> - <@048737>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6836 @04872c> : 0a 2c 00 00                load.sp(+44)
	<.main+6840 @048730> : 21                         load.i16
	<.main+6841 @048731> : 0a 2c 00 00                load.sp(+44)
	<.main+6845 @048735> : 21                         load.i16
	<.main+6846 @048736> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@048737> - <@04873f>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6847 @048737> : 0a 30 00 00                load.sp(+48)
	<.main+6851 @04873b> : 21                         load.i16
	<.main+6852 @04873c> : 10 72                      dup.x1 sp(114)
	<.main+6854 @04873e> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@04873f> - <@048747>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6855 @04873f> : 0a 34 00 00                load.sp(+52)
	<.main+6859 @048743> : 21                         load.i16
	<.main+6860 @048744> : 10 73                      dup.x1 sp(115)
	<.main+6862 @048746> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@048747> - <@04874e>): u16Not: bool := bool(!(u16B))
	<.main+6863 @048747> : 0a 34 00 00                load.sp(+52)
	<.main+6867 @04874b> : 21                         load.i16
	<.main+6868 @04874c> : 5a                         i32.2bool
	<.main+6869 @04874d> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@04874e> - <@048759>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6870 @04874e> : 0a 3c 00 00                load.sp(+60)
	<.main+6874 @048752> : 21                         load.i16
	<.main+6875 @048753> : 0a 3c 00 00                load.sp(+60)
	<.main+6879 @048757> : 21                         load.i16
	<.main+6880 @048758> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@048759> - <@048765>): u16Cne: bool := bool(u16A != u16B)
	<.main+6881 @048759> : 0a 40 00 00                load.sp(+64)
	<.main+6885 @04875d> : 21                         load.i16
	<.main+6886 @04875e> : 0a 40 00 00                load.sp(+64)
	<.main+6890 @048762> : 21                         load.i16
	<.main+6891 @048763> : 57                         ceq.i32
	<.main+6892 @048764> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@048765> - <@048770>): u16Clt: bool := bool(u16A < u16B)
	<.main+6893 @048765> : 0a 44 00 00                load.sp(+68)
	<.main+6897 @048769> : 21                         load.i16
	<.main+6898 @04876a> : 0a 44 00 00                load.sp(+68)
	<.main+6902 @04876e> : 21                         load.i16
	<.main+6903 @04876f> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@048770> - <@04877c>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6904 @048770> : 0a 48 00 00                load.sp(+72)
	<.main+6908 @048774> : 21                         load.i16
	<.main+6909 @048775> : 0a 48 00 00                load.sp(+72)
	<.main+6913 @048779> : 21                         load.i16
	<.main+6914 @04877a> : 39                         cgt.u32
	<.main+6915 @04877b> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@04877c> - <@048787>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6916 @04877c> : 0a 4c 00 00                load.sp(+76)
	<.main+6920 @048780> : 21                         load.i16
	<.main+6921 @048781> : 0a 4c 00 00                load.sp(+76)
	<.main+6925 @048785> : 21                         load.i16
	<.main+6926 @048786> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@048787> - <@048793>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6927 @048787> : 0a 50 00 00                load.sp(+80)
	<.main+6931 @04878b> : 21                         load.i16
	<.main+6932 @04878c> : 0a 50 00 00                load.sp(+80)
	<.main+6936 @048790> : 21                         load.i16
	<.main+6937 @048791> : 38                         clt.u32
	<.main+6938 @048792> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@048793> - <@048798>): i32A: int32 := a
	<.main+6939 @048793> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@048798> - <@04879d>): i32B: int32 := b
	<.main+6944 @048798> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@04879d> - <@04879f>): i32Pls: int32 := int32(+i32B)
	<.main+6949 @04879d> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@04879f> - <@0487a2>): i32Neg: int32 := int32(-i32B)
	<.main+6951 @04879f> : 10 01                      dup.x1 sp(1)
	<.main+6953 @0487a1> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@0487a2> - <@0487a5>): i32Cmt: int32 := int32(~i32B)
	<.main+6954 @0487a2> : 10 02                      dup.x1 sp(2)
	<.main+6956 @0487a4> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@0487a5> - <@0487aa>): i32Add: int32 := int32(i32A + i32B)
	<.main+6957 @0487a5> : 10 04                      dup.x1 sp(4)
	<.main+6959 @0487a7> : 10 04                      dup.x1 sp(4)
	<.main+6961 @0487a9> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@0487aa> - <@0487af>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6962 @0487aa> : 10 05                      dup.x1 sp(5)
	<.main+6964 @0487ac> : 10 05                      dup.x1 sp(5)
	<.main+6966 @0487ae> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@0487af> - <@0487b4>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6967 @0487af> : 10 06                      dup.x1 sp(6)
	<.main+6969 @0487b1> : 10 06                      dup.x1 sp(6)
	<.main+6971 @0487b3> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@0487b4> - <@0487b9>): i32Div: int32 := int32(i32A / i32B)
	<.main+6972 @0487b4> : 10 07                      dup.x1 sp(7)
	<.main+6974 @0487b6> : 10 07                      dup.x1 sp(7)
	<.main+6976 @0487b8> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@0487b9> - <@0487be>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6977 @0487b9> : 10 08                      dup.x1 sp(8)
	<.main+6979 @0487bb> : 10 08                      dup.x1 sp(8)
	<.main+6981 @0487bd> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@0487be> - <@0487c3>): i32And: int32 := int32(i32A & i32B)
	<.main+6982 @0487be> : 10 09                      dup.x1 sp(9)
	<.main+6984 @0487c0> : 10 09                      dup.x1 sp(9)
	<.main+6986 @0487c2> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@0487c3> - <@0487c8>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6987 @0487c3> : 10 0a                      dup.x1 sp(10)
	<.main+6989 @0487c5> : 10 0a                      dup.x1 sp(10)
	<.main+6991 @0487c7> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@0487c8> - <@0487cd>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6992 @0487c8> : 10 0b                      dup.x1 sp(11)
	<.main+6994 @0487ca> : 10 0b                      dup.x1 sp(11)
	<.main+6996 @0487cc> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@0487cd> - <@0487d2>): i32Shl: int32 := int32(i32A << shift)
	<.main+6997 @0487cd> : 10 0c                      dup.x1 sp(12)
	<.main+6999 @0487cf> : 10 88                      dup.x1 sp(136)
	<.main+7001 @0487d1> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@0487d2> - <@0487d7>): i32Shr: int32 := int32(i32A >> shift)
	<.main+7002 @0487d2> : 10 0d                      dup.x1 sp(13)
	<.main+7004 @0487d4> : 10 89                      dup.x1 sp(137)
	<.main+7006 @0487d6> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@0487d7> - <@0487db>): i32Not: bool := bool(!(i32B))
	<.main+7007 @0487d7> : 10 0d                      dup.x1 sp(13)
	<.main+7009 @0487d9> : 5a                         i32.2bool
	<.main+7010 @0487da> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@0487db> - <@0487e0>): i32Ceq: bool := bool(i32A == i32B)
	<.main+7011 @0487db> : 10 0f                      dup.x1 sp(15)
	<.main+7013 @0487dd> : 10 0f                      dup.x1 sp(15)
	<.main+7015 @0487df> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@0487e0> - <@0487e6>): i32Cne: bool := bool(i32A != i32B)
	<.main+7016 @0487e0> : 10 10                      dup.x1 sp(16)
	<.main+7018 @0487e2> : 10 10                      dup.x1 sp(16)
	<.main+7020 @0487e4> : 57                         ceq.i32
	<.main+7021 @0487e5> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@0487e6> - <@0487eb>): i32Clt: bool := bool(i32A < i32B)
	<.main+7022 @0487e6> : 10 11                      dup.x1 sp(17)
	<.main+7024 @0487e8> : 10 11                      dup.x1 sp(17)
	<.main+7026 @0487ea> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@0487eb> - <@0487f1>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7027 @0487eb> : 10 12                      dup.x1 sp(18)
	<.main+7029 @0487ed> : 10 12                      dup.x1 sp(18)
	<.main+7031 @0487ef> : 59                         cgt.i32
	<.main+7032 @0487f0> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@0487f1> - <@0487f6>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7033 @0487f1> : 10 13                      dup.x1 sp(19)
	<.main+7035 @0487f3> : 10 13                      dup.x1 sp(19)
	<.main+7037 @0487f5> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@0487f6> - <@0487fc>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7038 @0487f6> : 10 14                      dup.x1 sp(20)
	<.main+7040 @0487f8> : 10 14                      dup.x1 sp(20)
	<.main+7042 @0487fa> : 58                         clt.i32
	<.main+7043 @0487fb> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@0487fc> - <@048801>): u32A: uint32 := a
	<.main+7044 @0487fc> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@048801> - <@048806>): u32B: uint32 := b
	<.main+7049 @048801> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@048806> - <@048808>): u32Pls: uint32 := uint32(+u32B)
	<.main+7054 @048806> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@048808> - <@04880b>): u32Neg: uint32 := uint32(-u32B)
	<.main+7056 @048808> : 10 01                      dup.x1 sp(1)
	<.main+7058 @04880a> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@04880b> - <@04880e>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7059 @04880b> : 10 02                      dup.x1 sp(2)
	<.main+7061 @04880d> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@04880e> - <@048813>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7062 @04880e> : 10 04                      dup.x1 sp(4)
	<.main+7064 @048810> : 10 04                      dup.x1 sp(4)
	<.main+7066 @048812> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@048813> - <@048818>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7067 @048813> : 10 05                      dup.x1 sp(5)
	<.main+7069 @048815> : 10 05                      dup.x1 sp(5)
	<.main+7071 @048817> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@048818> - <@04881d>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7072 @048818> : 10 06                      dup.x1 sp(6)
	<.main+7074 @04881a> : 10 06                      dup.x1 sp(6)
	<.main+7076 @04881c> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@04881d> - <@048822>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7077 @04881d> : 10 07                      dup.x1 sp(7)
	<.main+7079 @04881f> : 10 07                      dup.x1 sp(7)
	<.main+7081 @048821> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@048822> - <@048827>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7082 @048822> : 10 08                      dup.x1 sp(8)
	<.main+7084 @048824> : 10 08                      dup.x1 sp(8)
	<.main+7086 @048826> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@048827> - <@04882c>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7087 @048827> : 10 09                      dup.x1 sp(9)
	<.main+7089 @048829> : 10 09                      dup.x1 sp(9)
	<.main+7091 @04882b> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@04882c> - <@048831>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7092 @04882c> : 10 0a                      dup.x1 sp(10)
	<.main+7094 @04882e> : 10 0a                      dup.x1 sp(10)
	<.main+7096 @048830> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@048831> - <@048836>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7097 @048831> : 10 0b                      dup.x1 sp(11)
	<.main+7099 @048833> : 10 0b                      dup.x1 sp(11)
	<.main+7101 @048835> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@048836> - <@04883b>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7102 @048836> : 10 0c                      dup.x1 sp(12)
	<.main+7104 @048838> : 10 9e                      dup.x1 sp(158)
	<.main+7106 @04883a> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@04883b> - <@048840>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7107 @04883b> : 10 0d                      dup.x1 sp(13)
	<.main+7109 @04883d> : 10 9f                      dup.x1 sp(159)
	<.main+7111 @04883f> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@048840> - <@048844>): u32Not: bool := bool(!(u32B))
	<.main+7112 @048840> : 10 0d                      dup.x1 sp(13)
	<.main+7114 @048842> : 5a                         i32.2bool
	<.main+7115 @048843> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@048844> - <@048849>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7116 @048844> : 10 0f                      dup.x1 sp(15)
	<.main+7118 @048846> : 10 0f                      dup.x1 sp(15)
	<.main+7120 @048848> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@048849> - <@04884f>): u32Cne: bool := bool(u32A != u32B)
	<.main+7121 @048849> : 10 10                      dup.x1 sp(16)
	<.main+7123 @04884b> : 10 10                      dup.x1 sp(16)
	<.main+7125 @04884d> : 57                         ceq.i32
	<.main+7126 @04884e> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@04884f> - <@048854>): u32Clt: bool := bool(u32A < u32B)
	<.main+7127 @04884f> : 10 11                      dup.x1 sp(17)
	<.main+7129 @048851> : 10 11                      dup.x1 sp(17)
	<.main+7131 @048853> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@048854> - <@04885a>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7132 @048854> : 10 12                      dup.x1 sp(18)
	<.main+7134 @048856> : 10 12                      dup.x1 sp(18)
	<.main+7136 @048858> : 39                         cgt.u32
	<.main+7137 @048859> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@04885a> - <@04885f>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7138 @04885a> : 10 13                      dup.x1 sp(19)
	<.main+7140 @04885c> : 10 13                      dup.x1 sp(19)
	<.main+7142 @04885e> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@04885f> - <@048865>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7143 @04885f> : 10 14                      dup.x1 sp(20)
	<.main+7145 @048861> : 10 14                      dup.x1 sp(20)
	<.main+7147 @048863> : 38                         clt.u32
	<.main+7148 @048864> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@048865> - <@04886e>): i64A: int64 := a
	<.main+7149 @048865> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@04886e> - <@048877>): i64B: int64 := b
	<.main+7158 @04886e> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@048877> - <@048879>): i64Pls: int64 := int64(+i64B)
	<.main+7167 @048877> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@048879> - <@04887c>): i64Neg: int64 := int64(-i64B)
	<.main+7169 @048879> : 11 02                      dup.x2 sp(2)
	<.main+7171 @04887b> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@04887c> - <@04887f>): i64Cmt: int64 := int64(~i64B)
	<.main+7172 @04887c> : 11 04                      dup.x2 sp(4)
	<.main+7174 @04887e> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@04887f> - <@048884>): i64Add: int64 := int64(i64A + i64B)
	<.main+7175 @04887f> : 11 08                      dup.x2 sp(8)
	<.main+7177 @048881> : 11 08                      dup.x2 sp(8)
	<.main+7179 @048883> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@048884> - <@048889>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7180 @048884> : 11 0a                      dup.x2 sp(10)
	<.main+7182 @048886> : 11 0a                      dup.x2 sp(10)
	<.main+7184 @048888> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@048889> - <@04888e>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7185 @048889> : 11 0c                      dup.x2 sp(12)
	<.main+7187 @04888b> : 11 0c                      dup.x2 sp(12)
	<.main+7189 @04888d> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@04888e> - <@048893>): i64Div: int64 := int64(i64A / i64B)
	<.main+7190 @04888e> : 11 0e                      dup.x2 sp(14)
	<.main+7192 @048890> : 11 0e                      dup.x2 sp(14)
	<.main+7194 @048892> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@048893> - <@048898>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7195 @048893> : 11 10                      dup.x2 sp(16)
	<.main+7197 @048895> : 11 10                      dup.x2 sp(16)
	<.main+7199 @048897> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@048898> - <@04889d>): i64And: int64 := int64(i64A & i64B)
	<.main+7200 @048898> : 11 12                      dup.x2 sp(18)
	<.main+7202 @04889a> : 11 12                      dup.x2 sp(18)
	<.main+7204 @04889c> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@04889d> - <@0488a2>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7205 @04889d> : 11 14                      dup.x2 sp(20)
	<.main+7207 @04889f> : 11 14                      dup.x2 sp(20)
	<.main+7209 @0488a1> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@0488a2> - <@0488a7>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7210 @0488a2> : 11 16                      dup.x2 sp(22)
	<.main+7212 @0488a4> : 11 16                      dup.x2 sp(22)
	<.main+7214 @0488a6> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@0488a7> - <@0488ac>): i64Shl: int64 := int64(i64A << shift)
	<.main+7215 @0488a7> : 11 18                      dup.x2 sp(24)
	<.main+7217 @0488a9> : 10 c2                      dup.x1 sp(194)
	<.main+7219 @0488ab> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@0488ac> - <@0488b1>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7220 @0488ac> : 11 1a                      dup.x2 sp(26)
	<.main+7222 @0488ae> : 10 c4                      dup.x1 sp(196)
	<.main+7224 @0488b0> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@0488b1> - <@0488b5>): i64Not: bool := bool(!(i64B))
	<.main+7225 @0488b1> : 11 1a                      dup.x2 sp(26)
	<.main+7227 @0488b3> : 6c                         i64.2bool
	<.main+7228 @0488b4> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@0488b5> - <@0488ba>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7229 @0488b5> : 11 1d                      dup.x2 sp(29)
	<.main+7231 @0488b7> : 11 1d                      dup.x2 sp(29)
	<.main+7233 @0488b9> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@0488ba> - <@0488c0>): i64Cne: bool := bool(i64A != i64B)
	<.main+7234 @0488ba> : 11 1e                      dup.x2 sp(30)
	<.main+7236 @0488bc> : 11 1e                      dup.x2 sp(30)
	<.main+7238 @0488be> : 67                         ceq.i64
	<.main+7239 @0488bf> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@0488c0> - <@0488c5>): i64Clt: bool := bool(i64A < i64B)
	<.main+7240 @0488c0> : 11 1f                      dup.x2 sp(31)
	<.main+7242 @0488c2> : 11 1f                      dup.x2 sp(31)
	<.main+7244 @0488c4> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@0488c5> - <@0488cb>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7245 @0488c5> : 11 20                      dup.x2 sp(32)
	<.main+7247 @0488c7> : 11 20                      dup.x2 sp(32)
	<.main+7249 @0488c9> : 69                         cgt.i64
	<.main+7250 @0488ca> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@0488cb> - <@0488d0>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7251 @0488cb> : 11 21                      dup.x2 sp(33)
	<.main+7253 @0488cd> : 11 21                      dup.x2 sp(33)
	<.main+7255 @0488cf> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@0488d0> - <@0488d6>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7256 @0488d0> : 11 22                      dup.x2 sp(34)
	<.main+7258 @0488d2> : 11 22                      dup.x2 sp(34)
	<.main+7260 @0488d4> : 68                         clt.i64
	<.main+7261 @0488d5> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@0488d6> - <@0488df>): u64A: uint64 := a
	<.main+7262 @0488d6> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@0488df> - <@0488e8>): u64B: uint64 := b
	<.main+7271 @0488df> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@0488e8> - <@0488ea>): u64Pls: uint64 := uint64(+u64B)
	<.main+7280 @0488e8> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@0488ea> - <@0488ed>): u64Neg: uint64 := uint64(-u64B)
	<.main+7282 @0488ea> : 11 02                      dup.x2 sp(2)
	<.main+7284 @0488ec> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@0488ed> - <@0488f0>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7285 @0488ed> : 11 04                      dup.x2 sp(4)
	<.main+7287 @0488ef> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@0488f0> - <@0488f5>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7288 @0488f0> : 11 08                      dup.x2 sp(8)
	<.main+7290 @0488f2> : 11 08                      dup.x2 sp(8)
	<.main+7292 @0488f4> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@0488f5> - <@0488fa>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7293 @0488f5> : 11 0a                      dup.x2 sp(10)
	<.main+7295 @0488f7> : 11 0a                      dup.x2 sp(10)
	<.main+7297 @0488f9> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@0488fa> - <@0488ff>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7298 @0488fa> : 11 0c                      dup.x2 sp(12)
	<.main+7300 @0488fc> : 11 0c                      dup.x2 sp(12)
	<.main+7302 @0488fe> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@0488ff> - <@048904>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7303 @0488ff> : 11 0e                      dup.x2 sp(14)
	<.main+7305 @048901> : 11 0e                      dup.x2 sp(14)
	<.main+7307 @048903> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@048904> - <@048909>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7308 @048904> : 11 10                      dup.x2 sp(16)
	<.main+7310 @048906> : 11 10                      dup.x2 sp(16)
	<.main+7312 @048908> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@048909> - <@04890e>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7313 @048909> : 11 12                      dup.x2 sp(18)
	<.main+7315 @04890b> : 11 12                      dup.x2 sp(18)
	<.main+7317 @04890d> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@04890e> - <@048913>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7318 @04890e> : 11 14                      dup.x2 sp(20)
	<.main+7320 @048910> : 11 14                      dup.x2 sp(20)
	<.main+7322 @048912> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@048913> - <@048918>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7323 @048913> : 11 16                      dup.x2 sp(22)
	<.main+7325 @048915> : 11 16                      dup.x2 sp(22)
	<.main+7327 @048917> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@048918> - <@04891d>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7328 @048918> : 11 18                      dup.x2 sp(24)
	<.main+7330 @04891a> : 10 e7                      dup.x1 sp(231)
	<.main+7332 @04891c> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@04891d> - <@048922>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7333 @04891d> : 11 1a                      dup.x2 sp(26)
	<.main+7335 @04891f> : 10 e9                      dup.x1 sp(233)
	<.main+7337 @048921> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@048922> - <@048926>): u64Not: bool := bool(!(u64B))
	<.main+7338 @048922> : 11 1a                      dup.x2 sp(26)
	<.main+7340 @048924> : 6c                         i64.2bool
	<.main+7341 @048925> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@048926> - <@04892b>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7342 @048926> : 11 1d                      dup.x2 sp(29)
	<.main+7344 @048928> : 11 1d                      dup.x2 sp(29)
	<.main+7346 @04892a> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@04892b> - <@048931>): u64Cne: bool := bool(u64A != u64B)
	<.main+7347 @04892b> : 11 1e                      dup.x2 sp(30)
	<.main+7349 @04892d> : 11 1e                      dup.x2 sp(30)
	<.main+7351 @04892f> : 67                         ceq.i64
	<.main+7352 @048930> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@048931> - <@048936>): u64Clt: bool := bool(u64A < u64B)
	<.main+7353 @048931> : 11 1f                      dup.x2 sp(31)
	<.main+7355 @048933> : 11 1f                      dup.x2 sp(31)
	<.main+7357 @048935> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@048936> - <@04893c>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7358 @048936> : 11 20                      dup.x2 sp(32)
	<.main+7360 @048938> : 11 20                      dup.x2 sp(32)
	<.main+7362 @04893a> : 49                         cgt.u64
	<.main+7363 @04893b> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@04893c> - <@048941>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7364 @04893c> : 11 21                      dup.x2 sp(33)
	<.main+7366 @04893e> : 11 21                      dup.x2 sp(33)
	<.main+7368 @048940> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@048941> - <@048947>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7369 @048941> : 11 22                      dup.x2 sp(34)
	<.main+7371 @048943> : 11 22                      dup.x2 sp(34)
	<.main+7373 @048945> : 48                         clt.u64
	<.main+7374 @048946> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@048947> - <@04894c>): f32A: float32 := a
	<.main+7375 @048947> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@04894c> - <@048951>): f32B: float32 := b
	<.main+7380 @04894c> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@048951> - <@048953>): f32Pls: float32 := float32(+f32B)
	<.main+7385 @048951> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@048953> - <@048956>): f32Neg: float32 := float32(-f32B)
	<.main+7387 @048953> : 10 01                      dup.x1 sp(1)
	<.main+7389 @048955> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@048956> - <@04895b>): f32Add: float32 := float32(f32A + f32B)
	<.main+7390 @048956> : 10 03                      dup.x1 sp(3)
	<.main+7392 @048958> : 10 03                      dup.x1 sp(3)
	<.main+7394 @04895a> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@04895b> - <@048960>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7395 @04895b> : 10 04                      dup.x1 sp(4)
	<.main+7397 @04895d> : 10 04                      dup.x1 sp(4)
	<.main+7399 @04895f> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@048960> - <@048965>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7400 @048960> : 10 05                      dup.x1 sp(5)
	<.main+7402 @048962> : 10 05                      dup.x1 sp(5)
	<.main+7404 @048964> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@048965> - <@04896a>): f32Div: float32 := float32(f32A / f32B)
	<.main+7405 @048965> : 10 06                      dup.x1 sp(6)
	<.main+7407 @048967> : 10 06                      dup.x1 sp(6)
	<.main+7409 @048969> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@04896a> - <@04896f>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7410 @04896a> : 10 07                      dup.x1 sp(7)
	<.main+7412 @04896c> : 10 07                      dup.x1 sp(7)
	<.main+7414 @04896e> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@04896f> - <@048973>): f32Not: bool := bool(!(f32B))
	<.main+7415 @04896f> : 10 07                      dup.x1 sp(7)
	<.main+7417 @048971> : 7b                         f32.2bool
	<.main+7418 @048972> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@048973> - <@048978>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7419 @048973> : 10 09                      dup.x1 sp(9)
	<.main+7421 @048975> : 10 09                      dup.x1 sp(9)
	<.main+7423 @048977> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@048978> - <@04897e>): f32Cne: bool := bool(f32A != f32B)
	<.main+7424 @048978> : 10 0a                      dup.x1 sp(10)
	<.main+7426 @04897a> : 10 0a                      dup.x1 sp(10)
	<.main+7428 @04897c> : 77                         ceq.f32
	<.main+7429 @04897d> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@04897e> - <@048983>): f32Clt: bool := bool(f32A < f32B)
	<.main+7430 @04897e> : 10 0b                      dup.x1 sp(11)
	<.main+7432 @048980> : 10 0b                      dup.x1 sp(11)
	<.main+7434 @048982> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@048983> - <@048989>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7435 @048983> : 10 0c                      dup.x1 sp(12)
	<.main+7437 @048985> : 10 0c                      dup.x1 sp(12)
	<.main+7439 @048987> : 79                         cgt.f32
	<.main+7440 @048988> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@048989> - <@04898e>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7441 @048989> : 10 0d                      dup.x1 sp(13)
	<.main+7443 @04898b> : 10 0d                      dup.x1 sp(13)
	<.main+7445 @04898d> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@04898e> - <@048994>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7446 @04898e> : 10 0e                      dup.x1 sp(14)
	<.main+7448 @048990> : 10 0e                      dup.x1 sp(14)
	<.main+7450 @048992> : 78                         clt.f32
	<.main+7451 @048993> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@048994> - <@04899d>): f64A: float64 := a
	<.main+7452 @048994> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@04899d> - <@0489a6>): f64B: float64 := b
	<.main+7461 @04899d> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@0489a6> - <@0489a8>): f64Pls: float64 := float64(+f64B)
	<.main+7470 @0489a6> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@0489a8> - <@0489ab>): f64Neg: float64 := float64(-f64B)
	<.main+7472 @0489a8> : 11 02                      dup.x2 sp(2)
	<.main+7474 @0489aa> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@0489ab> - <@0489b0>): f64Add: float64 := float64(f64A + f64B)
	<.main+7475 @0489ab> : 11 06                      dup.x2 sp(6)
	<.main+7477 @0489ad> : 11 06                      dup.x2 sp(6)
	<.main+7479 @0489af> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@0489b0> - <@0489b5>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7480 @0489b0> : 11 08                      dup.x2 sp(8)
	<.main+7482 @0489b2> : 11 08                      dup.x2 sp(8)
	<.main+7484 @0489b4> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@0489b5> - <@0489ba>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7485 @0489b5> : 11 0a                      dup.x2 sp(10)
	<.main+7487 @0489b7> : 11 0a                      dup.x2 sp(10)
	<.main+7489 @0489b9> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@0489ba> - <@0489bf>): f64Div: float64 := float64(f64A / f64B)
	<.main+7490 @0489ba> : 11 0c                      dup.x2 sp(12)
	<.main+7492 @0489bc> : 11 0c                      dup.x2 sp(12)
	<.main+7494 @0489be> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@0489bf> - <@0489c4>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7495 @0489bf> : 11 0e                      dup.x2 sp(14)
	<.main+7497 @0489c1> : 11 0e                      dup.x2 sp(14)
	<.main+7499 @0489c3> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@0489c4> - <@0489c8>): f64Not: bool := bool(!(f64B))
	<.main+7500 @0489c4> : 11 0e                      dup.x2 sp(14)
	<.main+7502 @0489c6> : 8d                         f64.2bool
	<.main+7503 @0489c7> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@0489c8> - <@0489cd>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7504 @0489c8> : 11 11                      dup.x2 sp(17)
	<.main+7506 @0489ca> : 11 11                      dup.x2 sp(17)
	<.main+7508 @0489cc> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@0489cd> - <@0489d3>): f64Cne: bool := bool(f64A != f64B)
	<.main+7509 @0489cd> : 11 12                      dup.x2 sp(18)
	<.main+7511 @0489cf> : 11 12                      dup.x2 sp(18)
	<.main+7513 @0489d1> : 87                         ceq.f64
	<.main+7514 @0489d2> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@0489d3> - <@0489d8>): f64Clt: bool := bool(f64A < f64B)
	<.main+7515 @0489d3> : 11 13                      dup.x2 sp(19)
	<.main+7517 @0489d5> : 11 13                      dup.x2 sp(19)
	<.main+7519 @0489d7> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@0489d8> - <@0489de>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7520 @0489d8> : 11 14                      dup.x2 sp(20)
	<.main+7522 @0489da> : 11 14                      dup.x2 sp(20)
	<.main+7524 @0489dc> : 89                         cgt.f64
	<.main+7525 @0489dd> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@0489de> - <@0489e3>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7526 @0489de> : 11 15                      dup.x2 sp(21)
	<.main+7528 @0489e0> : 11 15                      dup.x2 sp(21)
	<.main+7530 @0489e2> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@0489e3> - <@0489e9>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7531 @0489e3> : 11 16                      dup.x2 sp(22)
	<.main+7533 @0489e5> : 11 16                      dup.x2 sp(22)
	<.main+7535 @0489e7> : 88                         clt.f64
	<.main+7536 @0489e8> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@0489e9> - <@0489ee>): ptrA: pointer := null
	<.main+7537 @0489e9> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@0489ee> - <@0489f2>): ptrB: pointer := pointer(shift)
	<.main+7542 @0489ee> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@0489f2> - <@0489f7>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7546 @0489f2> : 10 01                      dup.x1 sp(1)
	<.main+7548 @0489f4> : 10 01                      dup.x1 sp(1)
	<.main+7550 @0489f6> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@0489f7> - <@0489fd>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7551 @0489f7> : 10 02                      dup.x1 sp(2)
	<.main+7553 @0489f9> : 10 02                      dup.x1 sp(2)
	<.main+7555 @0489fb> : 57                         ceq.i32
	<.main+7556 @0489fc> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@0489fd> - <@048a24>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7557 @0489fd> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7562 @048a02> : 1c 04 00 00 00             load.c32 4
	<.main+7567 @048a07> : 1c 0e 00 00 00             load.c32 14
	<.main+7572 @048a0c> : 1c 01 00 00 00             load.c32 1
	<.main+7577 @048a11> : 1f 71 32 04 00             load.ref <@043271> ;"0 == 0"
	<.main+7582 @048a16> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7587 @048a1b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7592 @048a20> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@048a24> - <@048a4b>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7596 @048a24> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7601 @048a29> : 1c 0c 00 00 00             load.c32 12
	<.main+7606 @048a2e> : 1c 0e 00 00 00             load.c32 14
	<.main+7611 @048a33> : 1c 03 00 00 00             load.c32 3
	<.main+7616 @048a38> : 1f 71 32 04 00             load.ref <@043271> ;"0 == 0"
	<.main+7621 @048a3d> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7626 @048a42> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7631 @048a47> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@048a4b> - <@048a72>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7635 @048a4b> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7640 @048a50> : 1c 16 00 00 00             load.c32 22
	<.main+7645 @048a55> : 1c 0e 00 00 00             load.c32 14
	<.main+7650 @048a5a> : 1c 06 00 00 00             load.c32 6
	<.main+7655 @048a5f> : 1f 71 32 04 00             load.ref <@043271> ;"0 == 0"
	<.main+7660 @048a64> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7665 @048a69> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7670 @048a6e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@048a72> - <@048a73>): t: int32 := 0
	<.main+7674 @048a72> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@048a73> - <@048aa1>): if (bool(t == 0))
	<.main+7675 @048a73> : 10 00                      dup.x1 sp(0)
	<.main+7677 @048a75> : 19                         load.z32
	<.main+7678 @048a76> : 57                         ceq.i32
	<.main+7679 @048a77> : 06 2a 00 00                jz <.main+7721 @048aa1>
	test/lang/statementIf.ci:29: (38 bytes: <@048a7b> - <@048aa1>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7683 @048a7b> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7688 @048a80> : 1c 1d 00 00 00             load.c32 29
	<.main+7693 @048a85> : 1c 0e 00 00 00             load.c32 14
	<.main+7698 @048a8a> : 1c 07 00 00 00             load.c32 7
	<.main+7703 @048a8f> : 1f 7f 32 04 00             load.ref <@04327f> ;"t == 0"
	<.main+7708 @048a94> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7713 @048a99> : 0a 18 00 00                load.sp(+24)
	<.main+7717 @048a9d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@048aa1> - <@048acf>): if (bool(t != 0))
	<.main+7721 @048aa1> : 10 00                      dup.x1 sp(0)
	<.main+7723 @048aa3> : 19                         load.z32
	<.main+7724 @048aa4> : 57                         ceq.i32
	<.main+7725 @048aa5> : 05 2a 00 00                jnz <.main+7767 @048acf>
	test/lang/statementIf.ci:33: (38 bytes: <@048aa9> - <@048acf>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7729 @048aa9> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7734 @048aae> : 1c 21 00 00 00             load.c32 33
	<.main+7739 @048ab3> : 1c 0e 00 00 00             load.c32 14
	<.main+7744 @048ab8> : 1c 08 00 00 00             load.c32 8
	<.main+7749 @048abd> : 1f 86 32 04 00             load.ref <@043286> ;"t != 0"
	<.main+7754 @048ac2> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7759 @048ac7> : 0a 18 00 00                load.sp(+24)
	<.main+7763 @048acb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@048acf> - <@048b27>): if (bool(t == 0))
	<.main+7767 @048acf> : 10 00                      dup.x1 sp(0)
	<.main+7769 @048ad1> : 19                         load.z32
	<.main+7770 @048ad2> : 57                         ceq.i32
	<.main+7771 @048ad3> : 06 2e 00 00                jz <.main+7817 @048b01>
	test/lang/statementIf.ci:37: (38 bytes: <@048ad7> - <@048afd>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7775 @048ad7> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7780 @048adc> : 1c 25 00 00 00             load.c32 37
	<.main+7785 @048ae1> : 1c 0e 00 00 00             load.c32 14
	<.main+7790 @048ae6> : 1c 09 00 00 00             load.c32 9
	<.main+7795 @048aeb> : 1f 7f 32 04 00             load.ref <@04327f> ;"t == 0"
	<.main+7800 @048af0> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7805 @048af5> : 0a 18 00 00                load.sp(+24)
	<.main+7809 @048af9> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7813 @048afd> : 04 2a 00 00                jmp <.main+7855 @048b27>
	test/lang/statementIf.ci:40: (38 bytes: <@048b01> - <@048b27>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7817 @048b01> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7822 @048b06> : 1c 28 00 00 00             load.c32 40
	<.main+7827 @048b0b> : 1c 0e 00 00 00             load.c32 14
	<.main+7832 @048b10> : 1c 0a 00 00 00             load.c32 10
	<.main+7837 @048b15> : 1f 86 32 04 00             load.ref <@043286> ;"t != 0"
	<.main+7842 @048b1a> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7847 @048b1f> : 0a 18 00 00                load.sp(+24)
	<.main+7851 @048b23> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@048b27> - <@048b7f>): if (bool(t != 0))
	<.main+7855 @048b27> : 10 00                      dup.x1 sp(0)
	<.main+7857 @048b29> : 19                         load.z32
	<.main+7858 @048b2a> : 57                         ceq.i32
	<.main+7859 @048b2b> : 05 2e 00 00                jnz <.main+7905 @048b59>
	test/lang/statementIf.ci:44: (38 bytes: <@048b2f> - <@048b55>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7863 @048b2f> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7868 @048b34> : 1c 2c 00 00 00             load.c32 44
	<.main+7873 @048b39> : 1c 0e 00 00 00             load.c32 14
	<.main+7878 @048b3e> : 1c 0b 00 00 00             load.c32 11
	<.main+7883 @048b43> : 1f 86 32 04 00             load.ref <@043286> ;"t != 0"
	<.main+7888 @048b48> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7893 @048b4d> : 0a 18 00 00                load.sp(+24)
	<.main+7897 @048b51> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7901 @048b55> : 04 2a 00 00                jmp <.main+7943 @048b7f>
	test/lang/statementIf.ci:47: (38 bytes: <@048b59> - <@048b7f>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7905 @048b59> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7910 @048b5e> : 1c 2f 00 00 00             load.c32 47
	<.main+7915 @048b63> : 1c 0e 00 00 00             load.c32 14
	<.main+7920 @048b68> : 1c 0c 00 00 00             load.c32 12
	<.main+7925 @048b6d> : 1f 7f 32 04 00             load.ref <@04327f> ;"t == 0"
	<.main+7930 @048b72> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7935 @048b77> : 0a 18 00 00                load.sp(+24)
	<.main+7939 @048b7b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@048b7f> - <@048ce5>): if (bool(t == 0))
	<.main+7943 @048b7f> : 10 00                      dup.x1 sp(0)
	<.main+7945 @048b81> : 19                         load.z32
	<.main+7946 @048b82> : 57                         ceq.i32
	<.main+7947 @048b83> : 06 2e 00 00                jz <.main+7993 @048bb1>
	test/lang/statementIf.ci:51: (38 bytes: <@048b87> - <@048bad>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7951 @048b87> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+7956 @048b8c> : 1c 33 00 00 00             load.c32 51
	<.main+7961 @048b91> : 1c 0e 00 00 00             load.c32 14
	<.main+7966 @048b96> : 1c 09 00 00 00             load.c32 9
	<.main+7971 @048b9b> : 1f 7f 32 04 00             load.ref <@04327f> ;"t == 0"
	<.main+7976 @048ba0> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7981 @048ba5> : 0a 18 00 00                load.sp(+24)
	<.main+7985 @048ba9> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7989 @048bad> : 04 38 01 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:53: (308 bytes: <@048bb1> - <@048ce5>): if (bool(t == 1))
	<.main+7993 @048bb1> : 10 00                      dup.x1 sp(0)
	<.main+7995 @048bb3> : 1c 01 00 00 00             load.c32 1
	<.main+8000 @048bb8> : 57                         ceq.i32
	<.main+8001 @048bb9> : 06 2e 00 00                jz <.main+8047 @048be7>
	test/lang/statementIf.ci:54: (38 bytes: <@048bbd> - <@048be3>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+8005 @048bbd> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8010 @048bc2> : 1c 36 00 00 00             load.c32 54
	<.main+8015 @048bc7> : 1c 0e 00 00 00             load.c32 14
	<.main+8020 @048bcc> : 1c 0a 00 00 00             load.c32 10
	<.main+8025 @048bd1> : 1f 8d 32 04 00             load.ref <@04328d> ;"t == 1"
	<.main+8030 @048bd6> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8035 @048bdb> : 0a 18 00 00                load.sp(+24)
	<.main+8039 @048bdf> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8043 @048be3> : 04 02 01 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:56: (254 bytes: <@048be7> - <@048ce5>): if (bool(t == 2))
	<.main+8047 @048be7> : 10 00                      dup.x1 sp(0)
	<.main+8049 @048be9> : 1c 02 00 00 00             load.c32 2
	<.main+8054 @048bee> : 57                         ceq.i32
	<.main+8055 @048bef> : 06 2e 00 00                jz <.main+8101 @048c1d>
	test/lang/statementIf.ci:57: (38 bytes: <@048bf3> - <@048c19>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8059 @048bf3> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8064 @048bf8> : 1c 39 00 00 00             load.c32 57
	<.main+8069 @048bfd> : 1c 0e 00 00 00             load.c32 14
	<.main+8074 @048c02> : 1c 0a 00 00 00             load.c32 10
	<.main+8079 @048c07> : 1f 94 32 04 00             load.ref <@043294> ;"t == 2"
	<.main+8084 @048c0c> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8089 @048c11> : 0a 18 00 00                load.sp(+24)
	<.main+8093 @048c15> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8097 @048c19> : 04 cc 00 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:59: (200 bytes: <@048c1d> - <@048ce5>): if (bool(t == 3))
	<.main+8101 @048c1d> : 10 00                      dup.x1 sp(0)
	<.main+8103 @048c1f> : 1c 03 00 00 00             load.c32 3
	<.main+8108 @048c24> : 57                         ceq.i32
	<.main+8109 @048c25> : 06 2e 00 00                jz <.main+8155 @048c53>
	test/lang/statementIf.ci:60: (38 bytes: <@048c29> - <@048c4f>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8113 @048c29> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8118 @048c2e> : 1c 3c 00 00 00             load.c32 60
	<.main+8123 @048c33> : 1c 0e 00 00 00             load.c32 14
	<.main+8128 @048c38> : 1c 0a 00 00 00             load.c32 10
	<.main+8133 @048c3d> : 1f 9b 32 04 00             load.ref <@04329b> ;"t == 3"
	<.main+8138 @048c42> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8143 @048c47> : 0a 18 00 00                load.sp(+24)
	<.main+8147 @048c4b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8151 @048c4f> : 04 96 00 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:62: (146 bytes: <@048c53> - <@048ce5>): if (bool(t == 4))
	<.main+8155 @048c53> : 10 00                      dup.x1 sp(0)
	<.main+8157 @048c55> : 1c 04 00 00 00             load.c32 4
	<.main+8162 @048c5a> : 57                         ceq.i32
	<.main+8163 @048c5b> : 06 2e 00 00                jz <.main+8209 @048c89>
	test/lang/statementIf.ci:63: (38 bytes: <@048c5f> - <@048c85>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8167 @048c5f> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8172 @048c64> : 1c 3f 00 00 00             load.c32 63
	<.main+8177 @048c69> : 1c 0e 00 00 00             load.c32 14
	<.main+8182 @048c6e> : 1c 0a 00 00 00             load.c32 10
	<.main+8187 @048c73> : 1f a2 32 04 00             load.ref <@0432a2> ;"t == 4"
	<.main+8192 @048c78> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8197 @048c7d> : 0a 18 00 00                load.sp(+24)
	<.main+8201 @048c81> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8205 @048c85> : 04 60 00 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:65: (92 bytes: <@048c89> - <@048ce5>): if (bool(t == 5))
	<.main+8209 @048c89> : 10 00                      dup.x1 sp(0)
	<.main+8211 @048c8b> : 1c 05 00 00 00             load.c32 5
	<.main+8216 @048c90> : 57                         ceq.i32
	<.main+8217 @048c91> : 06 2e 00 00                jz <.main+8263 @048cbf>
	test/lang/statementIf.ci:66: (38 bytes: <@048c95> - <@048cbb>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8221 @048c95> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8226 @048c9a> : 1c 42 00 00 00             load.c32 66
	<.main+8231 @048c9f> : 1c 0e 00 00 00             load.c32 14
	<.main+8236 @048ca4> : 1c 0a 00 00 00             load.c32 10
	<.main+8241 @048ca9> : 1f a9 32 04 00             load.ref <@0432a9> ;"t == 5"
	<.main+8246 @048cae> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8251 @048cb3> : 0a 18 00 00                load.sp(+24)
	<.main+8255 @048cb7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8259 @048cbb> : 04 2a 00 00                jmp <.main+8301 @048ce5>
	test/lang/statementIf.ci:69: (38 bytes: <@048cbf> - <@048ce5>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8263 @048cbf> : 1f 58 32 04 00             load.ref <@043258> ;"test/lang/statementIf.ci"
	<.main+8268 @048cc4> : 1c 45 00 00 00             load.c32 69
	<.main+8273 @048cc9> : 1c 0e 00 00 00             load.c32 14
	<.main+8278 @048cce> : 1c 0a 00 00 00             load.c32 10
	<.main+8283 @048cd3> : 1f b0 32 04 00             load.ref <@0432b0> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8288 @048cd8> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8293 @048cdd> : 0a 18 00 00                load.sp(+24)
	<.main+8297 @048ce1> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@048ce5> - <@048d14>): for ( ; ; )
	<.main+8301 @048ce5> : 04 2b 00 00                jmp <.main+8344 @048d10>
	test/lang/statementFor.ci:4: (35 bytes: <@048ce9> - <@048d0c>): debug("for ( ; ; )");
	<.main+8305 @048ce9> : 1f 88 33 04 00             load.ref <@043388> ;"test/lang/statementFor.ci"
	<.main+8310 @048cee> : 1c 04 00 00 00             load.c32 4
	<.main+8315 @048cf3> : 1c 0e 00 00 00             load.c32 14
	<.main+8320 @048cf8> : 19                         load.z32
	<.main+8321 @048cf9> : 1f a2 33 04 00             load.ref <@0433a2> ;"for ( ; ; )"
	<.main+8326 @048cfe> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+8331 @048d03> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8336 @048d08> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@048d0c> - <@048d10>): break;
	<.main+8340 @048d0c> : 04 08 00 00                jmp <.main+8348 @048d14>
	:: (4 bytes: <@048d10> - <@048d14>)
	<.main+8344 @048d10> : 04 d9 ff ff                jmp <.main+8305 @048ce9>
	test/lang/statementFor.ci:8: (59 bytes: <@048d14> - <@048d4f>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8348 @048d14> : 19                         load.z32
	<.main+8349 @048d15> : 04 2a 00 00                jmp <.main+8391 @048d3f>
	test/lang/statementFor.ci:9: (34 bytes: <@048d19> - <@048d3b>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8353 @048d19> : 1f 88 33 04 00             load.ref <@043388> ;"test/lang/statementFor.ci"
	<.main+8358 @048d1e> : 1c 09 00 00 00             load.c32 9
	<.main+8363 @048d23> : 1c 0e 00 00 00             load.c32 14
	<.main+8368 @048d28> : 19                         load.z32
	<.main+8369 @048d29> : 1f ae 33 04 00             load.ref <@0433ae> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8374 @048d2e> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8379 @048d33> : 0a 18 00 00                load.sp(+24)
	<.main+8383 @048d37> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@048d3b> - <@048d3f>): int32(i := int32(i + 1))
	<.main+8387 @048d3b> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@048d3f> - <@048d4b>): bool(i < 2)
	<.main+8391 @048d3f> : 10 00                      dup.x1 sp(0)
	<.main+8393 @048d41> : 1c 02 00 00 00             load.c32 2
	<.main+8398 @048d46> : 58                         clt.i32
	<.main+8399 @048d47> : 05 d2 ff ff                jnz <.main+8353 @048d19>
	<.main+8403 @048d4b> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@048d4f> - <@048d50>): forIdx: int32
	<.main+8407 @048d4f> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@048d50> - <@048d89>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8408 @048d50> : 19                         load.z32
	<.main+8409 @048d51> : 13 01                      set.x1 sp(1)
	<.main+8411 @048d53> : 04 2a 00 00                jmp <.main+8453 @048d7d>
	test/lang/statementFor.ci:14: (34 bytes: <@048d57> - <@048d79>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8415 @048d57> : 1f 88 33 04 00             load.ref <@043388> ;"test/lang/statementFor.ci"
	<.main+8420 @048d5c> : 1c 0e 00 00 00             load.c32 14
	<.main+8425 @048d61> : 1c 0e 00 00 00             load.c32 14
	<.main+8430 @048d66> : 19                         load.z32
	<.main+8431 @048d67> : 1f d4 33 04 00             load.ref <@0433d4> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8436 @048d6c> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8441 @048d71> : 0a 18 00 00                load.sp(+24)
	<.main+8445 @048d75> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@048d79> - <@048d7d>): int32(forIdx := int32(forIdx + 1))
	<.main+8449 @048d79> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@048d7d> - <@048d89>): bool(forIdx < 2)
	<.main+8453 @048d7d> : 10 00                      dup.x1 sp(0)
	<.main+8455 @048d7f> : 1c 02 00 00 00             load.c32 2
	<.main+8460 @048d84> : 58                         clt.i32
	<.main+8461 @048d85> : 05 d2 ff ff                jnz <.main+8415 @048d57>
	test/lang/statementFor.ci:17: (75 bytes: <@048d89> - <@048dd4>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8465 @048d89> : 19                         load.z32
	<.main+8466 @048d8a> : 04 3a 00 00                jmp <.main+8524 @048dc4>
	test/lang/statementFor.ci:18: (16 bytes: <@048d8e> - <@048d9e>): if (bool(i < 2))
	<.main+8470 @048d8e> : 10 00                      dup.x1 sp(0)
	<.main+8472 @048d90> : 1c 02 00 00 00             load.c32 2
	<.main+8477 @048d95> : 58                         clt.i32
	<.main+8478 @048d96> : 06 08 00 00                jz <.main+8486 @048d9e>
	test/lang/statementFor.ci:19: (4 bytes: <@048d9a> - <@048d9e>): continue;
	<.main+8482 @048d9a> : 04 26 00 00                jmp <.main+8520 @048dc0>
	test/lang/statementFor.ci:21: (34 bytes: <@048d9e> - <@048dc0>): debug(void("for with continue", i));
	<.main+8486 @048d9e> : 1f 88 33 04 00             load.ref <@043388> ;"test/lang/statementFor.ci"
	<.main+8491 @048da3> : 1c 15 00 00 00             load.c32 21
	<.main+8496 @048da8> : 1c 0e 00 00 00             load.c32 14
	<.main+8501 @048dad> : 19                         load.z32
	<.main+8502 @048dae> : 1f fe 33 04 00             load.ref <@0433fe> ;"for with continue"
	<.main+8507 @048db3> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8512 @048db8> : 0a 18 00 00                load.sp(+24)
	<.main+8516 @048dbc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@048dc0> - <@048dc4>): int32(i := int32(i + 1))
	<.main+8520 @048dc0> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@048dc4> - <@048dd0>): bool(i < 7)
	<.main+8524 @048dc4> : 10 00                      dup.x1 sp(0)
	<.main+8526 @048dc6> : 1c 07 00 00 00             load.c32 7
	<.main+8531 @048dcb> : 58                         clt.i32
	<.main+8532 @048dcc> : 05 c2 ff ff                jnz <.main+8470 @048d8e>
	<.main+8536 @048dd0> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@048dd4> - <@048e1f>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8540 @048dd4> : 19                         load.z32
	<.main+8541 @048dd5> : 04 3a 00 00                jmp <.main+8599 @048e0f>
	test/lang/statementFor.ci:25: (16 bytes: <@048dd9> - <@048de9>): if (bool(i > 2))
	<.main+8545 @048dd9> : 10 00                      dup.x1 sp(0)
	<.main+8547 @048ddb> : 1c 02 00 00 00             load.c32 2
	<.main+8552 @048de0> : 59                         cgt.i32
	<.main+8553 @048de1> : 06 08 00 00                jz <.main+8561 @048de9>
	test/lang/statementFor.ci:26: (4 bytes: <@048de5> - <@048de9>): break;
	<.main+8557 @048de5> : 04 36 00 00                jmp <.main+8611 @048e1b>
	test/lang/statementFor.ci:28: (34 bytes: <@048de9> - <@048e0b>): debug(void("for with break", i));
	<.main+8561 @048de9> : 1f 88 33 04 00             load.ref <@043388> ;"test/lang/statementFor.ci"
	<.main+8566 @048dee> : 1c 1c 00 00 00             load.c32 28
	<.main+8571 @048df3> : 1c 0e 00 00 00             load.c32 14
	<.main+8576 @048df8> : 19                         load.z32
	<.main+8577 @048df9> : 1f 10 34 04 00             load.ref <@043410> ;"for with break"
	<.main+8582 @048dfe> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8587 @048e03> : 0a 18 00 00                load.sp(+24)
	<.main+8591 @048e07> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@048e0b> - <@048e0f>): int32(i := int32(i + 1))
	<.main+8595 @048e0b> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@048e0f> - <@048e1b>): bool(i < 7)
	<.main+8599 @048e0f> : 10 00                      dup.x1 sp(0)
	<.main+8601 @048e11> : 1c 07 00 00 00             load.c32 7
	<.main+8606 @048e16> : 58                         clt.i32
	<.main+8607 @048e17> : 05 c2 ff ff                jnz <.main+8545 @048dd9>
	<.main+8611 @048e1b> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@048e1f> - <@048e33>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8615 @048e1f> : 1a                         load.z64
	<.main+8616 @048e20> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8625 @048e29> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8630 @048e2e> : 02                         call
	<.main+8631 @048e2f> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@048e33> - <@048e47>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8635 @048e33> : 1a                         load.z64
	<.main+8636 @048e34> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8645 @048e3d> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8650 @048e42> : 02                         call
	<.main+8651 @048e43> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@048e47> - <@048e5b>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8655 @048e47> : 1a                         load.z64
	<.main+8656 @048e48> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8665 @048e51> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8670 @048e56> : 02                         call
	<.main+8671 @048e57> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@048e5b> - <@048e6f>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8675 @048e5b> : 1a                         load.z64
	<.main+8676 @048e5c> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8685 @048e65> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8690 @048e6a> : 02                         call
	<.main+8691 @048e6b> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@048e6f> - <@048e83>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8695 @048e6f> : 1a                         load.z64
	<.main+8696 @048e70> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8705 @048e79> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8710 @048e7e> : 02                         call
	<.main+8711 @048e7f> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@048e83> - <@048e97>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8715 @048e83> : 1a                         load.z64
	<.main+8716 @048e84> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8725 @048e8d> : 1f 10 5a 04 00             load.ref <@045a10> ;Math.floor(x: float64): float64
	<.main+8730 @048e92> : 02                         call
	<.main+8731 @048e93> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (21 bytes: <@048e97> - <@048eac>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8735 @048e97> : 19                         load.z32
	<.main+8736 @048e98> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8745 @048ea1> : 1f 50 5a 04 00             load.ref <@045a50> ;Math.sign(x: float64): int32
	<.main+8750 @048ea6> : 02                         call
	<.main+8751 @048ea7> : 09 f8 ff ff                inc.sp(-8)
	<.main+8755 @048eab> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (13 bytes: <@048eac> - <@048eb9>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8756 @048eac> : 19                         load.z32
	<.main+8757 @048ead> : 1a                         load.z64
	<.main+8758 @048eae> : 1f 50 5a 04 00             load.ref <@045a50> ;Math.sign(x: float64): int32
	<.main+8763 @048eb3> : 02                         call
	<.main+8764 @048eb4> : 09 f8 ff ff                inc.sp(-8)
	<.main+8768 @048eb8> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (21 bytes: <@048eb9> - <@048ece>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8769 @048eb9> : 19                         load.z32
	<.main+8770 @048eba> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8779 @048ec3> : 1f 50 5a 04 00             load.ref <@045a50> ;Math.sign(x: float64): int32
	<.main+8784 @048ec8> : 02                         call
	<.main+8785 @048ec9> : 09 f8 ff ff                inc.sp(-8)
	<.main+8789 @048ecd> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@048ece> - <@048edf>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8790 @048ece> : 19                         load.z32
	<.main+8791 @048ecf> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8796 @048ed4> : 1f 28 5a 04 00             load.ref <@045a28> ;Math.sign(x: float32): int32
	<.main+8801 @048ed9> : 02                         call
	<.main+8802 @048eda> : 09 fc ff ff                inc.sp(-4)
	<.main+8806 @048ede> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@048edf> - <@048eec>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8807 @048edf> : 19                         load.z32
	<.main+8808 @048ee0> : 19                         load.z32
	<.main+8809 @048ee1> : 1f 28 5a 04 00             load.ref <@045a28> ;Math.sign(x: float32): int32
	<.main+8814 @048ee6> : 02                         call
	<.main+8815 @048ee7> : 09 fc ff ff                inc.sp(-4)
	<.main+8819 @048eeb> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@048eec> - <@048efd>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8820 @048eec> : 19                         load.z32
	<.main+8821 @048eed> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8826 @048ef2> : 1f 28 5a 04 00             load.ref <@045a28> ;Math.sign(x: float32): int32
	<.main+8831 @048ef7> : 02                         call
	<.main+8832 @048ef8> : 09 fc ff ff                inc.sp(-4)
	<.main+8836 @048efc> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@048efd> - <@048f11>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8837 @048efd> : 1a                         load.z64
	<.main+8838 @048efe> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8847 @048f07> : 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<.main+8852 @048f0c> : 02                         call
	<.main+8853 @048f0d> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@048f11> - <@048f1c>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8857 @048f11> : 1b                         load.z128
	<.main+8858 @048f12> : 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<.main+8863 @048f17> : 02                         call
	<.main+8864 @048f18> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@048f1c> - <@048f30>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8868 @048f1c> : 1a                         load.z64
	<.main+8869 @048f1d> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8878 @048f26> : 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<.main+8883 @048f2b> : 02                         call
	<.main+8884 @048f2c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@048f30> - <@048f41>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8888 @048f30> : 19                         load.z32
	<.main+8889 @048f31> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8894 @048f36> : 1f 78 5a 04 00             load.ref <@045a78> ;Math.abs(x: float32): float32
	<.main+8899 @048f3b> : 02                         call
	<.main+8900 @048f3c> : 09 fc ff ff                inc.sp(-4)
	<.main+8904 @048f40> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@048f41> - <@048f4e>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8905 @048f41> : 19                         load.z32
	<.main+8906 @048f42> : 19                         load.z32
	<.main+8907 @048f43> : 1f 78 5a 04 00             load.ref <@045a78> ;Math.abs(x: float32): float32
	<.main+8912 @048f48> : 02                         call
	<.main+8913 @048f49> : 09 fc ff ff                inc.sp(-4)
	<.main+8917 @048f4d> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@048f4e> - <@048f5f>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8918 @048f4e> : 19                         load.z32
	<.main+8919 @048f4f> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8924 @048f54> : 1f 78 5a 04 00             load.ref <@045a78> ;Math.abs(x: float32): float32
	<.main+8929 @048f59> : 02                         call
	<.main+8930 @048f5a> : 09 fc ff ff                inc.sp(-4)
	<.main+8934 @048f5e> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@048f5f> - <@048f75>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8935 @048f5f> : 19                         load.z32
	<.main+8936 @048f60> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8941 @048f65> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8946 @048f6a> : 1f a8 5a 04 00             load.ref <@045aa8> ;Math.min(a: float32, b: float32): float32
	<.main+8951 @048f6f> : 02                         call
	<.main+8952 @048f70> : 09 f8 ff ff                inc.sp(-8)
	<.main+8956 @048f74> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@048f75> - <@048f8b>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8957 @048f75> : 19                         load.z32
	<.main+8958 @048f76> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8963 @048f7b> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8968 @048f80> : 1f d8 5a 04 00             load.ref <@045ad8> ;Math.max(a: float32, b: float32): float32
	<.main+8973 @048f85> : 02                         call
	<.main+8974 @048f86> : 09 f8 ff ff                inc.sp(-8)
	<.main+8978 @048f8a> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@048f8b> - <@048fa8>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8979 @048f8b> : 1a                         load.z64
	<.main+8980 @048f8c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8989 @048f95> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8998 @048f9e> : 1f c0 5a 04 00             load.ref <@045ac0> ;Math.min(a: float64, b: float64): float64
	<.main+9003 @048fa3> : 02                         call
	<.main+9004 @048fa4> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@048fa8> - <@048fc5>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9008 @048fa8> : 1a                         load.z64
	<.main+9009 @048fa9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9018 @048fb2> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9027 @048fbb> : 1f f0 5a 04 00             load.ref <@045af0> ;Math.max(a: float64, b: float64): float64
	<.main+9032 @048fc0> : 02                         call
	<.main+9033 @048fc1> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@048fc5> - <@048fdc>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9037 @048fc5> : 19                         load.z32
	<.main+9038 @048fc6> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9043 @048fcb> : 19                         load.z32
	<.main+9044 @048fcc> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9049 @048fd1> : 1f 08 5b 04 00             load.ref <@045b08> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9054 @048fd6> : 02                         call
	<.main+9055 @048fd7> : 09 f4 ff ff                inc.sp(-12)
	<.main+9059 @048fdb> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@048fdc> - <@048ffa>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9060 @048fdc> : 1a                         load.z64
	<.main+9061 @048fdd> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9070 @048fe6> : 1a                         load.z64
	<.main+9071 @048fe7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9080 @048ff0> : 1f 28 5b 04 00             load.ref <@045b28> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9085 @048ff5> : 02                         call
	<.main+9086 @048ff6> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@048ffa> - <@04900f>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9090 @048ffa> : 19                         load.z32
	<.main+9091 @048ffb> : 10 00                      dup.x1 sp(0)
	<.main+9093 @048ffd> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9098 @049002> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9103 @049007> : 10 03                      dup.x1 sp(3)
	<.main+9105 @049009> : 72                         sub.f32
	<.main+9106 @04900a> : 73                         mul.f32
	<.main+9107 @04900b> : 71                         add.f32
	<.main+9108 @04900c> : 13 01                      set.x1 sp(1)
	<.main+9110 @04900e> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@04900f> - <@04902b>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9111 @04900f> : 1a                         load.z64
	<.main+9112 @049010> : 11 00                      dup.x2 sp(0)
	<.main+9114 @049012> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9123 @04901b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9132 @049024> : 11 06                      dup.x2 sp(6)
	<.main+9134 @049026> : 82                         sub.f64
	<.main+9135 @049027> : 83                         mul.f64
	<.main+9136 @049028> : 81                         add.f64
	<.main+9137 @049029> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (24 bytes: <@04902b> - <@049043>): testMathSmooth_0f: float64 := Math.smooth(0.000000)
	<.main+9139 @04902b> : 19                         load.z32
	<.main+9140 @04902c> : 10 00                      dup.x1 sp(0)
	<.main+9142 @04902e> : 10 01                      dup.x1 sp(1)
	<.main+9144 @049030> : 73                         mul.f32
	<.main+9145 @049031> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9150 @049036> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9155 @04903b> : 10 03                      dup.x1 sp(3)
	<.main+9157 @04903d> : 73                         mul.f32
	<.main+9158 @04903e> : 72                         sub.f32
	<.main+9159 @04903f> : 73                         mul.f32
	<.main+9160 @049040> : 13 01                      set.x1 sp(1)
	<.main+9162 @049042> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (31 bytes: <@049043> - <@049062>): testMathSmooth_0F: float64 := Math.smooth(0.000000)
	<.main+9163 @049043> : 1a                         load.z64
	<.main+9164 @049044> : 11 00                      dup.x2 sp(0)
	<.main+9166 @049046> : 11 02                      dup.x2 sp(2)
	<.main+9168 @049048> : 83                         mul.f64
	<.main+9169 @049049> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9178 @049052> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9187 @04905b> : 11 06                      dup.x2 sp(6)
	<.main+9189 @04905d> : 83                         mul.f64
	<.main+9190 @04905e> : 82                         sub.f64
	<.main+9191 @04905f> : 83                         mul.f64
	<.main+9192 @049060> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:37: (60 bytes: <@049062> - <@04909e>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9194 @049062> : 19                         load.z32
	<.main+9195 @049063> : 19                         load.z32
	<.main+9196 @049064> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9201 @049069> : 10 02                      dup.x1 sp(2)
	<.main+9203 @04906b> : 72                         sub.f32
	<.main+9204 @04906c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9209 @049071> : 10 03                      dup.x1 sp(3)
	<.main+9211 @049073> : 72                         sub.f32
	<.main+9212 @049074> : 74                         div.f32
	<.main+9213 @049075> : 19                         load.z32
	<.main+9214 @049076> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9219 @04907b> : 1f 08 5b 04 00             load.ref <@045b08> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9224 @049080> : 02                         call
	<.main+9225 @049081> : 09 f4 ff ff                inc.sp(-12)
	<.main+9229 @049085> : 10 00                      dup.x1 sp(0)
	<.main+9231 @049087> : 10 01                      dup.x1 sp(1)
	<.main+9233 @049089> : 73                         mul.f32
	<.main+9234 @04908a> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9239 @04908f> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9244 @049094> : 10 03                      dup.x1 sp(3)
	<.main+9246 @049096> : 73                         mul.f32
	<.main+9247 @049097> : 72                         sub.f32
	<.main+9248 @049098> : 73                         mul.f32
	<.main+9249 @049099> : 13 01                      set.x1 sp(1)
	<.main+9251 @04909b> : 13 01                      set.x1 sp(1)
	<.main+9253 @04909d> : 7d                         f32.2f64
	test/stdc/test.math.ci:38: (78 bytes: <@04909e> - <@0490ec>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9254 @04909e> : 1b                         load.z128
	<.main+9255 @04909f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9264 @0490a8> : 11 04                      dup.x2 sp(4)
	<.main+9266 @0490aa> : 82                         sub.f64
	<.main+9267 @0490ab> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9276 @0490b4> : 11 06                      dup.x2 sp(6)
	<.main+9278 @0490b6> : 82                         sub.f64
	<.main+9279 @0490b7> : 84                         div.f64
	<.main+9280 @0490b8> : 1a                         load.z64
	<.main+9281 @0490b9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9290 @0490c2> : 1f 28 5b 04 00             load.ref <@045b28> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9295 @0490c7> : 02                         call
	<.main+9296 @0490c8> : 09 e8 ff ff                inc.sp(-24)
	<.main+9300 @0490cc> : 11 00                      dup.x2 sp(0)
	<.main+9302 @0490ce> : 11 02                      dup.x2 sp(2)
	<.main+9304 @0490d0> : 83                         mul.f64
	<.main+9305 @0490d1> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9314 @0490da> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9323 @0490e3> : 11 06                      dup.x2 sp(6)
	<.main+9325 @0490e5> : 83                         mul.f64
	<.main+9326 @0490e6> : 82                         sub.f64
	<.main+9327 @0490e7> : 83                         mul.f64
	<.main+9328 @0490e8> : 14 02                      set.x2 sp(2)
	<.main+9330 @0490ea> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:40: (21 bytes: <@0490ec> - <@049101>): testMathMin_nan: float64 := Math.min()
	<.main+9332 @0490ec> : 19                         load.z32
	<.main+9333 @0490ed> : 0a 04 00 00                load.sp(+4)
	<.main+9337 @0490f1> : 1a                         load.z64
	<.main+9338 @0490f2> : 11 02                      dup.x2 sp(2)
	<.main+9340 @0490f4> : 1f 48 5b 04 00             load.ref <@045b48> ;Math.min(data: float64[]): float64
	<.main+9345 @0490f9> : 02                         call
	<.main+9346 @0490fa> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9349 @0490fd> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@049101> - <@04916b>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9353 @049101> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9362 @04910a> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9371 @049113> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9380 @04911c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9389 @049125> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9398 @04912e> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9407 @049137> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9416 @049140> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9425 @049149> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9434 @049152> : 1c 09 00 00 00             load.c32 9
	<.main+9439 @049157> : 0a 04 00 00                load.sp(+4)
	<.main+9443 @04915b> : 1a                         load.z64
	<.main+9444 @04915c> : 11 02                      dup.x2 sp(2)
	<.main+9446 @04915e> : 1f 48 5b 04 00             load.ref <@045b48> ;Math.min(data: float64[]): float64
	<.main+9451 @049163> : 02                         call
	<.main+9452 @049164> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9455 @049167> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:42: (21 bytes: <@04916b> - <@049180>): testMathMax_nan: float64 := Math.max()
	<.main+9459 @04916b> : 19                         load.z32
	<.main+9460 @04916c> : 0a 04 00 00                load.sp(+4)
	<.main+9464 @049170> : 1a                         load.z64
	<.main+9465 @049171> : 11 02                      dup.x2 sp(2)
	<.main+9467 @049173> : 1f 90 5b 04 00             load.ref <@045b90> ;Math.max(data: float64[]): float64
	<.main+9472 @049178> : 02                         call
	<.main+9473 @049179> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9476 @04917c> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:43: (106 bytes: <@049180> - <@0491ea>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9480 @049180> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9489 @049189> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9498 @049192> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9507 @04919b> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9516 @0491a4> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9525 @0491ad> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9534 @0491b6> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9543 @0491bf> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9552 @0491c8> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9561 @0491d1> : 1c 09 00 00 00             load.c32 9
	<.main+9566 @0491d6> : 0a 04 00 00                load.sp(+4)
	<.main+9570 @0491da> : 1a                         load.z64
	<.main+9571 @0491db> : 11 02                      dup.x2 sp(2)
	<.main+9573 @0491dd> : 1f 90 5b 04 00             load.ref <@045b90> ;Math.max(data: float64[]): float64
	<.main+9578 @0491e2> : 02                         call
	<.main+9579 @0491e3> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9582 @0491e6> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:45: (21 bytes: <@0491ea> - <@0491ff>): testMathSum_0: float64 := Math.sum()
	<.main+9586 @0491ea> : 19                         load.z32
	<.main+9587 @0491eb> : 0a 04 00 00                load.sp(+4)
	<.main+9591 @0491ef> : 1a                         load.z64
	<.main+9592 @0491f0> : 11 02                      dup.x2 sp(2)
	<.main+9594 @0491f2> : 1f d8 5b 04 00             load.ref <@045bd8> ;Math.sum(data: float64[]): float64
	<.main+9599 @0491f7> : 02                         call
	<.main+9600 @0491f8> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9603 @0491fb> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:46: (34 bytes: <@0491ff> - <@049221>): testMathSum_1: float64 := Math.sum(1)
	<.main+9607 @0491ff> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9616 @049208> : 1c 01 00 00 00             load.c32 1
	<.main+9621 @04920d> : 0a 04 00 00                load.sp(+4)
	<.main+9625 @049211> : 1a                         load.z64
	<.main+9626 @049212> : 11 02                      dup.x2 sp(2)
	<.main+9628 @049214> : 1f d8 5b 04 00             load.ref <@045bd8> ;Math.sum(data: float64[]): float64
	<.main+9633 @049219> : 02                         call
	<.main+9634 @04921a> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9637 @04921d> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:47: (43 bytes: <@049221> - <@04924c>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9641 @049221> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9650 @04922a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9659 @049233> : 1c 02 00 00 00             load.c32 2
	<.main+9664 @049238> : 0a 04 00 00                load.sp(+4)
	<.main+9668 @04923c> : 1a                         load.z64
	<.main+9669 @04923d> : 11 02                      dup.x2 sp(2)
	<.main+9671 @04923f> : 1f d8 5b 04 00             load.ref <@045bd8> ;Math.sum(data: float64[]): float64
	<.main+9676 @049244> : 02                         call
	<.main+9677 @049245> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9680 @049248> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:48: (115 bytes: <@04924c> - <@0492bf>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9684 @04924c> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9693 @049255> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9702 @04925e> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9711 @049267> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9720 @049270> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9729 @049279> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9738 @049282> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9747 @04928b> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9756 @049294> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9765 @04929d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9774 @0492a6> : 1c 0a 00 00 00             load.c32 10
	<.main+9779 @0492ab> : 0a 04 00 00                load.sp(+4)
	<.main+9783 @0492af> : 1a                         load.z64
	<.main+9784 @0492b0> : 11 02                      dup.x2 sp(2)
	<.main+9786 @0492b2> : 1f d8 5b 04 00             load.ref <@045bd8> ;Math.sum(data: float64[]): float64
	<.main+9791 @0492b7> : 02                         call
	<.main+9792 @0492b8> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9795 @0492bb> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:50: (9 bytes: <@0492bf> - <@0492c8>): testMathEval_x: float64 := 10
	<.main+9799 @0492bf> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:51: (23 bytes: <@0492c8> - <@0492df>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9808 @0492c8> : 19                         load.z32
	<.main+9809 @0492c9> : 0a 04 00 00                load.sp(+4)
	<.main+9813 @0492cd> : 1a                         load.z64
	<.main+9814 @0492ce> : 11 04                      dup.x2 sp(4)
	<.main+9816 @0492d0> : 11 04                      dup.x2 sp(4)
	<.main+9818 @0492d2> : 1f 00 5c 04 00             load.ref <@045c00> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9823 @0492d7> : 02                         call
	<.main+9824 @0492d8> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9827 @0492db> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:52: (9 bytes: <@0492df> - <@0492e8>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9831 @0492df> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:53: (22 bytes: <@0492e8> - <@0492fe>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9840 @0492e8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9849 @0492f1> : 11 06                      dup.x2 sp(6)
	<.main+9851 @0492f3> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9860 @0492fc> : 83                         mul.f64
	<.main+9861 @0492fd> : 81                         add.f64
	test/stdc/test.math.ci:54: (39 bytes: <@0492fe> - <@049325>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9862 @0492fe> : 11 06                      dup.x2 sp(6)
	<.main+9864 @049300> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9873 @049309> : 11 02                      dup.x2 sp(2)
	<.main+9875 @04930b> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9884 @049314> : 11 06                      dup.x2 sp(6)
	<.main+9886 @049316> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9895 @04931f> : 83                         mul.f64
	<.main+9896 @049320> : 81                         add.f64
	<.main+9897 @049321> : 83                         mul.f64
	<.main+9898 @049322> : 81                         add.f64
	<.main+9899 @049323> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:55: (56 bytes: <@049325> - <@04935d>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9901 @049325> : 11 08                      dup.x2 sp(8)
	<.main+9903 @049327> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9912 @049330> : 11 02                      dup.x2 sp(2)
	<.main+9914 @049332> : 11 04                      dup.x2 sp(4)
	<.main+9916 @049334> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9925 @04933d> : 11 02                      dup.x2 sp(2)
	<.main+9927 @04933f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9936 @049348> : 11 06                      dup.x2 sp(6)
	<.main+9938 @04934a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9947 @049353> : 83                         mul.f64
	<.main+9948 @049354> : 81                         add.f64
	<.main+9949 @049355> : 83                         mul.f64
	<.main+9950 @049356> : 81                         add.f64
	<.main+9951 @049357> : 14 02                      set.x2 sp(2)
	<.main+9953 @049359> : 83                         mul.f64
	<.main+9954 @04935a> : 81                         add.f64
	<.main+9955 @04935b> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:56: (72 bytes: <@04935d> - <@0493a5>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9957 @04935d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9966 @049366> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9975 @04936f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9984 @049378> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9993 @049381> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10002 @04938a>: 1c 05 00 00 00             load.c32 5
	<.main+10007 @04938f>: 0a 04 00 00                load.sp(+4)
	<.main+10011 @049393>: 1a                         load.z64
	<.main+10012 @049394>: 11 18                      dup.x2 sp(24)
	<.main+10014 @049396>: 11 04                      dup.x2 sp(4)
	<.main+10016 @049398>: 1f 00 5c 04 00             load.ref <@045c00> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10021 @04939d>: 02                         call
	<.main+10022 @04939e>: 17 10 04                   mov.x2 sp(16, 4)
	<.main+10025 @0493a1>: 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:57: (81 bytes: <@0493a5> - <@0493f6>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10029 @0493a5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10038 @0493ae>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10047 @0493b7>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10056 @0493c0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10065 @0493c9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10074 @0493d2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10083 @0493db>: 1c 06 00 00 00             load.c32 6
	<.main+10088 @0493e0>: 0a 04 00 00                load.sp(+4)
	<.main+10092 @0493e4>: 1a                         load.z64
	<.main+10093 @0493e5>: 11 1c                      dup.x2 sp(28)
	<.main+10095 @0493e7>: 11 04                      dup.x2 sp(4)
	<.main+10097 @0493e9>: 1f 00 5c 04 00             load.ref <@045c00> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10102 @0493ee>: 02                         call
	<.main+10103 @0493ef>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10106 @0493f2>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:59: (31 bytes: <@0493f6> - <@049415>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10110 @0493f6>: 1a                         load.z64
	<.main+10111 @0493f7>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10120 @049400>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10129 @049409>: 84                         div.f64
	<.main+10130 @04940a>: 19                         load.z32
	<.main+10131 @04940b>: 1f b0 5c 04 00             load.ref <@045cb0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10136 @049410>: 02                         call
	<.main+10137 @049411>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:60: (45 bytes: <@049415> - <@049442>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10141 @049415>: 1b                         load.z128
	<.main+10142 @049416>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10151 @04941f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10160 @049428>: 84                         div.f64
	<.main+10161 @049429>: 1f 90 5a 04 00             load.ref <@045a90> ;Math.abs(x: float64): float64
	<.main+10166 @04942e>: 02                         call
	<.main+10167 @04942f>: 09 f8 ff ff                inc.sp(-8)
	<.main+10171 @049433>: 1c 01 00 00 00             load.c32 1
	<.main+10176 @049438>: 1f b0 5c 04 00             load.ref <@045cb0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10181 @04943d>: 02                         call
	<.main+10182 @04943e>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:61: (30 bytes: <@049442> - <@049460>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10186 @049442>: 1a                         load.z64
	<.main+10187 @049443>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10196 @04944c>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10205 @049455>: 84                         div.f64
	<.main+10206 @049456>: 1f 00 5e 04 00             load.ref <@045e00> ;Math.tan(arg: float64): float64
	<.main+10211 @04945b>: 02                         call
	<.main+10212 @04945c>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:62: (30 bytes: <@049460> - <@04947e>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10216 @049460>: 1a                         load.z64
	<.main+10217 @049461>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10226 @04946a>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10235 @049473>: 84                         div.f64
	<.main+10236 @049474>: 1f 78 5f 04 00             load.ref <@045f78> ;Math.sinh(x: float64): float64
	<.main+10241 @049479>: 02                         call
	<.main+10242 @04947a>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (30 bytes: <@04947e> - <@04949c>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10246 @04947e>: 1a                         load.z64
	<.main+10247 @04947f>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10256 @049488>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10265 @049491>: 84                         div.f64
	<.main+10266 @049492>: 1f 70 60 04 00             load.ref <@046070> ;Math.cosh(x: float64): float64
	<.main+10271 @049497>: 02                         call
	<.main+10272 @049498>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:65: (20 bytes: <@04949c> - <@0494b0>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10276 @04949c>: 1a                         load.z64
	<.main+10277 @04949d>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10286 @0494a6>: 1f c0 60 04 00             load.ref <@0460c0> ;Math.asin(x: float64): float64
	<.main+10291 @0494ab>: 02                         call
	<.main+10292 @0494ac>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:66: (40 bytes: <@0494b0> - <@0494d8>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10296 @0494b0>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10305 @0494b9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10314 @0494c2>: 84                         div.f64
	<.main+10315 @0494c3>: 1a                         load.z64
	<.main+10316 @0494c4>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10325 @0494cd>: 1f c0 60 04 00             load.ref <@0460c0> ;Math.asin(x: float64): float64
	<.main+10330 @0494d2>: 02                         call
	<.main+10331 @0494d3>: 09 f8 ff ff                inc.sp(-8)
	<.main+10335 @0494d7>: 82                         sub.f64
	test/stdc/test.math.ci:69: (28 bytes: <@0494d8> - <@0494f4>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10336 @0494d8>: 19                         load.z32
	<.main+10337 @0494d9>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10342 @0494de>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10347 @0494e3>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10352 @0494e8>: 1f 30 5c 04 00             load.ref <@045c30> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10357 @0494ed>: 02                         call
	<.main+10358 @0494ee>: 09 f4 ff ff                inc.sp(-12)
	<.main+10362 @0494f2>: 19                         load.z32
	<.main+10363 @0494f3>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (40 bytes: <@0494f4> - <@04951c>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10364 @0494f4>: 19                         load.z32
	<.main+10365 @0494f5>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10374 @0494fe>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10383 @049507>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10392 @049510>: 1f 70 5c 04 00             load.ref <@045c70> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10397 @049515>: 02                         call
	<.main+10398 @049516>: 09 e8 ff ff                inc.sp(-24)
	<.main+10402 @04951a>: 19                         load.z32
	<.main+10403 @04951b>: 57                         ceq.i32
	<.main+10404 @04951c>: 01 00 00 00                nfc(0) ;halt(): void
.references:
}

---------- Execute: byte-code
[ 262.85] > .main
[ 263.28]  > funAdd(x: int32, y: int32): int32
[ 263.30]  < return
[ 263.31]  > funAdd(x: int32, y: int32): int32
[ 263.32]  < return
[ 263.33]  > funMul(x: int32, y: int32): int32
[ 263.34]  < return
[ 263.35]  > funMul(x: int32, y: int32): int32
[ 263.36]  < return
[ 263.37]  > fib(n: uint32): uint32
[ 263.38]   > fib(n: uint32): uint32
[ 263.39]    > fib(n: uint32): uint32
[ 263.40]     > fib(n: uint32): uint32
[ 263.41]      > fib(n: uint32): uint32
[ 263.42]       > fib(n: uint32): uint32
[ 263.43]        > fib(n: uint32): uint32
[ 263.44]         > fib(n: uint32): uint32
[ 263.45]          > fib(n: uint32): uint32
[ 263.46]           > fib(n: uint32): uint32
[ 263.47]            > fib(n: uint32): uint32
[ 263.48]             > fib(n: uint32): uint32
[ 263.49]              > fib(n: uint32): uint32
[ 263.50]              < return
[ 263.51]              > fib(n: uint32): uint32
[ 263.51]              < return
[ 263.52]             < return
[ 263.53]             > fib(n: uint32): uint32
[ 263.54]             < return
[ 263.55]            < return
[ 263.55]            > fib(n: uint32): uint32
[ 263.56]             > fib(n: uint32): uint32
[ 263.57]             < return
[ 263.58]             > fib(n: uint32): uint32
[ 263.59]             < return
[ 263.60]            < return
[ 263.60]           < return
[ 263.61]           > fib(n: uint32): uint32
[ 263.62]            > fib(n: uint32): uint32
[ 263.63]             > fib(n: uint32): uint32
[ 263.64]             < return
[ 263.65]             > fib(n: uint32): uint32
[ 263.66]             < return
[ 263.66]            < return
[ 263.67]            > fib(n: uint32): uint32
[ 263.68]            < return
[ 263.69]           < return
[ 263.69]          < return
[ 263.70]          > fib(n: uint32): uint32
[ 263.71]           > fib(n: uint32): uint32
[ 263.72]            > fib(n: uint32): uint32
[ 263.74]             > fib(n: uint32): uint32
[ 263.74]             < return
[ 263.75]             > fib(n: uint32): uint32
[ 263.76]             < return
[ 263.77]            < return
[ 263.77]            > fib(n: uint32): uint32
[ 263.78]            < return
[ 263.79]           < return
[ 263.80]           > fib(n: uint32): uint32
[ 263.81]            > fib(n: uint32): uint32
[ 263.82]            < return
[ 263.83]            > fib(n: uint32): uint32
[ 263.83]            < return
[ 263.84]           < return
[ 263.85]          < return
[ 263.86]         < return
[ 263.86]         > fib(n: uint32): uint32
[ 263.87]          > fib(n: uint32): uint32
[ 263.88]           > fib(n: uint32): uint32
[ 263.89]            > fib(n: uint32): uint32
[ 263.90]             > fib(n: uint32): uint32
[ 263.91]             < return
[ 263.92]             > fib(n: uint32): uint32
[ 263.93]             < return
[ 263.94]            < return
[ 263.94]            > fib(n: uint32): uint32
[ 263.95]            < return
[ 263.96]           < return
[ 263.97]           > fib(n: uint32): uint32
[ 263.98]            > fib(n: uint32): uint32
[ 263.99]            < return
[ 263.99]            > fib(n: uint32): uint32
[ 264.00]            < return
[ 264.01]           < return
[ 264.02]          < return
[ 264.02]          > fib(n: uint32): uint32
[ 264.03]           > fib(n: uint32): uint32
[ 264.04]            > fib(n: uint32): uint32
[ 264.05]            < return
[ 264.06]            > fib(n: uint32): uint32
[ 264.07]            < return
[ 264.08]           < return
[ 264.08]           > fib(n: uint32): uint32
[ 264.09]           < return
[ 264.10]          < return
[ 264.11]         < return
[ 264.13]        < return
[ 264.13]        > fib(n: uint32): uint32
[ 264.14]         > fib(n: uint32): uint32
[ 264.15]          > fib(n: uint32): uint32
[ 264.17]           > fib(n: uint32): uint32
[ 264.18]            > fib(n: uint32): uint32
[ 264.20]             > fib(n: uint32): uint32
[ 264.21]             < return
[ 264.22]             > fib(n: uint32): uint32
[ 264.23]             < return
[ 264.23]            < return
[ 264.24]            > fib(n: uint32): uint32
[ 264.25]            < return
[ 264.26]           < return
[ 264.26]           > fib(n: uint32): uint32
[ 264.27]            > fib(n: uint32): uint32
[ 264.28]            < return
[ 264.29]            > fib(n: uint32): uint32
[ 264.30]            < return
[ 264.31]           < return
[ 264.31]          < return
[ 264.32]          > fib(n: uint32): uint32
[ 264.33]           > fib(n: uint32): uint32
[ 264.34]            > fib(n: uint32): uint32
[ 264.35]            < return
[ 264.36]            > fib(n: uint32): uint32
[ 264.37]            < return
[ 264.37]           < return
[ 264.38]           > fib(n: uint32): uint32
[ 264.39]           < return
[ 264.40]          < return
[ 264.40]         < return
[ 264.41]         > fib(n: uint32): uint32
[ 264.43]          > fib(n: uint32): uint32
[ 264.45]           > fib(n: uint32): uint32
[ 264.46]            > fib(n: uint32): uint32
[ 264.47]            < return
[ 264.47]            > fib(n: uint32): uint32
[ 264.48]            < return
[ 264.49]           < return
[ 264.50]           > fib(n: uint32): uint32
[ 264.51]           < return
[ 264.52]          < return
[ 264.52]          > fib(n: uint32): uint32
[ 264.53]           > fib(n: uint32): uint32
[ 264.54]           < return
[ 264.55]           > fib(n: uint32): uint32
[ 264.56]           < return
[ 264.57]          < return
[ 264.57]         < return
[ 264.58]        < return
[ 264.59]       < return
[ 264.59]       > fib(n: uint32): uint32
[ 264.60]        > fib(n: uint32): uint32
[ 264.61]         > fib(n: uint32): uint32
[ 264.62]          > fib(n: uint32): uint32
[ 264.63]           > fib(n: uint32): uint32
[ 264.64]            > fib(n: uint32): uint32
[ 264.65]             > fib(n: uint32): uint32
[ 264.66]             < return
[ 264.69]             > fib(n: uint32): uint32
[ 264.69]             < return
[ 264.70]            < return
[ 264.71]            > fib(n: uint32): uint32
[ 264.72]            < return
[ 264.73]           < return
[ 264.75]           > fib(n: uint32): uint32
[ 264.76]            > fib(n: uint32): uint32
[ 264.77]            < return
[ 264.77]            > fib(n: uint32): uint32
[ 264.78]            < return
[ 264.79]           < return
[ 264.80]          < return
[ 264.81]          > fib(n: uint32): uint32
[ 264.82]           > fib(n: uint32): uint32
[ 264.83]            > fib(n: uint32): uint32
[ 264.83]            < return
[ 264.84]            > fib(n: uint32): uint32
[ 264.85]            < return
[ 264.86]           < return
[ 264.87]           > fib(n: uint32): uint32
[ 264.88]           < return
[ 264.88]          < return
[ 264.89]         < return
[ 264.90]         > fib(n: uint32): uint32
[ 264.91]          > fib(n: uint32): uint32
[ 264.92]           > fib(n: uint32): uint32
[ 264.93]            > fib(n: uint32): uint32
[ 264.94]            < return
[ 264.94]            > fib(n: uint32): uint32
[ 264.95]            < return
[ 264.96]           < return
[ 264.97]           > fib(n: uint32): uint32
[ 264.98]           < return
[ 264.98]          < return
[ 264.99]          > fib(n: uint32): uint32
[ 265.00]           > fib(n: uint32): uint32
[ 265.01]           < return
[ 265.02]           > fib(n: uint32): uint32
[ 265.03]           < return
[ 265.03]          < return
[ 265.04]         < return
[ 265.06]        < return
[ 265.07]        > fib(n: uint32): uint32
[ 265.08]         > fib(n: uint32): uint32
[ 265.09]          > fib(n: uint32): uint32
[ 265.10]           > fib(n: uint32): uint32
[ 265.11]            > fib(n: uint32): uint32
[ 265.13]            < return
[ 265.14]            > fib(n: uint32): uint32
[ 265.15]            < return
[ 265.15]           < return
[ 265.16]           > fib(n: uint32): uint32
[ 265.17]           < return
[ 265.18]          < return
[ 265.19]          > fib(n: uint32): uint32
[ 265.20]           > fib(n: uint32): uint32
[ 265.20]           < return
[ 265.21]           > fib(n: uint32): uint32
[ 265.22]           < return
[ 265.23]          < return
[ 265.24]         < return
[ 265.24]         > fib(n: uint32): uint32
[ 265.25]          > fib(n: uint32): uint32
[ 265.26]           > fib(n: uint32): uint32
[ 265.27]           < return
[ 265.28]           > fib(n: uint32): uint32
[ 265.29]           < return
[ 265.30]          < return
[ 265.30]          > fib(n: uint32): uint32
[ 265.31]          < return
[ 265.32]         < return
[ 265.33]        < return
[ 265.33]       < return
[ 265.34]      < return
[ 265.35]      > fib(n: uint32): uint32
[ 265.37]       > fib(n: uint32): uint32
[ 265.38]        > fib(n: uint32): uint32
[ 265.39]         > fib(n: uint32): uint32
[ 265.40]          > fib(n: uint32): uint32
[ 265.41]           > fib(n: uint32): uint32
[ 265.42]            > fib(n: uint32): uint32
[ 265.43]             > fib(n: uint32): uint32
[ 265.44]             < return
[ 265.45]             > fib(n: uint32): uint32
[ 265.46]             < return
[ 265.47]            < return
[ 265.47]            > fib(n: uint32): uint32
[ 265.48]            < return
[ 265.50]           < return
[ 265.51]           > fib(n: uint32): uint32
[ 265.52]            > fib(n: uint32): uint32
[ 265.53]            < return
[ 265.54]            > fib(n: uint32): uint32
[ 265.55]            < return
[ 265.56]           < return
[ 265.56]          < return
[ 265.57]          > fib(n: uint32): uint32
[ 265.58]           > fib(n: uint32): uint32
[ 265.59]            > fib(n: uint32): uint32
[ 265.60]            < return
[ 265.61]            > fib(n: uint32): uint32
[ 265.62]            < return
[ 265.62]           < return
[ 265.63]           > fib(n: uint32): uint32
[ 265.64]           < return
[ 265.65]          < return
[ 265.65]         < return
[ 265.66]         > fib(n: uint32): uint32
[ 265.67]          > fib(n: uint32): uint32
[ 265.68]           > fib(n: uint32): uint32
[ 265.69]            > fib(n: uint32): uint32
[ 265.70]            < return
[ 265.71]            > fib(n: uint32): uint32
[ 265.72]            < return
[ 265.72]           < return
[ 265.73]           > fib(n: uint32): uint32
[ 265.74]           < return
[ 265.75]          < return
[ 265.76]          > fib(n: uint32): uint32
[ 265.77]           > fib(n: uint32): uint32
[ 265.78]           < return
[ 265.78]           > fib(n: uint32): uint32
[ 265.79]           < return
[ 265.80]          < return
[ 265.81]         < return
[ 265.81]        < return
[ 265.82]        > fib(n: uint32): uint32
[ 265.83]         > fib(n: uint32): uint32
[ 265.84]          > fib(n: uint32): uint32
[ 265.85]           > fib(n: uint32): uint32
[ 265.86]            > fib(n: uint32): uint32
[ 265.87]            < return
[ 265.88]            > fib(n: uint32): uint32
[ 265.89]            < return
[ 265.89]           < return
[ 265.90]           > fib(n: uint32): uint32
[ 265.91]           < return
[ 265.92]          < return
[ 265.93]          > fib(n: uint32): uint32
[ 265.94]           > fib(n: uint32): uint32
[ 265.94]           < return
[ 265.95]           > fib(n: uint32): uint32
[ 265.96]           < return
[ 265.97]          < return
[ 265.98]         < return
[ 265.98]         > fib(n: uint32): uint32
[ 265.99]          > fib(n: uint32): uint32
[ 266.00]           > fib(n: uint32): uint32
[ 266.01]           < return
[ 266.02]           > fib(n: uint32): uint32
[ 266.03]           < return
[ 266.04]          < return
[ 266.04]          > fib(n: uint32): uint32
[ 266.05]          < return
[ 266.06]         < return
[ 266.07]        < return
[ 266.07]       < return
[ 266.08]       > fib(n: uint32): uint32
[ 266.09]        > fib(n: uint32): uint32
[ 266.10]         > fib(n: uint32): uint32
[ 266.11]          > fib(n: uint32): uint32
[ 266.12]           > fib(n: uint32): uint32
[ 266.13]            > fib(n: uint32): uint32
[ 266.14]            < return
[ 266.15]            > fib(n: uint32): uint32
[ 266.16]            < return
[ 266.16]           < return
[ 266.17]           > fib(n: uint32): uint32
[ 266.18]           < return
[ 266.19]          < return
[ 266.19]          > fib(n: uint32): uint32
[ 266.20]           > fib(n: uint32): uint32
[ 266.21]           < return
[ 266.22]           > fib(n: uint32): uint32
[ 266.23]           < return
[ 266.24]          < return
[ 266.26]         < return
[ 266.29]         > fib(n: uint32): uint32
[ 266.30]          > fib(n: uint32): uint32
[ 266.31]           > fib(n: uint32): uint32
[ 266.33]           < return
[ 266.34]           > fib(n: uint32): uint32
[ 266.35]           < return
[ 266.36]          < return
[ 266.37]          > fib(n: uint32): uint32
[ 266.39]          < return
[ 266.39]         < return
[ 266.40]        < return
[ 266.41]        > fib(n: uint32): uint32
[ 266.42]         > fib(n: uint32): uint32
[ 266.43]          > fib(n: uint32): uint32
[ 266.44]           > fib(n: uint32): uint32
[ 266.45]           < return
[ 266.46]           > fib(n: uint32): uint32
[ 266.47]           < return
[ 266.47]          < return
[ 266.48]          > fib(n: uint32): uint32
[ 266.49]          < return
[ 266.50]         < return
[ 266.50]         > fib(n: uint32): uint32
[ 266.51]          > fib(n: uint32): uint32
[ 266.52]          < return
[ 266.53]          > fib(n: uint32): uint32
[ 266.54]          < return
[ 266.55]         < return
[ 266.55]        < return
[ 266.56]       < return
[ 266.57]      < return
[ 266.57]     < return
[ 266.58]     > fib(n: uint32): uint32
[ 266.59]      > fib(n: uint32): uint32
[ 266.60]       > fib(n: uint32): uint32
[ 266.61]        > fib(n: uint32): uint32
[ 266.62]         > fib(n: uint32): uint32
[ 266.63]          > fib(n: uint32): uint32
[ 266.66]           > fib(n: uint32): uint32
[ 266.67]            > fib(n: uint32): uint32
[ 266.68]             > fib(n: uint32): uint32
[ 266.69]             < return
[ 266.69]             > fib(n: uint32): uint32
[ 266.70]             < return
[ 266.71]            < return
[ 266.72]            > fib(n: uint32): uint32
[ 266.73]            < return
[ 266.73]           < return
[ 266.74]           > fib(n: uint32): uint32
[ 266.75]            > fib(n: uint32): uint32
[ 266.76]            < return
[ 266.77]            > fib(n: uint32): uint32
[ 266.78]            < return
[ 266.79]           < return
[ 266.79]          < return
[ 266.80]          > fib(n: uint32): uint32
[ 266.81]           > fib(n: uint32): uint32
[ 266.82]            > fib(n: uint32): uint32
[ 266.83]            < return
[ 266.84]            > fib(n: uint32): uint32
[ 266.85]            < return
[ 266.85]           < return
[ 266.88]           > fib(n: uint32): uint32
[ 266.89]           < return
[ 266.90]          < return
[ 266.92]         < return
[ 266.93]         > fib(n: uint32): uint32
[ 266.94]          > fib(n: uint32): uint32
[ 266.95]           > fib(n: uint32): uint32
[ 266.96]            > fib(n: uint32): uint32
[ 266.97]            < return
[ 266.98]            > fib(n: uint32): uint32
[ 266.99]            < return
[ 267.01]           < return
[ 267.01]           > fib(n: uint32): uint32
[ 267.02]           < return
[ 267.03]          < return
[ 267.04]          > fib(n: uint32): uint32
[ 267.05]           > fib(n: uint32): uint32
[ 267.06]           < return
[ 267.06]           > fib(n: uint32): uint32
[ 267.07]           < return
[ 267.08]          < return
[ 267.09]         < return
[ 267.10]        < return
[ 267.10]        > fib(n: uint32): uint32
[ 267.12]         > fib(n: uint32): uint32
[ 267.12]          > fib(n: uint32): uint32
[ 267.13]           > fib(n: uint32): uint32
[ 267.15]            > fib(n: uint32): uint32
[ 267.15]            < return
[ 267.16]            > fib(n: uint32): uint32
[ 267.17]            < return
[ 267.18]           < return
[ 267.19]           > fib(n: uint32): uint32
[ 267.19]           < return
[ 267.20]          < return
[ 267.21]          > fib(n: uint32): uint32
[ 267.22]           > fib(n: uint32): uint32
[ 267.23]           < return
[ 267.24]           > fib(n: uint32): uint32
[ 267.25]           < return
[ 267.25]          < return
[ 267.26]         < return
[ 267.27]         > fib(n: uint32): uint32
[ 267.28]          > fib(n: uint32): uint32
[ 267.29]           > fib(n: uint32): uint32
[ 267.30]           < return
[ 267.30]           > fib(n: uint32): uint32
[ 267.31]           < return
[ 267.32]          < return
[ 267.33]          > fib(n: uint32): uint32
[ 267.35]          < return
[ 267.35]         < return
[ 267.36]        < return
[ 267.38]       < return
[ 267.41]       > fib(n: uint32): uint32
[ 267.43]        > fib(n: uint32): uint32
[ 267.44]         > fib(n: uint32): uint32
[ 267.45]          > fib(n: uint32): uint32
[ 267.46]           > fib(n: uint32): uint32
[ 267.47]            > fib(n: uint32): uint32
[ 267.48]            < return
[ 267.55]            > fib(n: uint32): uint32
[ 267.58]            < return
[ 267.60]           < return
[ 267.63]           > fib(n: uint32): uint32
[ 267.64]           < return
[ 267.64]          < return
[ 267.65]          > fib(n: uint32): uint32
[ 267.66]           > fib(n: uint32): uint32
[ 267.67]           < return
[ 267.69]           > fib(n: uint32): uint32
[ 267.71]           < return
[ 267.72]          < return
[ 267.72]         < return
[ 267.73]         > fib(n: uint32): uint32
[ 267.74]          > fib(n: uint32): uint32
[ 267.75]           > fib(n: uint32): uint32
[ 267.76]           < return
[ 267.78]           > fib(n: uint32): uint32
[ 267.79]           < return
[ 267.80]          < return
[ 267.81]          > fib(n: uint32): uint32
[ 267.81]          < return
[ 267.82]         < return
[ 267.84]        < return
[ 267.85]        > fib(n: uint32): uint32
[ 267.86]         > fib(n: uint32): uint32
[ 267.87]          > fib(n: uint32): uint32
[ 267.88]           > fib(n: uint32): uint32
[ 267.89]           < return
[ 267.90]           > fib(n: uint32): uint32
[ 267.90]           < return
[ 267.91]          < return
[ 267.92]          > fib(n: uint32): uint32
[ 267.93]          < return
[ 267.94]         < return
[ 267.94]         > fib(n: uint32): uint32
[ 267.95]          > fib(n: uint32): uint32
[ 267.96]          < return
[ 267.97]          > fib(n: uint32): uint32
[ 267.98]          < return
[ 267.99]         < return
[ 268.00]        < return
[ 268.00]       < return
[ 268.01]      < return
[ 268.02]      > fib(n: uint32): uint32
[ 268.03]       > fib(n: uint32): uint32
[ 268.04]        > fib(n: uint32): uint32
[ 268.05]         > fib(n: uint32): uint32
[ 268.06]          > fib(n: uint32): uint32
[ 268.07]           > fib(n: uint32): uint32
[ 268.09]            > fib(n: uint32): uint32
[ 268.10]            < return
[ 268.11]            > fib(n: uint32): uint32
[ 268.12]            < return
[ 268.12]           < return
[ 268.13]           > fib(n: uint32): uint32
[ 268.14]           < return
[ 268.15]          < return
[ 268.16]          > fib(n: uint32): uint32
[ 268.17]           > fib(n: uint32): uint32
[ 268.18]           < return
[ 268.18]           > fib(n: uint32): uint32
[ 268.19]           < return
[ 268.20]          < return
[ 268.21]         < return
[ 268.21]         > fib(n: uint32): uint32
[ 268.22]          > fib(n: uint32): uint32
[ 268.23]           > fib(n: uint32): uint32
[ 268.24]           < return
[ 268.25]           > fib(n: uint32): uint32
[ 268.26]           < return
[ 268.27]          < return
[ 268.29]          > fib(n: uint32): uint32
[ 268.30]          < return
[ 268.30]         < return
[ 268.31]        < return
[ 268.32]        > fib(n: uint32): uint32
[ 268.33]         > fib(n: uint32): uint32
[ 268.34]          > fib(n: uint32): uint32
[ 268.35]           > fib(n: uint32): uint32
[ 268.36]           < return
[ 268.37]           > fib(n: uint32): uint32
[ 268.37]           < return
[ 268.38]          < return
[ 268.39]          > fib(n: uint32): uint32
[ 268.40]          < return
[ 268.40]         < return
[ 268.41]         > fib(n: uint32): uint32
[ 268.42]          > fib(n: uint32): uint32
[ 268.43]          < return
[ 268.44]          > fib(n: uint32): uint32
[ 268.45]          < return
[ 268.45]         < return
[ 268.46]        < return
[ 268.47]       < return
[ 268.48]       > fib(n: uint32): uint32
[ 268.49]        > fib(n: uint32): uint32
[ 268.50]         > fib(n: uint32): uint32
[ 268.51]          > fib(n: uint32): uint32
[ 268.52]           > fib(n: uint32): uint32
[ 268.53]           < return
[ 268.53]           > fib(n: uint32): uint32
[ 268.54]           < return
[ 268.55]          < return
[ 268.56]          > fib(n: uint32): uint32
[ 268.57]          < return
[ 268.57]         < return
[ 268.58]         > fib(n: uint32): uint32
[ 268.59]          > fib(n: uint32): uint32
[ 268.60]          < return
[ 268.61]          > fib(n: uint32): uint32
[ 268.62]          < return
[ 268.62]         < return
[ 268.63]        < return
[ 268.64]        > fib(n: uint32): uint32
[ 268.65]         > fib(n: uint32): uint32
[ 268.66]          > fib(n: uint32): uint32
[ 268.67]          < return
[ 268.68]          > fib(n: uint32): uint32
[ 268.68]          < return
[ 268.69]         < return
[ 268.70]         > fib(n: uint32): uint32
[ 268.71]         < return
[ 268.71]        < return
[ 268.72]       < return
[ 268.73]      < return
[ 268.73]     < return
[ 268.74]    < return
[ 268.75]    > fib(n: uint32): uint32
[ 268.76]     > fib(n: uint32): uint32
[ 268.77]      > fib(n: uint32): uint32
[ 268.78]       > fib(n: uint32): uint32
[ 268.79]        > fib(n: uint32): uint32
[ 268.80]         > fib(n: uint32): uint32
[ 268.81]          > fib(n: uint32): uint32
[ 268.82]           > fib(n: uint32): uint32
[ 268.83]            > fib(n: uint32): uint32
[ 268.84]             > fib(n: uint32): uint32
[ 268.85]             < return
[ 268.86]             > fib(n: uint32): uint32
[ 268.87]             < return
[ 268.87]            < return
[ 268.88]            > fib(n: uint32): uint32
[ 268.89]            < return
[ 268.90]           < return
[ 268.90]           > fib(n: uint32): uint32
[ 268.91]            > fib(n: uint32): uint32
[ 268.92]            < return
[ 268.93]            > fib(n: uint32): uint32
[ 268.94]            < return
[ 268.95]           < return
[ 268.95]          < return
[ 268.96]          > fib(n: uint32): uint32
[ 268.97]           > fib(n: uint32): uint32
[ 268.98]            > fib(n: uint32): uint32
[ 268.99]            < return
[ 269.00]            > fib(n: uint32): uint32
[ 269.01]            < return
[ 269.02]           < return
[ 269.02]           > fib(n: uint32): uint32
[ 269.03]           < return
[ 269.04]          < return
[ 269.05]         < return
[ 269.05]         > fib(n: uint32): uint32
[ 269.06]          > fib(n: uint32): uint32
[ 269.07]           > fib(n: uint32): uint32
[ 269.08]            > fib(n: uint32): uint32
[ 269.09]            < return
[ 269.10]            > fib(n: uint32): uint32
[ 269.11]            < return
[ 269.12]           < return
[ 269.12]           > fib(n: uint32): uint32
[ 269.13]           < return
[ 269.14]          < return
[ 269.15]          > fib(n: uint32): uint32
[ 269.16]           > fib(n: uint32): uint32
[ 269.17]           < return
[ 269.18]           > fib(n: uint32): uint32
[ 269.19]           < return
[ 269.19]          < return
[ 269.20]         < return
[ 269.21]        < return
[ 269.21]        > fib(n: uint32): uint32
[ 269.22]         > fib(n: uint32): uint32
[ 269.23]          > fib(n: uint32): uint32
[ 269.24]           > fib(n: uint32): uint32
[ 269.25]            > fib(n: uint32): uint32
[ 269.26]            < return
[ 269.27]            > fib(n: uint32): uint32
[ 269.28]            < return
[ 269.29]           < return
[ 269.29]           > fib(n: uint32): uint32
[ 269.30]           < return
[ 269.31]          < return
[ 269.32]          > fib(n: uint32): uint32
[ 269.34]           > fib(n: uint32): uint32
[ 269.35]           < return
[ 269.36]           > fib(n: uint32): uint32
[ 269.37]           < return
[ 269.38]          < return
[ 269.38]         < return
[ 269.39]         > fib(n: uint32): uint32
[ 269.40]          > fib(n: uint32): uint32
[ 269.41]           > fib(n: uint32): uint32
[ 269.42]           < return
[ 269.43]           > fib(n: uint32): uint32
[ 269.44]           < return
[ 269.44]          < return
[ 269.45]          > fib(n: uint32): uint32
[ 269.46]          < return
[ 269.47]         < return
[ 269.47]        < return
[ 269.48]       < return
[ 269.49]       > fib(n: uint32): uint32
[ 269.50]        > fib(n: uint32): uint32
[ 269.51]         > fib(n: uint32): uint32
[ 269.52]          > fib(n: uint32): uint32
[ 269.53]           > fib(n: uint32): uint32
[ 269.54]            > fib(n: uint32): uint32
[ 269.55]            < return
[ 269.55]            > fib(n: uint32): uint32
[ 269.56]            < return
[ 269.57]           < return
[ 269.58]           > fib(n: uint32): uint32
[ 269.59]           < return
[ 269.59]          < return
[ 269.60]          > fib(n: uint32): uint32
[ 269.61]           > fib(n: uint32): uint32
[ 269.62]           < return
[ 269.63]           > fib(n: uint32): uint32
[ 269.64]           < return
[ 269.64]          < return
[ 269.65]         < return
[ 269.66]         > fib(n: uint32): uint32
[ 269.69]          > fib(n: uint32): uint32
[ 269.70]           > fib(n: uint32): uint32
[ 269.72]           < return
[ 269.74]           > fib(n: uint32): uint32
[ 269.75]           < return
[ 269.76]          < return
[ 269.77]          > fib(n: uint32): uint32
[ 269.78]          < return
[ 269.79]         < return
[ 269.80]        < return
[ 269.81]        > fib(n: uint32): uint32
[ 269.85]         > fib(n: uint32): uint32
[ 269.86]          > fib(n: uint32): uint32
[ 269.88]           > fib(n: uint32): uint32
[ 269.89]           < return
[ 269.90]           > fib(n: uint32): uint32
[ 269.91]           < return
[ 269.92]          < return
[ 269.93]          > fib(n: uint32): uint32
[ 269.94]          < return
[ 269.94]         < return
[ 269.95]         > fib(n: uint32): uint32
[ 269.98]          > fib(n: uint32): uint32
[ 269.99]          < return
[ 269.99]          > fib(n: uint32): uint32
[ 270.00]          < return
[ 270.01]         < return
[ 270.03]        < return
[ 270.04]       < return
[ 270.05]      < return
[ 270.05]      > fib(n: uint32): uint32
[ 270.06]       > fib(n: uint32): uint32
[ 270.09]        > fib(n: uint32): uint32
[ 270.10]         > fib(n: uint32): uint32
[ 270.11]          > fib(n: uint32): uint32
[ 270.12]           > fib(n: uint32): uint32
[ 270.14]            > fib(n: uint32): uint32
[ 270.15]            < return
[ 270.15]            > fib(n: uint32): uint32
[ 270.16]            < return
[ 270.17]           < return
[ 270.18]           > fib(n: uint32): uint32
[ 270.19]           < return
[ 270.19]          < return
[ 270.20]          > fib(n: uint32): uint32
[ 270.22]           > fib(n: uint32): uint32
[ 270.23]           < return
[ 270.26]           > fib(n: uint32): uint32
[ 270.27]           < return
[ 270.28]          < return
[ 270.28]         < return
[ 270.29]         > fib(n: uint32): uint32
[ 270.32]          > fib(n: uint32): uint32
[ 270.34]           > fib(n: uint32): uint32
[ 270.35]           < return
[ 270.36]           > fib(n: uint32): uint32
[ 270.37]           < return
[ 270.38]          < return
[ 270.39]          > fib(n: uint32): uint32
[ 270.41]          < return
[ 270.42]         < return
[ 270.42]        < return
[ 270.43]        > fib(n: uint32): uint32
[ 270.45]         > fib(n: uint32): uint32
[ 270.47]          > fib(n: uint32): uint32
[ 270.48]           > fib(n: uint32): uint32
[ 270.51]           < return
[ 270.52]           > fib(n: uint32): uint32
[ 270.54]           < return
[ 270.55]          < return
[ 270.56]          > fib(n: uint32): uint32
[ 270.58]          < return
[ 270.58]         < return
[ 270.59]         > fib(n: uint32): uint32
[ 270.62]          > fib(n: uint32): uint32
[ 270.63]          < return
[ 270.63]          > fib(n: uint32): uint32
[ 270.64]          < return
[ 270.65]         < return
[ 270.66]        < return
[ 270.66]       < return
[ 270.67]       > fib(n: uint32): uint32
[ 270.68]        > fib(n: uint32): uint32
[ 270.69]         > fib(n: uint32): uint32
[ 270.70]          > fib(n: uint32): uint32
[ 270.71]           > fib(n: uint32): uint32
[ 270.72]           < return
[ 270.73]           > fib(n: uint32): uint32
[ 270.74]           < return
[ 270.75]          < return
[ 270.75]          > fib(n: uint32): uint32
[ 270.76]          < return
[ 270.77]         < return
[ 270.78]         > fib(n: uint32): uint32
[ 270.79]          > fib(n: uint32): uint32
[ 270.80]          < return
[ 270.80]          > fib(n: uint32): uint32
[ 270.81]          < return
[ 270.82]         < return
[ 270.83]        < return
[ 270.83]        > fib(n: uint32): uint32
[ 270.84]         > fib(n: uint32): uint32
[ 270.87]          > fib(n: uint32): uint32
[ 270.89]          < return
[ 270.90]          > fib(n: uint32): uint32
[ 270.91]          < return
[ 270.91]         < return
[ 270.94]         > fib(n: uint32): uint32
[ 270.94]         < return
[ 270.95]        < return
[ 270.96]       < return
[ 270.96]      < return
[ 270.97]     < return
[ 270.98]     > fib(n: uint32): uint32
[ 270.99]      > fib(n: uint32): uint32
[ 271.00]       > fib(n: uint32): uint32
[ 271.01]        > fib(n: uint32): uint32
[ 271.02]         > fib(n: uint32): uint32
[ 271.03]          > fib(n: uint32): uint32
[ 271.04]           > fib(n: uint32): uint32
[ 271.06]            > fib(n: uint32): uint32
[ 271.07]            < return
[ 271.08]            > fib(n: uint32): uint32
[ 271.09]            < return
[ 271.10]           < return
[ 271.10]           > fib(n: uint32): uint32
[ 271.11]           < return
[ 271.12]          < return
[ 271.13]          > fib(n: uint32): uint32
[ 271.14]           > fib(n: uint32): uint32
[ 271.15]           < return
[ 271.15]           > fib(n: uint32): uint32
[ 271.16]           < return
[ 271.17]          < return
[ 271.18]         < return
[ 271.19]         > fib(n: uint32): uint32
[ 271.19]          > fib(n: uint32): uint32
[ 271.22]           > fib(n: uint32): uint32
[ 271.23]           < return
[ 271.24]           > fib(n: uint32): uint32
[ 271.26]           < return
[ 271.27]          < return
[ 271.28]          > fib(n: uint32): uint32
[ 271.30]          < return
[ 271.31]         < return
[ 271.32]        < return
[ 271.32]        > fib(n: uint32): uint32
[ 271.33]         > fib(n: uint32): uint32
[ 271.34]          > fib(n: uint32): uint32
[ 271.37]           > fib(n: uint32): uint32
[ 271.38]           < return
[ 271.39]           > fib(n: uint32): uint32
[ 271.40]           < return
[ 271.41]          < return
[ 271.41]          > fib(n: uint32): uint32
[ 271.42]          < return
[ 271.43]         < return
[ 271.44]         > fib(n: uint32): uint32
[ 271.45]          > fib(n: uint32): uint32
[ 271.46]          < return
[ 271.46]          > fib(n: uint32): uint32
[ 271.47]          < return
[ 271.48]         < return
[ 271.49]        < return
[ 271.49]       < return
[ 271.50]       > fib(n: uint32): uint32
[ 271.51]        > fib(n: uint32): uint32
[ 271.52]         > fib(n: uint32): uint32
[ 271.53]          > fib(n: uint32): uint32
[ 271.54]           > fib(n: uint32): uint32
[ 271.55]           < return
[ 271.56]           > fib(n: uint32): uint32
[ 271.59]           < return
[ 271.59]          < return
[ 271.60]          > fib(n: uint32): uint32
[ 271.61]          < return
[ 271.62]         < return
[ 271.64]         > fib(n: uint32): uint32
[ 271.65]          > fib(n: uint32): uint32
[ 271.66]          < return
[ 271.67]          > fib(n: uint32): uint32
[ 271.68]          < return
[ 271.68]         < return
[ 271.69]        < return
[ 271.70]        > fib(n: uint32): uint32
[ 271.71]         > fib(n: uint32): uint32
[ 271.72]          > fib(n: uint32): uint32
[ 271.73]          < return
[ 271.74]          > fib(n: uint32): uint32
[ 271.75]          < return
[ 271.75]         < return
[ 271.76]         > fib(n: uint32): uint32
[ 271.77]         < return
[ 271.77]        < return
[ 271.78]       < return
[ 271.79]      < return
[ 271.80]      > fib(n: uint32): uint32
[ 271.81]       > fib(n: uint32): uint32
[ 271.82]        > fib(n: uint32): uint32
[ 271.83]         > fib(n: uint32): uint32
[ 271.84]          > fib(n: uint32): uint32
[ 271.85]           > fib(n: uint32): uint32
[ 271.86]           < return
[ 271.86]           > fib(n: uint32): uint32
[ 271.87]           < return
[ 271.88]          < return
[ 271.89]          > fib(n: uint32): uint32
[ 271.90]          < return
[ 271.90]         < return
[ 271.91]         > fib(n: uint32): uint32
[ 271.92]          > fib(n: uint32): uint32
[ 271.93]          < return
[ 271.94]          > fib(n: uint32): uint32
[ 271.95]          < return
[ 271.95]         < return
[ 271.98]        < return
[ 271.99]        > fib(n: uint32): uint32
[ 272.00]         > fib(n: uint32): uint32
[ 272.01]          > fib(n: uint32): uint32
[ 272.03]          < return
[ 272.06]          > fib(n: uint32): uint32
[ 272.06]          < return
[ 272.07]         < return
[ 272.08]         > fib(n: uint32): uint32
[ 272.09]         < return
[ 272.11]        < return
[ 272.11]       < return
[ 272.12]       > fib(n: uint32): uint32
[ 272.13]        > fib(n: uint32): uint32
[ 272.14]         > fib(n: uint32): uint32
[ 272.15]          > fib(n: uint32): uint32
[ 272.16]          < return
[ 272.17]          > fib(n: uint32): uint32
[ 272.18]          < return
[ 272.19]         < return
[ 272.19]         > fib(n: uint32): uint32
[ 272.20]         < return
[ 272.21]        < return
[ 272.22]        > fib(n: uint32): uint32
[ 272.23]         > fib(n: uint32): uint32
[ 272.24]         < return
[ 272.24]         > fib(n: uint32): uint32
[ 272.25]         < return
[ 272.26]        < return
[ 272.27]       < return
[ 272.27]      < return
[ 272.28]     < return
[ 272.29]    < return
[ 272.29]   < return
[ 272.30]   > fib(n: uint32): uint32
[ 272.31]    > fib(n: uint32): uint32
[ 272.32]     > fib(n: uint32): uint32
[ 272.33]      > fib(n: uint32): uint32
[ 272.36]       > fib(n: uint32): uint32
[ 272.37]        > fib(n: uint32): uint32
[ 272.38]         > fib(n: uint32): uint32
[ 272.39]          > fib(n: uint32): uint32
[ 272.40]           > fib(n: uint32): uint32
[ 272.41]            > fib(n: uint32): uint32
[ 272.42]             > fib(n: uint32): uint32
[ 272.43]             < return
[ 272.43]             > fib(n: uint32): uint32
[ 272.44]             < return
[ 272.45]            < return
[ 272.46]            > fib(n: uint32): uint32
[ 272.47]            < return
[ 272.48]           < return
[ 272.48]           > fib(n: uint32): uint32
[ 272.49]            > fib(n: uint32): uint32
[ 272.50]            < return
[ 272.51]            > fib(n: uint32): uint32
[ 272.52]            < return
[ 272.53]           < return
[ 272.53]          < return
[ 272.54]          > fib(n: uint32): uint32
[ 272.55]           > fib(n: uint32): uint32
[ 272.56]            > fib(n: uint32): uint32
[ 272.57]            < return
[ 272.58]            > fib(n: uint32): uint32
[ 272.61]            < return
[ 272.63]           < return
[ 272.63]           > fib(n: uint32): uint32
[ 272.64]           < return
[ 272.65]          < return
[ 272.66]         < return
[ 272.67]         > fib(n: uint32): uint32
[ 272.68]          > fib(n: uint32): uint32
[ 272.69]           > fib(n: uint32): uint32
[ 272.71]            > fib(n: uint32): uint32
[ 272.72]            < return
[ 272.73]            > fib(n: uint32): uint32
[ 272.74]            < return
[ 272.74]           < return
[ 272.75]           > fib(n: uint32): uint32
[ 272.76]           < return
[ 272.77]          < return
[ 272.77]          > fib(n: uint32): uint32
[ 272.79]           > fib(n: uint32): uint32
[ 272.80]           < return
[ 272.80]           > fib(n: uint32): uint32
[ 272.81]           < return
[ 272.82]          < return
[ 272.82]         < return
[ 272.83]        < return
[ 272.84]        > fib(n: uint32): uint32
[ 272.85]         > fib(n: uint32): uint32
[ 272.86]          > fib(n: uint32): uint32
[ 272.87]           > fib(n: uint32): uint32
[ 272.88]            > fib(n: uint32): uint32
[ 272.89]            < return
[ 272.90]            > fib(n: uint32): uint32
[ 272.91]            < return
[ 272.91]           < return
[ 272.92]           > fib(n: uint32): uint32
[ 272.93]           < return
[ 272.94]          < return
[ 272.96]          > fib(n: uint32): uint32
[ 272.97]           > fib(n: uint32): uint32
[ 272.98]           < return
[ 272.99]           > fib(n: uint32): uint32
[ 273.00]           < return
[ 273.02]          < return
[ 273.03]         < return
[ 273.04]         > fib(n: uint32): uint32
[ 273.05]          > fib(n: uint32): uint32
[ 273.06]           > fib(n: uint32): uint32
[ 273.06]           < return
[ 273.07]           > fib(n: uint32): uint32
[ 273.08]           < return
[ 273.09]          < return
[ 273.10]          > fib(n: uint32): uint32
[ 273.11]          < return
[ 273.11]         < return
[ 273.12]        < return
[ 273.13]       < return
[ 273.16]       > fib(n: uint32): uint32
[ 273.19]        > fib(n: uint32): uint32
[ 273.20]         > fib(n: uint32): uint32
[ 273.21]          > fib(n: uint32): uint32
[ 273.22]           > fib(n: uint32): uint32
[ 273.23]            > fib(n: uint32): uint32
[ 273.24]            < return
[ 273.25]            > fib(n: uint32): uint32
[ 273.25]            < return
[ 273.26]           < return
[ 273.27]           > fib(n: uint32): uint32
[ 273.28]           < return
[ 273.29]          < return
[ 273.29]          > fib(n: uint32): uint32
[ 273.32]           > fib(n: uint32): uint32
[ 273.33]           < return
[ 273.36]           > fib(n: uint32): uint32
[ 273.36]           < return
[ 273.37]          < return
[ 273.38]         < return
[ 273.38]         > fib(n: uint32): uint32
[ 273.41]          > fib(n: uint32): uint32
[ 273.42]           > fib(n: uint32): uint32
[ 273.45]           < return
[ 273.47]           > fib(n: uint32): uint32
[ 273.48]           < return
[ 273.49]          < return
[ 273.49]          > fib(n: uint32): uint32
[ 273.51]          < return
[ 273.52]         < return
[ 273.53]        < return
[ 273.54]        > fib(n: uint32): uint32
[ 273.55]         > fib(n: uint32): uint32
[ 273.56]          > fib(n: uint32): uint32
[ 273.57]           > fib(n: uint32): uint32
[ 273.57]           < return
[ 273.58]           > fib(n: uint32): uint32
[ 273.59]           < return
[ 273.62]          < return
[ 273.62]          > fib(n: uint32): uint32
[ 273.65]          < return
[ 273.65]         < return
[ 273.66]         > fib(n: uint32): uint32
[ 273.67]          > fib(n: uint32): uint32
[ 273.68]          < return
[ 273.69]          > fib(n: uint32): uint32
[ 273.70]          < return
[ 273.71]         < return
[ 273.71]        < return
[ 273.72]       < return
[ 273.73]      < return
[ 273.74]      > fib(n: uint32): uint32
[ 273.75]       > fib(n: uint32): uint32
[ 273.76]        > fib(n: uint32): uint32
[ 273.77]         > fib(n: uint32): uint32
[ 273.78]          > fib(n: uint32): uint32
[ 273.79]           > fib(n: uint32): uint32
[ 273.80]            > fib(n: uint32): uint32
[ 273.81]            < return
[ 273.81]            > fib(n: uint32): uint32
[ 273.82]            < return
[ 273.83]           < return
[ 273.84]           > fib(n: uint32): uint32
[ 273.85]           < return
[ 273.85]          < return
[ 273.86]          > fib(n: uint32): uint32
[ 273.87]           > fib(n: uint32): uint32
[ 273.88]           < return
[ 273.89]           > fib(n: uint32): uint32
[ 273.92]           < return
[ 273.92]          < return
[ 273.93]         < return
[ 273.94]         > fib(n: uint32): uint32
[ 273.96]          > fib(n: uint32): uint32
[ 273.97]           > fib(n: uint32): uint32
[ 274.00]           < return
[ 274.00]           > fib(n: uint32): uint32
[ 274.01]           < return
[ 274.04]          < return
[ 274.04]          > fib(n: uint32): uint32
[ 274.06]          < return
[ 274.07]         < return
[ 274.08]        < return
[ 274.09]        > fib(n: uint32): uint32
[ 274.11]         > fib(n: uint32): uint32
[ 274.12]          > fib(n: uint32): uint32
[ 274.13]           > fib(n: uint32): uint32
[ 274.14]           < return
[ 274.15]           > fib(n: uint32): uint32
[ 274.16]           < return
[ 274.17]          < return
[ 274.17]          > fib(n: uint32): uint32
[ 274.18]          < return
[ 274.19]         < return
[ 274.20]         > fib(n: uint32): uint32
[ 274.21]          > fib(n: uint32): uint32
[ 274.22]          < return
[ 274.25]          > fib(n: uint32): uint32
[ 274.26]          < return
[ 274.26]         < return
[ 274.28]        < return
[ 274.29]       < return
[ 274.30]       > fib(n: uint32): uint32
[ 274.31]        > fib(n: uint32): uint32
[ 274.32]         > fib(n: uint32): uint32
[ 274.33]          > fib(n: uint32): uint32
[ 274.34]           > fib(n: uint32): uint32
[ 274.35]           < return
[ 274.36]           > fib(n: uint32): uint32
[ 274.37]           < return
[ 274.37]          < return
[ 274.38]          > fib(n: uint32): uint32
[ 274.39]          < return
[ 274.40]         < return
[ 274.40]         > fib(n: uint32): uint32
[ 274.43]          > fib(n: uint32): uint32
[ 274.46]          < return
[ 274.46]          > fib(n: uint32): uint32
[ 274.47]          < return
[ 274.48]         < return
[ 274.49]        < return
[ 274.50]        > fib(n: uint32): uint32
[ 274.50]         > fib(n: uint32): uint32
[ 274.53]          > fib(n: uint32): uint32
[ 274.54]          < return
[ 274.55]          > fib(n: uint32): uint32
[ 274.58]          < return
[ 274.58]         < return
[ 274.59]         > fib(n: uint32): uint32
[ 274.60]         < return
[ 274.61]        < return
[ 274.62]       < return
[ 274.62]      < return
[ 274.63]     < return
[ 274.64]     > fib(n: uint32): uint32
[ 274.65]      > fib(n: uint32): uint32
[ 274.66]       > fib(n: uint32): uint32
[ 274.67]        > fib(n: uint32): uint32
[ 274.68]         > fib(n: uint32): uint32
[ 274.69]          > fib(n: uint32): uint32
[ 274.72]           > fib(n: uint32): uint32
[ 274.73]            > fib(n: uint32): uint32
[ 274.74]            < return
[ 274.75]            > fib(n: uint32): uint32
[ 274.76]            < return
[ 274.76]           < return
[ 274.77]           > fib(n: uint32): uint32
[ 274.78]           < return
[ 274.79]          < return
[ 274.80]          > fib(n: uint32): uint32
[ 274.81]           > fib(n: uint32): uint32
[ 274.82]           < return
[ 274.82]           > fib(n: uint32): uint32
[ 274.85]           < return
[ 274.86]          < return
[ 274.87]         < return
[ 274.87]         > fib(n: uint32): uint32
[ 274.88]          > fib(n: uint32): uint32
[ 274.90]           > fib(n: uint32): uint32
[ 274.91]           < return
[ 274.94]           > fib(n: uint32): uint32
[ 274.95]           < return
[ 274.97]          < return
[ 274.98]          > fib(n: uint32): uint32
[ 274.99]          < return
[ 275.00]         < return
[ 275.02]        < return
[ 275.03]        > fib(n: uint32): uint32
[ 275.04]         > fib(n: uint32): uint32
[ 275.05]          > fib(n: uint32): uint32
[ 275.06]           > fib(n: uint32): uint32
[ 275.07]           < return
[ 275.08]           > fib(n: uint32): uint32
[ 275.09]           < return
[ 275.10]          < return
[ 275.11]          > fib(n: uint32): uint32
[ 275.13]          < return
[ 275.14]         < return
[ 275.14]         > fib(n: uint32): uint32
[ 275.15]          > fib(n: uint32): uint32
[ 275.16]          < return
[ 275.17]          > fib(n: uint32): uint32
[ 275.18]          < return
[ 275.21]         < return
[ 275.24]        < return
[ 275.24]       < return
[ 275.25]       > fib(n: uint32): uint32
[ 275.26]        > fib(n: uint32): uint32
[ 275.30]         > fib(n: uint32): uint32
[ 275.31]          > fib(n: uint32): uint32
[ 275.32]           > fib(n: uint32): uint32
[ 275.33]           < return
[ 275.33]           > fib(n: uint32): uint32
[ 275.34]           < return
[ 275.35]          < return
[ 275.36]          > fib(n: uint32): uint32
[ 275.37]          < return
[ 275.39]         < return
[ 275.40]         > fib(n: uint32): uint32
[ 275.41]          > fib(n: uint32): uint32
[ 275.42]          < return
[ 275.42]          > fib(n: uint32): uint32
[ 275.43]          < return
[ 275.44]         < return
[ 275.45]        < return
[ 275.45]        > fib(n: uint32): uint32
[ 275.48]         > fib(n: uint32): uint32
[ 275.49]          > fib(n: uint32): uint32
[ 275.50]          < return
[ 275.51]          > fib(n: uint32): uint32
[ 275.51]          < return
[ 275.52]         < return
[ 275.53]         > fib(n: uint32): uint32
[ 275.55]         < return
[ 275.56]        < return
[ 275.57]       < return
[ 275.59]      < return
[ 275.60]      > fib(n: uint32): uint32
[ 275.61]       > fib(n: uint32): uint32
[ 275.62]        > fib(n: uint32): uint32
[ 275.63]         > fib(n: uint32): uint32
[ 275.64]          > fib(n: uint32): uint32
[ 275.66]           > fib(n: uint32): uint32
[ 275.69]           < return
[ 275.70]           > fib(n: uint32): uint32
[ 275.70]           < return
[ 275.71]          < return
[ 275.72]          > fib(n: uint32): uint32
[ 275.73]          < return
[ 275.75]         < return
[ 275.76]         > fib(n: uint32): uint32
[ 275.77]          > fib(n: uint32): uint32
[ 275.78]          < return
[ 275.79]          > fib(n: uint32): uint32
[ 275.80]          < return
[ 275.81]         < return
[ 275.81]        < return
[ 275.82]        > fib(n: uint32): uint32
[ 275.83]         > fib(n: uint32): uint32
[ 275.84]          > fib(n: uint32): uint32
[ 275.85]          < return
[ 275.86]          > fib(n: uint32): uint32
[ 275.88]          < return
[ 275.89]         < return
[ 275.90]         > fib(n: uint32): uint32
[ 275.91]         < return
[ 275.91]        < return
[ 275.92]       < return
[ 275.93]       > fib(n: uint32): uint32
[ 275.94]        > fib(n: uint32): uint32
[ 275.95]         > fib(n: uint32): uint32
[ 275.96]          > fib(n: uint32): uint32
[ 275.97]          < return
[ 275.98]          > fib(n: uint32): uint32
[ 275.99]          < return
[ 276.00]         < return
[ 276.00]         > fib(n: uint32): uint32
[ 276.01]         < return
[ 276.02]        < return
[ 276.03]        > fib(n: uint32): uint32
[ 276.04]         > fib(n: uint32): uint32
[ 276.05]         < return
[ 276.06]         > fib(n: uint32): uint32
[ 276.06]         < return
[ 276.07]        < return
[ 276.08]       < return
[ 276.09]      < return
[ 276.09]     < return
[ 276.10]    < return
[ 276.11]    > fib(n: uint32): uint32
[ 276.12]     > fib(n: uint32): uint32
[ 276.13]      > fib(n: uint32): uint32
[ 276.14]       > fib(n: uint32): uint32
[ 276.15]        > fib(n: uint32): uint32
[ 276.16]         > fib(n: uint32): uint32
[ 276.18]          > fib(n: uint32): uint32
[ 276.19]           > fib(n: uint32): uint32
[ 276.20]            > fib(n: uint32): uint32
[ 276.21]            < return
[ 276.21]            > fib(n: uint32): uint32
[ 276.23]            < return
[ 276.23]           < return
[ 276.24]           > fib(n: uint32): uint32
[ 276.25]           < return
[ 276.26]          < return
[ 276.26]          > fib(n: uint32): uint32
[ 276.28]           > fib(n: uint32): uint32
[ 276.29]           < return
[ 276.29]           > fib(n: uint32): uint32
[ 276.30]           < return
[ 276.31]          < return
[ 276.32]         < return
[ 276.32]         > fib(n: uint32): uint32
[ 276.33]          > fib(n: uint32): uint32
[ 276.35]           > fib(n: uint32): uint32
[ 276.36]           < return
[ 276.36]           > fib(n: uint32): uint32
[ 276.37]           < return
[ 276.38]          < return
[ 276.39]          > fib(n: uint32): uint32
[ 276.40]          < return
[ 276.40]         < return
[ 276.41]        < return
[ 276.42]        > fib(n: uint32): uint32
[ 276.43]         > fib(n: uint32): uint32
[ 276.44]          > fib(n: uint32): uint32
[ 276.45]           > fib(n: uint32): uint32
[ 276.46]           < return
[ 276.47]           > fib(n: uint32): uint32
[ 276.48]           < return
[ 276.49]          < return
[ 276.49]          > fib(n: uint32): uint32
[ 276.50]          < return
[ 276.51]         < return
[ 276.52]         > fib(n: uint32): uint32
[ 276.53]          > fib(n: uint32): uint32
[ 276.54]          < return
[ 276.55]          > fib(n: uint32): uint32
[ 276.56]          < return
[ 276.56]         < return
[ 276.57]        < return
[ 276.58]       < return
[ 276.58]       > fib(n: uint32): uint32
[ 276.60]        > fib(n: uint32): uint32
[ 276.61]         > fib(n: uint32): uint32
[ 276.62]          > fib(n: uint32): uint32
[ 276.63]           > fib(n: uint32): uint32
[ 276.64]           < return
[ 276.64]           > fib(n: uint32): uint32
[ 276.65]           < return
[ 276.66]          < return
[ 276.67]          > fib(n: uint32): uint32
[ 276.68]          < return
[ 276.69]         < return
[ 276.69]         > fib(n: uint32): uint32
[ 276.70]          > fib(n: uint32): uint32
[ 276.71]          < return
[ 276.72]          > fib(n: uint32): uint32
[ 276.73]          < return
[ 276.74]         < return
[ 276.74]        < return
[ 276.75]        > fib(n: uint32): uint32
[ 276.76]         > fib(n: uint32): uint32
[ 276.77]          > fib(n: uint32): uint32
[ 276.78]          < return
[ 276.79]          > fib(n: uint32): uint32
[ 276.80]          < return
[ 276.81]         < return
[ 276.83]         > fib(n: uint32): uint32
[ 276.84]         < return
[ 276.85]        < return
[ 276.86]       < return
[ 276.86]      < return
[ 276.87]      > fib(n: uint32): uint32
[ 276.90]       > fib(n: uint32): uint32
[ 276.91]        > fib(n: uint32): uint32
[ 276.92]         > fib(n: uint32): uint32
[ 276.93]          > fib(n: uint32): uint32
[ 276.94]           > fib(n: uint32): uint32
[ 276.95]           < return
[ 276.96]           > fib(n: uint32): uint32
[ 276.97]           < return
[ 276.97]          < return
[ 276.98]          > fib(n: uint32): uint32
[ 276.99]          < return
[ 277.00]         < return
[ 277.01]         > fib(n: uint32): uint32
[ 277.02]          > fib(n: uint32): uint32
[ 277.03]          < return
[ 277.03]          > fib(n: uint32): uint32
[ 277.04]          < return
[ 277.05]         < return
[ 277.06]        < return
[ 277.06]        > fib(n: uint32): uint32
[ 277.08]         > fib(n: uint32): uint32
[ 277.09]          > fib(n: uint32): uint32
[ 277.10]          < return
[ 277.10]          > fib(n: uint32): uint32
[ 277.11]          < return
[ 277.12]         < return
[ 277.13]         > fib(n: uint32): uint32
[ 277.14]         < return
[ 277.15]        < return
[ 277.16]       < return
[ 277.16]       > fib(n: uint32): uint32
[ 277.17]        > fib(n: uint32): uint32
[ 277.19]         > fib(n: uint32): uint32
[ 277.19]          > fib(n: uint32): uint32
[ 277.21]          < return
[ 277.22]          > fib(n: uint32): uint32
[ 277.23]          < return
[ 277.24]         < return
[ 277.25]         > fib(n: uint32): uint32
[ 277.26]         < return
[ 277.26]        < return
[ 277.27]        > fib(n: uint32): uint32
[ 277.29]         > fib(n: uint32): uint32
[ 277.30]         < return
[ 277.30]         > fib(n: uint32): uint32
[ 277.31]         < return
[ 277.32]        < return
[ 277.33]       < return
[ 277.34]      < return
[ 277.34]     < return
[ 277.35]     > fib(n: uint32): uint32
[ 277.36]      > fib(n: uint32): uint32
[ 277.37]       > fib(n: uint32): uint32
[ 277.38]        > fib(n: uint32): uint32
[ 277.39]         > fib(n: uint32): uint32
[ 277.40]          > fib(n: uint32): uint32
[ 277.42]           > fib(n: uint32): uint32
[ 277.43]           < return
[ 277.44]           > fib(n: uint32): uint32
[ 277.46]           < return
[ 277.47]          < return
[ 277.48]          > fib(n: uint32): uint32
[ 277.49]          < return
[ 277.50]         < return
[ 277.50]         > fib(n: uint32): uint32
[ 277.51]          > fib(n: uint32): uint32
[ 277.54]          < return
[ 277.54]          > fib(n: uint32): uint32
[ 277.55]          < return
[ 277.56]         < return
[ 277.57]        < return
[ 277.58]        > fib(n: uint32): uint32
[ 277.59]         > fib(n: uint32): uint32
[ 277.62]          > fib(n: uint32): uint32
[ 277.63]          < return
[ 277.63]          > fib(n: uint32): uint32
[ 277.64]          < return
[ 277.65]         < return
[ 277.68]         > fib(n: uint32): uint32
[ 277.69]         < return
[ 277.70]        < return
[ 277.71]       < return
[ 277.72]       > fib(n: uint32): uint32
[ 277.75]        > fib(n: uint32): uint32
[ 277.76]         > fib(n: uint32): uint32
[ 277.78]          > fib(n: uint32): uint32
[ 277.80]          < return
[ 277.81]          > fib(n: uint32): uint32
[ 277.82]          < return
[ 277.83]         < return
[ 277.84]         > fib(n: uint32): uint32
[ 277.85]         < return
[ 277.85]        < return
[ 277.86]        > fib(n: uint32): uint32
[ 277.87]         > fib(n: uint32): uint32
[ 277.88]         < return
[ 277.89]         > fib(n: uint32): uint32
[ 277.90]         < return
[ 277.91]        < return
[ 277.92]       < return
[ 277.92]      < return
[ 277.93]      > fib(n: uint32): uint32
[ 277.94]       > fib(n: uint32): uint32
[ 277.95]        > fib(n: uint32): uint32
[ 277.96]         > fib(n: uint32): uint32
[ 277.97]          > fib(n: uint32): uint32
[ 277.98]          < return
[ 277.99]          > fib(n: uint32): uint32
[ 278.00]          < return
[ 278.01]         < return
[ 278.02]         > fib(n: uint32): uint32
[ 278.03]         < return
[ 278.03]        < return
[ 278.04]        > fib(n: uint32): uint32
[ 278.05]         > fib(n: uint32): uint32
[ 278.06]         < return
[ 278.07]         > fib(n: uint32): uint32
[ 278.08]         < return
[ 278.09]        < return
[ 278.10]       < return
[ 278.10]       > fib(n: uint32): uint32
[ 278.12]        > fib(n: uint32): uint32
[ 278.13]         > fib(n: uint32): uint32
[ 278.14]         < return
[ 278.14]         > fib(n: uint32): uint32
[ 278.15]         < return
[ 278.16]        < return
[ 278.17]        > fib(n: uint32): uint32
[ 278.18]        < return
[ 278.19]       < return
[ 278.20]      < return
[ 278.21]     < return
[ 278.21]    < return
[ 278.22]   < return
[ 278.23]  < return
[ 278.27]  > typename.name(type: typename): .cstr
[ 278.29]  < return
[ 278.30]  > typename.file(type: typename): .cstr
[ 278.31]  < return
[ 278.32]  > typename.line(type: typename): int32
[ 278.33]  < return
[ 278.34]  > typename.base(type: typename): typename
[ 278.35]  < return
[ 278.36]  > typename.name(type: typename): .cstr
[ 278.37]  < return
[ 278.38]  > typename.file(type: typename): .cstr
[ 278.39]  < return
[ 278.39]  > typename.line(type: typename): int32
[ 278.40]  < return
[ 278.41]  > typename.base(type: typename): typename
[ 278.42]  < return
[ 278.43]  > typename.base(type: typename): typename
[ 278.44]  < return
[ 278.49]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.50]  < return
[ 278.51]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.53]  < return
[ 278.56]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.58]  < return
[ 278.59]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.60]  < return
[ 278.61]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.62]  < return
[ 278.63]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.63]  < return
[ 278.64]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.65]  < return
[ 278.66]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.67]  < return
[ 278.68]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 278.69]  < return
[ 278.70]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.70]  < return
[ 278.73]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.74]  < return
[ 278.75]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 278.77]  < return
[ 278.78]  > float64.sin(x: float64): float64
[ 278.83]  < return
[ 278.83]  > float64.cos(x: float64): float64
[ 278.86]  < return
[ 278.87]  > float64.tan(x: float64): float64
[ 278.88]  < return
[ 278.89]  > float64.log(x: float64): float64
[ 278.90]  < return
[ 278.91]  > float64.exp(x: float64): float64
[ 278.92]  < return
[ 278.93]  > float64.pow(x: float64, y: float64): float64
[ 278.94]  < return
[ 278.95]  > float64.sqrt(x: float64): float64
[ 278.96]  < return
[ 278.97]  > float64.atan2(x: float64, y: float64): float64
[ 278.98]  < return
[ 278.99]  > float32.sin(x: float32): float32
[ 279.00]  < return
[ 279.00]  > float32.cos(x: float32): float32
[ 279.01]  < return
[ 279.02]  > float32.tan(x: float32): float32
[ 279.03]  < return
[ 279.04]  > float32.log(x: float32): float32
[ 279.05]  < return
[ 279.06]  > float32.exp(x: float32): float32
[ 279.07]  < return
[ 279.08]  > float32.pow(x: float32, y: float32): float32
[ 279.08]  < return
[ 279.09]  > float32.sqrt(x: float32): float32
[ 279.10]  < return
[ 279.11]  > float32.atan2(x: float32, y: float32): float32
[ 279.12]  < return
[ 279.13]  > uint32.pop(value: int32): int32
[ 279.14]  < return
[ 279.15]  > uint32.swap(value: int32): int32
[ 279.15]  < return
[ 279.16]  > uint32.bsr(value: int32): int32
[ 279.17]  < return
[ 279.18]  > uint32.bsf(value: int32): int32
[ 279.19]  < return
[ 279.20]  > uint32.hib(value: int32): int32
[ 279.23]  < return
[ 279.24]  > uint32.lob(value: int32): int32
[ 279.24]  < return
[ 279.27]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 279.28]  < return
[ 279.29]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 279.29]  < return
[ 279.30]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 279.31]  < return
[ 279.32]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 279.33]  < return
[ 279.34]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.35]  < return
[ 279.36]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.37]  < return
[ 279.38]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.39]  < return
[ 279.39]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.40]  < return
[ 279.41]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 279.42]  < return
[ 279.43]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 279.44]  < return
[ 279.46]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.47]  < return
[ 279.48]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.49]  < return
[ 279.50]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.51]  < return
[ 279.52]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 279.54]  < return
[ 279.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 279.60]  < return
[ 279.61]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 279.63]  < return
[ 279.64]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 279.65]  < return
[ 279.68]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 279.69]  < return
[ 279.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 279.74]  < return
[ 279.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 279.77]  < return
[ 279.78]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 279.79]   > noError(ptr: pointer): void
[ 279.80]   < return
[ 279.80]   > halt(): void
[ 279.81]   < return
[ 279.82]  < return
[ 279.82]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 279.84]  < return
[ 279.85]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 279.87]   > stackOverflow(ptr: pointer): void
[ 279.88]    > stackOverflow(ptr: pointer): void
[ 279.89]     > stackOverflow(ptr: pointer): void
[ 279.90]      > stackOverflow(ptr: pointer): void
[ 279.93]       > stackOverflow(ptr: pointer): void
[ 279.94]        > stackOverflow(ptr: pointer): void
[ 279.94]         > stackOverflow(ptr: pointer): void
[ 279.95]          > stackOverflow(ptr: pointer): void
[ 279.96]           > stackOverflow(ptr: pointer): void
[ 279.97]            > stackOverflow(ptr: pointer): void
[ 279.98]             > stackOverflow(ptr: pointer): void
[ 279.99]              > stackOverflow(ptr: pointer): void
[ 280.00]               > stackOverflow(ptr: pointer): void
[ 280.01]                > stackOverflow(ptr: pointer): void
[ 280.02]                 > stackOverflow(ptr: pointer): void
[ 280.03]                  > stackOverflow(ptr: pointer): void
[ 280.04]                   > stackOverflow(ptr: pointer): void
[ 280.05]                    > stackOverflow(ptr: pointer): void
[ 280.06]                     > stackOverflow(ptr: pointer): void
[ 280.07]                      > stackOverflow(ptr: pointer): void
[ 280.08]                       > stackOverflow(ptr: pointer): void
[ 280.09]                        > stackOverflow(ptr: pointer): void
[ 280.10]                         > stackOverflow(ptr: pointer): void
[ 280.11]                          > stackOverflow(ptr: pointer): void
[ 280.12]                           > stackOverflow(ptr: pointer): void
[ 280.13]                            > stackOverflow(ptr: pointer): void
[ 280.14]                             > stackOverflow(ptr: pointer): void
[ 280.15]                              > stackOverflow(ptr: pointer): void
[ 280.15]                               > stackOverflow(ptr: pointer): void
[ 280.17]                                > stackOverflow(ptr: pointer): void
[ 280.18]                                 > stackOverflow(ptr: pointer): void
[ 280.19]                                  > stackOverflow(ptr: pointer): void
[ 280.21]                                   > stackOverflow(ptr: pointer): void
[ 280.22]                                    > stackOverflow(ptr: pointer): void
[ 280.23]                                     > stackOverflow(ptr: pointer): void
[ 280.25]                                      > stackOverflow(ptr: pointer): void
[ 280.26]                                       > stackOverflow(ptr: pointer): void
[ 280.27]                                        > stackOverflow(ptr: pointer): void
[ 280.28]                                         > stackOverflow(ptr: pointer): void
[ 280.29]                                          > stackOverflow(ptr: pointer): void
[ 280.30]                                           > stackOverflow(ptr: pointer): void
[ 280.31]                                            > stackOverflow(ptr: pointer): void
[ 280.32]                                             > stackOverflow(ptr: pointer): void
[ 280.34]                                              > stackOverflow(ptr: pointer): void
[ 280.35]                                               > stackOverflow(ptr: pointer): void
[ 280.36]                                                > stackOverflow(ptr: pointer): void
[ 280.39]                                                 > stackOverflow(ptr: pointer): void
[ 280.40]                                                  > stackOverflow(ptr: pointer): void
[ 280.41]                                                   > stackOverflow(ptr: pointer): void
[ 280.42]                                                    > stackOverflow(ptr: pointer): void
[ 280.43]                                                     > stackOverflow(ptr: pointer): void
[ 280.44]                                                      > stackOverflow(ptr: pointer): void
[ 280.45]                                                       > stackOverflow(ptr: pointer): void
[ 280.46]                                                        > stackOverflow(ptr: pointer): void
[ 280.47]                                                         > stackOverflow(ptr: pointer): void
[ 280.48]                                                          > stackOverflow(ptr: pointer): void
[ 280.49]                                                           > stackOverflow(ptr: pointer): void
[ 280.50]                                                            > stackOverflow(ptr: pointer): void
[ 280.50]                                                             > stackOverflow(ptr: pointer): void
[ 280.51]                                                              > stackOverflow(ptr: pointer): void
[ 280.52]                                                               > stackOverflow(ptr: pointer): void
[ 280.55]                                                                > stackOverflow(ptr: pointer): void
[ 280.56]                                                                 > stackOverflow(ptr: pointer): void
[ 280.57]                                                                  > stackOverflow(ptr: pointer): void
[ 280.58]                                                                  < return
[ 280.58]                                                                 < return
[ 280.59]                                                                < return
[ 280.60]                                                               < return
[ 280.60]                                                              < return
[ 280.61]                                                             < return
[ 280.62]                                                            < return
[ 280.62]                                                           < return
[ 280.63]                                                          < return
[ 280.64]                                                         < return
[ 280.64]                                                        < return
[ 280.67]                                                       < return
[ 280.67]                                                      < return
[ 280.68]                                                     < return
[ 280.69]                                                    < return
[ 280.69]                                                   < return
[ 280.70]                                                  < return
[ 280.71]                                                 < return
[ 280.71]                                                < return
[ 280.72]                                               < return
[ 280.73]                                              < return
[ 280.73]                                             < return
[ 280.74]                                            < return
[ 280.75]                                           < return
[ 280.75]                                          < return
[ 280.76]                                         < return
[ 280.77]                                        < return
[ 280.77]                                       < return
[ 280.78]                                      < return
[ 280.79]                                     < return
[ 280.79]                                    < return
[ 280.80]                                   < return
[ 280.81]                                  < return
[ 280.82]                                 < return
[ 280.82]                                < return
[ 280.83]                               < return
[ 280.84]                              < return
[ 280.84]                             < return
[ 280.85]                            < return
[ 280.86]                           < return
[ 280.86]                          < return
[ 280.87]                         < return
[ 280.88]                        < return
[ 280.88]                       < return
[ 280.89]                      < return
[ 280.90]                     < return
[ 280.90]                    < return
[ 280.91]                   < return
[ 280.92]                  < return
[ 280.92]                 < return
[ 280.93]                < return
[ 280.94]               < return
[ 280.94]              < return
[ 280.95]             < return
[ 280.96]            < return
[ 280.96]           < return
[ 280.97]          < return
[ 280.98]         < return
[ 280.99]        < return
[ 280.99]       < return
[ 281.00]      < return
[ 281.00]     < return
[ 281.01]    < return
[ 281.02]   < return
[ 281.02]  < return
[ 281.03]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 281.04]   > divisionByZero(args: pointer): void
[ 281.05]   < return
[ 281.06]  < return
[ 281.07]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 281.08]   > invalidInstruction(args: pointer): void
[ 281.09]   < return
[ 281.09]  < return
[ 281.10]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 281.11]   > invalidMemoryAccess(args: pointer): void
[ 281.12]   < return
[ 281.13]  < return
[ 281.14]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 281.14]   > abortExecution(args: pointer): void
[ 281.16]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 281.25]    < return
[ 281.26]   < return
[ 281.26]  < return
[ 281.37]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 281.38]  < return
[ 281.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 281.47]  < return
[ 281.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 281.58]  < return
[ 281.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 281.62]  < return
[ 281.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 281.66]  < return
[ 281.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 281.70]  < return
[ 281.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 281.73]  < return
[ 281.76]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.76]  < return
[ 281.78]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.79]  < return
[ 281.80]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.81]  < return
[ 281.82]  > lenSlice(values: int64[]): int32
[ 281.83]  < return
[ 281.84]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.85]  < return
[ 281.86]  > lenSlice(values: int64[]): int32
[ 281.87]  < return
[ 281.88]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.89]  < return
[ 281.90]  > lenSlice(values: int64[]): int32
[ 281.91]  < return
[ 281.92]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.93]  < return
[ 281.94]  > lenSlice(values: int64[]): int32
[ 281.95]  < return
[ 281.96]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 281.97]  < return
[ 281.99]  > lenSlice(values: int64[]): int32
[ 282.00]  < return
[ 282.01]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 282.02]  < return
[ 282.07]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.08]  < return
[ 282.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.11]  < return
[ 282.12]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.13]  < return
[ 282.14]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.16]  < return
[ 282.17]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.18]  < return
[ 282.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.21]  < return
[ 282.22]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.24]  < return
[ 282.25]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.26]  < return
[ 282.31]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.32]  < return
[ 282.34]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.35]  < return
[ 282.36]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.39]  < return
[ 282.40]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.41]  < return
[ 282.43]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.44]  < return
[ 282.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.46]  < return
[ 282.48]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.49]  < return
[ 282.50]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.51]  < return
[ 282.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.57]  < return
[ 282.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.60]  < return
[ 282.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.62]  < return
[ 282.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.70]  < return
[ 282.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.73]  < return
[ 282.76]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.77]  < return
[ 282.79]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.80]  < return
[ 282.81]  > nthSlice(idx: int32, values: int64[]): int64
[ 282.82]  < return
[ 282.87]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.88]  < return
[ 282.89]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.90]  < return
[ 282.92]  > nthFixed(idx: int32, values: int64[7]): int64
[ 282.93]  < return
[ 282.94]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.95]  < return
[ 282.96]  > nthArray(idx: int32, values: int64[*]): int64
[ 282.97]  < return
[ 283.01]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.02]  < return
[ 283.03]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.06]  < return
[ 283.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.10]  < return
[ 283.18]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.19]  < return
[ 283.20]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.21]  < return
[ 283.23]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.24]  < return
[ 283.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.26]  < return
[ 283.27]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.30]  < return
[ 283.31]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.32]  < return
[ 283.34]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.35]  < return
[ 283.36]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.37]  < return
[ 283.42]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.43]  < return
[ 283.44]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.45]  < return
[ 283.46]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.48]  < return
[ 283.49]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.50]  < return
[ 283.52]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.53]  < return
[ 283.54]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.55]  < return
[ 283.56]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.58]  < return
[ 283.59]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.60]  < return
[ 283.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.65]  < return
[ 283.67]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.68]  < return
[ 283.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 283.70]  < return
[ 283.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.73]  < return
[ 283.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.75]  < return
[ 283.76]  > nthArray(idx: int32, values: int64[*]): int64
[ 283.77]  < return
[ 283.79]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.80]  < return
[ 283.81]  > nthSlice(idx: int32, values: int64[]): int64
[ 283.82]  < return
[ 283.88]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 283.89]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:69: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 283.98]   < return
[ 283.98]  < return
[ 283.99]  > customPrint(this: RecordMethodTest): void
[ 284.00]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:60: debug: override
	test/lang/method.ci:70: customPrint(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 284.08]   < return
[ 284.09]  < return
[ 284.10]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 284.11]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:73: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 284.19]   < return
[ 284.19]  < return
[ 284.20]  > print(this: RecordMethodTest): void
[ 284.21]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:84: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 284.29]   < return
[ 284.30]  < return
[ 284.31]  > printStatic(this: RecordMethodTest): void
[ 284.32]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:80: debug: extension
	test/lang/method.ci:85: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 284.41]   < return
[ 284.43]  < return
[ 284.44]  > print(this: RecordMethodTest): void
[ 284.45]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:86: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 284.57]   < return
[ 284.58]  < return
[ 284.59]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 284.60]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:89: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 284.69]   < return
[ 284.70]  < return
[ 284.71]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 284.72]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:90: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 284.80]   < return
[ 284.80]  < return
[ 284.81]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 284.82]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:91: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 284.90]   < return
[ 284.91]  < return
[ 285.90]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 285.93]  < return
[ 285.95]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 285.97]  < return
[ 285.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 286.03]  < return
[ 286.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 286.08]  < return
[ 286.10]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 286.14]  < return
[ 286.16]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 286.18]  < return
[ 286.20]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 286.23]  < return
[ 286.25]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 286.26]  < return
[ 286.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 286.31]  < return
[ 286.34]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 286.36]  < return
[ 286.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 286.43]  < return
[ 286.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 286.47]  < return
[ 286.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 286.55]  < return
[ 286.58]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 286.60]  < return
[ 286.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 286.65]  < return
[ 286.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 286.69]  < return
[ 286.72]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 286.74]  < return
[ 286.77]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 286.79]  < return
[ 286.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 286.84]  < return
[ 286.86]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 286.88]  < return
[ 286.91]  > Math.floor(x: float64): float64
[ 286.92]   > Math.modf(x: float64, intPart: float64): float64
[ 286.93]   < return
[ 286.93]  < return
[ 286.94]  > Math.floor(x: float64): float64
[ 286.95]   > Math.modf(x: float64, intPart: float64): float64
[ 286.96]   < return
[ 286.97]  < return
[ 286.98]  > Math.floor(x: float64): float64
[ 286.99]   > Math.modf(x: float64, intPart: float64): float64
[ 287.00]   < return
[ 287.00]  < return
[ 287.01]  > Math.floor(x: float64): float64
[ 287.02]   > Math.modf(x: float64, intPart: float64): float64
[ 287.03]    > Math.modf(x: float64, intPart: float64): float64
[ 287.04]    < return
[ 287.04]   < return
[ 287.05]  < return
[ 287.06]  > Math.floor(x: float64): float64
[ 287.07]   > Math.modf(x: float64, intPart: float64): float64
[ 287.08]    > Math.modf(x: float64, intPart: float64): float64
[ 287.09]    < return
[ 287.10]   < return
[ 287.11]  < return
[ 287.12]  > Math.floor(x: float64): float64
[ 287.13]   > Math.modf(x: float64, intPart: float64): float64
[ 287.14]    > Math.modf(x: float64, intPart: float64): float64
[ 287.15]    < return
[ 287.15]   < return
[ 287.16]  < return
[ 287.17]  > Math.sign(x: float64): int32
[ 287.18]  < return
[ 287.19]  > Math.sign(x: float64): int32
[ 287.20]  < return
[ 287.21]  > Math.sign(x: float64): int32
[ 287.22]  < return
[ 287.23]  > Math.sign(x: float32): int32
[ 287.24]  < return
[ 287.25]  > Math.sign(x: float32): int32
[ 287.26]  < return
[ 287.27]  > Math.sign(x: float32): int32
[ 287.28]  < return
[ 287.30]  > Math.abs(x: float64): float64
[ 287.30]  < return
[ 287.31]  > Math.abs(x: float64): float64
[ 287.32]  < return
[ 287.33]  > Math.abs(x: float64): float64
[ 287.34]  < return
[ 287.35]  > Math.abs(x: float32): float32
[ 287.36]  < return
[ 287.37]  > Math.abs(x: float32): float32
[ 287.38]  < return
[ 287.39]  > Math.abs(x: float32): float32
[ 287.40]  < return
[ 287.41]  > Math.min(a: float32, b: float32): float32
[ 287.42]  < return
[ 287.43]  > Math.max(a: float32, b: float32): float32
[ 287.44]  < return
[ 287.46]  > Math.min(a: float64, b: float64): float64
[ 287.46]  < return
[ 287.48]  > Math.max(a: float64, b: float64): float64
[ 287.48]  < return
[ 287.50]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 287.51]  < return
[ 287.52]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 287.53]  < return
[ 287.59]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 287.60]  < return
[ 287.63]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 287.64]  < return
[ 287.66]  > Math.min(data: float64[]): float64
[ 287.67]  < return
[ 287.69]  > Math.min(data: float64[]): float64
[ 287.73]  < return
[ 287.75]  > Math.max(data: float64[]): float64
[ 287.76]  < return
[ 287.79]  > Math.max(data: float64[]): float64
[ 287.83]  < return
[ 287.85]  > Math.sum(data: float64[]): float64
[ 287.86]  < return
[ 287.88]  > Math.sum(data: float64[]): float64
[ 287.91]  < return
[ 287.92]  > Math.sum(data: float64[]): float64
[ 287.94]  < return
[ 287.97]  > Math.sum(data: float64[]): float64
[ 288.01]  < return
[ 288.03]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 288.04]  < return
[ 288.10]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 288.13]  < return
[ 288.15]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 288.18]  < return
[ 288.20]  > Math.sinCos(arg: float64, quad: int32): float64
[ 288.23]  < return
[ 288.24]  > Math.abs(x: float64): float64
[ 288.25]  < return
[ 288.26]  > Math.sinCos(arg: float64, quad: int32): float64
[ 288.29]  < return
[ 288.30]  > Math.tan(arg: float64): float64
[ 288.31]   > Math.modf(x: float64, intPart: float64): float64
[ 288.32]   < return
[ 288.35]  < return
[ 288.36]  > Math.sinh(x: float64): float64
[ 288.37]   > float64.exp(x: float64): float64
[ 288.38]   < return
[ 288.39]   > float64.exp(x: float64): float64
[ 288.40]   < return
[ 288.41]  < return
[ 288.42]  > Math.cosh(x: float64): float64
[ 288.43]   > float64.exp(x: float64): float64
[ 288.44]   < return
[ 288.44]   > float64.exp(x: float64): float64
[ 288.45]   < return
[ 288.46]  < return
[ 288.47]  > Math.asin(x: float64): float64
[ 288.48]   > float64.sqrt(x: float64): float64
[ 288.49]   < return
[ 288.50]   > float64.atan2(x: float64, y: float64): float64
[ 288.50]   < return
[ 288.51]  < return
[ 288.53]  > Math.asin(x: float64): float64
[ 288.54]   > float64.sqrt(x: float64): float64
[ 288.55]   < return
[ 288.55]   > float64.atan2(x: float64, y: float64): float64
[ 288.56]   < return
[ 288.57]  < return
[ 288.58]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 288.59]  < return
[ 288.61]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 288.62]  < return
[ 288.63]  > halt(): void
[ 288.64]  < return
[ 288.64] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:39: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:46: Math.floor: function(<Math.floor>)
lib/std/math.ci:58: Math.sign: function(<Math.sign>)
lib/std/math.ci:67: Math.sign: function(<Math.sign>)
lib/std/math.ci:83: Math.abs: function(<Math.abs>)
lib/std/math.ci:89: Math.abs: function(<Math.abs>)
lib/std/math.ci:101: Math.min: function(<Math.min>)
lib/std/math.ci:107: Math.min: function(<Math.min>)
lib/std/math.ci:119: Math.max: function(<Math.max>)
lib/std/math.ci:125: Math.max: function(<Math.max>)
lib/std/math.ci:137: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:146: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:172: Math.min: function(<Math.min>)
lib/std/math.ci:184: Math.max: function(<Math.max>)
lib/std/math.ci:197: Math.sum: function(<Math.sum>)
lib/std/math.ci:215: Math.eval: function(<Math.eval>)
lib/std/math.ci:223: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:236: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:250: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:307: Math.tan: function(<Math.tan>)
lib/std/math.ci:364: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:403: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:419: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
lib/vec/vec2d.ci:3: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:8: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:3: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:21: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:3: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:13: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:25: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:33: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(136)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(195424)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(195152)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2472)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(136)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(5)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(6)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 51,
	constant: 52
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 61,
	constant: 62
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 6,
	constant: 7,
	memberInit: 8,
	constantInit: 9,
	memberRec: {
		member: 61,
		constant: 62
	},
	constantRec: {
		member: 71,
		constant: 72
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:12: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:26: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:31: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.print: function(<RecordMethodTest.print>)
test/lang/method.ci:44: RecordMethodTest.printStatic: function(<RecordMethodTest.printStatic>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:49: globalFunction: function(<globalFunction>)
test/lang/method.ci:53: recordMethodTest: RecordMethodTest({
	abstractMethod: <RecordMethodTest.staticMethod>,
	delegateMethod: <globalFunction>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <RecordMethodTest.print>
})
test/lang/method.ci:59: customPrint: function(<customPrint>)
test/lang/method.ci:63: recordMethodTestCustomPrint: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <customPrint>
})
test/lang/method.ci:75: print: function(<print>)
test/lang/method.ci:79: printStatic: function(<printStatic>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_0f: float64(0.000000)
test/stdc/test.math.ci:36: testMathSmooth_0F: float64(0.000000)
test/stdc/test.math.ci:37: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:38: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:40: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:42: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:43: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:45: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:46: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:47: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:48: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:50: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:51: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:52: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:53: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:54: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:55: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:56: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:57: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:59: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:61: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:62: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:63: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:65: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:66: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:69: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:70: testMathCmp_f64: bool(1)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 300320(293.3 Kb)
memory[heap] @049520; size: 1272286(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 285016(278.3 Kb)
memory[code] @000000; size: 14978(14.6 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @049538; size: 1272240(1.2 Mb)

---------- Profile functions: 80/116, coverage: 68.97%
::[.0052b0, .0052b0): exec(2), time(12 / 0.012 ms): halt(): void
::[.0055a8, .0055a8): exec(3), time(26 / 0.026 ms): typename.base(type: typename): typename
::[.005778, .005778): exec(2), time(19 / 0.019 ms): typename.file(type: typename): .cstr
::[.005948, .005948): exec(2), time(18 / 0.018 ms): typename.line(type: typename): int32
::[.005b18, .005b18): exec(2), time(26 / 0.026 ms): typename.name(type: typename): .cstr
::[.0061f0, .0061f0): exec(40), time(1735 / 1.735 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0069f0, .0069f0): exec(7), time(1434 / 1.434 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.006c50, .006c50): exec(8), time(89 / 0.089 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.006f40, .006f40): exec(2), time(18 / 0.018 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007228, .007228): exec(2), time(19 / 0.019 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.007508, .007508): exec(1), time(9 / 0.009 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.007770, .007770): exec(0), time(0 / 0.000 ms): System.exit(code: int32): void
::[.007948, .007948): exec(0), time(0 / 0.000 ms): System.srand(seed: int32): void
::[.007a90, .007a90): exec(0), time(0 / 0.000 ms): System.rand(): int32
::[.007bd8, .007bd8): exec(0), time(0 / 0.000 ms): System.time(): int32
::[.007d20, .007d20): exec(0), time(0 / 0.000 ms): System.clock(): int32
::[.007e68, .007e68): exec(0), time(0 / 0.000 ms): System.millis(): int64
::[.008038, .008038): exec(0), time(0 / 0.000 ms): System.sleep(millis: int64): void
::[.008328, .008328): exec(7), time(86 / 0.086 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.008608, .008608): exec(7), time(73 / 0.073 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0087d8, .0087d8): exec(1), time(8 / 0.008 ms): uint32.pop(value: int32): int32
::[.0089a8, .0089a8): exec(1), time(8 / 0.008 ms): uint32.swap(value: int32): int32
::[.008b78, .008b78): exec(1), time(8 / 0.008 ms): uint32.bsr(value: int32): int32
::[.008d48, .008d48): exec(1), time(8 / 0.008 ms): uint32.bsf(value: int32): int32
::[.008f18, .008f18): exec(1), time(30 / 0.030 ms): uint32.hib(value: int32): int32
::[.0090e8, .0090e8): exec(1), time(8 / 0.008 ms): uint32.lob(value: int32): int32
::[.0093c0, .0093c0): exec(1), time(9 / 0.009 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.009698, .009698): exec(1), time(8 / 0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.009870, .009870): exec(1), time(8 / 0.008 ms): float32.sin(x: float32): float32
::[.009a40, .009a40): exec(1), time(8 / 0.008 ms): float32.cos(x: float32): float32
::[.009c10, .009c10): exec(1), time(8 / 0.008 ms): float32.tan(x: float32): float32
::[.009de0, .009de0): exec(1), time(8 / 0.008 ms): float32.log(x: float32): float32
::[.009fb0, .009fb0): exec(1), time(8 / 0.008 ms): float32.exp(x: float32): float32
::[.00a210, .00a210): exec(1), time(9 / 0.009 ms): float32.pow(x: float32, y: float32): float32
::[.00a3e0, .00a3e0): exec(1), time(8 / 0.008 ms): float32.sqrt(x: float32): float32
::[.00a638, .00a638): exec(1), time(10 / 0.010 ms): float32.atan2(x: float32, y: float32): float32
::[.00a800, .00a800): exec(1), time(42 / 0.042 ms): float64.sin(x: float64): float64
::[.00a9c8, .00a9c8): exec(1), time(27 / 0.027 ms): float64.cos(x: float64): float64
::[.00ab90, .00ab90): exec(1), time(9 / 0.009 ms): float64.tan(x: float64): float64
::[.00ad58, .00ad58): exec(1), time(11 / 0.011 ms): float64.log(x: float64): float64
::[.00af20, .00af20): exec(5), time(43 / 0.043 ms): float64.exp(x: float64): float64
::[.00b170, .00b170): exec(1), time(11 / 0.011 ms): float64.pow(x: float64, y: float64): float64
::[.00b338, .00b338): exec(3), time(23 / 0.023 ms): float64.sqrt(x: float64): float64
::[.00b588, .00b588): exec(3), time(23 / 0.023 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:39:[.045958, .0459b6): exec(8), time(84 / 0.084 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.0459b8, .045a0e): exec(10), time(113 / 0.113 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:46:[.045a10, .045a28): exec(6), time(195-104 / 0.195-0.104 ms): Math.floor(x: float64): float64
lib/std/math.ci:58:[.045a28, .045a4c): exec(3), time(26 / 0.026 ms): Math.sign(x: float32): int32
lib/std/math.ci:67:[.045a50, .045a74): exec(3), time(26 / 0.026 ms): Math.sign(x: float64): int32
lib/std/math.ci:83:[.045a78, .045a8a): exec(3), time(24 / 0.024 ms): Math.abs(x: float32): float32
lib/std/math.ci:89:[.045a90, .045aa2): exec(4), time(33 / 0.033 ms): Math.abs(x: float64): float64
lib/std/math.ci:101:[.045aa8, .045ab9): exec(1), time(8 / 0.008 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:107:[.045ac0, .045ad1): exec(1), time(8 / 0.008 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:119:[.045ad8, .045ae9): exec(1), time(9 / 0.009 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:125:[.045af0, .045b01): exec(1), time(8 / 0.008 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:137:[.045b08, .045b26): exec(2), time(19 / 0.019 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:146:[.045b28, .045b46): exec(2), time(19 / 0.019 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:172:[.045b48, .045b90): exec(2), time(50 / 0.050 ms): Math.min(data: float64[]): float64
lib/std/math.ci:184:[.045b90, .045bd8): exec(2), time(64 / 0.064 ms): Math.max(data: float64[]): float64
lib/std/math.ci:197:[.045bd8, .045c00): exec(4), time(105 / 0.105 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:215:[.045c00, .045c2f): exec(3), time(74 / 0.074 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:223:[.045c30, .045c69): exec(1), time(10 / 0.010 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:236:[.045c70, .045ca9): exec(1), time(11 / 0.011 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:250:[.045cb0, .045dff): exec(2), time(55 / 0.055 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:307:[.045e00, .045f73): exec(1), time(46-9 / 0.046-0.009 ms): Math.tan(arg: float64): float64
lib/std/math.ci:364:[.045f78, .046069): exec(1), time(48-20 / 0.048-0.020 ms): Math.sinh(x: float64): float64
lib/std/math.ci:403:[.046070, .0460bb): exec(1), time(36-14 / 0.036-0.014 ms): Math.cosh(x: float64): float64
lib/std/math.ci:419:[.0460c0, .046166): exec(2), time(87-29 / 0.087-0.029 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:20:[.046168, .04616f): exec(0), time(0 / 0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:25:[.046170, .046177): exec(0), time(0 / 0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:66:[.046178, .0461f3): exec(0), time(0 / 0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:93:[.0461f8, .046217): exec(0), time(0 / 0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:107:[.046218, .04627c): exec(0), time(0 / 0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:3:[.046280, .0462a6): exec(0), time(0 / 0.000 ms): length(str: char[*]): int32
lib/std/string.ci:14:[.0462a8, .0462da): exec(0), time(0 / 0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:24:[.0462e0, .046312): exec(0), time(0 / 0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:35:[.046318, .046361): exec(0), time(0 / 0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:44:[.046368, .0463e6): exec(0), time(0 / 0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:58:[.0463e8, .046427): exec(0), time(0 / 0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:71:[.046428, .04646f): exec(0), time(0 / 0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:70:[.046470, .046494): exec(0), time(0 / 0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:84:[.046498, .0464a6): exec(0), time(0 / 0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:113:[.0464a8, .0464fc): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:129:[.046510, .0467a1): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:192:[.0467a8, .0467bf): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:196:[.0467c0, .0467f1): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:205:[.046808, .046821): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:8:[.046828, .04682f): exec(0), time(0 / 0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:21:[.046830, .04683d): exec(0), time(0 / 0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:13:[.046840, .046871): exec(0), time(0 / 0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:25:[.046878, .04688d): exec(0), time(0 / 0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:33:[.046890, .046a31): exec(0), time(0 / 0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:3:[.046a40, .046a41): exec(0), time(0 / 0.000 ms): empty(): void
test/lang/function.ci:6:[.046a48, .046a50): exec(2), time(21 / 0.021 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.046a50, .046a58): exec(2), time(17 / 0.017 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.046a58, .046a8e): exec(753), time(14862 / 14.862 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.046a90, .046a91): exec(1), time(11 / 0.011 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.046a98, .046ab0): exec(64-64), time(1146 / 1.146 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.046ab0, .046abc): exec(1-1), time(10 / 0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.046ac0, .046b04): exec(1-1), time(114-92 / 0.114-0.092 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.046b08, .046b15): exec(1-1), time(11 / 0.011 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.046b18, .046b1a): exec(1-1), time(10 / 0.010 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.046b20, .046b24): exec(5), time(56 / 0.056 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.046b28, .046b34): exec(21), time(258 / 0.258 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.046b38, .046b44): exec(21), time(299 / 0.299 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.046b48, .046b54): exec(14), time(196 / 0.196 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.046b88, .046b90): exec(0), time(0 / 0.000 ms): RecordMethodTest.staticMethod(x: int32, y: int32): int32
test/lang/method.ci:26:[.046b98, .046ba0): exec(0), time(0 / 0.000 ms): RecordMethodTest.virtualMethod(x: int32, y: int32): int32
test/lang/method.ci:31:[.046ba0, .046ba8): exec(0), time(0 / 0.000 ms): RecordMethodTest.forwardMethod(x: int32, y: int32): int32
test/lang/method.ci:40:[.046ba8, .046bd0): exec(3), time(302-248 / 0.302-0.248 ms): RecordMethodTest.print(this: RecordMethodTest): void
test/lang/method.ci:44:[.046bd0, .046bf8): exec(2), time(186-151 / 0.186-0.151 ms): RecordMethodTest.printStatic(this: RecordMethodTest): void
test/lang/method.ci:49:[.046bf8, .046c00): exec(0), time(0 / 0.000 ms): globalFunction(x: int32, y: int32): int32
test/lang/method.ci:59:[.046c00, .046c28): exec(1), time(96-78 / 0.096-0.078 ms): customPrint(this: RecordMethodTest): void
test/lang/method.ci:75:[.046c28, .046c50): exec(2), time(231-195 / 0.231-0.195 ms): print(this: RecordMethodTest): void
test/lang/method.ci:79:[.046c50, .046c78): exec(1), time(123-91 / 0.123-0.091 ms): printStatic(this: RecordMethodTest): void
::[.046c78, .049520): exec(1), time(25792-20681 / 25.792-20.681 ms): .main

---------- Profile statements: 875/1127, coverage: 77.64%
lib/stdlib.ci:41:[.045961, .045962) exec(8), time(52-52 / 0.052-0.052 ms): <assertEq+9>
lib/stdlib.ci:40:[.045958, .045962) exec(8-8), time(0 / 0.000 ms): <assertEq+0>
lib/stdlib.ci:44:[.045966, .045971) exec(0), time(0 / 0.000 ms): <assertEq+14>
lib/stdlib.ci:45:[.045971, .04597c) exec(0), time(0 / 0.000 ms): <assertEq+25>
lib/stdlib.ci:46:[.04597c, .04597f) exec(0), time(0 / 0.000 ms): <assertEq+36>
::[.04597f, .04598b) exec(0), time(0 / 0.000 ms): <assertEq+39>
lib/stdlib.ci:43:[.045962, .04598b) exec(0), time(0 / 0.000 ms): <assertEq+10>
lib/stdlib.ci:48:[.04598b, .0459b1) exec(0), time(0 / 0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.0459d0, .0459e1) exec(3), time(49-49 / 0.049-0.049 ms): <modf+24>
lib/std/math.ci:26:[.0459e1, .0459e8) exec(3), time(2-2 / 0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.0459e8, .0459eb) exec(3), time(17-17 / 0.017-0.017 ms): <modf+48>
lib/std/math.ci:24:[.0459c8, .0459ef) exec(3-3), time(0 / 0.000 ms): <modf+16>
lib/std/math.ci:29:[.0459ef, .0459f3) exec(0), time(0 / 0.000 ms): <modf+55>
lib/std/math.ci:30:[.0459f3, .0459f7) exec(0), time(0 / 0.000 ms): <modf+59>
lib/std/math.ci:23:[.0459b8, .0459f7) exec(10-3), time(2-2 / 0.002-0.002 ms): <modf+0>
lib/std/math.ci:32:[.0459f7, .045a03) exec(7), time(4-4 / 0.004-0.004 ms): <modf+63>
lib/std/math.ci:33:[.045a03, .045a0b) exec(7), time(5-5 / 0.005-0.005 ms): <modf+75>
lib/std/math.ci:34:[.045a0b, .045a0e) exec(7), time(40-40 / 0.040-0.040 ms): <modf+83>
lib/std/math.ci:47:[.045a10, .045a11) exec(6), time(0 / 0.000 ms): <floor+0>
lib/std/math.ci:48:[.045a11, .045a25) exec(6), time(137-137 / 0.137-0.137 ms): <floor+1>
lib/std/math.ci:49:[.045a25, .045a28) exec(6), time(34-34 / 0.034-0.034 ms): <floor+21>
lib/std/math.ci:60:[.045a30, .045a34) exec(1), time(5-5 / 0.005-0.005 ms): <sign+8>
lib/std/math.ci:59:[.045a28, .045a34) exec(3-1), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:63:[.045a3c, .045a44) exec(1), time(6-6 / 0.006-0.006 ms): <sign+20>
lib/std/math.ci:62:[.045a34, .045a44) exec(2-1), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:65:[.045a44, .045a4c) exec(1), time(5-5 / 0.005-0.005 ms): <sign+28>
lib/std/math.ci:69:[.045a58, .045a5c) exec(1), time(6-6 / 0.006-0.006 ms): <sign+8>
lib/std/math.ci:68:[.045a50, .045a5c) exec(3-1), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:72:[.045a64, .045a6c) exec(1), time(6-6 / 0.006-0.006 ms): <sign+20>
lib/std/math.ci:71:[.045a5c, .045a6c) exec(2-1), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:74:[.045a6c, .045a74) exec(1), time(5-5 / 0.005-0.005 ms): <sign+28>
lib/std/math.ci:85:[.045a80, .045a86) exec(1), time(5-5 / 0.005-0.005 ms): <abs+8>
lib/std/math.ci:84:[.045a78, .045a86) exec(3-1), time(1-1 / 0.001-0.001 ms): <abs+0>
lib/std/math.ci:87:[.045a86, .045a8a) exec(2), time(10-10 / 0.010-0.010 ms): <abs+14>
lib/std/math.ci:91:[.045a98, .045a9e) exec(1), time(6-6 / 0.006-0.006 ms): <abs+8>
lib/std/math.ci:90:[.045a90, .045a9e) exec(4-1), time(1-1 / 0.001-0.001 ms): <abs+0>
lib/std/math.ci:93:[.045a9e, .045aa2) exec(3), time(16-16 / 0.016-0.016 ms): <abs+14>
lib/std/math.ci:103:[.045ab1, .045ab5) exec(1), time(5-5 / 0.005-0.005 ms): <min+9>
lib/std/math.ci:102:[.045aa8, .045ab5) exec(1-1), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:105:[.045ab5, .045ab9) exec(0), time(0 / 0.000 ms): <min+13>
lib/std/math.ci:109:[.045ac9, .045acd) exec(1), time(6-6 / 0.006-0.006 ms): <min+9>
lib/std/math.ci:108:[.045ac0, .045acd) exec(1-1), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:111:[.045acd, .045ad1) exec(0), time(0 / 0.000 ms): <min+13>
lib/std/math.ci:121:[.045ae1, .045ae5) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:120:[.045ad8, .045ae5) exec(1), time(1-1 / 0.001-0.001 ms): <max+0>
lib/std/math.ci:123:[.045ae5, .045ae9) exec(1), time(6-6 / 0.006-0.006 ms): <max+13>
lib/std/math.ci:127:[.045af9, .045afd) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:126:[.045af0, .045afd) exec(1), time(0 / 0.000 ms): <max+0>
lib/std/math.ci:129:[.045afd, .045b01) exec(1), time(5-5 / 0.005-0.005 ms): <max+13>
lib/std/math.ci:139:[.045b11, .045b15) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:138:[.045b08, .045b15) exec(2), time(2-2 / 0.002-0.002 ms): <clamp+0>
lib/std/math.ci:142:[.045b1e, .045b22) exec(1), time(5-5 / 0.005-0.005 ms): <clamp+22>
lib/std/math.ci:141:[.045b15, .045b22) exec(2-1), time(1-1 / 0.001-0.001 ms): <clamp+13>
lib/std/math.ci:144:[.045b22, .045b26) exec(1), time(6-6 / 0.006-0.006 ms): <clamp+26>
lib/std/math.ci:148:[.045b31, .045b35) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:147:[.045b28, .045b35) exec(2), time(2-2 / 0.002-0.002 ms): <clamp+0>
lib/std/math.ci:151:[.045b3e, .045b42) exec(1), time(5-5 / 0.005-0.005 ms): <clamp+22>
lib/std/math.ci:150:[.045b35, .045b42) exec(2-1), time(0 / 0.000 ms): <clamp+13>
lib/std/math.ci:153:[.045b42, .045b46) exec(1), time(5-5 / 0.005-0.005 ms): <clamp+26>
lib/std/math.ci:174:[.045b50, .045b55) exec(1), time(5-5 / 0.005-0.005 ms): <min+8>
lib/std/math.ci:173:[.045b48, .045b55) exec(2-1), time(1-1 / 0.001-0.001 ms): <min+0>
lib/std/math.ci:176:[.045b55, .045b58) exec(1), time(1-1 / 0.001-0.001 ms): <min+13>
lib/std/math.ci:179:[.045b71, .045b7c) exec(2), time(0 / 0.000 ms): <min+41>
lib/std/math.ci:178:[.045b61, .045b7c) exec(8-2), time(2-2 / 0.002-0.002 ms): <min+25>
lib/std/math.ci:177:[.045b7c, .045b80) exec(8), time(0 / 0.000 ms): <min+52>
lib/std/math.ci:177:[.045b80, .045b89) exec(9), time(0 / 0.000 ms): <min+56>
lib/std/math.ci:177:[.045b58, .045b8d) exec(1), time(1-1 / 0.001-0.001 ms): <min+16>
lib/std/math.ci:182:[.045b8d, .045b90) exec(1), time(6-6 / 0.006-0.006 ms): <min+69>
lib/std/math.ci:186:[.045b98, .045b9d) exec(1), time(6-6 / 0.006-0.006 ms): <max+8>
lib/std/math.ci:185:[.045b90, .045b9d) exec(2-1), time(1-1 / 0.001-0.001 ms): <max+0>
lib/std/math.ci:188:[.045b9d, .045ba0) exec(1), time(1-1 / 0.001-0.001 ms): <max+13>
lib/std/math.ci:191:[.045bb9, .045bc4) exec(2), time(1-1 / 0.001-0.001 ms): <max+41>
lib/std/math.ci:190:[.045ba9, .045bc4) exec(8-2), time(5-5 / 0.005-0.005 ms): <max+25>
lib/std/math.ci:189:[.045bc4, .045bc8) exec(8), time(3-3 / 0.003-0.003 ms): <max+52>
lib/std/math.ci:189:[.045bc8, .045bd1) exec(9), time(4-4 / 0.004-0.004 ms): <max+56>
lib/std/math.ci:189:[.045ba0, .045bd5) exec(1), time(1-1 / 0.001-0.001 ms): <max+16>
lib/std/math.ci:194:[.045bd5, .045bd8) exec(1), time(5-5 / 0.005-0.005 ms): <max+69>
lib/std/math.ci:198:[.045bd8, .045bd9) exec(4), time(1-1 / 0.001-0.001 ms): <sum+0>
lib/std/math.ci:200:[.045bde, .045bec) exec(13), time(9-9 / 0.009-0.009 ms): <sum+6>
lib/std/math.ci:199:[.045bec, .045bf0) exec(13), time(3-3 / 0.003-0.003 ms): <sum+20>
lib/std/math.ci:199:[.045bf0, .045bf9) exec(17), time(8-8 / 0.008-0.008 ms): <sum+24>
lib/std/math.ci:199:[.045bd9, .045bfd) exec(4), time(4-4 / 0.004-0.004 ms): <sum+1>
lib/std/math.ci:202:[.045bfd, .045c00) exec(4), time(24-24 / 0.024-0.024 ms): <sum+37>
lib/std/math.ci:216:[.045c00, .045c01) exec(3), time(1-1 / 0.001-0.001 ms): <eval+0>
lib/std/math.ci:218:[.045c0b, .045c1c) exec(11), time(10-10 / 0.010-0.010 ms): <eval+11>
lib/std/math.ci:217:[.045c1c, .045c20) exec(11), time(5-5 / 0.005-0.005 ms): <eval+28>
lib/std/math.ci:217:[.045c20, .045c28) exec(14), time(9-9 / 0.009-0.009 ms): <eval+32>
lib/std/math.ci:217:[.045c01, .045c2c) exec(3), time(3-3 / 0.003-0.003 ms): <eval+1>
lib/std/math.ci:220:[.045c2c, .045c2f) exec(3), time(18-18 / 0.018-0.018 ms): <eval+44>
lib/std/math.ci:226:[.045c45, .045c4d) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:225:[.045c39, .045c4d) exec(1), time(1-1 / 0.001-0.001 ms): <cmp+9>
lib/std/math.ci:231:[.045c5d, .045c65) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:230:[.045c51, .045c65) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:224:[.045c30, .045c65) exec(1), time(1-1 / 0.001-0.001 ms): <cmp+0>
lib/std/math.ci:234:[.045c65, .045c69) exec(1), time(5-5 / 0.005-0.005 ms): <cmp+53>
lib/std/math.ci:239:[.045c85, .045c8d) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:238:[.045c79, .045c8d) exec(1), time(1-1 / 0.001-0.001 ms): <cmp+9>
lib/std/math.ci:244:[.045c9d, .045ca5) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:243:[.045c91, .045ca5) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:237:[.045c70, .045ca5) exec(1), time(2-2 / 0.002-0.002 ms): <cmp+0>
lib/std/math.ci:247:[.045ca5, .045ca9) exec(1), time(6-6 / 0.006-0.006 ms): <cmp+53>
lib/std/math.ci:264:[.045cb0, .045cb2) exec(2), time(0 / 0.000 ms): <sinCos+0>
lib/std/math.ci:266:[.045cba, .045cbb) exec(0), time(0 / 0.000 ms): <sinCos+10>
lib/std/math.ci:267:[.045cbb, .045cc3) exec(0), time(0 / 0.000 ms): <sinCos+11>
lib/std/math.ci:265:[.045cb2, .045cc3) exec(2), time(2-2 / 0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:270:[.045cc3, .045cc4) exec(2), time(1-1 / 0.001-0.001 ms): <sinCos+19>
lib/std/math.ci:271:[.045cc4, .045cdc) exec(2), time(2-2 / 0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:273:[.045cec, .045ced) exec(0), time(0 / 0.000 ms): <sinCos+60>
lib/std/math.ci:274:[.045ced, .045cff) exec(0), time(0 / 0.000 ms): <sinCos+61>
lib/std/math.ci:275:[.045cff, .045d03) exec(0), time(0 / 0.000 ms): <sinCos+79>
lib/std/math.ci:277:[.045d03, .045d04) exec(0), time(0 / 0.000 ms): <sinCos+83>
lib/std/math.ci:278:[.045d04, .045d22) exec(0), time(0 / 0.000 ms): <sinCos+84>
lib/std/math.ci:279:[.045d22, .045d34) exec(0), time(0 / 0.000 ms): <sinCos+114>
lib/std/math.ci:282:[.045d3c, .045d3f) exec(2), time(2-2 / 0.002-0.002 ms): <sinCos+140>
lib/std/math.ci:283:[.045d3f, .045d47) exec(2), time(2-2 / 0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:284:[.045d47, .045d4e) exec(2), time(0 / 0.000 ms): <sinCos+151>
lib/std/math.ci:285:[.045d4e, .045d54) exec(2), time(0 / 0.000 ms): <sinCos+158>
lib/std/math.ci:272:[.045cdc, .045d58) exec(2), time(2-2 / 0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:288:[.045d60, .045d6e) exec(1), time(1-1 / 0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:287:[.045d58, .045d6e) exec(2-1), time(1-1 / 0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:291:[.045d7a, .045d7b) exec(1), time(1-1 / 0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:290:[.045d6e, .045d7b) exec(2-1), time(1-1 / 0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:294:[.045d7b, .045d80) exec(2), time(1-1 / 0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:295:[.045d80, .045dc0) exec(2), time(4-4 / 0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:296:[.045dc0, .045df3) exec(2), time(3-3 / 0.003-0.003 ms): <sinCos+272>
lib/std/math.ci:297:[.045df3, .045dff) exec(2), time(12-12 / 0.012-0.012 ms): <sinCos+323>
lib/std/math.ci:320:[.045e00, .045e01) exec(1), time(0 / 0.000 ms): <tan+0>
lib/std/math.ci:321:[.045e01, .045e02) exec(1), time(0 / 0.000 ms): <tan+1>
lib/std/math.ci:324:[.045e0a, .045e0f) exec(0), time(0 / 0.000 ms): <tan+10>
lib/std/math.ci:325:[.045e0f, .045e19) exec(0), time(0 / 0.000 ms): <tan+15>
lib/std/math.ci:323:[.045e02, .045e19) exec(1), time(1-1 / 0.001-0.001 ms): <tan+2>
lib/std/math.ci:327:[.045e19, .045e31) exec(1), time(1-1 / 0.001-0.001 ms): <tan+25>
lib/std/math.ci:329:[.045e31, .045e32) exec(1), time(1-1 / 0.001-0.001 ms): <tan+49>
lib/std/math.ci:330:[.045e32, .045e42) exec(1), time(16-16 / 0.016-0.016 ms): <tan+50>
lib/std/math.ci:331:[.045e42, .045e4b) exec(1), time(1-1 / 0.001-0.001 ms): <tan+66>
lib/std/math.ci:335:[.045e5f, .045e6d) exec(1), time(0 / 0.000 ms): <tan+95>
lib/std/math.ci:336:[.045e6d, .045e77) exec(1), time(1-1 / 0.001-0.001 ms): <tan+109>
lib/std/math.ci:339:[.045e87, .045e92) exec(0), time(0 / 0.000 ms): <tan+135>
lib/std/math.ci:340:[.045e92, .045e9c) exec(0), time(0 / 0.000 ms): <tan+146>
lib/std/math.ci:343:[.045eac, .045eba) exec(0), time(0 / 0.000 ms): <tan+172>
lib/std/math.ci:344:[.045eba, .045ec5) exec(0), time(0 / 0.000 ms): <tan+186>
lib/std/math.ci:342:[.045ea0, .045ec5) exec(0), time(0 / 0.000 ms): <tan+160>
lib/std/math.ci:338:[.045e7b, .045ec5) exec(0), time(0 / 0.000 ms): <tan+123>
lib/std/math.ci:334:[.045e53, .045ec5) exec(1), time(1-1 / 0.001-0.001 ms): <tan+83>
lib/std/math.ci:333:[.045e4b, .045ec5) exec(1-1), time(0 / 0.000 ms): <tan+75>
lib/std/math.ci:347:[.045ec5, .045eca) exec(1), time(0 / 0.000 ms): <tan+197>
lib/std/math.ci:348:[.045eca, .045f0a) exec(1), time(2-2 / 0.002-0.002 ms): <tan+202>
lib/std/math.ci:349:[.045f0a, .045f31) exec(1), time(2-2 / 0.002-0.002 ms): <tan+266>
lib/std/math.ci:353:[.045f42, .045f4b) exec(0), time(0 / 0.000 ms): <tan+322>
lib/std/math.ci:352:[.045f3a, .045f4b) exec(1), time(1-1 / 0.001-0.001 ms): <tan+314>
lib/std/math.ci:355:[.045f4b, .045f59) exec(1), time(1-1 / 0.001-0.001 ms): <tan+331>
lib/std/math.ci:351:[.045f31, .045f59) exec(1-1), time(0 / 0.000 ms): <tan+305>
lib/std/math.ci:358:[.045f62, .045f6c) exec(0), time(0 / 0.000 ms): <tan+354>
lib/std/math.ci:357:[.045f59, .045f6c) exec(1), time(1-1 / 0.001-0.001 ms): <tan+345>
lib/std/math.ci:360:[.045f6c, .045f73) exec(1), time(5-5 / 0.005-0.005 ms): <tan+364>
lib/std/math.ci:376:[.045f78, .045f79) exec(1), time(0 / 0.000 ms): <sinh+0>
lib/std/math.ci:378:[.045f81, .045f86) exec(0), time(0 / 0.000 ms): <sinh+9>
lib/std/math.ci:379:[.045f86, .045f90) exec(0), time(0 / 0.000 ms): <sinh+14>
lib/std/math.ci:377:[.045f79, .045f90) exec(1), time(1-1 / 0.001-0.001 ms): <sinh+1>
lib/std/math.ci:383:[.045fa0, .045fb7) exec(0), time(0 / 0.000 ms): <sinh+40>
lib/std/math.ci:382:[.045f90, .045fb7) exec(1), time(1-1 / 0.001-0.001 ms): <sinh+24>
lib/std/math.ci:386:[.045fb7, .045fb8) exec(1), time(1-1 / 0.001-0.001 ms): <sinh+63>
lib/std/math.ci:388:[.045fc8, .045fe2) exec(1), time(33-33 / 0.033-0.033 ms): <sinh+80>
lib/std/math.ci:391:[.045fe6, .045feb) exec(0), time(0 / 0.000 ms): <sinh+110>
lib/std/math.ci:392:[.045feb, .046020) exec(0), time(0 / 0.000 ms): <sinh+115>
lib/std/math.ci:393:[.046020, .04604b) exec(0), time(0 / 0.000 ms): <sinh+168>
lib/std/math.ci:387:[.045fb8, .04604f) exec(1), time(34-34 / 0.034-0.034 ms): <sinh+64>
lib/std/math.ci:397:[.046058, .046062) exec(0), time(0 / 0.000 ms): <sinh+224>
lib/std/math.ci:396:[.04604f, .046062) exec(1), time(1-1 / 0.001-0.001 ms): <sinh+215>
lib/std/math.ci:399:[.046062, .046069) exec(1), time(6-6 / 0.006-0.006 ms): <sinh+234>
lib/std/math.ci:405:[.046078, .04607d) exec(0), time(0 / 0.000 ms): <cosh+8>
lib/std/math.ci:404:[.046070, .04607d) exec(1), time(1-1 / 0.001-0.001 ms): <cosh+0>
lib/std/math.ci:408:[.04608d, .0460a0) exec(0), time(0 / 0.000 ms): <cosh+29>
lib/std/math.ci:407:[.04607d, .0460a0) exec(1), time(1-1 / 0.001-0.001 ms): <cosh+13>
lib/std/math.ci:410:[.0460a0, .0460bb) exec(1), time(31-31 / 0.031-0.031 ms): <cosh+48>
lib/std/math.ci:422:[.0460c8, .0460cc) exec(0), time(0 / 0.000 ms): <asin+8>
lib/std/math.ci:420:[.0460c0, .0460cc) exec(2), time(1-1 / 0.001-0.001 ms): <asin+0>
lib/std/math.ci:425:[.0460cc, .0460cd) exec(2), time(0 / 0.000 ms): <asin+12>
lib/std/math.ci:427:[.0460d5, .0460df) exec(0), time(0 / 0.000 ms): <asin+21>
lib/std/math.ci:428:[.0460df, .0460e4) exec(0), time(0 / 0.000 ms): <asin+31>
lib/std/math.ci:426:[.0460cd, .0460e4) exec(2), time(1-1 / 0.001-0.001 ms): <asin+13>
lib/std/math.ci:433:[.0460f4, .0460fd) exec(0), time(0 / 0.000 ms): <asin+52>
lib/std/math.ci:431:[.0460e4, .0460fd) exec(2), time(2-2 / 0.002-0.002 ms): <asin+36>
lib/std/math.ci:436:[.0460fd, .046110) exec(2), time(27-27 / 0.027-0.027 ms): <asin+61>
lib/std/math.ci:438:[.046120, .04613e) exec(0), time(0 / 0.000 ms): <asin+96>
lib/std/math.ci:441:[.046142, .04614c) exec(2), time(27-27 / 0.027-0.027 ms): <asin+130>
lib/std/math.ci:437:[.046110, .04614c) exec(2-2), time(0 / 0.000 ms): <asin+80>
lib/std/math.ci:445:[.046155, .04615f) exec(0), time(0 / 0.000 ms): <asin+149>
lib/std/math.ci:444:[.04614c, .04615f) exec(2), time(0 / 0.000 ms): <asin+140>
lib/std/math.ci:447:[.04615f, .046166) exec(2), time(12-12 / 0.012-0.012 ms): <asin+159>
::[.04616b, .04616e) exec(0), time(0 / 0.000 ms): <Complex+3>
lib/std/math.Complex.ci:21:[.046168, .04616f) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:28:[.046173, .046176) exec(0), time(0 / 0.000 ms): <Complex+3>
lib/std/math.Complex.ci:26:[.046170, .046177) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:71:[.046197, .04619c) exec(0), time(0 / 0.000 ms): <div+31>
lib/std/math.Complex.ci:72:[.04619c, .0461a4) exec(0), time(0 / 0.000 ms): <div+36>
lib/std/math.Complex.ci:75:[.0461b1, .0461be) exec(0), time(0 / 0.000 ms): <div+57>
lib/std/math.Complex.ci:73:[.0461a4, .0461c3) exec(0), time(0 / 0.000 ms): <div+44>
lib/std/math.Complex.ci:70:[.046178, .0461c7) exec(0), time(0 / 0.000 ms): <div+0>
lib/std/math.Complex.ci:78:[.0461c7, .0461cc) exec(0), time(0 / 0.000 ms): <div+79>
lib/std/math.Complex.ci:79:[.0461cc, .0461d4) exec(0), time(0 / 0.000 ms): <div+84>
lib/std/math.Complex.ci:82:[.0461e1, .0461ee) exec(0), time(0 / 0.000 ms): <div+105>
lib/std/math.Complex.ci:80:[.0461d4, .0461f3) exec(0), time(0 / 0.000 ms): <div+92>
lib/std/math.Complex.ci:94:[.0461f8, .046203) exec(0), time(0 / 0.000 ms): <inv+0>
lib/std/math.Complex.ci:97:[.04620a, .046212) exec(0), time(0 / 0.000 ms): <inv+18>
lib/std/math.Complex.ci:95:[.046203, .046217) exec(0), time(0 / 0.000 ms): <inv+11>
lib/std/math.Complex.ci:108:[.046218, .04622f) exec(0), time(0 / 0.000 ms): <pow+0>
lib/std/math.Complex.ci:109:[.04622f, .04623f) exec(0), time(0 / 0.000 ms): <pow+23>
lib/std/math.Complex.ci:110:[.04623f, .04624e) exec(0), time(0 / 0.000 ms): <pow+39>
lib/std/math.Complex.ci:111:[.04624e, .046261) exec(0), time(0 / 0.000 ms): <pow+54>
lib/std/math.Complex.ci:114:[.04626c, .046277) exec(0), time(0 / 0.000 ms): <pow+84>
lib/std/math.Complex.ci:112:[.046261, .04627c) exec(0), time(0 / 0.000 ms): <pow+73>
lib/std/string.ci:5:[.04628c, .046290) exec(0), time(0 / 0.000 ms): <length+12>
lib/std/string.ci:4:[.046280, .046290) exec(0), time(0 / 0.000 ms): <length+0>
lib/std/string.ci:7:[.046290, .046291) exec(0), time(0 / 0.000 ms): <length+16>
lib/std/string.ci:8:[.046295, .046299) exec(0), time(0 / 0.000 ms): <length+21>
lib/std/string.ci:8:[.046299, .0462a3) exec(0), time(0 / 0.000 ms): <length+25>
lib/std/string.ci:8:[.046291, .0462a3) exec(0), time(0 / 0.000 ms): <length+17>
lib/std/string.ci:10:[.0462a3, .0462a6) exec(0), time(0 / 0.000 ms): <length+35>
lib/std/string.ci:17:[.0462bd, .0462c0) exec(0), time(0 / 0.000 ms): <indexOf+21>
lib/std/string.ci:16:[.0462ad, .0462c0) exec(0), time(0 / 0.000 ms): <indexOf+5>
lib/std/string.ci:15:[.0462c0, .0462c4) exec(0), time(0 / 0.000 ms): <indexOf+24>
lib/std/string.ci:15:[.0462c4, .0462ce) exec(0), time(0 / 0.000 ms): <indexOf+28>
lib/std/string.ci:15:[.0462a8, .0462d2) exec(0), time(0 / 0.000 ms): <indexOf+0>
lib/std/string.ci:20:[.0462d2, .0462da) exec(0), time(0 / 0.000 ms): <indexOf+42>
lib/std/string.ci:25:[.0462e0, .0462e5) exec(0), time(0 / 0.000 ms): <lastIndexOf+0>
lib/std/string.ci:28:[.0462fa, .0462fd) exec(0), time(0 / 0.000 ms): <lastIndexOf+26>
lib/std/string.ci:27:[.0462ea, .0462fd) exec(0), time(0 / 0.000 ms): <lastIndexOf+10>
lib/std/string.ci:26:[.0462fd, .046301) exec(0), time(0 / 0.000 ms): <lastIndexOf+29>
lib/std/string.ci:26:[.046301, .04630b) exec(0), time(0 / 0.000 ms): <lastIndexOf+33>
lib/std/string.ci:26:[.0462e5, .04630f) exec(0), time(0 / 0.000 ms): <lastIndexOf+5>
lib/std/string.ci:31:[.04630f, .046312) exec(0), time(0 / 0.000 ms): <lastIndexOf+47>
lib/std/string.ci:38:[.046337, .046342) exec(0), time(0 / 0.000 ms): <startsWith+31>
lib/std/string.ci:37:[.04631d, .046342) exec(0), time(0 / 0.000 ms): <startsWith+5>
lib/std/string.ci:36:[.046342, .046346) exec(0), time(0 / 0.000 ms): <startsWith+42>
lib/std/string.ci:36:[.046346, .046352) exec(0), time(0 / 0.000 ms): <startsWith+46>
lib/std/string.ci:36:[.046318, .046356) exec(0), time(0 / 0.000 ms): <startsWith+0>
lib/std/string.ci:41:[.046356, .046361) exec(0), time(0 / 0.000 ms): <startsWith+62>
lib/std/string.ci:45:[.046368, .046375) exec(0), time(0 / 0.000 ms): <endsWith+0>
lib/std/string.ci:46:[.046375, .046382) exec(0), time(0 / 0.000 ms): <endsWith+13>
lib/std/string.ci:48:[.04638b, .046396) exec(0), time(0 / 0.000 ms): <endsWith+35>
lib/std/string.ci:47:[.046382, .046396) exec(0), time(0 / 0.000 ms): <endsWith+26>
lib/std/string.ci:52:[.0463bb, .0463c6) exec(0), time(0 / 0.000 ms): <endsWith+83>
lib/std/string.ci:51:[.04639b, .0463c6) exec(0), time(0 / 0.000 ms): <endsWith+51>
lib/std/string.ci:50:[.0463c6, .0463ca) exec(0), time(0 / 0.000 ms): <endsWith+94>
lib/std/string.ci:50:[.0463ca, .0463d3) exec(0), time(0 / 0.000 ms): <endsWith+98>
lib/std/string.ci:50:[.046396, .0463d7) exec(0), time(0 / 0.000 ms): <endsWith+46>
lib/std/string.ci:55:[.0463d7, .0463e6) exec(0), time(0 / 0.000 ms): <endsWith+111>
lib/std/string.ci:59:[.0463e8, .0463e9) exec(0), time(0 / 0.000 ms): <compare+0>
lib/std/string.ci:61:[.0463ee, .046404) exec(0), time(0 / 0.000 ms): <compare+6>
lib/std/string.ci:63:[.046410, .046414) exec(0), time(0 / 0.000 ms): <compare+40>
lib/std/string.ci:62:[.046404, .046414) exec(0), time(0 / 0.000 ms): <compare+28>
lib/std/string.ci:60:[.046414, .046418) exec(0), time(0 / 0.000 ms): <compare+44>
lib/std/string.ci:60:[.046418, .046420) exec(0), time(0 / 0.000 ms): <compare+48>
lib/std/string.ci:60:[.0463e9, .046424) exec(0), time(0 / 0.000 ms): <compare+1>
lib/std/string.ci:66:[.046424, .046427) exec(0), time(0 / 0.000 ms): <compare+60>
lib/std/string.ci:73:[.046437, .046442) exec(0), time(0 / 0.000 ms): <ignCase+15>
lib/std/string.ci:72:[.046428, .046442) exec(0), time(0 / 0.000 ms): <ignCase+0>
lib/std/string.ci:76:[.046451, .04645c) exec(0), time(0 / 0.000 ms): <ignCase+41>
lib/std/string.ci:75:[.046442, .04645c) exec(0), time(0 / 0.000 ms): <ignCase+26>
lib/std/string.ci:78:[.04645c, .04646f) exec(0), time(0 / 0.000 ms): <ignCase+52>
lib/std/string.ci:81:[.046470, .046494) exec(0), time(0 / 0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:85:[.046498, .0464a6) exec(0), time(0 / 0.000 ms): <caseCmp+0>
lib/std/string.ci:116:[.0464b6, .0464ba) exec(0), time(0 / 0.000 ms): <append+14>
lib/std/string.ci:115:[.0464ad, .0464ba) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:118:[.0464ba, .0464c6) exec(0), time(0 / 0.000 ms): <append+18>
lib/std/string.ci:119:[.0464c6, .0464ce) exec(0), time(0 / 0.000 ms): <append+30>
lib/std/string.ci:114:[.0464ce, .0464d2) exec(0), time(0 / 0.000 ms): <append+38>
lib/std/string.ci:114:[.0464d2, .0464dc) exec(0), time(0 / 0.000 ms): <append+42>
lib/std/string.ci:114:[.0464a8, .0464e0) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:123:[.0464e9, .0464f1) exec(0), time(0 / 0.000 ms): <append+65>
lib/std/string.ci:122:[.0464e0, .0464f1) exec(0), time(0 / 0.000 ms): <append+56>
lib/std/string.ci:125:[.0464f1, .0464f8) exec(0), time(0 / 0.000 ms): <append+73>
lib/std/string.ci:126:[.0464f8, .0464fc) exec(0), time(0 / 0.000 ms): <append+80>
lib/std/string.ci:133:[.046510, .046511) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:134:[.046511, .046515) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:136:[.046515, .046518) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:137:[.046518, .04654e) exec(0), time(0 / 0.000 ms): <append+8>
lib/std/string.ci:138:[.04654e, .046583) exec(0), time(0 / 0.000 ms): <append+62>
lib/std/string.ci:142:[.046587, .0465a2) exec(0), time(0 / 0.000 ms): <append+119>
lib/std/string.ci:141:[.0465a2, .0465a9) exec(0), time(0 / 0.000 ms): <append+146>
lib/std/string.ci:141:[.0465a9, .0465b1) exec(0), time(0 / 0.000 ms): <append+153>
lib/std/string.ci:141:[.046583, .0465b1) exec(0), time(0 / 0.000 ms): <append+115>
lib/std/string.ci:145:[.0465b9, .0465ce) exec(0), time(0 / 0.000 ms): <append+169>
lib/std/string.ci:144:[.0465b1, .0465ce) exec(0), time(0 / 0.000 ms): <append+161>
lib/std/string.ci:148:[.0465ce, .0465d8) exec(0), time(0 / 0.000 ms): <append+190>
lib/std/string.ci:150:[.0465d8, .0465df) exec(0), time(0 / 0.000 ms): <append+200>
lib/std/string.ci:152:[.0465ea, .0465f4) exec(0), time(0 / 0.000 ms): <append+218>
lib/std/string.ci:151:[.0465df, .0465f4) exec(0), time(0 / 0.000 ms): <append+207>
lib/std/string.ci:157:[.0465ff, .046607) exec(0), time(0 / 0.000 ms): <append+239>
lib/std/string.ci:161:[.046625, .046659) exec(0), time(0 / 0.000 ms): <append+277>
lib/std/string.ci:162:[.046659, .046664) exec(0), time(0 / 0.000 ms): <append+329>
lib/std/string.ci:163:[.046664, .04666c) exec(0), time(0 / 0.000 ms): <append+340>
lib/std/string.ci:160:[.04666c, .046674) exec(0), time(0 / 0.000 ms): <append+348>
lib/std/string.ci:160:[.046674, .04667c) exec(0), time(0 / 0.000 ms): <append+356>
lib/std/string.ci:160:[.046621, .04667c) exec(0), time(0 / 0.000 ms): <append+273>
lib/std/string.ci:158:[.046607, .04667c) exec(0), time(0 / 0.000 ms): <append+247>
lib/std/string.ci:166:[.04667c, .0466b0) exec(0), time(0 / 0.000 ms): <append+364>
lib/std/string.ci:167:[.0466b0, .0466bb) exec(0), time(0 / 0.000 ms): <append+416>
lib/std/string.ci:168:[.0466bb, .0466c3) exec(0), time(0 / 0.000 ms): <append+427>
lib/std/string.ci:156:[.0465f4, .0466c3) exec(0), time(0 / 0.000 ms): <append+228>
lib/std/string.ci:173:[.0466c7, .0466fb) exec(0), time(0 / 0.000 ms): <append+439>
lib/std/string.ci:174:[.0466fb, .046706) exec(0), time(0 / 0.000 ms): <append+491>
lib/std/string.ci:175:[.046706, .04670e) exec(0), time(0 / 0.000 ms): <append+502>
lib/std/string.ci:172:[.04670e, .046716) exec(0), time(0 / 0.000 ms): <append+510>
lib/std/string.ci:172:[.046716, .04671e) exec(0), time(0 / 0.000 ms): <append+518>
lib/std/string.ci:172:[.0466c3, .04671e) exec(0), time(0 / 0.000 ms): <append+435>
lib/std/string.ci:180:[.046723, .046757) exec(0), time(0 / 0.000 ms): <append+531>
lib/std/string.ci:181:[.046757, .046768) exec(0), time(0 / 0.000 ms): <append+583>
lib/std/string.ci:182:[.046768, .046770) exec(0), time(0 / 0.000 ms): <append+600>
lib/std/string.ci:179:[.046770, .046774) exec(0), time(0 / 0.000 ms): <append+608>
lib/std/string.ci:179:[.046774, .04677d) exec(0), time(0 / 0.000 ms): <append+612>
lib/std/string.ci:179:[.04671e, .046781) exec(0), time(0 / 0.000 ms): <append+526>
lib/std/string.ci:186:[.04678a, .046792) exec(0), time(0 / 0.000 ms): <append+634>
lib/std/string.ci:185:[.046781, .046792) exec(0), time(0 / 0.000 ms): <append+625>
lib/std/string.ci:188:[.046792, .046799) exec(0), time(0 / 0.000 ms): <append+642>
lib/std/string.ci:189:[.046799, .0467a1) exec(0), time(0 / 0.000 ms): <append+649>
lib/std/string.ci:193:[.0467a8, .0467bf) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:197:[.0467c0, .0467c1) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:199:[.0467c9, .0467d0) exec(0), time(0 / 0.000 ms): <append+9>
lib/std/string.ci:200:[.0467d0, .0467d5) exec(0), time(0 / 0.000 ms): <append+16>
lib/std/string.ci:198:[.0467c1, .0467d5) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:202:[.0467d5, .0467f1) exec(0), time(0 / 0.000 ms): <append+21>
lib/std/string.ci:207:[.046808, .046821) exec(0), time(0 / 0.000 ms): <append+0>
lib/vec/vec2d.ci:11:[.04682b, .04682e) exec(0), time(0 / 0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:9:[.046828, .04682f) exec(0), time(0 / 0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:22:[.046833, .046836) exec(0), time(0 / 0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:22:[.046836, .046839) exec(0), time(0 / 0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:22:[.046839, .04683c) exec(0), time(0 / 0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:22:[.046830, .04683d) exec(0), time(0 / 0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:18:[.046843, .046846) exec(0), time(0 / 0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:18:[.046846, .046849) exec(0), time(0 / 0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:18:[.046849, .04684c) exec(0), time(0 / 0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:19:[.04684c, .04684f) exec(0), time(0 / 0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:19:[.04684f, .046852) exec(0), time(0 / 0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:19:[.046852, .046855) exec(0), time(0 / 0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:19:[.046855, .046858) exec(0), time(0 / 0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:20:[.046858, .04685b) exec(0), time(0 / 0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:20:[.04685b, .04685e) exec(0), time(0 / 0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:20:[.04685e, .046861) exec(0), time(0 / 0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:20:[.046861, .046864) exec(0), time(0 / 0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:21:[.046864, .046867) exec(0), time(0 / 0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:21:[.046867, .04686a) exec(0), time(0 / 0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:21:[.04686a, .04686d) exec(0), time(0 / 0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:21:[.04686d, .046870) exec(0), time(0 / 0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:17:[.046840, .046871) exec(0), time(0 / 0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:26:[.04687d, .046882) exec(0), time(0 / 0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:26:[.046882, .046887) exec(0), time(0 / 0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:26:[.046887, .04688c) exec(0), time(0 / 0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:26:[.046878, .04688d) exec(0), time(0 / 0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:35:[.046894, .046899) exec(0), time(0 / 0.000 ms): <mul+4>
lib/vec/mat4f.ci:35:[.046899, .0468a2) exec(0), time(0 / 0.000 ms): <mul+9>
lib/vec/mat4f.ci:35:[.0468a2, .0468ab) exec(0), time(0 / 0.000 ms): <mul+18>
lib/vec/mat4f.ci:35:[.0468ab, .0468b4) exec(0), time(0 / 0.000 ms): <mul+27>
lib/vec/mat4f.ci:36:[.0468b4, .0468bd) exec(0), time(0 / 0.000 ms): <mul+36>
lib/vec/mat4f.ci:36:[.0468bd, .0468c6) exec(0), time(0 / 0.000 ms): <mul+45>
lib/vec/mat4f.ci:36:[.0468c6, .0468cf) exec(0), time(0 / 0.000 ms): <mul+54>
lib/vec/mat4f.ci:36:[.0468cf, .0468d8) exec(0), time(0 / 0.000 ms): <mul+63>
lib/vec/mat4f.ci:37:[.0468d8, .0468e1) exec(0), time(0 / 0.000 ms): <mul+72>
lib/vec/mat4f.ci:37:[.0468e1, .0468ea) exec(0), time(0 / 0.000 ms): <mul+81>
lib/vec/mat4f.ci:37:[.0468ea, .0468f3) exec(0), time(0 / 0.000 ms): <mul+90>
lib/vec/mat4f.ci:37:[.0468f3, .0468fc) exec(0), time(0 / 0.000 ms): <mul+99>
lib/vec/mat4f.ci:38:[.0468fc, .046905) exec(0), time(0 / 0.000 ms): <mul+108>
lib/vec/mat4f.ci:38:[.046905, .04690e) exec(0), time(0 / 0.000 ms): <mul+117>
lib/vec/mat4f.ci:38:[.04690e, .046917) exec(0), time(0 / 0.000 ms): <mul+126>
lib/vec/mat4f.ci:38:[.046917, .046920) exec(0), time(0 / 0.000 ms): <mul+135>
lib/vec/mat4f.ci:34:[.046890, .046920) exec(0), time(0 / 0.000 ms): <mul+0>
lib/vec/mat4f.ci:43:[.046960, .0469a4) exec(0), time(0 / 0.000 ms): <mul+208>
lib/vec/mat4f.ci:44:[.0469a4, .0469e8) exec(0), time(0 / 0.000 ms): <mul+276>
lib/vec/mat4f.ci:45:[.0469e8, .046a2c) exec(0), time(0 / 0.000 ms): <mul+344>
lib/vec/mat4f.ci:41:[.046920, .046a31) exec(0), time(0 / 0.000 ms): <mul+144>
test/lang/function.ci:7:[.046a48, .046a50) exec(2), time(15-15 / 0.015-0.015 ms): <funAdd+0>
test/lang/function.ci:33:[.046a50, .046a58) exec(2), time(14-14 / 0.014-0.014 ms): <funMul+0>
test/lang/function.ci:39:[.046a64, .046a68) exec(377), time(2632-2632 / 2.632-2.632 ms): <fib+12>
test/lang/function.ci:38:[.046a58, .046a68) exec(753-377), time(614-614 / 0.614-0.614 ms): <fib+0>
test/lang/function.ci:41:[.046a68, .046a8e) exec(376-375), time(14865-14865 / 14.865-14.865 ms): <fib+16>
test/stdc/tryExec.ci:15:[.046a98, .046a9c) exec(64-1), time(29-29 / 0.029-0.029 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.046a9c, .046aab) exec(63-63), time(0 / 0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.046ab0, .046ab7) exec(1-1), time(0 / 0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.046ac4, .046acb) exec(1), time(0 / 0.000 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.046acb, .046ad2) exec(1), time(1-1 / 0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.046ad2, .046ad9) exec(1), time(1-1 / 0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.046ac0, .046ad9) exec(1-1), time(0 / 0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.046ad9, .046aff) exec(1-1), time(0 / 0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.046b08, .046b0d) exec(1), time(0 / 0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.046b0d, .046b10) exec(1-1), time(0 / 0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.046b18, .046b1a) exec(1-1), time(0 / 0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.046b20, .046b24) exec(5), time(37-37 / 0.037-0.037 ms): <lenSlice+0>
test/lang/array.ci:104:[.046b28, .046b34) exec(21), time(158-158 / 0.158-0.158 ms): <nthFixed+0>
test/lang/array.ci:105:[.046b38, .046b44) exec(21), time(176-176 / 0.176-0.176 ms): <nthArray+0>
test/lang/array.ci:106:[.046b48, .046b54) exec(14), time(106-106 / 0.106-0.106 ms): <nthSlice+0>
test/lang/method.ci:7:[.046b88, .046b90) exec(0), time(0 / 0.000 ms): <staticMethod+0>
test/lang/method.ci:27:[.046b98, .046ba0) exec(0), time(0 / 0.000 ms): <virtualMethod+0>
test/lang/method.ci:32:[.046ba0, .046ba8) exec(0), time(0 / 0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.046ba8, .046bcf) exec(3), time(273-273 / 0.273-0.273 ms): <print+0>
test/lang/method.ci:45:[.046bd0, .046bf7) exec(2), time(168-168 / 0.168-0.168 ms): <printStatic+0>
test/lang/method.ci:50:[.046bf8, .046c00) exec(0), time(0 / 0.000 ms): <globalFunction+0>
test/lang/method.ci:60:[.046c00, .046c27) exec(1), time(86-86 / 0.086-0.086 ms): <customPrint+0>
test/lang/method.ci:76:[.046c28, .046c4f) exec(2), time(211-211 / 0.211-0.211 ms): <print+0>
test/lang/method.ci:80:[.046c50, .046c77) exec(1), time(100-100 / 0.100-0.100 ms): <printStatic+0>
lib/std/string.ci:130:[.046c78, .046c86) exec(1), time(1-1 / 0.001-0.001 ms): <.main+0>
lib/std/string.ci:131:[.046c86, .046c94) exec(1), time(1-1 / 0.001-0.001 ms): <.main+14>
::[.046c9d, .046ca4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+37>
::[.046ca4, .046ca9) exec(1), time(0 / 0.000 ms): <.main+44>
::[.046ca9, .046cae) exec(1), time(1-1 / 0.001-0.001 ms): <.main+49>
lib/std/string.ci:206:[.046c94, .046cae) exec(1-1), time(0 / 0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.046cae, .046cbb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.046cbb, .046cc0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.046cc0, .046cc9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.046cc9, .046cd2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.046cdb, .046ce4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+99>
test/lang/member.ci:47:[.046cd2, .046ce4) exec(1-1), time(0 / 0.000 ms): <.main+90>
test/lang/member.ci:50:[.046ced, .046cf6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+117>
test/lang/member.ci:50:[.046ce4, .046cf6) exec(1-1), time(0 / 0.000 ms): <.main+108>
test/lang/method.ci:12:[.046cf6, .046cff) exec(1), time(1-1 / 0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.046cff, .046d00) exec(1), time(0 / 0.000 ms): <.main+135>
test/lang/emit.ci:4:[.046d00, .046d01) exec(1), time(0 / 0.000 ms): <.main+136>
test/lang/emit.ci:6:[.046d01, .046d06) exec(1), time(0 / 0.000 ms): <.main+137>
test/lang/emit.ci:7:[.046d06, .046d0b) exec(1), time(0 / 0.000 ms): <.main+142>
test/lang/emit.ci:9:[.046d0b, .046d10) exec(1), time(1-1 / 0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.046d10, .046d1b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+152>
test/lang/emit.ci:17:[.046d1b, .046d20) exec(1), time(0 / 0.000 ms): <.main+163>
test/lang/emit.ci:18:[.046d20, .046d26) exec(1), time(1-1 / 0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.046d26, .046d30) exec(1), time(0 / 0.000 ms): <.main+174>
test/lang/emit.ci:20:[.046d30, .046d39) exec(1), time(1-1 / 0.001-0.001 ms): <.main+184>
test/lang/emit.ci:23:[.046d39, .046d43) exec(1), time(1-1 / 0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.046d43, .046d48) exec(1), time(0 / 0.000 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.046d48, .046d4d) exec(1), time(0 / 0.000 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.046d4d, .046d52) exec(1), time(1-1 / 0.001-0.001 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.046d52, .046d57) exec(1), time(1-1 / 0.001-0.001 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.046d57, .046d58) exec(1), time(1-1 / 0.001-0.001 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.046d58, .046d59) exec(1), time(0 / 0.000 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.046d59, .046d5a) exec(1), time(0 / 0.000 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.046d5a, .046d5f) exec(1), time(0 / 0.000 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.046d5f, .046d61) exec(1), time(0 / 0.000 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.046d61, .046d6b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.046d6b, .046d74) exec(1), time(1-1 / 0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.046d74, .046d79) exec(1), time(1-1 / 0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.046d79, .046d8a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.046d8a, .046da2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.046da2, .046db4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.046db4, .046dd2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.046dd2, .046df3) exec(1), time(4-4 / 0.004-0.004 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.046df3, .046e0e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.046e0e, .046e35) exec(1), time(4-4 / 0.004-0.004 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.046e35, .046e56) exec(1), time(3-3 / 0.003-0.003 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.046e56, .046e71) exec(1), time(3-3 / 0.003-0.003 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.046e71, .046e98) exec(1), time(4-4 / 0.004-0.004 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.046e98, .046ead) exec(1), time(2-2 / 0.002-0.002 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.046ead, .046ebe) exec(1), time(2-2 / 0.002-0.002 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.046ebe, .046ec9) exec(1), time(2-2 / 0.002-0.002 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.046ec9, .046ed4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.046ed4, .046ef3) exec(1), time(4-4 / 0.004-0.004 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.046ef3, .046f12) exec(1), time(4-4 / 0.004-0.004 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.046f12, .046f50) exec(1), time(2-2 / 0.002-0.002 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.046f50, .046f8e) exec(1), time(6-6 / 0.006-0.006 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.046f8e, .046fc0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.046fc0, .046ff2) exec(1), time(6-6 / 0.006-0.006 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.046ff2, .047038) exec(1), time(2-2 / 0.002-0.002 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.047038, .04707e) exec(1), time(6-6 / 0.006-0.006 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.04707e, .0470d7) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.0470d7, .047130) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.047130, .04717d) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.04717d, .0471ca) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.0471ca, .04722b) exec(1), time(10-10 / 0.010-0.010 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.04722b, .04728c) exec(1), time(11-11 / 0.011-0.011 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.04728c, .0472e5) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.0472e5, .04733e) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.04733e, .04738b) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.04738b, .0473d8) exec(1), time(9-9 / 0.009-0.009 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.0473d8, .047439) exec(1), time(11-11 / 0.011-0.011 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.047439, .04749a) exec(1), time(11-11 / 0.011-0.011 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.04749a, .04749f) exec(1), time(0 / 0.000 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.04749f, .0474a4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.0474a4, .0474a9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.0474a9, .0474ae) exec(1), time(0 / 0.000 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.0474ae, .0474b3) exec(1), time(0 / 0.000 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.0474b3, .0474bc) exec(1), time(0 / 0.000 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.0474bc, .0474d2) exec(1), time(3-3 / 0.003-0.003 ms): <.main+2116>
test/lang/initByRef.ci:8:[.0474d2, .0474d7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2138>
test/lang/initByRef.ci:9:[.0474d7, .0474dc) exec(1), time(0 / 0.000 ms): <.main+2143>
test/lang/initByRef.ci:10:[.0474dc, .0474e6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.0474e6, .0474e9) exec(1), time(0 / 0.000 ms): <.main+2158>
test/lang/initByRef.ci:13:[.0474e9, .0474eb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2161>
test/lang/initByRef.ci:14:[.0474eb, .0474ed) exec(1), time(0 / 0.000 ms): <.main+2163>
test/lang/initByRef.ci:16:[.0474ed, .0474f2) exec(1), time(0 / 0.000 ms): <.main+2165>
test/lang/initByRef.ci:17:[.0474f2, .0474f7) exec(1), time(0 / 0.000 ms): <.main+2170>
test/lang/initByRef.ci:18:[.0474f7, .047501) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.047501, .047506) exec(1), time(0 / 0.000 ms): <.main+2185>
test/lang/initByRef.ci:20:[.047506, .04750b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2190>
test/lang/initByRef.ci:21:[.04750b, .047510) exec(1), time(0 / 0.000 ms): <.main+2195>
test/lang/initByRef.ci:23:[.047510, .047515) exec(1), time(0 / 0.000 ms): <.main+2200>
test/lang/initByRef.ci:24:[.047515, .04751f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2205>
test/lang/initByRef.ci:25:[.04751f, .047524) exec(1), time(0 / 0.000 ms): <.main+2215>
test/lang/initByRef.ci:27:[.047524, .047528) exec(1), time(0 / 0.000 ms): <.main+2220>
test/lang/initByRef.ci:28:[.047528, .04752a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2224>
test/lang/initByRef.ci:29:[.04752a, .04752c) exec(1), time(0 / 0.000 ms): <.main+2226>
test/lang/initByRef.ci:30:[.04752c, .04752e) exec(1), time(0 / 0.000 ms): <.main+2228>
test/lang/initByRef.ci:31:[.04752e, .047530) exec(1), time(0 / 0.000 ms): <.main+2230>
test/lang/initByRef.ci:32:[.047530, .047532) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2232>
test/lang/initByRef.ci:35:[.047532, .047537) exec(1), time(0 / 0.000 ms): <.main+2234>
test/lang/initByRef.ci:36:[.047537, .04753c) exec(1), time(0 / 0.000 ms): <.main+2239>
test/lang/initByRef.ci:37:[.04753c, .047541) exec(1), time(0 / 0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.047541, .047546) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2249>
test/lang/initByRef.ci:39:[.047546, .04754b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2254>
test/lang/initByRef.ci:40:[.04754b, .047550) exec(1), time(0 / 0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.047550, .047555) exec(1), time(0 / 0.000 ms): <.main+2264>
test/lang/initByRef.ci:42:[.047555, .04755a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2269>
test/lang/initByRef.ci:43:[.04755a, .04755f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2274>
test/lang/initByRef.ci:44:[.04755f, .047564) exec(1), time(0 / 0.000 ms): <.main+2279>
test/lang/initByRef.ci:45:[.047564, .047569) exec(1), time(0 / 0.000 ms): <.main+2284>
test/lang/initByRef.ci:46:[.047569, .04756e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2289>
test/lang/initByRef.ci:47:[.04756e, .047573) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2294>
test/lang/initByRef.ci:48:[.047573, .047578) exec(1), time(0 / 0.000 ms): <.main+2299>
test/lang/initByRef.ci:49:[.047578, .04757d) exec(1), time(0 / 0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.04757d, .047582) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2309>
test/lang/initByRef.ci:51:[.047582, .047587) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2314>
test/lang/initByRef.ci:52:[.047587, .04758c) exec(1), time(0 / 0.000 ms): <.main+2319>
test/lang/initByRef.ci:55:[.04758c, .047596) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.047596, .0475a0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.0475a0, .0475aa) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.0475aa, .0475b4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.0475b4, .0475be) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.0475be, .0475c8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2374>
test/lang/initByRef.ci:61:[.0475c8, .0475d2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.0475d2, .0475dc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2394>
test/lang/initByRef.ci:63:[.0475dc, .0475e6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2404>
test/lang/initByRef.ci:64:[.0475e6, .0475f0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.0475f0, .0475fa) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.0475fa, .047604) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.047604, .04760e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.04760e, .047618) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2454>
test/lang/initByRef.ci:69:[.047618, .047622) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.047622, .04762c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.04762c, .047636) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2484>
test/lang/initByRef.ci:72:[.047636, .047640) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.047640, .047645) exec(1), time(0 / 0.000 ms): <.main+2504>
test/lang/initByRef.ci:76:[.047645, .04764a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2509>
test/lang/initByRef.ci:77:[.04764a, .04764f) exec(1), time(0 / 0.000 ms): <.main+2514>
test/lang/initByRef.ci:78:[.04764f, .047654) exec(1), time(0 / 0.000 ms): <.main+2519>
test/lang/initByRef.ci:79:[.047654, .047659) exec(1), time(0 / 0.000 ms): <.main+2524>
test/lang/initByRef.ci:80:[.047659, .04765e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2529>
test/lang/initByRef.ci:81:[.04765e, .047663) exec(1), time(0 / 0.000 ms): <.main+2534>
test/lang/initByRef.ci:82:[.047663, .047668) exec(1), time(0 / 0.000 ms): <.main+2539>
test/lang/initByRef.ci:83:[.047668, .04766d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2544>
test/lang/initByRef.ci:84:[.04766d, .047672) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2549>
test/lang/initByRef.ci:85:[.047672, .047677) exec(1), time(0 / 0.000 ms): <.main+2554>
test/lang/initByRef.ci:86:[.047677, .04767c) exec(1), time(0 / 0.000 ms): <.main+2559>
test/lang/initByRef.ci:87:[.04767c, .047681) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2564>
test/lang/initByRef.ci:88:[.047681, .047686) exec(1), time(0 / 0.000 ms): <.main+2569>
test/lang/initByRef.ci:89:[.047686, .04768b) exec(1), time(0 / 0.000 ms): <.main+2574>
test/lang/initByRef.ci:90:[.04768b, .047690) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2579>
test/lang/initByRef.ci:91:[.047690, .047695) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2584>
test/lang/initByRef.ci:92:[.047695, .04769a) exec(1), time(0 / 0.000 ms): <.main+2589>
test/lang/initByRef.ci:95:[.04769a, .04769f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:96:[.04769f, .0476a9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.0476a9, .0476ae) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2609>
test/lang/initByRef.ci:99:[.0476ae, .0476b3) exec(1), time(0 / 0.000 ms): <.main+2614>
test/lang/initByRef.ci:105:[.0476b3, .0476ba) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.0476ba, .0476bc) exec(1), time(0 / 0.000 ms): <.main+2626>
test/lang/function.ci:11:[.0476bc, .0476d1) exec(1), time(22-22 / 0.022-0.022 ms): <.main+2628>
test/lang/function.ci:14:[.0476d1, .0476d6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2649>
test/lang/function.ci:17:[.0476d6, .0476e8) exec(1), time(18-18 / 0.018-0.018 ms): <.main+2654>
test/lang/function.ci:20:[.0476e8, .0476ed) exec(1), time(0 / 0.000 ms): <.main+2672>
test/lang/function.ci:23:[.0476ed, .0476ff) exec(1), time(18-18 / 0.018-0.018 ms): <.main+2677>
test/lang/function.ci:26:[.0476ff, .047701) exec(1), time(0 / 0.000 ms): <.main+2695>
test/lang/function.ci:29:[.047701, .047713) exec(1), time(17-17 / 0.017-0.017 ms): <.main+2697>
test/lang/function.ci:45:[.047713, .047723) exec(1), time(14878-14878 / 14.878-14.878 ms): <.main+2715>
test/lang/reflect.ci:3:[.047723, .047727) exec(1), time(0 / 0.000 ms): <.main+2731>
test/lang/reflect.ci:4:[.047727, .04772b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2735>
test/lang/reflect.ci:5:[.04772b, .04772f) exec(1), time(0 / 0.000 ms): <.main+2739>
test/lang/reflect.ci:6:[.04772f, .047733) exec(1), time(0 / 0.000 ms): <.main+2743>
test/lang/reflect.ci:7:[.047733, .047737) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2747>
test/lang/reflect.ci:8:[.047737, .04773b) exec(1), time(0 / 0.000 ms): <.main+2751>
test/lang/reflect.ci:9:[.04773b, .04773f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:10:[.04773f, .047743) exec(1), time(0 / 0.000 ms): <.main+2759>
test/lang/reflect.ci:11:[.047743, .047747) exec(1), time(0 / 0.000 ms): <.main+2763>
test/lang/reflect.ci:12:[.047747, .04774b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2767>
test/lang/reflect.ci:13:[.04774b, .04774f) exec(1), time(0 / 0.000 ms): <.main+2771>
test/lang/reflect.ci:14:[.04774f, .047753) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2775>
test/lang/reflect.ci:15:[.047753, .047757) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:16:[.047757, .04775b) exec(1), time(0 / 0.000 ms): <.main+2783>
test/lang/reflect.ci:17:[.04775b, .04775f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2787>
test/lang/reflect.ci:18:[.04775f, .047763) exec(1), time(0 / 0.000 ms): <.main+2791>
test/lang/reflect.ci:19:[.047763, .047767) exec(1), time(0 / 0.000 ms): <.main+2795>
test/lang/reflect.ci:20:[.047767, .04776b) exec(1), time(0 / 0.000 ms): <.main+2799>
test/lang/reflect.ci:30:[.04776b, .047770) exec(1), time(0 / 0.000 ms): <.main+2803>
test/lang/reflect.ci:31:[.047770, .047776) exec(1), time(26-26 / 0.026-0.026 ms): <.main+2808>
test/lang/reflect.ci:32:[.047776, .04777d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2814>
test/lang/reflect.ci:33:[.04777d, .047784) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2821>
test/lang/reflect.ci:34:[.047784, .04778a) exec(1), time(17-17 / 0.017-0.017 ms): <.main+2828>
test/lang/reflect.ci:35:[.04778a, .047790) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2834>
test/lang/reflect.ci:37:[.047790, .047796) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2840>
test/lang/reflect.ci:38:[.047796, .04779c) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2846>
test/lang/reflect.ci:39:[.04779c, .0477a3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2852>
test/lang/reflect.ci:40:[.0477a3, .0477aa) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2859>
test/lang/reflect.ci:41:[.0477aa, .0477b0) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2866>
test/lang/reflect.ci:42:[.0477b0, .0477b6) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2872>
test/lang/reflect.ci:44:[.0477b6, .0477bc) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2878>
test/lang/reflect.ci:45:[.0477bc, .0477c3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2884>
test/lang/reflect.ci:46:[.0477c3, .0477ca) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2891>
test/lang/reflect.ci:48:[.0477ca, .0477d0) exec(1), time(16-16 / 0.016-0.016 ms): <.main+2898>
test/lang/reflect.ci:49:[.0477d0, .0477d7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2904>
test/lang/reflect.ci:50:[.0477d7, .0477de) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2911>
test/stdc/number.ci:3:[.0477de, .0477e7) exec(1), time(0 / 0.000 ms): <.main+2918>
test/stdc/number.ci:4:[.0477e7, .0477f0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2927>
test/stdc/number.ci:6:[.0477f0, .0477f3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2936>
test/stdc/number.ci:7:[.0477f3, .0477f6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.0477f6, .0477fd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2942>
test/stdc/number.ci:15:[.0477fd, .047804) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2949>
test/stdc/number.ci:16:[.047804, .04780b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.04780b, .047827) exec(1), time(7-7 / 0.007-0.007 ms): <.main+2963>
test/stdc/number.ci:19:[.047827, .047841) exec(1), time(7-7 / 0.007-0.007 ms): <.main+2991>
test/stdc/number.ci:21:[.047841, .047851) exec(1), time(21-21 / 0.021-0.021 ms): <.main+3017>
test/stdc/number.ci:22:[.047851, .047861) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3033>
test/stdc/number.ci:23:[.047861, .04786d) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3049>
test/stdc/number.ci:25:[.04786d, .04787d) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3061>
test/stdc/number.ci:26:[.04787d, .04788d) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3077>
test/stdc/number.ci:27:[.04788d, .047899) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3093>
test/stdc/number.ci:29:[.047899, .0478a9) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3105>
test/stdc/number.ci:30:[.0478a9, .0478b9) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3121>
test/stdc/number.ci:31:[.0478b9, .0478c5) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3137>
test/stdc/number.ci:33:[.0478c5, .0478d5) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3149>
test/stdc/number.ci:34:[.0478d5, .0478e5) exec(1), time(37-37 / 0.037-0.037 ms): <.main+3165>
test/stdc/number.ci:35:[.0478e5, .0478f1) exec(1), time(29-29 / 0.029-0.029 ms): <.main+3181>
test/stdc/number.ci:37:[.0478f1, .047901) exec(1), time(52-52 / 0.052-0.052 ms): <.main+3193>
test/stdc/number.ci:38:[.047901, .047911) exec(1), time(36-36 / 0.036-0.036 ms): <.main+3209>
test/stdc/number.ci:39:[.047911, .047921) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3225>
test/stdc/number.ci:40:[.047921, .04792d) exec(1), time(20-20 / 0.020-0.020 ms): <.main+3241>
test/stdc/number.ci:41:[.04792d, .04793a) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3253>
test/stdc/number.ci:42:[.04793a, .04794c) exec(1), time(20-20 / 0.020-0.020 ms): <.main+3266>
test/stdc/number.ci:43:[.04794c, .047955) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3284>
test/stdc/number.ci:44:[.047955, .047964) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3293>
test/stdc/number.ci:46:[.047964, .047970) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3308>
test/stdc/number.ci:47:[.047970, .04797c) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3320>
test/stdc/number.ci:48:[.04797c, .047988) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3332>
test/stdc/number.ci:49:[.047988, .047994) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3344>
test/stdc/number.ci:50:[.047994, .04799d) exec(1), time(15-15 / 0.015-0.015 ms): <.main+3356>
test/stdc/number.ci:51:[.04799d, .0479ab) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3365>
test/stdc/number.ci:52:[.0479ab, .0479b4) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3379>
test/stdc/number.ci:53:[.0479b4, .0479bf) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3388>
test/stdc/number.ci:55:[.0479bf, .0479c5) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3399>
test/stdc/number.ci:56:[.0479c5, .0479cb) exec(1), time(15-15 / 0.015-0.015 ms): <.main+3405>
test/stdc/number.ci:57:[.0479cb, .0479d1) exec(1), time(15-15 / 0.015-0.015 ms): <.main+3411>
test/stdc/number.ci:58:[.0479d1, .0479d7) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3417>
test/stdc/number.ci:59:[.0479d7, .0479dd) exec(1), time(38-38 / 0.038-0.038 ms): <.main+3423>
test/stdc/number.ci:60:[.0479dd, .0479e3) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3429>
test/stdc/number.ci:62:[.0479e3, .0479ef) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3435>
test/stdc/number.ci:63:[.0479ef, .0479fb) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3447>
test/stdc/number.ci:65:[.0479fb, .047a09) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3459>
test/stdc/number.ci:66:[.047a09, .047a17) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3473>
test/stdc/memory.ci:7:[.047a17, .047a25) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3487>
test/stdc/memory.ci:8:[.047a25, .047a33) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3501>
test/stdc/memory.ci:9:[.047a33, .047a41) exec(1), time(17-17 / 0.017-0.017 ms): <.main+3515>
test/stdc/memory.ci:10:[.047a41, .047a4f) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3529>
test/stdc/memory.ci:13:[.047a4f, .047a5f) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3543>
test/stdc/memory.ci:14:[.047a5f, .047a70) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3559>
test/stdc/memory.ci:17:[.047a70, .047a7b) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3576>
test/stdc/memory.ci:18:[.047a7b, .047a86) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3587>
test/stdc/memory.ci:19:[.047a86, .047a91) exec(1), time(16-16 / 0.016-0.016 ms): <.main+3598>
test/stdc/memory.ci:20:[.047a91, .047a9c) exec(1), time(37-37 / 0.037-0.037 ms): <.main+3609>
test/stdc/memory.ci:23:[.047a9c, .047aa5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3620>
test/stdc/memory.ci:24:[.047aa5, .047aae) exec(1), time(0 / 0.000 ms): <.main+3629>
test/stdc/memory.ci:26:[.047aae, .047ad0) exec(1), time(48-48 / 0.048-0.048 ms): <.main+3638>
test/stdc/memory.ci:27:[.047ad0, .047af2) exec(1), time(34-34 / 0.034-0.034 ms): <.main+3672>
test/stdc/memory.ci:29:[.047af2, .047b06) exec(1), time(37-37 / 0.037-0.037 ms): <.main+3706>
test/stdc/memory.ci:30:[.047b06, .047b17) exec(1), time(18-18 / 0.018-0.018 ms): <.main+3726>
test/stdc/memory.ci:32:[.047b17, .047b39) exec(1), time(45-45 / 0.045-0.045 ms): <.main+3743>
test/stdc/memory.ci:33:[.047b39, .047b5b) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.047b5b, .047b69) exec(1), time(48-48 / 0.048-0.048 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.047b69, .047b77) exec(1), time(19-19 / 0.019-0.019 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.047b77, .047b85) exec(1), time(1187-1187 / 1.187-1.187 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.047b85, .047b93) exec(1), time(33-33 / 0.033-0.033 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.047b93, .047ba1) exec(1), time(33-33 / 0.033-0.033 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.047ba1, .047baf) exec(1), time(33-33 / 0.033-0.033 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.047baf, .047bbd) exec(1), time(137-137 / 0.137-0.137 ms): <.main+3895>
test/lang/array.ci:49:[.047bbd, .047bc1) exec(1), time(0 / 0.000 ms): <.main+3909>
test/lang/array.ci:50:[.047bc1, .047bc5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3913>
test/lang/array.ci:51:[.047bc5, .047bc9) exec(1), time(0 / 0.000 ms): <.main+3917>
test/lang/array.ci:55:[.047bce, .047be2) exec(7), time(34-34 / 0.034-0.034 ms): <.main+3926>
test/lang/array.ci:54:[.047be2, .047be6) exec(7), time(3-3 / 0.003-0.003 ms): <.main+3946>
test/lang/array.ci:54:[.047be6, .047bf2) exec(8), time(19-19 / 0.019-0.019 ms): <.main+3950>
test/lang/array.ci:54:[.047bc9, .047bf6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+3921>
test/lang/array.ci:59:[.047bf6, .047bfb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3966>
test/lang/array.ci:60:[.047bfb, .047c01) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.047c01, .047c05) exec(1), time(0 / 0.000 ms): <.main+3977>
test/lang/array.ci:64:[.047c05, .047c0e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+3981>
test/lang/array.ci:67:[.047c0e, .047c10) exec(1), time(0 / 0.000 ms): <.main+3990>
test/lang/array.ci:68:[.047c10, .047c12) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3992>
test/lang/array.ci:71:[.047c12, .047c14) exec(1), time(0 / 0.000 ms): <.main+3994>
test/lang/array.ci:81:[.047c14, .047c18) exec(1), time(0 / 0.000 ms): <.main+3996>
test/lang/array.ci:82:[.047c18, .047c2e) exec(1), time(20-20 / 0.020-0.020 ms): <.main+4000>
test/lang/array.ci:83:[.047c2e, .047c50) exec(1), time(81-81 / 0.081-0.081 ms): <.main+4022>
test/lang/array.ci:84:[.047c50, .047c72) exec(1), time(110-110 / 0.110-0.110 ms): <.main+4056>
test/lang/array.ci:86:[.047c72, .047c77) exec(1), time(0 / 0.000 ms): <.main+4090>
test/lang/array.ci:87:[.047c77, .047c97) exec(1), time(37-37 / 0.037-0.037 ms): <.main+4095>
test/lang/array.ci:88:[.047c97, .047cb7) exec(1), time(38-38 / 0.038-0.038 ms): <.main+4127>
test/lang/array.ci:90:[.047cb7, .047cc1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+4159>
test/lang/array.ci:91:[.047cc1, .047ce1) exec(1), time(35-35 / 0.035-0.035 ms): <.main+4169>
test/lang/array.ci:92:[.047ce1, .047d01) exec(1), time(36-36 / 0.036-0.036 ms): <.main+4201>
test/lang/array.ci:98:[.047d01, .047d34) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4233>
test/lang/array.ci:99:[.047d34, .047d67) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4284>
test/lang/array.ci:101:[.047d67, .047da2) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4335>
test/lang/array.ci:108:[.047da2, .047dbb) exec(1), time(19-19 / 0.019-0.019 ms): <.main+4394>
test/lang/array.ci:109:[.047dbb, .047dd1) exec(1), time(19-19 / 0.019-0.019 ms): <.main+4419>
test/lang/array.ci:110:[.047dd1, .047de7) exec(1), time(18-18 / 0.018-0.018 ms): <.main+4441>
test/lang/array.ci:112:[.047de7, .047e07) exec(1), time(43-43 / 0.043-0.043 ms): <.main+4463>
test/lang/array.ci:113:[.047e07, .047e24) exec(1), time(39-39 / 0.039-0.039 ms): <.main+4495>
test/lang/array.ci:114:[.047e24, .047e4c) exec(1), time(39-39 / 0.039-0.039 ms): <.main+4524>
test/lang/array.ci:115:[.047e4c, .047e6d) exec(1), time(43-43 / 0.043-0.043 ms): <.main+4564>
test/lang/array.ci:116:[.047e6d, .047e8e) exec(1), time(54-54 / 0.054-0.054 ms): <.main+4597>
test/lang/array.ci:119:[.047e93, .047e9c) exec(7), time(29-29 / 0.029-0.029 ms): <.main+4635>
test/lang/array.ci:120:[.047e9c, .047ed9) exec(7), time(32-32 / 0.032-0.032 ms): <.main+4644>
test/lang/array.ci:121:[.047ed9, .047f14) exec(7), time(53-53 / 0.053-0.053 ms): <.main+4705>
test/lang/array.ci:122:[.047f14, .047f4f) exec(7), time(33-33 / 0.033-0.033 ms): <.main+4764>
test/lang/array.ci:124:[.047f4f, .047f92) exec(7), time(169-169 / 0.169-0.169 ms): <.main+4823>
test/lang/array.ci:125:[.047f92, .047fd3) exec(7), time(165-165 / 0.165-0.165 ms): <.main+4890>
test/lang/array.ci:126:[.047fd3, .048014) exec(7), time(196-196 / 0.196-0.196 ms): <.main+4955>
test/lang/array.ci:128:[.048014, .048057) exec(7), time(216-216 / 0.216-0.216 ms): <.main+5020>
test/lang/array.ci:129:[.048057, .048098) exec(7), time(191-191 / 0.191-0.191 ms): <.main+5087>
test/lang/array.ci:130:[.048098, .0480d9) exec(7), time(182-182 / 0.182-0.182 ms): <.main+5152>
test/lang/array.ci:132:[.0480d9, .048121) exec(7), time(189-189 / 0.189-0.189 ms): <.main+5217>
test/lang/array.ci:134:[.048121, .048162) exec(7), time(183-183 / 0.183-0.183 ms): <.main+5289>
test/lang/array.ci:136:[.048162, .04819d) exec(7), time(32-32 / 0.032-0.032 ms): <.main+5354>
test/lang/array.ci:118:[.0481a1, .0481a5) exec(7), time(1-1 / 0.001-0.001 ms): <.main+5417>
test/lang/array.ci:118:[.0481a5, .0481b1) exec(8), time(19-19 / 0.019-0.019 ms): <.main+5421>
test/lang/array.ci:118:[.047e8e, .0481b5) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4630>
test/lang/member.ci:54:[.0481b9, .0481c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5441>
test/lang/member.ci:55:[.0481c0, .0481c7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5448>
test/lang/member.ci:56:[.0481c7, .0481ce) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5455>
test/lang/member.ci:57:[.0481ce, .0481d5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.0481d5, .0481dc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5469>
test/lang/member.ci:61:[.0481dc, .0481e3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.0481e3, .0481ea) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5483>
test/lang/member.ci:66:[.0481ea, .0481f1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5490>
test/lang/member.ci:53:[.0481b5, .0481f1) exec(1-1), time(0 / 0.000 ms): <.main+5437>
test/lang/method.ci:54:[.0481f5, .0481fc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5501>
test/lang/method.ci:55:[.0481fc, .048203) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5508>
::[.048203, .04820a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5515>
::[.04820a, .048211) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5522>
test/lang/method.ci:53:[.0481f1, .048211) exec(1-1), time(0 / 0.000 ms): <.main+5497>
test/lang/method.ci:64:[.048215, .04821c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5533>
test/lang/method.ci:65:[.04821c, .048223) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5540>
::[.048223, .048229) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5547>
::[.048229, .048230) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5553>
test/lang/method.ci:63:[.048211, .048230) exec(1-1), time(0 / 0.000 ms): <.main+5529>
test/lang/method.ci:69:[.048230, .048239) exec(1), time(109-109 / 0.109-0.109 ms): <.main+5560>
test/lang/method.ci:70:[.048239, .048242) exec(1), time(105-105 / 0.105-0.105 ms): <.main+5569>
test/lang/method.ci:73:[.048242, .04824e) exec(1), time(102-102 / 0.102-0.102 ms): <.main+5578>
test/lang/method.ci:84:[.04824e, .04825a) exec(1), time(103-103 / 0.103-0.103 ms): <.main+5590>
test/lang/method.ci:85:[.04825a, .048266) exec(1), time(132-132 / 0.132-0.132 ms): <.main+5602>
test/lang/method.ci:86:[.048266, .048272) exec(1), time(147-147 / 0.147-0.147 ms): <.main+5614>
test/lang/method.ci:89:[.048272, .04827e) exec(1), time(120-120 / 0.120-0.120 ms): <.main+5626>
test/lang/method.ci:90:[.04827e, .04828a) exec(1), time(103-103 / 0.103-0.103 ms): <.main+5638>
test/lang/method.ci:91:[.04828a, .048296) exec(1), time(102-102 / 0.102-0.102 ms): <.main+5650>
test/lang/recUnion.ci:26:[.04829a, .0482a0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5666>
test/lang/recUnion.ci:26:[.0482a0, .0482a6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5672>
test/lang/recUnion.ci:26:[.0482a6, .0482ac) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5678>
test/lang/recUnion.ci:26:[.048296, .0482ac) exec(1-1), time(0 / 0.000 ms): <.main+5662>
test/lang/recUnion.ci:27:[.0482b0, .0482b6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5688>
test/lang/recUnion.ci:27:[.0482b6, .0482c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5694>
test/lang/recUnion.ci:27:[.0482c0, .0482c6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5704>
test/lang/recUnion.ci:27:[.0482ac, .0482c6) exec(1-1), time(0 / 0.000 ms): <.main+5684>
test/lang/recUnion.ci:28:[.0482ca, .0482d4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5714>
test/lang/recUnion.ci:28:[.0482d4, .0482de) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5724>
test/lang/recUnion.ci:28:[.0482de, .0482e8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5734>
test/lang/recUnion.ci:28:[.0482c6, .0482e8) exec(1-1), time(0 / 0.000 ms): <.main+5710>
test/lang/recUnion.ci:30:[.0482ec, .0482f3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5748>
test/lang/recUnion.ci:30:[.0482e8, .0482f3) exec(1-1), time(0 / 0.000 ms): <.main+5744>
test/lang/recUnion.ci:31:[.0482f7, .0482fd) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5759>
test/lang/recUnion.ci:31:[.0482fd, .048303) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5765>
test/lang/recUnion.ci:31:[.048303, .04830d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5771>
test/lang/recUnion.ci:31:[.0482f3, .04830d) exec(1-1), time(0 / 0.000 ms): <.main+5755>
test/lang/useOperator.ci:5:[.04830d, .048312) exec(1), time(0 / 0.000 ms): <.main+5781>
test/lang/useOperator.ci:7:[.048312, .048317) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5786>
test/lang/useOperator.ci:8:[.048317, .04831c) exec(1), time(0 / 0.000 ms): <.main+5791>
test/lang/useOperator.ci:17:[.04831c, .048327) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5796>
test/lang/useOperator.ci:18:[.048327, .048332) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5807>
test/lang/useOperator.ci:19:[.048332, .04833d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5818>
test/lang/useOperator.ci:22:[.04833d, .048343) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5829>
test/lang/useOperator.ci:23:[.048343, .04834e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5835>
test/lang/useOperator.ci:24:[.04834e, .04835a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5846>
test/lang/useOperator.ci:25:[.04835a, .048365) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5858>
test/lang/useOperator.ci:26:[.048365, .048371) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5869>
test/lang/useOperator.ci:27:[.048371, .04837c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5881>
test/lang/useOperator.ci:28:[.04837c, .048388) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5892>
test/lang/useOperator.ci:30:[.048388, .04838d) exec(1), time(0 / 0.000 ms): <.main+5904>
test/lang/useOperator.ci:31:[.04838d, .048392) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5909>
test/lang/useOperator.ci:32:[.048392, .048397) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5914>
test/lang/useOperator.ci:33:[.048397, .04839d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5919>
test/lang/useOperator.ci:34:[.04839d, .0483a3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5925>
test/lang/useOperator.ci:35:[.0483a3, .0483ae) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5931>
test/lang/useOperator.ci:36:[.0483ae, .0483b9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5942>
test/lang/useOperator.ci:37:[.0483b9, .0483c4) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5953>
test/lang/useOperator.ci:38:[.0483c4, .0483cf) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5964>
test/lang/useOperator.ci:39:[.0483cf, .0483da) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5975>
test/lang/useOperator.ci:40:[.0483da, .0483e5) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5986>
test/lang/useOperator.ci:41:[.0483e5, .0483f0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5997>
test/lang/useOperator.ci:42:[.0483f0, .0483fb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6008>
test/lang/useOperator.ci:43:[.0483fb, .048403) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6019>
test/lang/useOperator.ci:44:[.048403, .04840b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6027>
test/lang/useOperator.ci:45:[.04840b, .048412) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6035>
test/lang/useOperator.ci:46:[.048412, .04841d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6042>
test/lang/useOperator.ci:47:[.04841d, .048429) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6053>
test/lang/useOperator.ci:48:[.048429, .048434) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6065>
test/lang/useOperator.ci:49:[.048434, .048440) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6076>
test/lang/useOperator.ci:50:[.048440, .04844b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6088>
test/lang/useOperator.ci:51:[.04844b, .048457) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6099>
test/lang/useOperator.ci:53:[.048457, .04845c) exec(1), time(0 / 0.000 ms): <.main+6111>
test/lang/useOperator.ci:54:[.04845c, .048461) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6116>
test/lang/useOperator.ci:55:[.048461, .048466) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6121>
test/lang/useOperator.ci:56:[.048466, .04846c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6126>
test/lang/useOperator.ci:57:[.04846c, .048472) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6132>
test/lang/useOperator.ci:58:[.048472, .04847d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6138>
test/lang/useOperator.ci:59:[.04847d, .048488) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6149>
test/lang/useOperator.ci:60:[.048488, .048493) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6160>
test/lang/useOperator.ci:61:[.048493, .04849e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6171>
test/lang/useOperator.ci:62:[.04849e, .0484a9) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6182>
test/lang/useOperator.ci:63:[.0484a9, .0484b4) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6193>
test/lang/useOperator.ci:64:[.0484b4, .0484bf) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6204>
test/lang/useOperator.ci:65:[.0484bf, .0484ca) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6215>
test/lang/useOperator.ci:66:[.0484ca, .0484d2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6226>
test/lang/useOperator.ci:67:[.0484d2, .0484da) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6234>
test/lang/useOperator.ci:68:[.0484da, .0484e1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6242>
test/lang/useOperator.ci:69:[.0484e1, .0484ec) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6249>
test/lang/useOperator.ci:70:[.0484ec, .0484f8) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6260>
test/lang/useOperator.ci:71:[.0484f8, .048503) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6272>
test/lang/useOperator.ci:72:[.048503, .04850f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6283>
test/lang/useOperator.ci:73:[.04850f, .04851a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6295>
test/lang/useOperator.ci:74:[.04851a, .048526) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6306>
test/lang/useOperator.ci:76:[.048526, .04852b) exec(1), time(0 / 0.000 ms): <.main+6318>
test/lang/useOperator.ci:77:[.04852b, .048530) exec(1), time(0 / 0.000 ms): <.main+6323>
test/lang/useOperator.ci:78:[.048530, .048535) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6328>
test/lang/useOperator.ci:79:[.048535, .04853b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6333>
test/lang/useOperator.ci:80:[.04853b, .048541) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6339>
test/lang/useOperator.ci:81:[.048541, .04854c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6345>
test/lang/useOperator.ci:82:[.04854c, .048557) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6356>
test/lang/useOperator.ci:83:[.048557, .048562) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6367>
test/lang/useOperator.ci:84:[.048562, .04856d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6378>
test/lang/useOperator.ci:85:[.04856d, .048578) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6389>
test/lang/useOperator.ci:86:[.048578, .048583) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6400>
test/lang/useOperator.ci:87:[.048583, .04858e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6411>
test/lang/useOperator.ci:88:[.04858e, .048599) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6422>
test/lang/useOperator.ci:89:[.048599, .0485a1) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6433>
test/lang/useOperator.ci:90:[.0485a1, .0485a9) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6441>
test/lang/useOperator.ci:91:[.0485a9, .0485b0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6449>
test/lang/useOperator.ci:92:[.0485b0, .0485bb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6456>
test/lang/useOperator.ci:93:[.0485bb, .0485c7) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6467>
test/lang/useOperator.ci:94:[.0485c7, .0485d2) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6479>
test/lang/useOperator.ci:95:[.0485d2, .0485de) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6490>
test/lang/useOperator.ci:96:[.0485de, .0485e9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6502>
test/lang/useOperator.ci:97:[.0485e9, .0485f5) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6513>
test/lang/useOperator.ci:99:[.0485f5, .0485fa) exec(1), time(0 / 0.000 ms): <.main+6525>
test/lang/useOperator.ci:100:[.0485fa, .0485ff) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6530>
test/lang/useOperator.ci:101:[.0485ff, .048604) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6535>
test/lang/useOperator.ci:102:[.048604, .04860a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6540>
test/lang/useOperator.ci:103:[.04860a, .048610) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6546>
test/lang/useOperator.ci:104:[.048610, .04861b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6552>
test/lang/useOperator.ci:105:[.04861b, .048626) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6563>
test/lang/useOperator.ci:106:[.048626, .048631) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6574>
test/lang/useOperator.ci:107:[.048631, .04863c) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6585>
test/lang/useOperator.ci:108:[.04863c, .048647) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6596>
test/lang/useOperator.ci:109:[.048647, .048652) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6607>
test/lang/useOperator.ci:110:[.048652, .04865d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6618>
test/lang/useOperator.ci:111:[.04865d, .048668) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6629>
test/lang/useOperator.ci:112:[.048668, .048670) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6640>
test/lang/useOperator.ci:113:[.048670, .048678) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6648>
test/lang/useOperator.ci:114:[.048678, .04867f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6656>
test/lang/useOperator.ci:115:[.04867f, .04868a) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6663>
test/lang/useOperator.ci:116:[.04868a, .048696) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6674>
test/lang/useOperator.ci:117:[.048696, .0486a1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6686>
test/lang/useOperator.ci:118:[.0486a1, .0486ad) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6697>
test/lang/useOperator.ci:119:[.0486ad, .0486b8) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6709>
test/lang/useOperator.ci:120:[.0486b8, .0486c4) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6720>
test/lang/useOperator.ci:122:[.0486c4, .0486c9) exec(1), time(0 / 0.000 ms): <.main+6732>
test/lang/useOperator.ci:123:[.0486c9, .0486ce) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6737>
test/lang/useOperator.ci:124:[.0486ce, .0486d3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6742>
test/lang/useOperator.ci:125:[.0486d3, .0486d9) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6747>
test/lang/useOperator.ci:126:[.0486d9, .0486df) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6753>
test/lang/useOperator.ci:127:[.0486df, .0486ea) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6759>
test/lang/useOperator.ci:128:[.0486ea, .0486f5) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6770>
test/lang/useOperator.ci:129:[.0486f5, .048700) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6781>
test/lang/useOperator.ci:130:[.048700, .04870b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6792>
test/lang/useOperator.ci:131:[.04870b, .048716) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6803>
test/lang/useOperator.ci:132:[.048716, .048721) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6814>
test/lang/useOperator.ci:133:[.048721, .04872c) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6825>
test/lang/useOperator.ci:134:[.04872c, .048737) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6836>
test/lang/useOperator.ci:135:[.048737, .04873f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6847>
test/lang/useOperator.ci:136:[.04873f, .048747) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6855>
test/lang/useOperator.ci:137:[.048747, .04874e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6863>
test/lang/useOperator.ci:138:[.04874e, .048759) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6870>
test/lang/useOperator.ci:139:[.048759, .048765) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6881>
test/lang/useOperator.ci:140:[.048765, .048770) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6893>
test/lang/useOperator.ci:141:[.048770, .04877c) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6904>
test/lang/useOperator.ci:142:[.04877c, .048787) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6916>
test/lang/useOperator.ci:143:[.048787, .048793) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6927>
test/lang/useOperator.ci:145:[.048793, .048798) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6939>
test/lang/useOperator.ci:146:[.048798, .04879d) exec(1), time(0 / 0.000 ms): <.main+6944>
test/lang/useOperator.ci:147:[.04879d, .04879f) exec(1), time(0 / 0.000 ms): <.main+6949>
test/lang/useOperator.ci:148:[.04879f, .0487a2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6951>
test/lang/useOperator.ci:149:[.0487a2, .0487a5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6954>
test/lang/useOperator.ci:150:[.0487a5, .0487aa) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6957>
test/lang/useOperator.ci:151:[.0487aa, .0487af) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6962>
test/lang/useOperator.ci:152:[.0487af, .0487b4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6967>
test/lang/useOperator.ci:153:[.0487b4, .0487b9) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6972>
test/lang/useOperator.ci:154:[.0487b9, .0487be) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6977>
test/lang/useOperator.ci:155:[.0487be, .0487c3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6982>
test/lang/useOperator.ci:156:[.0487c3, .0487c8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6987>
test/lang/useOperator.ci:157:[.0487c8, .0487cd) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6992>
test/lang/useOperator.ci:158:[.0487cd, .0487d2) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6997>
test/lang/useOperator.ci:159:[.0487d2, .0487d7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7002>
test/lang/useOperator.ci:160:[.0487d7, .0487db) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7007>
test/lang/useOperator.ci:161:[.0487db, .0487e0) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7011>
test/lang/useOperator.ci:162:[.0487e0, .0487e6) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7016>
test/lang/useOperator.ci:163:[.0487e6, .0487eb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7022>
test/lang/useOperator.ci:164:[.0487eb, .0487f1) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7027>
test/lang/useOperator.ci:165:[.0487f1, .0487f6) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7033>
test/lang/useOperator.ci:166:[.0487f6, .0487fc) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7038>
test/lang/useOperator.ci:168:[.0487fc, .048801) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7044>
test/lang/useOperator.ci:169:[.048801, .048806) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7049>
test/lang/useOperator.ci:170:[.048806, .048808) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7054>
test/lang/useOperator.ci:171:[.048808, .04880b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7056>
test/lang/useOperator.ci:172:[.04880b, .04880e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7059>
test/lang/useOperator.ci:173:[.04880e, .048813) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7062>
test/lang/useOperator.ci:174:[.048813, .048818) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7067>
test/lang/useOperator.ci:175:[.048818, .04881d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7072>
test/lang/useOperator.ci:176:[.04881d, .048822) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7077>
test/lang/useOperator.ci:177:[.048822, .048827) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7082>
test/lang/useOperator.ci:178:[.048827, .04882c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7087>
test/lang/useOperator.ci:179:[.04882c, .048831) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7092>
test/lang/useOperator.ci:180:[.048831, .048836) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7097>
test/lang/useOperator.ci:181:[.048836, .04883b) exec(1), time(17-17 / 0.017-0.017 ms): <.main+7102>
test/lang/useOperator.ci:182:[.04883b, .048840) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7107>
test/lang/useOperator.ci:183:[.048840, .048844) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7112>
test/lang/useOperator.ci:184:[.048844, .048849) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7116>
test/lang/useOperator.ci:185:[.048849, .04884f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7121>
test/lang/useOperator.ci:186:[.04884f, .048854) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7127>
test/lang/useOperator.ci:187:[.048854, .04885a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7132>
test/lang/useOperator.ci:188:[.04885a, .04885f) exec(1), time(11-11 / 0.011-0.011 ms): <.main+7138>
test/lang/useOperator.ci:189:[.04885f, .048865) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7143>
test/lang/useOperator.ci:191:[.048865, .04886e) exec(1), time(0 / 0.000 ms): <.main+7149>
test/lang/useOperator.ci:192:[.04886e, .048877) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7158>
test/lang/useOperator.ci:193:[.048877, .048879) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7167>
test/lang/useOperator.ci:194:[.048879, .04887c) exec(1), time(7-7 / 0.007-0.007 ms): <.main+7169>
test/lang/useOperator.ci:195:[.04887c, .04887f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7172>
test/lang/useOperator.ci:196:[.04887f, .048884) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7175>
test/lang/useOperator.ci:197:[.048884, .048889) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7180>
test/lang/useOperator.ci:198:[.048889, .04888e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7185>
test/lang/useOperator.ci:199:[.04888e, .048893) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7190>
test/lang/useOperator.ci:200:[.048893, .048898) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7195>
test/lang/useOperator.ci:201:[.048898, .04889d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7200>
test/lang/useOperator.ci:202:[.04889d, .0488a2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7205>
test/lang/useOperator.ci:203:[.0488a2, .0488a7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7210>
test/lang/useOperator.ci:204:[.0488a7, .0488ac) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7215>
test/lang/useOperator.ci:205:[.0488ac, .0488b1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7220>
test/lang/useOperator.ci:206:[.0488b1, .0488b5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7225>
test/lang/useOperator.ci:207:[.0488b5, .0488ba) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7229>
test/lang/useOperator.ci:208:[.0488ba, .0488c0) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7234>
test/lang/useOperator.ci:209:[.0488c0, .0488c5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7240>
test/lang/useOperator.ci:210:[.0488c5, .0488cb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7245>
test/lang/useOperator.ci:211:[.0488cb, .0488d0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7251>
test/lang/useOperator.ci:212:[.0488d0, .0488d6) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7256>
test/lang/useOperator.ci:214:[.0488d6, .0488df) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7262>
test/lang/useOperator.ci:215:[.0488df, .0488e8) exec(1), time(0 / 0.000 ms): <.main+7271>
test/lang/useOperator.ci:216:[.0488e8, .0488ea) exec(1), time(0 / 0.000 ms): <.main+7280>
test/lang/useOperator.ci:217:[.0488ea, .0488ed) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7282>
test/lang/useOperator.ci:218:[.0488ed, .0488f0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7285>
test/lang/useOperator.ci:219:[.0488f0, .0488f5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7288>
test/lang/useOperator.ci:220:[.0488f5, .0488fa) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7293>
test/lang/useOperator.ci:221:[.0488fa, .0488ff) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7298>
test/lang/useOperator.ci:222:[.0488ff, .048904) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7303>
test/lang/useOperator.ci:223:[.048904, .048909) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7308>
test/lang/useOperator.ci:224:[.048909, .04890e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7313>
test/lang/useOperator.ci:225:[.04890e, .048913) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7318>
test/lang/useOperator.ci:226:[.048913, .048918) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7323>
test/lang/useOperator.ci:227:[.048918, .04891d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7328>
test/lang/useOperator.ci:228:[.04891d, .048922) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7333>
test/lang/useOperator.ci:229:[.048922, .048926) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7338>
test/lang/useOperator.ci:230:[.048926, .04892b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7342>
test/lang/useOperator.ci:231:[.04892b, .048931) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7347>
test/lang/useOperator.ci:232:[.048931, .048936) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7353>
test/lang/useOperator.ci:233:[.048936, .04893c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7358>
test/lang/useOperator.ci:234:[.04893c, .048941) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7364>
test/lang/useOperator.ci:235:[.048941, .048947) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7369>
test/lang/useOperator.ci:237:[.048947, .04894c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7375>
test/lang/useOperator.ci:238:[.04894c, .048951) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7380>
test/lang/useOperator.ci:239:[.048951, .048953) exec(1), time(0 / 0.000 ms): <.main+7385>
test/lang/useOperator.ci:240:[.048953, .048956) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7387>
test/lang/useOperator.ci:242:[.048956, .04895b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7390>
test/lang/useOperator.ci:243:[.04895b, .048960) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7395>
test/lang/useOperator.ci:244:[.048960, .048965) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7400>
test/lang/useOperator.ci:245:[.048965, .04896a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7405>
test/lang/useOperator.ci:246:[.04896a, .04896f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7410>
test/lang/useOperator.ci:252:[.04896f, .048973) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7415>
test/lang/useOperator.ci:253:[.048973, .048978) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7419>
test/lang/useOperator.ci:254:[.048978, .04897e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7424>
test/lang/useOperator.ci:255:[.04897e, .048983) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7430>
test/lang/useOperator.ci:256:[.048983, .048989) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7435>
test/lang/useOperator.ci:257:[.048989, .04898e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7441>
test/lang/useOperator.ci:258:[.04898e, .048994) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7446>
test/lang/useOperator.ci:260:[.048994, .04899d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7452>
test/lang/useOperator.ci:261:[.04899d, .0489a6) exec(1), time(0 / 0.000 ms): <.main+7461>
test/lang/useOperator.ci:262:[.0489a6, .0489a8) exec(1), time(0 / 0.000 ms): <.main+7470>
test/lang/useOperator.ci:263:[.0489a8, .0489ab) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7472>
test/lang/useOperator.ci:265:[.0489ab, .0489b0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7475>
test/lang/useOperator.ci:266:[.0489b0, .0489b5) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7480>
test/lang/useOperator.ci:267:[.0489b5, .0489ba) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7485>
test/lang/useOperator.ci:268:[.0489ba, .0489bf) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7490>
test/lang/useOperator.ci:269:[.0489bf, .0489c4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7495>
test/lang/useOperator.ci:275:[.0489c4, .0489c8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7500>
test/lang/useOperator.ci:276:[.0489c8, .0489cd) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7504>
test/lang/useOperator.ci:277:[.0489cd, .0489d3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7509>
test/lang/useOperator.ci:278:[.0489d3, .0489d8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7515>
test/lang/useOperator.ci:279:[.0489d8, .0489de) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7520>
test/lang/useOperator.ci:280:[.0489de, .0489e3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7526>
test/lang/useOperator.ci:281:[.0489e3, .0489e9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7531>
test/lang/useOperator.ci:283:[.0489e9, .0489ee) exec(1), time(0 / 0.000 ms): <.main+7537>
test/lang/useOperator.ci:284:[.0489ee, .0489f2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7542>
test/lang/useOperator.ci:299:[.0489f2, .0489f7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7546>
test/lang/useOperator.ci:300:[.0489f7, .0489fd) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7551>
test/lang/statementIf.ci:4:[.0489fd, .048a24) exec(1), time(48-48 / 0.048-0.048 ms): <.main+7557>
test/lang/statementIf.ci:12:[.048a24, .048a4b) exec(1), time(36-36 / 0.036-0.036 ms): <.main+7596>
test/lang/statementIf.ci:22:[.048a4b, .048a72) exec(1), time(61-61 / 0.061-0.061 ms): <.main+7635>
test/lang/statementIf.ci:26:[.048a72, .048a73) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7674>
test/lang/statementIf.ci:29:[.048a7b, .048aa1) exec(1), time(39-39 / 0.039-0.039 ms): <.main+7683>
test/lang/statementIf.ci:28:[.048a73, .048aa1) exec(1-1), time(0 / 0.000 ms): <.main+7675>
test/lang/statementIf.ci:33:[.048aa9, .048acf) exec(0), time(0 / 0.000 ms): <.main+7729>
test/lang/statementIf.ci:32:[.048aa1, .048acf) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7721>
test/lang/statementIf.ci:37:[.048ad7, .048afd) exec(1), time(49-49 / 0.049-0.049 ms): <.main+7775>
test/lang/statementIf.ci:40:[.048b01, .048b27) exec(0), time(0 / 0.000 ms): <.main+7817>
test/lang/statementIf.ci:36:[.048acf, .048b27) exec(1), time(50-50 / 0.050-0.050 ms): <.main+7767>
test/lang/statementIf.ci:44:[.048b2f, .048b55) exec(0), time(0 / 0.000 ms): <.main+7863>
test/lang/statementIf.ci:47:[.048b59, .048b7f) exec(1), time(38-38 / 0.038-0.038 ms): <.main+7905>
test/lang/statementIf.ci:43:[.048b27, .048b7f) exec(1-1), time(0 / 0.000 ms): <.main+7855>
test/lang/statementIf.ci:51:[.048b87, .048bad) exec(1), time(39-39 / 0.039-0.039 ms): <.main+7951>
test/lang/statementIf.ci:54:[.048bbd, .048be3) exec(0), time(0 / 0.000 ms): <.main+8005>
test/lang/statementIf.ci:57:[.048bf3, .048c19) exec(0), time(0 / 0.000 ms): <.main+8059>
test/lang/statementIf.ci:60:[.048c29, .048c4f) exec(0), time(0 / 0.000 ms): <.main+8113>
test/lang/statementIf.ci:63:[.048c5f, .048c85) exec(0), time(0 / 0.000 ms): <.main+8167>
test/lang/statementIf.ci:66:[.048c95, .048cbb) exec(0), time(0 / 0.000 ms): <.main+8221>
test/lang/statementIf.ci:69:[.048cbf, .048ce5) exec(0), time(0 / 0.000 ms): <.main+8263>
test/lang/statementIf.ci:65:[.048c89, .048ce5) exec(0), time(0 / 0.000 ms): <.main+8209>
test/lang/statementIf.ci:62:[.048c53, .048ce5) exec(0), time(0 / 0.000 ms): <.main+8155>
test/lang/statementIf.ci:59:[.048c1d, .048ce5) exec(0), time(0 / 0.000 ms): <.main+8101>
test/lang/statementIf.ci:56:[.048be7, .048ce5) exec(0), time(0 / 0.000 ms): <.main+8047>
test/lang/statementIf.ci:53:[.048bb1, .048ce5) exec(0), time(0 / 0.000 ms): <.main+7993>
test/lang/statementIf.ci:50:[.048b7f, .048ce5) exec(1), time(40-40 / 0.040-0.040 ms): <.main+7943>
test/lang/statementFor.ci:4:[.048ce9, .048d0c) exec(1), time(29-29 / 0.029-0.029 ms): <.main+8305>
test/lang/statementFor.ci:5:[.048d0c, .048d10) exec(1), time(0 / 0.000 ms): <.main+8340>
::[.048d10, .048d14) exec(1), time(0 / 0.000 ms): <.main+8344>
test/lang/statementFor.ci:3:[.048ce5, .048d14) exec(1-1), time(0 / 0.000 ms): <.main+8301>
test/lang/statementFor.ci:9:[.048d19, .048d3b) exec(2), time(70-70 / 0.070-0.070 ms): <.main+8353>
test/lang/statementFor.ci:8:[.048d3b, .048d3f) exec(2), time(0 / 0.000 ms): <.main+8387>
test/lang/statementFor.ci:8:[.048d3f, .048d4b) exec(3), time(18-18 / 0.018-0.018 ms): <.main+8391>
test/lang/statementFor.ci:8:[.048d14, .048d4f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+8348>
test/lang/statementFor.ci:12:[.048d4f, .048d50) exec(1), time(0 / 0.000 ms): <.main+8407>
test/lang/statementFor.ci:14:[.048d57, .048d79) exec(2), time(89-89 / 0.089-0.089 ms): <.main+8415>
test/lang/statementFor.ci:13:[.048d79, .048d7d) exec(2), time(0 / 0.000 ms): <.main+8449>
test/lang/statementFor.ci:13:[.048d7d, .048d89) exec(3), time(9-9 / 0.009-0.009 ms): <.main+8453>
test/lang/statementFor.ci:13:[.048d50, .048d89) exec(1-1), time(0 / 0.000 ms): <.main+8408>
test/lang/statementFor.ci:19:[.048d9a, .048d9e) exec(2), time(2-2 / 0.002-0.002 ms): <.main+8482>
test/lang/statementFor.ci:18:[.048d8e, .048d9e) exec(7-2), time(16-16 / 0.016-0.016 ms): <.main+8470>
test/lang/statementFor.ci:21:[.048d9e, .048dc0) exec(5), time(173-173 / 0.173-0.173 ms): <.main+8486>
test/lang/statementFor.ci:17:[.048dc0, .048dc4) exec(7), time(4-4 / 0.004-0.004 ms): <.main+8520>
test/lang/statementFor.ci:17:[.048dc4, .048dd0) exec(8), time(24-24 / 0.024-0.024 ms): <.main+8524>
test/lang/statementFor.ci:17:[.048d89, .048dd4) exec(1), time(4-4 / 0.004-0.004 ms): <.main+8465>
test/lang/statementFor.ci:26:[.048de5, .048de9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8557>
test/lang/statementFor.ci:25:[.048dd9, .048de9) exec(4-1), time(9-9 / 0.009-0.009 ms): <.main+8545>
test/lang/statementFor.ci:28:[.048de9, .048e0b) exec(3), time(102-102 / 0.102-0.102 ms): <.main+8561>
test/lang/statementFor.ci:24:[.048e0b, .048e0f) exec(3), time(1-1 / 0.001-0.001 ms): <.main+8595>
test/lang/statementFor.ci:24:[.048e0f, .048e1b) exec(4), time(12-12 / 0.012-0.012 ms): <.main+8599>
test/lang/statementFor.ci:24:[.048dd4, .048e1f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+8540>
test/stdc/test.math.ci:3:[.048e1f, .048e33) exec(1), time(36-36 / 0.036-0.036 ms): <.main+8615>
test/stdc/test.math.ci:4:[.048e33, .048e47) exec(1), time(33-33 / 0.033-0.033 ms): <.main+8635>
test/stdc/test.math.ci:5:[.048e47, .048e5b) exec(1), time(34-34 / 0.034-0.034 ms): <.main+8655>
test/stdc/test.math.ci:6:[.048e5b, .048e6f) exec(1), time(48-48 / 0.048-0.048 ms): <.main+8675>
test/stdc/test.math.ci:7:[.048e6f, .048e83) exec(1), time(60-60 / 0.060-0.060 ms): <.main+8695>
test/stdc/test.math.ci:8:[.048e83, .048e97) exec(1), time(46-46 / 0.046-0.046 ms): <.main+8715>
test/stdc/test.math.ci:10:[.048e97, .048eac) exec(1), time(20-20 / 0.020-0.020 ms): <.main+8735>
test/stdc/test.math.ci:11:[.048eac, .048eb9) exec(1), time(18-18 / 0.018-0.018 ms): <.main+8756>
test/stdc/test.math.ci:12:[.048eb9, .048ece) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8769>
test/stdc/test.math.ci:13:[.048ece, .048edf) exec(1), time(20-20 / 0.020-0.020 ms): <.main+8790>
test/stdc/test.math.ci:14:[.048edf, .048eec) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8807>
test/stdc/test.math.ci:15:[.048eec, .048efd) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8820>
test/stdc/test.math.ci:17:[.048efd, .048f11) exec(1), time(18-18 / 0.018-0.018 ms): <.main+8837>
test/stdc/test.math.ci:18:[.048f11, .048f1c) exec(1), time(18-18 / 0.018-0.018 ms): <.main+8857>
test/stdc/test.math.ci:19:[.048f1c, .048f30) exec(1), time(17-17 / 0.017-0.017 ms): <.main+8868>
test/stdc/test.math.ci:20:[.048f30, .048f41) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8888>
test/stdc/test.math.ci:21:[.048f41, .048f4e) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8905>
test/stdc/test.math.ci:22:[.048f4e, .048f5f) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8918>
test/stdc/test.math.ci:24:[.048f5f, .048f75) exec(1), time(20-20 / 0.020-0.020 ms): <.main+8935>
test/stdc/test.math.ci:25:[.048f75, .048f8b) exec(1), time(20-20 / 0.020-0.020 ms): <.main+8957>
test/stdc/test.math.ci:26:[.048f8b, .048fa8) exec(1), time(19-19 / 0.019-0.019 ms): <.main+8979>
test/stdc/test.math.ci:27:[.048fa8, .048fc5) exec(1), time(19-19 / 0.019-0.019 ms): <.main+9008>
test/stdc/test.math.ci:29:[.048fc5, .048fdc) exec(1), time(22-22 / 0.022-0.022 ms): <.main+9037>
test/stdc/test.math.ci:30:[.048fdc, .048ffa) exec(1), time(21-21 / 0.021-0.021 ms): <.main+9060>
test/stdc/test.math.ci:32:[.048ffa, .04900f) exec(1), time(9-9 / 0.009-0.009 ms): <.main+9090>
test/stdc/test.math.ci:33:[.04900f, .04902b) exec(1), time(8-8 / 0.008-0.008 ms): <.main+9111>
test/stdc/test.math.ci:35:[.04902b, .049043) exec(1), time(10-10 / 0.010-0.010 ms): <.main+9139>
test/stdc/test.math.ci:36:[.049043, .049062) exec(1), time(9-9 / 0.009-0.009 ms): <.main+9163>
test/stdc/test.math.ci:37:[.049062, .04909e) exec(1), time(38-38 / 0.038-0.038 ms): <.main+9194>
test/stdc/test.math.ci:38:[.04909e, .0490ec) exec(1), time(37-37 / 0.037-0.037 ms): <.main+9254>
test/stdc/test.math.ci:40:[.0490ec, .049101) exec(1), time(23-23 / 0.023-0.023 ms): <.main+9332>
test/stdc/test.math.ci:41:[.049101, .04916b) exec(1), time(60-60 / 0.060-0.060 ms): <.main+9353>
test/stdc/test.math.ci:42:[.04916b, .049180) exec(1), time(29-29 / 0.029-0.029 ms): <.main+9459>
test/stdc/test.math.ci:43:[.049180, .0491ea) exec(1), time(70-70 / 0.070-0.070 ms): <.main+9480>
test/stdc/test.math.ci:45:[.0491ea, .0491ff) exec(1), time(25-25 / 0.025-0.025 ms): <.main+9586>
test/stdc/test.math.ci:46:[.0491ff, .049221) exec(1), time(43-43 / 0.043-0.043 ms): <.main+9607>
test/stdc/test.math.ci:47:[.049221, .04924c) exec(1), time(33-33 / 0.033-0.033 ms): <.main+9641>
test/stdc/test.math.ci:48:[.04924c, .0492bf) exec(1), time(67-67 / 0.067-0.067 ms): <.main+9684>
test/stdc/test.math.ci:50:[.0492bf, .0492c8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+9799>
test/stdc/test.math.ci:51:[.0492c8, .0492df) exec(1), time(26-26 / 0.026-0.026 ms): <.main+9808>
test/stdc/test.math.ci:52:[.0492df, .0492e8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+9831>
test/stdc/test.math.ci:53:[.0492e8, .0492fe) exec(1), time(4-4 / 0.004-0.004 ms): <.main+9840>
test/stdc/test.math.ci:54:[.0492fe, .049325) exec(1), time(10-10 / 0.010-0.010 ms): <.main+9862>
test/stdc/test.math.ci:55:[.049325, .04935d) exec(1), time(15-15 / 0.015-0.015 ms): <.main+9901>
test/stdc/test.math.ci:56:[.04935d, .0493a5) exec(1), time(48-48 / 0.048-0.048 ms): <.main+9957>
test/stdc/test.math.ci:57:[.0493a5, .0493f6) exec(1), time(53-53 / 0.053-0.053 ms): <.main+10029>
test/stdc/test.math.ci:59:[.0493f6, .049415) exec(1), time(41-41 / 0.041-0.041 ms): <.main+10110>
test/stdc/test.math.ci:60:[.049415, .049442) exec(1), time(57-57 / 0.057-0.057 ms): <.main+10141>
test/stdc/test.math.ci:61:[.049442, .049460) exec(1), time(59-59 / 0.059-0.059 ms): <.main+10186>
test/stdc/test.math.ci:62:[.049460, .04947e) exec(1), time(60-60 / 0.060-0.060 ms): <.main+10216>
test/stdc/test.math.ci:63:[.04947e, .04949c) exec(1), time(48-48 / 0.048-0.048 ms): <.main+10246>
test/stdc/test.math.ci:65:[.04949c, .0494b0) exec(1), time(55-55 / 0.055-0.055 ms): <.main+10276>
test/stdc/test.math.ci:66:[.0494b0, .0494d8) exec(1), time(57-57 / 0.057-0.057 ms): <.main+10296>
test/stdc/test.math.ci:69:[.0494d8, .0494f4) exec(1), time(24-24 / 0.024-0.024 ms): <.main+10336>
test/stdc/test.math.ci:70:[.0494f4, .04951c) exec(1), time(24-24 / 0.024-0.024 ms): <.main+10364>

---------- Exitcode: 0, time: 25.806 ms
