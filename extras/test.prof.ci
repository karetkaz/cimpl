
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:44: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:45: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:46: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:43: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:34: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:56: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:59: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:62: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:68: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:71: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:84: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:90: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:96: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:176: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:176: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:177: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:177: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:186: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:190: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:198: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:202: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:212: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:230: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:278: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:284: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:285: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:286: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:288: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:292: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:292: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:296: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:301: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:336: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:340: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:342: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:348: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:356: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:355: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:351: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:347: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:365: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:390: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:395: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:396: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:401: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:417: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:420: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:421: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:423: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:439: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:444: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:451: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:467: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:490: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:491: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:498: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:57: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:109: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:115: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:122: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:123: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:123: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:125: warn: adding implicit cast char(0: int32)
lib/std/string.ci:138: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:141: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:141: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:142: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:166: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:173: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:186: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:186: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:188: warn: adding implicit cast char(0: int32)
lib/std/string.ci:199: warn: adding implicit cast int32('-': char)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:108: warn: adding implicit cast char(0: int32)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:59: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:60: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:61: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:3: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:64: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:70: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:59: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:62: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:63: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:47: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:283: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:286: warn: using default type initializer: e := 0
lib/std/math.ci:290: warn: using default type initializer: f := 0
lib/std/math.ci:342: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:399: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:30: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang/method.ci:58: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+24>, cast: const variable)
.field offset: int32 (size: 4, offs: <+32>, cast: const variable)
.field base: function (size: 0, offs: <@0055a8>, cast: static const inline)
.field file: function (size: 0, offs: <@005778>, cast: static const inline)
.field line: function (size: 0, offs: <@005948>, cast: static const inline)
.field name: function (size: 0, offs: <@005b18>, cast: static const inline)
.references:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:54: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal references: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+24>
.name: 'size'
.owner: typename
.references:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:54: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'offset'
.print: '@%06x'
.owner: typename
.references:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0055a8>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.references:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal references: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005778>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.references:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal references: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005948>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.references:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal references: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005b18>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.references:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal references: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000a0>
.name: 'void'
.references:
	test/lang/method.ci:68: referenced as `void`
	test/lang/method.ci:62: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:30: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:19: referenced as `void`
	test/lang/method.ci:15: referenced as `void`
	test/lang/method.ci:11: referenced as `void`
	test/lang/method.ci:6: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:39: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	internal references: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000130>
.name: 'bool'
.print: '%d'
.value: 0
.references:
	test/stdc/test.math.ci:70: referenced as `bool`
	test/stdc/test.math.ci:69: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:44: referenced as `bool`
	lib/std/string.ci:35: referenced as `bool`
	lib/std/math.ci:438: referenced as `bool`
	lib/std/math.ci:389: referenced as `bool`
	lib/std/math.ci:334: referenced as `bool`
	lib/std/math.ci:333: referenced as `bool`
	lib/stdlib.ci:29: referenced as `bool`
	lib/stdlib.ci:28: referenced as `bool`
	lib/stdlib.ci:27: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001c0>
.name: 'char'
.print: '%c'
.value: 0
.references:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:205: referenced as `char`
	lib/std/string.ci:196: referenced as `char`
	lib/std/string.ci:192: referenced as `char`
	lib/std/string.ci:150: referenced as `char`
	lib/std/string.ci:134: referenced as `char`
	lib/std/string.ci:131: referenced as `char`
	lib/std/string.ci:130: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:108: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:3: referenced as `char`
	lib/stdlib.ci:39: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:24: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	lib/stdlib.ci:14: referenced as `char`
	lib/stdlib.ci:12: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:9: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	lib/stdlib.ci:5: referenced as `char`
	internal references: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000250>
.name: 'int8'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@0002e0>
.name: 'int16'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000370>
.name: 'int32'
.print: '%d'
.value: 0
.references:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:68: referenced as `int32`
	test/lang/method.ci:62: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:30: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:19: referenced as `int32`
	test/lang/method.ci:15: referenced as `int32`
	test/lang/method.ci:11: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:197: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:179: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:136: referenced as `int32`
	lib/std/string.ci:133: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:114: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:110: referenced as `int32`
	lib/std/string.ci:109: referenced as `int32`
	lib/std/string.ci:107: referenced as `int32`
	lib/std/string.ci:84: referenced as `int32`
	lib/std/string.ci:70: referenced as `int32`
	lib/std/string.ci:60: referenced as `int32`
	lib/std/string.ci:59: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:50: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:45: referenced as `int32`
	lib/std/string.ci:44: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:35: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:24: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:14: referenced as `int32`
	lib/std/string.ci:7: referenced as `int32`
	lib/std/string.ci:3: referenced as `int32`
	lib/std/math.ci:344: referenced as `int32`
	lib/std/math.ci:344: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:263: referenced as `int32`
	lib/std/math.ci:249: referenced as `int32`
	lib/std/math.ci:236: referenced as `int32`
	lib/std/math.ci:230: referenced as `int32`
	lib/std/math.ci:212: referenced as `int32`
	lib/std/math.ci:202: referenced as `int32`
	lib/std/math.ci:190: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:58: referenced as `int32`
	lib/stdlib.ci:54: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:50: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	lib/stdlib.ci:39: referenced as `int32`
	internal references: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000400>
.name: 'int64'
.print: '%D'
.value: 0
.references:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal references: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000490>
.name: 'uint8'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@000520>
.name: 'uint16'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0005b0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@008328>, cast: static const inline)
.field sxt: function (size: 0, offs: <@008608>, cast: static const inline)
.field pop: function (size: 0, offs: <@0087d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0089a8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@008b78>, cast: static const inline)
.field bsf: function (size: 0, offs: <@008d48>, cast: static const inline)
.field hib: function (size: 0, offs: <@008f18>, cast: static const inline)
.field lob: function (size: 0, offs: <@0090e8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:205: referenced as `uint32`
	lib/std/string.ci:192: referenced as `uint32`
	lib/std/string.ci:129: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008328>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.references:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal references: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008608>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.references:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal references: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0087d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.references:
	test/stdc/number.ci:55: referenced as `pop`
	internal references: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.references:
	test/stdc/number.ci:56: referenced as `swap`
	internal references: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b78>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.references:
	test/stdc/number.ci:57: referenced as `bsr`
	internal references: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d48>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.references:
	test/stdc/number.ci:58: referenced as `bsf`
	internal references: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.references:
	test/stdc/number.ci:59: referenced as `hib`
	internal references: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0090e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.references:
	test/stdc/number.ci:60: referenced as `lob`
	internal references: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000640>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@0093c0>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009698>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093c0>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.references:
	test/stdc/number.ci:65: referenced as `zxt`
	internal references: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009698>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.references:
	test/stdc/number.ci:66: referenced as `sxt`
	internal references: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0006d0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@009870>, cast: static const inline)
.field cos: function (size: 0, offs: <@009a40>, cast: static const inline)
.field tan: function (size: 0, offs: <@009c10>, cast: static const inline)
.field log: function (size: 0, offs: <@009de0>, cast: static const inline)
.field exp: function (size: 0, offs: <@009fb0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00a210>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00a3e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00a638>, cast: static const inline)
.value: 0
.references:
	test/stdc/test.math.ci:98: referenced as `float32`
	test/stdc/test.math.ci:97: referenced as `float32`
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:92: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:87: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:16: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:15: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:13: referenced as `float32`
	lib/vec/mat4f.ci:4: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:77: referenced as `float32`
	lib/vec/vec4f.ci:74: referenced as `float32`
	lib/vec/vec4f.ci:70: referenced as `float32`
	lib/vec/vec4f.ci:69: referenced as `float32`
	lib/vec/vec4f.ci:68: referenced as `float32`
	lib/vec/vec4f.ci:63: referenced as `float32`
	lib/vec/vec4f.ci:62: referenced as `float32`
	lib/vec/vec4f.ci:26: referenced as `float32`
	lib/vec/vec4f.ci:25: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:24: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:21: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:8: referenced as `float32`
	lib/vec/vec4f.ci:7: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:4: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:236: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:178: referenced as `float32`
	lib/std/math.ci:176: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:173: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:150: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:132: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:114: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:95: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:83: referenced as `float32`
	lib/std/math.ci:58: referenced as `float32`
	internal references: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009870>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.references:
	test/stdc/number.ci:46: referenced as `sin`
	internal references: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a40>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.references:
	test/stdc/number.ci:47: referenced as `cos`
	internal references: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c10>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.references:
	test/stdc/number.ci:48: referenced as `tan`
	internal references: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009de0>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.references:
	test/stdc/number.ci:49: referenced as `log`
	internal references: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009fb0>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.references:
	test/stdc/number.ci:50: referenced as `exp`
	internal references: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a210>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.references:
	test/stdc/number.ci:51: referenced as `pow`
	internal references: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a3e0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.references:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:74: referenced as `sqrt`
	internal references: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a638>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.references:
	test/stdc/number.ci:53: referenced as `atan2`
	internal references: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000760>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00a800>, cast: static const inline)
.field cos: function (size: 0, offs: <@00a9c8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ab90>, cast: static const inline)
.field log: function (size: 0, offs: <@00ad58>, cast: static const inline)
.field exp: function (size: 0, offs: <@00af20>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b170>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b338>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b588>, cast: static const inline)
.value: 0
.references:
	test/stdc/test.math.ci:84: referenced as `float64`
	test/stdc/test.math.ci:83: referenced as `float64`
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:78: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:73: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:66: referenced as `float64`
	test/stdc/test.math.ci:65: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:62: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:56: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:47: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:42: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:37: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:8: referenced as `float64`
	lib/vec/vec2d.ci:5: referenced as `float64`
	lib/vec/vec2d.ci:4: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:117: referenced as `float64`
	lib/std/math.Complex.ci:114: referenced as `float64`
	lib/std/math.Complex.ci:113: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:108: referenced as `float64`
	lib/std/math.Complex.ci:105: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:94: referenced as `float64`
	lib/std/math.Complex.ci:90: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:87: referenced as `float64`
	lib/std/math.Complex.ci:86: referenced as `float64`
	lib/std/math.Complex.ci:79: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:72: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:63: referenced as `float64`
	lib/std/math.Complex.ci:60: referenced as `float64`
	lib/std/math.Complex.ci:59: referenced as `float64`
	lib/std/math.Complex.ci:56: referenced as `float64`
	lib/std/math.Complex.ci:55: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:20: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.Complex.ci:4: referenced as `float64`
	lib/std/math.ci:491: referenced as `float64`
	lib/std/math.ci:491: referenced as `float64`
	lib/std/math.ci:490: referenced as `float64`
	lib/std/math.ci:490: referenced as `float64`
	lib/std/math.ci:467: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:451: referenced as `float64`
	lib/std/math.ci:449: referenced as `float64`
	lib/std/math.ci:449: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:432: referenced as `float64`
	lib/std/math.ci:423: referenced as `float64`
	lib/std/math.ci:423: referenced as `float64`
	lib/std/math.ci:421: referenced as `float64`
	lib/std/math.ci:416: referenced as `float64`
	lib/std/math.ci:416: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:401: referenced as `float64`
	lib/std/math.ci:401: referenced as `float64`
	lib/std/math.ci:399: referenced as `float64`
	lib/std/math.ci:396: referenced as `float64`
	lib/std/math.ci:379: referenced as `float64`
	lib/std/math.ci:377: referenced as `float64`
	lib/std/math.ci:377: referenced as `float64`
	lib/std/math.ci:361: referenced as `float64`
	lib/std/math.ci:360: referenced as `float64`
	lib/std/math.ci:343: referenced as `float64`
	lib/std/math.ci:342: referenced as `float64`
	lib/std/math.ci:321: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:314: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:308: referenced as `float64`
	lib/std/math.ci:307: referenced as `float64`
	lib/std/math.ci:290: referenced as `float64`
	lib/std/math.ci:286: referenced as `float64`
	lib/std/math.ci:283: referenced as `float64`
	lib/std/math.ci:277: referenced as `float64`
	lib/std/math.ci:264: referenced as `float64`
	lib/std/math.ci:263: referenced as `float64`
	lib/std/math.ci:263: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:249: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:228: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:227: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:226: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:225: referenced as `float64`
	lib/std/math.ci:224: referenced as `float64`
	lib/std/math.ci:224: referenced as `float64`
	lib/std/math.ci:211: referenced as `float64`
	lib/std/math.ci:210: referenced as `float64`
	lib/std/math.ci:210: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:197: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:179: referenced as `float64`
	lib/std/math.ci:177: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:174: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:120: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:89: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:52: referenced as `float64`
	lib/std/math.ci:51: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:46: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:6: referenced as `float64`
	internal references: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a800>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.references:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:145: referenced as `sin`
	lib/std/math.Complex.ci:120: referenced as `sin`
	lib/std/math.Complex.ci:119: referenced as `sin`
	lib/std/math.Complex.ci:114: referenced as `sin`
	lib/std/math.Complex.ci:103: referenced as `sin`
	internal references: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a9c8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.references:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:145: referenced as `cos`
	lib/std/math.Complex.ci:120: referenced as `cos`
	lib/std/math.Complex.ci:119: referenced as `cos`
	lib/std/math.Complex.ci:113: referenced as `cos`
	lib/std/math.Complex.ci:103: referenced as `cos`
	internal references: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab90>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.references:
	test/stdc/number.ci:39: referenced as `tan`
	internal references: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad58>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.references:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:110: referenced as `log`
	lib/std/math.Complex.ci:105: referenced as `log`
	internal references: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af20>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.references:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:111: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.ci:423: referenced as `exp`
	lib/std/math.ci:423: referenced as `exp`
	lib/std/math.ci:421: referenced as `exp`
	lib/std/math.ci:401: referenced as `exp`
	lib/std/math.ci:401: referenced as `exp`
	lib/std/math.ci:396: referenced as `exp`
	internal references: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b170>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.references:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:111: referenced as `pow`
	internal references: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.references:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:89: referenced as `sqrt`
	lib/std/math.ci:449: referenced as `sqrt`
	internal references: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b588>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.references:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:90: referenced as `atan2`
	lib/std/math.ci:454: referenced as `atan2`
	lib/std/math.ci:451: referenced as `atan2`
	internal references: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@006c50>, cast: static const inline)
.field fill: function (size: 0, offs: <@006f40>, cast: static const inline)
.field copy: function (size: 0, offs: <@007228>, cast: static const inline)
.field move: function (size: 0, offs: <@007508>, cast: static const inline)
.references:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal references: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006c50>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.references:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal references: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f40>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.references:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal references: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007228>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.references:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal references: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007508>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.references:
	test/stdc/memory.ci:29: referenced as `move`
	internal references: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000880>
.name: 'variant'
.references:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:34: referenced as `variant`
	lib/stdlib.ci:33: referenced as `variant`
	lib/stdlib.ci:32: referenced as `variant`
	lib/stdlib.ci:27: referenced as `variant`
	lib/stdlib.ci:23: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:17: referenced as `variant`
	lib/stdlib.ci:14: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:8: referenced as `variant`
	lib/stdlib.ci:5: referenced as `variant`
	internal references: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000910>
.name: 'function'
.references:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0009a8>
.name: 'object'
.references:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.references:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:70: referenced as `null`
	test/lang/method.ci:64: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:4: referenced as `null`
	lib/stdlib.ci:50: referenced as `null`
	lib/stdlib.ci:35: referenced as `null`
	lib/stdlib.ci:34: referenced as `null`
	lib/stdlib.ci:25: referenced as `null`
	lib/stdlib.ci:24: referenced as `null`
	lib/stdlib.ci:21: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:15: referenced as `null`
	lib/stdlib.ci:12: referenced as `null`
	lib/stdlib.ci:9: referenced as `null`
	lib/stdlib.ci:6: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.references:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:55: referenced as `true`
	lib/std/string.ci:41: referenced as `true`
	lib/std/math.ci:440: referenced as `true`
	lib/std/math.ci:392: referenced as `true`
	lib/std/math.ci:353: referenced as `true`
	lib/std/math.ci:349: referenced as `true`
	lib/std/math.ci:338: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.references:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:52: referenced as `false`
	lib/std/string.ci:48: referenced as `false`
	lib/std/string.ci:38: referenced as `false`
	lib/std/math.ci:438: referenced as `false`
	lib/std/math.ci:389: referenced as `false`
	lib/std/math.ci:334: referenced as `false`
	lib/std/math.ci:333: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.references:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.references:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.references:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.references:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000eb8>
.name: '.cstr'
.print: '%s'
.references:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000f48>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0012a8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001338>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@001578>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a88>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001dc0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@0022b0>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002450>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@0025f0>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@0028a0>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002c80>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003040>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003400>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@0038d0>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@003da0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004160>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004520>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@0048e0>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@004ca0>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@004e40>, cast: static const typename(void))
.references:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:70: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:68: referenced as `emit`
	lib/vec/vec4f.ci:63: referenced as `emit`
	lib/vec/vec4f.ci:62: referenced as `emit`
	lib/vec/vec4f.ci:60: referenced as `emit`
	lib/vec/vec4f.ci:59: referenced as `emit`
	lib/vec/vec4f.ci:58: referenced as `emit`
	lib/vec/vec4f.ci:57: referenced as `emit`
	lib/vec/vec4f.ci:56: referenced as `emit`
	lib/vec/vec2d.ci:15: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.references:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.references:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.references:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.references:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.references:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0012a8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:70: referenced as `p4x`
	lib/vec/vec4f.ci:69: referenced as `p4x`
	lib/vec/vec4f.ci:68: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.references:
	lib/vec/vec4f.ci:68: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.references:
	lib/vec/vec4f.ci:70: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.references:
	lib/vec/vec4f.ci:69: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001338>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.references:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.references:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.references:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001578>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.references:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.references:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.references:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.references:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.references:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.references:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.references:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.references:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a88>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.references:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.references:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.references:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.references:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.references:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001dc0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.references:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.references:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.references:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.references:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.references:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.references:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022b0>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.references:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.references:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002450>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.references:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.references:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0025f0>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.references:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.references:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.references:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.references:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0028a0>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.references:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.references:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.references:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.references:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.references:
	lib/vec/vec4f.ci:56: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.references:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c80>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:57: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.references:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.references:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.references:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.references:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.references:
	lib/vec/vec4f.ci:57: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.references:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003040>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:58: referenced as `sub`
	lib/vec/vec2d.ci:15: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.references:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.references:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.references:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.references:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.references:
	lib/vec/vec4f.ci:58: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.references:
	lib/vec/vec2d.ci:15: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003400>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:59: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.references:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.references:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.references:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.references:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.references:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.references:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.references:
	lib/vec/vec4f.ci:59: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.references:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0038d0>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:60: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.references:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.references:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.references:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.references:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.references:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.references:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.references:
	lib/vec/vec4f.ci:60: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.references:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003da0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.references:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.references:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.references:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.references:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.references:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.references:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004160>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.references:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.references:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.references:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.references:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.references:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.references:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004520>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.references:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.references:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.references:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.references:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.references:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.references:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048e0>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.references:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.references:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.references:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.references:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.references:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.references:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004ca0>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:62: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.references:
	lib/vec/vec4f.ci:62: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.references:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e40>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	lib/vec/vec4f.ci:63: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.references:
	lib/vec/vec4f.ci:63: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.references:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0052b0>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.references:
	internal references: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.references:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.references:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0061f0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.value: nfc(5)
.references:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:48: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal references: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.references:
	lib/stdlib.ci:48: referenced as `abort`
	lib/stdlib.ci:25: referenced as `abort`
	lib/stdlib.ci:24: referenced as `abort`
	lib/stdlib.ci:23: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.references:
	lib/stdlib.ci:21: referenced as `error`
	lib/stdlib.ci:20: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.references:
	lib/stdlib.ci:18: referenced as `warn`
	lib/stdlib.ci:17: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.references:
	lib/stdlib.ci:15: referenced as `info`
	lib/stdlib.ci:14: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.references:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:12: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
	lib/stdlib.ci:9: referenced as `debug`
	lib/stdlib.ci:8: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.references:
	lib/stdlib.ci:6: referenced as `verbose`
	lib/stdlib.ci:5: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.references:
	lib/stdlib.ci:18: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
	lib/stdlib.ci:14: referenced as `noTrace`
	lib/stdlib.ci:12: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
	lib/stdlib.ci:5: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.references:
	lib/stdlib.ci:48: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
	lib/stdlib.ci:24: referenced as `defTrace`
	lib/stdlib.ci:23: referenced as `defTrace`
	lib/stdlib.ci:21: referenced as `defTrace`
	lib/stdlib.ci:20: referenced as `defTrace`
	lib/stdlib.ci:9: referenced as `defTrace`
	lib/stdlib.ci:8: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0069f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.references:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal references: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@007538>
.name: 'System'
.field exit: function (size: 0, offs: <@007770>, cast: static const inline)
.field srand: function (size: 0, offs: <@007948>, cast: static const inline)
.field rand: function (size: 0, offs: <@007a90>, cast: static const inline)
.field time: function (size: 0, offs: <@007bd8>, cast: static const inline)
.field clock: function (size: 0, offs: <@007d20>, cast: static const inline)
.field millis: function (size: 0, offs: <@007e68>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008038>, cast: static const inline)
.references:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007770>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.references:
	internal references: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007948>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.references:
	internal references: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.references:
	internal references: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bd8>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.references:
	internal references: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d20>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.references:
	internal references: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e68>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.references:
	internal references: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008038>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.references:
	internal references: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:5: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:6: defined as `verbose(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.references:
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:31: referenced as `trace`
	test/lang/method.ci:26: referenced as `trace`
	test/lang/method.ci:7: referenced as `trace`
	lib/stdlib.ci:8: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:9: defined as `trace(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.references:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.references:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:69: referenced as `debug`
	test/lang/method.ci:63: referenced as `debug`
	lib/stdlib.ci:12: defined as `debug(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:14: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:15: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:17: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:18: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:20: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.references:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:21: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.references:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:27: referenced as `abort`
	lib/stdlib.ci:23: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:29: referenced as `abort`
	lib/stdlib.ci:28: referenced as `abort`
	lib/stdlib.ci:24: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.references:
	lib/stdlib.ci:25: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.value: void(condition ? void(0) : abort(void(message, inspect)))
.references:
	lib/std/string.ci:138: referenced as `assert`
	lib/std/string.ci:137: referenced as `assert`
	lib/stdlib.ci:27: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.value: void(condition ? void(0) : abort(message))
.references:
	lib/stdlib.ci:28: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
.references:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:173: referenced as `assert`
	lib/std/string.ci:166: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/stdlib.ci:29: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00e088>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.references:
	lib/stdlib.ci:43: referenced as `NotEquals`
	lib/stdlib.ci:31: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
.references:
	lib/stdlib.ci:44: referenced as `expected`
	lib/stdlib.ci:32: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
.references:
	lib/stdlib.ci:45: referenced as `returned`
	lib/stdlib.ci:33: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:34: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:35'
.owner: NotEquals
.value: null
.references:
	lib/stdlib.ci:46: referenced as `message`
	lib/stdlib.ci:35: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@046638>
.name: 'assertEq'
.file: 'lib/stdlib.ci:39'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@046638> - <@046696>)
	lib/stdlib.ci:40: (10 bytes: <@046638> - <@046642>): if (bool(returned == expected))
	<assertEq @046638>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @04663a>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @04663c>    : 57                         ceq.i32
	<assertEq+5 @04663d>    : 06 05 00 00                jz <assertEq+10 @046642>
	lib/stdlib.ci:41: (1 byte: <@046641> - <@046642>): return;
	<assertEq+9 @046641>    : 03                         ret
	lib/stdlib.ci:43: (41 bytes: <@046642> - <@04666b>): details: NotEquals := {...}
	<assertEq+10 @046642>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:44: (11 bytes: <@046646> - <@046651>): void(details.expected := (expected));
	<assertEq+14 @046646>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+19 @04664b>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @04664f>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:45: (11 bytes: <@046651> - <@04665c>): void(details.returned := (returned));
	<assertEq+25 @046651>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+30 @046656>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @04665a>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:46: (3 bytes: <@04665c> - <@04665f>): void(details.message := (message));
	<assertEq+36 @04665c>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@04665f> - <@04666b>): void(details.argument := (null))
	<assertEq+39 @04665f>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<assertEq+44 @046664>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @046669>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:48: (38 bytes: <@04666b> - <@046691>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @04666b>   : 1f b8 b5 00 00             load.ref <@00b5b8> ;"lib/stdlib.ci"
	<assertEq+56 @046670>   : 1c 30 00 00 00             load.c32 48
	<assertEq+61 @046675>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @04667a>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @04667f>   : 1f 32 b6 00 00             load.ref <@00b632> ;"assertion failed"
	<assertEq+76 @046684>   : 1f 88 e0 00 00             load.ref <@00e088> ;NotEquals
	<assertEq+81 @046689>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @04668d>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @046691>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @046695>   : 03                         ret
.references:
	lib/stdlib.ci:50: referenced as `assertEq`
	lib/stdlib.ci:39: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:50'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.value: assertEq(void(void(expected, returned), null))
.references:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:50: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:54'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.value: int32(type.size)
.references:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:54: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@00eca8>
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@046698>, cast: static const function)
.field floor: function (size: 24, offs: <@0466f0>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 36, offs: <@046708>, cast: static const function)
.field sign: function (size: 36, offs: <@046730>, cast: static const function)
.field abs: function (size: 18, offs: <@046758>, cast: static const function)
.field abs: function (size: 18, offs: <@046770>, cast: static const function)
.field absMod: function (size: 27, offs: <@046788>, cast: static const function)
.field absMod: function (size: 27, offs: <@0467a8>, cast: static const function)
.field min: function (size: 17, offs: <@0467c8>, cast: static const function)
.field min: function (size: 17, offs: <@0467e0>, cast: static const function)
.field max: function (size: 17, offs: <@0467f8>, cast: static const function)
.field max: function (size: 17, offs: <@046810>, cast: static const function)
.field clamp: function (size: 30, offs: <@046828>, cast: static const function)
.field clamp: function (size: 30, offs: <@046848>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@046868>, cast: static const function)
.field max: function (size: 72, offs: <@0468b0>, cast: static const function)
.field sum: function (size: 40, offs: <@0468f8>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@046920>, cast: static const function)
.field cmp: function (size: 57, offs: <@046950>, cast: static const function)
.field cmp: function (size: 57, offs: <@046990>, cast: static const function)
.field sinCos: function (size: 335, offs: <@0469d0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@046b20>, cast: static const function)
.field sinh: function (size: 241, offs: <@046c98>, cast: static const function)
.field cosh: function (size: 75, offs: <@046d90>, cast: static const function)
.field asin: function (size: 166, offs: <@046de0>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field deg2rad: function (size: 0, offs: <@000000>, cast: static inline)
.field rad2deg: function (size: 0, offs: <@000000>, cast: static inline)
.references:
	test/stdc/test.math.ci:98: referenced as `Math`
	test/stdc/test.math.ci:97: referenced as `Math`
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:92: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:87: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:83: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:78: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:73: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:69: referenced as `Math`
	test/stdc/test.math.ci:66: referenced as `Math`
	test/stdc/test.math.ci:65: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:62: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:56: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:48: referenced as `Math`
	test/stdc/test.math.ci:47: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:42: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:37: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.ci:3: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
.references:
	test/stdc/test.math.ci:63: referenced as `pi`
	test/stdc/test.math.ci:62: referenced as `pi`
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	lib/std/math.ci:491: referenced as `pi`
	lib/std/math.ci:490: referenced as `pi`
	lib/std/math.ci:467: referenced as `pi`
	lib/std/math.ci:451: referenced as `pi`
	lib/std/math.ci:7: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
.references:
	lib/std/math.ci:8: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
.references:
	lib/std/math.ci:10: referenced as `ln2`
	lib/std/math.ci:9: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: float64(1.000000 / ln2)
.references:
	lib/std/math.ci:10: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
.references:
	lib/std/math.ci:12: referenced as `ln10`
	lib/std/math.ci:11: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: float64(1.000000 / ln10)
.references:
	lib/std/math.ci:12: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
.references:
	lib/std/math.ci:13: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
.references:
	lib/std/math.ci:14: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
.references:
	lib/std/math.ci:15: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
.references:
	lib/std/math.ci:16: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
.references:
	lib/std/math.ci:17: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: float64((0) / 0.000000)
.references:
	lib/std/math.ci:446: referenced as `nan`
	lib/std/math.ci:366: referenced as `nan`
	lib/std/math.ci:199: referenced as `nan`
	lib/std/math.ci:187: referenced as `nan`
	lib/std/math.ci:18: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: float64((1) / 0.000000)
.references:
	lib/std/math.ci:19: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@046698>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@046698> - <@0466ee>)
	lib/std/math.ci:23: (63 bytes: <@046698> - <@0466d7>): if (bool(x < (1)))
	<modf @046698>      : 11 02                      dup.x2 sp(2)
	<modf+2 @04669a>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0466a3>   : 88                         clt.f64
	<modf+12 @0466a4>   : 06 33 00 00                jz <modf+63 @0466d7>
	lib/std/math.ci:24: (39 bytes: <@0466a8> - <@0466cf>): if (bool(x < (0)))
	<modf+16 @0466a8>   : 11 02                      dup.x2 sp(2)
	<modf+18 @0466aa>   : 1a                         load.z64
	<modf+19 @0466ab>   : 88                         clt.f64
	<modf+20 @0466ac>   : 06 23 00 00                jz <modf+55 @0466cf>
	lib/std/math.ci:25: (17 bytes: <@0466b0> - <@0466c1>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @0466b0>   : 1a                         load.z64
	<modf+25 @0466b1>   : 11 04                      dup.x2 sp(4)
	<modf+27 @0466b3>   : 80                         neg.f64
	<modf+28 @0466b4>   : 10 05                      dup.x1 sp(5)
	<modf+30 @0466b6>   : 1f 98 66 04 00             load.ref <@046698> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @0466bb>   : 02                         call
	<modf+36 @0466bc>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @0466c0>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@0466c1> - <@0466c8>): float64(intPart := float64(-intPart));
	<modf+41 @0466c1>   : 10 03                      dup.x1 sp(3)
	<modf+43 @0466c3>   : 23                         load.i64
	<modf+44 @0466c4>   : 80                         neg.f64
	<modf+45 @0466c5>   : 10 05                      dup.x1 sp(5)
	<modf+47 @0466c7>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0466c8> - <@0466cb>): return float64(.result := result);
	<modf+48 @0466c8>   : 14 06                      set.x2 sp(6)
	<modf+50 @0466ca>   : 03                         ret
	<modf+51 @0466cb>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0466cf> - <@0466d3>): float64(intPart := (0));
	<modf+55 @0466cf>   : 1a                         load.z64
	<modf+56 @0466d0>   : 10 03                      dup.x1 sp(3)
	<modf+58 @0466d2>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0466d3> - <@0466d7>): return float64(.result := x);
	<modf+59 @0466d3>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @0466d6>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0466d7> - <@0466e3>): result: float64 := float64(x % (1))
	<modf+63 @0466d7>   : 11 02                      dup.x2 sp(2)
	<modf+65 @0466d9>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @0466e2>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@0466e3> - <@0466eb>): float64(intPart := float64(x - result));
	<modf+75 @0466e3>   : 11 04                      dup.x2 sp(4)
	<modf+77 @0466e5>   : 11 02                      dup.x2 sp(2)
	<modf+79 @0466e7>   : 82                         sub.f64
	<modf+80 @0466e8>   : 10 05                      dup.x1 sp(5)
	<modf+82 @0466ea>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@0466eb> - <@0466ee>): return float64(.result := result);
	<modf+83 @0466eb>   : 14 06                      set.x2 sp(6)
	<modf+85 @0466ed>   : 03                         ret
.references:
	lib/std/math.ci:343: referenced as `modf`
	lib/std/math.ci:291: referenced as `modf`
	lib/std/math.ci:287: referenced as `modf`
	lib/std/math.ci:48: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@0466f0>
.name: 'floor'
.file: 'lib/std/math.ci:46'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@0466f0> - <@046708>)
	lib/std/math.ci:47: (1 byte: <@0466f0> - <@0466f1>): result: float64
	<floor @0466f0>      : 1b                         load.z128
	lib/std/math.ci:48: (20 bytes: <@0466f1> - <@046705>): modf(void(x, result));
	<floor+1 @0466f1>    : 11 05                      dup.x2 sp(5)
	<floor+3 @0466f3>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @0466f7>    : 1f 98 66 04 00             load.ref <@046698> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @0466fc>   : 02                         call
	<floor+13 @0466fd>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @046701>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:49: (3 bytes: <@046705> - <@046708>): return float64(.result := result);
	<floor+21 @046705>   : 14 05                      set.x2 sp(5)
	<floor+23 @046707>   : 03                         ret
.references:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:52: referenced as `floor`
	lib/std/math.ci:51: referenced as `floor`
	lib/std/math.ci:46: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:51'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(-floor(float64(-x)))
.references:
	lib/std/math.ci:51: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:52'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: floor(float64(x + 0.500000))
.references:
	lib/std/math.ci:52: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@046708>
.name: 'sign'
.file: 'lib/std/math.ci:58'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@046708> - <@04672c>)
	lib/std/math.ci:59: (12 bytes: <@046708> - <@046714>): if (bool(x == (0)))
	<sign @046708>      : 10 01                      dup.x1 sp(1)
	<sign+2 @04670a>    : 19                         load.z32
	<sign+3 @04670b>    : 77                         ceq.f32
	<sign+4 @04670c>    : 06 08 00 00                jz <sign+12 @046714>
	lib/std/math.ci:60: (4 bytes: <@046710> - <@046714>): return int32(.result := 0);
	<sign+8 @046710>    : 19                         load.z32
	<sign+9 @046711>    : 13 03                      set.x1 sp(3)
	<sign+11 @046713>   : 03                         ret
	lib/std/math.ci:62: (16 bytes: <@046714> - <@046724>): if (bool(x < (0)))
	<sign+12 @046714>   : 10 01                      dup.x1 sp(1)
	<sign+14 @046716>   : 19                         load.z32
	<sign+15 @046717>   : 78                         clt.f32
	<sign+16 @046718>   : 06 0c 00 00                jz <sign+28 @046724>
	lib/std/math.ci:63: (8 bytes: <@04671c> - <@046724>): return int32(.result := int32(-1));
	<sign+20 @04671c>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @046721>   : 13 03                      set.x1 sp(3)
	<sign+27 @046723>   : 03                         ret
	lib/std/math.ci:65: (8 bytes: <@046724> - <@04672c>): return int32(.result := 1);
	<sign+28 @046724>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @046729>   : 13 03                      set.x1 sp(3)
	<sign+35 @04672b>   : 03                         ret
.references:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:58: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@046730>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float64 (size: 8, offs: <+12>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@046730> - <@046754>)
	lib/std/math.ci:68: (12 bytes: <@046730> - <@04673c>): if (bool(x == (0)))
	<sign @046730>      : 11 01                      dup.x2 sp(1)
	<sign+2 @046732>    : 1a                         load.z64
	<sign+3 @046733>    : 87                         ceq.f64
	<sign+4 @046734>    : 06 08 00 00                jz <sign+12 @04673c>
	lib/std/math.ci:69: (4 bytes: <@046738> - <@04673c>): return int32(.result := 0);
	<sign+8 @046738>    : 19                         load.z32
	<sign+9 @046739>    : 13 04                      set.x1 sp(4)
	<sign+11 @04673b>   : 03                         ret
	lib/std/math.ci:71: (16 bytes: <@04673c> - <@04674c>): if (bool(x < (0)))
	<sign+12 @04673c>   : 11 01                      dup.x2 sp(1)
	<sign+14 @04673e>   : 1a                         load.z64
	<sign+15 @04673f>   : 88                         clt.f64
	<sign+16 @046740>   : 06 0c 00 00                jz <sign+28 @04674c>
	lib/std/math.ci:72: (8 bytes: <@046744> - <@04674c>): return int32(.result := int32(-1));
	<sign+20 @046744>   : 1c ff ff ff ff             load.c32 -1
	<sign+25 @046749>   : 13 04                      set.x1 sp(4)
	<sign+27 @04674b>   : 03                         ret
	lib/std/math.ci:74: (8 bytes: <@04674c> - <@046754>): return int32(.result := 1);
	<sign+28 @04674c>   : 1c 01 00 00 00             load.c32 1
	<sign+33 @046751>   : 13 04                      set.x1 sp(4)
	<sign+35 @046753>   : 03                         ret
.references:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@046758>
.name: 'abs'
.file: 'lib/std/math.ci:83'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@046758> - <@04676a>)
	lib/std/math.ci:84: (14 bytes: <@046758> - <@046766>): if (bool(x < (0)))
	<abs @046758>      : 10 01                      dup.x1 sp(1)
	<abs+2 @04675a>    : 19                         load.z32
	<abs+3 @04675b>    : 78                         clt.f32
	<abs+4 @04675c>    : 06 0a 00 00                jz <abs+14 @046766>
	lib/std/math.ci:85: (6 bytes: <@046760> - <@046766>): return float32(.result := float32(-x));
	<abs+8 @046760>    : 10 01                      dup.x1 sp(1)
	<abs+10 @046762>   : 70                         neg.f32
	<abs+11 @046763>   : 13 03                      set.x1 sp(3)
	<abs+13 @046765>   : 03                         ret
	lib/std/math.ci:87: (4 bytes: <@046766> - <@04676a>): return float32(.result := x);
	<abs+14 @046766>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @046769>   : 03                         ret
.references:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:83: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@046770>
.name: 'abs'
.file: 'lib/std/math.ci:89'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@046770> - <@046782>)
	lib/std/math.ci:90: (14 bytes: <@046770> - <@04677e>): if (bool(x < (0)))
	<abs @046770>      : 11 01                      dup.x2 sp(1)
	<abs+2 @046772>    : 1a                         load.z64
	<abs+3 @046773>    : 88                         clt.f64
	<abs+4 @046774>    : 06 0a 00 00                jz <abs+14 @04677e>
	lib/std/math.ci:91: (6 bytes: <@046778> - <@04677e>): return float64(.result := float64(-x));
	<abs+8 @046778>    : 11 01                      dup.x2 sp(1)
	<abs+10 @04677a>   : 80                         neg.f64
	<abs+11 @04677b>   : 14 05                      set.x2 sp(5)
	<abs+13 @04677d>   : 03                         ret
	lib/std/math.ci:93: (4 bytes: <@04677e> - <@046782>): return float64(.result := x);
	<abs+14 @04677e>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @046781>   : 03                         ret
.references:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.ci:317: referenced as `abs`
	lib/std/math.ci:89: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@046788>
.name: 'absMod'
.file: 'lib/std/math.ci:95'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@046788> - <@0467a3>)
	lib/std/math.ci:96: (23 bytes: <@046788> - <@04679f>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @046788>      : 10 02                      dup.x1 sp(2)
	<absMod+2 @04678a>    : 10 02                      dup.x1 sp(2)
	<absMod+4 @04678c>    : 75                         mod.f32
	<absMod+5 @04678d>    : 10 00                      dup.x1 sp(0)
	<absMod+7 @04678f>    : 13 04                      set.x1 sp(4)
	<absMod+9 @046791>    : 19                         load.z32
	<absMod+10 @046792>   : 78                         clt.f32
	<absMod+11 @046793>   : 06 0c 00 00                jz <absMod+23 @04679f>
	lib/std/math.ci:97: (8 bytes: <@046797> - <@04679f>): return float32(.result := float32(val + mod));
	<absMod+15 @046797>   : 10 02                      dup.x1 sp(2)
	<absMod+17 @046799>   : 10 02                      dup.x1 sp(2)
	<absMod+19 @04679b>   : 71                         add.f32
	<absMod+20 @04679c>   : 13 04                      set.x1 sp(4)
	<absMod+22 @04679e>   : 03                         ret
	lib/std/math.ci:99: (4 bytes: <@04679f> - <@0467a3>): return float32(.result := val);
	<absMod+23 @04679f>   : 16 03 02                   mov.x1 sp(3, 2)
	<absMod+26 @0467a2>   : 03                         ret
.references:
	test/stdc/test.math.ci:98: referenced as `absMod`
	test/stdc/test.math.ci:97: referenced as `absMod`
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:92: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:87: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	lib/std/math.ci:95: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@0467a8>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@0467a8> - <@0467c3>)
	lib/std/math.ci:102: (23 bytes: <@0467a8> - <@0467bf>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @0467a8>      : 11 03                      dup.x2 sp(3)
	<absMod+2 @0467aa>    : 11 03                      dup.x2 sp(3)
	<absMod+4 @0467ac>    : 85                         mod.f64
	<absMod+5 @0467ad>    : 11 00                      dup.x2 sp(0)
	<absMod+7 @0467af>    : 14 07                      set.x2 sp(7)
	<absMod+9 @0467b1>    : 1a                         load.z64
	<absMod+10 @0467b2>   : 88                         clt.f64
	<absMod+11 @0467b3>   : 06 0c 00 00                jz <absMod+23 @0467bf>
	lib/std/math.ci:103: (8 bytes: <@0467b7> - <@0467bf>): return float64(.result := float64(val + mod));
	<absMod+15 @0467b7>   : 11 03                      dup.x2 sp(3)
	<absMod+17 @0467b9>   : 11 03                      dup.x2 sp(3)
	<absMod+19 @0467bb>   : 81                         add.f64
	<absMod+20 @0467bc>   : 14 07                      set.x2 sp(7)
	<absMod+22 @0467be>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@0467bf> - <@0467c3>): return float64(.result := val);
	<absMod+23 @0467bf>   : 17 05 03                   mov.x2 sp(5, 3)
	<absMod+26 @0467c2>   : 03                         ret
.references:
	test/stdc/test.math.ci:84: referenced as `absMod`
	test/stdc/test.math.ci:83: referenced as `absMod`
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:78: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:73: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0467c8>
.name: 'min'
.file: 'lib/std/math.ci:114'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0467c8> - <@0467d9>)
	lib/std/math.ci:115: (13 bytes: <@0467c8> - <@0467d5>): if (bool(a < b))
	<min @0467c8>      : 10 02                      dup.x1 sp(2)
	<min+2 @0467ca>    : 10 02                      dup.x1 sp(2)
	<min+4 @0467cc>    : 78                         clt.f32
	<min+5 @0467cd>    : 06 08 00 00                jz <min+13 @0467d5>
	lib/std/math.ci:116: (4 bytes: <@0467d1> - <@0467d5>): return float32(.result := a);
	<min+9 @0467d1>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @0467d4>   : 03                         ret
	lib/std/math.ci:118: (4 bytes: <@0467d5> - <@0467d9>): return float32(.result := b);
	<min+13 @0467d5>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @0467d8>   : 03                         ret
.references:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:114: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0467e0>
.name: 'min'
.file: 'lib/std/math.ci:120'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0467e0> - <@0467f1>)
	lib/std/math.ci:121: (13 bytes: <@0467e0> - <@0467ed>): if (bool(a < b))
	<min @0467e0>      : 11 03                      dup.x2 sp(3)
	<min+2 @0467e2>    : 11 03                      dup.x2 sp(3)
	<min+4 @0467e4>    : 88                         clt.f64
	<min+5 @0467e5>    : 06 08 00 00                jz <min+13 @0467ed>
	lib/std/math.ci:122: (4 bytes: <@0467e9> - <@0467ed>): return float64(.result := a);
	<min+9 @0467e9>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @0467ec>   : 03                         ret
	lib/std/math.ci:124: (4 bytes: <@0467ed> - <@0467f1>): return float64(.result := b);
	<min+13 @0467ed>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @0467f0>   : 03                         ret
.references:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:120: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0467f8>
.name: 'max'
.file: 'lib/std/math.ci:132'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0467f8> - <@046809>)
	lib/std/math.ci:133: (13 bytes: <@0467f8> - <@046805>): if (bool(a > b))
	<max @0467f8>      : 10 02                      dup.x1 sp(2)
	<max+2 @0467fa>    : 10 02                      dup.x1 sp(2)
	<max+4 @0467fc>    : 79                         cgt.f32
	<max+5 @0467fd>    : 06 08 00 00                jz <max+13 @046805>
	lib/std/math.ci:134: (4 bytes: <@046801> - <@046805>): return float32(.result := a);
	<max+9 @046801>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @046804>   : 03                         ret
	lib/std/math.ci:136: (4 bytes: <@046805> - <@046809>): return float32(.result := b);
	<max+13 @046805>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @046808>   : 03                         ret
.references:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:132: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@046810>
.name: 'max'
.file: 'lib/std/math.ci:138'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@046810> - <@046821>)
	lib/std/math.ci:139: (13 bytes: <@046810> - <@04681d>): if (bool(a > b))
	<max @046810>      : 11 03                      dup.x2 sp(3)
	<max+2 @046812>    : 11 03                      dup.x2 sp(3)
	<max+4 @046814>    : 89                         cgt.f64
	<max+5 @046815>    : 06 08 00 00                jz <max+13 @04681d>
	lib/std/math.ci:140: (4 bytes: <@046819> - <@04681d>): return float64(.result := a);
	<max+9 @046819>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @04681c>   : 03                         ret
	lib/std/math.ci:142: (4 bytes: <@04681d> - <@046821>): return float64(.result := b);
	<max+13 @04681d>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @046820>   : 03                         ret
.references:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:138: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@046828>
.name: 'clamp'
.file: 'lib/std/math.ci:150'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@046828> - <@046846>)
	lib/std/math.ci:151: (13 bytes: <@046828> - <@046835>): if (bool(t < a))
	<clamp @046828>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @04682a>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @04682c>    : 78                         clt.f32
	<clamp+5 @04682d>    : 06 08 00 00                jz <clamp+13 @046835>
	lib/std/math.ci:152: (4 bytes: <@046831> - <@046835>): return float32(.result := a);
	<clamp+9 @046831>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @046834>   : 03                         ret
	lib/std/math.ci:154: (13 bytes: <@046835> - <@046842>): if (bool(t > b))
	<clamp+13 @046835>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @046837>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @046839>   : 79                         cgt.f32
	<clamp+18 @04683a>   : 06 08 00 00                jz <clamp+26 @046842>
	lib/std/math.ci:155: (4 bytes: <@04683e> - <@046842>): return float32(.result := b);
	<clamp+22 @04683e>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @046841>   : 03                         ret
	lib/std/math.ci:157: (4 bytes: <@046842> - <@046846>): return float32(.result := t);
	<clamp+26 @046842>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @046845>   : 03                         ret
.references:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:178: referenced as `clamp`
	lib/std/math.ci:150: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@046848>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@046848> - <@046866>)
	lib/std/math.ci:160: (13 bytes: <@046848> - <@046855>): if (bool(t < a))
	<clamp @046848>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @04684a>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @04684c>    : 88                         clt.f64
	<clamp+5 @04684d>    : 06 08 00 00                jz <clamp+13 @046855>
	lib/std/math.ci:161: (4 bytes: <@046851> - <@046855>): return float64(.result := a);
	<clamp+9 @046851>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @046854>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@046855> - <@046862>): if (bool(t > b))
	<clamp+13 @046855>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @046857>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @046859>   : 89                         cgt.f64
	<clamp+18 @04685a>   : 06 08 00 00                jz <clamp+26 @046862>
	lib/std/math.ci:164: (4 bytes: <@04685e> - <@046862>): return float64(.result := b);
	<clamp+22 @04685e>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @046861>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@046862> - <@046866>): return float64(.result := t);
	<clamp+26 @046862>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @046865>   : 03                         ret
.references:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:179: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:173'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: float32(a + float32(t * (float32(b - a))))
.references:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:173: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:174'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: float64(a + float64(t * (float64(b - a))))
.references:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:174: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:176'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.references:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:178: referenced as `smooth`
	lib/std/math.ci:176: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:177'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.references:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:179: referenced as `smooth`
	lib/std/math.ci:177: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:178'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.references:
	test/stdc/test.math.ci:37: referenced as `smooth`
	lib/std/math.ci:178: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:179'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.references:
	test/stdc/test.math.ci:38: referenced as `smooth`
	lib/std/math.ci:179: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@046868>
.name: 'min'
.file: 'lib/std/math.ci:185'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@046868> - <@0468b0>)
	lib/std/math.ci:186: (13 bytes: <@046868> - <@046875>): if (bool(data.length == (0)))
	<min @046868>      : 10 02                      dup.x1 sp(2)
	<min+2 @04686a>    : 19                         load.z32
	<min+3 @04686b>    : 57                         ceq.i32
	<min+4 @04686c>    : 06 09 00 00                jz <min+13 @046875>
	lib/std/math.ci:187: (5 bytes: <@046870> - <@046875>): return float64(.result := nan);
	<min+8 @046870>    : 1b                         load.z128
	<min+9 @046871>    : 84                         div.f64
	<min+10 @046872>   : 14 05                      set.x2 sp(5)
	<min+12 @046874>   : 03                         ret
	lib/std/math.ci:189: (3 bytes: <@046875> - <@046878>): result: float64 := data[0]
	<min+13 @046875>   : 10 01                      dup.x1 sp(1)
	<min+15 @046877>   : 23                         load.i64
	lib/std/math.ci:190: (53 bytes: <@046878> - <@0468ad>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @046878>   : 1c 01 00 00 00             load.c32 1
	<min+21 @04687d>   : 04 23 00 00                jmp <min+56 @0468a0>
	lib/std/math.ci:191: (27 bytes: <@046881> - <@04689c>): if (bool(result > data[i]))
	<min+25 @046881>   : 11 01                      dup.x2 sp(1)
	<min+27 @046883>   : 10 06                      dup.x1 sp(6)
	<min+29 @046885>   : 10 03                      dup.x1 sp(3)
	<min+31 @046887>   : 0d 08 00 00                mad.u32 8
	<min+35 @04688b>   : 23                         load.i64
	<min+36 @04688c>   : 89                         cgt.f64
	<min+37 @04688d>   : 06 0f 00 00                jz <min+52 @04689c>
	lib/std/math.ci:192: (11 bytes: <@046891> - <@04689c>): float64(result := data[i]);
	<min+41 @046891>   : 10 04                      dup.x1 sp(4)
	<min+43 @046893>   : 10 01                      dup.x1 sp(1)
	<min+45 @046895>   : 0d 08 00 00                mad.u32 8
	<min+49 @046899>   : 23                         load.i64
	<min+50 @04689a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:190: (4 bytes: <@04689c> - <@0468a0>): int32(i := int32(i + 1))
	<min+52 @04689c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:190: (9 bytes: <@0468a0> - <@0468a9>): bool(i < (data.length))
	<min+56 @0468a0>   : 10 00                      dup.x1 sp(0)
	<min+58 @0468a2>   : 10 06                      dup.x1 sp(6)
	<min+60 @0468a4>   : 58                         clt.i32
	<min+61 @0468a5>   : 05 dc ff ff                jnz <min+25 @046881>
	<min+65 @0468a9>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:195: (3 bytes: <@0468ad> - <@0468b0>): return float64(.result := result);
	<min+69 @0468ad>   : 14 05                      set.x2 sp(5)
	<min+71 @0468af>   : 03                         ret
.references:
	test/stdc/test.math.ci:41: referenced as `min`
	test/stdc/test.math.ci:40: referenced as `min`
	lib/std/math.ci:185: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@0468b0>
.name: 'max'
.file: 'lib/std/math.ci:197'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@0468b0> - <@0468f8>)
	lib/std/math.ci:198: (13 bytes: <@0468b0> - <@0468bd>): if (bool(data.length == (0)))
	<max @0468b0>      : 10 02                      dup.x1 sp(2)
	<max+2 @0468b2>    : 19                         load.z32
	<max+3 @0468b3>    : 57                         ceq.i32
	<max+4 @0468b4>    : 06 09 00 00                jz <max+13 @0468bd>
	lib/std/math.ci:199: (5 bytes: <@0468b8> - <@0468bd>): return float64(.result := nan);
	<max+8 @0468b8>    : 1b                         load.z128
	<max+9 @0468b9>    : 84                         div.f64
	<max+10 @0468ba>   : 14 05                      set.x2 sp(5)
	<max+12 @0468bc>   : 03                         ret
	lib/std/math.ci:201: (3 bytes: <@0468bd> - <@0468c0>): result: float64 := data[0]
	<max+13 @0468bd>   : 10 01                      dup.x1 sp(1)
	<max+15 @0468bf>   : 23                         load.i64
	lib/std/math.ci:202: (53 bytes: <@0468c0> - <@0468f5>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @0468c0>   : 1c 01 00 00 00             load.c32 1
	<max+21 @0468c5>   : 04 23 00 00                jmp <max+56 @0468e8>
	lib/std/math.ci:203: (27 bytes: <@0468c9> - <@0468e4>): if (bool(result < data[i]))
	<max+25 @0468c9>   : 11 01                      dup.x2 sp(1)
	<max+27 @0468cb>   : 10 06                      dup.x1 sp(6)
	<max+29 @0468cd>   : 10 03                      dup.x1 sp(3)
	<max+31 @0468cf>   : 0d 08 00 00                mad.u32 8
	<max+35 @0468d3>   : 23                         load.i64
	<max+36 @0468d4>   : 88                         clt.f64
	<max+37 @0468d5>   : 06 0f 00 00                jz <max+52 @0468e4>
	lib/std/math.ci:204: (11 bytes: <@0468d9> - <@0468e4>): float64(result := data[i]);
	<max+41 @0468d9>   : 10 04                      dup.x1 sp(4)
	<max+43 @0468db>   : 10 01                      dup.x1 sp(1)
	<max+45 @0468dd>   : 0d 08 00 00                mad.u32 8
	<max+49 @0468e1>   : 23                         load.i64
	<max+50 @0468e2>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:202: (4 bytes: <@0468e4> - <@0468e8>): int32(i := int32(i + 1))
	<max+52 @0468e4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:202: (9 bytes: <@0468e8> - <@0468f1>): bool(i < (data.length))
	<max+56 @0468e8>   : 10 00                      dup.x1 sp(0)
	<max+58 @0468ea>   : 10 06                      dup.x1 sp(6)
	<max+60 @0468ec>   : 58                         clt.i32
	<max+61 @0468ed>   : 05 dc ff ff                jnz <max+25 @0468c9>
	<max+65 @0468f1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:207: (3 bytes: <@0468f5> - <@0468f8>): return float64(.result := result);
	<max+69 @0468f5>   : 14 05                      set.x2 sp(5)
	<max+71 @0468f7>   : 03                         ret
.references:
	test/stdc/test.math.ci:43: referenced as `max`
	test/stdc/test.math.ci:42: referenced as `max`
	lib/std/math.ci:197: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@0468f8>
.name: 'sum'
.file: 'lib/std/math.ci:210'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@0468f8> - <@046920>)
	lib/std/math.ci:211: (1 byte: <@0468f8> - <@0468f9>): result: float64 := 0
	<sum @0468f8>      : 1b                         load.z128
	lib/std/math.ci:212: (36 bytes: <@0468f9> - <@04691d>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @0468f9>    : 6a                         i64.2i32
	<sum+2 @0468fa>    : 04 16 00 00                jmp <sum+24 @046910>
	lib/std/math.ci:213: (14 bytes: <@0468fe> - <@04690c>): float64(result := float64(result + data[i]));
	<sum+6 @0468fe>    : 11 01                      dup.x2 sp(1)
	<sum+8 @046900>    : 10 06                      dup.x1 sp(6)
	<sum+10 @046902>   : 10 03                      dup.x1 sp(3)
	<sum+12 @046904>   : 0d 08 00 00                mad.u32 8
	<sum+16 @046908>   : 23                         load.i64
	<sum+17 @046909>   : 81                         add.f64
	<sum+18 @04690a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:212: (4 bytes: <@04690c> - <@046910>): int32(i := int32(i + 1))
	<sum+20 @04690c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:212: (9 bytes: <@046910> - <@046919>): bool(i < (data.length))
	<sum+24 @046910>   : 10 00                      dup.x1 sp(0)
	<sum+26 @046912>   : 10 06                      dup.x1 sp(6)
	<sum+28 @046914>   : 58                         clt.i32
	<sum+29 @046915>   : 05 e9 ff ff                jnz <sum+6 @0468fe>
	<sum+33 @046919>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:215: (3 bytes: <@04691d> - <@046920>): return float64(.result := result);
	<sum+37 @04691d>   : 14 05                      set.x2 sp(5)
	<sum+39 @04691f>   : 03                         ret
.references:
	test/stdc/test.math.ci:48: referenced as `sum`
	test/stdc/test.math.ci:47: referenced as `sum`
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	lib/std/math.ci:210: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:224'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.value: (a0)
.references:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:224: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:225'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.value: (float64(a0 + float64(x * a1)))
.references:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:226: referenced as `eval`
	lib/std/math.ci:225: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:226'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.references:
	test/stdc/test.math.ci:54: referenced as `eval`
	lib/std/math.ci:227: referenced as `eval`
	lib/std/math.ci:226: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:227'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.references:
	test/stdc/test.math.ci:55: referenced as `eval`
	lib/std/math.ci:227: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@046920>
.name: 'eval'
.file: 'lib/std/math.ci:228'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@046920> - <@04694f>)
	lib/std/math.ci:229: (1 byte: <@046920> - <@046921>): result: float64 := 0
	<eval @046920>      : 1a                         load.z64
	lib/std/math.ci:230: (43 bytes: <@046921> - <@04694c>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @046921>    : 10 04                      dup.x1 sp(4)
	<eval+3 @046923>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @046927>    : 04 19 00 00                jmp <eval+32 @046940>
	lib/std/math.ci:231: (17 bytes: <@04692b> - <@04693c>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @04692b>   : 11 01                      dup.x2 sp(1)
	<eval+13 @04692d>   : 11 08                      dup.x2 sp(8)
	<eval+15 @04692f>   : 83                         mul.f64
	<eval+16 @046930>   : 10 06                      dup.x1 sp(6)
	<eval+18 @046932>   : 10 03                      dup.x1 sp(3)
	<eval+20 @046934>   : 0d 08 00 00                mad.u32 8
	<eval+24 @046938>   : 23                         load.i64
	<eval+25 @046939>   : 81                         add.f64
	<eval+26 @04693a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:230: (4 bytes: <@04693c> - <@046940>): int32(i := int32(i - 1))
	<eval+28 @04693c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:230: (8 bytes: <@046940> - <@046948>): bool(i >= 0)
	<eval+32 @046940>   : 10 00                      dup.x1 sp(0)
	<eval+34 @046942>   : 19                         load.z32
	<eval+35 @046943>   : 58                         clt.i32
	<eval+36 @046944>   : 06 e7 ff ff                jz <eval+11 @04692b>
	<eval+40 @046948>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:233: (3 bytes: <@04694c> - <@04694f>): return float64(.result := result);
	<eval+44 @04694c>   : 14 07                      set.x2 sp(7)
	<eval+46 @04694e>   : 03                         ret
.references:
	test/stdc/test.math.ci:57: referenced as `eval`
	test/stdc/test.math.ci:56: referenced as `eval`
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:228: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@046950>
.name: 'cmp'
.file: 'lib/std/math.ci:236'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@046950> - <@046989>)
	lib/std/math.ci:237: (53 bytes: <@046950> - <@046985>): if (bool(a < b))
	<cmp @046950>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @046952>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @046954>    : 78                         clt.f32
	<cmp+5 @046955>    : 06 1c 00 00                jz <cmp+33 @046971>
	lib/std/math.ci:238: (20 bytes: <@046959> - <@04696d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @046959>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @04695b>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @04695d>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @04695f>   : 72                         sub.f32
	<cmp+16 @046960>   : 78                         clt.f32
	<cmp+17 @046961>   : 06 0c 00 00                jz <cmp+29 @04696d>
	lib/std/math.ci:239: (8 bytes: <@046965> - <@04696d>): return int32(.result := int32(-1));
	<cmp+21 @046965>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04696a>   : 13 05                      set.x1 sp(5)
	<cmp+28 @04696c>   : 03                         ret
	<cmp+29 @04696d>   : 04 18 00 00                jmp <cmp+53 @046985>
	lib/std/math.ci:243: (20 bytes: <@046971> - <@046985>): if (bool(eps < (float32(a - b))))
	<cmp+33 @046971>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @046973>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @046975>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @046977>   : 72                         sub.f32
	<cmp+40 @046978>   : 78                         clt.f32
	<cmp+41 @046979>   : 06 0c 00 00                jz <cmp+53 @046985>
	lib/std/math.ci:244: (8 bytes: <@04697d> - <@046985>): return int32(.result := int32(+1));
	<cmp+45 @04697d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @046982>   : 13 05                      set.x1 sp(5)
	<cmp+52 @046984>   : 03                         ret
	lib/std/math.ci:247: (4 bytes: <@046985> - <@046989>): return int32(.result := 0);
	<cmp+53 @046985>   : 19                         load.z32
	<cmp+54 @046986>   : 13 05                      set.x1 sp(5)
	<cmp+56 @046988>   : 03                         ret
.references:
	test/stdc/test.math.ci:69: referenced as `cmp`
	lib/std/math.ci:236: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@046990>
.name: 'cmp'
.file: 'lib/std/math.ci:249'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@046990> - <@0469c9>)
	lib/std/math.ci:250: (53 bytes: <@046990> - <@0469c5>): if (bool(a < b))
	<cmp @046990>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @046992>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @046994>    : 88                         clt.f64
	<cmp+5 @046995>    : 06 1c 00 00                jz <cmp+33 @0469b1>
	lib/std/math.ci:251: (20 bytes: <@046999> - <@0469ad>): if (bool(eps < (float64(b - a))))
	<cmp+9 @046999>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @04699b>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @04699d>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @04699f>   : 82                         sub.f64
	<cmp+16 @0469a0>   : 88                         clt.f64
	<cmp+17 @0469a1>   : 06 0c 00 00                jz <cmp+29 @0469ad>
	lib/std/math.ci:252: (8 bytes: <@0469a5> - <@0469ad>): return int32(.result := int32(-1));
	<cmp+21 @0469a5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @0469aa>   : 13 08                      set.x1 sp(8)
	<cmp+28 @0469ac>   : 03                         ret
	<cmp+29 @0469ad>   : 04 18 00 00                jmp <cmp+53 @0469c5>
	lib/std/math.ci:256: (20 bytes: <@0469b1> - <@0469c5>): if (bool(eps < (float64(a - b))))
	<cmp+33 @0469b1>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @0469b3>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @0469b5>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @0469b7>   : 82                         sub.f64
	<cmp+40 @0469b8>   : 88                         clt.f64
	<cmp+41 @0469b9>   : 06 0c 00 00                jz <cmp+53 @0469c5>
	lib/std/math.ci:257: (8 bytes: <@0469bd> - <@0469c5>): return int32(.result := int32(+1));
	<cmp+45 @0469bd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @0469c2>   : 13 08                      set.x1 sp(8)
	<cmp+52 @0469c4>   : 03                         ret
	lib/std/math.ci:260: (4 bytes: <@0469c5> - <@0469c9>): return int32(.result := 0);
	<cmp+53 @0469c5>   : 19                         load.z32
	<cmp+54 @0469c6>   : 13 08                      set.x1 sp(8)
	<cmp+56 @0469c8>   : 03                         ret
.references:
	test/stdc/test.math.ci:70: referenced as `cmp`
	lib/std/math.ci:249: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@0469d0>
.name: 'sinCos'
.file: 'lib/std/math.ci:263'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@0469d0> - <@046b1f>)
	lib/std/math.ci:277: (2 bytes: <@0469d0> - <@0469d2>): x: float64 := arg
	<sinCos @0469d0>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:278: (17 bytes: <@0469d2> - <@0469e3>): if (bool(x < (0)))
	<sinCos+2 @0469d2>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @0469d4>    : 1a                         load.z64
	<sinCos+5 @0469d5>    : 88                         clt.f64
	<sinCos+6 @0469d6>    : 06 0d 00 00                jz <sinCos+19 @0469e3>
	lib/std/math.ci:279: (1 byte: <@0469da> - <@0469db>): float64(x := float64(-x));
	<sinCos+10 @0469da>   : 80                         neg.f64
	lib/std/math.ci:280: (8 bytes: <@0469db> - <@0469e3>): int32(quad := int32(quad + 2));
	<sinCos+11 @0469db>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @0469dd>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @0469e1>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:283: (1 byte: <@0469e3> - <@0469e4>): y: float64
	<sinCos+19 @0469e3>   : 1a                         load.z64
	lib/std/math.ci:284: (24 bytes: <@0469e4> - <@0469fc>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @0469e4>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @0469e6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @0469ef>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @0469f8>   : 84                         div.f64
	<sinCos+41 @0469f9>   : 83                         mul.f64
	<sinCos+42 @0469fa>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:285: (124 bytes: <@0469fc> - <@046a78>): if (bool(x > (32764)))
	<sinCos+44 @0469fc>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @0469fe>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @046a07>   : 89                         cgt.f64
	<sinCos+56 @046a08>   : 06 54 00 00                jz <sinCos+140 @046a5c>
	lib/std/math.ci:286: (1 byte: <@046a0c> - <@046a0d>): e: float64
	<sinCos+60 @046a0c>   : 1b                         load.z128
	lib/std/math.ci:287: (18 bytes: <@046a0d> - <@046a1f>): float64(y := modf(void(x, e)));
	<sinCos+61 @046a0d>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @046a0f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @046a13>   : 1f 98 66 04 00             load.ref <@046698> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @046a18>   : 02                         call
	<sinCos+73 @046a19>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @046a1d>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:288: (4 bytes: <@046a1f> - <@046a23>): float64(e := float64(e + (quad)));
	<sinCos+79 @046a1f>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @046a21>   : 5d                         i32.2f64
	<sinCos+82 @046a22>   : 81                         add.f64
	lib/std/math.ci:290: (1 byte: <@046a23> - <@046a24>): f: float64
	<sinCos+83 @046a23>   : 1b                         load.z128
	lib/std/math.ci:291: (30 bytes: <@046a24> - <@046a42>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @046a24>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @046a2d>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @046a2f>   : 83                         mul.f64
	<sinCos+96 @046a30>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @046a34>  : 1f 98 66 04 00             load.ref <@046698> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @046a39>  : 02                         call
	<sinCos+106 @046a3a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @046a3e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:292: (18 bytes: <@046a42> - <@046a54>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @046a42>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @046a44>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @046a4d>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @046a4f>  : 83                         mul.f64
	<sinCos+128 @046a50>  : 82                         sub.f64
	<sinCos+129 @046a51>  : 8a                         f64.2i32
	<sinCos+130 @046a52>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @046a54>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @046a58>  : 04 20 00 00                jmp <sinCos+168 @046a78>
	lib/std/math.ci:295: (3 bytes: <@046a5c> - <@046a5f>): k: int32 := x
	<sinCos+140 @046a5c>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @046a5e>  : 8a                         f64.2i32
	lib/std/math.ci:296: (8 bytes: <@046a5f> - <@046a67>): float64(y := float64(x - (k)));
	<sinCos+143 @046a5f>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @046a61>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @046a63>  : 5d                         i32.2f64
	<sinCos+148 @046a64>  : 82                         sub.f64
	<sinCos+149 @046a65>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:297: (7 bytes: <@046a67> - <@046a6e>): int32(quad := int32(quad + k));
	<sinCos+151 @046a67>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @046a69>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @046a6b>  : 51                         add.i32
	<sinCos+156 @046a6c>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:298: (6 bytes: <@046a6e> - <@046a74>): int32(quad := int32(quad & 3));
	<sinCos+158 @046a6e>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @046a70>  : 3f 02                      b32.and 0x003
	<sinCos+162 @046a72>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @046a74>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:300: (22 bytes: <@046a78> - <@046a8e>): if (int32(quad & 1))
	<sinCos+168 @046a78>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @046a7a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @046a7c>  : 06 12 00 00                jz <sinCos+190 @046a8e>
	lib/std/math.ci:301: (14 bytes: <@046a80> - <@046a8e>): float64(y := float64((1) - y));
	<sinCos+176 @046a80>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @046a89>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @046a8b>  : 82                         sub.f64
	<sinCos+188 @046a8c>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:303: (13 bytes: <@046a8e> - <@046a9b>): if (bool(quad > 1))
	<sinCos+190 @046a8e>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @046a90>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @046a95>  : 59                         cgt.i32
	<sinCos+198 @046a96>  : 06 05 00 00                jz <sinCos+203 @046a9b>
	lib/std/math.ci:304: (1 byte: <@046a9a> - <@046a9b>): float64(y := float64(-y));
	<sinCos+202 @046a9a>  : 80                         neg.f64
	lib/std/math.ci:307: (5 bytes: <@046a9b> - <@046aa0>): ysq: float64 := float64(y * y)
	<sinCos+203 @046a9b>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @046a9d>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @046a9f>  : 83                         mul.f64
	lib/std/math.ci:308: (64 bytes: <@046aa0> - <@046ae0>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @046aa0>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @046aa9>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @046aab>  : 83                         mul.f64
	<sinCos+220 @046aac>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @046ab5>  : 81                         add.f64
	<sinCos+230 @046ab6>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @046ab8>  : 83                         mul.f64
	<sinCos+233 @046ab9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @046ac2>  : 81                         add.f64
	<sinCos+243 @046ac3>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @046ac5>  : 83                         mul.f64
	<sinCos+246 @046ac6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @046acf>  : 81                         add.f64
	<sinCos+256 @046ad0>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @046ad2>  : 83                         mul.f64
	<sinCos+259 @046ad3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @046adc>  : 81                         add.f64
	<sinCos+269 @046add>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @046adf>  : 83                         mul.f64
	lib/std/math.ci:309: (51 bytes: <@046ae0> - <@046b13>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @046ae0>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @046ae2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @046aeb>  : 81                         add.f64
	<sinCos+284 @046aec>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @046aee>  : 83                         mul.f64
	<sinCos+287 @046aef>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @046af8>  : 81                         add.f64
	<sinCos+297 @046af9>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @046afb>  : 83                         mul.f64
	<sinCos+300 @046afc>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @046b05>  : 81                         add.f64
	<sinCos+310 @046b06>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @046b08>  : 83                         mul.f64
	<sinCos+313 @046b09>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @046b12>  : 81                         add.f64
	lib/std/math.ci:310: (12 bytes: <@046b13> - <@046b1f>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @046b13>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @046b15>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @046b17>  : 84                         div.f64
	<sinCos+328 @046b18>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @046b1a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @046b1e>  : 03                         ret
.references:
	lib/std/math.ci:317: referenced as `sinCos`
	lib/std/math.ci:314: referenced as `sinCos`
	lib/std/math.ci:263: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:314'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(arg, 0))
.references:
	test/stdc/test.math.ci:59: referenced as `sin`
	lib/std/math.ci:314: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:317'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(abs(arg), 1))
.references:
	test/stdc/test.math.ci:60: referenced as `cos`
	lib/std/math.ci:317: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@046b20>
.name: 'tan'
.file: 'lib/std/math.ci:320'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@046b20> - <@046c93>)
	lib/std/math.ci:333: (1 byte: <@046b20> - <@046b21>): complement: bool := false
	<tan @046b20>      : 19                         load.z32
	lib/std/math.ci:334: (1 byte: <@046b21> - <@046b22>): negate: bool := false
	<tan+1 @046b21>    : 19                         load.z32
	lib/std/math.ci:336: (23 bytes: <@046b22> - <@046b39>): if (bool(arg < (0)))
	<tan+2 @046b22>    : 11 03                      dup.x2 sp(3)
	<tan+4 @046b24>    : 1a                         load.z64
	<tan+5 @046b25>    : 88                         clt.f64
	<tan+6 @046b26>    : 06 13 00 00                jz <tan+25 @046b39>
	lib/std/math.ci:337: (5 bytes: <@046b2a> - <@046b2f>): float64(arg := float64(-arg));
	<tan+10 @046b2a>   : 11 03                      dup.x2 sp(3)
	<tan+12 @046b2c>   : 80                         neg.f64
	<tan+13 @046b2d>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:338: (10 bytes: <@046b2f> - <@046b39>): bool(negate := true);
	<tan+15 @046b2f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @046b34>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @046b38>   : 25                         store.i8
	lib/std/math.ci:340: (24 bytes: <@046b39> - <@046b51>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @046b39>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @046b42>   : 11 05                      dup.x2 sp(5)
	<tan+36 @046b44>   : 83                         mul.f64
	<tan+37 @046b45>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @046b4e>   : 84                         div.f64
	<tan+47 @046b4f>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:342: (1 byte: <@046b51> - <@046b52>): e: float64
	<tan+49 @046b51>   : 1b                         load.z128
	lib/std/math.ci:343: (16 bytes: <@046b52> - <@046b62>): x: float64 := modf(void(arg, e))
	<tan+50 @046b52>   : 11 07                      dup.x2 sp(7)
	<tan+52 @046b54>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @046b58>   : 1f 98 66 04 00             load.ref <@046698> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @046b5d>   : 02                         call
	<tan+62 @046b5e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:344: (9 bytes: <@046b62> - <@046b6b>): i: int32 := int32(int32(e) % 4)
	<tan+66 @046b62>   : 11 02                      dup.x2 sp(2)
	<tan+68 @046b64>   : 8a                         f64.2i32
	<tan+69 @046b65>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @046b6a>   : 55                         mod.i32
	lib/std/math.ci:346: (122 bytes: <@046b6b> - <@046be5>): if (bool(i == 0))
	<tan+75 @046b6b>   : 10 00                      dup.x1 sp(0)
	<tan+77 @046b6d>   : 19                         load.z32
	<tan+78 @046b6e>   : 57                         ceq.i32
	<tan+79 @046b6f>   : 05 76 00 00                jnz <tan+197 @046be5>
	lib/std/math.ci:347: (114 bytes: <@046b73> - <@046be5>): if (bool(i == 1))
	<tan+83 @046b73>   : 10 00                      dup.x1 sp(0)
	<tan+85 @046b75>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @046b7a>   : 57                         ceq.i32
	<tan+91 @046b7b>   : 06 20 00 00                jz <tan+123 @046b9b>
	lib/std/math.ci:348: (14 bytes: <@046b7f> - <@046b8d>): float64(x := float64((1) - x));
	<tan+95 @046b7f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @046b88>  : 11 03                      dup.x2 sp(3)
	<tan+106 @046b8a>  : 82                         sub.f64
	<tan+107 @046b8b>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:349: (10 bytes: <@046b8d> - <@046b97>): bool(complement := true);
	<tan+109 @046b8d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @046b92>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @046b96>  : 25                         store.i8
	<tan+119 @046b97>  : 04 4e 00 00                jmp <tan+197 @046be5>
	lib/std/math.ci:351: (74 bytes: <@046b9b> - <@046be5>): if (bool(i == 2))
	<tan+123 @046b9b>  : 10 00                      dup.x1 sp(0)
	<tan+125 @046b9d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @046ba2>  : 57                         ceq.i32
	<tan+131 @046ba3>  : 06 1d 00 00                jz <tan+160 @046bc0>
	lib/std/math.ci:352: (11 bytes: <@046ba7> - <@046bb2>): bool(negate := bool(!negate));
	<tan+135 @046ba7>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @046bab>  : 20                         load.i8
	<tan+140 @046bac>  : 0b                         not.b32
	<tan+141 @046bad>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @046bb1>  : 25                         store.i8
	lib/std/math.ci:353: (10 bytes: <@046bb2> - <@046bbc>): bool(complement := true);
	<tan+146 @046bb2>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @046bb7>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @046bbb>  : 25                         store.i8
	<tan+156 @046bbc>  : 04 29 00 00                jmp <tan+197 @046be5>
	lib/std/math.ci:355: (37 bytes: <@046bc0> - <@046be5>): if (bool(i == 3))
	<tan+160 @046bc0>  : 10 00                      dup.x1 sp(0)
	<tan+162 @046bc2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @046bc7>  : 57                         ceq.i32
	<tan+168 @046bc8>  : 06 1d 00 00                jz <tan+197 @046be5>
	lib/std/math.ci:356: (14 bytes: <@046bcc> - <@046bda>): float64(x := float64((1) - x));
	<tan+172 @046bcc>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @046bd5>  : 11 03                      dup.x2 sp(3)
	<tan+183 @046bd7>  : 82                         sub.f64
	<tan+184 @046bd8>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:357: (11 bytes: <@046bda> - <@046be5>): bool(negate := bool(!negate));
	<tan+186 @046bda>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @046bde>  : 20                         load.i8
	<tan+191 @046bdf>  : 0b                         not.b32
	<tan+192 @046be0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @046be4>  : 25                         store.i8
	lib/std/math.ci:360: (5 bytes: <@046be5> - <@046bea>): xsq: float64 := float64(x * x)
	<tan+197 @046be5>  : 11 01                      dup.x2 sp(1)
	<tan+199 @046be7>  : 11 03                      dup.x2 sp(3)
	<tan+201 @046be9>  : 83                         mul.f64
	lib/std/math.ci:361: (64 bytes: <@046bea> - <@046c2a>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @046bea>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @046bf3>  : 11 02                      dup.x2 sp(2)
	<tan+213 @046bf5>  : 83                         mul.f64
	<tan+214 @046bf6>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @046bff>  : 81                         add.f64
	<tan+224 @046c00>  : 11 02                      dup.x2 sp(2)
	<tan+226 @046c02>  : 83                         mul.f64
	<tan+227 @046c03>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @046c0c>  : 81                         add.f64
	<tan+237 @046c0d>  : 11 02                      dup.x2 sp(2)
	<tan+239 @046c0f>  : 83                         mul.f64
	<tan+240 @046c10>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @046c19>  : 81                         add.f64
	<tan+250 @046c1a>  : 11 02                      dup.x2 sp(2)
	<tan+252 @046c1c>  : 83                         mul.f64
	<tan+253 @046c1d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @046c26>  : 81                         add.f64
	<tan+263 @046c27>  : 11 05                      dup.x2 sp(5)
	<tan+265 @046c29>  : 83                         mul.f64
	lib/std/math.ci:362: (39 bytes: <@046c2a> - <@046c51>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @046c2a>  : 11 02                      dup.x2 sp(2)
	<tan+268 @046c2c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @046c35>  : 81                         add.f64
	<tan+278 @046c36>  : 11 04                      dup.x2 sp(4)
	<tan+280 @046c38>  : 83                         mul.f64
	<tan+281 @046c39>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @046c42>  : 81                         add.f64
	<tan+291 @046c43>  : 11 04                      dup.x2 sp(4)
	<tan+293 @046c45>  : 83                         mul.f64
	<tan+294 @046c46>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @046c4f>  : 81                         add.f64
	<tan+304 @046c50>  : 84                         div.f64
	lib/std/math.ci:364: (40 bytes: <@046c51> - <@046c79>): if (complement)
	<tan+305 @046c51>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @046c55>  : 20                         load.i8
	<tan+310 @046c56>  : 06 23 00 00                jz <tan+345 @046c79>
	lib/std/math.ci:365: (17 bytes: <@046c5a> - <@046c6b>): if (bool(result == (0)))
	<tan+314 @046c5a>  : 11 00                      dup.x2 sp(0)
	<tan+316 @046c5c>  : 1a                         load.z64
	<tan+317 @046c5d>  : 87                         ceq.f64
	<tan+318 @046c5e>  : 06 0d 00 00                jz <tan+331 @046c6b>
	lib/std/math.ci:366: (9 bytes: <@046c62> - <@046c6b>): return float64(.result := nan);
	<tan+322 @046c62>  : 1b                         load.z128
	<tan+323 @046c63>  : 84                         div.f64
	<tan+324 @046c64>  : 14 10                      set.x2 sp(16)
	<tan+326 @046c66>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @046c6a>  : 03                         ret
	lib/std/math.ci:368: (14 bytes: <@046c6b> - <@046c79>): float64(result := float64((1) / result));
	<tan+331 @046c6b>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @046c74>  : 11 02                      dup.x2 sp(2)
	<tan+342 @046c76>  : 84                         div.f64
	<tan+343 @046c77>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:370: (19 bytes: <@046c79> - <@046c8c>): if (negate)
	<tan+345 @046c79>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @046c7d>  : 20                         load.i8
	<tan+350 @046c7e>  : 06 0e 00 00                jz <tan+364 @046c8c>
	lib/std/math.ci:371: (10 bytes: <@046c82> - <@046c8c>): return float64(.result := float64(-result));
	<tan+354 @046c82>  : 11 00                      dup.x2 sp(0)
	<tan+356 @046c84>  : 80                         neg.f64
	<tan+357 @046c85>  : 14 10                      set.x2 sp(16)
	<tan+359 @046c87>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @046c8b>  : 03                         ret
	lib/std/math.ci:373: (7 bytes: <@046c8c> - <@046c93>): return float64(.result := result);
	<tan+364 @046c8c>  : 14 0e                      set.x2 sp(14)
	<tan+366 @046c8e>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @046c92>  : 03                         ret
.references:
	test/stdc/test.math.ci:61: referenced as `tan`
	lib/std/math.ci:320: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@046c98>
.name: 'sinh'
.file: 'lib/std/math.ci:377'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@046c98> - <@046d89>)
	lib/std/math.ci:389: (1 byte: <@046c98> - <@046c99>): negate: bool := false
	<sinh @046c98>      : 19                         load.z32
	lib/std/math.ci:390: (23 bytes: <@046c99> - <@046cb0>): if (bool(x < (0)))
	<sinh+1 @046c99>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @046c9b>    : 1a                         load.z64
	<sinh+4 @046c9c>    : 88                         clt.f64
	<sinh+5 @046c9d>    : 06 13 00 00                jz <sinh+24 @046cb0>
	lib/std/math.ci:391: (5 bytes: <@046ca1> - <@046ca6>): float64(x := float64(-x));
	<sinh+9 @046ca1>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @046ca3>   : 80                         neg.f64
	<sinh+12 @046ca4>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:392: (10 bytes: <@046ca6> - <@046cb0>): bool(negate := true);
	<sinh+14 @046ca6>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @046cab>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @046caf>   : 25                         store.i8
	lib/std/math.ci:395: (39 bytes: <@046cb0> - <@046cd7>): if (bool(x > (21)))
	<sinh+24 @046cb0>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @046cb2>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @046cbb>   : 89                         cgt.f64
	<sinh+36 @046cbc>   : 06 1b 00 00                jz <sinh+63 @046cd7>
	lib/std/math.ci:396: (23 bytes: <@046cc0> - <@046cd7>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @046cc0>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @046cc2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @046cc6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @046ccf>   : 84                         div.f64
	<sinh+56 @046cd0>   : 14 06                      set.x2 sp(6)
	<sinh+58 @046cd2>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @046cd6>   : 03                         ret
	lib/std/math.ci:399: (1 byte: <@046cd7> - <@046cd8>): result: float64
	<sinh+63 @046cd7>   : 1a                         load.z64
	lib/std/math.ci:400: (151 bytes: <@046cd8> - <@046d6f>): if (bool(x > 0.500000))
	<sinh+64 @046cd8>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @046cda>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @046ce3>   : 89                         cgt.f64
	<sinh+76 @046ce4>   : 06 22 00 00                jz <sinh+110 @046d06>
	lib/std/math.ci:401: (26 bytes: <@046ce8> - <@046d02>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @046ce8>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @046cea>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @046cee>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @046cf0>   : 80                         neg.f64
	<sinh+89 @046cf1>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @046cf5>   : 82                         sub.f64
	<sinh+94 @046cf6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @046cff>  : 84                         div.f64
	<sinh+104 @046d00>  : 14 02                      set.x2 sp(2)
	<sinh+106 @046d02>  : 04 6d 00 00                jmp <sinh+215 @046d6f>
	lib/std/math.ci:404: (5 bytes: <@046d06> - <@046d0b>): sq: float64 := float64(x * x)
	<sinh+110 @046d06>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @046d08>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @046d0a>  : 83                         mul.f64
	lib/std/math.ci:405: (53 bytes: <@046d0b> - <@046d40>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @046d0b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @046d14>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @046d16>  : 83                         mul.f64
	<sinh+127 @046d17>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @046d20>  : 81                         add.f64
	<sinh+137 @046d21>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @046d23>  : 83                         mul.f64
	<sinh+140 @046d24>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @046d2d>  : 81                         add.f64
	<sinh+150 @046d2e>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @046d30>  : 83                         mul.f64
	<sinh+153 @046d31>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @046d3a>  : 81                         add.f64
	<sinh+163 @046d3b>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @046d3d>  : 83                         mul.f64
	<sinh+166 @046d3e>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:406: (43 bytes: <@046d40> - <@046d6b>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @046d40>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @046d42>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @046d44>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @046d4d>  : 81                         add.f64
	<sinh+182 @046d4e>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @046d50>  : 83                         mul.f64
	<sinh+185 @046d51>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @046d5a>  : 81                         add.f64
	<sinh+195 @046d5b>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @046d5d>  : 83                         mul.f64
	<sinh+198 @046d5e>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @046d67>  : 81                         add.f64
	<sinh+208 @046d68>  : 84                         div.f64
	<sinh+209 @046d69>  : 14 04                      set.x2 sp(4)
	<sinh+211 @046d6b>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:409: (19 bytes: <@046d6f> - <@046d82>): if (negate)
	<sinh+215 @046d6f>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @046d73>  : 20                         load.i8
	<sinh+220 @046d74>  : 06 0e 00 00                jz <sinh+234 @046d82>
	lib/std/math.ci:410: (10 bytes: <@046d78> - <@046d82>): return float64(.result := float64(-result));
	<sinh+224 @046d78>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @046d7a>  : 80                         neg.f64
	<sinh+227 @046d7b>  : 14 08                      set.x2 sp(8)
	<sinh+229 @046d7d>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @046d81>  : 03                         ret
	lib/std/math.ci:412: (7 bytes: <@046d82> - <@046d89>): return float64(.result := result);
	<sinh+234 @046d82>  : 14 06                      set.x2 sp(6)
	<sinh+236 @046d84>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @046d88>  : 03                         ret
.references:
	test/stdc/test.math.ci:62: referenced as `sinh`
	lib/std/math.Complex.ci:120: referenced as `sinh`
	lib/std/math.Complex.ci:119: referenced as `sinh`
	lib/std/math.ci:377: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@046d90>
.name: 'cosh'
.file: 'lib/std/math.ci:416'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@046d90> - <@046ddb>)
	lib/std/math.ci:417: (13 bytes: <@046d90> - <@046d9d>): if (bool(x < (0)))
	<cosh @046d90>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @046d92>    : 1a                         load.z64
	<cosh+3 @046d93>    : 88                         clt.f64
	<cosh+4 @046d94>    : 06 09 00 00                jz <cosh+13 @046d9d>
	lib/std/math.ci:418: (5 bytes: <@046d98> - <@046d9d>): float64(x := float64(-x));
	<cosh+8 @046d98>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @046d9a>   : 80                         neg.f64
	<cosh+11 @046d9b>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:420: (35 bytes: <@046d9d> - <@046dc0>): if (bool(x > (21)))
	<cosh+13 @046d9d>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @046d9f>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @046da8>   : 89                         cgt.f64
	<cosh+25 @046da9>   : 06 17 00 00                jz <cosh+48 @046dc0>
	lib/std/math.ci:421: (19 bytes: <@046dad> - <@046dc0>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @046dad>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @046daf>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @046db3>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @046dbc>   : 84                         div.f64
	<cosh+45 @046dbd>   : 14 05                      set.x2 sp(5)
	<cosh+47 @046dbf>   : 03                         ret
	lib/std/math.ci:423: (27 bytes: <@046dc0> - <@046ddb>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @046dc0>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @046dc2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @046dc6>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @046dc8>   : 80                         neg.f64
	<cosh+57 @046dc9>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @046dcd>   : 81                         add.f64
	<cosh+62 @046dce>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @046dd7>   : 84                         div.f64
	<cosh+72 @046dd8>   : 14 05                      set.x2 sp(5)
	<cosh+74 @046dda>   : 03                         ret
.references:
	test/stdc/test.math.ci:63: referenced as `cosh`
	lib/std/math.Complex.ci:120: referenced as `cosh`
	lib/std/math.Complex.ci:119: referenced as `cosh`
	lib/std/math.ci:416: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@046de0>
.name: 'asin'
.file: 'lib/std/math.ci:432'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@046de0> - <@046e86>)
	lib/std/math.ci:433: (12 bytes: <@046de0> - <@046dec>): if (bool(x == (0)))
	<asin @046de0>      : 11 01                      dup.x2 sp(1)
	<asin+2 @046de2>    : 1a                         load.z64
	<asin+3 @046de3>    : 87                         ceq.f64
	<asin+4 @046de4>    : 06 08 00 00                jz <asin+12 @046dec>
	lib/std/math.ci:435: (4 bytes: <@046de8> - <@046dec>): return float64(.result := x);
	<asin+8 @046de8>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @046deb>   : 03                         ret
	lib/std/math.ci:438: (1 byte: <@046dec> - <@046ded>): negate: bool := false
	<asin+12 @046dec>   : 19                         load.z32
	lib/std/math.ci:439: (23 bytes: <@046ded> - <@046e04>): if (bool(x < (0)))
	<asin+13 @046ded>   : 11 02                      dup.x2 sp(2)
	<asin+15 @046def>   : 1a                         load.z64
	<asin+16 @046df0>   : 88                         clt.f64
	<asin+17 @046df1>   : 06 13 00 00                jz <asin+36 @046e04>
	lib/std/math.ci:440: (10 bytes: <@046df5> - <@046dff>): bool(negate := true);
	<asin+21 @046df5>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @046dfa>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @046dfe>   : 25                         store.i8
	lib/std/math.ci:441: (5 bytes: <@046dff> - <@046e04>): float64(x := float64(-x));
	<asin+31 @046dff>   : 11 02                      dup.x2 sp(2)
	<asin+33 @046e01>   : 80                         neg.f64
	<asin+34 @046e02>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:444: (25 bytes: <@046e04> - <@046e1d>): if (bool(x > (1)))
	<asin+36 @046e04>   : 11 02                      dup.x2 sp(2)
	<asin+38 @046e06>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @046e0f>   : 89                         cgt.f64
	<asin+48 @046e10>   : 06 0d 00 00                jz <asin+61 @046e1d>
	lib/std/math.ci:446: (9 bytes: <@046e14> - <@046e1d>): return float64(.result := nan);
	<asin+52 @046e14>   : 1b                         load.z128
	<asin+53 @046e15>   : 84                         div.f64
	<asin+54 @046e16>   : 14 06                      set.x2 sp(6)
	<asin+56 @046e18>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @046e1c>   : 03                         ret
	lib/std/math.ci:449: (19 bytes: <@046e1d> - <@046e30>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @046e1d>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @046e26>   : 11 04                      dup.x2 sp(4)
	<asin+72 @046e28>   : 11 06                      dup.x2 sp(6)
	<asin+74 @046e2a>   : 83                         mul.f64
	<asin+75 @046e2b>   : 82                         sub.f64
	<asin+76 @046e2c>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:450: (60 bytes: <@046e30> - <@046e6c>): if (bool(x > 0.700000))
	<asin+80 @046e30>   : 11 04                      dup.x2 sp(4)
	<asin+82 @046e32>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @046e3b>   : 89                         cgt.f64
	<asin+92 @046e3c>   : 06 26 00 00                jz <asin+130 @046e62>
	lib/std/math.ci:451: (30 bytes: <@046e40> - <@046e5e>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @046e40>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @046e49>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @046e52>  : 84                         div.f64
	<asin+115 @046e53>  : 11 02                      dup.x2 sp(2)
	<asin+117 @046e55>  : 11 08                      dup.x2 sp(8)
	<asin+119 @046e57>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @046e5b>  : 82                         sub.f64
	<asin+124 @046e5c>  : 14 02                      set.x2 sp(2)
	<asin+126 @046e5e>  : 04 0e 00 00                jmp <asin+140 @046e6c>
	lib/std/math.ci:454: (10 bytes: <@046e62> - <@046e6c>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @046e62>  : 11 04                      dup.x2 sp(4)
	<asin+132 @046e64>  : 11 02                      dup.x2 sp(2)
	<asin+134 @046e66>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @046e6a>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:457: (19 bytes: <@046e6c> - <@046e7f>): if (negate)
	<asin+140 @046e6c>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @046e70>  : 20                         load.i8
	<asin+145 @046e71>  : 06 0e 00 00                jz <asin+159 @046e7f>
	lib/std/math.ci:458: (10 bytes: <@046e75> - <@046e7f>): return float64(.result := float64(-result));
	<asin+149 @046e75>  : 11 00                      dup.x2 sp(0)
	<asin+151 @046e77>  : 80                         neg.f64
	<asin+152 @046e78>  : 14 08                      set.x2 sp(8)
	<asin+154 @046e7a>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @046e7e>  : 03                         ret
	lib/std/math.ci:460: (7 bytes: <@046e7f> - <@046e86>): return float64(.result := result);
	<asin+159 @046e7f>  : 14 06                      set.x2 sp(6)
	<asin+161 @046e81>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @046e85>  : 03                         ret
.references:
	test/stdc/test.math.ci:65: referenced as `asin`
	lib/std/math.ci:467: referenced as `asin`
	lib/std/math.ci:432: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:467'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: (float64(float64(pi / (2)) - asin(x)))
.references:
	test/stdc/test.math.ci:66: referenced as `acos`
	lib/std/math.ci:467: defined as `acos(x: float64): float64`
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'deg2rad'
.file: 'lib/std/math.ci:490'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * pi) / (180)))
.references:
	lib/std/math.ci:490: defined as `deg2rad(x: float64): float64`
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rad2deg'
.file: 'lib/std/math.ci:491'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * (180)) / pi))
.references:
	lib/std/math.ci:491: defined as `rad2deg(x: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@016a78>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:142: referenced as `Complex`
	lib/std/math.Complex.ci:141: referenced as `Complex`
	lib/std/math.Complex.ci:140: referenced as `Complex`
	lib/std/math.Complex.ci:138: referenced as `Complex`
	lib/std/math.Complex.ci:137: referenced as `Complex`
	lib/std/math.Complex.ci:136: referenced as `Complex`
	lib/std/math.Complex.ci:135: referenced as `Complex`
	lib/std/math.Complex.ci:133: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:90: referenced as `Complex`
	lib/std/math.Complex.ci:89: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: referenced as `Complex`
	lib/std/math.Complex.ci:20: referenced as `Complex`
	lib/std/math.Complex.ci:3: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
.references:
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:113: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:110: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:101: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:90: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:82: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:79: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:75: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:72: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:70: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:63: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:60: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:56: referenced as `re`
	lib/std/math.Complex.ci:55: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:52: referenced as `re`
	lib/std/math.Complex.ci:27: referenced as `re`
	lib/std/math.Complex.ci:22: referenced as `re`
	lib/std/math.Complex.ci:4: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
.references:
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:114: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:110: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:101: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:90: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:81: referenced as `im`
	lib/std/math.Complex.ci:79: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:74: referenced as `im`
	lib/std/math.Complex.ci:72: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:70: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:63: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:60: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:56: referenced as `im`
	lib/std/math.Complex.ci:55: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:52: referenced as `im`
	lib/std/math.Complex.ci:28: referenced as `im`
	lib/std/math.Complex.ci:5: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@046e88>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@046e88> - <@046e8f>)
	lib/std/math.Complex.ci:21: (7 bytes: <@046e88> - <@046e8f>): return void(.result := {...});
	<Complex @046e88>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@046e8b> - <@046e8e>): void(.result.im := (0))
	<Complex+3 @046e8b>    : 1a                         load.z64
	<Complex+4 @046e8c>    : 14 07                      set.x2 sp(7)
	<Complex+6 @046e8e>    : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:20: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@046e90>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@046e90> - <@046e97>)
	lib/std/math.Complex.ci:26: (7 bytes: <@046e90> - <@046e97>): return void(.result := {...});
	<Complex @046e90>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:28: (3 bytes: <@046e93> - <@046e96>): void(.result.im := im);
	<Complex+3 @046e93>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @046e96>    : 03                         ret
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(-a.re), float64(-a.im)))
.references:
	lib/vec/vec4f.ci:56: referenced as `neg`
	lib/std/math.Complex.ci:136: referenced as `neg`
	lib/std/math.Complex.ci:135: referenced as `neg`
	lib/std/math.Complex.ci:52: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `add`
	lib/std/math.Complex.ci:54: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re + b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `add`
	lib/std/math.Complex.ci:137: referenced as `add`
	lib/std/math.Complex.ci:55: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a + b.re), b.im))
.references:
	lib/std/math.Complex.ci:56: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.references:
	lib/std/math.Complex.ci:135: referenced as `sub`
	lib/std/math.Complex.ci:58: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re - b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `sub`
	lib/std/math.Complex.ci:137: referenced as `sub`
	lib/std/math.Complex.ci:59: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a - b.re), b.im))
.references:
	lib/std/math.Complex.ci:60: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.references:
	lib/std/math.Complex.ci:62: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.references:
	lib/std/math.Complex.ci:63: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.references:
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:64: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@046e98>
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@046e98> - <@046f13>)
	lib/std/math.Complex.ci:70: (79 bytes: <@046e98> - <@046ee7>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @046e98>      : 1a                         load.z64
	<div+1 @046e99>    : 11 03                      dup.x2 sp(3)
	<div+3 @046e9b>    : 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<div+8 @046ea0>    : 02                         call
	<div+9 @046ea1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @046ea5>   : 1a                         load.z64
	<div+14 @046ea6>   : 11 07                      dup.x2 sp(7)
	<div+16 @046ea8>   : 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<div+21 @046ead>   : 02                         call
	<div+22 @046eae>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @046eb2>   : 88                         clt.f64
	<div+27 @046eb3>   : 05 34 00 00                jnz <div+79 @046ee7>
	lib/std/math.Complex.ci:71: (5 bytes: <@046eb7> - <@046ebc>): r: float64 := float64(b.im / b.re)
	<div+31 @046eb7>   : 11 03                      dup.x2 sp(3)
	<div+33 @046eb9>   : 11 03                      dup.x2 sp(3)
	<div+35 @046ebb>   : 84                         div.f64
	lib/std/math.Complex.ci:72: (8 bytes: <@046ebc> - <@046ec4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @046ebc>   : 11 03                      dup.x2 sp(3)
	<div+38 @046ebe>   : 11 02                      dup.x2 sp(2)
	<div+40 @046ec0>   : 11 09                      dup.x2 sp(9)
	<div+42 @046ec2>   : 83                         mul.f64
	<div+43 @046ec3>   : 81                         add.f64
	lib/std/math.Complex.ci:73: (31 bytes: <@046ec4> - <@046ee3>): return void(.result := {...});
	<div+44 @046ec4>   : 11 09                      dup.x2 sp(9)
	<div+46 @046ec6>   : 11 04                      dup.x2 sp(4)
	<div+48 @046ec8>   : 11 0f                      dup.x2 sp(15)
	<div+50 @046eca>   : 83                         mul.f64
	<div+51 @046ecb>   : 81                         add.f64
	<div+52 @046ecc>   : 11 02                      dup.x2 sp(2)
	<div+54 @046ece>   : 84                         div.f64
	<div+55 @046ecf>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes: <@046ed1> - <@046ede>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @046ed1>   : 11 0b                      dup.x2 sp(11)
	<div+59 @046ed3>   : 11 04                      dup.x2 sp(4)
	<div+61 @046ed5>   : 11 0d                      dup.x2 sp(13)
	<div+63 @046ed7>   : 83                         mul.f64
	<div+64 @046ed8>   : 82                         sub.f64
	<div+65 @046ed9>   : 11 02                      dup.x2 sp(2)
	<div+67 @046edb>   : 84                         div.f64
	<div+68 @046edc>   : 14 11                      set.x2 sp(17)
	<div+70 @046ede>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @046ee2>   : 03                         ret
	<div+75 @046ee3>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes: <@046ee7> - <@046eec>): r: float64 := float64(b.re / b.im)
	<div+79 @046ee7>   : 11 01                      dup.x2 sp(1)
	<div+81 @046ee9>   : 11 05                      dup.x2 sp(5)
	<div+83 @046eeb>   : 84                         div.f64
	lib/std/math.Complex.ci:79: (8 bytes: <@046eec> - <@046ef4>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @046eec>   : 11 05                      dup.x2 sp(5)
	<div+86 @046eee>   : 11 02                      dup.x2 sp(2)
	<div+88 @046ef0>   : 11 07                      dup.x2 sp(7)
	<div+90 @046ef2>   : 83                         mul.f64
	<div+91 @046ef3>   : 81                         add.f64
	lib/std/math.Complex.ci:80: (31 bytes: <@046ef4> - <@046f13>): return void(.result := {...});
	<div+92 @046ef4>   : 11 09                      dup.x2 sp(9)
	<div+94 @046ef6>   : 11 04                      dup.x2 sp(4)
	<div+96 @046ef8>   : 83                         mul.f64
	<div+97 @046ef9>   : 11 0d                      dup.x2 sp(13)
	<div+99 @046efb>   : 81                         add.f64
	<div+100 @046efc>  : 11 02                      dup.x2 sp(2)
	<div+102 @046efe>  : 84                         div.f64
	<div+103 @046eff>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes: <@046f01> - <@046f0e>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @046f01>  : 11 0b                      dup.x2 sp(11)
	<div+107 @046f03>  : 11 04                      dup.x2 sp(4)
	<div+109 @046f05>  : 83                         mul.f64
	<div+110 @046f06>  : 11 0b                      dup.x2 sp(11)
	<div+112 @046f08>  : 82                         sub.f64
	<div+113 @046f09>  : 11 02                      dup.x2 sp(2)
	<div+115 @046f0b>  : 84                         div.f64
	<div+116 @046f0c>  : 14 11                      set.x2 sp(17)
	<div+118 @046f0e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @046f12>  : 03                         ret
.references:
	lib/std/math.Complex.ci:138: referenced as `div`
	lib/std/math.Complex.ci:137: referenced as `div`
	lib/std/math.Complex.ci:133: referenced as `div`
	lib/std/math.Complex.ci:132: referenced as `div`
	lib/std/math.Complex.ci:87: referenced as `div`
	lib/std/math.Complex.ci:86: referenced as `div`
	lib/std/math.Complex.ci:66: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: div(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:136: referenced as `div`
	lib/std/math.Complex.ci:135: referenced as `div`
	lib/std/math.Complex.ci:86: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.value: div(void(Complex(a), b))
.references:
	lib/std/math.Complex.ci:87: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.references:
	lib/std/math.Complex.ci:146: referenced as `abs`
	lib/std/math.Complex.ci:108: referenced as `abs`
	lib/std/math.Complex.ci:105: referenced as `abs`
	lib/std/math.Complex.ci:89: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.atan2(void(a.re, a.im))
.references:
	lib/std/math.Complex.ci:146: referenced as `arg`
	lib/std/math.Complex.ci:109: referenced as `arg`
	lib/std/math.Complex.ci:105: referenced as `arg`
	lib/std/math.Complex.ci:90: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@046f18>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@046f18> - <@046f37>)
	lib/std/math.Complex.ci:94: (11 bytes: <@046f18> - <@046f23>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @046f18>      : 11 01                      dup.x2 sp(1)
	<inv+2 @046f1a>    : 11 03                      dup.x2 sp(3)
	<inv+4 @046f1c>    : 83                         mul.f64
	<inv+5 @046f1d>    : 11 05                      dup.x2 sp(5)
	<inv+7 @046f1f>    : 11 07                      dup.x2 sp(7)
	<inv+9 @046f21>    : 83                         mul.f64
	<inv+10 @046f22>   : 81                         add.f64
	lib/std/math.Complex.ci:95: (20 bytes: <@046f23> - <@046f37>): return void(.result := {...});
	<inv+11 @046f23>   : 11 03                      dup.x2 sp(3)
	<inv+13 @046f25>   : 11 02                      dup.x2 sp(2)
	<inv+15 @046f27>   : 84                         div.f64
	<inv+16 @046f28>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes: <@046f2a> - <@046f32>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @046f2a>   : 11 05                      dup.x2 sp(5)
	<inv+20 @046f2c>   : 80                         neg.f64
	<inv+21 @046f2d>   : 11 02                      dup.x2 sp(2)
	<inv+23 @046f2f>   : 84                         div.f64
	<inv+24 @046f30>   : 14 0b                      set.x2 sp(11)
	<inv+26 @046f32>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @046f36>   : 03                         ret
.references:
	lib/std/math.Complex.ci:143: referenced as `inv`
	lib/std/math.Complex.ci:142: referenced as `inv`
	lib/std/math.Complex.ci:141: referenced as `inv`
	lib/std/math.Complex.ci:140: referenced as `inv`
	lib/std/math.Complex.ci:93: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(a.re, float64(-a.im)))
.references:
	lib/std/math.Complex.ci:101: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.references:
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:103: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64.log(abs(a)), arg(a)))
.references:
	lib/std/math.Complex.ci:105: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@046f38>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@046f38> - <@046f9c>)
	lib/std/math.Complex.ci:108: (23 bytes: <@046f38> - <@046f4f>): r: float64 := abs(a)
	<pow @046f38>      : 12 05                      dup.x4 sp(5)
	<pow+2 @046f3a>    : 11 00                      dup.x2 sp(0)
	<pow+4 @046f3c>    : 11 02                      dup.x2 sp(2)
	<pow+6 @046f3e>    : 83                         mul.f64
	<pow+7 @046f3f>    : 11 04                      dup.x2 sp(4)
	<pow+9 @046f41>    : 11 06                      dup.x2 sp(6)
	<pow+11 @046f43>   : 83                         mul.f64
	<pow+12 @046f44>   : 81                         add.f64
	<pow+13 @046f45>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @046f49>   : 14 04                      set.x2 sp(4)
	<pow+19 @046f4b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes: <@046f4f> - <@046f5f>): t: float64 := arg(a)
	<pow+23 @046f4f>   : 12 07                      dup.x4 sp(7)
	<pow+25 @046f51>   : 11 00                      dup.x2 sp(0)
	<pow+27 @046f53>   : 11 04                      dup.x2 sp(4)
	<pow+29 @046f55>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @046f59>   : 14 04                      set.x2 sp(4)
	<pow+35 @046f5b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes: <@046f5f> - <@046f6e>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @046f5f>   : 11 05                      dup.x2 sp(5)
	<pow+41 @046f61>   : 11 02                      dup.x2 sp(2)
	<pow+43 @046f63>   : 83                         mul.f64
	<pow+44 @046f64>   : 11 09                      dup.x2 sp(9)
	<pow+46 @046f66>   : 11 06                      dup.x2 sp(6)
	<pow+48 @046f68>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @046f6c>   : 83                         mul.f64
	<pow+53 @046f6d>   : 81                         add.f64
	lib/std/math.Complex.ci:111: (19 bytes: <@046f6e> - <@046f81>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @046f6e>   : 11 04                      dup.x2 sp(4)
	<pow+56 @046f70>   : 11 09                      dup.x2 sp(9)
	<pow+58 @046f72>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @046f76>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @046f78>   : 80                         neg.f64
	<pow+65 @046f79>   : 11 06                      dup.x2 sp(6)
	<pow+67 @046f7b>   : 83                         mul.f64
	<pow+68 @046f7c>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @046f80>   : 83                         mul.f64
	lib/std/math.Complex.ci:112: (27 bytes: <@046f81> - <@046f9c>): return void(.result := {...});
	<pow+73 @046f81>   : 11 00                      dup.x2 sp(0)
	<pow+75 @046f83>   : 11 04                      dup.x2 sp(4)
	<pow+77 @046f85>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @046f89>   : 83                         mul.f64
	<pow+82 @046f8a>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes: <@046f8c> - <@046f97>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @046f8c>   : 11 00                      dup.x2 sp(0)
	<pow+86 @046f8e>   : 11 04                      dup.x2 sp(4)
	<pow+88 @046f90>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @046f94>   : 83                         mul.f64
	<pow+93 @046f95>   : 14 15                      set.x2 sp(21)
	<pow+95 @046f97>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @046f9b>   : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `pow`
	lib/std/math.Complex.ci:107: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: pow(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:117: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:141: referenced as `sin`
	lib/std/math.Complex.ci:133: referenced as `sin`
	lib/std/math.Complex.ci:132: referenced as `sin`
	lib/std/math.Complex.ci:119: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:140: referenced as `cos`
	lib/std/math.Complex.ci:133: referenced as `cos`
	lib/std/math.Complex.ci:132: referenced as `cos`
	lib/std/math.Complex.ci:120: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sin(a), cos(a)))
.references:
	lib/std/math.Complex.ci:132: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(cos(a), sin(a)))
.references:
	lib/std/math.Complex.ci:133: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:143: referenced as `sinh`
	lib/std/math.Complex.ci:135: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:142: referenced as `cosh`
	lib/std/math.Complex.ci:136: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:137: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:138: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cos(a))
.references:
	lib/std/math.Complex.ci:140: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sin(a))
.references:
	lib/std/math.Complex.ci:141: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cosh(a))
.references:
	lib/std/math.Complex.ci:142: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sinh(a))
.references:
	lib/std/math.Complex.ci:143: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.references:
	lib/std/math.Complex.ci:145: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(abs(x), arg(x)))
.references:
	lib/std/math.Complex.ci:146: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@046fa0>
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@046fa0> - <@046fc6>)
	lib/std/string.ci:4: (16 bytes: <@046fa0> - <@046fb0>): if (bool((str) == null))
	<length @046fa0>      : 10 01                      dup.x1 sp(1)
	<length+2 @046fa2>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @046fa7>    : 57                         ceq.i32
	<length+8 @046fa8>    : 06 08 00 00                jz <length+16 @046fb0>
	lib/std/string.ci:5: (4 bytes: <@046fac> - <@046fb0>): return int32(.result := 0);
	<length+12 @046fac>   : 19                         load.z32
	<length+13 @046fad>   : 13 03                      set.x1 sp(3)
	<length+15 @046faf>   : 03                         ret
	lib/std/string.ci:7: (1 byte: <@046fb0> - <@046fb1>): result: int32 := 0
	<length+16 @046fb0>   : 19                         load.z32
	lib/std/string.ci:8: (18 bytes: <@046fb1> - <@046fc3>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @046fb1>   : 04 08 00 00                jmp <length+25 @046fb9>
	lib/std/string.ci:8: (4 bytes: <@046fb5> - <@046fb9>): int32(result := int32(result + 1))
	<length+21 @046fb5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:8: (10 bytes: <@046fb9> - <@046fc3>): str[result]
	<length+25 @046fb9>   : 10 02                      dup.x1 sp(2)
	<length+27 @046fbb>   : 10 01                      dup.x1 sp(1)
	<length+29 @046fbd>   : 51                         add.i32
	<length+30 @046fbe>   : 20                         load.i8
	<length+31 @046fbf>   : 05 f6 ff ff                jnz <length+21 @046fb5>
	lib/std/string.ci:10: (3 bytes: <@046fc3> - <@046fc6>): return int32(.result := result);
	<length+35 @046fc3>   : 13 03                      set.x1 sp(3)
	<length+37 @046fc5>   : 03                         ret
.references:
	lib/std/string.ci:46: referenced as `length`
	lib/std/string.ci:45: referenced as `length`
	lib/std/string.ci:3: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@046fc8>
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@046fc8> - <@046ffa>)
	lib/std/string.ci:15: (42 bytes: <@046fc8> - <@046ff2>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @046fc8>      : 19                         load.z32
	<indexOf+1 @046fc9>    : 04 1b 00 00                jmp <indexOf+28 @046fe4>
	lib/std/string.ci:16: (19 bytes: <@046fcd> - <@046fe0>): if (bool(str[i] == chr))
	<indexOf+5 @046fcd>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @046fcf>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @046fd1>    : 51                         add.i32
	<indexOf+10 @046fd2>   : 20                         load.i8
	<indexOf+11 @046fd3>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @046fd7>   : 20                         load.i8
	<indexOf+16 @046fd8>   : 57                         ceq.i32
	<indexOf+17 @046fd9>   : 06 07 00 00                jz <indexOf+24 @046fe0>
	lib/std/string.ci:17: (3 bytes: <@046fdd> - <@046fe0>): return int32(.result := i);
	<indexOf+21 @046fdd>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @046fdf>   : 03                         ret
	lib/std/string.ci:15: (4 bytes: <@046fe0> - <@046fe4>): int32(i := int32(i + 1))
	<indexOf+24 @046fe0>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:15: (10 bytes: <@046fe4> - <@046fee>): str[i]
	<indexOf+28 @046fe4>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @046fe6>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @046fe8>   : 51                         add.i32
	<indexOf+33 @046fe9>   : 20                         load.i8
	<indexOf+34 @046fea>   : 05 e3 ff ff                jnz <indexOf+5 @046fcd>
	<indexOf+38 @046fee>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:20: (8 bytes: <@046ff2> - <@046ffa>): return int32(.result := int32(-1));
	<indexOf+42 @046ff2>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @046ff7>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @046ff9>   : 03                         ret
.references:
	lib/std/string.ci:92: referenced as `indexOf`
	lib/std/string.ci:14: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@047000>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@047000> - <@047032>)
	lib/std/string.ci:25: (5 bytes: <@047000> - <@047005>): result: int32 := int32(-1)
	<lastIndexOf @047000>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:26: (42 bytes: <@047005> - <@04702f>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @047005>    : 19                         load.z32
	<lastIndexOf+6 @047006>    : 04 1b 00 00                jmp <lastIndexOf+33 @047021>
	lib/std/string.ci:27: (19 bytes: <@04700a> - <@04701d>): if (bool(str[i] == chr))
	<lastIndexOf+10 @04700a>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @04700c>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @04700e>   : 51                         add.i32
	<lastIndexOf+15 @04700f>   : 20                         load.i8
	<lastIndexOf+16 @047010>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @047014>   : 20                         load.i8
	<lastIndexOf+21 @047015>   : 57                         ceq.i32
	<lastIndexOf+22 @047016>   : 06 07 00 00                jz <lastIndexOf+29 @04701d>
	lib/std/string.ci:28: (3 bytes: <@04701a> - <@04701d>): int32(result := i);
	<lastIndexOf+26 @04701a>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:26: (4 bytes: <@04701d> - <@047021>): int32(i := int32(i + 1))
	<lastIndexOf+29 @04701d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:26: (10 bytes: <@047021> - <@04702b>): str[i]
	<lastIndexOf+33 @047021>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @047023>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @047025>   : 51                         add.i32
	<lastIndexOf+38 @047026>   : 20                         load.i8
	<lastIndexOf+39 @047027>   : 05 e3 ff ff                jnz <lastIndexOf+10 @04700a>
	<lastIndexOf+43 @04702b>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:31: (3 bytes: <@04702f> - <@047032>): return int32(.result := result);
	<lastIndexOf+47 @04702f>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @047031>   : 03                         ret
.references:
	lib/std/string.ci:24: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@047038>
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@047038> - <@047081>)
	lib/std/string.ci:36: (62 bytes: <@047038> - <@047076>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @047038>      : 19                         load.z32
	<startsWith+1 @047039>    : 04 2d 00 00                jmp <startsWith+46 @047066>
	lib/std/string.ci:37: (37 bytes: <@04703d> - <@047062>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @04703d>    : 19                         load.z32
	<startsWith+6 @04703e>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @047040>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @047042>   : 51                         add.i32
	<startsWith+11 @047043>   : 20                         load.i8
	<startsWith+12 @047044>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @047046>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @047048>   : 51                         add.i32
	<startsWith+17 @047049>   : 20                         load.i8
	<startsWith+18 @04704a>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @04704c>   : 02                         call
	<startsWith+21 @04704d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @047051>   : 19                         load.z32
	<startsWith+26 @047052>   : 57                         ceq.i32
	<startsWith+27 @047053>   : 05 0f 00 00                jnz <startsWith+42 @047062>
	lib/std/string.ci:38: (11 bytes: <@047057> - <@047062>): return bool(.result := false);
	<startsWith+31 @047057>   : 19                         load.z32
	<startsWith+32 @047058>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @04705c>   : 25                         store.i8
	<startsWith+37 @04705d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @047061>   : 03                         ret
	lib/std/string.ci:36: (4 bytes: <@047062> - <@047066>): int32(i := int32(i + 1))
	<startsWith+42 @047062>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:36: (12 bytes: <@047066> - <@047072>): bool((with[i]) != 0)
	<startsWith+46 @047066>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @047068>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @04706a>   : 51                         add.i32
	<startsWith+51 @04706b>   : 20                         load.i8
	<startsWith+52 @04706c>   : 19                         load.z32
	<startsWith+53 @04706d>   : 57                         ceq.i32
	<startsWith+54 @04706e>   : 06 cf ff ff                jz <startsWith+5 @04703d>
	<startsWith+58 @047072>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:41: (11 bytes: <@047076> - <@047081>): return bool(.result := true);
	<startsWith+62 @047076>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @04707b>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @04707f>   : 25                         store.i8
	<startsWith+72 @047080>   : 03                         ret
.references:
	lib/std/string.ci:88: referenced as `startsWith`
	lib/std/string.ci:35: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@047088>
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@047088> - <@047106>)
	lib/std/string.ci:45: (13 bytes: <@047088> - <@047095>): withLen: int32 := length(with)
	<endsWith @047088>      : 19                         load.z32
	<endsWith+1 @047089>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @04708b>    : 1f a0 6f 04 00             load.ref <@046fa0> ;length(str: char[*]): int32
	<endsWith+8 @047090>    : 02                         call
	<endsWith+9 @047091>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:46: (13 bytes: <@047095> - <@0470a2>): strLen: int32 := length(str)
	<endsWith+13 @047095>   : 19                         load.z32
	<endsWith+14 @047096>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @047098>   : 1f a0 6f 04 00             load.ref <@046fa0> ;length(str: char[*]): int32
	<endsWith+21 @04709d>   : 02                         call
	<endsWith+22 @04709e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:47: (20 bytes: <@0470a2> - <@0470b6>): if (bool(strLen < withLen))
	<endsWith+26 @0470a2>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @0470a4>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @0470a6>   : 58                         clt.i32
	<endsWith+31 @0470a7>   : 06 0f 00 00                jz <endsWith+46 @0470b6>
	lib/std/string.ci:48: (11 bytes: <@0470ab> - <@0470b6>): return bool(.result := false);
	<endsWith+35 @0470ab>   : 19                         load.z32
	<endsWith+36 @0470ac>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @0470b0>   : 25                         store.i8
	<endsWith+41 @0470b1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @0470b5>   : 03                         ret
	lib/std/string.ci:50: (65 bytes: <@0470b6> - <@0470f7>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @0470b6>   : 19                         load.z32
	<endsWith+47 @0470b7>   : 04 33 00 00                jmp <endsWith+98 @0470ea>
	lib/std/string.ci:51: (43 bytes: <@0470bb> - <@0470e6>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @0470bb>   : 19                         load.z32
	<endsWith+52 @0470bc>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @0470be>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @0470c0>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @0470c2>   : 52                         sub.i32
	<endsWith+59 @0470c3>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @0470c5>   : 51                         add.i32
	<endsWith+62 @0470c6>   : 51                         add.i32
	<endsWith+63 @0470c7>   : 20                         load.i8
	<endsWith+64 @0470c8>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @0470ca>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @0470cc>   : 51                         add.i32
	<endsWith+69 @0470cd>   : 20                         load.i8
	<endsWith+70 @0470ce>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @0470d0>   : 02                         call
	<endsWith+73 @0470d1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @0470d5>   : 19                         load.z32
	<endsWith+78 @0470d6>   : 57                         ceq.i32
	<endsWith+79 @0470d7>   : 05 0f 00 00                jnz <endsWith+94 @0470e6>
	lib/std/string.ci:52: (11 bytes: <@0470db> - <@0470e6>): return bool(.result := false);
	<endsWith+83 @0470db>   : 19                         load.z32
	<endsWith+84 @0470dc>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @0470e0>   : 25                         store.i8
	<endsWith+89 @0470e1>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @0470e5>   : 03                         ret
	lib/std/string.ci:50: (4 bytes: <@0470e6> - <@0470ea>): int32(i := int32(i + 1))
	<endsWith+94 @0470e6>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:50: (9 bytes: <@0470ea> - <@0470f3>): bool(i < withLen)
	<endsWith+98 @0470ea>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @0470ec>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @0470ee>  : 58                         clt.i32
	<endsWith+103 @0470ef>  : 05 cc ff ff                jnz <endsWith+51 @0470bb>
	<endsWith+107 @0470f3>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:55: (15 bytes: <@0470f7> - <@047106>): return bool(.result := true);
	<endsWith+111 @0470f7>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @0470fc>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @047100>  : 25                         store.i8
	<endsWith+121 @047101>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @047105>  : 03                         ret
.references:
	lib/std/string.ci:89: referenced as `endsWith`
	lib/std/string.ci:44: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@047108>
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@047108> - <@047147>)
	lib/std/string.ci:59: (1 byte: <@047108> - <@047109>): result: int32 := 0
	<compare @047108>      : 19                         load.z32
	lib/std/string.ci:60: (59 bytes: <@047109> - <@047144>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @047109>    : 19                         load.z32
	<compare+2 @04710a>    : 04 2e 00 00                jmp <compare+48 @047138>
	lib/std/string.ci:61: (22 bytes: <@04710e> - <@047124>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @04710e>    : 19                         load.z32
	<compare+7 @04710f>    : 10 06                      dup.x1 sp(6)
	<compare+9 @047111>    : 10 02                      dup.x1 sp(2)
	<compare+11 @047113>   : 51                         add.i32
	<compare+12 @047114>   : 20                         load.i8
	<compare+13 @047115>   : 10 06                      dup.x1 sp(6)
	<compare+15 @047117>   : 10 03                      dup.x1 sp(3)
	<compare+17 @047119>   : 51                         add.i32
	<compare+18 @04711a>   : 20                         load.i8
	<compare+19 @04711b>   : 10 06                      dup.x1 sp(6)
	<compare+21 @04711d>   : 02                         call
	<compare+22 @04711e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @047122>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes: <@047124> - <@047134>): if (bool((str[i]) == 0))
	<compare+28 @047124>   : 10 05                      dup.x1 sp(5)
	<compare+30 @047126>   : 10 01                      dup.x1 sp(1)
	<compare+32 @047128>   : 51                         add.i32
	<compare+33 @047129>   : 20                         load.i8
	<compare+34 @04712a>   : 19                         load.z32
	<compare+35 @04712b>   : 57                         ceq.i32
	<compare+36 @04712c>   : 06 08 00 00                jz <compare+44 @047134>
	lib/std/string.ci:63: (4 bytes: <@047130> - <@047134>): break;
	<compare+40 @047130>   : 04 10 00 00                jmp <compare+56 @047140>
	lib/std/string.ci:60: (4 bytes: <@047134> - <@047138>): int32(i := int32(i + 1))
	<compare+44 @047134>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:60: (8 bytes: <@047138> - <@047140>): bool(result == 0)
	<compare+48 @047138>   : 10 01                      dup.x1 sp(1)
	<compare+50 @04713a>   : 19                         load.z32
	<compare+51 @04713b>   : 57                         ceq.i32
	<compare+52 @04713c>   : 05 d2 ff ff                jnz <compare+6 @04710e>
	<compare+56 @047140>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:66: (3 bytes: <@047144> - <@047147>): return int32(.result := result);
	<compare+60 @047144>   : 13 05                      set.x1 sp(5)
	<compare+62 @047146>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `compare`
	lib/std/string.ci:58: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@047190>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@047190> - <@0471b4>)
	lib/std/string.ci:81: (36 bytes: <@047190> - <@0471b4>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @047190>      : 19                         load.z32
	<ignCaseCmp+1 @047191>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @047195>    : 20                         load.i8
	<ignCaseCmp+6 @047196>    : 1f 48 71 04 00             load.ref <@047148> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @04719b>   : 02                         call
	<ignCaseCmp+12 @04719c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @0471a0>   : 19                         load.z32
	<ignCaseCmp+17 @0471a1>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @0471a5>   : 20                         load.i8
	<ignCaseCmp+22 @0471a6>   : 1f 48 71 04 00             load.ref <@047148> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @0471ab>   : 02                         call
	<ignCaseCmp+28 @0471ac>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @0471b0>   : 52                         sub.i32
	<ignCaseCmp+33 @0471b1>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @0471b3>   : 03                         ret
.references:
	lib/std/string.ci:70: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@0471b8>
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@0471b8> - <@0471c6>)
	lib/std/string.ci:85: (14 bytes: <@0471b8> - <@0471c6>): return char(.result := char(chr - with));
	<caseCmp @0471b8>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @0471bc>    : 20                         load.i8
	<caseCmp+5 @0471bd>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @0471c1>    : 20                         load.i8
	<caseCmp+10 @0471c2>   : 52                         sub.i32
	<caseCmp+11 @0471c3>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @0471c5>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `caseCmp`
	lib/std/string.ci:89: referenced as `caseCmp`
	lib/std/string.ci:88: referenced as `caseCmp`
	lib/std/string.ci:84: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:88: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:89: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:90: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.value: bool(indexOf(void(str, chr)) >= 0)
.references:
	lib/std/string.ci:158: referenced as `contains`
	lib/std/string.ci:92: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01e3c8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.references:
	lib/std/string.ci:206: referenced as `FormatFlags`
	lib/std/string.ci:196: referenced as `FormatFlags`
	lib/std/string.ci:192: referenced as `FormatFlags`
	lib/std/string.ci:129: referenced as `FormatFlags`
	lib/std/string.ci:106: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
.references:
	lib/std/string.ci:136: referenced as `radix`
	lib/std/string.ci:107: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:150: referenced as `padChr`
	lib/std/string.ci:108: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:148: referenced as `padLen`
	lib/std/string.ci:109: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:110: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@0471c8>
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@0471c8> - <@04721c>)
	lib/std/string.ci:114: (56 bytes: <@0471c8> - <@047200>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @0471c8>      : 19                         load.z32
	<append+1 @0471c9>    : 04 29 00 00                jmp <append+42 @0471f2>
	lib/std/string.ci:115: (13 bytes: <@0471cd> - <@0471da>): if (bool(pos >= (output.length)))
	<append+5 @0471cd>    : 10 03                      dup.x1 sp(3)
	<append+7 @0471cf>    : 10 06                      dup.x1 sp(6)
	<append+9 @0471d1>    : 58                         clt.i32
	<append+10 @0471d2>   : 05 08 00 00                jnz <append+18 @0471da>
	lib/std/string.ci:116: (4 bytes: <@0471d6> - <@0471da>): break;
	<append+14 @0471d6>   : 04 26 00 00                jmp <append+52 @0471fc>
	lib/std/string.ci:118: (12 bytes: <@0471da> - <@0471e6>): char(output[pos] := value[i]);
	<append+18 @0471da>   : 10 02                      dup.x1 sp(2)
	<append+20 @0471dc>   : 10 01                      dup.x1 sp(1)
	<append+22 @0471de>   : 51                         add.i32
	<append+23 @0471df>   : 20                         load.i8
	<append+24 @0471e0>   : 10 05                      dup.x1 sp(5)
	<append+26 @0471e2>   : 10 05                      dup.x1 sp(5)
	<append+28 @0471e4>   : 51                         add.i32
	<append+29 @0471e5>   : 25                         store.i8
	lib/std/string.ci:119: (8 bytes: <@0471e6> - <@0471ee>): int32(pos := int32(pos + 1));
	<append+30 @0471e6>   : 10 03                      dup.x1 sp(3)
	<append+32 @0471e8>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @0471ec>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes: <@0471ee> - <@0471f2>): int32(i := int32(i + 1))
	<append+38 @0471ee>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:114: (10 bytes: <@0471f2> - <@0471fc>): value[i]
	<append+42 @0471f2>   : 10 02                      dup.x1 sp(2)
	<append+44 @0471f4>   : 10 01                      dup.x1 sp(1)
	<append+46 @0471f6>   : 51                         add.i32
	<append+47 @0471f7>   : 20                         load.i8
	<append+48 @0471f8>   : 05 d5 ff ff                jnz <append+5 @0471cd>
	<append+52 @0471fc>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:122: (17 bytes: <@047200> - <@047211>): if (bool(pos >= (output.length)))
	<append+56 @047200>   : 10 02                      dup.x1 sp(2)
	<append+58 @047202>   : 10 05                      dup.x1 sp(5)
	<append+60 @047204>   : 58                         clt.i32
	<append+61 @047205>   : 05 0c 00 00                jnz <append+73 @047211>
	lib/std/string.ci:123: (8 bytes: <@047209> - <@047211>): int32(pos := (uint32(output.length - (1))));
	<append+65 @047209>   : 10 04                      dup.x1 sp(4)
	<append+67 @04720b>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @04720f>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes: <@047211> - <@047218>): char(output[pos] := (0));
	<append+73 @047211>   : 19                         load.z32
	<append+74 @047212>   : 10 04                      dup.x1 sp(4)
	<append+76 @047214>   : 10 04                      dup.x1 sp(4)
	<append+78 @047216>   : 51                         add.i32
	<append+79 @047217>   : 25                         store.i8
	lib/std/string.ci:126: (4 bytes: <@047218> - <@04721c>): return int32(.result := pos);
	<append+80 @047218>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @04721b>   : 03                         ret
.references:
	lib/std/string.ci:113: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@047230>
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@047230> - <@0474c1>)
	lib/std/string.ci:133: (1 byte: <@047230> - <@047231>): len: int32 := 0
	<append @047230>      : 19                         load.z32
	lib/std/string.ci:134: (4 bytes: <@047231> - <@047235>): digits: char[80]
	<append+1 @047231>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:136: (3 bytes: <@047235> - <@047238>): radix: int32 := format.radix
	<append+5 @047235>    : 10 16                      dup.x1 sp(22)
	<append+7 @047237>    : 22                         load.i32
	lib/std/string.ci:137: (54 bytes: <@047238> - <@04726e>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @047238>    : 10 00                      dup.x1 sp(0)
	<append+10 @04723a>   : 1c 01 00 00 00             load.c32 1
	<append+15 @04723f>   : 59                         cgt.i32
	<append+16 @047240>   : 06 08 00 00                jz <append+24 @047248>
	<append+20 @047244>   : 04 2a 00 00                jmp <append+62 @04726e>
	<append+24 @047248>   : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+29 @04724d>   : 1c 89 00 00 00             load.c32 137
	<append+34 @047252>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @047257>   : 1c 80 00 00 00             load.c32 128
	<append+44 @04725c>   : 1f d9 b4 01 00             load.ref <@01b4d9> ;"radix is too small"
	<append+49 @047261>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+54 @047266>   : 0a 18 00 00                load.sp(+24)
	<append+58 @04726a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes: <@04726e> - <@0472a3>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @04726e>   : 10 00                      dup.x1 sp(0)
	<append+64 @047270>   : 2a 2c 72 04                load.m32 <@04722c> ;append.radixDigits+4
	<append+68 @047274>   : 58                         clt.i32
	<append+69 @047275>   : 06 08 00 00                jz <append+77 @04727d>
	<append+73 @047279>   : 04 2a 00 00                jmp <append+115 @0472a3>
	<append+77 @04727d>   : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+82 @047282>   : 1c 8a 00 00 00             load.c32 138
	<append+87 @047287>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @04728c>   : 1c 80 00 00 00             load.c32 128
	<append+97 @047291>   : 1f ec b4 01 00             load.ref <@01b4ec> ;"radix is too big"
	<append+102 @047296>  : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+107 @04729b>  : 0a 18 00 00                load.sp(+24)
	<append+111 @04729f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes: <@0472a3> - <@0472d1>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @0472a3>  : 04 26 00 00                jmp <append+153 @0472c9>
	lib/std/string.ci:142: (27 bytes: <@0472a7> - <@0472c2>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @0472a7>  : 2a 28 72 04                load.m32 <@047228> ;append.radixDigits
	<append+123 @0472ab>  : 10 19                      dup.x1 sp(25)
	<append+125 @0472ad>  : 10 02                      dup.x1 sp(2)
	<append+127 @0472af>  : 35                         mod.u32
	<append+128 @0472b0>  : 51                         add.i32
	<append+129 @0472b1>  : 20                         load.i8
	<append+130 @0472b2>  : 0a 08 00 00                load.sp(+8)
	<append+134 @0472b6>  : 10 17                      dup.x1 sp(23)
	<append+136 @0472b8>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @0472bc>  : 10 00                      dup.x1 sp(0)
	<append+142 @0472be>  : 13 19                      set.x1 sp(25)
	<append+144 @0472c0>  : 51                         add.i32
	<append+145 @0472c1>  : 25                         store.i8
	lib/std/string.ci:141: (7 bytes: <@0472c2> - <@0472c9>): uint32(value := uint32(value / (radix)))
	<append+146 @0472c2>  : 10 18                      dup.x1 sp(24)
	<append+148 @0472c4>  : 10 01                      dup.x1 sp(1)
	<append+150 @0472c6>  : 34                         div.u32
	<append+151 @0472c7>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes: <@0472c9> - <@0472d1>): bool(value > (0))
	<append+153 @0472c9>  : 10 18                      dup.x1 sp(24)
	<append+155 @0472cb>  : 19                         load.z32
	<append+156 @0472cc>  : 39                         cgt.u32
	<append+157 @0472cd>  : 05 da ff ff                jnz <append+119 @0472a7>
	lib/std/string.ci:144: (29 bytes: <@0472d1> - <@0472ee>): if (bool(len == 0))
	<append+161 @0472d1>  : 10 15                      dup.x1 sp(21)
	<append+163 @0472d3>  : 19                         load.z32
	<append+164 @0472d4>  : 57                         ceq.i32
	<append+165 @0472d5>  : 06 19 00 00                jz <append+190 @0472ee>
	lib/std/string.ci:145: (21 bytes: <@0472d9> - <@0472ee>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @0472d9>  : 1c 30 00 00 00             load.c32 48
	<append+174 @0472de>  : 0a 08 00 00                load.sp(+8)
	<append+178 @0472e2>  : 10 17                      dup.x1 sp(23)
	<append+180 @0472e4>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @0472e8>  : 10 00                      dup.x1 sp(0)
	<append+186 @0472ea>  : 13 19                      set.x1 sp(25)
	<append+188 @0472ec>  : 51                         add.i32
	<append+189 @0472ed>  : 25                         store.i8
	lib/std/string.ci:148: (10 bytes: <@0472ee> - <@0472f8>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @0472ee>  : 10 17                      dup.x1 sp(23)
	<append+192 @0472f0>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @0472f4>  : 22                         load.i32
	<append+197 @0472f5>  : 10 16                      dup.x1 sp(22)
	<append+199 @0472f7>  : 52                         sub.i32
	lib/std/string.ci:150: (7 bytes: <@0472f8> - <@0472ff>): padChr: char := format.padChr
	<append+200 @0472f8>  : 10 18                      dup.x1 sp(24)
	<append+202 @0472fa>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @0472fe>  : 20                         load.i8
	lib/std/string.ci:151: (21 bytes: <@0472ff> - <@047314>): if (bool(padChr == ''))
	<append+207 @0472ff>  : 0a 00 00 00                load.sp(+0)
	<append+211 @047303>  : 20                         load.i8
	<append+212 @047304>  : 19                         load.z32
	<append+213 @047305>  : 57                         ceq.i32
	<append+214 @047306>  : 06 0e 00 00                jz <append+228 @047314>
	lib/std/string.ci:152: (10 bytes: <@04730a> - <@047314>): char(padChr := ' ');
	<append+218 @04730a>  : 1c 20 00 00 00             load.c32 32
	<append+223 @04730f>  : 0a 04 00 00                load.sp(+4)
	<append+227 @047313>  : 25                         store.i8
	lib/std/string.ci:156: (207 bytes: <@047314> - <@0473e3>): if (bool((sign) != 0))
	<append+228 @047314>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @047318>  : 20                         load.i8
	<append+233 @047319>  : 19                         load.z32
	<append+234 @04731a>  : 57                         ceq.i32
	<append+235 @04731b>  : 05 c8 00 00                jnz <append+435 @0473e3>
	lib/std/string.ci:157: (8 bytes: <@04731f> - <@047327>): int32(maxLen := int32(maxLen - 1));
	<append+239 @04731f>  : 10 01                      dup.x1 sp(1)
	<append+241 @047321>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @047325>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes: <@047327> - <@04739c>): if (contains(void(whiteSpace, padChr)))
	<append+247 @047327>  : 19                         load.z32
	<append+248 @047328>  : 2a 20 72 04                load.m32 <@047220> ;append.whiteSpace
	<append+252 @04732c>  : 0a 08 00 00                load.sp(+8)
	<append+256 @047330>  : 20                         load.i8
	<append+257 @047331>  : 1f c8 6f 04 00             load.ref <@046fc8> ;indexOf(str: char[*], chr: char): int32
	<append+262 @047336>  : 02                         call
	<append+263 @047337>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @04733b>  : 19                         load.z32
	<append+268 @04733c>  : 58                         clt.i32
	<append+269 @04733d>  : 05 5f 00 00                jnz <append+364 @04739c>
	lib/std/string.ci:160: (91 bytes: <@047341> - <@04739c>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @047341>  : 04 53 00 00                jmp <append+356 @047394>
	lib/std/string.ci:161: (52 bytes: <@047345> - <@047379>): assert(bool(pos < (output.length)));
	<append+277 @047345>  : 10 1c                      dup.x1 sp(28)
	<append+279 @047347>  : 10 1f                      dup.x1 sp(31)
	<append+281 @047349>  : 58                         clt.i32
	<append+282 @04734a>  : 06 08 00 00                jz <append+290 @047352>
	<append+286 @04734e>  : 04 2b 00 00                jmp <append+329 @047379>
	<append+290 @047352>  : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+295 @047357>  : 1c a1 00 00 00             load.c32 161
	<append+300 @04735c>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @047361>  : 1c 80 00 00 00             load.c32 128
	<append+310 @047366>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+315 @04736b>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+320 @047370>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @047375>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes: <@047379> - <@047384>): char(output[pos] := padChr);
	<append+329 @047379>  : 0a 00 00 00                load.sp(+0)
	<append+333 @04737d>  : 20                         load.i8
	<append+334 @04737e>  : 10 1e                      dup.x1 sp(30)
	<append+336 @047380>  : 10 1e                      dup.x1 sp(30)
	<append+338 @047382>  : 51                         add.i32
	<append+339 @047383>  : 25                         store.i8
	lib/std/string.ci:163: (8 bytes: <@047384> - <@04738c>): int32(pos := int32(pos + 1));
	<append+340 @047384>  : 10 1c                      dup.x1 sp(28)
	<append+342 @047386>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @04738a>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes: <@04738c> - <@047394>): int32(maxLen := int32(maxLen - 1))
	<append+348 @04738c>  : 10 01                      dup.x1 sp(1)
	<append+350 @04738e>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @047392>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes: <@047394> - <@04739c>): bool(maxLen > 0)
	<append+356 @047394>  : 10 01                      dup.x1 sp(1)
	<append+358 @047396>  : 19                         load.z32
	<append+359 @047397>  : 59                         cgt.i32
	<append+360 @047398>  : 05 ad ff ff                jnz <append+277 @047345>
	lib/std/string.ci:166: (52 bytes: <@04739c> - <@0473d0>): assert(bool(pos < (output.length)));
	<append+364 @04739c>  : 10 1c                      dup.x1 sp(28)
	<append+366 @04739e>  : 10 1f                      dup.x1 sp(31)
	<append+368 @0473a0>  : 58                         clt.i32
	<append+369 @0473a1>  : 06 08 00 00                jz <append+377 @0473a9>
	<append+373 @0473a5>  : 04 2b 00 00                jmp <append+416 @0473d0>
	<append+377 @0473a9>  : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+382 @0473ae>  : 1c a6 00 00 00             load.c32 166
	<append+387 @0473b3>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @0473b8>  : 1c 80 00 00 00             load.c32 128
	<append+397 @0473bd>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+402 @0473c2>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+407 @0473c7>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @0473cc>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes: <@0473d0> - <@0473db>): char(output[pos] := sign);
	<append+416 @0473d0>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @0473d4>  : 20                         load.i8
	<append+421 @0473d5>  : 10 1e                      dup.x1 sp(30)
	<append+423 @0473d7>  : 10 1e                      dup.x1 sp(30)
	<append+425 @0473d9>  : 51                         add.i32
	<append+426 @0473da>  : 25                         store.i8
	lib/std/string.ci:168: (8 bytes: <@0473db> - <@0473e3>): int32(pos := int32(pos + 1));
	<append+427 @0473db>  : 10 1c                      dup.x1 sp(28)
	<append+429 @0473dd>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @0473e1>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes: <@0473e3> - <@04743e>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @0473e3>  : 04 53 00 00                jmp <append+518 @047436>
	lib/std/string.ci:173: (52 bytes: <@0473e7> - <@04741b>): assert(bool(pos < (output.length)));
	<append+439 @0473e7>  : 10 1c                      dup.x1 sp(28)
	<append+441 @0473e9>  : 10 1f                      dup.x1 sp(31)
	<append+443 @0473eb>  : 58                         clt.i32
	<append+444 @0473ec>  : 06 08 00 00                jz <append+452 @0473f4>
	<append+448 @0473f0>  : 04 2b 00 00                jmp <append+491 @04741b>
	<append+452 @0473f4>  : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+457 @0473f9>  : 1c ad 00 00 00             load.c32 173
	<append+462 @0473fe>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @047403>  : 1c 80 00 00 00             load.c32 128
	<append+472 @047408>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+477 @04740d>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+482 @047412>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @047417>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes: <@04741b> - <@047426>): char(output[pos] := padChr);
	<append+491 @04741b>  : 0a 00 00 00                load.sp(+0)
	<append+495 @04741f>  : 20                         load.i8
	<append+496 @047420>  : 10 1e                      dup.x1 sp(30)
	<append+498 @047422>  : 10 1e                      dup.x1 sp(30)
	<append+500 @047424>  : 51                         add.i32
	<append+501 @047425>  : 25                         store.i8
	lib/std/string.ci:175: (8 bytes: <@047426> - <@04742e>): int32(pos := int32(pos + 1));
	<append+502 @047426>  : 10 1c                      dup.x1 sp(28)
	<append+504 @047428>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @04742c>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes: <@04742e> - <@047436>): int32(maxLen := int32(maxLen - 1))
	<append+510 @04742e>  : 10 01                      dup.x1 sp(1)
	<append+512 @047430>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @047434>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes: <@047436> - <@04743e>): bool(maxLen > 0)
	<append+518 @047436>  : 10 01                      dup.x1 sp(1)
	<append+520 @047438>  : 19                         load.z32
	<append+521 @047439>  : 59                         cgt.i32
	<append+522 @04743a>  : 05 ad ff ff                jnz <append+439 @0473e7>
	lib/std/string.ci:179: (99 bytes: <@04743e> - <@0474a1>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @04743e>  : 19                         load.z32
	<append+527 @04743f>  : 04 55 00 00                jmp <append+612 @047494>
	lib/std/string.ci:180: (52 bytes: <@047443> - <@047477>): assert(bool(i < (output.length)));
	<append+531 @047443>  : 10 00                      dup.x1 sp(0)
	<append+533 @047445>  : 10 20                      dup.x1 sp(32)
	<append+535 @047447>  : 58                         clt.i32
	<append+536 @047448>  : 06 08 00 00                jz <append+544 @047450>
	<append+540 @04744c>  : 04 2b 00 00                jmp <append+583 @047477>
	<append+544 @047450>  : 1f c8 b3 01 00             load.ref <@01b3c8> ;"lib/std/string.ci"
	<append+549 @047455>  : 1c b4 00 00 00             load.c32 180
	<append+554 @04745a>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @04745f>  : 1c 80 00 00 00             load.c32 128
	<append+564 @047464>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+569 @047469>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+574 @04746e>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @047473>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes: <@047477> - <@047488>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @047477>  : 0a 10 00 00                load.sp(+16)
	<append+587 @04747b>  : 10 19                      dup.x1 sp(25)
	<append+589 @04747d>  : 10 02                      dup.x1 sp(2)
	<append+591 @04747f>  : 52                         sub.i32
	<append+592 @047480>  : 51                         add.i32
	<append+593 @047481>  : 20                         load.i8
	<append+594 @047482>  : 10 1f                      dup.x1 sp(31)
	<append+596 @047484>  : 10 1f                      dup.x1 sp(31)
	<append+598 @047486>  : 51                         add.i32
	<append+599 @047487>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@047488> - <@047490>): int32(pos := int32(pos + 1));
	<append+600 @047488>  : 10 1d                      dup.x1 sp(29)
	<append+602 @04748a>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @04748e>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes: <@047490> - <@047494>): int32(i := int32(i + 1))
	<append+608 @047490>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:179: (9 bytes: <@047494> - <@04749d>): bool(i < len)
	<append+612 @047494>  : 10 00                      dup.x1 sp(0)
	<append+614 @047496>  : 10 19                      dup.x1 sp(25)
	<append+616 @047498>  : 58                         clt.i32
	<append+617 @047499>  : 05 aa ff ff                jnz <append+531 @047443>
	<append+621 @04749d>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:185: (17 bytes: <@0474a1> - <@0474b2>): if (bool(pos >= (output.length)))
	<append+625 @0474a1>  : 10 1c                      dup.x1 sp(28)
	<append+627 @0474a3>  : 10 1f                      dup.x1 sp(31)
	<append+629 @0474a5>  : 58                         clt.i32
	<append+630 @0474a6>  : 05 0c 00 00                jnz <append+642 @0474b2>
	lib/std/string.ci:186: (8 bytes: <@0474aa> - <@0474b2>): int32(pos := (uint32(output.length - (1))));
	<append+634 @0474aa>  : 10 1e                      dup.x1 sp(30)
	<append+636 @0474ac>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @0474b0>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes: <@0474b2> - <@0474b9>): char(output[pos] := (0));
	<append+642 @0474b2>  : 19                         load.z32
	<append+643 @0474b3>  : 10 1e                      dup.x1 sp(30)
	<append+645 @0474b5>  : 10 1e                      dup.x1 sp(30)
	<append+647 @0474b7>  : 51                         add.i32
	<append+648 @0474b8>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@0474b9> - <@0474c1>): return int32(.result := pos);
	<append+649 @0474b9>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @0474bc>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @0474c0>  : 03                         ret
.references:
	lib/std/string.ci:202: referenced as `append`
	lib/std/string.ci:193: referenced as `append`
	lib/std/string.ci:129: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@0474c8>
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@0474c8> - <@0474df>)
	lib/std/string.ci:193: (23 bytes: <@0474c8> - <@0474df>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @0474c8>      : 19                         load.z32
	<append+1 @0474c9>    : 11 05                      dup.x2 sp(5)
	<append+3 @0474cb>    : 10 06                      dup.x1 sp(6)
	<append+5 @0474cd>    : 19                         load.z32
	<append+6 @0474ce>    : 10 07                      dup.x1 sp(7)
	<append+8 @0474d0>    : 10 07                      dup.x1 sp(7)
	<append+10 @0474d2>   : 1f 30 72 04 00             load.ref <@047230> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @0474d7>   : 02                         call
	<append+16 @0474d8>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @0474dc>   : 13 07                      set.x1 sp(7)
	<append+22 @0474de>   : 03                         ret
.references:
	lib/std/string.ci:207: referenced as `append`
	lib/std/string.ci:192: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0474e0>
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@0474e0> - <@047511>)
	lib/std/string.ci:197: (1 byte: <@0474e0> - <@0474e1>): sign: int32 := 0
	<append @0474e0>      : 19                         load.z32
	lib/std/string.ci:198: (20 bytes: <@0474e1> - <@0474f5>): if (bool(value < 0))
	<append+1 @0474e1>    : 10 03                      dup.x1 sp(3)
	<append+3 @0474e3>    : 19                         load.z32
	<append+4 @0474e4>    : 58                         clt.i32
	<append+5 @0474e5>    : 06 10 00 00                jz <append+21 @0474f5>
	lib/std/string.ci:199: (7 bytes: <@0474e9> - <@0474f0>): int32(sign := ('-'));
	<append+9 @0474e9>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @0474ee>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes: <@0474f0> - <@0474f5>): int32(value := int32(-value));
	<append+16 @0474f0>   : 10 03                      dup.x1 sp(3)
	<append+18 @0474f2>   : 50                         neg.i32
	<append+19 @0474f3>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes: <@0474f5> - <@047511>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @0474f5>   : 19                         load.z32
	<append+22 @0474f6>   : 11 06                      dup.x2 sp(6)
	<append+24 @0474f8>   : 10 07                      dup.x1 sp(7)
	<append+26 @0474fa>   : 10 04                      dup.x1 sp(4)
	<append+28 @0474fc>   : 10 08                      dup.x1 sp(8)
	<append+30 @0474fe>   : 10 08                      dup.x1 sp(8)
	<append+32 @047500>   : 1f 30 72 04 00             load.ref <@047230> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @047505>   : 02                         call
	<append+38 @047506>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @04750a>   : 13 08                      set.x1 sp(8)
	<append+44 @04750c>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @047510>   : 03                         ret
.references:
	lib/std/string.ci:196: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@047528>
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@047528> - <@047541>)
	lib/std/string.ci:207: (25 bytes: <@047528> - <@047541>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @047528>      : 19                         load.z32
	<append+1 @047529>    : 11 04                      dup.x2 sp(4)
	<append+3 @04752b>    : 10 05                      dup.x1 sp(5)
	<append+5 @04752d>    : 10 05                      dup.x1 sp(5)
	<append+7 @04752f>    : 1f 18 75 04 00             load.ref <@047518> ;append.format
	<append+12 @047534>   : 1f c8 74 04 00             load.ref <@0474c8> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @047539>   : 02                         call
	<append+18 @04753a>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @04753e>   : 13 06                      set.x1 sp(6)
	<append+24 @047540>   : 03                         ret
.references:
	lib/std/string.ci:205: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020120>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:3'
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.references:
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:15: referenced as `vec2d`
	lib/vec/vec2d.ci:8: referenced as `vec2d`
	lib/vec/vec2d.ci:3: defined as `vec2d`
}
vec2d.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:4'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:16: referenced as `x`
	lib/vec/vec2d.ci:10: referenced as `x`
	lib/vec/vec2d.ci:4: defined as `x`
}
vec2d.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:5'
.owner: vec2d
.references:
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:16: referenced as `y`
	lib/vec/vec2d.ci:11: referenced as `y`
	lib/vec/vec2d.ci:5: defined as `y`
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@047548>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:8'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@047548> - <@04754f>)
	lib/vec/vec2d.ci:9: (7 bytes: <@047548> - <@04754f>): return void(.result := {...});
	<vec2d @047548>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:11: (3 bytes: <@04754b> - <@04754e>): void(.result.y := y);
	<vec2d+3 @04754b>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @04754e>    : 03                         ret
.references:
	lib/vec/vec2d.ci:8: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:15'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.references:
	lib/vec/vec2d.ci:15: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:16'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.references:
	lib/vec/vec2d.ci:16: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@020950>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:3'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field .anonymous: vec4f..anonymous (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:25: referenced as `vec4f`
	lib/vec/mat4f.ci:9: referenced as `vec4f`
	lib/vec/mat4f.ci:8: referenced as `vec4f`
	lib/vec/mat4f.ci:7: referenced as `vec4f`
	lib/vec/mat4f.ci:6: referenced as `vec4f`
	lib/vec/vec4f.ci:77: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:74: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:70: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:68: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:63: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:62: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:60: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:59: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:58: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:57: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:56: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:21: referenced as `vec4f`
	lib/vec/vec4f.ci:3: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:4'
.owner: vec4f
.references:
	lib/vec/vec4f.ci:4: defined as `data`
}
vec4f..anonymous: vec4f..anonymous {
.kind: variable(val)
.base: `vec4f..anonymous`
.size: 16
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/vec4f.ci:84'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.references:
	lib/vec/vec4f.ci:84: defined as `.anonymous`
}
vec4f..anonymous.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:21: referenced as `x`
	lib/vec/mat4f.ci:20: referenced as `x`
	lib/vec/mat4f.ci:19: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/vec4f.ci:77: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:72: referenced as `x`
	lib/vec/vec4f.ci:25: referenced as `x`
	lib/vec/vec4f.ci:22: referenced as `x`
	lib/vec/vec4f.ci:6: defined as `x`
}
vec4f..anonymous.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:21: referenced as `y`
	lib/vec/mat4f.ci:20: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:18: referenced as `y`
	lib/vec/vec4f.ci:77: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:72: referenced as `y`
	lib/vec/vec4f.ci:25: referenced as `y`
	lib/vec/vec4f.ci:22: referenced as `y`
	lib/vec/vec4f.ci:7: defined as `y`
}
vec4f..anonymous.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:21: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:19: referenced as `z`
	lib/vec/mat4f.ci:18: referenced as `z`
	lib/vec/vec4f.ci:77: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:72: referenced as `z`
	lib/vec/vec4f.ci:25: referenced as `z`
	lib/vec/vec4f.ci:22: referenced as `z`
	lib/vec/vec4f.ci:8: defined as `z`
}
vec4f..anonymous.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f..anonymous
.references:
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:20: referenced as `w`
	lib/vec/mat4f.ci:19: referenced as `w`
	lib/vec/mat4f.ci:18: referenced as `w`
	lib/vec/vec4f.ci:77: referenced as `w`
	lib/vec/vec4f.ci:22: referenced as `w`
	lib/vec/vec4f.ci:9: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.value: x: float32
.references:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:7'
.owner: vec4f
.value: y: float32
.references:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:8'
.owner: vec4f
.value: z: float32
.references:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.value: w: float32
.references:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@047550>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:21'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@047550> - <@04755d>)
	lib/vec/vec4f.ci:22: (13 bytes: <@047550> - <@04755d>): return void(.result := {...});
	<vec4f @047550>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:22: (3 bytes: <@047553> - <@047556>): void(.result.y := y);
	<vec4f+3 @047553>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:22: (3 bytes: <@047556> - <@047559>): void(.result.z := z);
	<vec4f+6 @047556>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:22: (3 bytes: <@047559> - <@04755c>): void(.result.w := w);
	<vec4f+9 @047559>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @04755c>   : 03                         ret
.references:
	lib/vec/mat4f.ci:31: referenced as `vec4f`
	lib/vec/mat4f.ci:30: referenced as `vec4f`
	lib/vec/mat4f.ci:29: referenced as `vec4f`
	lib/vec/vec4f.ci:26: referenced as `vec4f`
	lib/vec/vec4f.ci:25: referenced as `vec4f`
	lib/vec/vec4f.ci:24: referenced as `vec4f`
	lib/vec/vec4f.ci:21: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:24'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.value: vec4f(void(void(void(x, y), z), 0.000000))
.references:
	lib/vec/vec4f.ci:72: referenced as `vec4f`
	lib/vec/vec4f.ci:24: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:25'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.references:
	lib/vec/vec4f.ci:25: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: vec4f(void(void(void(val, val), val), val))
.references:
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:26: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:56'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.references:
	lib/vec/vec4f.ci:56: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:57'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.references:
	lib/vec/vec4f.ci:57: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:58'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.references:
	lib/vec/vec4f.ci:58: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:59'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.references:
	lib/vec/vec4f.ci:59: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:60'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.references:
	lib/vec/vec4f.ci:75: referenced as `div`
	lib/vec/vec4f.ci:60: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:62'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.references:
	lib/vec/vec4f.ci:62: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:63'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.references:
	lib/vec/vec4f.ci:63: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:68'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.references:
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/mat4f.ci:29: referenced as `dp3`
	lib/vec/vec4f.ci:74: referenced as `dp3`
	lib/vec/vec4f.ci:68: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:69'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.references:
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/mat4f.ci:31: referenced as `dph`
	lib/vec/vec4f.ci:69: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:70'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.references:
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/mat4f.ci:30: referenced as `dp4`
	lib/vec/vec4f.ci:70: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:72'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.references:
	lib/vec/vec4f.ci:72: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:74'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.value: float32.sqrt(dp3(void(v, v)))
.references:
	lib/vec/vec4f.ci:75: referenced as `len`
	lib/vec/vec4f.ci:74: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.value: div(void(v, vec4f(len(v))))
.references:
	lib/vec/vec4f.ci:75: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:77'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.references:
	lib/vec/vec4f.ci:77: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@023660>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:3'
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field .anonymous: mat4f..anonymous (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.references:
	lib/vec/mat4f.ci:34: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:33: referenced as `mat4f`
	lib/vec/mat4f.ci:31: referenced as `mat4f`
	lib/vec/mat4f.ci:30: referenced as `mat4f`
	lib/vec/mat4f.ci:29: referenced as `mat4f`
	lib/vec/mat4f.ci:25: referenced as `mat4f`
	lib/vec/mat4f.ci:13: referenced as `mat4f`
	lib/vec/mat4f.ci:3: defined as `mat4f`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:4'
.owner: mat4f
.references:
	lib/vec/mat4f.ci:4: defined as `data`
}
mat4f..anonymous: mat4f..anonymous {
.kind: variable(val)
.base: `mat4f..anonymous`
.size: 64
.offset: <+0>
.name: '.anonymous'
.file: 'lib/vec/mat4f.ci:59'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.references:
	lib/vec/mat4f.ci:59: defined as `.anonymous`
}
mat4f..anonymous.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:42: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:38: referenced as `x`
	lib/vec/mat4f.ci:37: referenced as `x`
	lib/vec/mat4f.ci:36: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:31: referenced as `x`
	lib/vec/mat4f.ci:30: referenced as `x`
	lib/vec/mat4f.ci:29: referenced as `x`
	lib/vec/mat4f.ci:26: referenced as `x`
	lib/vec/mat4f.ci:18: referenced as `x`
	lib/vec/mat4f.ci:6: defined as `x`
}
mat4f..anonymous.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:43: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:38: referenced as `y`
	lib/vec/mat4f.ci:37: referenced as `y`
	lib/vec/mat4f.ci:36: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:31: referenced as `y`
	lib/vec/mat4f.ci:30: referenced as `y`
	lib/vec/mat4f.ci:29: referenced as `y`
	lib/vec/mat4f.ci:26: referenced as `y`
	lib/vec/mat4f.ci:19: referenced as `y`
	lib/vec/mat4f.ci:7: defined as `y`
}
mat4f..anonymous.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:44: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:38: referenced as `z`
	lib/vec/mat4f.ci:37: referenced as `z`
	lib/vec/mat4f.ci:36: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:31: referenced as `z`
	lib/vec/mat4f.ci:30: referenced as `z`
	lib/vec/mat4f.ci:29: referenced as `z`
	lib/vec/mat4f.ci:26: referenced as `z`
	lib/vec/mat4f.ci:20: referenced as `z`
	lib/vec/mat4f.ci:8: defined as `z`
}
mat4f..anonymous.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f..anonymous
.references:
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:45: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:38: referenced as `w`
	lib/vec/mat4f.ci:37: referenced as `w`
	lib/vec/mat4f.ci:36: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:31: referenced as `w`
	lib/vec/mat4f.ci:30: referenced as `w`
	lib/vec/mat4f.ci:26: referenced as `w`
	lib/vec/mat4f.ci:21: referenced as `w`
	lib/vec/mat4f.ci:9: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.value: x: vec4f
.references:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:7'
.owner: mat4f
.value: y: vec4f
.references:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:8'
.owner: mat4f
.value: z: vec4f
.references:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.value: w: vec4f
.references:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@047560>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:13'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@047560> - <@047591>)
	lib/vec/mat4f.ci:17: (49 bytes: <@047560> - <@047591>): return void(.result := {...});
	<mat4f @047560>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:18: (3 bytes: <@047563> - <@047566>): void(.result.x.y := xy);
	<mat4f+3 @047563>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:18: (3 bytes: <@047566> - <@047569>): void(.result.x.z := xz);
	<mat4f+6 @047566>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:18: (3 bytes: <@047569> - <@04756c>): void(.result.x.w := xw);
	<mat4f+9 @047569>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:19: (3 bytes: <@04756c> - <@04756f>): void(.result.y.x := yx);
	<mat4f+12 @04756c>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:19: (3 bytes: <@04756f> - <@047572>): void(.result.y.y := yy);
	<mat4f+15 @04756f>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:19: (3 bytes: <@047572> - <@047575>): void(.result.y.z := yz);
	<mat4f+18 @047572>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:19: (3 bytes: <@047575> - <@047578>): void(.result.y.w := yw);
	<mat4f+21 @047575>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:20: (3 bytes: <@047578> - <@04757b>): void(.result.z.x := zx);
	<mat4f+24 @047578>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:20: (3 bytes: <@04757b> - <@04757e>): void(.result.z.y := zy);
	<mat4f+27 @04757b>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:20: (3 bytes: <@04757e> - <@047581>): void(.result.z.z := zz);
	<mat4f+30 @04757e>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:20: (3 bytes: <@047581> - <@047584>): void(.result.z.w := zw);
	<mat4f+33 @047581>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:21: (3 bytes: <@047584> - <@047587>): void(.result.w.x := wx);
	<mat4f+36 @047584>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:21: (3 bytes: <@047587> - <@04758a>): void(.result.w.y := wy);
	<mat4f+39 @047587>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:21: (3 bytes: <@04758a> - <@04758d>): void(.result.w.z := wz);
	<mat4f+42 @04758a>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:21: (3 bytes: <@04758d> - <@047590>): void(.result.w.w := ww);
	<mat4f+45 @04758d>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @047590>   : 03                         ret
.references:
	lib/vec/mat4f.ci:13: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@047598>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:25'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@047598> - <@0475ad>)
	lib/vec/mat4f.ci:26: (21 bytes: <@047598> - <@0475ad>): return void(.result := {...});
	<mat4f @047598>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @04759a>    : 24                         load.i128
	<mat4f+3 @04759b>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:26: (5 bytes: <@04759d> - <@0475a2>): void(.result.y := y);
	<mat4f+5 @04759d>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @04759f>    : 24                         load.i128
	<mat4f+8 @0475a0>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:26: (5 bytes: <@0475a2> - <@0475a7>): void(.result.z := z);
	<mat4f+10 @0475a2>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @0475a4>   : 24                         load.i128
	<mat4f+13 @0475a5>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:26: (5 bytes: <@0475a7> - <@0475ac>): void(.result.w := w);
	<mat4f+15 @0475a7>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @0475a9>   : 24                         load.i128
	<mat4f+18 @0475aa>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @0475ac>   : 03                         ret
.references:
	lib/vec/mat4f.ci:25: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.references:
	lib/vec/mat4f.ci:29: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:30'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:45: referenced as `dp4`
	lib/vec/mat4f.ci:44: referenced as `dp4`
	lib/vec/mat4f.ci:43: referenced as `dp4`
	lib/vec/mat4f.ci:42: referenced as `dp4`
	lib/vec/mat4f.ci:30: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:31'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.references:
	lib/vec/mat4f.ci:31: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@0475b0>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:33'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@0475b0> - <@047751>)
	lib/vec/mat4f.ci:34: (144 bytes: <@0475b0> - <@047640>): transposed: mat4f := {...}
	<mul @0475b0>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:35: (5 bytes: <@0475b4> - <@0475b9>): void(transposed.x.x := rhs.x.x);
	<mul+4 @0475b4>    : 10 11                      dup.x1 sp(17)
	<mul+6 @0475b6>    : 22                         load.i32
	<mul+7 @0475b7>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:35: (9 bytes: <@0475b9> - <@0475c2>): void(transposed.x.y := rhs.y.x);
	<mul+9 @0475b9>    : 10 11                      dup.x1 sp(17)
	<mul+11 @0475bb>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @0475bf>   : 22                         load.i32
	<mul+16 @0475c0>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:35: (9 bytes: <@0475c2> - <@0475cb>): void(transposed.x.z := rhs.z.x);
	<mul+18 @0475c2>   : 10 11                      dup.x1 sp(17)
	<mul+20 @0475c4>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @0475c8>   : 22                         load.i32
	<mul+25 @0475c9>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:35: (9 bytes: <@0475cb> - <@0475d4>): void(transposed.x.w := rhs.w.x);
	<mul+27 @0475cb>   : 10 11                      dup.x1 sp(17)
	<mul+29 @0475cd>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @0475d1>   : 22                         load.i32
	<mul+34 @0475d2>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:36: (9 bytes: <@0475d4> - <@0475dd>): void(transposed.y.x := rhs.x.y);
	<mul+36 @0475d4>   : 10 11                      dup.x1 sp(17)
	<mul+38 @0475d6>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @0475da>   : 22                         load.i32
	<mul+43 @0475db>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:36: (9 bytes: <@0475dd> - <@0475e6>): void(transposed.y.y := rhs.y.y);
	<mul+45 @0475dd>   : 10 11                      dup.x1 sp(17)
	<mul+47 @0475df>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @0475e3>   : 22                         load.i32
	<mul+52 @0475e4>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:36: (9 bytes: <@0475e6> - <@0475ef>): void(transposed.y.z := rhs.z.y);
	<mul+54 @0475e6>   : 10 11                      dup.x1 sp(17)
	<mul+56 @0475e8>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @0475ec>   : 22                         load.i32
	<mul+61 @0475ed>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:36: (9 bytes: <@0475ef> - <@0475f8>): void(transposed.y.w := rhs.w.y);
	<mul+63 @0475ef>   : 10 11                      dup.x1 sp(17)
	<mul+65 @0475f1>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @0475f5>   : 22                         load.i32
	<mul+70 @0475f6>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:37: (9 bytes: <@0475f8> - <@047601>): void(transposed.z.x := rhs.x.z);
	<mul+72 @0475f8>   : 10 11                      dup.x1 sp(17)
	<mul+74 @0475fa>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @0475fe>   : 22                         load.i32
	<mul+79 @0475ff>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:37: (9 bytes: <@047601> - <@04760a>): void(transposed.z.y := rhs.y.z);
	<mul+81 @047601>   : 10 11                      dup.x1 sp(17)
	<mul+83 @047603>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @047607>   : 22                         load.i32
	<mul+88 @047608>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:37: (9 bytes: <@04760a> - <@047613>): void(transposed.z.z := rhs.z.z);
	<mul+90 @04760a>   : 10 11                      dup.x1 sp(17)
	<mul+92 @04760c>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @047610>   : 22                         load.i32
	<mul+97 @047611>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:37: (9 bytes: <@047613> - <@04761c>): void(transposed.z.w := rhs.w.z);
	<mul+99 @047613>   : 10 11                      dup.x1 sp(17)
	<mul+101 @047615>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @047619>  : 22                         load.i32
	<mul+106 @04761a>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:38: (9 bytes: <@04761c> - <@047625>): void(transposed.w.x := rhs.x.w);
	<mul+108 @04761c>  : 10 11                      dup.x1 sp(17)
	<mul+110 @04761e>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @047622>  : 22                         load.i32
	<mul+115 @047623>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:38: (9 bytes: <@047625> - <@04762e>): void(transposed.w.y := rhs.y.w);
	<mul+117 @047625>  : 10 11                      dup.x1 sp(17)
	<mul+119 @047627>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @04762b>  : 22                         load.i32
	<mul+124 @04762c>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:38: (9 bytes: <@04762e> - <@047637>): void(transposed.w.z := rhs.z.w);
	<mul+126 @04762e>  : 10 11                      dup.x1 sp(17)
	<mul+128 @047630>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @047634>  : 22                         load.i32
	<mul+133 @047635>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:38: (9 bytes: <@047637> - <@047640>): void(transposed.w.w := rhs.w.w);
	<mul+135 @047637>  : 10 11                      dup.x1 sp(17)
	<mul+137 @047639>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @04763d>  : 22                         load.i32
	<mul+142 @04763e>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:41: (273 bytes: <@047640> - <@047751>): return void(.result := {...});
	<mul+144 @047640>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @047644>  : 10 13                      dup.x1 sp(19)
	<mul+150 @047646>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @04764a>  : 10 04                      dup.x1 sp(4)
	<mul+156 @04764c>  : 24                         load.i128
	<mul+157 @04764d>  : 10 09                      dup.x1 sp(9)
	<mul+159 @04764f>  : 24                         load.i128
	<mul+160 @047650>  : 9b                         dp4.v4f
	<mul+161 @047651>  : 10 05                      dup.x1 sp(5)
	<mul+163 @047653>  : 24                         load.i128
	<mul+164 @047654>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @047656>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @04765a>  : 24                         load.i128
	<mul+171 @04765b>  : 9b                         dp4.v4f
	<mul+172 @04765c>  : 10 06                      dup.x1 sp(6)
	<mul+174 @04765e>  : 24                         load.i128
	<mul+175 @04765f>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @047661>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @047665>  : 24                         load.i128
	<mul+182 @047666>  : 9b                         dp4.v4f
	<mul+183 @047667>  : 10 07                      dup.x1 sp(7)
	<mul+185 @047669>  : 24                         load.i128
	<mul+186 @04766a>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @04766c>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @047670>  : 24                         load.i128
	<mul+193 @047671>  : 9b                         dp4.v4f
	<mul+194 @047672>  : 1f 50 75 04 00             load.ref <@047550> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @047677>  : 02                         call
	<mul+200 @047678>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @04767c>  : 15 02                      set.x4 sp(2)
	<mul+206 @04767e>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:43: (68 bytes: <@047680> - <@0476c4>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @047680>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @047684>  : 10 13                      dup.x1 sp(19)
	<mul+214 @047686>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @04768a>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @04768e>  : 10 04                      dup.x1 sp(4)
	<mul+224 @047690>  : 24                         load.i128
	<mul+225 @047691>  : 10 09                      dup.x1 sp(9)
	<mul+227 @047693>  : 24                         load.i128
	<mul+228 @047694>  : 9b                         dp4.v4f
	<mul+229 @047695>  : 10 05                      dup.x1 sp(5)
	<mul+231 @047697>  : 24                         load.i128
	<mul+232 @047698>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @04769a>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @04769e>  : 24                         load.i128
	<mul+239 @04769f>  : 9b                         dp4.v4f
	<mul+240 @0476a0>  : 10 06                      dup.x1 sp(6)
	<mul+242 @0476a2>  : 24                         load.i128
	<mul+243 @0476a3>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @0476a5>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @0476a9>  : 24                         load.i128
	<mul+250 @0476aa>  : 9b                         dp4.v4f
	<mul+251 @0476ab>  : 10 07                      dup.x1 sp(7)
	<mul+253 @0476ad>  : 24                         load.i128
	<mul+254 @0476ae>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @0476b0>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @0476b4>  : 24                         load.i128
	<mul+261 @0476b5>  : 9b                         dp4.v4f
	<mul+262 @0476b6>  : 1f 50 75 04 00             load.ref <@047550> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @0476bb>  : 02                         call
	<mul+268 @0476bc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @0476c0>  : 15 02                      set.x4 sp(2)
	<mul+274 @0476c2>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:44: (68 bytes: <@0476c4> - <@047708>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @0476c4>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @0476c8>  : 10 13                      dup.x1 sp(19)
	<mul+282 @0476ca>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @0476ce>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @0476d2>  : 10 04                      dup.x1 sp(4)
	<mul+292 @0476d4>  : 24                         load.i128
	<mul+293 @0476d5>  : 10 09                      dup.x1 sp(9)
	<mul+295 @0476d7>  : 24                         load.i128
	<mul+296 @0476d8>  : 9b                         dp4.v4f
	<mul+297 @0476d9>  : 10 05                      dup.x1 sp(5)
	<mul+299 @0476db>  : 24                         load.i128
	<mul+300 @0476dc>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @0476de>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @0476e2>  : 24                         load.i128
	<mul+307 @0476e3>  : 9b                         dp4.v4f
	<mul+308 @0476e4>  : 10 06                      dup.x1 sp(6)
	<mul+310 @0476e6>  : 24                         load.i128
	<mul+311 @0476e7>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @0476e9>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @0476ed>  : 24                         load.i128
	<mul+318 @0476ee>  : 9b                         dp4.v4f
	<mul+319 @0476ef>  : 10 07                      dup.x1 sp(7)
	<mul+321 @0476f1>  : 24                         load.i128
	<mul+322 @0476f2>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @0476f4>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @0476f8>  : 24                         load.i128
	<mul+329 @0476f9>  : 9b                         dp4.v4f
	<mul+330 @0476fa>  : 1f 50 75 04 00             load.ref <@047550> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @0476ff>  : 02                         call
	<mul+336 @047700>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @047704>  : 15 02                      set.x4 sp(2)
	<mul+342 @047706>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:45: (68 bytes: <@047708> - <@04774c>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @047708>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @04770c>  : 10 13                      dup.x1 sp(19)
	<mul+350 @04770e>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @047712>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @047716>  : 10 04                      dup.x1 sp(4)
	<mul+360 @047718>  : 24                         load.i128
	<mul+361 @047719>  : 10 09                      dup.x1 sp(9)
	<mul+363 @04771b>  : 24                         load.i128
	<mul+364 @04771c>  : 9b                         dp4.v4f
	<mul+365 @04771d>  : 10 05                      dup.x1 sp(5)
	<mul+367 @04771f>  : 24                         load.i128
	<mul+368 @047720>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @047722>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @047726>  : 24                         load.i128
	<mul+375 @047727>  : 9b                         dp4.v4f
	<mul+376 @047728>  : 10 06                      dup.x1 sp(6)
	<mul+378 @04772a>  : 24                         load.i128
	<mul+379 @04772b>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @04772d>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @047731>  : 24                         load.i128
	<mul+386 @047732>  : 9b                         dp4.v4f
	<mul+387 @047733>  : 10 07                      dup.x1 sp(7)
	<mul+389 @047735>  : 24                         load.i128
	<mul+390 @047736>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @047738>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @04773c>  : 24                         load.i128
	<mul+397 @04773d>  : 9b                         dp4.v4f
	<mul+398 @04773e>  : 1f 50 75 04 00             load.ref <@047550> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @047743>  : 02                         call
	<mul+404 @047744>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @047748>  : 15 02                      set.x4 sp(2)
	<mul+410 @04774a>  : 15 23                      set.x4 sp(35)
	<mul+412 @04774c>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @047750>  : 03                         ret
.references:
	lib/vec/mat4f.ci:33: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.references:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.references:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.references:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.references:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.references:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.references:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.references:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.references:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.references:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.references:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.references:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.references:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.references:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.references:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.references:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.references:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.references:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.references:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.references:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.references:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.references:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.references:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.references:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.references:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.references:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.references:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.references:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.references:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.references:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.references:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.references:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.references:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.references:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.references:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.references:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.references:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.references:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.references:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02a9c0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.references:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02aad0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.references:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.references:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.references:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.references:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@047758>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.references:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.references:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.references:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.references:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.references:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.references:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.references:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.references:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.references:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.references:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.references:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.references:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.references:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.references:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.references:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.references:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.references:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.references:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.references:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.references:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.references:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.references:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.references:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.references:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.references:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.references:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.references:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.references:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.references:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.references:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.references:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.references:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.references:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.references:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.references:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.references:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.references:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.references:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.references:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.references:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.references:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.references:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.references:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.references:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.references:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.references:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.references:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.references:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.references:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.references:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.references:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.references:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.references:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.references:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.references:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.references:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.references:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.references:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.references:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.references:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.references:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.references:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.references:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.references:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.references:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.references:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.references:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.references:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.references:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.references:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.references:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.references:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.references:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.references:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.references:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.references:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.references:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.references:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.references:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.references:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.references:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.references:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@047760>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@047760> - <@047761>)
	<empty @047760>      : 03                         ret
.references:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@047768>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@047768> - <@047770>)
	test/lang/function.ci:7: (8 bytes: <@047768> - <@047770>): return int32(.result := int32(x + y));
	<funAdd @047768>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @04776a>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @04776c>    : 51                         add.i32
	<funAdd+5 @04776d>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @04776f>    : 03                         ret
.references:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.references:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.references:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.references:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.references:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.references:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@047770>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@047770> - <@047778>)
	test/lang/function.ci:33: (8 bytes: <@047770> - <@047778>): return int32(.result := int32(x * y));
	<funMul @047770>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @047772>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @047774>    : 53                         mul.i32
	<funMul+5 @047775>    : 13 04                      set.x1 sp(4)
	<funMul+7 @047777>    : 03                         ret
.references:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@047778>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@047778> - <@0477ae>)
	test/lang/function.ci:38: (16 bytes: <@047778> - <@047788>): if (bool(n <= (1)))
	<fib @047778>      : 10 01                      dup.x1 sp(1)
	<fib+2 @04777a>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @04777f>    : 39                         cgt.u32
	<fib+8 @047780>    : 05 08 00 00                jnz <fib+16 @047788>
	test/lang/function.ci:39: (4 bytes: <@047784> - <@047788>): return uint32(.result := n);
	<fib+12 @047784>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @047787>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@047788> - <@0477ae>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @047788>   : 19                         load.z32
	<fib+17 @047789>   : 10 02                      dup.x1 sp(2)
	<fib+19 @04778b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @04778f>   : 1f 78 77 04 00             load.ref <@047778> ;fib(n: uint32): uint32
	<fib+28 @047794>   : 02                         call
	<fib+29 @047795>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @047799>   : 19                         load.z32
	<fib+34 @04779a>   : 10 03                      dup.x1 sp(3)
	<fib+36 @04779c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @0477a0>   : 1f 78 77 04 00             load.ref <@047778> ;fib(n: uint32): uint32
	<fib+45 @0477a5>   : 02                         call
	<fib+46 @0477a6>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @0477aa>   : 51                         add.i32
	<fib+51 @0477ab>   : 13 03                      set.x1 sp(3)
	<fib+53 @0477ad>   : 03                         ret
.references:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.references:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.references:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.references:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.references:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.references:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.references:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.references:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.references:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.references:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.references:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.references:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.references:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.references:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.references:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.references:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.references:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.references:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.references:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.references:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@02fe90>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.references:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.references:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@02ffa0>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.references:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.references:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.references:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.references:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.references:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.references:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.references:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.references:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.references:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.references:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.references:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.references:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.references:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.references:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.references:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.references:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.references:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.references:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.references:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.references:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.references:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.references:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.references:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.references:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.references:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.references:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.references:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.references:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.references:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.references:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.references:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.references:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.references:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.references:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.references:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.references:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.references:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.references:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.references:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.references:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.references:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.references:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.references:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.references:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.references:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.references:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.references:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.references:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.references:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.references:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.references:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.references:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.references:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.references:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.references:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@0477b0>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@0477b0> - <@0477b1>)
	<noError @0477b0>      : 03                         ret
.references:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@0477b8>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@0477b8> - <@0477d0>)
	test/stdc/tryExec.ci:15: (4 bytes: <@0477b8> - <@0477bc>): data: uint8[8192]
	<stackOverflow @0477b8>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@0477bc> - <@0477cb>): stackOverflow(ptr);
	<stackOverflow+4 @0477bc>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @0477c0>    : 22                         load.i32
	<stackOverflow+9 @0477c1>    : 1f b8 77 04 00             load.ref <@0477b8> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @0477c6>   : 02                         call
	<stackOverflow+15 @0477c7>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @0477cb>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @0477cf>   : 03                         ret
.references:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0477d0>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@0477d0> - <@0477dc>)
	test/stdc/tryExec.ci:20: (7 bytes: <@0477d0> - <@0477d7>): value: int32 := int32(3 / 0)
	<divisionByZero @0477d0>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @0477d5>    : 19                         load.z32
	<divisionByZero+6 @0477d6>    : 54                         div.i32
	<divisionByZero+7 @0477d7>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @0477db>   : 03                         ret
.references:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@0477e0>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@0477e0> - <@047824>)
	test/stdc/tryExec.ci:29: (25 bytes: <@0477e0> - <@0477f9>): details: NotEquals := {...}
	<abortExecution @0477e0>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@0477e4> - <@0477eb>): void(details.message := ("assertion failed"));
	<abortExecution+4 @0477e4>    : 1f 32 b6 00 00             load.ref <@00b632> ;"assertion failed"
	<abortExecution+9 @0477e9>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@0477eb> - <@0477f2>): void(details.expected := 97);
	<abortExecution+11 @0477eb>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @0477f0>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@0477f2> - <@0477f9>): void(details.returned := 77);
	<abortExecution+18 @0477f2>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @0477f7>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@0477f9> - <@04781f>): abort(void("fatal error", details));
	<abortExecution+25 @0477f9>   : 1f 88 35 03 00             load.ref <@033588> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @0477fe>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @047803>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @047808>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @04780d>   : 1f d1 35 03 00             load.ref <@0335d1> ;"fatal error"
	<abortExecution+50 @047812>   : 1f e8 3e 03 00             load.ref <@033ee8> ;abortExecution.NotEquals
	<abortExecution+55 @047817>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @04781b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @04781f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @047823>   : 03                         ret
.references:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@047828>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@047828> - <@047835>)
	test/stdc/tryExec.ci:38: (5 bytes: <@047828> - <@04782d>): i32Ref: int32 := null
	<invalidMemoryAccess @047828>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@04782d> - <@047830>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @04782d>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @04782f>    : 22                         load.i32
	<invalidMemoryAccess+8 @047830>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @047834>   : 03                         ret
.references:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@047838>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@047838> - <@04783a>)
	test/stdc/tryExec.ci:43: (2 bytes: <@047838> - <@04783a>): emit(void(load.z32, ret));
	<invalidInstruction @047838>      : 19                         load.z32
	<invalidInstruction+1 @047839>    : 03                         ret
.references:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.references:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.references:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.references:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.references:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.references:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.references:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.references:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.references:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.references:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.references:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.references:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.references:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.references:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.references:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.references:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.references:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@047840>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@047840> - <@047844>)
	test/lang/array.ci:103: (4 bytes: <@047840> - <@047844>): return uint32(.result := values.length);
	<lenSlice @047840>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @047843>    : 03                         ret
.references:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@047848>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@047848> - <@047854>)
	test/lang/array.ci:104: (12 bytes: <@047848> - <@047854>): return int64(.result := values[idx]);
	<nthFixed @047848>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @04784a>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @04784c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @047850>    : 23                         load.i64
	<nthFixed+9 @047851>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @047853>   : 03                         ret
.references:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@047858>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@047858> - <@047864>)
	test/lang/array.ci:105: (12 bytes: <@047858> - <@047864>): return int64(.result := values[idx]);
	<nthArray @047858>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @04785a>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @04785c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @047860>    : 23                         load.i64
	<nthArray+9 @047861>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @047863>   : 03                         ret
.references:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@047868>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@047868> - <@047874>)
	test/lang/array.ci:106: (12 bytes: <@047868> - <@047874>): return int64(.result := values[idx]);
	<nthSlice @047868>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @04786a>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @04786c>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @047870>    : 23                         load.i64
	<nthSlice+9 @047871>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @047873>   : 03                         ret
.references:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0367a0>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@036828>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@047878>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@047880>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@047888>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@047890>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@047898>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@0478a0>, cast: static const variable(val))
.references:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@036828>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.references:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.references:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@047878>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@047880>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.references:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@047888>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@047890>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@047898>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.references:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0478a0>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.references:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.references:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@037168>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 39, offs: <@0478a8>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@0478d0>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@0478d8>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@047900>, cast: static const function)
.references:
	test/lang/method.ci:80: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:68: referenced as `RecordMethodTest`
	test/lang/method.ci:65: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:30: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:19: referenced as `RecordMethodTest`
	test/lang/method.ci:15: referenced as `RecordMethodTest`
	test/lang/method.ci:11: referenced as `RecordMethodTest`
	test/lang/method.ci:6: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@0478a8>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@0478a8> - <@0478cf>)
	test/lang/method.ci:7: (38 bytes: <@0478a8> - <@0478ce>): trace(void("staticMethod", x));
	<staticMethod @0478a8>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<staticMethod+5 @0478ad>    : 1c 07 00 00 00             load.c32 7
	<staticMethod+10 @0478b2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0478b7>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @0478bc>   : 1f cd 70 03 00             load.ref <@0370cd> ;"staticMethod"
	<staticMethod+25 @0478c1>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<staticMethod+30 @0478c6>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @0478ca>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @0478ce>   : 03                         ret
.references:
	test/lang/method.ci:79: referenced as `staticMethod`
	test/lang/method.ci:65: referenced as `staticMethod`
	test/lang/method.ci:58: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0478d0>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:11'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:19: referenced as `forwardMethod`
	test/lang/method.ci:11: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:15'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.references:
	test/lang/method.ci:46: referenced as `abstractMethod`
	test/lang/method.ci:15: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:19'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:19: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: virtualMethod
.references:
	test/lang/method.ci:81: referenced as `virtualMethod`
	test/lang/method.ci:71: referenced as `virtualMethod`
	test/lang/method.ci:59: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@0478d8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@0478d8> - <@0478ff>)
	test/lang/method.ci:26: (38 bytes: <@0478d8> - <@0478fe>): trace(void("virtualMethod", x));
	<virtualMethod @0478d8>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<virtualMethod+5 @0478dd>    : 1c 1a 00 00 00             load.c32 26
	<virtualMethod+10 @0478e2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @0478e7>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @0478ec>   : 1f 0b 71 03 00             load.ref <@03710b> ;"virtualMethod"
	<virtualMethod+25 @0478f1>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<virtualMethod+30 @0478f6>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @0478fa>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @0478fe>   : 03                         ret
.references:
	test/lang/method.ci:80: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@047900>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:30'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@047900> - <@047927>)
	test/lang/method.ci:31: (38 bytes: <@047900> - <@047926>): trace(void("forwardMethod", x));
	<forwardMethod @047900>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<forwardMethod+5 @047905>    : 1c 1f 00 00 00             load.c32 31
	<forwardMethod+10 @04790a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @04790f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @047914>   : 1f df 70 03 00             load.ref <@0370df> ;"forwardMethod"
	<forwardMethod+25 @047919>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<forwardMethod+30 @04791e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @047922>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @047926>   : 03                         ret
.references:
	test/lang/method.ci:30: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@047928>
.name: 'globalFunction'
.file: 'test/lang/method.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@047928> - <@04794f>)
	test/lang/method.ci:41: (38 bytes: <@047928> - <@04794e>): trace(void("globalFunction", x));
	<globalFunction @047928>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<globalFunction+5 @04792d>    : 1c 29 00 00 00             load.c32 41
	<globalFunction+10 @047932>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @047937>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @04793c>   : 1f 19 71 03 00             load.ref <@037119> ;"globalFunction"
	<globalFunction+25 @047941>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<globalFunction+30 @047946>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @04794a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @04794e>   : 03                         ret
.references:
	test/lang/method.ci:46: referenced as `globalFunction`
	test/lang/method.ci:40: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:44'
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.references:
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:80: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:76: referenced as `recordMethodTest`
	test/lang/method.ci:75: referenced as `recordMethodTest`
	test/lang/method.ci:59: referenced as `recordMethodTest`
	test/lang/method.ci:58: referenced as `recordMethodTest`
	test/lang/method.ci:44: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@047950>
.name: 'staticMethod'
.file: 'test/lang/method.ci:62'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@047950> - <@047992>)
	test/lang/method.ci:63: (35 bytes: <@047950> - <@047973>): debug("extension.staticMethod");
	<staticMethod @047950>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<staticMethod+5 @047955>    : 1c 3f 00 00 00             load.c32 63
	<staticMethod+10 @04795a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @04795f>   : 19                         load.z32
	<staticMethod+16 @047960>   : 1f 39 71 03 00             load.ref <@037139> ;"extension.staticMethod"
	<staticMethod+21 @047965>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<staticMethod+26 @04796a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @04796f>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:64: (30 bytes: <@047973> - <@047991>): if (bool((this) != null))
	<staticMethod+35 @047973>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @047977>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @04797c>   : 57                         ceq.i32
	<staticMethod+45 @04797d>   : 05 14 00 00                jnz <staticMethod+65 @047991>
	test/lang/method.ci:65: (16 bytes: <@047981> - <@047991>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @047981>   : 12 02                      dup.x4 sp(2)
	<staticMethod+51 @047983>   : 10 05                      dup.x1 sp(5)
	<staticMethod+53 @047985>   : 13 04                      set.x1 sp(4)
	<staticMethod+55 @047987>   : 1f a8 78 04 00             load.ref <@0478a8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @04798c>   : 02                         call
	<staticMethod+61 @04798d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @047991>   : 03                         ret
.references:
	test/lang/method.ci:75: referenced as `staticMethod`
	test/lang/method.ci:62: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@047998>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:68'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@047998> - <@0479d7>)
	test/lang/method.ci:69: (35 bytes: <@047998> - <@0479bb>): debug("extension.virtualMethod");
	<virtualMethod @047998>      : 1f a8 70 03 00             load.ref <@0370a8> ;"test/lang/method.ci"
	<virtualMethod+5 @04799d>    : 1c 45 00 00 00             load.c32 69
	<virtualMethod+10 @0479a2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @0479a7>   : 19                         load.z32
	<virtualMethod+16 @0479a8>   : 1f 50 71 03 00             load.ref <@037150> ;"extension.virtualMethod"
	<virtualMethod+21 @0479ad>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<virtualMethod+26 @0479b2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @0479b7>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:70: (27 bytes: <@0479bb> - <@0479d6>): if (bool((this) != null))
	<virtualMethod+35 @0479bb>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @0479bf>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @0479c4>   : 57                         ceq.i32
	<virtualMethod+45 @0479c5>   : 05 11 00 00                jnz <virtualMethod+62 @0479d6>
	test/lang/method.ci:71: (13 bytes: <@0479c9> - <@0479d6>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @0479c9>   : 12 02                      dup.x4 sp(2)
	<virtualMethod+51 @0479cb>   : 10 05                      dup.x1 sp(5)
	<virtualMethod+53 @0479cd>   : 13 04                      set.x1 sp(4)
	<virtualMethod+55 @0479cf>   : 10 08                      dup.x1 sp(8)
	<virtualMethod+57 @0479d1>   : 02                         call
	<virtualMethod+58 @0479d2>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @0479d6>   : 03                         ret
.references:
	test/lang/method.ci:76: referenced as `virtualMethod`
	test/lang/method.ci:68: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@038678>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.references:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@038898>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.references:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@038ab8>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.references:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.references:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.references:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@038c50>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.references:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.references:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1356>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.references:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1360>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.references:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1364>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.references:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1368>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.references:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1372>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.references:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@039080>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@039438>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0397f0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@039ba8>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@039f60>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03a318>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.references:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.references:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1376>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.references:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.references:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.references:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.references:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.references:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.references:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.references:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.references:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.references:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.references:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.references:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.references:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.references:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.references:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.references:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.references:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.references:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.references:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.references:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.references:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.references:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.references:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.references:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.references:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.references:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.references:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.references:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.references:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.references:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.references:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1496>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.references:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1500>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.references:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.references:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.references:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.references:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.references:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.references:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.references:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.references:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.references:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.references:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.references:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.references:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.references:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.references:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.references:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.references:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.references:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.references:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.references:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.references:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.references:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1584>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.references:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1588>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.references:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.references:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.references:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.references:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.references:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.references:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.references:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.references:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.references:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.references:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.references:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.references:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.references:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.references:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.references:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.references:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.references:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.references:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.references:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.references:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.references:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1672>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.references:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1676>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.references:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.references:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.references:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.references:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.references:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.references:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.references:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.references:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.references:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.references:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.references:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.references:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.references:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.references:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.references:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.references:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.references:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.references:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.references:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.references:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.references:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1760>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.references:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1764>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.references:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.references:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.references:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.references:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.references:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.references:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.references:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.references:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.references:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.references:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.references:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.references:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.references:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.references:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.references:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.references:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.references:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.references:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.references:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.references:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.references:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1848>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.references:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1852>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.references:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.references:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.references:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.references:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.references:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.references:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.references:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.references:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.references:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.references:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.references:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.references:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.references:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.references:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.references:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.references:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.references:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.references:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.references:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.references:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.references:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1936>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.references:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1940>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.references:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.references:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.references:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.references:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.references:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.references:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.references:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.references:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.references:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.references:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.references:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.references:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.references:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.references:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.references:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.references:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.references:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.references:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.references:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.references:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.references:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2024>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.references:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2028>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.references:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.references:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.references:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.references:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2048>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.references:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2056>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.references:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.references:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.references:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.references:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.references:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.references:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.references:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.references:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.references:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.references:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.references:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.references:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.references:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.references:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.references:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.references:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2172>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.references:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2176>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.references:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.references:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.references:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.references:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2196>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.references:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2204>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.references:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.references:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.references:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.references:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.references:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.references:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.references:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.references:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.references:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.references:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.references:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.references:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.references:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.references:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.references:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.references:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2320>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.references:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2324>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.references:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.references:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.references:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.references:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.references:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.references:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.references:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.references:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.references:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.references:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.references:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.references:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.references:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.references:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.references:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2384>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.references:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2388>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.references:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.references:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.references:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.references:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2408>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.references:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2416>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.references:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.references:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.references:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.references:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.references:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.references:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.references:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.references:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.references:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.references:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2484>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.references:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2488>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.references:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.references:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.references:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.references:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2504>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.references:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2508>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.references:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.references:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.references:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2520>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.references:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2524>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.references:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2532>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.references:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2540>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.references:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.references:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.references:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.references:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.references:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.references:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.references:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.references:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.references:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.references:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.references:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.references:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.references:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.references:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.references:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_0f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathSmooth_0f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_0f`
}
testMathSmooth_0F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathSmooth_0F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(0.000000)
.references:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_0F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:37'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:37: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:38'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.references:
	test/stdc/test.math.ci:38: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.min()
.references:
	test/stdc/test.math.ci:40: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:41'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:41: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:42'
.value: Math.max()
.references:
	test/stdc/test.math.ci:42: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:43'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.references:
	test/stdc/test.math.ci:43: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum()
.references:
	test/stdc/test.math.ci:45: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(1)
.references:
	test/stdc/test.math.ci:46: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:47'
.value: Math.sum(void(1, 2))
.references:
	test/stdc/test.math.ci:47: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:48'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.references:
	test/stdc/test.math.ci:48: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:50'
.value: 10
.references:
	test/stdc/test.math.ci:57: referenced as `testMathEval_x`
	test/stdc/test.math.ci:56: referenced as `testMathEval_x`
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(testMathEval_x)
.references:
	test/stdc/test.math.ci:51: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(testMathEval_x, 1.000000))
.references:
	test/stdc/test.math.ci:52: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:53: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:54: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:55: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:56'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:56: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:57'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.references:
	test/stdc/test.math.ci:57: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.sin(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:59: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.cos(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:60: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.tan(float64(Math.pi / (4)))
.references:
	test/stdc/test.math.ci:61: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:62'
.value: Math.sinh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:62: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.cosh(float64(Math.pi / (2)))
.references:
	test/stdc/test.math.ci:63: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2940>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:65'
.value: Math.asin(0.200000)
.references:
	test/stdc/test.math.ci:65: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:66'
.value: Math.acos(0.200000)
.references:
	test/stdc/test.math.ci:66: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2952>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:69'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:69: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2956>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:70'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.references:
	test/stdc/test.math.ci:70: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(10.000000, 10.000000))
.references:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2972>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:73'
.value: Math.absMod(void(0.000000, 10.000000))
.references:
	test/stdc/test.math.ci:73: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2980>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.references:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2988>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(19.000000, 10.000000))
.references:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2996>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(9.000000, 10.000000))
.references:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3004>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:78'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.references:
	test/stdc/test.math.ci:78: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3012>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.references:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3020>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(18.000000, 10.000000))
.references:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3028>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(8.000000, 10.000000))
.references:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3036>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:83'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.references:
	test/stdc/test.math.ci:83: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3044>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.references:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3048>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(10.000000, 10.000000))
.references:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3052>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:87'
.value: Math.absMod(void(0.000000, 10.000000))
.references:
	test/stdc/test.math.ci:87: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3056>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.references:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3060>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(19.000000, 10.000000))
.references:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3064>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(9.000000, 10.000000))
.references:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3068>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:92'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.references:
	test/stdc/test.math.ci:92: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3072>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.references:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3076>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(18.000000, 10.000000))
.references:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3080>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(8.000000, 10.000000))
.references:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3084>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:97'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.references:
	test/stdc/test.math.ci:97: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3088>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:98'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.references:
	test/stdc/test.math.ci:98: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 10927
.offset: <@0479d7>
.name: '.main'
.print: '.main'
.field typename: typename (size: 136, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000a0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000130>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001c0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000250>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@0002e0>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000370>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000400>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000490>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@000520>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0005b0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000640>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0006d0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000760>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0007f0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000880>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000910>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@0009a8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000eb8>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000f48>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@0052b0>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0061f0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0069f0>, cast: static const inline)
.field System: typename (size: 0, offs: <@007538>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00e088>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@046638>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@00eca8>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@016a78>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@046e88>, cast: static const function)
.field Complex: function (size: 7, offs: <@046e90>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@046e98>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@046f18>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@046f38>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@046fa0>, cast: static const function)
.field indexOf: function (size: 50, offs: <@046fc8>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@047000>, cast: static const function)
.field startsWith: function (size: 73, offs: <@047038>, cast: static const function)
.field endsWith: function (size: 126, offs: <@047088>, cast: static const function)
.field compare: function (size: 63, offs: <@047108>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@047190>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@0471b8>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@01e3c8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@0471c8>, cast: static const function)
.field append: function (size: 657, offs: <@047230>, cast: static const function)
.field append: function (size: 23, offs: <@0474c8>, cast: static const function)
.field append: function (size: 49, offs: <@0474e0>, cast: static const function)
.field append: function (size: 25, offs: <@047528>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@020120>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@047548>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@020950>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@047550>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@023660>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@047560>, cast: static const function)
.field mat4f: function (size: 21, offs: <@047598>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@0475b0>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@02a9c0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@02aad0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@047758>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@047760>, cast: static const function)
.field funAdd: function (size: 8, offs: <@047768>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@047770>, cast: static const function)
.field fib: function (size: 54, offs: <@047778>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@02fe90>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@02ffa0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@0477b0>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@0477b8>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@0477d0>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@0477e0>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@047828>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@047838>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@047840>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@047848>, cast: static const function)
.field nthArray: function (size: 12, offs: <@047858>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@047868>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@0367a0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@037168>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@047928>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field staticMethod: function (size: 66, offs: <@047950>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@047998>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@038678>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@038898>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@038ab8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@038c50>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1356>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1360>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1364>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1368>, cast: variable(val))
.field blue: color (size: 4, offs: <+1372>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@039080>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@039438>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0397f0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@039ba8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@039f60>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@03a318>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1376>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1496>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1500>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1584>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1588>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1672>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1676>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1760>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1764>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1848>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1852>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1936>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1940>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2024>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2028>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2048>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2056>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2172>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2176>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2196>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2204>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2320>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2324>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2384>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2388>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2408>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2416>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2484>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2488>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2504>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2508>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2520>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2524>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2532>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2540>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathSmooth_0f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathSmooth_0F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2940>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2952>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2956>, cast: variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <+2972>, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <+2980>, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <+2988>, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <+2996>, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <+3004>, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <+3012>, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <+3020>, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <+3028>, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <+3036>, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <+3044>, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <+3048>, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <+3052>, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <+3056>, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <+3060>, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <+3064>, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <+3068>, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <+3072>, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <+3076>, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <+3080>, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <+3084>, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <+3088>, cast: variable(f32))
.field .main: function (size: 10927, offs: <@0479d7>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static const sign(x: float32): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const sign(x: float64): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static deg2rad(x: float64): float64 := float64(float64(float64(x * pi) / (180)));
			static rad2deg(x: float64): float64 := float64(float64(float64(x * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				x: float64;
				y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				.anonymous: .anonymous;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				data: float32[16];
				.anonymous: .anonymous;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_0f: float64 := Math.smooth(0.000000);
		testMathSmooth_0F: float64 := Math.smooth(0.000000);
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (10927 bytes: <@0479d7> - <@04a486>)
	lib/std/string.ci:130: (14 bytes: <@0479d7> - <@0479e5>): static const whiteSpace: char[] := " \t\n\r"
	<.main @0479d7>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @0479dc>    : 1f 98 b4 01 00             load.ref <@01b498> ;" \t\n\r"
	<.main+10 @0479e1>   : 2d 20 72 04                store.m64 <@047220> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes: <@0479e5> - <@0479f3>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @0479e5>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @0479ea>   : 1f a9 b4 01 00             load.ref <@01b4a9> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @0479ef>   : 2d 28 72 04                store.m64 <@047228> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes: <@0479f3> - <@047a0d>): static const format: FormatFlags := {...}
	<.main+28 @0479f3>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @0479f8>   : 2e 18 75 04                store.m32 <@047518> ;append.format
	:: (7 bytes: <@0479fc> - <@047a03>): void(format.padChr := (0))
	<.main+37 @0479fc>   : 19                         load.z32
	<.main+38 @0479fd>   : 1f 1c 75 04 00             load.ref <@04751c> ;append.format+4
	<.main+43 @047a02>   : 25                         store.i8
	:: (5 bytes: <@047a03> - <@047a08>): void(format.padLen := 0)
	<.main+44 @047a03>   : 19                         load.z32
	<.main+45 @047a04>   : 2e 20 75 04                store.m32 <@047520> ;append.format+8
	:: (5 bytes: <@047a08> - <@047a0d>): void(format.precision := 0)
	<.main+49 @047a08>   : 19                         load.z32
	<.main+50 @047a09>   : 2e 24 75 04                store.m32 <@047524> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@047a0d> - <@047a1a>): static value: int64 := 42
	<.main+54 @047a0d>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @047a16>   : 2d 58 77 04                store.m64 <@047758> ;value
	test/lang/member.ci:35: (5 bytes: <@047a1a> - <@047a1f>): static global: int32
	<.main+67 @047a1a>   : 19                         load.z32
	<.main+68 @047a1b>   : 2e 78 78 04                store.m32 <@047878> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@047a1f> - <@047a28>): static globalInit: int32 := 1
	<.main+72 @047a1f>   : 1c 01 00 00 00             load.c32 1
	<.main+77 @047a24>   : 2e 80 78 04                store.m32 <@047880> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@047a28> - <@047a31>): static const globalConstant: int32 := 2
	<.main+81 @047a28>   : 1c 02 00 00 00             load.c32 2
	<.main+86 @047a2d>   : 2e 88 78 04                store.m32 <@047888> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@047a31> - <@047a43>): static globalRecInit: Inner := {...}
	<.main+90 @047a31>   : 1c 04 00 00 00             load.c32 4
	<.main+95 @047a36>   : 2e 98 78 04                store.m32 <@047898> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@047a3a> - <@047a43>): void(globalRecInit.constant := 5);
	<.main+99 @047a3a>   : 1c 05 00 00 00             load.c32 5
	<.main+104 @047a3f>  : 2e 9c 78 04                store.m32 <@04789c> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@047a43> - <@047a55>): static const globalConstantRec: Inner := {...}
	<.main+108 @047a43>  : 1c 06 00 00 00             load.c32 6
	<.main+113 @047a48>  : 2e a0 78 04                store.m32 <@0478a0> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@047a4c> - <@047a55>): void(globalConstantRec.constant := 7);
	<.main+117 @047a4c>  : 1c 07 00 00 00             load.c32 7
	<.main+122 @047a51>  : 2e a4 78 04                store.m32 <@0478a4> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:11: (9 bytes: <@047a55> - <@047a5e>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+126 @047a55>  : 1f 00 79 04 00             load.ref <@047900> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+131 @047a5a>  : 2e d0 78 04                store.m32 <@0478d0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/emit.ci:3: (1 byte: <@047a5e> - <@047a5f>): emitldz32: int32 := emit(load.z32)
	<.main+135 @047a5e>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@047a5f> - <@047a60>): emitldz64: int64 := emit(load.z64)
	<.main+136 @047a5f>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@047a60> - <@047a65>): emitA: int32 := 42
	<.main+137 @047a60>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@047a65> - <@047a6a>): emitB: int32 := 96
	<.main+142 @047a65>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@047a6a> - <@047a6f>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @047a6a>  : 10 01                      dup.x1 sp(1)
	<.main+149 @047a6c>  : 10 01                      dup.x1 sp(1)
	<.main+151 @047a6e>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@047a6f> - <@047a7a>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @047a6f>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @047a74>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @047a79>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@047a7a> - <@047a7f>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @047a7a>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@047a7f> - <@047a85>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @047a7f>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @047a84>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@047a85> - <@047a8f>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @047a85>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @047a8e>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@047a8f> - <@047a98>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @047a8f>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@047a98> - <@047aa2>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @047a98>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @047a9d>  : 1f 94 55 02 00             load.ref <@025594> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@047aa2> - <@047aa7>): i3: int32 := 3
	<.main+203 @047aa2>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@047aa7> - <@047aac>): i6: int32 := 6
	<.main+208 @047aa7>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@047aac> - <@047ab1>): i2: int32 := 2
	<.main+213 @047aac>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@047ab1> - <@047ab6>): i8: int32 := 8
	<.main+218 @047ab1>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@047ab6> - <@047ab7>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @047ab6>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@047ab7> - <@047ab8>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @047ab7>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@047ab8> - <@047ab9>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @047ab8>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@047ab9> - <@047abe>): lastVal: int32 := last(void(3, 6))
	<.main+226 @047ab9>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@047abe> - <@047ac0>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @047abe>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@047ac0> - <@047aca>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @047ac0>  : 10 07                      dup.x1 sp(7)
	<.main+235 @047ac2>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @047ac6>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@047aca> - <@047ad3>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @047aca>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @047acf>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@047ad3> - <@047ad8>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @047ad3>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @047ad5>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @047ad7>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@047ad8> - <@047ae9>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @047ad8>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @047ada>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @047ade>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @047ae0>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @047ae4>  : 51                         add.i32
	<.main+270 @047ae5>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@047ae9> - <@047b01>): any2Val: int32 := any(void(3, 6))
	<.main+274 @047ae9>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @047aee>  : 10 00                      dup.x1 sp(0)
	<.main+281 @047af0>  : 06 0a 00 00                jz <.main+291 @047afa>
	<.main+285 @047af4>  : 10 00                      dup.x1 sp(0)
	<.main+287 @047af6>  : 04 09 00 00                jmp <.main+296 @047aff>
	<.main+291 @047afa>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @047aff>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@047b01> - <@047b13>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @047b01>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @047b03>  : 10 00                      dup.x1 sp(0)
	<.main+302 @047b05>  : 06 0a 00 00                jz <.main+312 @047b0f>
	<.main+306 @047b09>  : 10 00                      dup.x1 sp(0)
	<.main+308 @047b0b>  : 04 06 00 00                jmp <.main+314 @047b11>
	<.main+312 @047b0f>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @047b11>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@047b13> - <@047b31>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @047b13>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @047b15>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @047b19>  : 10 00                      dup.x1 sp(0)
	<.main+324 @047b1b>  : 06 0a 00 00                jz <.main+334 @047b25>
	<.main+328 @047b1f>  : 10 00                      dup.x1 sp(0)
	<.main+330 @047b21>  : 04 0a 00 00                jmp <.main+340 @047b2b>
	<.main+334 @047b25>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @047b27>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @047b2b>  : 13 01                      set.x1 sp(1)
	<.main+342 @047b2d>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@047b31> - <@047b52>): min2Val: int32 := min(void(3, 6))
	<.main+346 @047b31>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @047b36>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @047b3b>  : 10 01                      dup.x1 sp(1)
	<.main+358 @047b3d>  : 10 01                      dup.x1 sp(1)
	<.main+360 @047b3f>  : 58                         clt.i32
	<.main+361 @047b40>  : 06 0a 00 00                jz <.main+371 @047b4a>
	<.main+365 @047b44>  : 10 01                      dup.x1 sp(1)
	<.main+367 @047b46>  : 04 06 00 00                jmp <.main+373 @047b4c>
	<.main+371 @047b4a>  : 10 00                      dup.x1 sp(0)
	<.main+373 @047b4c>  : 13 02                      set.x1 sp(2)
	<.main+375 @047b4e>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@047b52> - <@047b6d>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @047b52>  : 10 10                      dup.x1 sp(16)
	<.main+381 @047b54>  : 10 10                      dup.x1 sp(16)
	<.main+383 @047b56>  : 10 01                      dup.x1 sp(1)
	<.main+385 @047b58>  : 10 01                      dup.x1 sp(1)
	<.main+387 @047b5a>  : 58                         clt.i32
	<.main+388 @047b5b>  : 06 0a 00 00                jz <.main+398 @047b65>
	<.main+392 @047b5f>  : 10 01                      dup.x1 sp(1)
	<.main+394 @047b61>  : 04 06 00 00                jmp <.main+400 @047b67>
	<.main+398 @047b65>  : 10 00                      dup.x1 sp(0)
	<.main+400 @047b67>  : 13 02                      set.x1 sp(2)
	<.main+402 @047b69>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@047b6d> - <@047b94>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @047b6d>  : 10 11                      dup.x1 sp(17)
	<.main+408 @047b6f>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @047b73>  : 10 11                      dup.x1 sp(17)
	<.main+414 @047b75>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @047b79>  : 10 01                      dup.x1 sp(1)
	<.main+420 @047b7b>  : 10 01                      dup.x1 sp(1)
	<.main+422 @047b7d>  : 58                         clt.i32
	<.main+423 @047b7e>  : 06 0a 00 00                jz <.main+433 @047b88>
	<.main+427 @047b82>  : 10 01                      dup.x1 sp(1)
	<.main+429 @047b84>  : 04 06 00 00                jmp <.main+435 @047b8a>
	<.main+433 @047b88>  : 10 00                      dup.x1 sp(0)
	<.main+435 @047b8a>  : 13 02                      set.x1 sp(2)
	<.main+437 @047b8c>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @047b90>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@047b94> - <@047bb5>): max2Val: int32 := max(void(3, 6))
	<.main+445 @047b94>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @047b99>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @047b9e>  : 10 01                      dup.x1 sp(1)
	<.main+457 @047ba0>  : 10 01                      dup.x1 sp(1)
	<.main+459 @047ba2>  : 59                         cgt.i32
	<.main+460 @047ba3>  : 06 0a 00 00                jz <.main+470 @047bad>
	<.main+464 @047ba7>  : 10 01                      dup.x1 sp(1)
	<.main+466 @047ba9>  : 04 06 00 00                jmp <.main+472 @047baf>
	<.main+470 @047bad>  : 10 00                      dup.x1 sp(0)
	<.main+472 @047baf>  : 13 02                      set.x1 sp(2)
	<.main+474 @047bb1>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@047bb5> - <@047bd0>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @047bb5>  : 10 13                      dup.x1 sp(19)
	<.main+480 @047bb7>  : 10 13                      dup.x1 sp(19)
	<.main+482 @047bb9>  : 10 01                      dup.x1 sp(1)
	<.main+484 @047bbb>  : 10 01                      dup.x1 sp(1)
	<.main+486 @047bbd>  : 59                         cgt.i32
	<.main+487 @047bbe>  : 06 0a 00 00                jz <.main+497 @047bc8>
	<.main+491 @047bc2>  : 10 01                      dup.x1 sp(1)
	<.main+493 @047bc4>  : 04 06 00 00                jmp <.main+499 @047bca>
	<.main+497 @047bc8>  : 10 00                      dup.x1 sp(0)
	<.main+499 @047bca>  : 13 02                      set.x1 sp(2)
	<.main+501 @047bcc>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@047bd0> - <@047bf7>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @047bd0>  : 10 14                      dup.x1 sp(20)
	<.main+507 @047bd2>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @047bd6>  : 10 14                      dup.x1 sp(20)
	<.main+513 @047bd8>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @047bdc>  : 10 01                      dup.x1 sp(1)
	<.main+519 @047bde>  : 10 01                      dup.x1 sp(1)
	<.main+521 @047be0>  : 59                         cgt.i32
	<.main+522 @047be1>  : 06 0a 00 00                jz <.main+532 @047beb>
	<.main+526 @047be5>  : 10 01                      dup.x1 sp(1)
	<.main+528 @047be7>  : 04 06 00 00                jmp <.main+534 @047bed>
	<.main+532 @047beb>  : 10 00                      dup.x1 sp(0)
	<.main+534 @047bed>  : 13 02                      set.x1 sp(2)
	<.main+536 @047bef>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @047bf3>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@047bf7> - <@047c0c>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @047bf7>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @047bfc>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @047c01>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @047c06>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @047c0a>  : 51                         add.i32
	<.main+564 @047c0b>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@047c0c> - <@047c1d>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @047c0c>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @047c11>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @047c15>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @047c19>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@047c1d> - <@047c28>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @047c1d>  : 10 17                      dup.x1 sp(23)
	<.main+584 @047c1f>  : 10 17                      dup.x1 sp(23)
	<.main+586 @047c21>  : 10 17                      dup.x1 sp(23)
	<.main+588 @047c23>  : 10 17                      dup.x1 sp(23)
	<.main+590 @047c25>  : 51                         add.i32
	<.main+591 @047c26>  : 51                         add.i32
	<.main+592 @047c27>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@047c28> - <@047c33>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @047c28>  : 10 18                      dup.x1 sp(24)
	<.main+595 @047c2a>  : 10 18                      dup.x1 sp(24)
	<.main+597 @047c2c>  : 51                         add.i32
	<.main+598 @047c2d>  : 10 17                      dup.x1 sp(23)
	<.main+600 @047c2f>  : 51                         add.i32
	<.main+601 @047c30>  : 10 16                      dup.x1 sp(22)
	<.main+603 @047c32>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@047c33> - <@047c52>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @047c33>  : 10 19                      dup.x1 sp(25)
	<.main+606 @047c35>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @047c39>  : 10 19                      dup.x1 sp(25)
	<.main+612 @047c3b>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @047c3f>  : 10 19                      dup.x1 sp(25)
	<.main+618 @047c41>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @047c45>  : 10 19                      dup.x1 sp(25)
	<.main+624 @047c47>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @047c4b>  : 51                         add.i32
	<.main+629 @047c4c>  : 51                         add.i32
	<.main+630 @047c4d>  : 51                         add.i32
	<.main+631 @047c4e>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@047c52> - <@047c71>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @047c52>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @047c54>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @047c58>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @047c5a>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @047c5e>  : 51                         add.i32
	<.main+648 @047c5f>  : 10 19                      dup.x1 sp(25)
	<.main+650 @047c61>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @047c65>  : 51                         add.i32
	<.main+655 @047c66>  : 10 18                      dup.x1 sp(24)
	<.main+657 @047c68>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @047c6c>  : 51                         add.i32
	<.main+662 @047c6d>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@047c71> - <@047caf>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @047c71>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @047c76>  : 10 00                      dup.x1 sp(0)
	<.main+673 @047c78>  : 06 0a 00 00                jz <.main+683 @047c82>
	<.main+677 @047c7c>  : 10 00                      dup.x1 sp(0)
	<.main+679 @047c7e>  : 04 2f 00 00                jmp <.main+726 @047cad>
	<.main+683 @047c82>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @047c87>  : 10 00                      dup.x1 sp(0)
	<.main+690 @047c89>  : 06 0a 00 00                jz <.main+700 @047c93>
	<.main+694 @047c8d>  : 10 00                      dup.x1 sp(0)
	<.main+696 @047c8f>  : 04 1c 00 00                jmp <.main+724 @047cab>
	<.main+700 @047c93>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @047c98>  : 10 00                      dup.x1 sp(0)
	<.main+707 @047c9a>  : 06 0a 00 00                jz <.main+717 @047ca4>
	<.main+711 @047c9e>  : 10 00                      dup.x1 sp(0)
	<.main+713 @047ca0>  : 04 09 00 00                jmp <.main+722 @047ca9>
	<.main+717 @047ca4>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @047ca9>  : 13 01                      set.x1 sp(1)
	<.main+724 @047cab>  : 13 01                      set.x1 sp(1)
	<.main+726 @047cad>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@047caf> - <@047ced>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @047caf>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @047cb4>  : 10 00                      dup.x1 sp(0)
	<.main+735 @047cb6>  : 06 0a 00 00                jz <.main+745 @047cc0>
	<.main+739 @047cba>  : 10 00                      dup.x1 sp(0)
	<.main+741 @047cbc>  : 04 09 00 00                jmp <.main+750 @047cc5>
	<.main+745 @047cc0>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @047cc5>  : 13 01                      set.x1 sp(1)
	<.main+752 @047cc7>  : 10 00                      dup.x1 sp(0)
	<.main+754 @047cc9>  : 06 0a 00 00                jz <.main+764 @047cd3>
	<.main+758 @047ccd>  : 10 00                      dup.x1 sp(0)
	<.main+760 @047ccf>  : 04 09 00 00                jmp <.main+769 @047cd8>
	<.main+764 @047cd3>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @047cd8>  : 13 01                      set.x1 sp(1)
	<.main+771 @047cda>  : 10 00                      dup.x1 sp(0)
	<.main+773 @047cdc>  : 06 0a 00 00                jz <.main+783 @047ce6>
	<.main+777 @047ce0>  : 10 00                      dup.x1 sp(0)
	<.main+779 @047ce2>  : 04 09 00 00                jmp <.main+788 @047ceb>
	<.main+783 @047ce6>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @047ceb>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@047ced> - <@047d1f>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @047ced>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @047cef>  : 10 00                      dup.x1 sp(0)
	<.main+794 @047cf1>  : 06 0a 00 00                jz <.main+804 @047cfb>
	<.main+798 @047cf5>  : 10 00                      dup.x1 sp(0)
	<.main+800 @047cf7>  : 04 26 00 00                jmp <.main+838 @047d1d>
	<.main+804 @047cfb>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @047cfd>  : 10 00                      dup.x1 sp(0)
	<.main+808 @047cff>  : 06 0a 00 00                jz <.main+818 @047d09>
	<.main+812 @047d03>  : 10 00                      dup.x1 sp(0)
	<.main+814 @047d05>  : 04 16 00 00                jmp <.main+836 @047d1b>
	<.main+818 @047d09>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @047d0b>  : 10 00                      dup.x1 sp(0)
	<.main+822 @047d0d>  : 06 0a 00 00                jz <.main+832 @047d17>
	<.main+826 @047d11>  : 10 00                      dup.x1 sp(0)
	<.main+828 @047d13>  : 04 06 00 00                jmp <.main+834 @047d19>
	<.main+832 @047d17>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @047d19>  : 13 01                      set.x1 sp(1)
	<.main+836 @047d1b>  : 13 01                      set.x1 sp(1)
	<.main+838 @047d1d>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@047d1f> - <@047d51>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @047d1f>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @047d21>  : 10 00                      dup.x1 sp(0)
	<.main+844 @047d23>  : 06 0a 00 00                jz <.main+854 @047d2d>
	<.main+848 @047d27>  : 10 00                      dup.x1 sp(0)
	<.main+850 @047d29>  : 04 06 00 00                jmp <.main+856 @047d2f>
	<.main+854 @047d2d>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @047d2f>  : 13 01                      set.x1 sp(1)
	<.main+858 @047d31>  : 10 00                      dup.x1 sp(0)
	<.main+860 @047d33>  : 06 0a 00 00                jz <.main+870 @047d3d>
	<.main+864 @047d37>  : 10 00                      dup.x1 sp(0)
	<.main+866 @047d39>  : 04 06 00 00                jmp <.main+872 @047d3f>
	<.main+870 @047d3d>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @047d3f>  : 13 01                      set.x1 sp(1)
	<.main+874 @047d41>  : 10 00                      dup.x1 sp(0)
	<.main+876 @047d43>  : 06 0a 00 00                jz <.main+886 @047d4d>
	<.main+880 @047d47>  : 10 00                      dup.x1 sp(0)
	<.main+882 @047d49>  : 04 06 00 00                jmp <.main+888 @047d4f>
	<.main+886 @047d4d>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @047d4f>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@047d51> - <@047d97>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @047d51>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @047d53>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @047d57>  : 10 00                      dup.x1 sp(0)
	<.main+898 @047d59>  : 06 0a 00 00                jz <.main+908 @047d63>
	<.main+902 @047d5d>  : 10 00                      dup.x1 sp(0)
	<.main+904 @047d5f>  : 04 32 00 00                jmp <.main+954 @047d91>
	<.main+908 @047d63>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @047d65>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @047d69>  : 10 00                      dup.x1 sp(0)
	<.main+916 @047d6b>  : 06 0a 00 00                jz <.main+926 @047d75>
	<.main+920 @047d6f>  : 10 00                      dup.x1 sp(0)
	<.main+922 @047d71>  : 04 1e 00 00                jmp <.main+952 @047d8f>
	<.main+926 @047d75>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @047d77>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @047d7b>  : 10 00                      dup.x1 sp(0)
	<.main+934 @047d7d>  : 06 0a 00 00                jz <.main+944 @047d87>
	<.main+938 @047d81>  : 10 00                      dup.x1 sp(0)
	<.main+940 @047d83>  : 04 0a 00 00                jmp <.main+950 @047d8d>
	<.main+944 @047d87>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @047d89>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @047d8d>  : 13 01                      set.x1 sp(1)
	<.main+952 @047d8f>  : 13 01                      set.x1 sp(1)
	<.main+954 @047d91>  : 13 01                      set.x1 sp(1)
	<.main+956 @047d93>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@047d97> - <@047ddd>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @047d97>  : 10 20                      dup.x1 sp(32)
	<.main+962 @047d99>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @047d9d>  : 10 00                      dup.x1 sp(0)
	<.main+968 @047d9f>  : 06 0a 00 00                jz <.main+978 @047da9>
	<.main+972 @047da3>  : 10 00                      dup.x1 sp(0)
	<.main+974 @047da5>  : 04 0a 00 00                jmp <.main+984 @047daf>
	<.main+978 @047da9>  : 10 20                      dup.x1 sp(32)
	<.main+980 @047dab>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @047daf>  : 13 01                      set.x1 sp(1)
	<.main+986 @047db1>  : 10 00                      dup.x1 sp(0)
	<.main+988 @047db3>  : 06 0a 00 00                jz <.main+998 @047dbd>
	<.main+992 @047db7>  : 10 00                      dup.x1 sp(0)
	<.main+994 @047db9>  : 04 0a 00 00                jmp <.main+1004 @047dc3>
	<.main+998 @047dbd>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @047dbf> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @047dc3> : 13 01                      set.x1 sp(1)
	<.main+1006 @047dc5> : 10 00                      dup.x1 sp(0)
	<.main+1008 @047dc7> : 06 0a 00 00                jz <.main+1018 @047dd1>
	<.main+1012 @047dcb> : 10 00                      dup.x1 sp(0)
	<.main+1014 @047dcd> : 04 0a 00 00                jmp <.main+1024 @047dd7>
	<.main+1018 @047dd1> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @047dd3> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @047dd7> : 13 01                      set.x1 sp(1)
	<.main+1026 @047dd9> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@047ddd> - <@047e36>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @047ddd> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @047de2> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @047de7> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @047dec> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @047df1> : 10 01                      dup.x1 sp(1)
	<.main+1052 @047df3> : 10 01                      dup.x1 sp(1)
	<.main+1054 @047df5> : 58                         clt.i32
	<.main+1055 @047df6> : 06 0a 00 00                jz <.main+1065 @047e00>
	<.main+1059 @047dfa> : 10 01                      dup.x1 sp(1)
	<.main+1061 @047dfc> : 04 06 00 00                jmp <.main+1067 @047e02>
	<.main+1065 @047e00> : 10 00                      dup.x1 sp(0)
	<.main+1067 @047e02> : 13 02                      set.x1 sp(2)
	<.main+1069 @047e04> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @047e08> : 10 01                      dup.x1 sp(1)
	<.main+1075 @047e0a> : 10 01                      dup.x1 sp(1)
	<.main+1077 @047e0c> : 58                         clt.i32
	<.main+1078 @047e0d> : 06 0a 00 00                jz <.main+1088 @047e17>
	<.main+1082 @047e11> : 10 01                      dup.x1 sp(1)
	<.main+1084 @047e13> : 04 06 00 00                jmp <.main+1090 @047e19>
	<.main+1088 @047e17> : 10 00                      dup.x1 sp(0)
	<.main+1090 @047e19> : 13 02                      set.x1 sp(2)
	<.main+1092 @047e1b> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @047e1f> : 10 01                      dup.x1 sp(1)
	<.main+1098 @047e21> : 10 01                      dup.x1 sp(1)
	<.main+1100 @047e23> : 58                         clt.i32
	<.main+1101 @047e24> : 06 0a 00 00                jz <.main+1111 @047e2e>
	<.main+1105 @047e28> : 10 01                      dup.x1 sp(1)
	<.main+1107 @047e2a> : 04 06 00 00                jmp <.main+1113 @047e30>
	<.main+1111 @047e2e> : 10 00                      dup.x1 sp(0)
	<.main+1113 @047e30> : 13 02                      set.x1 sp(2)
	<.main+1115 @047e32> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@047e36> - <@047e8f>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @047e36> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @047e3b> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @047e40> : 10 01                      dup.x1 sp(1)
	<.main+1131 @047e42> : 10 01                      dup.x1 sp(1)
	<.main+1133 @047e44> : 58                         clt.i32
	<.main+1134 @047e45> : 06 0a 00 00                jz <.main+1144 @047e4f>
	<.main+1138 @047e49> : 10 01                      dup.x1 sp(1)
	<.main+1140 @047e4b> : 04 06 00 00                jmp <.main+1146 @047e51>
	<.main+1144 @047e4f> : 10 00                      dup.x1 sp(0)
	<.main+1146 @047e51> : 13 02                      set.x1 sp(2)
	<.main+1148 @047e53> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @047e57> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @047e5c> : 10 01                      dup.x1 sp(1)
	<.main+1159 @047e5e> : 10 01                      dup.x1 sp(1)
	<.main+1161 @047e60> : 58                         clt.i32
	<.main+1162 @047e61> : 06 0a 00 00                jz <.main+1172 @047e6b>
	<.main+1166 @047e65> : 10 01                      dup.x1 sp(1)
	<.main+1168 @047e67> : 04 06 00 00                jmp <.main+1174 @047e6d>
	<.main+1172 @047e6b> : 10 00                      dup.x1 sp(0)
	<.main+1174 @047e6d> : 13 02                      set.x1 sp(2)
	<.main+1176 @047e6f> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @047e73> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @047e78> : 10 01                      dup.x1 sp(1)
	<.main+1187 @047e7a> : 10 01                      dup.x1 sp(1)
	<.main+1189 @047e7c> : 58                         clt.i32
	<.main+1190 @047e7d> : 06 0a 00 00                jz <.main+1200 @047e87>
	<.main+1194 @047e81> : 10 01                      dup.x1 sp(1)
	<.main+1196 @047e83> : 04 06 00 00                jmp <.main+1202 @047e89>
	<.main+1200 @047e87> : 10 00                      dup.x1 sp(0)
	<.main+1202 @047e89> : 13 02                      set.x1 sp(2)
	<.main+1204 @047e8b> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@047e8f> - <@047edc>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @047e8f> : 10 23                      dup.x1 sp(35)
	<.main+1210 @047e91> : 10 23                      dup.x1 sp(35)
	<.main+1212 @047e93> : 10 23                      dup.x1 sp(35)
	<.main+1214 @047e95> : 10 23                      dup.x1 sp(35)
	<.main+1216 @047e97> : 10 01                      dup.x1 sp(1)
	<.main+1218 @047e99> : 10 01                      dup.x1 sp(1)
	<.main+1220 @047e9b> : 58                         clt.i32
	<.main+1221 @047e9c> : 06 0a 00 00                jz <.main+1231 @047ea6>
	<.main+1225 @047ea0> : 10 01                      dup.x1 sp(1)
	<.main+1227 @047ea2> : 04 06 00 00                jmp <.main+1233 @047ea8>
	<.main+1231 @047ea6> : 10 00                      dup.x1 sp(0)
	<.main+1233 @047ea8> : 13 02                      set.x1 sp(2)
	<.main+1235 @047eaa> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @047eae> : 10 01                      dup.x1 sp(1)
	<.main+1241 @047eb0> : 10 01                      dup.x1 sp(1)
	<.main+1243 @047eb2> : 58                         clt.i32
	<.main+1244 @047eb3> : 06 0a 00 00                jz <.main+1254 @047ebd>
	<.main+1248 @047eb7> : 10 01                      dup.x1 sp(1)
	<.main+1250 @047eb9> : 04 06 00 00                jmp <.main+1256 @047ebf>
	<.main+1254 @047ebd> : 10 00                      dup.x1 sp(0)
	<.main+1256 @047ebf> : 13 02                      set.x1 sp(2)
	<.main+1258 @047ec1> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @047ec5> : 10 01                      dup.x1 sp(1)
	<.main+1264 @047ec7> : 10 01                      dup.x1 sp(1)
	<.main+1266 @047ec9> : 58                         clt.i32
	<.main+1267 @047eca> : 06 0a 00 00                jz <.main+1277 @047ed4>
	<.main+1271 @047ece> : 10 01                      dup.x1 sp(1)
	<.main+1273 @047ed0> : 04 06 00 00                jmp <.main+1279 @047ed6>
	<.main+1277 @047ed4> : 10 00                      dup.x1 sp(0)
	<.main+1279 @047ed6> : 13 02                      set.x1 sp(2)
	<.main+1281 @047ed8> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@047edc> - <@047f29>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @047edc> : 10 24                      dup.x1 sp(36)
	<.main+1287 @047ede> : 10 24                      dup.x1 sp(36)
	<.main+1289 @047ee0> : 10 01                      dup.x1 sp(1)
	<.main+1291 @047ee2> : 10 01                      dup.x1 sp(1)
	<.main+1293 @047ee4> : 58                         clt.i32
	<.main+1294 @047ee5> : 06 0a 00 00                jz <.main+1304 @047eef>
	<.main+1298 @047ee9> : 10 01                      dup.x1 sp(1)
	<.main+1300 @047eeb> : 04 06 00 00                jmp <.main+1306 @047ef1>
	<.main+1304 @047eef> : 10 00                      dup.x1 sp(0)
	<.main+1306 @047ef1> : 13 02                      set.x1 sp(2)
	<.main+1308 @047ef3> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @047ef7> : 10 23                      dup.x1 sp(35)
	<.main+1314 @047ef9> : 10 01                      dup.x1 sp(1)
	<.main+1316 @047efb> : 10 01                      dup.x1 sp(1)
	<.main+1318 @047efd> : 58                         clt.i32
	<.main+1319 @047efe> : 06 0a 00 00                jz <.main+1329 @047f08>
	<.main+1323 @047f02> : 10 01                      dup.x1 sp(1)
	<.main+1325 @047f04> : 04 06 00 00                jmp <.main+1331 @047f0a>
	<.main+1329 @047f08> : 10 00                      dup.x1 sp(0)
	<.main+1331 @047f0a> : 13 02                      set.x1 sp(2)
	<.main+1333 @047f0c> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @047f10> : 10 22                      dup.x1 sp(34)
	<.main+1339 @047f12> : 10 01                      dup.x1 sp(1)
	<.main+1341 @047f14> : 10 01                      dup.x1 sp(1)
	<.main+1343 @047f16> : 58                         clt.i32
	<.main+1344 @047f17> : 06 0a 00 00                jz <.main+1354 @047f21>
	<.main+1348 @047f1b> : 10 01                      dup.x1 sp(1)
	<.main+1350 @047f1d> : 04 06 00 00                jmp <.main+1356 @047f23>
	<.main+1354 @047f21> : 10 00                      dup.x1 sp(0)
	<.main+1356 @047f23> : 13 02                      set.x1 sp(2)
	<.main+1358 @047f25> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@047f29> - <@047f8a>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @047f29> : 10 25                      dup.x1 sp(37)
	<.main+1364 @047f2b> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @047f2f> : 10 25                      dup.x1 sp(37)
	<.main+1370 @047f31> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @047f35> : 10 25                      dup.x1 sp(37)
	<.main+1376 @047f37> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @047f3b> : 10 25                      dup.x1 sp(37)
	<.main+1382 @047f3d> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @047f41> : 10 01                      dup.x1 sp(1)
	<.main+1388 @047f43> : 10 01                      dup.x1 sp(1)
	<.main+1390 @047f45> : 58                         clt.i32
	<.main+1391 @047f46> : 06 0a 00 00                jz <.main+1401 @047f50>
	<.main+1395 @047f4a> : 10 01                      dup.x1 sp(1)
	<.main+1397 @047f4c> : 04 06 00 00                jmp <.main+1403 @047f52>
	<.main+1401 @047f50> : 10 00                      dup.x1 sp(0)
	<.main+1403 @047f52> : 13 02                      set.x1 sp(2)
	<.main+1405 @047f54> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @047f58> : 10 01                      dup.x1 sp(1)
	<.main+1411 @047f5a> : 10 01                      dup.x1 sp(1)
	<.main+1413 @047f5c> : 58                         clt.i32
	<.main+1414 @047f5d> : 06 0a 00 00                jz <.main+1424 @047f67>
	<.main+1418 @047f61> : 10 01                      dup.x1 sp(1)
	<.main+1420 @047f63> : 04 06 00 00                jmp <.main+1426 @047f69>
	<.main+1424 @047f67> : 10 00                      dup.x1 sp(0)
	<.main+1426 @047f69> : 13 02                      set.x1 sp(2)
	<.main+1428 @047f6b> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @047f6f> : 10 01                      dup.x1 sp(1)
	<.main+1434 @047f71> : 10 01                      dup.x1 sp(1)
	<.main+1436 @047f73> : 58                         clt.i32
	<.main+1437 @047f74> : 06 0a 00 00                jz <.main+1447 @047f7e>
	<.main+1441 @047f78> : 10 01                      dup.x1 sp(1)
	<.main+1443 @047f7a> : 04 06 00 00                jmp <.main+1449 @047f80>
	<.main+1447 @047f7e> : 10 00                      dup.x1 sp(0)
	<.main+1449 @047f80> : 13 02                      set.x1 sp(2)
	<.main+1451 @047f82> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @047f86> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@047f8a> - <@047feb>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @047f8a> : 10 26                      dup.x1 sp(38)
	<.main+1461 @047f8c> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @047f90> : 10 26                      dup.x1 sp(38)
	<.main+1467 @047f92> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @047f96> : 10 01                      dup.x1 sp(1)
	<.main+1473 @047f98> : 10 01                      dup.x1 sp(1)
	<.main+1475 @047f9a> : 58                         clt.i32
	<.main+1476 @047f9b> : 06 0a 00 00                jz <.main+1486 @047fa5>
	<.main+1480 @047f9f> : 10 01                      dup.x1 sp(1)
	<.main+1482 @047fa1> : 04 06 00 00                jmp <.main+1488 @047fa7>
	<.main+1486 @047fa5> : 10 00                      dup.x1 sp(0)
	<.main+1488 @047fa7> : 13 02                      set.x1 sp(2)
	<.main+1490 @047fa9> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @047fad> : 10 25                      dup.x1 sp(37)
	<.main+1496 @047faf> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @047fb3> : 10 01                      dup.x1 sp(1)
	<.main+1502 @047fb5> : 10 01                      dup.x1 sp(1)
	<.main+1504 @047fb7> : 58                         clt.i32
	<.main+1505 @047fb8> : 06 0a 00 00                jz <.main+1515 @047fc2>
	<.main+1509 @047fbc> : 10 01                      dup.x1 sp(1)
	<.main+1511 @047fbe> : 04 06 00 00                jmp <.main+1517 @047fc4>
	<.main+1515 @047fc2> : 10 00                      dup.x1 sp(0)
	<.main+1517 @047fc4> : 13 02                      set.x1 sp(2)
	<.main+1519 @047fc6> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @047fca> : 10 24                      dup.x1 sp(36)
	<.main+1525 @047fcc> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @047fd0> : 10 01                      dup.x1 sp(1)
	<.main+1531 @047fd2> : 10 01                      dup.x1 sp(1)
	<.main+1533 @047fd4> : 58                         clt.i32
	<.main+1534 @047fd5> : 06 0a 00 00                jz <.main+1544 @047fdf>
	<.main+1538 @047fd9> : 10 01                      dup.x1 sp(1)
	<.main+1540 @047fdb> : 04 06 00 00                jmp <.main+1546 @047fe1>
	<.main+1544 @047fdf> : 10 00                      dup.x1 sp(0)
	<.main+1546 @047fe1> : 13 02                      set.x1 sp(2)
	<.main+1548 @047fe3> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @047fe7> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@047feb> - <@048044>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @047feb> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @047ff0> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @047ff5> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @047ffa> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @047fff> : 10 01                      dup.x1 sp(1)
	<.main+1578 @048001> : 10 01                      dup.x1 sp(1)
	<.main+1580 @048003> : 59                         cgt.i32
	<.main+1581 @048004> : 06 0a 00 00                jz <.main+1591 @04800e>
	<.main+1585 @048008> : 10 01                      dup.x1 sp(1)
	<.main+1587 @04800a> : 04 06 00 00                jmp <.main+1593 @048010>
	<.main+1591 @04800e> : 10 00                      dup.x1 sp(0)
	<.main+1593 @048010> : 13 02                      set.x1 sp(2)
	<.main+1595 @048012> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @048016> : 10 01                      dup.x1 sp(1)
	<.main+1601 @048018> : 10 01                      dup.x1 sp(1)
	<.main+1603 @04801a> : 59                         cgt.i32
	<.main+1604 @04801b> : 06 0a 00 00                jz <.main+1614 @048025>
	<.main+1608 @04801f> : 10 01                      dup.x1 sp(1)
	<.main+1610 @048021> : 04 06 00 00                jmp <.main+1616 @048027>
	<.main+1614 @048025> : 10 00                      dup.x1 sp(0)
	<.main+1616 @048027> : 13 02                      set.x1 sp(2)
	<.main+1618 @048029> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @04802d> : 10 01                      dup.x1 sp(1)
	<.main+1624 @04802f> : 10 01                      dup.x1 sp(1)
	<.main+1626 @048031> : 59                         cgt.i32
	<.main+1627 @048032> : 06 0a 00 00                jz <.main+1637 @04803c>
	<.main+1631 @048036> : 10 01                      dup.x1 sp(1)
	<.main+1633 @048038> : 04 06 00 00                jmp <.main+1639 @04803e>
	<.main+1637 @04803c> : 10 00                      dup.x1 sp(0)
	<.main+1639 @04803e> : 13 02                      set.x1 sp(2)
	<.main+1641 @048040> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@048044> - <@04809d>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @048044> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @048049> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @04804e> : 10 01                      dup.x1 sp(1)
	<.main+1657 @048050> : 10 01                      dup.x1 sp(1)
	<.main+1659 @048052> : 59                         cgt.i32
	<.main+1660 @048053> : 06 0a 00 00                jz <.main+1670 @04805d>
	<.main+1664 @048057> : 10 01                      dup.x1 sp(1)
	<.main+1666 @048059> : 04 06 00 00                jmp <.main+1672 @04805f>
	<.main+1670 @04805d> : 10 00                      dup.x1 sp(0)
	<.main+1672 @04805f> : 13 02                      set.x1 sp(2)
	<.main+1674 @048061> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @048065> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @04806a> : 10 01                      dup.x1 sp(1)
	<.main+1685 @04806c> : 10 01                      dup.x1 sp(1)
	<.main+1687 @04806e> : 59                         cgt.i32
	<.main+1688 @04806f> : 06 0a 00 00                jz <.main+1698 @048079>
	<.main+1692 @048073> : 10 01                      dup.x1 sp(1)
	<.main+1694 @048075> : 04 06 00 00                jmp <.main+1700 @04807b>
	<.main+1698 @048079> : 10 00                      dup.x1 sp(0)
	<.main+1700 @04807b> : 13 02                      set.x1 sp(2)
	<.main+1702 @04807d> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @048081> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @048086> : 10 01                      dup.x1 sp(1)
	<.main+1713 @048088> : 10 01                      dup.x1 sp(1)
	<.main+1715 @04808a> : 59                         cgt.i32
	<.main+1716 @04808b> : 06 0a 00 00                jz <.main+1726 @048095>
	<.main+1720 @04808f> : 10 01                      dup.x1 sp(1)
	<.main+1722 @048091> : 04 06 00 00                jmp <.main+1728 @048097>
	<.main+1726 @048095> : 10 00                      dup.x1 sp(0)
	<.main+1728 @048097> : 13 02                      set.x1 sp(2)
	<.main+1730 @048099> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@04809d> - <@0480ea>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @04809d> : 10 29                      dup.x1 sp(41)
	<.main+1736 @04809f> : 10 29                      dup.x1 sp(41)
	<.main+1738 @0480a1> : 10 29                      dup.x1 sp(41)
	<.main+1740 @0480a3> : 10 29                      dup.x1 sp(41)
	<.main+1742 @0480a5> : 10 01                      dup.x1 sp(1)
	<.main+1744 @0480a7> : 10 01                      dup.x1 sp(1)
	<.main+1746 @0480a9> : 59                         cgt.i32
	<.main+1747 @0480aa> : 06 0a 00 00                jz <.main+1757 @0480b4>
	<.main+1751 @0480ae> : 10 01                      dup.x1 sp(1)
	<.main+1753 @0480b0> : 04 06 00 00                jmp <.main+1759 @0480b6>
	<.main+1757 @0480b4> : 10 00                      dup.x1 sp(0)
	<.main+1759 @0480b6> : 13 02                      set.x1 sp(2)
	<.main+1761 @0480b8> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @0480bc> : 10 01                      dup.x1 sp(1)
	<.main+1767 @0480be> : 10 01                      dup.x1 sp(1)
	<.main+1769 @0480c0> : 59                         cgt.i32
	<.main+1770 @0480c1> : 06 0a 00 00                jz <.main+1780 @0480cb>
	<.main+1774 @0480c5> : 10 01                      dup.x1 sp(1)
	<.main+1776 @0480c7> : 04 06 00 00                jmp <.main+1782 @0480cd>
	<.main+1780 @0480cb> : 10 00                      dup.x1 sp(0)
	<.main+1782 @0480cd> : 13 02                      set.x1 sp(2)
	<.main+1784 @0480cf> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @0480d3> : 10 01                      dup.x1 sp(1)
	<.main+1790 @0480d5> : 10 01                      dup.x1 sp(1)
	<.main+1792 @0480d7> : 59                         cgt.i32
	<.main+1793 @0480d8> : 06 0a 00 00                jz <.main+1803 @0480e2>
	<.main+1797 @0480dc> : 10 01                      dup.x1 sp(1)
	<.main+1799 @0480de> : 04 06 00 00                jmp <.main+1805 @0480e4>
	<.main+1803 @0480e2> : 10 00                      dup.x1 sp(0)
	<.main+1805 @0480e4> : 13 02                      set.x1 sp(2)
	<.main+1807 @0480e6> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@0480ea> - <@048137>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @0480ea> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @0480ec> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @0480ee> : 10 01                      dup.x1 sp(1)
	<.main+1817 @0480f0> : 10 01                      dup.x1 sp(1)
	<.main+1819 @0480f2> : 59                         cgt.i32
	<.main+1820 @0480f3> : 06 0a 00 00                jz <.main+1830 @0480fd>
	<.main+1824 @0480f7> : 10 01                      dup.x1 sp(1)
	<.main+1826 @0480f9> : 04 06 00 00                jmp <.main+1832 @0480ff>
	<.main+1830 @0480fd> : 10 00                      dup.x1 sp(0)
	<.main+1832 @0480ff> : 13 02                      set.x1 sp(2)
	<.main+1834 @048101> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @048105> : 10 29                      dup.x1 sp(41)
	<.main+1840 @048107> : 10 01                      dup.x1 sp(1)
	<.main+1842 @048109> : 10 01                      dup.x1 sp(1)
	<.main+1844 @04810b> : 59                         cgt.i32
	<.main+1845 @04810c> : 06 0a 00 00                jz <.main+1855 @048116>
	<.main+1849 @048110> : 10 01                      dup.x1 sp(1)
	<.main+1851 @048112> : 04 06 00 00                jmp <.main+1857 @048118>
	<.main+1855 @048116> : 10 00                      dup.x1 sp(0)
	<.main+1857 @048118> : 13 02                      set.x1 sp(2)
	<.main+1859 @04811a> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @04811e> : 10 28                      dup.x1 sp(40)
	<.main+1865 @048120> : 10 01                      dup.x1 sp(1)
	<.main+1867 @048122> : 10 01                      dup.x1 sp(1)
	<.main+1869 @048124> : 59                         cgt.i32
	<.main+1870 @048125> : 06 0a 00 00                jz <.main+1880 @04812f>
	<.main+1874 @048129> : 10 01                      dup.x1 sp(1)
	<.main+1876 @04812b> : 04 06 00 00                jmp <.main+1882 @048131>
	<.main+1880 @04812f> : 10 00                      dup.x1 sp(0)
	<.main+1882 @048131> : 13 02                      set.x1 sp(2)
	<.main+1884 @048133> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@048137> - <@048198>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @048137> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @048139> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @04813d> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @04813f> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @048143> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @048145> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @048149> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @04814b> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @04814f> : 10 01                      dup.x1 sp(1)
	<.main+1914 @048151> : 10 01                      dup.x1 sp(1)
	<.main+1916 @048153> : 59                         cgt.i32
	<.main+1917 @048154> : 06 0a 00 00                jz <.main+1927 @04815e>
	<.main+1921 @048158> : 10 01                      dup.x1 sp(1)
	<.main+1923 @04815a> : 04 06 00 00                jmp <.main+1929 @048160>
	<.main+1927 @04815e> : 10 00                      dup.x1 sp(0)
	<.main+1929 @048160> : 13 02                      set.x1 sp(2)
	<.main+1931 @048162> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @048166> : 10 01                      dup.x1 sp(1)
	<.main+1937 @048168> : 10 01                      dup.x1 sp(1)
	<.main+1939 @04816a> : 59                         cgt.i32
	<.main+1940 @04816b> : 06 0a 00 00                jz <.main+1950 @048175>
	<.main+1944 @04816f> : 10 01                      dup.x1 sp(1)
	<.main+1946 @048171> : 04 06 00 00                jmp <.main+1952 @048177>
	<.main+1950 @048175> : 10 00                      dup.x1 sp(0)
	<.main+1952 @048177> : 13 02                      set.x1 sp(2)
	<.main+1954 @048179> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @04817d> : 10 01                      dup.x1 sp(1)
	<.main+1960 @04817f> : 10 01                      dup.x1 sp(1)
	<.main+1962 @048181> : 59                         cgt.i32
	<.main+1963 @048182> : 06 0a 00 00                jz <.main+1973 @04818c>
	<.main+1967 @048186> : 10 01                      dup.x1 sp(1)
	<.main+1969 @048188> : 04 06 00 00                jmp <.main+1975 @04818e>
	<.main+1973 @04818c> : 10 00                      dup.x1 sp(0)
	<.main+1975 @04818e> : 13 02                      set.x1 sp(2)
	<.main+1977 @048190> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @048194> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@048198> - <@0481f9>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @048198> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @04819a> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @04819e> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @0481a0> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @0481a4> : 10 01                      dup.x1 sp(1)
	<.main+1999 @0481a6> : 10 01                      dup.x1 sp(1)
	<.main+2001 @0481a8> : 59                         cgt.i32
	<.main+2002 @0481a9> : 06 0a 00 00                jz <.main+2012 @0481b3>
	<.main+2006 @0481ad> : 10 01                      dup.x1 sp(1)
	<.main+2008 @0481af> : 04 06 00 00                jmp <.main+2014 @0481b5>
	<.main+2012 @0481b3> : 10 00                      dup.x1 sp(0)
	<.main+2014 @0481b5> : 13 02                      set.x1 sp(2)
	<.main+2016 @0481b7> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @0481bb> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @0481bd> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @0481c1> : 10 01                      dup.x1 sp(1)
	<.main+2028 @0481c3> : 10 01                      dup.x1 sp(1)
	<.main+2030 @0481c5> : 59                         cgt.i32
	<.main+2031 @0481c6> : 06 0a 00 00                jz <.main+2041 @0481d0>
	<.main+2035 @0481ca> : 10 01                      dup.x1 sp(1)
	<.main+2037 @0481cc> : 04 06 00 00                jmp <.main+2043 @0481d2>
	<.main+2041 @0481d0> : 10 00                      dup.x1 sp(0)
	<.main+2043 @0481d2> : 13 02                      set.x1 sp(2)
	<.main+2045 @0481d4> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @0481d8> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @0481da> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @0481de> : 10 01                      dup.x1 sp(1)
	<.main+2057 @0481e0> : 10 01                      dup.x1 sp(1)
	<.main+2059 @0481e2> : 59                         cgt.i32
	<.main+2060 @0481e3> : 06 0a 00 00                jz <.main+2070 @0481ed>
	<.main+2064 @0481e7> : 10 01                      dup.x1 sp(1)
	<.main+2066 @0481e9> : 04 06 00 00                jmp <.main+2072 @0481ef>
	<.main+2070 @0481ed> : 10 00                      dup.x1 sp(0)
	<.main+2072 @0481ef> : 13 02                      set.x1 sp(2)
	<.main+2074 @0481f1> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @0481f5> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@0481f9> - <@0481fe>): overload1: float32 := overload
	<.main+2082 @0481f9> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@0481fe> - <@048203>): overload2: float32 := overload()
	<.main+2087 @0481fe> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@048203> - <@048208>): overload3: float32 := overload(0)
	<.main+2092 @048203> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@048208> - <@04820d>): overload4: float32 := overload(0.000000)
	<.main+2097 @048208> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@04820d> - <@048212>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @04820d> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@048212> - <@04821b>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @048212> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@04821b> - <@048231>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @04821b> : 11 00                      dup.x2 sp(0)
	<.main+2118 @04821d> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @048226> : 83                         mul.f64
	<.main+2128 @048227> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @048230> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@048231> - <@048236>): valueRef: int64 := value
	<.main+2138 @048231> : 1f 58 77 04 00             load.ref <@047758> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@048236> - <@04823b>): valuePtr: pointer := value
	<.main+2143 @048236> : 1f 58 77 04 00             load.ref <@047758> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@04823b> - <@048245>): valueVar: variant := value
	<.main+2148 @04823b> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2153 @048240> : 1f 58 77 04 00             load.ref <@047758> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@048245> - <@048248>): fromRef: int64 := valueRef
	<.main+2158 @048245> : 10 03                      dup.x1 sp(3)
	<.main+2160 @048247> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@048248> - <@04824a>): fromPtr: int64 := valuePtr
	<.main+2161 @048248> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@04824a> - <@04824c>): fromVar: int64 := valueVar
	<.main+2163 @04824a> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@04824c> - <@048251>): nullRef: int64 := null
	<.main+2165 @04824c> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@048251> - <@048256>): nullPtr: pointer := null
	<.main+2170 @048251> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@048256> - <@048260>): nullVar: variant := null
	<.main+2175 @048256> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2180 @04825b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@048260> - <@048265>): nullTyp: typename := null
	<.main+2185 @048260> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@048265> - <@04826a>): nullFun: function := null
	<.main+2190 @048265> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@04826a> - <@04826f>): nullObj: object := null
	<.main+2195 @04826a> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@04826f> - <@048274>): typePtr: pointer := int64
	<.main+2200 @04826f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@048274> - <@04827e>): typeVar: variant := int64
	<.main+2205 @048274> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @048279> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@04827e> - <@048283>): typeTyp: typename := int64
	<.main+2215 @04827e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@048283> - <@048287>): local: int64 := value
	<.main+2220 @048283> : 2b 58 77 04                load.m64 <@047758> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@048287> - <@048289>): copyVal: int64 := local
	<.main+2224 @048287> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@048289> - <@04828b>): copyRef: int64 := valueRef
	<.main+2226 @048289> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@04828b> - <@04828d>): copyPtr: pointer := valuePtr
	<.main+2228 @04828b> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@04828d> - <@04828f>): copyVar: variant := valueVar
	<.main+2230 @04828d> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@04828f> - <@048291>): copyTyp: typename := typeTyp
	<.main+2232 @04828f> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@048291> - <@048296>): ptrVoid: pointer := void
	<.main+2234 @048291> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@048296> - <@04829b>): ptrBool: pointer := bool
	<.main+2239 @048296> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@04829b> - <@0482a0>): ptrChar: pointer := char
	<.main+2244 @04829b> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@0482a0> - <@0482a5>): ptrInt8: pointer := int8
	<.main+2249 @0482a0> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@0482a5> - <@0482aa>): ptrInt16: pointer := int16
	<.main+2254 @0482a5> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@0482aa> - <@0482af>): ptrInt32: pointer := int32
	<.main+2259 @0482aa> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@0482af> - <@0482b4>): ptrInt64: pointer := int64
	<.main+2264 @0482af> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@0482b4> - <@0482b9>): ptrUint8: pointer := uint8
	<.main+2269 @0482b4> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@0482b9> - <@0482be>): ptrUint16: pointer := uint16
	<.main+2274 @0482b9> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@0482be> - <@0482c3>): ptrUint32: pointer := uint32
	<.main+2279 @0482be> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@0482c3> - <@0482c8>): ptrUint64: pointer := uint64
	<.main+2284 @0482c3> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@0482c8> - <@0482cd>): ptrFloat32: pointer := float32
	<.main+2289 @0482c8> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@0482cd> - <@0482d2>): ptrFloat64: pointer := float64
	<.main+2294 @0482cd> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@0482d2> - <@0482d7>): ptrTypename: pointer := typename
	<.main+2299 @0482d2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@0482d7> - <@0482dc>): ptrFunction: pointer := function
	<.main+2304 @0482d7> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@0482dc> - <@0482e1>): ptrPointer: pointer := pointer
	<.main+2309 @0482dc> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@0482e1> - <@0482e6>): ptrVariant: pointer := variant
	<.main+2314 @0482e1> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@0482e6> - <@0482eb>): ptrObject: pointer := object
	<.main+2319 @0482e6> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@0482eb> - <@0482f5>): varVoid: variant := void
	<.main+2324 @0482eb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @0482f0> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@0482f5> - <@0482ff>): varBool: variant := bool
	<.main+2334 @0482f5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @0482fa> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@0482ff> - <@048309>): varChar: variant := char
	<.main+2344 @0482ff> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @048304> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@048309> - <@048313>): varInt8: variant := int8
	<.main+2354 @048309> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @04830e> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@048313> - <@04831d>): varInt16: variant := int16
	<.main+2364 @048313> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @048318> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@04831d> - <@048327>): varInt32: variant := int32
	<.main+2374 @04831d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @048322> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@048327> - <@048331>): varInt64: variant := int64
	<.main+2384 @048327> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @04832c> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@048331> - <@04833b>): varUint8: variant := uint8
	<.main+2394 @048331> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @048336> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@04833b> - <@048345>): varUint16: variant := uint16
	<.main+2404 @04833b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @048340> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@048345> - <@04834f>): varUint32: variant := uint32
	<.main+2414 @048345> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @04834a> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@04834f> - <@048359>): varUint64: variant := uint64
	<.main+2424 @04834f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @048354> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@048359> - <@048363>): varFloat32: variant := float32
	<.main+2434 @048359> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @04835e> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@048363> - <@04836d>): varFloat64: variant := float64
	<.main+2444 @048363> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @048368> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@04836d> - <@048377>): varTypename: variant := typename
	<.main+2454 @04836d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @048372> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@048377> - <@048381>): varFunction: variant := function
	<.main+2464 @048377> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @04837c> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@048381> - <@04838b>): varPointer: variant := pointer
	<.main+2474 @048381> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @048386> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@04838b> - <@048395>): varVariant: variant := variant
	<.main+2484 @04838b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @048390> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@048395> - <@04839f>): varObject: variant := object
	<.main+2494 @048395> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @04839a> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@04839f> - <@0483a4>): typVoid: typename := void
	<.main+2504 @04839f> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@0483a4> - <@0483a9>): typBool: typename := bool
	<.main+2509 @0483a4> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@0483a9> - <@0483ae>): typChar: typename := char
	<.main+2514 @0483a9> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@0483ae> - <@0483b3>): typInt8: typename := int8
	<.main+2519 @0483ae> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@0483b3> - <@0483b8>): typInt16: typename := int16
	<.main+2524 @0483b3> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@0483b8> - <@0483bd>): typInt32: typename := int32
	<.main+2529 @0483b8> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@0483bd> - <@0483c2>): typInt64: typename := int64
	<.main+2534 @0483bd> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@0483c2> - <@0483c7>): typUint8: typename := uint8
	<.main+2539 @0483c2> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@0483c7> - <@0483cc>): typUint16: typename := uint16
	<.main+2544 @0483c7> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@0483cc> - <@0483d1>): typUint32: typename := uint32
	<.main+2549 @0483cc> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@0483d1> - <@0483d6>): typUint64: typename := uint64
	<.main+2554 @0483d1> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@0483d6> - <@0483db>): typFloat32: typename := float32
	<.main+2559 @0483d6> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@0483db> - <@0483e0>): typFloat64: typename := float64
	<.main+2564 @0483db> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@0483e0> - <@0483e5>): typTypename: typename := typename
	<.main+2569 @0483e0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@0483e5> - <@0483ea>): typFunction: typename := function
	<.main+2574 @0483e5> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@0483ea> - <@0483ef>): typPointer: typename := pointer
	<.main+2579 @0483ea> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@0483ef> - <@0483f4>): typVariant: typename := variant
	<.main+2584 @0483ef> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@0483f4> - <@0483f9>): typObject: typename := object
	<.main+2589 @0483f4> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@0483f9> - <@0483fe>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @0483f9> : 1f 58 77 04 00             load.ref <@047758> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@0483fe> - <@048408>): valueOfVar: variant := variant(value)
	<.main+2599 @0483fe> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2604 @048403> : 1f 58 77 04 00             load.ref <@047758> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@048408> - <@04840d>): valueOfTyp: typename := typename(value)
	<.main+2609 @048408> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@04840d> - <@048412>): typeOfValue: typename := typename(value)
	<.main+2614 @04840d> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@048412> - <@048419>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @048412> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2624 @048417> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@048419> - <@04841b>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @048419> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@04841b> - <@048430>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @04841b> : 19                         load.z32
	<.main+2629 @04841c> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @048421> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @048426> : 1f 68 77 04 00             load.ref <@047768> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @04842b> : 02                         call
	<.main+2645 @04842c> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@048430> - <@048435>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @048430> : 1f 68 77 04 00             load.ref <@047768> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@048435> - <@048447>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @048435> : 19                         load.z32
	<.main+2655 @048436> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @04843b> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @048440> : 10 03                      dup.x1 sp(3)
	<.main+2667 @048442> : 02                         call
	<.main+2668 @048443> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@048447> - <@04844c>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @048447> : 1f 70 77 04 00             load.ref <@047770> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@04844c> - <@04845e>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @04844c> : 19                         load.z32
	<.main+2678 @04844d> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @048452> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @048457> : 10 03                      dup.x1 sp(3)
	<.main+2690 @048459> : 02                         call
	<.main+2691 @04845a> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@04845e> - <@048460>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @04845e> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@048460> - <@048472>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @048460> : 19                         load.z32
	<.main+2698 @048461> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @048466> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @04846b> : 10 03                      dup.x1 sp(3)
	<.main+2710 @04846d> : 02                         call
	<.main+2711 @04846e> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@048472> - <@048482>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @048472> : 19                         load.z32
	<.main+2716 @048473> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @048478> : 1f 78 77 04 00             load.ref <@047778> ;fib(n: uint32): uint32
	<.main+2726 @04847d> : 02                         call
	<.main+2727 @04847e> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@048482> - <@048486>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @048482> : 2a b8 00 00                load.m32 <@0000b8>
	test/lang/reflect.ci:4: (4 bytes: <@048486> - <@04848a>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @048486> : 2a 48 01 00                load.m32 <@000148>
	test/lang/reflect.ci:5: (4 bytes: <@04848a> - <@04848e>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @04848a> : 2a d8 01 00                load.m32 <@0001d8>
	test/lang/reflect.ci:6: (4 bytes: <@04848e> - <@048492>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @04848e> : 2a 68 02 00                load.m32 <@000268>
	test/lang/reflect.ci:7: (4 bytes: <@048492> - <@048496>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @048492> : 2a f8 02 00                load.m32 <@0002f8>
	test/lang/reflect.ci:8: (4 bytes: <@048496> - <@04849a>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @048496> : 2a 88 03 00                load.m32 <@000388>
	test/lang/reflect.ci:9: (4 bytes: <@04849a> - <@04849e>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @04849a> : 2a 18 04 00                load.m32 <@000418>
	test/lang/reflect.ci:10: (4 bytes: <@04849e> - <@0484a2>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @04849e> : 2a a8 04 00                load.m32 <@0004a8>
	test/lang/reflect.ci:11: (4 bytes: <@0484a2> - <@0484a6>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @0484a2> : 2a 38 05 00                load.m32 <@000538>
	test/lang/reflect.ci:12: (4 bytes: <@0484a6> - <@0484aa>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @0484a6> : 2a c8 05 00                load.m32 <@0005c8>
	test/lang/reflect.ci:13: (4 bytes: <@0484aa> - <@0484ae>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @0484aa> : 2a 58 06 00                load.m32 <@000658>
	test/lang/reflect.ci:14: (4 bytes: <@0484ae> - <@0484b2>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @0484ae> : 2a e8 06 00                load.m32 <@0006e8>
	test/lang/reflect.ci:15: (4 bytes: <@0484b2> - <@0484b6>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @0484b2> : 2a 78 07 00                load.m32 <@000778>
	test/lang/reflect.ci:16: (4 bytes: <@0484b6> - <@0484ba>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @0484b6> : 2a 08 08 00                load.m32 <@000808>
	test/lang/reflect.ci:17: (4 bytes: <@0484ba> - <@0484be>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @0484ba> : 2a 98 08 00                load.m32 <@000898>
	test/lang/reflect.ci:18: (4 bytes: <@0484be> - <@0484c2>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @0484be> : 2a 20 00 00                load.m32 <@000020> ;typename+24
	test/lang/reflect.ci:19: (4 bytes: <@0484c2> - <@0484c6>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @0484c2> : 2a 28 09 00                load.m32 <@000928>
	test/lang/reflect.ci:20: (4 bytes: <@0484c6> - <@0484ca>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @0484c6> : 2a c0 09 00                load.m32 <@0009c0>
	test/lang/reflect.ci:30: (5 bytes: <@0484ca> - <@0484cf>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @0484ca> : 1f a0 ff 02 00             load.ref <@02ffa0> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@0484cf> - <@0484d5>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @0484cf> : 10 00                      dup.x1 sp(0)
	<.main+2810 @0484d1> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@0484d5> - <@0484dc>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @0484d5> : 10 01                      dup.x1 sp(1)
	<.main+2816 @0484d7> : 0c 20 00 00                inc.i32(+32)
	<.main+2820 @0484db> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@0484dc> - <@0484e3>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @0484dc> : 10 02                      dup.x1 sp(2)
	<.main+2823 @0484de> : 0c 18 00 00                inc.i32(+24)
	<.main+2827 @0484e2> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@0484e3> - <@0484e9>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @0484e3> : 10 03                      dup.x1 sp(3)
	<.main+2830 @0484e5> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@0484e9> - <@0484ef>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @0484e9> : 10 04                      dup.x1 sp(4)
	<.main+2836 @0484eb> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@0484ef> - <@0484f5>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @0484ef> : 10 05                      dup.x1 sp(5)
	<.main+2842 @0484f1> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@0484f5> - <@0484fb>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @0484f5> : 10 00                      dup.x1 sp(0)
	<.main+2848 @0484f7> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@0484fb> - <@048502>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @0484fb> : 10 01                      dup.x1 sp(1)
	<.main+2854 @0484fd> : 0c 20 00 00                inc.i32(+32)
	<.main+2858 @048501> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@048502> - <@048509>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @048502> : 10 02                      dup.x1 sp(2)
	<.main+2861 @048504> : 0c 18 00 00                inc.i32(+24)
	<.main+2865 @048508> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@048509> - <@04850f>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @048509> : 10 03                      dup.x1 sp(3)
	<.main+2868 @04850b> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@04850f> - <@048515>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @04850f> : 10 04                      dup.x1 sp(4)
	<.main+2874 @048511> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@048515> - <@04851b>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @048515> : 10 05                      dup.x1 sp(5)
	<.main+2880 @048517> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@04851b> - <@048522>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @04851b> : 10 00                      dup.x1 sp(0)
	<.main+2886 @04851d> : 0c 20 00 00                inc.i32(+32)
	<.main+2890 @048521> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@048522> - <@048529>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @048522> : 10 01                      dup.x1 sp(1)
	<.main+2893 @048524> : 0c 18 00 00                inc.i32(+24)
	<.main+2897 @048528> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@048529> - <@04852f>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @048529> : 10 02                      dup.x1 sp(2)
	<.main+2900 @04852b> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@04852f> - <@048536>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @04852f> : 10 00                      dup.x1 sp(0)
	<.main+2906 @048531> : 0c 20 00 00                inc.i32(+32)
	<.main+2910 @048535> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@048536> - <@04853d>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @048536> : 10 01                      dup.x1 sp(1)
	<.main+2913 @048538> : 0c 18 00 00                inc.i32(+24)
	<.main+2917 @04853c> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@04853d> - <@048546>): pi64: float64 := 3.141593
	<.main+2918 @04853d> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@048546> - <@04854f>): e64: float64 := 2.718282
	<.main+2927 @048546> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@04854f> - <@048552>): pi32: float32 := pi64
	<.main+2936 @04854f> : 11 02                      dup.x2 sp(2)
	<.main+2938 @048551> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@048552> - <@048555>): e32: float32 := e64
	<.main+2939 @048552> : 11 01                      dup.x2 sp(1)
	<.main+2941 @048554> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@048555> - <@04855c>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @048555> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @04855a> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@04855c> - <@048563>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @04855c> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @048561> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@048563> - <@04856a>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @048563> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @048568> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@04856a> - <@048586>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @04856a> : 10 02                      dup.x1 sp(2)
	<.main+2965 @04856c> : 3f 48                      b32.shl 0x008
	<.main+2967 @04856e> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @048573> : 31                         and.b32
	<.main+2973 @048574> : 10 02                      dup.x1 sp(2)
	<.main+2975 @048576> : 3f 43                      b32.shl 0x003
	<.main+2977 @048578> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @04857d> : 31                         and.b32
	<.main+2983 @04857e> : 32                         or.b32
	<.main+2984 @04857f> : 10 01                      dup.x1 sp(1)
	<.main+2986 @048581> : 3f c3                      b32.sar 0x003
	<.main+2988 @048583> : 3f 05                      b32.and 0x01f
	<.main+2990 @048585> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@048586> - <@0485a0>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @048586> : 10 03                      dup.x1 sp(3)
	<.main+2993 @048588> : 3f 50                      b32.shl 0x010
	<.main+2995 @04858a> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @04858f> : 31                         and.b32
	<.main+3001 @048590> : 10 03                      dup.x1 sp(3)
	<.main+3003 @048592> : 3f 48                      b32.shl 0x008
	<.main+3005 @048594> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @048599> : 31                         and.b32
	<.main+3011 @04859a> : 32                         or.b32
	<.main+3012 @04859b> : 10 02                      dup.x1 sp(2)
	<.main+3014 @04859d> : 3f 08                      b32.and 0x0ff
	<.main+3016 @04859f> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@0485a0> - <@0485b0>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @0485a0> : 10 01                      dup.x1 sp(1)
	<.main+3019 @0485a2> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @0485a7> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @0485ac> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@0485b0> - <@0485c0>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @0485b0> : 10 02                      dup.x1 sp(2)
	<.main+3035 @0485b2> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @0485b7> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @0485bc> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@0485c0> - <@0485cc>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @0485c0> : 10 03                      dup.x1 sp(3)
	<.main+3051 @0485c2> : 19                         load.z32
	<.main+3052 @0485c3> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @0485c8> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@0485cc> - <@0485dc>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @0485cc> : 10 04                      dup.x1 sp(4)
	<.main+3063 @0485ce> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @0485d3> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @0485d8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@0485dc> - <@0485ec>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @0485dc> : 10 05                      dup.x1 sp(5)
	<.main+3079 @0485de> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @0485e3> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @0485e8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@0485ec> - <@0485f8>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @0485ec> : 10 06                      dup.x1 sp(6)
	<.main+3095 @0485ee> : 19                         load.z32
	<.main+3096 @0485ef> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @0485f4> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@0485f8> - <@048608>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @0485f8> : 10 06                      dup.x1 sp(6)
	<.main+3107 @0485fa> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @0485ff> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @048604> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@048608> - <@048618>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @048608> : 10 07                      dup.x1 sp(7)
	<.main+3123 @04860a> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @04860f> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @048614> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@048618> - <@048624>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @048618> : 10 08                      dup.x1 sp(8)
	<.main+3139 @04861a> : 19                         load.z32
	<.main+3140 @04861b> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @048620> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@048624> - <@048634>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @048624> : 10 09                      dup.x1 sp(9)
	<.main+3151 @048626> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @04862b> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @048630> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@048634> - <@048644>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @048634> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @048636> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @04863b> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @048640> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@048644> - <@048650>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @048644> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @048646> : 19                         load.z32
	<.main+3184 @048647> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @04864c> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@048650> - <@048660>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @048650> : 11 15                      dup.x2 sp(21)
	<.main+3195 @048652> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @04865b> : 84                         div.f64
	<.main+3205 @04865c> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@048660> - <@048670>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @048660> : 11 17                      dup.x2 sp(23)
	<.main+3211 @048662> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @04866b> : 84                         div.f64
	<.main+3221 @04866c> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@048670> - <@048680>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @048670> : 11 19                      dup.x2 sp(25)
	<.main+3227 @048672> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @04867b> : 84                         div.f64
	<.main+3237 @04867c> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@048680> - <@04868c>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @048680> : 11 19                      dup.x2 sp(25)
	<.main+3243 @048682> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @048684> : 83                         mul.f64
	<.main+3246 @048685> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @048687> : 83                         mul.f64
	<.main+3249 @048688> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@04868c> - <@048699>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @04868c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @048695> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@048699> - <@0486ab>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @048699> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @04869b> : 11 21                      dup.x2 sp(33)
	<.main+3270 @04869d> : 83                         mul.f64
	<.main+3271 @04869e> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @0486a7> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@0486ab> - <@0486b4>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @0486ab> : 11 21                      dup.x2 sp(33)
	<.main+3286 @0486ad> : 11 23                      dup.x2 sp(35)
	<.main+3288 @0486af> : 83                         mul.f64
	<.main+3289 @0486b0> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@0486b4> - <@0486c3>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @0486b4> : 11 23                      dup.x2 sp(35)
	<.main+3295 @0486b6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @0486bf> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@0486c3> - <@0486cf>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @0486c3> : 10 22                      dup.x1 sp(34)
	<.main+3310 @0486c5> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @0486ca> : 74                         div.f32
	<.main+3316 @0486cb> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@0486cf> - <@0486db>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @0486cf> : 10 23                      dup.x1 sp(35)
	<.main+3322 @0486d1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @0486d6> : 74                         div.f32
	<.main+3328 @0486d7> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@0486db> - <@0486e7>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @0486db> : 10 24                      dup.x1 sp(36)
	<.main+3334 @0486dd> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @0486e2> : 74                         div.f32
	<.main+3340 @0486e3> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@0486e7> - <@0486f3>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @0486e7> : 10 24                      dup.x1 sp(36)
	<.main+3346 @0486e9> : 10 25                      dup.x1 sp(37)
	<.main+3348 @0486eb> : 73                         mul.f32
	<.main+3349 @0486ec> : 10 25                      dup.x1 sp(37)
	<.main+3351 @0486ee> : 73                         mul.f32
	<.main+3352 @0486ef> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@0486f3> - <@0486fc>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @0486f3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @0486f8> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@0486fc> - <@04870a>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @0486fc> : 10 27                      dup.x1 sp(39)
	<.main+3367 @0486fe> : 10 28                      dup.x1 sp(40)
	<.main+3369 @048700> : 73                         mul.f32
	<.main+3370 @048701> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @048706> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@04870a> - <@048713>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @04870a> : 10 28                      dup.x1 sp(40)
	<.main+3381 @04870c> : 10 29                      dup.x1 sp(41)
	<.main+3383 @04870e> : 73                         mul.f32
	<.main+3384 @04870f> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@048713> - <@04871e>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @048713> : 10 29                      dup.x1 sp(41)
	<.main+3390 @048715> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @04871a> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@04871e> - <@048724>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @04871e> : 10 25                      dup.x1 sp(37)
	<.main+3401 @048720> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@048724> - <@04872a>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @048724> : 10 26                      dup.x1 sp(38)
	<.main+3407 @048726> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@04872a> - <@048730>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @04872a> : 10 27                      dup.x1 sp(39)
	<.main+3413 @04872c> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@048730> - <@048736>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @048730> : 10 28                      dup.x1 sp(40)
	<.main+3419 @048732> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@048736> - <@04873c>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @048736> : 10 29                      dup.x1 sp(41)
	<.main+3425 @048738> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@04873c> - <@048742>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @04873c> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @04873e> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@048742> - <@04874e>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @048742> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @048744> : 19                         load.z32
	<.main+3438 @048745> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @04874a> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@04874e> - <@04875a>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @04874e> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @048750> : 19                         load.z32
	<.main+3450 @048751> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @048756> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@04875a> - <@048768>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @04875a> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @04875c> : 5c                         i32.2i64
	<.main+3462 @04875d> : 19                         load.z32
	<.main+3463 @04875e> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @048763> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @048767> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@048768> - <@048776>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @048768> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @04876a> : 5c                         i32.2i64
	<.main+3476 @04876b> : 19                         load.z32
	<.main+3477 @04876c> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @048771> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @048775> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@048776> - <@048784>): p1: pointer := malloc(1024)
	<.main+3487 @048776> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @04877b> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @048780> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@048784> - <@048792>): p2: pointer := malloc(80)
	<.main+3501 @048784> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @048789> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @04878e> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@048792> - <@0487a0>): p3: pointer := malloc(160)
	<.main+3515 @048792> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @048797> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @04879c> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@0487a0> - <@0487ae>): p4: pointer := malloc(820)
	<.main+3529 @0487a0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @0487a5> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @0487aa> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@0487ae> - <@0487be>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @0487ae> : 10 03                      dup.x1 sp(3)
	<.main+3545 @0487b0> : 19                         load.z32
	<.main+3546 @0487b1> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @0487b6> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @0487ba> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@0487be> - <@0487cf>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @0487be> : 10 03                      dup.x1 sp(3)
	<.main+3561 @0487c0> : 10 02                      dup.x1 sp(2)
	<.main+3563 @0487c2> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @0487c7> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @0487cb> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@0487cf> - <@0487da>): free(p1);
	<.main+3576 @0487cf> : 10 03                      dup.x1 sp(3)
	<.main+3578 @0487d1> : 19                         load.z32
	<.main+3579 @0487d2> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @0487d6> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@0487da> - <@0487e5>): free(p2);
	<.main+3587 @0487da> : 10 02                      dup.x1 sp(2)
	<.main+3589 @0487dc> : 19                         load.z32
	<.main+3590 @0487dd> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @0487e1> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@0487e5> - <@0487f0>): free(p3);
	<.main+3598 @0487e5> : 10 01                      dup.x1 sp(1)
	<.main+3600 @0487e7> : 19                         load.z32
	<.main+3601 @0487e8> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @0487ec> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@0487f0> - <@0487fb>): free(p4);
	<.main+3609 @0487f0> : 10 00                      dup.x1 sp(0)
	<.main+3611 @0487f2> : 19                         load.z32
	<.main+3612 @0487f3> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @0487f7> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@0487fb> - <@048804>): val1: int64 := 42
	<.main+3620 @0487fb> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@048804> - <@04880d>): val2: int64 := 96
	<.main+3629 @048804> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@04880d> - <@04882f>): debug(void("val1", val1));
	<.main+3638 @04880d> : 1f d0 2c 03 00             load.ref <@032cd0> ;"test/stdc/memory.ci"
	<.main+3643 @048812> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @048817> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @04881c> : 19                         load.z32
	<.main+3654 @04881d> : 1f f8 2c 03 00             load.ref <@032cf8> ;"val1"
	<.main+3659 @048822> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3664 @048827> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @04882b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@04882f> - <@048851>): debug(void("val2", val2));
	<.main+3672 @04882f> : 1f d0 2c 03 00             load.ref <@032cd0> ;"test/stdc/memory.ci"
	<.main+3677 @048834> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @048839> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @04883e> : 19                         load.z32
	<.main+3688 @04883f> : 1f fd 2c 03 00             load.ref <@032cfd> ;"val2"
	<.main+3693 @048844> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3698 @048849> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @04884d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@048851> - <@048865>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @048851> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @048855> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @048859> : 2a 18 04 00                load.m32 <@000418>
	<.main+3718 @04885d> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @048861> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@048865> - <@048876>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @048865> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @048869> : 19                         load.z32
	<.main+3731 @04886a> : 2a 18 04 00                load.m32 <@000418>
	<.main+3735 @04886e> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @048872> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@048876> - <@048898>): debug(void("val1", val1));
	<.main+3743 @048876> : 1f d0 2c 03 00             load.ref <@032cd0> ;"test/stdc/memory.ci"
	<.main+3748 @04887b> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @048880> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @048885> : 19                         load.z32
	<.main+3759 @048886> : 1f f8 2c 03 00             load.ref <@032cf8> ;"val1"
	<.main+3764 @04888b> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3769 @048890> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @048894> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@048898> - <@0488ba>): debug(void("val2", val2));
	<.main+3777 @048898> : 1f d0 2c 03 00             load.ref <@032cd0> ;"test/stdc/memory.ci"
	<.main+3782 @04889d> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @0488a2> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @0488a7> : 19                         load.z32
	<.main+3793 @0488a8> : 1f fd 2c 03 00             load.ref <@032cfd> ;"val2"
	<.main+3798 @0488ad> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3803 @0488b2> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @0488b6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@0488ba> - <@0488c8>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @0488ba> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @0488bf> : 1f b0 77 04 00             load.ref <@0477b0> ;noError(ptr: pointer): void
	<.main+3821 @0488c4> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@0488c8> - <@0488d6>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @0488c8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @0488cd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @0488d2> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@0488d6> - <@0488e4>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @0488d6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @0488db> : 1f b8 77 04 00             load.ref <@0477b8> ;stackOverflow(ptr: pointer): void
	<.main+3849 @0488e0> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@0488e4> - <@0488f2>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @0488e4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @0488e9> : 1f d0 77 04 00             load.ref <@0477d0> ;divisionByZero(args: pointer): void
	<.main+3863 @0488ee> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@0488f2> - <@048900>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @0488f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @0488f7> : 1f 38 78 04 00             load.ref <@047838> ;invalidInstruction(args: pointer): void
	<.main+3877 @0488fc> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@048900> - <@04890e>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @048900> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @048905> : 1f 28 78 04 00             load.ref <@047828> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @04890a> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@04890e> - <@04891c>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @04890e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @048913> : 1f e0 77 04 00             load.ref <@0477e0> ;abortExecution(args: pointer): void
	<.main+3905 @048918> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@04891c> - <@048920>): arrFixedNoInit: int64[7]
	<.main+3909 @04891c> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@048920> - <@048924>): arrArrayNoInit: int64[*]
	<.main+3913 @048920> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@048924> - <@048928>): arrSliceNoInit: int64[]
	<.main+3917 @048924> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@048928> - <@048955>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @048928> : 19                         load.z32
	<.main+3922 @048929> : 04 1c 00 00                jmp <.main+3950 @048945>
	test/lang/array.ci:55: (20 bytes: <@04892d> - <@048941>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @04892d> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @048932> : 10 01                      dup.x1 sp(1)
	<.main+3933 @048934> : 51                         add.i32
	<.main+3934 @048935> : 5c                         i32.2i64
	<.main+3935 @048936> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @04893a> : 10 03                      dup.x1 sp(3)
	<.main+3941 @04893c> : 0d 08 00 00                mad.u32 8
	<.main+3945 @048940> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@048941> - <@048945>): int32(i := int32(i + 1))
	<.main+3946 @048941> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@048945> - <@048951>): bool(i < arrFixedNoInit.length)
	<.main+3950 @048945> : 10 00                      dup.x1 sp(0)
	<.main+3952 @048947> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @04894c> : 58                         clt.i32
	<.main+3958 @04894d> : 05 e0 ff ff                jnz <.main+3926 @04892d>
	<.main+3962 @048951> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@048955> - <@04895a>): arrArrayInitNull: int64[*] := null
	<.main+3966 @048955> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@04895a> - <@048960>): arrSliceInitNull: int64[] := null
	<.main+3971 @04895a> : 19                         load.z32
	<.main+3972 @04895b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@048960> - <@048964>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @048960> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@048964> - <@04896d>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @048964> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @048969> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@04896d> - <@04896f>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @04896d> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@04896f> - <@048971>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @04896f> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@048971> - <@048973>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @048971> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@048973> - <@048977>): strFixed: char[7]
	<.main+3996 @048973> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@048977> - <@04898d>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @048977> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @04897b> : 1f 94 55 02 00             load.ref <@025594> ;"string"
	<.main+4009 @048980> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @048985> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @048989> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@04898d> - <@0489af>): debug(void("string as variant", strFixed));
	<.main+4022 @04898d> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4027 @048992> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @048997> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @04899c> : 19                         load.z32
	<.main+4038 @04899d> : 1f d3 4a 03 00             load.ref <@034ad3> ;"string as variant"
	<.main+4043 @0489a2> : 1f 70 57 03 00             load.ref <@035770>
	<.main+4048 @0489a7> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @0489ab> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@0489af> - <@0489d1>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @0489af> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4061 @0489b4> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @0489b9> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @0489be> : 19                         load.z32
	<.main+4072 @0489bf> : 1f e5 4a 03 00             load.ref <@034ae5> ;"string to variant"
	<.main+4077 @0489c4> : 1f 70 57 03 00             load.ref <@035770>
	<.main+4082 @0489c9> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @0489cd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@0489d1> - <@0489d6>): strArray: char[*] := "string"
	<.main+4090 @0489d1> : 1f 94 55 02 00             load.ref <@025594> ;"string"
	test/lang/array.ci:87: (32 bytes: <@0489d6> - <@0489f6>): debug(void("string as variant", strArray));
	<.main+4095 @0489d6> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4100 @0489db> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @0489e0> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @0489e5> : 19                         load.z32
	<.main+4111 @0489e6> : 1f d3 4a 03 00             load.ref <@034ad3> ;"string as variant"
	<.main+4116 @0489eb> : 1f 08 59 03 00             load.ref <@035908>
	<.main+4121 @0489f0> : 10 06                      dup.x1 sp(6)
	<.main+4123 @0489f2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@0489f6> - <@048a16>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @0489f6> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4132 @0489fb> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @048a00> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @048a05> : 19                         load.z32
	<.main+4143 @048a06> : 1f e5 4a 03 00             load.ref <@034ae5> ;"string to variant"
	<.main+4148 @048a0b> : 1f 08 59 03 00             load.ref <@035908>
	<.main+4153 @048a10> : 10 06                      dup.x1 sp(6)
	<.main+4155 @048a12> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@048a16> - <@048a20>): strSlice: char[] := "string"
	<.main+4159 @048a16> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @048a1b> : 1f 94 55 02 00             load.ref <@025594> ;"string"
	test/lang/array.ci:91: (32 bytes: <@048a20> - <@048a40>): debug(void("string as variant", strSlice));
	<.main+4169 @048a20> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4174 @048a25> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @048a2a> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @048a2f> : 19                         load.z32
	<.main+4185 @048a30> : 1f d3 4a 03 00             load.ref <@034ad3> ;"string as variant"
	<.main+4190 @048a35> : 1f 18 5a 03 00             load.ref <@035a18>
	<.main+4195 @048a3a> : 10 06                      dup.x1 sp(6)
	<.main+4197 @048a3c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@048a40> - <@048a60>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @048a40> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4206 @048a45> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @048a4a> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @048a4f> : 19                         load.z32
	<.main+4217 @048a50> : 1f e5 4a 03 00             load.ref <@034ae5> ;"string to variant"
	<.main+4222 @048a55> : 1f 18 5a 03 00             load.ref <@035a18>
	<.main+4227 @048a5a> : 10 06                      dup.x1 sp(6)
	<.main+4229 @048a5c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@048a60> - <@048a93>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @048a60> : 10 10                      dup.x1 sp(16)
	<.main+4235 @048a62> : 19                         load.z32
	<.main+4236 @048a63> : 38                         clt.u32
	<.main+4237 @048a64> : 05 08 00 00                jnz <.main+4245 @048a6c>
	<.main+4241 @048a68> : 04 2b 00 00                jmp <.main+4284 @048a93>
	<.main+4245 @048a6c> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4250 @048a71> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @048a76> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @048a7b> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @048a80> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4270 @048a85> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4275 @048a8a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @048a8f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@048a93> - <@048ac6>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @048a93> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @048a95> : 19                         load.z32
	<.main+4287 @048a96> : 57                         ceq.i32
	<.main+4288 @048a97> : 06 08 00 00                jz <.main+4296 @048a9f>
	<.main+4292 @048a9b> : 04 2b 00 00                jmp <.main+4335 @048ac6>
	<.main+4296 @048a9f> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4301 @048aa4> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @048aa9> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @048aae> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @048ab3> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4321 @048ab8> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4326 @048abd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @048ac2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@048ac6> - <@048b01>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @048ac6> : 11 12                      dup.x2 sp(18)
	<.main+4337 @048ac8> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @048ad1> : 67                         ceq.i64
	<.main+4347 @048ad2> : 06 08 00 00                jz <.main+4355 @048ada>
	<.main+4351 @048ad6> : 04 2b 00 00                jmp <.main+4394 @048b01>
	<.main+4355 @048ada> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4360 @048adf> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @048ae4> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @048ae9> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @048aee> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4380 @048af3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4385 @048af8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @048afd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@048b01> - <@048b1a>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @048b01> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @048b06> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @048b0b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @048b10> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @048b15> : 02                         call
	<.main+4415 @048b16> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@048b1a> - <@048b30>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @048b1a> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @048b1f> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @048b21> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @048b26> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @048b2b> : 02                         call
	<.main+4437 @048b2c> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@048b30> - <@048b46>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @048b30> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @048b35> : 10 08                      dup.x1 sp(8)
	<.main+4448 @048b37> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @048b3c> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @048b41> : 02                         call
	<.main+4459 @048b42> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@048b46> - <@048b66>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @048b46> : 19                         load.z32
	<.main+4464 @048b47> : 1a                         load.z64
	<.main+4465 @048b48> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @048b4d> : 1f 40 78 04 00             load.ref <@047840> ;lenSlice(values: int64[]): int32
	<.main+4475 @048b52> : 02                         call
	<.main+4476 @048b53> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @048b57> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @048b5c> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @048b61> : 02                         call
	<.main+4491 @048b62> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@048b66> - <@048b83>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @048b66> : 19                         load.z32
	<.main+4496 @048b67> : 19                         load.z32
	<.main+4497 @048b68> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @048b6a> : 1f 40 78 04 00             load.ref <@047840> ;lenSlice(values: int64[]): int32
	<.main+4504 @048b6f> : 02                         call
	<.main+4505 @048b70> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @048b74> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @048b79> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @048b7e> : 02                         call
	<.main+4520 @048b7f> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@048b83> - <@048bab>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @048b83> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @048b88> : 19                         load.z32
	<.main+4530 @048b89> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @048b8e> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @048b92> : 1f 40 78 04 00             load.ref <@047840> ;lenSlice(values: int64[]): int32
	<.main+4544 @048b97> : 02                         call
	<.main+4545 @048b98> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @048b9c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @048ba1> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @048ba6> : 02                         call
	<.main+4560 @048ba7> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@048bab> - <@048bcc>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @048bab> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @048bb0> : 19                         load.z32
	<.main+4570 @048bb1> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @048bb3> : 1f 40 78 04 00             load.ref <@047840> ;lenSlice(values: int64[]): int32
	<.main+4577 @048bb8> : 02                         call
	<.main+4578 @048bb9> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @048bbd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @048bc2> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @048bc7> : 02                         call
	<.main+4593 @048bc8> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@048bcc> - <@048bed>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @048bcc> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @048bd1> : 19                         load.z32
	<.main+4603 @048bd2> : 11 08                      dup.x2 sp(8)
	<.main+4605 @048bd4> : 1f 40 78 04 00             load.ref <@047840> ;lenSlice(values: int64[]): int32
	<.main+4610 @048bd9> : 02                         call
	<.main+4611 @048bda> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @048bde> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @048be3> : 1f 38 66 04 00             load.ref <@046638> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @048be8> : 02                         call
	<.main+4626 @048be9> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@048bed> - <@048f14>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @048bed> : 19                         load.z32
	<.main+4631 @048bee> : 04 16 03 00                jmp <.main+5421 @048f04>
	test/lang/array.ci:119: (9 bytes: <@048bf2> - <@048bfb>): expected: int64 := int32(42 + i)
	<.main+4635 @048bf2> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @048bf7> : 10 01                      dup.x1 sp(1)
	<.main+4642 @048bf9> : 51                         add.i32
	<.main+4643 @048bfa> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@048bfb> - <@048c38>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @048bfb> : 11 00                      dup.x2 sp(0)
	<.main+4646 @048bfd> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @048c01> : 10 05                      dup.x1 sp(5)
	<.main+4652 @048c03> : 0d 08 00 00                mad.u32 8
	<.main+4656 @048c07> : 23                         load.i64
	<.main+4657 @048c08> : 67                         ceq.i64
	<.main+4658 @048c09> : 06 08 00 00                jz <.main+4666 @048c11>
	<.main+4662 @048c0d> : 04 2b 00 00                jmp <.main+4705 @048c38>
	<.main+4666 @048c11> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4671 @048c16> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @048c1b> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @048c20> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @048c25> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4691 @048c2a> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4696 @048c2f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @048c34> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@048c38> - <@048c73>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @048c38> : 11 00                      dup.x2 sp(0)
	<.main+4707 @048c3a> : 10 10                      dup.x1 sp(16)
	<.main+4709 @048c3c> : 10 05                      dup.x1 sp(5)
	<.main+4711 @048c3e> : 0d 08 00 00                mad.u32 8
	<.main+4715 @048c42> : 23                         load.i64
	<.main+4716 @048c43> : 67                         ceq.i64
	<.main+4717 @048c44> : 06 08 00 00                jz <.main+4725 @048c4c>
	<.main+4721 @048c48> : 04 2b 00 00                jmp <.main+4764 @048c73>
	<.main+4725 @048c4c> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4730 @048c51> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @048c56> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @048c5b> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @048c60> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4750 @048c65> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4755 @048c6a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @048c6f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@048c73> - <@048cae>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @048c73> : 11 00                      dup.x2 sp(0)
	<.main+4766 @048c75> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @048c77> : 10 05                      dup.x1 sp(5)
	<.main+4770 @048c79> : 0d 08 00 00                mad.u32 8
	<.main+4774 @048c7d> : 23                         load.i64
	<.main+4775 @048c7e> : 67                         ceq.i64
	<.main+4776 @048c7f> : 06 08 00 00                jz <.main+4784 @048c87>
	<.main+4780 @048c83> : 04 2b 00 00                jmp <.main+4823 @048cae>
	<.main+4784 @048c87> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4789 @048c8c> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @048c91> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @048c96> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @048c9b> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4809 @048ca0> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4814 @048ca5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @048caa> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@048cae> - <@048cf1>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @048cae> : 11 00                      dup.x2 sp(0)
	<.main+4825 @048cb0> : 1a                         load.z64
	<.main+4826 @048cb1> : 10 06                      dup.x1 sp(6)
	<.main+4828 @048cb3> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @048cb7> : 1f 48 78 04 00             load.ref <@047848> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @048cbc> : 02                         call
	<.main+4838 @048cbd> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @048cc1> : 67                         ceq.i64
	<.main+4843 @048cc2> : 06 08 00 00                jz <.main+4851 @048cca>
	<.main+4847 @048cc6> : 04 2b 00 00                jmp <.main+4890 @048cf1>
	<.main+4851 @048cca> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4856 @048ccf> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @048cd4> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @048cd9> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @048cde> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4876 @048ce3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4881 @048ce8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @048ced> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@048cf1> - <@048d32>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @048cf1> : 11 00                      dup.x2 sp(0)
	<.main+4892 @048cf3> : 1a                         load.z64
	<.main+4893 @048cf4> : 10 06                      dup.x1 sp(6)
	<.main+4895 @048cf6> : 10 13                      dup.x1 sp(19)
	<.main+4897 @048cf8> : 1f 48 78 04 00             load.ref <@047848> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @048cfd> : 02                         call
	<.main+4903 @048cfe> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @048d02> : 67                         ceq.i64
	<.main+4908 @048d03> : 06 08 00 00                jz <.main+4916 @048d0b>
	<.main+4912 @048d07> : 04 2b 00 00                jmp <.main+4955 @048d32>
	<.main+4916 @048d0b> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4921 @048d10> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @048d15> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @048d1a> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @048d1f> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4941 @048d24> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4946 @048d29> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @048d2e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@048d32> - <@048d73>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @048d32> : 11 00                      dup.x2 sp(0)
	<.main+4957 @048d34> : 1a                         load.z64
	<.main+4958 @048d35> : 10 06                      dup.x1 sp(6)
	<.main+4960 @048d37> : 10 11                      dup.x1 sp(17)
	<.main+4962 @048d39> : 1f 48 78 04 00             load.ref <@047848> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @048d3e> : 02                         call
	<.main+4968 @048d3f> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @048d43> : 67                         ceq.i64
	<.main+4973 @048d44> : 06 08 00 00                jz <.main+4981 @048d4c>
	<.main+4977 @048d48> : 04 2b 00 00                jmp <.main+5020 @048d73>
	<.main+4981 @048d4c> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+4986 @048d51> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @048d56> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @048d5b> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @048d60> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5006 @048d65> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5011 @048d6a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @048d6f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@048d73> - <@048db6>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @048d73> : 11 00                      dup.x2 sp(0)
	<.main+5022 @048d75> : 1a                         load.z64
	<.main+5023 @048d76> : 10 06                      dup.x1 sp(6)
	<.main+5025 @048d78> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @048d7c> : 1f 58 78 04 00             load.ref <@047858> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @048d81> : 02                         call
	<.main+5035 @048d82> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @048d86> : 67                         ceq.i64
	<.main+5040 @048d87> : 06 08 00 00                jz <.main+5048 @048d8f>
	<.main+5044 @048d8b> : 04 2b 00 00                jmp <.main+5087 @048db6>
	<.main+5048 @048d8f> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5053 @048d94> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @048d99> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @048d9e> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @048da3> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5073 @048da8> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5078 @048dad> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @048db2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@048db6> - <@048df7>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @048db6> : 11 00                      dup.x2 sp(0)
	<.main+5089 @048db8> : 1a                         load.z64
	<.main+5090 @048db9> : 10 06                      dup.x1 sp(6)
	<.main+5092 @048dbb> : 10 13                      dup.x1 sp(19)
	<.main+5094 @048dbd> : 1f 58 78 04 00             load.ref <@047858> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @048dc2> : 02                         call
	<.main+5100 @048dc3> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @048dc7> : 67                         ceq.i64
	<.main+5105 @048dc8> : 06 08 00 00                jz <.main+5113 @048dd0>
	<.main+5109 @048dcc> : 04 2b 00 00                jmp <.main+5152 @048df7>
	<.main+5113 @048dd0> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5118 @048dd5> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @048dda> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @048ddf> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @048de4> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5138 @048de9> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5143 @048dee> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @048df3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@048df7> - <@048e38>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @048df7> : 11 00                      dup.x2 sp(0)
	<.main+5154 @048df9> : 1a                         load.z64
	<.main+5155 @048dfa> : 10 06                      dup.x1 sp(6)
	<.main+5157 @048dfc> : 10 11                      dup.x1 sp(17)
	<.main+5159 @048dfe> : 1f 58 78 04 00             load.ref <@047858> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @048e03> : 02                         call
	<.main+5165 @048e04> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @048e08> : 67                         ceq.i64
	<.main+5170 @048e09> : 06 08 00 00                jz <.main+5178 @048e11>
	<.main+5174 @048e0d> : 04 2b 00 00                jmp <.main+5217 @048e38>
	<.main+5178 @048e11> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5183 @048e16> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @048e1b> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @048e20> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @048e25> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5203 @048e2a> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5208 @048e2f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @048e34> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@048e38> - <@048e80>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @048e38> : 11 00                      dup.x2 sp(0)
	<.main+5219 @048e3a> : 1a                         load.z64
	<.main+5220 @048e3b> : 10 06                      dup.x1 sp(6)
	<.main+5222 @048e3d> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @048e42> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @048e46> : 1f 68 78 04 00             load.ref <@047868> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @048e4b> : 02                         call
	<.main+5237 @048e4c> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @048e50> : 67                         ceq.i64
	<.main+5242 @048e51> : 06 08 00 00                jz <.main+5250 @048e59>
	<.main+5246 @048e55> : 04 2b 00 00                jmp <.main+5289 @048e80>
	<.main+5250 @048e59> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5255 @048e5e> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @048e63> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @048e68> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @048e6d> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5275 @048e72> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5280 @048e77> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @048e7c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@048e80> - <@048ec1>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @048e80> : 11 00                      dup.x2 sp(0)
	<.main+5291 @048e82> : 1a                         load.z64
	<.main+5292 @048e83> : 10 06                      dup.x1 sp(6)
	<.main+5294 @048e85> : 11 11                      dup.x2 sp(17)
	<.main+5296 @048e87> : 1f 68 78 04 00             load.ref <@047868> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @048e8c> : 02                         call
	<.main+5302 @048e8d> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @048e91> : 67                         ceq.i64
	<.main+5307 @048e92> : 06 08 00 00                jz <.main+5315 @048e9a>
	<.main+5311 @048e96> : 04 2b 00 00                jmp <.main+5354 @048ec1>
	<.main+5315 @048e9a> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5320 @048e9f> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @048ea4> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @048ea9> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @048eae> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5340 @048eb3> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5345 @048eb8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @048ebd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@048ec1> - <@048efc>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @048ec1> : 11 00                      dup.x2 sp(0)
	<.main+5356 @048ec3> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @048ec5> : 10 05                      dup.x1 sp(5)
	<.main+5360 @048ec7> : 0d 08 00 00                mad.u32 8
	<.main+5364 @048ecb> : 23                         load.i64
	<.main+5365 @048ecc> : 67                         ceq.i64
	<.main+5366 @048ecd> : 06 08 00 00                jz <.main+5374 @048ed5>
	<.main+5370 @048ed1> : 04 2b 00 00                jmp <.main+5413 @048efc>
	<.main+5374 @048ed5> : 1f 10 4a 03 00             load.ref <@034a10> ;"test/lang/array.ci"
	<.main+5379 @048eda> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @048edf> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @048ee4> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @048ee9> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5399 @048eee> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5404 @048ef3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @048ef8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @048efc> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@048f00> - <@048f04>): int32(i := int32(i + 1))
	<.main+5417 @048f00> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@048f04> - <@048f10>): bool(i < arrFixedNoInit.length)
	<.main+5421 @048f04> : 10 00                      dup.x1 sp(0)
	<.main+5423 @048f06> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @048f0b> : 58                         clt.i32
	<.main+5429 @048f0c> : 05 e6 fc ff                jnz <.main+4635 @048bf2>
	<.main+5433 @048f10> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@048f14> - <@048f50>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @048f14> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@048f18> - <@048f1f>): void(recordMemberTest.member := 10);
	<.main+5441 @048f18> : 1c 0a 00 00 00             load.c32 10
	<.main+5446 @048f1d> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@048f1f> - <@048f26>): void(recordMemberTest.constant := 11);
	<.main+5448 @048f1f> : 1c 0b 00 00 00             load.c32 11
	<.main+5453 @048f24> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@048f26> - <@048f2d>): void(recordMemberTest.memberInit := 12);
	<.main+5455 @048f26> : 1c 0c 00 00 00             load.c32 12
	<.main+5460 @048f2b> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@048f2d> - <@048f34>): void(recordMemberTest.constantInit := 13);
	<.main+5462 @048f2d> : 1c 0d 00 00 00             load.c32 13
	<.main+5467 @048f32> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@048f34> - <@048f3b>): void(recordMemberTest.memberRec.member := 14);
	<.main+5469 @048f34> : 1c 0e 00 00 00             load.c32 14
	<.main+5474 @048f39> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@048f3b> - <@048f42>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5476 @048f3b> : 1c 0f 00 00 00             load.c32 15
	<.main+5481 @048f40> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@048f42> - <@048f49>): void(recordMemberTest.constantRec.member := 16);
	<.main+5483 @048f42> : 1c 10 00 00 00             load.c32 16
	<.main+5488 @048f47> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@048f49> - <@048f50>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5490 @048f49> : 1c 11 00 00 00             load.c32 17
	<.main+5495 @048f4e> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:44: (24 bytes: <@048f50> - <@048f68>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @048f50> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:46: (7 bytes: <@048f54> - <@048f5b>): void(recordMethodTest.abstractMethod := globalFunction);
	<.main+5501 @048f54> : 1f 28 79 04 00             load.ref <@047928> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5506 @048f59> : 13 01                      set.x1 sp(1)
	:: (6 bytes: <@048f5b> - <@048f61>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5508 @048f5b> : 2a d0 78 04                load.m32 <@0478d0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5512 @048f5f> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@048f61> - <@048f68>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5514 @048f61> : 1f d8 78 04 00             load.ref <@0478d8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5519 @048f66> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:58: (19 bytes: <@048f68> - <@048f7b>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+5521 @048f68> : 12 00                      dup.x4 sp(0)
	<.main+5523 @048f6a> : 1c 01 00 00 00             load.c32 1
	<.main+5528 @048f6f> : 13 04                      set.x1 sp(4)
	<.main+5530 @048f71> : 1f a8 78 04 00             load.ref <@0478a8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5535 @048f76> : 02                         call
	<.main+5536 @048f77> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:59: (16 bytes: <@048f7b> - <@048f8b>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+5540 @048f7b> : 12 00                      dup.x4 sp(0)
	<.main+5542 @048f7d> : 1c 01 00 00 00             load.c32 1
	<.main+5547 @048f82> : 13 04                      set.x1 sp(4)
	<.main+5549 @048f84> : 10 06                      dup.x1 sp(6)
	<.main+5551 @048f86> : 02                         call
	<.main+5552 @048f87> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:75: (17 bytes: <@048f8b> - <@048f9c>): staticMethod(void(recordMethodTest, 2));
	<.main+5556 @048f8b> : 12 00                      dup.x4 sp(0)
	<.main+5558 @048f8d> : 1c 02 00 00 00             load.c32 2
	<.main+5563 @048f92> : 1f 50 79 04 00             load.ref <@047950> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5568 @048f97> : 02                         call
	<.main+5569 @048f98> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:76: (17 bytes: <@048f9c> - <@048fad>): virtualMethod(void(recordMethodTest, 2));
	<.main+5573 @048f9c> : 12 00                      dup.x4 sp(0)
	<.main+5575 @048f9e> : 1c 02 00 00 00             load.c32 2
	<.main+5580 @048fa3> : 1f 98 79 04 00             load.ref <@047998> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5585 @048fa8> : 02                         call
	<.main+5586 @048fa9> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:79: (19 bytes: <@048fad> - <@048fc0>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+5590 @048fad> : 12 00                      dup.x4 sp(0)
	<.main+5592 @048faf> : 1c 03 00 00 00             load.c32 3
	<.main+5597 @048fb4> : 13 04                      set.x1 sp(4)
	<.main+5599 @048fb6> : 1f a8 78 04 00             load.ref <@0478a8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5604 @048fbb> : 02                         call
	<.main+5605 @048fbc> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:80: (19 bytes: <@048fc0> - <@048fd3>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5609 @048fc0> : 12 00                      dup.x4 sp(0)
	<.main+5611 @048fc2> : 1c 03 00 00 00             load.c32 3
	<.main+5616 @048fc7> : 13 04                      set.x1 sp(4)
	<.main+5618 @048fc9> : 1f d8 78 04 00             load.ref <@0478d8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5623 @048fce> : 02                         call
	<.main+5624 @048fcf> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:81: (16 bytes: <@048fd3> - <@048fe3>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5628 @048fd3> : 12 00                      dup.x4 sp(0)
	<.main+5630 @048fd5> : 1c 03 00 00 00             load.c32 3
	<.main+5635 @048fda> : 13 04                      set.x1 sp(4)
	<.main+5637 @048fdc> : 10 06                      dup.x1 sp(6)
	<.main+5639 @048fde> : 02                         call
	<.main+5640 @048fdf> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@048fe3> - <@048ff9>): black: rgbU8 := {...}
	<.main+5644 @048fe3> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@048fe7> - <@048fed>): void(black.r := (0));
	<.main+5648 @048fe7> : 19                         load.z32
	<.main+5649 @048fe8> : 0a 06 00 00                load.sp(+6)
	<.main+5653 @048fec> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@048fed> - <@048ff3>): void(black.g := (0));
	<.main+5654 @048fed> : 19                         load.z32
	<.main+5655 @048fee> : 0a 05 00 00                load.sp(+5)
	<.main+5659 @048ff2> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@048ff3> - <@048ff9>): void(black.b := (0));
	<.main+5660 @048ff3> : 19                         load.z32
	<.main+5661 @048ff4> : 0a 04 00 00                load.sp(+4)
	<.main+5665 @048ff8> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@048ff9> - <@049013>): green: rgbU8 := {...}
	<.main+5666 @048ff9> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@048ffd> - <@049003>): void(green.r := (0));
	<.main+5670 @048ffd> : 19                         load.z32
	<.main+5671 @048ffe> : 0a 06 00 00                load.sp(+6)
	<.main+5675 @049002> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@049003> - <@04900d>): void(green.g := (255));
	<.main+5676 @049003> : 1c ff 00 00 00             load.c32 255
	<.main+5681 @049008> : 0a 05 00 00                load.sp(+5)
	<.main+5685 @04900c> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@04900d> - <@049013>): void(green.b := (0));
	<.main+5686 @04900d> : 19                         load.z32
	<.main+5687 @04900e> : 0a 04 00 00                load.sp(+4)
	<.main+5691 @049012> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@049013> - <@049035>): white: rgbU8 := {...}
	<.main+5692 @049013> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@049017> - <@049021>): void(white.r := (255));
	<.main+5696 @049017> : 1c ff 00 00 00             load.c32 255
	<.main+5701 @04901c> : 0a 06 00 00                load.sp(+6)
	<.main+5705 @049020> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@049021> - <@04902b>): void(white.g := (255));
	<.main+5706 @049021> : 1c ff 00 00 00             load.c32 255
	<.main+5711 @049026> : 0a 05 00 00                load.sp(+5)
	<.main+5715 @04902a> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@04902b> - <@049035>): void(white.b := (255));
	<.main+5716 @04902b> : 1c ff 00 00 00             load.c32 255
	<.main+5721 @049030> : 0a 04 00 00                load.sp(+4)
	<.main+5725 @049034> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@049035> - <@049040>): cyan: color := {...}
	<.main+5726 @049035> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@049039> - <@049040>): void(cyan.col := (65535));
	<.main+5730 @049039> : 1c ff ff 00 00             load.c32 65535
	<.main+5735 @04903e> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@049040> - <@04905a>): blue: color := {...}
	<.main+5737 @049040> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@049044> - <@04904a>): void(blue.rgb.r := (0));
	<.main+5741 @049044> : 19                         load.z32
	<.main+5742 @049045> : 0a 06 00 00                load.sp(+6)
	<.main+5746 @049049> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@04904a> - <@049050>): void(blue.rgb.g := (0));
	<.main+5747 @04904a> : 19                         load.z32
	<.main+5748 @04904b> : 0a 05 00 00                load.sp(+5)
	<.main+5752 @04904f> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@049050> - <@04905a>): void(blue.rgb.b := (255));
	<.main+5753 @049050> : 1c ff 00 00 00             load.c32 255
	<.main+5758 @049055> : 0a 04 00 00                load.sp(+4)
	<.main+5762 @049059> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@04905a> - <@04905f>): shift: int32 := 2
	<.main+5763 @04905a> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@04905f> - <@049064>): boolA: bool := true
	<.main+5768 @04905f> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@049064> - <@049069>): boolB: bool := bool(!false)
	<.main+5773 @049064> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@049069> - <@049074>): boolAnd: bool := bool(boolA & boolB)
	<.main+5778 @049069> : 0a 04 00 00                load.sp(+4)
	<.main+5782 @04906d> : 20                         load.i8
	<.main+5783 @04906e> : 0a 04 00 00                load.sp(+4)
	<.main+5787 @049072> : 20                         load.i8
	<.main+5788 @049073> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@049074> - <@04907f>): boolIor: bool := bool(boolA | boolB)
	<.main+5789 @049074> : 0a 08 00 00                load.sp(+8)
	<.main+5793 @049078> : 20                         load.i8
	<.main+5794 @049079> : 0a 08 00 00                load.sp(+8)
	<.main+5798 @04907d> : 20                         load.i8
	<.main+5799 @04907e> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@04907f> - <@04908a>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5800 @04907f> : 0a 0c 00 00                load.sp(+12)
	<.main+5804 @049083> : 20                         load.i8
	<.main+5805 @049084> : 0a 0c 00 00                load.sp(+12)
	<.main+5809 @049088> : 20                         load.i8
	<.main+5810 @049089> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@04908a> - <@049090>): boolNot: bool := bool(!boolB)
	<.main+5811 @04908a> : 0a 0c 00 00                load.sp(+12)
	<.main+5815 @04908e> : 20                         load.i8
	<.main+5816 @04908f> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@049090> - <@04909b>): boolCeq: bool := bool(boolA == boolB)
	<.main+5817 @049090> : 0a 14 00 00                load.sp(+20)
	<.main+5821 @049094> : 20                         load.i8
	<.main+5822 @049095> : 0a 14 00 00                load.sp(+20)
	<.main+5826 @049099> : 20                         load.i8
	<.main+5827 @04909a> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@04909b> - <@0490a7>): boolCne: bool := bool(boolA != boolB)
	<.main+5828 @04909b> : 0a 18 00 00                load.sp(+24)
	<.main+5832 @04909f> : 20                         load.i8
	<.main+5833 @0490a0> : 0a 18 00 00                load.sp(+24)
	<.main+5837 @0490a4> : 20                         load.i8
	<.main+5838 @0490a5> : 57                         ceq.i32
	<.main+5839 @0490a6> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@0490a7> - <@0490b2>): boolClt: bool := bool(boolA < boolB)
	<.main+5840 @0490a7> : 0a 1c 00 00                load.sp(+28)
	<.main+5844 @0490ab> : 20                         load.i8
	<.main+5845 @0490ac> : 0a 1c 00 00                load.sp(+28)
	<.main+5849 @0490b0> : 20                         load.i8
	<.main+5850 @0490b1> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@0490b2> - <@0490be>): boolCle: bool := bool(boolA <= boolB)
	<.main+5851 @0490b2> : 0a 20 00 00                load.sp(+32)
	<.main+5855 @0490b6> : 20                         load.i8
	<.main+5856 @0490b7> : 0a 20 00 00                load.sp(+32)
	<.main+5860 @0490bb> : 20                         load.i8
	<.main+5861 @0490bc> : 59                         cgt.i32
	<.main+5862 @0490bd> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@0490be> - <@0490c9>): boolCgt: bool := bool(boolA > boolB)
	<.main+5863 @0490be> : 0a 24 00 00                load.sp(+36)
	<.main+5867 @0490c2> : 20                         load.i8
	<.main+5868 @0490c3> : 0a 24 00 00                load.sp(+36)
	<.main+5872 @0490c7> : 20                         load.i8
	<.main+5873 @0490c8> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@0490c9> - <@0490d5>): boolCge: bool := bool(boolA >= boolB)
	<.main+5874 @0490c9> : 0a 28 00 00                load.sp(+40)
	<.main+5878 @0490cd> : 20                         load.i8
	<.main+5879 @0490ce> : 0a 28 00 00                load.sp(+40)
	<.main+5883 @0490d2> : 20                         load.i8
	<.main+5884 @0490d3> : 58                         clt.i32
	<.main+5885 @0490d4> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@0490d5> - <@0490da>): chrA: char := 'a'
	<.main+5886 @0490d5> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@0490da> - <@0490df>): chrB: char := 'b'
	<.main+5891 @0490da> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@0490df> - <@0490e4>): chrPls: char := char(+chrB)
	<.main+5896 @0490df> : 0a 00 00 00                load.sp(+0)
	<.main+5900 @0490e3> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@0490e4> - <@0490ea>): chrNeg: char := char(-chrB)
	<.main+5901 @0490e4> : 0a 04 00 00                load.sp(+4)
	<.main+5905 @0490e8> : 20                         load.i8
	<.main+5906 @0490e9> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@0490ea> - <@0490f0>): chrCmt: char := char(~chrB)
	<.main+5907 @0490ea> : 0a 08 00 00                load.sp(+8)
	<.main+5911 @0490ee> : 20                         load.i8
	<.main+5912 @0490ef> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@0490f0> - <@0490fb>): chrAdd: char := char(chrA + chrB)
	<.main+5913 @0490f0> : 0a 10 00 00                load.sp(+16)
	<.main+5917 @0490f4> : 20                         load.i8
	<.main+5918 @0490f5> : 0a 10 00 00                load.sp(+16)
	<.main+5922 @0490f9> : 20                         load.i8
	<.main+5923 @0490fa> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@0490fb> - <@049106>): chrSub: char := char(chrA - chrB)
	<.main+5924 @0490fb> : 0a 14 00 00                load.sp(+20)
	<.main+5928 @0490ff> : 20                         load.i8
	<.main+5929 @049100> : 0a 14 00 00                load.sp(+20)
	<.main+5933 @049104> : 20                         load.i8
	<.main+5934 @049105> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@049106> - <@049111>): chrMul: char := char(chrA * chrB)
	<.main+5935 @049106> : 0a 18 00 00                load.sp(+24)
	<.main+5939 @04910a> : 20                         load.i8
	<.main+5940 @04910b> : 0a 18 00 00                load.sp(+24)
	<.main+5944 @04910f> : 20                         load.i8
	<.main+5945 @049110> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@049111> - <@04911c>): chrDiv: char := char(chrA / chrB)
	<.main+5946 @049111> : 0a 1c 00 00                load.sp(+28)
	<.main+5950 @049115> : 20                         load.i8
	<.main+5951 @049116> : 0a 1c 00 00                load.sp(+28)
	<.main+5955 @04911a> : 20                         load.i8
	<.main+5956 @04911b> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@04911c> - <@049127>): chrMod: char := char(chrA % chrB)
	<.main+5957 @04911c> : 0a 20 00 00                load.sp(+32)
	<.main+5961 @049120> : 20                         load.i8
	<.main+5962 @049121> : 0a 20 00 00                load.sp(+32)
	<.main+5966 @049125> : 20                         load.i8
	<.main+5967 @049126> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@049127> - <@049132>): chrAnd: char := char(chrA & chrB)
	<.main+5968 @049127> : 0a 24 00 00                load.sp(+36)
	<.main+5972 @04912b> : 20                         load.i8
	<.main+5973 @04912c> : 0a 24 00 00                load.sp(+36)
	<.main+5977 @049130> : 20                         load.i8
	<.main+5978 @049131> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@049132> - <@04913d>): chrIor: char := char(chrA | chrB)
	<.main+5979 @049132> : 0a 28 00 00                load.sp(+40)
	<.main+5983 @049136> : 20                         load.i8
	<.main+5984 @049137> : 0a 28 00 00                load.sp(+40)
	<.main+5988 @04913b> : 20                         load.i8
	<.main+5989 @04913c> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@04913d> - <@049148>): chrXor: char := char(chrA ^ chrB)
	<.main+5990 @04913d> : 0a 2c 00 00                load.sp(+44)
	<.main+5994 @049141> : 20                         load.i8
	<.main+5995 @049142> : 0a 2c 00 00                load.sp(+44)
	<.main+5999 @049146> : 20                         load.i8
	<.main+6000 @049147> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@049148> - <@049150>): chrShl: char := int32((chrA) << shift)
	<.main+6001 @049148> : 0a 30 00 00                load.sp(+48)
	<.main+6005 @04914c> : 20                         load.i8
	<.main+6006 @04914d> : 10 1a                      dup.x1 sp(26)
	<.main+6008 @04914f> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@049150> - <@049158>): chrShr: char := int32((chrA) >> shift)
	<.main+6009 @049150> : 0a 34 00 00                load.sp(+52)
	<.main+6013 @049154> : 20                         load.i8
	<.main+6014 @049155> : 10 1b                      dup.x1 sp(27)
	<.main+6016 @049157> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@049158> - <@04915f>): chrNot: bool := bool(!(chrB))
	<.main+6017 @049158> : 0a 34 00 00                load.sp(+52)
	<.main+6021 @04915c> : 20                         load.i8
	<.main+6022 @04915d> : 5a                         i32.2bool
	<.main+6023 @04915e> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@04915f> - <@04916a>): chrCeq: bool := bool(chrA == chrB)
	<.main+6024 @04915f> : 0a 3c 00 00                load.sp(+60)
	<.main+6028 @049163> : 20                         load.i8
	<.main+6029 @049164> : 0a 3c 00 00                load.sp(+60)
	<.main+6033 @049168> : 20                         load.i8
	<.main+6034 @049169> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@04916a> - <@049176>): chrCne: bool := bool(chrA != chrB)
	<.main+6035 @04916a> : 0a 40 00 00                load.sp(+64)
	<.main+6039 @04916e> : 20                         load.i8
	<.main+6040 @04916f> : 0a 40 00 00                load.sp(+64)
	<.main+6044 @049173> : 20                         load.i8
	<.main+6045 @049174> : 57                         ceq.i32
	<.main+6046 @049175> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@049176> - <@049181>): chrClt: bool := bool(chrA < chrB)
	<.main+6047 @049176> : 0a 44 00 00                load.sp(+68)
	<.main+6051 @04917a> : 20                         load.i8
	<.main+6052 @04917b> : 0a 44 00 00                load.sp(+68)
	<.main+6056 @04917f> : 20                         load.i8
	<.main+6057 @049180> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@049181> - <@04918d>): chrCle: bool := bool(chrA <= chrB)
	<.main+6058 @049181> : 0a 48 00 00                load.sp(+72)
	<.main+6062 @049185> : 20                         load.i8
	<.main+6063 @049186> : 0a 48 00 00                load.sp(+72)
	<.main+6067 @04918a> : 20                         load.i8
	<.main+6068 @04918b> : 59                         cgt.i32
	<.main+6069 @04918c> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@04918d> - <@049198>): chrCgt: bool := bool(chrA > chrB)
	<.main+6070 @04918d> : 0a 4c 00 00                load.sp(+76)
	<.main+6074 @049191> : 20                         load.i8
	<.main+6075 @049192> : 0a 4c 00 00                load.sp(+76)
	<.main+6079 @049196> : 20                         load.i8
	<.main+6080 @049197> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@049198> - <@0491a4>): chrCge: bool := bool(chrA >= chrB)
	<.main+6081 @049198> : 0a 50 00 00                load.sp(+80)
	<.main+6085 @04919c> : 20                         load.i8
	<.main+6086 @04919d> : 0a 50 00 00                load.sp(+80)
	<.main+6090 @0491a1> : 20                         load.i8
	<.main+6091 @0491a2> : 58                         clt.i32
	<.main+6092 @0491a3> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@0491a4> - <@0491a9>): i8A: int8 := a
	<.main+6093 @0491a4> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@0491a9> - <@0491ae>): i8B: int8 := b
	<.main+6098 @0491a9> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@0491ae> - <@0491b3>): i8Pls: int8 := int8(+i8B)
	<.main+6103 @0491ae> : 0a 00 00 00                load.sp(+0)
	<.main+6107 @0491b2> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@0491b3> - <@0491b9>): i8Neg: int8 := int8(-i8B)
	<.main+6108 @0491b3> : 0a 04 00 00                load.sp(+4)
	<.main+6112 @0491b7> : 20                         load.i8
	<.main+6113 @0491b8> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@0491b9> - <@0491bf>): i8Cmt: int8 := int8(~i8B)
	<.main+6114 @0491b9> : 0a 08 00 00                load.sp(+8)
	<.main+6118 @0491bd> : 20                         load.i8
	<.main+6119 @0491be> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@0491bf> - <@0491ca>): i8Add: int8 := int8(i8A + i8B)
	<.main+6120 @0491bf> : 0a 10 00 00                load.sp(+16)
	<.main+6124 @0491c3> : 20                         load.i8
	<.main+6125 @0491c4> : 0a 10 00 00                load.sp(+16)
	<.main+6129 @0491c8> : 20                         load.i8
	<.main+6130 @0491c9> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@0491ca> - <@0491d5>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6131 @0491ca> : 0a 14 00 00                load.sp(+20)
	<.main+6135 @0491ce> : 20                         load.i8
	<.main+6136 @0491cf> : 0a 14 00 00                load.sp(+20)
	<.main+6140 @0491d3> : 20                         load.i8
	<.main+6141 @0491d4> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@0491d5> - <@0491e0>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6142 @0491d5> : 0a 18 00 00                load.sp(+24)
	<.main+6146 @0491d9> : 20                         load.i8
	<.main+6147 @0491da> : 0a 18 00 00                load.sp(+24)
	<.main+6151 @0491de> : 20                         load.i8
	<.main+6152 @0491df> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@0491e0> - <@0491eb>): i8Div: int8 := int8(i8A / i8B)
	<.main+6153 @0491e0> : 0a 1c 00 00                load.sp(+28)
	<.main+6157 @0491e4> : 20                         load.i8
	<.main+6158 @0491e5> : 0a 1c 00 00                load.sp(+28)
	<.main+6162 @0491e9> : 20                         load.i8
	<.main+6163 @0491ea> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@0491eb> - <@0491f6>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6164 @0491eb> : 0a 20 00 00                load.sp(+32)
	<.main+6168 @0491ef> : 20                         load.i8
	<.main+6169 @0491f0> : 0a 20 00 00                load.sp(+32)
	<.main+6173 @0491f4> : 20                         load.i8
	<.main+6174 @0491f5> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@0491f6> - <@049201>): i8And: int8 := int8(i8A & i8B)
	<.main+6175 @0491f6> : 0a 24 00 00                load.sp(+36)
	<.main+6179 @0491fa> : 20                         load.i8
	<.main+6180 @0491fb> : 0a 24 00 00                load.sp(+36)
	<.main+6184 @0491ff> : 20                         load.i8
	<.main+6185 @049200> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@049201> - <@04920c>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6186 @049201> : 0a 28 00 00                load.sp(+40)
	<.main+6190 @049205> : 20                         load.i8
	<.main+6191 @049206> : 0a 28 00 00                load.sp(+40)
	<.main+6195 @04920a> : 20                         load.i8
	<.main+6196 @04920b> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@04920c> - <@049217>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6197 @04920c> : 0a 2c 00 00                load.sp(+44)
	<.main+6201 @049210> : 20                         load.i8
	<.main+6202 @049211> : 0a 2c 00 00                load.sp(+44)
	<.main+6206 @049215> : 20                         load.i8
	<.main+6207 @049216> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@049217> - <@04921f>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6208 @049217> : 0a 30 00 00                load.sp(+48)
	<.main+6212 @04921b> : 20                         load.i8
	<.main+6213 @04921c> : 10 30                      dup.x1 sp(48)
	<.main+6215 @04921e> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@04921f> - <@049227>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6216 @04921f> : 0a 34 00 00                load.sp(+52)
	<.main+6220 @049223> : 20                         load.i8
	<.main+6221 @049224> : 10 31                      dup.x1 sp(49)
	<.main+6223 @049226> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@049227> - <@04922e>): i8Not: bool := bool(!(i8B))
	<.main+6224 @049227> : 0a 34 00 00                load.sp(+52)
	<.main+6228 @04922b> : 20                         load.i8
	<.main+6229 @04922c> : 5a                         i32.2bool
	<.main+6230 @04922d> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@04922e> - <@049239>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6231 @04922e> : 0a 3c 00 00                load.sp(+60)
	<.main+6235 @049232> : 20                         load.i8
	<.main+6236 @049233> : 0a 3c 00 00                load.sp(+60)
	<.main+6240 @049237> : 20                         load.i8
	<.main+6241 @049238> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@049239> - <@049245>): i8Cne: bool := bool(i8A != i8B)
	<.main+6242 @049239> : 0a 40 00 00                load.sp(+64)
	<.main+6246 @04923d> : 20                         load.i8
	<.main+6247 @04923e> : 0a 40 00 00                load.sp(+64)
	<.main+6251 @049242> : 20                         load.i8
	<.main+6252 @049243> : 57                         ceq.i32
	<.main+6253 @049244> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@049245> - <@049250>): i8Clt: bool := bool(i8A < i8B)
	<.main+6254 @049245> : 0a 44 00 00                load.sp(+68)
	<.main+6258 @049249> : 20                         load.i8
	<.main+6259 @04924a> : 0a 44 00 00                load.sp(+68)
	<.main+6263 @04924e> : 20                         load.i8
	<.main+6264 @04924f> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@049250> - <@04925c>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6265 @049250> : 0a 48 00 00                load.sp(+72)
	<.main+6269 @049254> : 20                         load.i8
	<.main+6270 @049255> : 0a 48 00 00                load.sp(+72)
	<.main+6274 @049259> : 20                         load.i8
	<.main+6275 @04925a> : 59                         cgt.i32
	<.main+6276 @04925b> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@04925c> - <@049267>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6277 @04925c> : 0a 4c 00 00                load.sp(+76)
	<.main+6281 @049260> : 20                         load.i8
	<.main+6282 @049261> : 0a 4c 00 00                load.sp(+76)
	<.main+6286 @049265> : 20                         load.i8
	<.main+6287 @049266> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@049267> - <@049273>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6288 @049267> : 0a 50 00 00                load.sp(+80)
	<.main+6292 @04926b> : 20                         load.i8
	<.main+6293 @04926c> : 0a 50 00 00                load.sp(+80)
	<.main+6297 @049270> : 20                         load.i8
	<.main+6298 @049271> : 58                         clt.i32
	<.main+6299 @049272> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@049273> - <@049278>): u8A: uint8 := a
	<.main+6300 @049273> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@049278> - <@04927d>): u8B: uint8 := b
	<.main+6305 @049278> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@04927d> - <@049282>): u8Pls: uint8 := uint8(+u8B)
	<.main+6310 @04927d> : 0a 00 00 00                load.sp(+0)
	<.main+6314 @049281> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@049282> - <@049288>): u8Neg: uint8 := uint8(-u8B)
	<.main+6315 @049282> : 0a 04 00 00                load.sp(+4)
	<.main+6319 @049286> : 20                         load.i8
	<.main+6320 @049287> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@049288> - <@04928e>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6321 @049288> : 0a 08 00 00                load.sp(+8)
	<.main+6325 @04928c> : 20                         load.i8
	<.main+6326 @04928d> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@04928e> - <@049299>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6327 @04928e> : 0a 10 00 00                load.sp(+16)
	<.main+6331 @049292> : 20                         load.i8
	<.main+6332 @049293> : 0a 10 00 00                load.sp(+16)
	<.main+6336 @049297> : 20                         load.i8
	<.main+6337 @049298> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@049299> - <@0492a4>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6338 @049299> : 0a 14 00 00                load.sp(+20)
	<.main+6342 @04929d> : 20                         load.i8
	<.main+6343 @04929e> : 0a 14 00 00                load.sp(+20)
	<.main+6347 @0492a2> : 20                         load.i8
	<.main+6348 @0492a3> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@0492a4> - <@0492af>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6349 @0492a4> : 0a 18 00 00                load.sp(+24)
	<.main+6353 @0492a8> : 20                         load.i8
	<.main+6354 @0492a9> : 0a 18 00 00                load.sp(+24)
	<.main+6358 @0492ad> : 20                         load.i8
	<.main+6359 @0492ae> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@0492af> - <@0492ba>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6360 @0492af> : 0a 1c 00 00                load.sp(+28)
	<.main+6364 @0492b3> : 20                         load.i8
	<.main+6365 @0492b4> : 0a 1c 00 00                load.sp(+28)
	<.main+6369 @0492b8> : 20                         load.i8
	<.main+6370 @0492b9> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@0492ba> - <@0492c5>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6371 @0492ba> : 0a 20 00 00                load.sp(+32)
	<.main+6375 @0492be> : 20                         load.i8
	<.main+6376 @0492bf> : 0a 20 00 00                load.sp(+32)
	<.main+6380 @0492c3> : 20                         load.i8
	<.main+6381 @0492c4> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@0492c5> - <@0492d0>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6382 @0492c5> : 0a 24 00 00                load.sp(+36)
	<.main+6386 @0492c9> : 20                         load.i8
	<.main+6387 @0492ca> : 0a 24 00 00                load.sp(+36)
	<.main+6391 @0492ce> : 20                         load.i8
	<.main+6392 @0492cf> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@0492d0> - <@0492db>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6393 @0492d0> : 0a 28 00 00                load.sp(+40)
	<.main+6397 @0492d4> : 20                         load.i8
	<.main+6398 @0492d5> : 0a 28 00 00                load.sp(+40)
	<.main+6402 @0492d9> : 20                         load.i8
	<.main+6403 @0492da> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@0492db> - <@0492e6>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6404 @0492db> : 0a 2c 00 00                load.sp(+44)
	<.main+6408 @0492df> : 20                         load.i8
	<.main+6409 @0492e0> : 0a 2c 00 00                load.sp(+44)
	<.main+6413 @0492e4> : 20                         load.i8
	<.main+6414 @0492e5> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@0492e6> - <@0492ee>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6415 @0492e6> : 0a 30 00 00                load.sp(+48)
	<.main+6419 @0492ea> : 20                         load.i8
	<.main+6420 @0492eb> : 10 46                      dup.x1 sp(70)
	<.main+6422 @0492ed> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@0492ee> - <@0492f6>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6423 @0492ee> : 0a 34 00 00                load.sp(+52)
	<.main+6427 @0492f2> : 20                         load.i8
	<.main+6428 @0492f3> : 10 47                      dup.x1 sp(71)
	<.main+6430 @0492f5> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@0492f6> - <@0492fd>): u8Not: bool := bool(!(u8B))
	<.main+6431 @0492f6> : 0a 34 00 00                load.sp(+52)
	<.main+6435 @0492fa> : 20                         load.i8
	<.main+6436 @0492fb> : 5a                         i32.2bool
	<.main+6437 @0492fc> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@0492fd> - <@049308>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6438 @0492fd> : 0a 3c 00 00                load.sp(+60)
	<.main+6442 @049301> : 20                         load.i8
	<.main+6443 @049302> : 0a 3c 00 00                load.sp(+60)
	<.main+6447 @049306> : 20                         load.i8
	<.main+6448 @049307> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@049308> - <@049314>): u8Cne: bool := bool(u8A != u8B)
	<.main+6449 @049308> : 0a 40 00 00                load.sp(+64)
	<.main+6453 @04930c> : 20                         load.i8
	<.main+6454 @04930d> : 0a 40 00 00                load.sp(+64)
	<.main+6458 @049311> : 20                         load.i8
	<.main+6459 @049312> : 57                         ceq.i32
	<.main+6460 @049313> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@049314> - <@04931f>): u8Clt: bool := bool(u8A < u8B)
	<.main+6461 @049314> : 0a 44 00 00                load.sp(+68)
	<.main+6465 @049318> : 20                         load.i8
	<.main+6466 @049319> : 0a 44 00 00                load.sp(+68)
	<.main+6470 @04931d> : 20                         load.i8
	<.main+6471 @04931e> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@04931f> - <@04932b>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6472 @04931f> : 0a 48 00 00                load.sp(+72)
	<.main+6476 @049323> : 20                         load.i8
	<.main+6477 @049324> : 0a 48 00 00                load.sp(+72)
	<.main+6481 @049328> : 20                         load.i8
	<.main+6482 @049329> : 39                         cgt.u32
	<.main+6483 @04932a> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@04932b> - <@049336>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6484 @04932b> : 0a 4c 00 00                load.sp(+76)
	<.main+6488 @04932f> : 20                         load.i8
	<.main+6489 @049330> : 0a 4c 00 00                load.sp(+76)
	<.main+6493 @049334> : 20                         load.i8
	<.main+6494 @049335> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@049336> - <@049342>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6495 @049336> : 0a 50 00 00                load.sp(+80)
	<.main+6499 @04933a> : 20                         load.i8
	<.main+6500 @04933b> : 0a 50 00 00                load.sp(+80)
	<.main+6504 @04933f> : 20                         load.i8
	<.main+6505 @049340> : 38                         clt.u32
	<.main+6506 @049341> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@049342> - <@049347>): i16A: int16 := a
	<.main+6507 @049342> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@049347> - <@04934c>): i16B: int16 := b
	<.main+6512 @049347> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@04934c> - <@049351>): i16Pls: int16 := int16(+i16B)
	<.main+6517 @04934c> : 0a 00 00 00                load.sp(+0)
	<.main+6521 @049350> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@049351> - <@049357>): i16Neg: int16 := int16(-i16B)
	<.main+6522 @049351> : 0a 04 00 00                load.sp(+4)
	<.main+6526 @049355> : 21                         load.i16
	<.main+6527 @049356> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@049357> - <@04935d>): i16Cmt: int16 := int16(~i16B)
	<.main+6528 @049357> : 0a 08 00 00                load.sp(+8)
	<.main+6532 @04935b> : 21                         load.i16
	<.main+6533 @04935c> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@04935d> - <@049368>): i16Add: int16 := int16(i16A + i16B)
	<.main+6534 @04935d> : 0a 10 00 00                load.sp(+16)
	<.main+6538 @049361> : 21                         load.i16
	<.main+6539 @049362> : 0a 10 00 00                load.sp(+16)
	<.main+6543 @049366> : 21                         load.i16
	<.main+6544 @049367> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@049368> - <@049373>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6545 @049368> : 0a 14 00 00                load.sp(+20)
	<.main+6549 @04936c> : 21                         load.i16
	<.main+6550 @04936d> : 0a 14 00 00                load.sp(+20)
	<.main+6554 @049371> : 21                         load.i16
	<.main+6555 @049372> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@049373> - <@04937e>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6556 @049373> : 0a 18 00 00                load.sp(+24)
	<.main+6560 @049377> : 21                         load.i16
	<.main+6561 @049378> : 0a 18 00 00                load.sp(+24)
	<.main+6565 @04937c> : 21                         load.i16
	<.main+6566 @04937d> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@04937e> - <@049389>): i16Div: int16 := int16(i16A / i16B)
	<.main+6567 @04937e> : 0a 1c 00 00                load.sp(+28)
	<.main+6571 @049382> : 21                         load.i16
	<.main+6572 @049383> : 0a 1c 00 00                load.sp(+28)
	<.main+6576 @049387> : 21                         load.i16
	<.main+6577 @049388> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@049389> - <@049394>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6578 @049389> : 0a 20 00 00                load.sp(+32)
	<.main+6582 @04938d> : 21                         load.i16
	<.main+6583 @04938e> : 0a 20 00 00                load.sp(+32)
	<.main+6587 @049392> : 21                         load.i16
	<.main+6588 @049393> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@049394> - <@04939f>): i16And: int16 := int16(i16A & i16B)
	<.main+6589 @049394> : 0a 24 00 00                load.sp(+36)
	<.main+6593 @049398> : 21                         load.i16
	<.main+6594 @049399> : 0a 24 00 00                load.sp(+36)
	<.main+6598 @04939d> : 21                         load.i16
	<.main+6599 @04939e> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@04939f> - <@0493aa>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6600 @04939f> : 0a 28 00 00                load.sp(+40)
	<.main+6604 @0493a3> : 21                         load.i16
	<.main+6605 @0493a4> : 0a 28 00 00                load.sp(+40)
	<.main+6609 @0493a8> : 21                         load.i16
	<.main+6610 @0493a9> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@0493aa> - <@0493b5>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6611 @0493aa> : 0a 2c 00 00                load.sp(+44)
	<.main+6615 @0493ae> : 21                         load.i16
	<.main+6616 @0493af> : 0a 2c 00 00                load.sp(+44)
	<.main+6620 @0493b3> : 21                         load.i16
	<.main+6621 @0493b4> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@0493b5> - <@0493bd>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6622 @0493b5> : 0a 30 00 00                load.sp(+48)
	<.main+6626 @0493b9> : 21                         load.i16
	<.main+6627 @0493ba> : 10 5c                      dup.x1 sp(92)
	<.main+6629 @0493bc> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@0493bd> - <@0493c5>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6630 @0493bd> : 0a 34 00 00                load.sp(+52)
	<.main+6634 @0493c1> : 21                         load.i16
	<.main+6635 @0493c2> : 10 5d                      dup.x1 sp(93)
	<.main+6637 @0493c4> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@0493c5> - <@0493cc>): i16Not: bool := bool(!(i16B))
	<.main+6638 @0493c5> : 0a 34 00 00                load.sp(+52)
	<.main+6642 @0493c9> : 21                         load.i16
	<.main+6643 @0493ca> : 5a                         i32.2bool
	<.main+6644 @0493cb> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@0493cc> - <@0493d7>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6645 @0493cc> : 0a 3c 00 00                load.sp(+60)
	<.main+6649 @0493d0> : 21                         load.i16
	<.main+6650 @0493d1> : 0a 3c 00 00                load.sp(+60)
	<.main+6654 @0493d5> : 21                         load.i16
	<.main+6655 @0493d6> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@0493d7> - <@0493e3>): i16Cne: bool := bool(i16A != i16B)
	<.main+6656 @0493d7> : 0a 40 00 00                load.sp(+64)
	<.main+6660 @0493db> : 21                         load.i16
	<.main+6661 @0493dc> : 0a 40 00 00                load.sp(+64)
	<.main+6665 @0493e0> : 21                         load.i16
	<.main+6666 @0493e1> : 57                         ceq.i32
	<.main+6667 @0493e2> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@0493e3> - <@0493ee>): i16Clt: bool := bool(i16A < i16B)
	<.main+6668 @0493e3> : 0a 44 00 00                load.sp(+68)
	<.main+6672 @0493e7> : 21                         load.i16
	<.main+6673 @0493e8> : 0a 44 00 00                load.sp(+68)
	<.main+6677 @0493ec> : 21                         load.i16
	<.main+6678 @0493ed> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@0493ee> - <@0493fa>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6679 @0493ee> : 0a 48 00 00                load.sp(+72)
	<.main+6683 @0493f2> : 21                         load.i16
	<.main+6684 @0493f3> : 0a 48 00 00                load.sp(+72)
	<.main+6688 @0493f7> : 21                         load.i16
	<.main+6689 @0493f8> : 59                         cgt.i32
	<.main+6690 @0493f9> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@0493fa> - <@049405>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6691 @0493fa> : 0a 4c 00 00                load.sp(+76)
	<.main+6695 @0493fe> : 21                         load.i16
	<.main+6696 @0493ff> : 0a 4c 00 00                load.sp(+76)
	<.main+6700 @049403> : 21                         load.i16
	<.main+6701 @049404> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@049405> - <@049411>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6702 @049405> : 0a 50 00 00                load.sp(+80)
	<.main+6706 @049409> : 21                         load.i16
	<.main+6707 @04940a> : 0a 50 00 00                load.sp(+80)
	<.main+6711 @04940e> : 21                         load.i16
	<.main+6712 @04940f> : 58                         clt.i32
	<.main+6713 @049410> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@049411> - <@049416>): u16A: uint16 := a
	<.main+6714 @049411> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@049416> - <@04941b>): u16B: uint16 := b
	<.main+6719 @049416> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@04941b> - <@049420>): u16Pls: uint16 := uint16(+u16B)
	<.main+6724 @04941b> : 0a 00 00 00                load.sp(+0)
	<.main+6728 @04941f> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@049420> - <@049426>): u16Neg: uint16 := uint16(-u16B)
	<.main+6729 @049420> : 0a 04 00 00                load.sp(+4)
	<.main+6733 @049424> : 21                         load.i16
	<.main+6734 @049425> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@049426> - <@04942c>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6735 @049426> : 0a 08 00 00                load.sp(+8)
	<.main+6739 @04942a> : 21                         load.i16
	<.main+6740 @04942b> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@04942c> - <@049437>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6741 @04942c> : 0a 10 00 00                load.sp(+16)
	<.main+6745 @049430> : 21                         load.i16
	<.main+6746 @049431> : 0a 10 00 00                load.sp(+16)
	<.main+6750 @049435> : 21                         load.i16
	<.main+6751 @049436> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@049437> - <@049442>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6752 @049437> : 0a 14 00 00                load.sp(+20)
	<.main+6756 @04943b> : 21                         load.i16
	<.main+6757 @04943c> : 0a 14 00 00                load.sp(+20)
	<.main+6761 @049440> : 21                         load.i16
	<.main+6762 @049441> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@049442> - <@04944d>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6763 @049442> : 0a 18 00 00                load.sp(+24)
	<.main+6767 @049446> : 21                         load.i16
	<.main+6768 @049447> : 0a 18 00 00                load.sp(+24)
	<.main+6772 @04944b> : 21                         load.i16
	<.main+6773 @04944c> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@04944d> - <@049458>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6774 @04944d> : 0a 1c 00 00                load.sp(+28)
	<.main+6778 @049451> : 21                         load.i16
	<.main+6779 @049452> : 0a 1c 00 00                load.sp(+28)
	<.main+6783 @049456> : 21                         load.i16
	<.main+6784 @049457> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@049458> - <@049463>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6785 @049458> : 0a 20 00 00                load.sp(+32)
	<.main+6789 @04945c> : 21                         load.i16
	<.main+6790 @04945d> : 0a 20 00 00                load.sp(+32)
	<.main+6794 @049461> : 21                         load.i16
	<.main+6795 @049462> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@049463> - <@04946e>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6796 @049463> : 0a 24 00 00                load.sp(+36)
	<.main+6800 @049467> : 21                         load.i16
	<.main+6801 @049468> : 0a 24 00 00                load.sp(+36)
	<.main+6805 @04946c> : 21                         load.i16
	<.main+6806 @04946d> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@04946e> - <@049479>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6807 @04946e> : 0a 28 00 00                load.sp(+40)
	<.main+6811 @049472> : 21                         load.i16
	<.main+6812 @049473> : 0a 28 00 00                load.sp(+40)
	<.main+6816 @049477> : 21                         load.i16
	<.main+6817 @049478> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@049479> - <@049484>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6818 @049479> : 0a 2c 00 00                load.sp(+44)
	<.main+6822 @04947d> : 21                         load.i16
	<.main+6823 @04947e> : 0a 2c 00 00                load.sp(+44)
	<.main+6827 @049482> : 21                         load.i16
	<.main+6828 @049483> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@049484> - <@04948c>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6829 @049484> : 0a 30 00 00                load.sp(+48)
	<.main+6833 @049488> : 21                         load.i16
	<.main+6834 @049489> : 10 72                      dup.x1 sp(114)
	<.main+6836 @04948b> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@04948c> - <@049494>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6837 @04948c> : 0a 34 00 00                load.sp(+52)
	<.main+6841 @049490> : 21                         load.i16
	<.main+6842 @049491> : 10 73                      dup.x1 sp(115)
	<.main+6844 @049493> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@049494> - <@04949b>): u16Not: bool := bool(!(u16B))
	<.main+6845 @049494> : 0a 34 00 00                load.sp(+52)
	<.main+6849 @049498> : 21                         load.i16
	<.main+6850 @049499> : 5a                         i32.2bool
	<.main+6851 @04949a> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@04949b> - <@0494a6>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6852 @04949b> : 0a 3c 00 00                load.sp(+60)
	<.main+6856 @04949f> : 21                         load.i16
	<.main+6857 @0494a0> : 0a 3c 00 00                load.sp(+60)
	<.main+6861 @0494a4> : 21                         load.i16
	<.main+6862 @0494a5> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@0494a6> - <@0494b2>): u16Cne: bool := bool(u16A != u16B)
	<.main+6863 @0494a6> : 0a 40 00 00                load.sp(+64)
	<.main+6867 @0494aa> : 21                         load.i16
	<.main+6868 @0494ab> : 0a 40 00 00                load.sp(+64)
	<.main+6872 @0494af> : 21                         load.i16
	<.main+6873 @0494b0> : 57                         ceq.i32
	<.main+6874 @0494b1> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@0494b2> - <@0494bd>): u16Clt: bool := bool(u16A < u16B)
	<.main+6875 @0494b2> : 0a 44 00 00                load.sp(+68)
	<.main+6879 @0494b6> : 21                         load.i16
	<.main+6880 @0494b7> : 0a 44 00 00                load.sp(+68)
	<.main+6884 @0494bb> : 21                         load.i16
	<.main+6885 @0494bc> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@0494bd> - <@0494c9>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6886 @0494bd> : 0a 48 00 00                load.sp(+72)
	<.main+6890 @0494c1> : 21                         load.i16
	<.main+6891 @0494c2> : 0a 48 00 00                load.sp(+72)
	<.main+6895 @0494c6> : 21                         load.i16
	<.main+6896 @0494c7> : 39                         cgt.u32
	<.main+6897 @0494c8> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@0494c9> - <@0494d4>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6898 @0494c9> : 0a 4c 00 00                load.sp(+76)
	<.main+6902 @0494cd> : 21                         load.i16
	<.main+6903 @0494ce> : 0a 4c 00 00                load.sp(+76)
	<.main+6907 @0494d2> : 21                         load.i16
	<.main+6908 @0494d3> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@0494d4> - <@0494e0>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6909 @0494d4> : 0a 50 00 00                load.sp(+80)
	<.main+6913 @0494d8> : 21                         load.i16
	<.main+6914 @0494d9> : 0a 50 00 00                load.sp(+80)
	<.main+6918 @0494dd> : 21                         load.i16
	<.main+6919 @0494de> : 38                         clt.u32
	<.main+6920 @0494df> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@0494e0> - <@0494e5>): i32A: int32 := a
	<.main+6921 @0494e0> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@0494e5> - <@0494ea>): i32B: int32 := b
	<.main+6926 @0494e5> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@0494ea> - <@0494ec>): i32Pls: int32 := int32(+i32B)
	<.main+6931 @0494ea> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@0494ec> - <@0494ef>): i32Neg: int32 := int32(-i32B)
	<.main+6933 @0494ec> : 10 01                      dup.x1 sp(1)
	<.main+6935 @0494ee> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@0494ef> - <@0494f2>): i32Cmt: int32 := int32(~i32B)
	<.main+6936 @0494ef> : 10 02                      dup.x1 sp(2)
	<.main+6938 @0494f1> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@0494f2> - <@0494f7>): i32Add: int32 := int32(i32A + i32B)
	<.main+6939 @0494f2> : 10 04                      dup.x1 sp(4)
	<.main+6941 @0494f4> : 10 04                      dup.x1 sp(4)
	<.main+6943 @0494f6> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@0494f7> - <@0494fc>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6944 @0494f7> : 10 05                      dup.x1 sp(5)
	<.main+6946 @0494f9> : 10 05                      dup.x1 sp(5)
	<.main+6948 @0494fb> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@0494fc> - <@049501>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6949 @0494fc> : 10 06                      dup.x1 sp(6)
	<.main+6951 @0494fe> : 10 06                      dup.x1 sp(6)
	<.main+6953 @049500> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@049501> - <@049506>): i32Div: int32 := int32(i32A / i32B)
	<.main+6954 @049501> : 10 07                      dup.x1 sp(7)
	<.main+6956 @049503> : 10 07                      dup.x1 sp(7)
	<.main+6958 @049505> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@049506> - <@04950b>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6959 @049506> : 10 08                      dup.x1 sp(8)
	<.main+6961 @049508> : 10 08                      dup.x1 sp(8)
	<.main+6963 @04950a> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@04950b> - <@049510>): i32And: int32 := int32(i32A & i32B)
	<.main+6964 @04950b> : 10 09                      dup.x1 sp(9)
	<.main+6966 @04950d> : 10 09                      dup.x1 sp(9)
	<.main+6968 @04950f> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@049510> - <@049515>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6969 @049510> : 10 0a                      dup.x1 sp(10)
	<.main+6971 @049512> : 10 0a                      dup.x1 sp(10)
	<.main+6973 @049514> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@049515> - <@04951a>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6974 @049515> : 10 0b                      dup.x1 sp(11)
	<.main+6976 @049517> : 10 0b                      dup.x1 sp(11)
	<.main+6978 @049519> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@04951a> - <@04951f>): i32Shl: int32 := int32(i32A << shift)
	<.main+6979 @04951a> : 10 0c                      dup.x1 sp(12)
	<.main+6981 @04951c> : 10 88                      dup.x1 sp(136)
	<.main+6983 @04951e> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@04951f> - <@049524>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6984 @04951f> : 10 0d                      dup.x1 sp(13)
	<.main+6986 @049521> : 10 89                      dup.x1 sp(137)
	<.main+6988 @049523> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@049524> - <@049528>): i32Not: bool := bool(!(i32B))
	<.main+6989 @049524> : 10 0d                      dup.x1 sp(13)
	<.main+6991 @049526> : 5a                         i32.2bool
	<.main+6992 @049527> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@049528> - <@04952d>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6993 @049528> : 10 0f                      dup.x1 sp(15)
	<.main+6995 @04952a> : 10 0f                      dup.x1 sp(15)
	<.main+6997 @04952c> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@04952d> - <@049533>): i32Cne: bool := bool(i32A != i32B)
	<.main+6998 @04952d> : 10 10                      dup.x1 sp(16)
	<.main+7000 @04952f> : 10 10                      dup.x1 sp(16)
	<.main+7002 @049531> : 57                         ceq.i32
	<.main+7003 @049532> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@049533> - <@049538>): i32Clt: bool := bool(i32A < i32B)
	<.main+7004 @049533> : 10 11                      dup.x1 sp(17)
	<.main+7006 @049535> : 10 11                      dup.x1 sp(17)
	<.main+7008 @049537> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@049538> - <@04953e>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7009 @049538> : 10 12                      dup.x1 sp(18)
	<.main+7011 @04953a> : 10 12                      dup.x1 sp(18)
	<.main+7013 @04953c> : 59                         cgt.i32
	<.main+7014 @04953d> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@04953e> - <@049543>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7015 @04953e> : 10 13                      dup.x1 sp(19)
	<.main+7017 @049540> : 10 13                      dup.x1 sp(19)
	<.main+7019 @049542> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@049543> - <@049549>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7020 @049543> : 10 14                      dup.x1 sp(20)
	<.main+7022 @049545> : 10 14                      dup.x1 sp(20)
	<.main+7024 @049547> : 58                         clt.i32
	<.main+7025 @049548> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@049549> - <@04954e>): u32A: uint32 := a
	<.main+7026 @049549> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@04954e> - <@049553>): u32B: uint32 := b
	<.main+7031 @04954e> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@049553> - <@049555>): u32Pls: uint32 := uint32(+u32B)
	<.main+7036 @049553> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@049555> - <@049558>): u32Neg: uint32 := uint32(-u32B)
	<.main+7038 @049555> : 10 01                      dup.x1 sp(1)
	<.main+7040 @049557> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@049558> - <@04955b>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7041 @049558> : 10 02                      dup.x1 sp(2)
	<.main+7043 @04955a> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@04955b> - <@049560>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7044 @04955b> : 10 04                      dup.x1 sp(4)
	<.main+7046 @04955d> : 10 04                      dup.x1 sp(4)
	<.main+7048 @04955f> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@049560> - <@049565>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7049 @049560> : 10 05                      dup.x1 sp(5)
	<.main+7051 @049562> : 10 05                      dup.x1 sp(5)
	<.main+7053 @049564> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@049565> - <@04956a>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7054 @049565> : 10 06                      dup.x1 sp(6)
	<.main+7056 @049567> : 10 06                      dup.x1 sp(6)
	<.main+7058 @049569> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@04956a> - <@04956f>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7059 @04956a> : 10 07                      dup.x1 sp(7)
	<.main+7061 @04956c> : 10 07                      dup.x1 sp(7)
	<.main+7063 @04956e> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@04956f> - <@049574>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7064 @04956f> : 10 08                      dup.x1 sp(8)
	<.main+7066 @049571> : 10 08                      dup.x1 sp(8)
	<.main+7068 @049573> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@049574> - <@049579>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7069 @049574> : 10 09                      dup.x1 sp(9)
	<.main+7071 @049576> : 10 09                      dup.x1 sp(9)
	<.main+7073 @049578> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@049579> - <@04957e>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7074 @049579> : 10 0a                      dup.x1 sp(10)
	<.main+7076 @04957b> : 10 0a                      dup.x1 sp(10)
	<.main+7078 @04957d> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@04957e> - <@049583>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7079 @04957e> : 10 0b                      dup.x1 sp(11)
	<.main+7081 @049580> : 10 0b                      dup.x1 sp(11)
	<.main+7083 @049582> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@049583> - <@049588>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7084 @049583> : 10 0c                      dup.x1 sp(12)
	<.main+7086 @049585> : 10 9e                      dup.x1 sp(158)
	<.main+7088 @049587> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@049588> - <@04958d>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7089 @049588> : 10 0d                      dup.x1 sp(13)
	<.main+7091 @04958a> : 10 9f                      dup.x1 sp(159)
	<.main+7093 @04958c> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@04958d> - <@049591>): u32Not: bool := bool(!(u32B))
	<.main+7094 @04958d> : 10 0d                      dup.x1 sp(13)
	<.main+7096 @04958f> : 5a                         i32.2bool
	<.main+7097 @049590> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@049591> - <@049596>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7098 @049591> : 10 0f                      dup.x1 sp(15)
	<.main+7100 @049593> : 10 0f                      dup.x1 sp(15)
	<.main+7102 @049595> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@049596> - <@04959c>): u32Cne: bool := bool(u32A != u32B)
	<.main+7103 @049596> : 10 10                      dup.x1 sp(16)
	<.main+7105 @049598> : 10 10                      dup.x1 sp(16)
	<.main+7107 @04959a> : 57                         ceq.i32
	<.main+7108 @04959b> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@04959c> - <@0495a1>): u32Clt: bool := bool(u32A < u32B)
	<.main+7109 @04959c> : 10 11                      dup.x1 sp(17)
	<.main+7111 @04959e> : 10 11                      dup.x1 sp(17)
	<.main+7113 @0495a0> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@0495a1> - <@0495a7>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7114 @0495a1> : 10 12                      dup.x1 sp(18)
	<.main+7116 @0495a3> : 10 12                      dup.x1 sp(18)
	<.main+7118 @0495a5> : 39                         cgt.u32
	<.main+7119 @0495a6> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@0495a7> - <@0495ac>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7120 @0495a7> : 10 13                      dup.x1 sp(19)
	<.main+7122 @0495a9> : 10 13                      dup.x1 sp(19)
	<.main+7124 @0495ab> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@0495ac> - <@0495b2>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7125 @0495ac> : 10 14                      dup.x1 sp(20)
	<.main+7127 @0495ae> : 10 14                      dup.x1 sp(20)
	<.main+7129 @0495b0> : 38                         clt.u32
	<.main+7130 @0495b1> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@0495b2> - <@0495bb>): i64A: int64 := a
	<.main+7131 @0495b2> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@0495bb> - <@0495c4>): i64B: int64 := b
	<.main+7140 @0495bb> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@0495c4> - <@0495c6>): i64Pls: int64 := int64(+i64B)
	<.main+7149 @0495c4> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@0495c6> - <@0495c9>): i64Neg: int64 := int64(-i64B)
	<.main+7151 @0495c6> : 11 02                      dup.x2 sp(2)
	<.main+7153 @0495c8> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@0495c9> - <@0495cc>): i64Cmt: int64 := int64(~i64B)
	<.main+7154 @0495c9> : 11 04                      dup.x2 sp(4)
	<.main+7156 @0495cb> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@0495cc> - <@0495d1>): i64Add: int64 := int64(i64A + i64B)
	<.main+7157 @0495cc> : 11 08                      dup.x2 sp(8)
	<.main+7159 @0495ce> : 11 08                      dup.x2 sp(8)
	<.main+7161 @0495d0> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@0495d1> - <@0495d6>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7162 @0495d1> : 11 0a                      dup.x2 sp(10)
	<.main+7164 @0495d3> : 11 0a                      dup.x2 sp(10)
	<.main+7166 @0495d5> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@0495d6> - <@0495db>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7167 @0495d6> : 11 0c                      dup.x2 sp(12)
	<.main+7169 @0495d8> : 11 0c                      dup.x2 sp(12)
	<.main+7171 @0495da> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@0495db> - <@0495e0>): i64Div: int64 := int64(i64A / i64B)
	<.main+7172 @0495db> : 11 0e                      dup.x2 sp(14)
	<.main+7174 @0495dd> : 11 0e                      dup.x2 sp(14)
	<.main+7176 @0495df> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@0495e0> - <@0495e5>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7177 @0495e0> : 11 10                      dup.x2 sp(16)
	<.main+7179 @0495e2> : 11 10                      dup.x2 sp(16)
	<.main+7181 @0495e4> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@0495e5> - <@0495ea>): i64And: int64 := int64(i64A & i64B)
	<.main+7182 @0495e5> : 11 12                      dup.x2 sp(18)
	<.main+7184 @0495e7> : 11 12                      dup.x2 sp(18)
	<.main+7186 @0495e9> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@0495ea> - <@0495ef>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7187 @0495ea> : 11 14                      dup.x2 sp(20)
	<.main+7189 @0495ec> : 11 14                      dup.x2 sp(20)
	<.main+7191 @0495ee> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@0495ef> - <@0495f4>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7192 @0495ef> : 11 16                      dup.x2 sp(22)
	<.main+7194 @0495f1> : 11 16                      dup.x2 sp(22)
	<.main+7196 @0495f3> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@0495f4> - <@0495f9>): i64Shl: int64 := int64(i64A << shift)
	<.main+7197 @0495f4> : 11 18                      dup.x2 sp(24)
	<.main+7199 @0495f6> : 10 c2                      dup.x1 sp(194)
	<.main+7201 @0495f8> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@0495f9> - <@0495fe>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7202 @0495f9> : 11 1a                      dup.x2 sp(26)
	<.main+7204 @0495fb> : 10 c4                      dup.x1 sp(196)
	<.main+7206 @0495fd> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@0495fe> - <@049602>): i64Not: bool := bool(!(i64B))
	<.main+7207 @0495fe> : 11 1a                      dup.x2 sp(26)
	<.main+7209 @049600> : 6c                         i64.2bool
	<.main+7210 @049601> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@049602> - <@049607>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7211 @049602> : 11 1d                      dup.x2 sp(29)
	<.main+7213 @049604> : 11 1d                      dup.x2 sp(29)
	<.main+7215 @049606> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@049607> - <@04960d>): i64Cne: bool := bool(i64A != i64B)
	<.main+7216 @049607> : 11 1e                      dup.x2 sp(30)
	<.main+7218 @049609> : 11 1e                      dup.x2 sp(30)
	<.main+7220 @04960b> : 67                         ceq.i64
	<.main+7221 @04960c> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@04960d> - <@049612>): i64Clt: bool := bool(i64A < i64B)
	<.main+7222 @04960d> : 11 1f                      dup.x2 sp(31)
	<.main+7224 @04960f> : 11 1f                      dup.x2 sp(31)
	<.main+7226 @049611> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@049612> - <@049618>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7227 @049612> : 11 20                      dup.x2 sp(32)
	<.main+7229 @049614> : 11 20                      dup.x2 sp(32)
	<.main+7231 @049616> : 69                         cgt.i64
	<.main+7232 @049617> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@049618> - <@04961d>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7233 @049618> : 11 21                      dup.x2 sp(33)
	<.main+7235 @04961a> : 11 21                      dup.x2 sp(33)
	<.main+7237 @04961c> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@04961d> - <@049623>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7238 @04961d> : 11 22                      dup.x2 sp(34)
	<.main+7240 @04961f> : 11 22                      dup.x2 sp(34)
	<.main+7242 @049621> : 68                         clt.i64
	<.main+7243 @049622> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@049623> - <@04962c>): u64A: uint64 := a
	<.main+7244 @049623> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@04962c> - <@049635>): u64B: uint64 := b
	<.main+7253 @04962c> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@049635> - <@049637>): u64Pls: uint64 := uint64(+u64B)
	<.main+7262 @049635> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@049637> - <@04963a>): u64Neg: uint64 := uint64(-u64B)
	<.main+7264 @049637> : 11 02                      dup.x2 sp(2)
	<.main+7266 @049639> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@04963a> - <@04963d>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7267 @04963a> : 11 04                      dup.x2 sp(4)
	<.main+7269 @04963c> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@04963d> - <@049642>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7270 @04963d> : 11 08                      dup.x2 sp(8)
	<.main+7272 @04963f> : 11 08                      dup.x2 sp(8)
	<.main+7274 @049641> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@049642> - <@049647>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7275 @049642> : 11 0a                      dup.x2 sp(10)
	<.main+7277 @049644> : 11 0a                      dup.x2 sp(10)
	<.main+7279 @049646> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@049647> - <@04964c>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7280 @049647> : 11 0c                      dup.x2 sp(12)
	<.main+7282 @049649> : 11 0c                      dup.x2 sp(12)
	<.main+7284 @04964b> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@04964c> - <@049651>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7285 @04964c> : 11 0e                      dup.x2 sp(14)
	<.main+7287 @04964e> : 11 0e                      dup.x2 sp(14)
	<.main+7289 @049650> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@049651> - <@049656>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7290 @049651> : 11 10                      dup.x2 sp(16)
	<.main+7292 @049653> : 11 10                      dup.x2 sp(16)
	<.main+7294 @049655> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@049656> - <@04965b>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7295 @049656> : 11 12                      dup.x2 sp(18)
	<.main+7297 @049658> : 11 12                      dup.x2 sp(18)
	<.main+7299 @04965a> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@04965b> - <@049660>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7300 @04965b> : 11 14                      dup.x2 sp(20)
	<.main+7302 @04965d> : 11 14                      dup.x2 sp(20)
	<.main+7304 @04965f> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@049660> - <@049665>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7305 @049660> : 11 16                      dup.x2 sp(22)
	<.main+7307 @049662> : 11 16                      dup.x2 sp(22)
	<.main+7309 @049664> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@049665> - <@04966a>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7310 @049665> : 11 18                      dup.x2 sp(24)
	<.main+7312 @049667> : 10 e7                      dup.x1 sp(231)
	<.main+7314 @049669> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@04966a> - <@04966f>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7315 @04966a> : 11 1a                      dup.x2 sp(26)
	<.main+7317 @04966c> : 10 e9                      dup.x1 sp(233)
	<.main+7319 @04966e> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@04966f> - <@049673>): u64Not: bool := bool(!(u64B))
	<.main+7320 @04966f> : 11 1a                      dup.x2 sp(26)
	<.main+7322 @049671> : 6c                         i64.2bool
	<.main+7323 @049672> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@049673> - <@049678>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7324 @049673> : 11 1d                      dup.x2 sp(29)
	<.main+7326 @049675> : 11 1d                      dup.x2 sp(29)
	<.main+7328 @049677> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@049678> - <@04967e>): u64Cne: bool := bool(u64A != u64B)
	<.main+7329 @049678> : 11 1e                      dup.x2 sp(30)
	<.main+7331 @04967a> : 11 1e                      dup.x2 sp(30)
	<.main+7333 @04967c> : 67                         ceq.i64
	<.main+7334 @04967d> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@04967e> - <@049683>): u64Clt: bool := bool(u64A < u64B)
	<.main+7335 @04967e> : 11 1f                      dup.x2 sp(31)
	<.main+7337 @049680> : 11 1f                      dup.x2 sp(31)
	<.main+7339 @049682> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@049683> - <@049689>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7340 @049683> : 11 20                      dup.x2 sp(32)
	<.main+7342 @049685> : 11 20                      dup.x2 sp(32)
	<.main+7344 @049687> : 49                         cgt.u64
	<.main+7345 @049688> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@049689> - <@04968e>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7346 @049689> : 11 21                      dup.x2 sp(33)
	<.main+7348 @04968b> : 11 21                      dup.x2 sp(33)
	<.main+7350 @04968d> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@04968e> - <@049694>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7351 @04968e> : 11 22                      dup.x2 sp(34)
	<.main+7353 @049690> : 11 22                      dup.x2 sp(34)
	<.main+7355 @049692> : 48                         clt.u64
	<.main+7356 @049693> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@049694> - <@049699>): f32A: float32 := a
	<.main+7357 @049694> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@049699> - <@04969e>): f32B: float32 := b
	<.main+7362 @049699> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@04969e> - <@0496a0>): f32Pls: float32 := float32(+f32B)
	<.main+7367 @04969e> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@0496a0> - <@0496a3>): f32Neg: float32 := float32(-f32B)
	<.main+7369 @0496a0> : 10 01                      dup.x1 sp(1)
	<.main+7371 @0496a2> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@0496a3> - <@0496a8>): f32Add: float32 := float32(f32A + f32B)
	<.main+7372 @0496a3> : 10 03                      dup.x1 sp(3)
	<.main+7374 @0496a5> : 10 03                      dup.x1 sp(3)
	<.main+7376 @0496a7> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@0496a8> - <@0496ad>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7377 @0496a8> : 10 04                      dup.x1 sp(4)
	<.main+7379 @0496aa> : 10 04                      dup.x1 sp(4)
	<.main+7381 @0496ac> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@0496ad> - <@0496b2>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7382 @0496ad> : 10 05                      dup.x1 sp(5)
	<.main+7384 @0496af> : 10 05                      dup.x1 sp(5)
	<.main+7386 @0496b1> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@0496b2> - <@0496b7>): f32Div: float32 := float32(f32A / f32B)
	<.main+7387 @0496b2> : 10 06                      dup.x1 sp(6)
	<.main+7389 @0496b4> : 10 06                      dup.x1 sp(6)
	<.main+7391 @0496b6> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@0496b7> - <@0496bc>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7392 @0496b7> : 10 07                      dup.x1 sp(7)
	<.main+7394 @0496b9> : 10 07                      dup.x1 sp(7)
	<.main+7396 @0496bb> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@0496bc> - <@0496c0>): f32Not: bool := bool(!(f32B))
	<.main+7397 @0496bc> : 10 07                      dup.x1 sp(7)
	<.main+7399 @0496be> : 7b                         f32.2bool
	<.main+7400 @0496bf> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@0496c0> - <@0496c5>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7401 @0496c0> : 10 09                      dup.x1 sp(9)
	<.main+7403 @0496c2> : 10 09                      dup.x1 sp(9)
	<.main+7405 @0496c4> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@0496c5> - <@0496cb>): f32Cne: bool := bool(f32A != f32B)
	<.main+7406 @0496c5> : 10 0a                      dup.x1 sp(10)
	<.main+7408 @0496c7> : 10 0a                      dup.x1 sp(10)
	<.main+7410 @0496c9> : 77                         ceq.f32
	<.main+7411 @0496ca> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@0496cb> - <@0496d0>): f32Clt: bool := bool(f32A < f32B)
	<.main+7412 @0496cb> : 10 0b                      dup.x1 sp(11)
	<.main+7414 @0496cd> : 10 0b                      dup.x1 sp(11)
	<.main+7416 @0496cf> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@0496d0> - <@0496d6>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7417 @0496d0> : 10 0c                      dup.x1 sp(12)
	<.main+7419 @0496d2> : 10 0c                      dup.x1 sp(12)
	<.main+7421 @0496d4> : 79                         cgt.f32
	<.main+7422 @0496d5> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@0496d6> - <@0496db>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7423 @0496d6> : 10 0d                      dup.x1 sp(13)
	<.main+7425 @0496d8> : 10 0d                      dup.x1 sp(13)
	<.main+7427 @0496da> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@0496db> - <@0496e1>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7428 @0496db> : 10 0e                      dup.x1 sp(14)
	<.main+7430 @0496dd> : 10 0e                      dup.x1 sp(14)
	<.main+7432 @0496df> : 78                         clt.f32
	<.main+7433 @0496e0> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@0496e1> - <@0496ea>): f64A: float64 := a
	<.main+7434 @0496e1> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@0496ea> - <@0496f3>): f64B: float64 := b
	<.main+7443 @0496ea> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@0496f3> - <@0496f5>): f64Pls: float64 := float64(+f64B)
	<.main+7452 @0496f3> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@0496f5> - <@0496f8>): f64Neg: float64 := float64(-f64B)
	<.main+7454 @0496f5> : 11 02                      dup.x2 sp(2)
	<.main+7456 @0496f7> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@0496f8> - <@0496fd>): f64Add: float64 := float64(f64A + f64B)
	<.main+7457 @0496f8> : 11 06                      dup.x2 sp(6)
	<.main+7459 @0496fa> : 11 06                      dup.x2 sp(6)
	<.main+7461 @0496fc> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@0496fd> - <@049702>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7462 @0496fd> : 11 08                      dup.x2 sp(8)
	<.main+7464 @0496ff> : 11 08                      dup.x2 sp(8)
	<.main+7466 @049701> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@049702> - <@049707>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7467 @049702> : 11 0a                      dup.x2 sp(10)
	<.main+7469 @049704> : 11 0a                      dup.x2 sp(10)
	<.main+7471 @049706> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@049707> - <@04970c>): f64Div: float64 := float64(f64A / f64B)
	<.main+7472 @049707> : 11 0c                      dup.x2 sp(12)
	<.main+7474 @049709> : 11 0c                      dup.x2 sp(12)
	<.main+7476 @04970b> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@04970c> - <@049711>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7477 @04970c> : 11 0e                      dup.x2 sp(14)
	<.main+7479 @04970e> : 11 0e                      dup.x2 sp(14)
	<.main+7481 @049710> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@049711> - <@049715>): f64Not: bool := bool(!(f64B))
	<.main+7482 @049711> : 11 0e                      dup.x2 sp(14)
	<.main+7484 @049713> : 8d                         f64.2bool
	<.main+7485 @049714> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@049715> - <@04971a>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7486 @049715> : 11 11                      dup.x2 sp(17)
	<.main+7488 @049717> : 11 11                      dup.x2 sp(17)
	<.main+7490 @049719> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@04971a> - <@049720>): f64Cne: bool := bool(f64A != f64B)
	<.main+7491 @04971a> : 11 12                      dup.x2 sp(18)
	<.main+7493 @04971c> : 11 12                      dup.x2 sp(18)
	<.main+7495 @04971e> : 87                         ceq.f64
	<.main+7496 @04971f> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@049720> - <@049725>): f64Clt: bool := bool(f64A < f64B)
	<.main+7497 @049720> : 11 13                      dup.x2 sp(19)
	<.main+7499 @049722> : 11 13                      dup.x2 sp(19)
	<.main+7501 @049724> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@049725> - <@04972b>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7502 @049725> : 11 14                      dup.x2 sp(20)
	<.main+7504 @049727> : 11 14                      dup.x2 sp(20)
	<.main+7506 @049729> : 89                         cgt.f64
	<.main+7507 @04972a> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@04972b> - <@049730>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7508 @04972b> : 11 15                      dup.x2 sp(21)
	<.main+7510 @04972d> : 11 15                      dup.x2 sp(21)
	<.main+7512 @04972f> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@049730> - <@049736>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7513 @049730> : 11 16                      dup.x2 sp(22)
	<.main+7515 @049732> : 11 16                      dup.x2 sp(22)
	<.main+7517 @049734> : 88                         clt.f64
	<.main+7518 @049735> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@049736> - <@04973b>): ptrA: pointer := null
	<.main+7519 @049736> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@04973b> - <@04973f>): ptrB: pointer := pointer(shift)
	<.main+7524 @04973b> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@04973f> - <@049744>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7528 @04973f> : 10 01                      dup.x1 sp(1)
	<.main+7530 @049741> : 10 01                      dup.x1 sp(1)
	<.main+7532 @049743> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@049744> - <@04974a>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7533 @049744> : 10 02                      dup.x1 sp(2)
	<.main+7535 @049746> : 10 02                      dup.x1 sp(2)
	<.main+7537 @049748> : 57                         ceq.i32
	<.main+7538 @049749> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@04974a> - <@049771>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7539 @04974a> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7544 @04974f> : 1c 04 00 00 00             load.c32 4
	<.main+7549 @049754> : 1c 0e 00 00 00             load.c32 14
	<.main+7554 @049759> : 1c 01 00 00 00             load.c32 1
	<.main+7559 @04975e> : 1f b9 31 04 00             load.ref <@0431b9> ;"0 == 0"
	<.main+7564 @049763> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7569 @049768> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7574 @04976d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@049771> - <@049798>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7578 @049771> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7583 @049776> : 1c 0c 00 00 00             load.c32 12
	<.main+7588 @04977b> : 1c 0e 00 00 00             load.c32 14
	<.main+7593 @049780> : 1c 03 00 00 00             load.c32 3
	<.main+7598 @049785> : 1f b9 31 04 00             load.ref <@0431b9> ;"0 == 0"
	<.main+7603 @04978a> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7608 @04978f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7613 @049794> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@049798> - <@0497bf>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7617 @049798> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7622 @04979d> : 1c 16 00 00 00             load.c32 22
	<.main+7627 @0497a2> : 1c 0e 00 00 00             load.c32 14
	<.main+7632 @0497a7> : 1c 06 00 00 00             load.c32 6
	<.main+7637 @0497ac> : 1f b9 31 04 00             load.ref <@0431b9> ;"0 == 0"
	<.main+7642 @0497b1> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7647 @0497b6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7652 @0497bb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@0497bf> - <@0497c0>): t: int32 := 0
	<.main+7656 @0497bf> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@0497c0> - <@0497ee>): if (bool(t == 0))
	<.main+7657 @0497c0> : 10 00                      dup.x1 sp(0)
	<.main+7659 @0497c2> : 19                         load.z32
	<.main+7660 @0497c3> : 57                         ceq.i32
	<.main+7661 @0497c4> : 06 2a 00 00                jz <.main+7703 @0497ee>
	test/lang/statementIf.ci:29: (38 bytes: <@0497c8> - <@0497ee>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7665 @0497c8> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7670 @0497cd> : 1c 1d 00 00 00             load.c32 29
	<.main+7675 @0497d2> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @0497d7> : 1c 07 00 00 00             load.c32 7
	<.main+7685 @0497dc> : 1f c7 31 04 00             load.ref <@0431c7> ;"t == 0"
	<.main+7690 @0497e1> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7695 @0497e6> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @0497ea> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@0497ee> - <@04981c>): if (bool(t != 0))
	<.main+7703 @0497ee> : 10 00                      dup.x1 sp(0)
	<.main+7705 @0497f0> : 19                         load.z32
	<.main+7706 @0497f1> : 57                         ceq.i32
	<.main+7707 @0497f2> : 05 2a 00 00                jnz <.main+7749 @04981c>
	test/lang/statementIf.ci:33: (38 bytes: <@0497f6> - <@04981c>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7711 @0497f6> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7716 @0497fb> : 1c 21 00 00 00             load.c32 33
	<.main+7721 @049800> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @049805> : 1c 08 00 00 00             load.c32 8
	<.main+7731 @04980a> : 1f ce 31 04 00             load.ref <@0431ce> ;"t != 0"
	<.main+7736 @04980f> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7741 @049814> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @049818> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@04981c> - <@049874>): if (bool(t == 0))
	<.main+7749 @04981c> : 10 00                      dup.x1 sp(0)
	<.main+7751 @04981e> : 19                         load.z32
	<.main+7752 @04981f> : 57                         ceq.i32
	<.main+7753 @049820> : 06 2e 00 00                jz <.main+7799 @04984e>
	test/lang/statementIf.ci:37: (38 bytes: <@049824> - <@04984a>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7757 @049824> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7762 @049829> : 1c 25 00 00 00             load.c32 37
	<.main+7767 @04982e> : 1c 0e 00 00 00             load.c32 14
	<.main+7772 @049833> : 1c 09 00 00 00             load.c32 9
	<.main+7777 @049838> : 1f c7 31 04 00             load.ref <@0431c7> ;"t == 0"
	<.main+7782 @04983d> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7787 @049842> : 0a 18 00 00                load.sp(+24)
	<.main+7791 @049846> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7795 @04984a> : 04 2a 00 00                jmp <.main+7837 @049874>
	test/lang/statementIf.ci:40: (38 bytes: <@04984e> - <@049874>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7799 @04984e> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7804 @049853> : 1c 28 00 00 00             load.c32 40
	<.main+7809 @049858> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @04985d> : 1c 0a 00 00 00             load.c32 10
	<.main+7819 @049862> : 1f ce 31 04 00             load.ref <@0431ce> ;"t != 0"
	<.main+7824 @049867> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7829 @04986c> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @049870> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@049874> - <@0498cc>): if (bool(t != 0))
	<.main+7837 @049874> : 10 00                      dup.x1 sp(0)
	<.main+7839 @049876> : 19                         load.z32
	<.main+7840 @049877> : 57                         ceq.i32
	<.main+7841 @049878> : 05 2e 00 00                jnz <.main+7887 @0498a6>
	test/lang/statementIf.ci:44: (38 bytes: <@04987c> - <@0498a2>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7845 @04987c> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7850 @049881> : 1c 2c 00 00 00             load.c32 44
	<.main+7855 @049886> : 1c 0e 00 00 00             load.c32 14
	<.main+7860 @04988b> : 1c 0b 00 00 00             load.c32 11
	<.main+7865 @049890> : 1f ce 31 04 00             load.ref <@0431ce> ;"t != 0"
	<.main+7870 @049895> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7875 @04989a> : 0a 18 00 00                load.sp(+24)
	<.main+7879 @04989e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7883 @0498a2> : 04 2a 00 00                jmp <.main+7925 @0498cc>
	test/lang/statementIf.ci:47: (38 bytes: <@0498a6> - <@0498cc>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7887 @0498a6> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7892 @0498ab> : 1c 2f 00 00 00             load.c32 47
	<.main+7897 @0498b0> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @0498b5> : 1c 0c 00 00 00             load.c32 12
	<.main+7907 @0498ba> : 1f c7 31 04 00             load.ref <@0431c7> ;"t == 0"
	<.main+7912 @0498bf> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7917 @0498c4> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @0498c8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@0498cc> - <@049a32>): if (bool(t == 0))
	<.main+7925 @0498cc> : 10 00                      dup.x1 sp(0)
	<.main+7927 @0498ce> : 19                         load.z32
	<.main+7928 @0498cf> : 57                         ceq.i32
	<.main+7929 @0498d0> : 06 2e 00 00                jz <.main+7975 @0498fe>
	test/lang/statementIf.ci:51: (38 bytes: <@0498d4> - <@0498fa>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7933 @0498d4> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7938 @0498d9> : 1c 33 00 00 00             load.c32 51
	<.main+7943 @0498de> : 1c 0e 00 00 00             load.c32 14
	<.main+7948 @0498e3> : 1c 09 00 00 00             load.c32 9
	<.main+7953 @0498e8> : 1f c7 31 04 00             load.ref <@0431c7> ;"t == 0"
	<.main+7958 @0498ed> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7963 @0498f2> : 0a 18 00 00                load.sp(+24)
	<.main+7967 @0498f6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7971 @0498fa> : 04 38 01 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:53: (308 bytes: <@0498fe> - <@049a32>): if (bool(t == 1))
	<.main+7975 @0498fe> : 10 00                      dup.x1 sp(0)
	<.main+7977 @049900> : 1c 01 00 00 00             load.c32 1
	<.main+7982 @049905> : 57                         ceq.i32
	<.main+7983 @049906> : 06 2e 00 00                jz <.main+8029 @049934>
	test/lang/statementIf.ci:54: (38 bytes: <@04990a> - <@049930>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7987 @04990a> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+7992 @04990f> : 1c 36 00 00 00             load.c32 54
	<.main+7997 @049914> : 1c 0e 00 00 00             load.c32 14
	<.main+8002 @049919> : 1c 0a 00 00 00             load.c32 10
	<.main+8007 @04991e> : 1f d5 31 04 00             load.ref <@0431d5> ;"t == 1"
	<.main+8012 @049923> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8017 @049928> : 0a 18 00 00                load.sp(+24)
	<.main+8021 @04992c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8025 @049930> : 04 02 01 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:56: (254 bytes: <@049934> - <@049a32>): if (bool(t == 2))
	<.main+8029 @049934> : 10 00                      dup.x1 sp(0)
	<.main+8031 @049936> : 1c 02 00 00 00             load.c32 2
	<.main+8036 @04993b> : 57                         ceq.i32
	<.main+8037 @04993c> : 06 2e 00 00                jz <.main+8083 @04996a>
	test/lang/statementIf.ci:57: (38 bytes: <@049940> - <@049966>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8041 @049940> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+8046 @049945> : 1c 39 00 00 00             load.c32 57
	<.main+8051 @04994a> : 1c 0e 00 00 00             load.c32 14
	<.main+8056 @04994f> : 1c 0a 00 00 00             load.c32 10
	<.main+8061 @049954> : 1f dc 31 04 00             load.ref <@0431dc> ;"t == 2"
	<.main+8066 @049959> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8071 @04995e> : 0a 18 00 00                load.sp(+24)
	<.main+8075 @049962> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8079 @049966> : 04 cc 00 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:59: (200 bytes: <@04996a> - <@049a32>): if (bool(t == 3))
	<.main+8083 @04996a> : 10 00                      dup.x1 sp(0)
	<.main+8085 @04996c> : 1c 03 00 00 00             load.c32 3
	<.main+8090 @049971> : 57                         ceq.i32
	<.main+8091 @049972> : 06 2e 00 00                jz <.main+8137 @0499a0>
	test/lang/statementIf.ci:60: (38 bytes: <@049976> - <@04999c>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8095 @049976> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+8100 @04997b> : 1c 3c 00 00 00             load.c32 60
	<.main+8105 @049980> : 1c 0e 00 00 00             load.c32 14
	<.main+8110 @049985> : 1c 0a 00 00 00             load.c32 10
	<.main+8115 @04998a> : 1f e3 31 04 00             load.ref <@0431e3> ;"t == 3"
	<.main+8120 @04998f> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8125 @049994> : 0a 18 00 00                load.sp(+24)
	<.main+8129 @049998> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8133 @04999c> : 04 96 00 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:62: (146 bytes: <@0499a0> - <@049a32>): if (bool(t == 4))
	<.main+8137 @0499a0> : 10 00                      dup.x1 sp(0)
	<.main+8139 @0499a2> : 1c 04 00 00 00             load.c32 4
	<.main+8144 @0499a7> : 57                         ceq.i32
	<.main+8145 @0499a8> : 06 2e 00 00                jz <.main+8191 @0499d6>
	test/lang/statementIf.ci:63: (38 bytes: <@0499ac> - <@0499d2>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8149 @0499ac> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+8154 @0499b1> : 1c 3f 00 00 00             load.c32 63
	<.main+8159 @0499b6> : 1c 0e 00 00 00             load.c32 14
	<.main+8164 @0499bb> : 1c 0a 00 00 00             load.c32 10
	<.main+8169 @0499c0> : 1f ea 31 04 00             load.ref <@0431ea> ;"t == 4"
	<.main+8174 @0499c5> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8179 @0499ca> : 0a 18 00 00                load.sp(+24)
	<.main+8183 @0499ce> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8187 @0499d2> : 04 60 00 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:65: (92 bytes: <@0499d6> - <@049a32>): if (bool(t == 5))
	<.main+8191 @0499d6> : 10 00                      dup.x1 sp(0)
	<.main+8193 @0499d8> : 1c 05 00 00 00             load.c32 5
	<.main+8198 @0499dd> : 57                         ceq.i32
	<.main+8199 @0499de> : 06 2e 00 00                jz <.main+8245 @049a0c>
	test/lang/statementIf.ci:66: (38 bytes: <@0499e2> - <@049a08>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8203 @0499e2> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+8208 @0499e7> : 1c 42 00 00 00             load.c32 66
	<.main+8213 @0499ec> : 1c 0e 00 00 00             load.c32 14
	<.main+8218 @0499f1> : 1c 0a 00 00 00             load.c32 10
	<.main+8223 @0499f6> : 1f f1 31 04 00             load.ref <@0431f1> ;"t == 5"
	<.main+8228 @0499fb> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8233 @049a00> : 0a 18 00 00                load.sp(+24)
	<.main+8237 @049a04> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8241 @049a08> : 04 2a 00 00                jmp <.main+8283 @049a32>
	test/lang/statementIf.ci:69: (38 bytes: <@049a0c> - <@049a32>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8245 @049a0c> : 1f a0 31 04 00             load.ref <@0431a0> ;"test/lang/statementIf.ci"
	<.main+8250 @049a11> : 1c 45 00 00 00             load.c32 69
	<.main+8255 @049a16> : 1c 0e 00 00 00             load.c32 14
	<.main+8260 @049a1b> : 1c 0a 00 00 00             load.c32 10
	<.main+8265 @049a20> : 1f f8 31 04 00             load.ref <@0431f8> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8270 @049a25> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8275 @049a2a> : 0a 18 00 00                load.sp(+24)
	<.main+8279 @049a2e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@049a32> - <@049a61>): for ( ; ; )
	<.main+8283 @049a32> : 04 2b 00 00                jmp <.main+8326 @049a5d>
	test/lang/statementFor.ci:4: (35 bytes: <@049a36> - <@049a59>): debug("for ( ; ; )");
	<.main+8287 @049a36> : 1f d0 32 04 00             load.ref <@0432d0> ;"test/lang/statementFor.ci"
	<.main+8292 @049a3b> : 1c 04 00 00 00             load.c32 4
	<.main+8297 @049a40> : 1c 0e 00 00 00             load.c32 14
	<.main+8302 @049a45> : 19                         load.z32
	<.main+8303 @049a46> : 1f ea 32 04 00             load.ref <@0432ea> ;"for ( ; ; )"
	<.main+8308 @049a4b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+8313 @049a50> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8318 @049a55> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@049a59> - <@049a5d>): break;
	<.main+8322 @049a59> : 04 08 00 00                jmp <.main+8330 @049a61>
	:: (4 bytes: <@049a5d> - <@049a61>)
	<.main+8326 @049a5d> : 04 d9 ff ff                jmp <.main+8287 @049a36>
	test/lang/statementFor.ci:8: (59 bytes: <@049a61> - <@049a9c>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8330 @049a61> : 19                         load.z32
	<.main+8331 @049a62> : 04 2a 00 00                jmp <.main+8373 @049a8c>
	test/lang/statementFor.ci:9: (34 bytes: <@049a66> - <@049a88>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8335 @049a66> : 1f d0 32 04 00             load.ref <@0432d0> ;"test/lang/statementFor.ci"
	<.main+8340 @049a6b> : 1c 09 00 00 00             load.c32 9
	<.main+8345 @049a70> : 1c 0e 00 00 00             load.c32 14
	<.main+8350 @049a75> : 19                         load.z32
	<.main+8351 @049a76> : 1f f6 32 04 00             load.ref <@0432f6> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8356 @049a7b> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8361 @049a80> : 0a 18 00 00                load.sp(+24)
	<.main+8365 @049a84> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@049a88> - <@049a8c>): int32(i := int32(i + 1))
	<.main+8369 @049a88> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@049a8c> - <@049a98>): bool(i < 2)
	<.main+8373 @049a8c> : 10 00                      dup.x1 sp(0)
	<.main+8375 @049a8e> : 1c 02 00 00 00             load.c32 2
	<.main+8380 @049a93> : 58                         clt.i32
	<.main+8381 @049a94> : 05 d2 ff ff                jnz <.main+8335 @049a66>
	<.main+8385 @049a98> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@049a9c> - <@049a9d>): forIdx: int32
	<.main+8389 @049a9c> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@049a9d> - <@049ad6>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8390 @049a9d> : 19                         load.z32
	<.main+8391 @049a9e> : 13 01                      set.x1 sp(1)
	<.main+8393 @049aa0> : 04 2a 00 00                jmp <.main+8435 @049aca>
	test/lang/statementFor.ci:14: (34 bytes: <@049aa4> - <@049ac6>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8397 @049aa4> : 1f d0 32 04 00             load.ref <@0432d0> ;"test/lang/statementFor.ci"
	<.main+8402 @049aa9> : 1c 0e 00 00 00             load.c32 14
	<.main+8407 @049aae> : 1c 0e 00 00 00             load.c32 14
	<.main+8412 @049ab3> : 19                         load.z32
	<.main+8413 @049ab4> : 1f 1c 33 04 00             load.ref <@04331c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8418 @049ab9> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8423 @049abe> : 0a 18 00 00                load.sp(+24)
	<.main+8427 @049ac2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@049ac6> - <@049aca>): int32(forIdx := int32(forIdx + 1))
	<.main+8431 @049ac6> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@049aca> - <@049ad6>): bool(forIdx < 2)
	<.main+8435 @049aca> : 10 00                      dup.x1 sp(0)
	<.main+8437 @049acc> : 1c 02 00 00 00             load.c32 2
	<.main+8442 @049ad1> : 58                         clt.i32
	<.main+8443 @049ad2> : 05 d2 ff ff                jnz <.main+8397 @049aa4>
	test/lang/statementFor.ci:17: (75 bytes: <@049ad6> - <@049b21>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8447 @049ad6> : 19                         load.z32
	<.main+8448 @049ad7> : 04 3a 00 00                jmp <.main+8506 @049b11>
	test/lang/statementFor.ci:18: (16 bytes: <@049adb> - <@049aeb>): if (bool(i < 2))
	<.main+8452 @049adb> : 10 00                      dup.x1 sp(0)
	<.main+8454 @049add> : 1c 02 00 00 00             load.c32 2
	<.main+8459 @049ae2> : 58                         clt.i32
	<.main+8460 @049ae3> : 06 08 00 00                jz <.main+8468 @049aeb>
	test/lang/statementFor.ci:19: (4 bytes: <@049ae7> - <@049aeb>): continue;
	<.main+8464 @049ae7> : 04 26 00 00                jmp <.main+8502 @049b0d>
	test/lang/statementFor.ci:21: (34 bytes: <@049aeb> - <@049b0d>): debug(void("for with continue", i));
	<.main+8468 @049aeb> : 1f d0 32 04 00             load.ref <@0432d0> ;"test/lang/statementFor.ci"
	<.main+8473 @049af0> : 1c 15 00 00 00             load.c32 21
	<.main+8478 @049af5> : 1c 0e 00 00 00             load.c32 14
	<.main+8483 @049afa> : 19                         load.z32
	<.main+8484 @049afb> : 1f 46 33 04 00             load.ref <@043346> ;"for with continue"
	<.main+8489 @049b00> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8494 @049b05> : 0a 18 00 00                load.sp(+24)
	<.main+8498 @049b09> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@049b0d> - <@049b11>): int32(i := int32(i + 1))
	<.main+8502 @049b0d> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@049b11> - <@049b1d>): bool(i < 7)
	<.main+8506 @049b11> : 10 00                      dup.x1 sp(0)
	<.main+8508 @049b13> : 1c 07 00 00 00             load.c32 7
	<.main+8513 @049b18> : 58                         clt.i32
	<.main+8514 @049b19> : 05 c2 ff ff                jnz <.main+8452 @049adb>
	<.main+8518 @049b1d> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@049b21> - <@049b6c>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8522 @049b21> : 19                         load.z32
	<.main+8523 @049b22> : 04 3a 00 00                jmp <.main+8581 @049b5c>
	test/lang/statementFor.ci:25: (16 bytes: <@049b26> - <@049b36>): if (bool(i > 2))
	<.main+8527 @049b26> : 10 00                      dup.x1 sp(0)
	<.main+8529 @049b28> : 1c 02 00 00 00             load.c32 2
	<.main+8534 @049b2d> : 59                         cgt.i32
	<.main+8535 @049b2e> : 06 08 00 00                jz <.main+8543 @049b36>
	test/lang/statementFor.ci:26: (4 bytes: <@049b32> - <@049b36>): break;
	<.main+8539 @049b32> : 04 36 00 00                jmp <.main+8593 @049b68>
	test/lang/statementFor.ci:28: (34 bytes: <@049b36> - <@049b58>): debug(void("for with break", i));
	<.main+8543 @049b36> : 1f d0 32 04 00             load.ref <@0432d0> ;"test/lang/statementFor.ci"
	<.main+8548 @049b3b> : 1c 1c 00 00 00             load.c32 28
	<.main+8553 @049b40> : 1c 0e 00 00 00             load.c32 14
	<.main+8558 @049b45> : 19                         load.z32
	<.main+8559 @049b46> : 1f 58 33 04 00             load.ref <@043358> ;"for with break"
	<.main+8564 @049b4b> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8569 @049b50> : 0a 18 00 00                load.sp(+24)
	<.main+8573 @049b54> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@049b58> - <@049b5c>): int32(i := int32(i + 1))
	<.main+8577 @049b58> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@049b5c> - <@049b68>): bool(i < 7)
	<.main+8581 @049b5c> : 10 00                      dup.x1 sp(0)
	<.main+8583 @049b5e> : 1c 07 00 00 00             load.c32 7
	<.main+8588 @049b63> : 58                         clt.i32
	<.main+8589 @049b64> : 05 c2 ff ff                jnz <.main+8527 @049b26>
	<.main+8593 @049b68> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@049b6c> - <@049b80>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8597 @049b6c> : 1a                         load.z64
	<.main+8598 @049b6d> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8607 @049b76> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8612 @049b7b> : 02                         call
	<.main+8613 @049b7c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@049b80> - <@049b94>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8617 @049b80> : 1a                         load.z64
	<.main+8618 @049b81> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8627 @049b8a> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8632 @049b8f> : 02                         call
	<.main+8633 @049b90> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@049b94> - <@049ba8>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8637 @049b94> : 1a                         load.z64
	<.main+8638 @049b95> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8647 @049b9e> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8652 @049ba3> : 02                         call
	<.main+8653 @049ba4> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@049ba8> - <@049bbc>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8657 @049ba8> : 1a                         load.z64
	<.main+8658 @049ba9> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8667 @049bb2> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8672 @049bb7> : 02                         call
	<.main+8673 @049bb8> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@049bbc> - <@049bd0>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8677 @049bbc> : 1a                         load.z64
	<.main+8678 @049bbd> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8687 @049bc6> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8692 @049bcb> : 02                         call
	<.main+8693 @049bcc> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@049bd0> - <@049be4>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8697 @049bd0> : 1a                         load.z64
	<.main+8698 @049bd1> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8707 @049bda> : 1f f0 66 04 00             load.ref <@0466f0> ;Math.floor(x: float64): float64
	<.main+8712 @049bdf> : 02                         call
	<.main+8713 @049be0> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (21 bytes: <@049be4> - <@049bf9>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8717 @049be4> : 19                         load.z32
	<.main+8718 @049be5> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8727 @049bee> : 1f 30 67 04 00             load.ref <@046730> ;Math.sign(x: float64): int32
	<.main+8732 @049bf3> : 02                         call
	<.main+8733 @049bf4> : 09 f8 ff ff                inc.sp(-8)
	<.main+8737 @049bf8> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (13 bytes: <@049bf9> - <@049c06>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8738 @049bf9> : 19                         load.z32
	<.main+8739 @049bfa> : 1a                         load.z64
	<.main+8740 @049bfb> : 1f 30 67 04 00             load.ref <@046730> ;Math.sign(x: float64): int32
	<.main+8745 @049c00> : 02                         call
	<.main+8746 @049c01> : 09 f8 ff ff                inc.sp(-8)
	<.main+8750 @049c05> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (21 bytes: <@049c06> - <@049c1b>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8751 @049c06> : 19                         load.z32
	<.main+8752 @049c07> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8761 @049c10> : 1f 30 67 04 00             load.ref <@046730> ;Math.sign(x: float64): int32
	<.main+8766 @049c15> : 02                         call
	<.main+8767 @049c16> : 09 f8 ff ff                inc.sp(-8)
	<.main+8771 @049c1a> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@049c1b> - <@049c2c>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8772 @049c1b> : 19                         load.z32
	<.main+8773 @049c1c> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8778 @049c21> : 1f 08 67 04 00             load.ref <@046708> ;Math.sign(x: float32): int32
	<.main+8783 @049c26> : 02                         call
	<.main+8784 @049c27> : 09 fc ff ff                inc.sp(-4)
	<.main+8788 @049c2b> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@049c2c> - <@049c39>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8789 @049c2c> : 19                         load.z32
	<.main+8790 @049c2d> : 19                         load.z32
	<.main+8791 @049c2e> : 1f 08 67 04 00             load.ref <@046708> ;Math.sign(x: float32): int32
	<.main+8796 @049c33> : 02                         call
	<.main+8797 @049c34> : 09 fc ff ff                inc.sp(-4)
	<.main+8801 @049c38> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@049c39> - <@049c4a>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8802 @049c39> : 19                         load.z32
	<.main+8803 @049c3a> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8808 @049c3f> : 1f 08 67 04 00             load.ref <@046708> ;Math.sign(x: float32): int32
	<.main+8813 @049c44> : 02                         call
	<.main+8814 @049c45> : 09 fc ff ff                inc.sp(-4)
	<.main+8818 @049c49> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@049c4a> - <@049c5e>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8819 @049c4a> : 1a                         load.z64
	<.main+8820 @049c4b> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8829 @049c54> : 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<.main+8834 @049c59> : 02                         call
	<.main+8835 @049c5a> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@049c5e> - <@049c69>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8839 @049c5e> : 1b                         load.z128
	<.main+8840 @049c5f> : 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<.main+8845 @049c64> : 02                         call
	<.main+8846 @049c65> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@049c69> - <@049c7d>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8850 @049c69> : 1a                         load.z64
	<.main+8851 @049c6a> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8860 @049c73> : 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<.main+8865 @049c78> : 02                         call
	<.main+8866 @049c79> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@049c7d> - <@049c8e>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8870 @049c7d> : 19                         load.z32
	<.main+8871 @049c7e> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8876 @049c83> : 1f 58 67 04 00             load.ref <@046758> ;Math.abs(x: float32): float32
	<.main+8881 @049c88> : 02                         call
	<.main+8882 @049c89> : 09 fc ff ff                inc.sp(-4)
	<.main+8886 @049c8d> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@049c8e> - <@049c9b>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8887 @049c8e> : 19                         load.z32
	<.main+8888 @049c8f> : 19                         load.z32
	<.main+8889 @049c90> : 1f 58 67 04 00             load.ref <@046758> ;Math.abs(x: float32): float32
	<.main+8894 @049c95> : 02                         call
	<.main+8895 @049c96> : 09 fc ff ff                inc.sp(-4)
	<.main+8899 @049c9a> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@049c9b> - <@049cac>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8900 @049c9b> : 19                         load.z32
	<.main+8901 @049c9c> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8906 @049ca1> : 1f 58 67 04 00             load.ref <@046758> ;Math.abs(x: float32): float32
	<.main+8911 @049ca6> : 02                         call
	<.main+8912 @049ca7> : 09 fc ff ff                inc.sp(-4)
	<.main+8916 @049cab> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@049cac> - <@049cc2>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8917 @049cac> : 19                         load.z32
	<.main+8918 @049cad> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8923 @049cb2> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8928 @049cb7> : 1f c8 67 04 00             load.ref <@0467c8> ;Math.min(a: float32, b: float32): float32
	<.main+8933 @049cbc> : 02                         call
	<.main+8934 @049cbd> : 09 f8 ff ff                inc.sp(-8)
	<.main+8938 @049cc1> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@049cc2> - <@049cd8>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8939 @049cc2> : 19                         load.z32
	<.main+8940 @049cc3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8945 @049cc8> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8950 @049ccd> : 1f f8 67 04 00             load.ref <@0467f8> ;Math.max(a: float32, b: float32): float32
	<.main+8955 @049cd2> : 02                         call
	<.main+8956 @049cd3> : 09 f8 ff ff                inc.sp(-8)
	<.main+8960 @049cd7> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@049cd8> - <@049cf5>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8961 @049cd8> : 1a                         load.z64
	<.main+8962 @049cd9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8971 @049ce2> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8980 @049ceb> : 1f e0 67 04 00             load.ref <@0467e0> ;Math.min(a: float64, b: float64): float64
	<.main+8985 @049cf0> : 02                         call
	<.main+8986 @049cf1> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@049cf5> - <@049d12>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8990 @049cf5> : 1a                         load.z64
	<.main+8991 @049cf6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9000 @049cff> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9009 @049d08> : 1f 10 68 04 00             load.ref <@046810> ;Math.max(a: float64, b: float64): float64
	<.main+9014 @049d0d> : 02                         call
	<.main+9015 @049d0e> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@049d12> - <@049d29>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9019 @049d12> : 19                         load.z32
	<.main+9020 @049d13> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9025 @049d18> : 19                         load.z32
	<.main+9026 @049d19> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9031 @049d1e> : 1f 28 68 04 00             load.ref <@046828> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9036 @049d23> : 02                         call
	<.main+9037 @049d24> : 09 f4 ff ff                inc.sp(-12)
	<.main+9041 @049d28> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@049d29> - <@049d47>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9042 @049d29> : 1a                         load.z64
	<.main+9043 @049d2a> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9052 @049d33> : 1a                         load.z64
	<.main+9053 @049d34> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9062 @049d3d> : 1f 48 68 04 00             load.ref <@046848> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9067 @049d42> : 02                         call
	<.main+9068 @049d43> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@049d47> - <@049d5c>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9072 @049d47> : 19                         load.z32
	<.main+9073 @049d48> : 10 00                      dup.x1 sp(0)
	<.main+9075 @049d4a> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9080 @049d4f> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9085 @049d54> : 10 03                      dup.x1 sp(3)
	<.main+9087 @049d56> : 72                         sub.f32
	<.main+9088 @049d57> : 73                         mul.f32
	<.main+9089 @049d58> : 71                         add.f32
	<.main+9090 @049d59> : 13 01                      set.x1 sp(1)
	<.main+9092 @049d5b> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@049d5c> - <@049d78>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9093 @049d5c> : 1a                         load.z64
	<.main+9094 @049d5d> : 11 00                      dup.x2 sp(0)
	<.main+9096 @049d5f> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9105 @049d68> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9114 @049d71> : 11 06                      dup.x2 sp(6)
	<.main+9116 @049d73> : 82                         sub.f64
	<.main+9117 @049d74> : 83                         mul.f64
	<.main+9118 @049d75> : 81                         add.f64
	<.main+9119 @049d76> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (24 bytes: <@049d78> - <@049d90>): testMathSmooth_0f: float64 := Math.smooth(0.000000)
	<.main+9121 @049d78> : 19                         load.z32
	<.main+9122 @049d79> : 10 00                      dup.x1 sp(0)
	<.main+9124 @049d7b> : 10 01                      dup.x1 sp(1)
	<.main+9126 @049d7d> : 73                         mul.f32
	<.main+9127 @049d7e> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9132 @049d83> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9137 @049d88> : 10 03                      dup.x1 sp(3)
	<.main+9139 @049d8a> : 73                         mul.f32
	<.main+9140 @049d8b> : 72                         sub.f32
	<.main+9141 @049d8c> : 73                         mul.f32
	<.main+9142 @049d8d> : 13 01                      set.x1 sp(1)
	<.main+9144 @049d8f> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (31 bytes: <@049d90> - <@049daf>): testMathSmooth_0F: float64 := Math.smooth(0.000000)
	<.main+9145 @049d90> : 1a                         load.z64
	<.main+9146 @049d91> : 11 00                      dup.x2 sp(0)
	<.main+9148 @049d93> : 11 02                      dup.x2 sp(2)
	<.main+9150 @049d95> : 83                         mul.f64
	<.main+9151 @049d96> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9160 @049d9f> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9169 @049da8> : 11 06                      dup.x2 sp(6)
	<.main+9171 @049daa> : 83                         mul.f64
	<.main+9172 @049dab> : 82                         sub.f64
	<.main+9173 @049dac> : 83                         mul.f64
	<.main+9174 @049dad> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:37: (60 bytes: <@049daf> - <@049deb>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9176 @049daf> : 19                         load.z32
	<.main+9177 @049db0> : 19                         load.z32
	<.main+9178 @049db1> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9183 @049db6> : 10 02                      dup.x1 sp(2)
	<.main+9185 @049db8> : 72                         sub.f32
	<.main+9186 @049db9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9191 @049dbe> : 10 03                      dup.x1 sp(3)
	<.main+9193 @049dc0> : 72                         sub.f32
	<.main+9194 @049dc1> : 74                         div.f32
	<.main+9195 @049dc2> : 19                         load.z32
	<.main+9196 @049dc3> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9201 @049dc8> : 1f 28 68 04 00             load.ref <@046828> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9206 @049dcd> : 02                         call
	<.main+9207 @049dce> : 09 f4 ff ff                inc.sp(-12)
	<.main+9211 @049dd2> : 10 00                      dup.x1 sp(0)
	<.main+9213 @049dd4> : 10 01                      dup.x1 sp(1)
	<.main+9215 @049dd6> : 73                         mul.f32
	<.main+9216 @049dd7> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9221 @049ddc> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9226 @049de1> : 10 03                      dup.x1 sp(3)
	<.main+9228 @049de3> : 73                         mul.f32
	<.main+9229 @049de4> : 72                         sub.f32
	<.main+9230 @049de5> : 73                         mul.f32
	<.main+9231 @049de6> : 13 01                      set.x1 sp(1)
	<.main+9233 @049de8> : 13 01                      set.x1 sp(1)
	<.main+9235 @049dea> : 7d                         f32.2f64
	test/stdc/test.math.ci:38: (78 bytes: <@049deb> - <@049e39>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9236 @049deb> : 1b                         load.z128
	<.main+9237 @049dec> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9246 @049df5> : 11 04                      dup.x2 sp(4)
	<.main+9248 @049df7> : 82                         sub.f64
	<.main+9249 @049df8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9258 @049e01> : 11 06                      dup.x2 sp(6)
	<.main+9260 @049e03> : 82                         sub.f64
	<.main+9261 @049e04> : 84                         div.f64
	<.main+9262 @049e05> : 1a                         load.z64
	<.main+9263 @049e06> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9272 @049e0f> : 1f 48 68 04 00             load.ref <@046848> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9277 @049e14> : 02                         call
	<.main+9278 @049e15> : 09 e8 ff ff                inc.sp(-24)
	<.main+9282 @049e19> : 11 00                      dup.x2 sp(0)
	<.main+9284 @049e1b> : 11 02                      dup.x2 sp(2)
	<.main+9286 @049e1d> : 83                         mul.f64
	<.main+9287 @049e1e> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9296 @049e27> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9305 @049e30> : 11 06                      dup.x2 sp(6)
	<.main+9307 @049e32> : 83                         mul.f64
	<.main+9308 @049e33> : 82                         sub.f64
	<.main+9309 @049e34> : 83                         mul.f64
	<.main+9310 @049e35> : 14 02                      set.x2 sp(2)
	<.main+9312 @049e37> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:40: (21 bytes: <@049e39> - <@049e4e>): testMathMin_nan: float64 := Math.min()
	<.main+9314 @049e39> : 19                         load.z32
	<.main+9315 @049e3a> : 0a 04 00 00                load.sp(+4)
	<.main+9319 @049e3e> : 1a                         load.z64
	<.main+9320 @049e3f> : 11 02                      dup.x2 sp(2)
	<.main+9322 @049e41> : 1f 68 68 04 00             load.ref <@046868> ;Math.min(data: float64[]): float64
	<.main+9327 @049e46> : 02                         call
	<.main+9328 @049e47> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9331 @049e4a> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@049e4e> - <@049eb8>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9335 @049e4e> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9344 @049e57> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9353 @049e60> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9362 @049e69> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9371 @049e72> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9380 @049e7b> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9389 @049e84> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9398 @049e8d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9407 @049e96> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9416 @049e9f> : 1c 09 00 00 00             load.c32 9
	<.main+9421 @049ea4> : 0a 04 00 00                load.sp(+4)
	<.main+9425 @049ea8> : 1a                         load.z64
	<.main+9426 @049ea9> : 11 02                      dup.x2 sp(2)
	<.main+9428 @049eab> : 1f 68 68 04 00             load.ref <@046868> ;Math.min(data: float64[]): float64
	<.main+9433 @049eb0> : 02                         call
	<.main+9434 @049eb1> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9437 @049eb4> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:42: (21 bytes: <@049eb8> - <@049ecd>): testMathMax_nan: float64 := Math.max()
	<.main+9441 @049eb8> : 19                         load.z32
	<.main+9442 @049eb9> : 0a 04 00 00                load.sp(+4)
	<.main+9446 @049ebd> : 1a                         load.z64
	<.main+9447 @049ebe> : 11 02                      dup.x2 sp(2)
	<.main+9449 @049ec0> : 1f b0 68 04 00             load.ref <@0468b0> ;Math.max(data: float64[]): float64
	<.main+9454 @049ec5> : 02                         call
	<.main+9455 @049ec6> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9458 @049ec9> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:43: (106 bytes: <@049ecd> - <@049f37>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9462 @049ecd> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9471 @049ed6> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9480 @049edf> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9489 @049ee8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9498 @049ef1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9507 @049efa> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9516 @049f03> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9525 @049f0c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9534 @049f15> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9543 @049f1e> : 1c 09 00 00 00             load.c32 9
	<.main+9548 @049f23> : 0a 04 00 00                load.sp(+4)
	<.main+9552 @049f27> : 1a                         load.z64
	<.main+9553 @049f28> : 11 02                      dup.x2 sp(2)
	<.main+9555 @049f2a> : 1f b0 68 04 00             load.ref <@0468b0> ;Math.max(data: float64[]): float64
	<.main+9560 @049f2f> : 02                         call
	<.main+9561 @049f30> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9564 @049f33> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:45: (21 bytes: <@049f37> - <@049f4c>): testMathSum_0: float64 := Math.sum()
	<.main+9568 @049f37> : 19                         load.z32
	<.main+9569 @049f38> : 0a 04 00 00                load.sp(+4)
	<.main+9573 @049f3c> : 1a                         load.z64
	<.main+9574 @049f3d> : 11 02                      dup.x2 sp(2)
	<.main+9576 @049f3f> : 1f f8 68 04 00             load.ref <@0468f8> ;Math.sum(data: float64[]): float64
	<.main+9581 @049f44> : 02                         call
	<.main+9582 @049f45> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9585 @049f48> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:46: (34 bytes: <@049f4c> - <@049f6e>): testMathSum_1: float64 := Math.sum(1)
	<.main+9589 @049f4c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9598 @049f55> : 1c 01 00 00 00             load.c32 1
	<.main+9603 @049f5a> : 0a 04 00 00                load.sp(+4)
	<.main+9607 @049f5e> : 1a                         load.z64
	<.main+9608 @049f5f> : 11 02                      dup.x2 sp(2)
	<.main+9610 @049f61> : 1f f8 68 04 00             load.ref <@0468f8> ;Math.sum(data: float64[]): float64
	<.main+9615 @049f66> : 02                         call
	<.main+9616 @049f67> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9619 @049f6a> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:47: (43 bytes: <@049f6e> - <@049f99>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9623 @049f6e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9632 @049f77> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9641 @049f80> : 1c 02 00 00 00             load.c32 2
	<.main+9646 @049f85> : 0a 04 00 00                load.sp(+4)
	<.main+9650 @049f89> : 1a                         load.z64
	<.main+9651 @049f8a> : 11 02                      dup.x2 sp(2)
	<.main+9653 @049f8c> : 1f f8 68 04 00             load.ref <@0468f8> ;Math.sum(data: float64[]): float64
	<.main+9658 @049f91> : 02                         call
	<.main+9659 @049f92> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9662 @049f95> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:48: (115 bytes: <@049f99> - <@04a00c>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9666 @049f99> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9675 @049fa2> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9684 @049fab> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9693 @049fb4> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9702 @049fbd> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9711 @049fc6> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9720 @049fcf> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9729 @049fd8> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9738 @049fe1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9747 @049fea> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9756 @049ff3> : 1c 0a 00 00 00             load.c32 10
	<.main+9761 @049ff8> : 0a 04 00 00                load.sp(+4)
	<.main+9765 @049ffc> : 1a                         load.z64
	<.main+9766 @049ffd> : 11 02                      dup.x2 sp(2)
	<.main+9768 @049fff> : 1f f8 68 04 00             load.ref <@0468f8> ;Math.sum(data: float64[]): float64
	<.main+9773 @04a004> : 02                         call
	<.main+9774 @04a005> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9777 @04a008> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:50: (9 bytes: <@04a00c> - <@04a015>): testMathEval_x: float64 := 10
	<.main+9781 @04a00c> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:51: (23 bytes: <@04a015> - <@04a02c>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9790 @04a015> : 19                         load.z32
	<.main+9791 @04a016> : 0a 04 00 00                load.sp(+4)
	<.main+9795 @04a01a> : 1a                         load.z64
	<.main+9796 @04a01b> : 11 04                      dup.x2 sp(4)
	<.main+9798 @04a01d> : 11 04                      dup.x2 sp(4)
	<.main+9800 @04a01f> : 1f 20 69 04 00             load.ref <@046920> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9805 @04a024> : 02                         call
	<.main+9806 @04a025> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9809 @04a028> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:52: (9 bytes: <@04a02c> - <@04a035>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9813 @04a02c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:53: (22 bytes: <@04a035> - <@04a04b>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9822 @04a035> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9831 @04a03e> : 11 06                      dup.x2 sp(6)
	<.main+9833 @04a040> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9842 @04a049> : 83                         mul.f64
	<.main+9843 @04a04a> : 81                         add.f64
	test/stdc/test.math.ci:54: (39 bytes: <@04a04b> - <@04a072>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9844 @04a04b> : 11 06                      dup.x2 sp(6)
	<.main+9846 @04a04d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9855 @04a056> : 11 02                      dup.x2 sp(2)
	<.main+9857 @04a058> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9866 @04a061> : 11 06                      dup.x2 sp(6)
	<.main+9868 @04a063> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9877 @04a06c> : 83                         mul.f64
	<.main+9878 @04a06d> : 81                         add.f64
	<.main+9879 @04a06e> : 83                         mul.f64
	<.main+9880 @04a06f> : 81                         add.f64
	<.main+9881 @04a070> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:55: (56 bytes: <@04a072> - <@04a0aa>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9883 @04a072> : 11 08                      dup.x2 sp(8)
	<.main+9885 @04a074> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9894 @04a07d> : 11 02                      dup.x2 sp(2)
	<.main+9896 @04a07f> : 11 04                      dup.x2 sp(4)
	<.main+9898 @04a081> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9907 @04a08a> : 11 02                      dup.x2 sp(2)
	<.main+9909 @04a08c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9918 @04a095> : 11 06                      dup.x2 sp(6)
	<.main+9920 @04a097> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9929 @04a0a0> : 83                         mul.f64
	<.main+9930 @04a0a1> : 81                         add.f64
	<.main+9931 @04a0a2> : 83                         mul.f64
	<.main+9932 @04a0a3> : 81                         add.f64
	<.main+9933 @04a0a4> : 14 02                      set.x2 sp(2)
	<.main+9935 @04a0a6> : 83                         mul.f64
	<.main+9936 @04a0a7> : 81                         add.f64
	<.main+9937 @04a0a8> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:56: (72 bytes: <@04a0aa> - <@04a0f2>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9939 @04a0aa> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9948 @04a0b3> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9957 @04a0bc> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9966 @04a0c5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9975 @04a0ce> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9984 @04a0d7> : 1c 05 00 00 00             load.c32 5
	<.main+9989 @04a0dc> : 0a 04 00 00                load.sp(+4)
	<.main+9993 @04a0e0> : 1a                         load.z64
	<.main+9994 @04a0e1> : 11 18                      dup.x2 sp(24)
	<.main+9996 @04a0e3> : 11 04                      dup.x2 sp(4)
	<.main+9998 @04a0e5> : 1f 20 69 04 00             load.ref <@046920> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10003 @04a0ea>: 02                         call
	<.main+10004 @04a0eb>: 17 10 04                   mov.x2 sp(16, 4)
	<.main+10007 @04a0ee>: 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:57: (81 bytes: <@04a0f2> - <@04a143>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10011 @04a0f2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10020 @04a0fb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10029 @04a104>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10038 @04a10d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10047 @04a116>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10056 @04a11f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10065 @04a128>: 1c 06 00 00 00             load.c32 6
	<.main+10070 @04a12d>: 0a 04 00 00                load.sp(+4)
	<.main+10074 @04a131>: 1a                         load.z64
	<.main+10075 @04a132>: 11 1c                      dup.x2 sp(28)
	<.main+10077 @04a134>: 11 04                      dup.x2 sp(4)
	<.main+10079 @04a136>: 1f 20 69 04 00             load.ref <@046920> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10084 @04a13b>: 02                         call
	<.main+10085 @04a13c>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10088 @04a13f>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:59: (31 bytes: <@04a143> - <@04a162>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10092 @04a143>: 1a                         load.z64
	<.main+10093 @04a144>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10102 @04a14d>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10111 @04a156>: 84                         div.f64
	<.main+10112 @04a157>: 19                         load.z32
	<.main+10113 @04a158>: 1f d0 69 04 00             load.ref <@0469d0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10118 @04a15d>: 02                         call
	<.main+10119 @04a15e>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:60: (45 bytes: <@04a162> - <@04a18f>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10123 @04a162>: 1b                         load.z128
	<.main+10124 @04a163>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10133 @04a16c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10142 @04a175>: 84                         div.f64
	<.main+10143 @04a176>: 1f 70 67 04 00             load.ref <@046770> ;Math.abs(x: float64): float64
	<.main+10148 @04a17b>: 02                         call
	<.main+10149 @04a17c>: 09 f8 ff ff                inc.sp(-8)
	<.main+10153 @04a180>: 1c 01 00 00 00             load.c32 1
	<.main+10158 @04a185>: 1f d0 69 04 00             load.ref <@0469d0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10163 @04a18a>: 02                         call
	<.main+10164 @04a18b>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:61: (30 bytes: <@04a18f> - <@04a1ad>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10168 @04a18f>: 1a                         load.z64
	<.main+10169 @04a190>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10178 @04a199>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10187 @04a1a2>: 84                         div.f64
	<.main+10188 @04a1a3>: 1f 20 6b 04 00             load.ref <@046b20> ;Math.tan(arg: float64): float64
	<.main+10193 @04a1a8>: 02                         call
	<.main+10194 @04a1a9>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:62: (30 bytes: <@04a1ad> - <@04a1cb>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10198 @04a1ad>: 1a                         load.z64
	<.main+10199 @04a1ae>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10208 @04a1b7>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10217 @04a1c0>: 84                         div.f64
	<.main+10218 @04a1c1>: 1f 98 6c 04 00             load.ref <@046c98> ;Math.sinh(x: float64): float64
	<.main+10223 @04a1c6>: 02                         call
	<.main+10224 @04a1c7>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (30 bytes: <@04a1cb> - <@04a1e9>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10228 @04a1cb>: 1a                         load.z64
	<.main+10229 @04a1cc>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10238 @04a1d5>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10247 @04a1de>: 84                         div.f64
	<.main+10248 @04a1df>: 1f 90 6d 04 00             load.ref <@046d90> ;Math.cosh(x: float64): float64
	<.main+10253 @04a1e4>: 02                         call
	<.main+10254 @04a1e5>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:65: (20 bytes: <@04a1e9> - <@04a1fd>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10258 @04a1e9>: 1a                         load.z64
	<.main+10259 @04a1ea>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10268 @04a1f3>: 1f e0 6d 04 00             load.ref <@046de0> ;Math.asin(x: float64): float64
	<.main+10273 @04a1f8>: 02                         call
	<.main+10274 @04a1f9>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:66: (40 bytes: <@04a1fd> - <@04a225>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10278 @04a1fd>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10287 @04a206>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10296 @04a20f>: 84                         div.f64
	<.main+10297 @04a210>: 1a                         load.z64
	<.main+10298 @04a211>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10307 @04a21a>: 1f e0 6d 04 00             load.ref <@046de0> ;Math.asin(x: float64): float64
	<.main+10312 @04a21f>: 02                         call
	<.main+10313 @04a220>: 09 f8 ff ff                inc.sp(-8)
	<.main+10317 @04a224>: 82                         sub.f64
	test/stdc/test.math.ci:69: (28 bytes: <@04a225> - <@04a241>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10318 @04a225>: 19                         load.z32
	<.main+10319 @04a226>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10324 @04a22b>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10329 @04a230>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10334 @04a235>: 1f 50 69 04 00             load.ref <@046950> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10339 @04a23a>: 02                         call
	<.main+10340 @04a23b>: 09 f4 ff ff                inc.sp(-12)
	<.main+10344 @04a23f>: 19                         load.z32
	<.main+10345 @04a240>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (40 bytes: <@04a241> - <@04a269>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10346 @04a241>: 19                         load.z32
	<.main+10347 @04a242>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10356 @04a24b>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10365 @04a254>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10374 @04a25d>: 1f 90 69 04 00             load.ref <@046990> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10379 @04a262>: 02                         call
	<.main+10380 @04a263>: 09 e8 ff ff                inc.sp(-24)
	<.main+10384 @04a267>: 19                         load.z32
	<.main+10385 @04a268>: 57                         ceq.i32
	test/stdc/test.math.ci:72: (29 bytes: <@04a269> - <@04a286>): testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10386 @04a269>: 1a                         load.z64
	<.main+10387 @04a26a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10396 @04a273>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10405 @04a27c>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10410 @04a281>: 02                         call
	<.main+10411 @04a282>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:73: (20 bytes: <@04a286> - <@04a29a>): testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+10415 @04a286>: 1b                         load.z128
	<.main+10416 @04a287>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10425 @04a290>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10430 @04a295>: 02                         call
	<.main+10431 @04a296>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:74: (29 bytes: <@04a29a> - <@04a2b7>): testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+10435 @04a29a>: 1a                         load.z64
	<.main+10436 @04a29b>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+10445 @04a2a4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10454 @04a2ad>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10459 @04a2b2>: 02                         call
	<.main+10460 @04a2b3>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:76: (29 bytes: <@04a2b7> - <@04a2d4>): testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+10464 @04a2b7>: 1a                         load.z64
	<.main+10465 @04a2b8>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+10474 @04a2c1>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10483 @04a2ca>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10488 @04a2cf>: 02                         call
	<.main+10489 @04a2d0>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:77: (29 bytes: <@04a2d4> - <@04a2f1>): testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+10493 @04a2d4>: 1a                         load.z64
	<.main+10494 @04a2d5>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10503 @04a2de>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10512 @04a2e7>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10517 @04a2ec>: 02                         call
	<.main+10518 @04a2ed>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:78: (29 bytes: <@04a2f1> - <@04a30e>): testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+10522 @04a2f1>: 1a                         load.z64
	<.main+10523 @04a2f2>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+10532 @04a2fb>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10541 @04a304>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10546 @04a309>: 02                         call
	<.main+10547 @04a30a>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:79: (29 bytes: <@04a30e> - <@04a32b>): testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+10551 @04a30e>: 1a                         load.z64
	<.main+10552 @04a30f>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+10561 @04a318>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10570 @04a321>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10575 @04a326>: 02                         call
	<.main+10576 @04a327>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:81: (29 bytes: <@04a32b> - <@04a348>): testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+10580 @04a32b>: 1a                         load.z64
	<.main+10581 @04a32c>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+10590 @04a335>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10599 @04a33e>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10604 @04a343>: 02                         call
	<.main+10605 @04a344>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:82: (29 bytes: <@04a348> - <@04a365>): testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+10609 @04a348>: 1a                         load.z64
	<.main+10610 @04a349>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10619 @04a352>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10628 @04a35b>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10633 @04a360>: 02                         call
	<.main+10634 @04a361>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:83: (29 bytes: <@04a365> - <@04a382>): testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+10638 @04a365>: 1a                         load.z64
	<.main+10639 @04a366>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+10648 @04a36f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10657 @04a378>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10662 @04a37d>: 02                         call
	<.main+10663 @04a37e>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:84: (29 bytes: <@04a382> - <@04a39f>): testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+10667 @04a382>: 1a                         load.z64
	<.main+10668 @04a383>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+10677 @04a38c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10686 @04a395>: 1f a8 67 04 00             load.ref <@0467a8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10691 @04a39a>: 02                         call
	<.main+10692 @04a39b>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:86: (21 bytes: <@04a39f> - <@04a3b4>): testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+10696 @04a39f>: 19                         load.z32
	<.main+10697 @04a3a0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10702 @04a3a5>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10707 @04a3aa>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10712 @04a3af>: 02                         call
	<.main+10713 @04a3b0>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:87: (17 bytes: <@04a3b4> - <@04a3c5>): testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+10717 @04a3b4>: 19                         load.z32
	<.main+10718 @04a3b5>: 19                         load.z32
	<.main+10719 @04a3b6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10724 @04a3bb>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10729 @04a3c0>: 02                         call
	<.main+10730 @04a3c1>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:88: (21 bytes: <@04a3c5> - <@04a3da>): testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+10734 @04a3c5>: 19                         load.z32
	<.main+10735 @04a3c6>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+10740 @04a3cb>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10745 @04a3d0>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10750 @04a3d5>: 02                         call
	<.main+10751 @04a3d6>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:90: (21 bytes: <@04a3da> - <@04a3ef>): testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+10755 @04a3da>: 19                         load.z32
	<.main+10756 @04a3db>: 7f 00 00 98 41             load.f32 19.000000
	<.main+10761 @04a3e0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10766 @04a3e5>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10771 @04a3ea>: 02                         call
	<.main+10772 @04a3eb>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:91: (21 bytes: <@04a3ef> - <@04a404>): testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+10776 @04a3ef>: 19                         load.z32
	<.main+10777 @04a3f0>: 7f 00 00 10 41             load.f32 9.000000
	<.main+10782 @04a3f5>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10787 @04a3fa>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10792 @04a3ff>: 02                         call
	<.main+10793 @04a400>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:92: (21 bytes: <@04a404> - <@04a419>): testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+10797 @04a404>: 19                         load.z32
	<.main+10798 @04a405>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+10803 @04a40a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10808 @04a40f>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10813 @04a414>: 02                         call
	<.main+10814 @04a415>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:93: (21 bytes: <@04a419> - <@04a42e>): testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+10818 @04a419>: 19                         load.z32
	<.main+10819 @04a41a>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+10824 @04a41f>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10829 @04a424>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10834 @04a429>: 02                         call
	<.main+10835 @04a42a>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:95: (21 bytes: <@04a42e> - <@04a443>): testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+10839 @04a42e>: 19                         load.z32
	<.main+10840 @04a42f>: 7f 00 00 90 41             load.f32 18.000000
	<.main+10845 @04a434>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10850 @04a439>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10855 @04a43e>: 02                         call
	<.main+10856 @04a43f>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:96: (21 bytes: <@04a443> - <@04a458>): testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+10860 @04a443>: 19                         load.z32
	<.main+10861 @04a444>: 7f 00 00 00 41             load.f32 8.000000
	<.main+10866 @04a449>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10871 @04a44e>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10876 @04a453>: 02                         call
	<.main+10877 @04a454>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:97: (21 bytes: <@04a458> - <@04a46d>): testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+10881 @04a458>: 19                         load.z32
	<.main+10882 @04a459>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+10887 @04a45e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10892 @04a463>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10897 @04a468>: 02                         call
	<.main+10898 @04a469>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:98: (21 bytes: <@04a46d> - <@04a482>): testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+10902 @04a46d>: 19                         load.z32
	<.main+10903 @04a46e>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+10908 @04a473>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10913 @04a478>: 1f 88 67 04 00             load.ref <@046788> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10918 @04a47d>: 02                         call
	<.main+10919 @04a47e>: 09 f8 ff ff                inc.sp(-8)
	<.main+10923 @04a482>: 01 00 00 00                nfc(0) ;halt(): void
.references:
}

---------- Execute: byte-code
[ 236.94] > .main
[ 237.45]  > funAdd(x: int32, y: int32): int32
[ 237.46]  < return
[ 237.47]  > funAdd(x: int32, y: int32): int32
[ 237.48]  < return
[ 237.49]  > funMul(x: int32, y: int32): int32
[ 237.50]  < return
[ 237.51]  > funMul(x: int32, y: int32): int32
[ 237.52]  < return
[ 237.54]  > fib(n: uint32): uint32
[ 237.55]   > fib(n: uint32): uint32
[ 237.56]    > fib(n: uint32): uint32
[ 237.57]     > fib(n: uint32): uint32
[ 237.58]      > fib(n: uint32): uint32
[ 237.59]       > fib(n: uint32): uint32
[ 237.61]        > fib(n: uint32): uint32
[ 237.62]         > fib(n: uint32): uint32
[ 237.63]          > fib(n: uint32): uint32
[ 237.66]           > fib(n: uint32): uint32
[ 237.67]            > fib(n: uint32): uint32
[ 237.68]             > fib(n: uint32): uint32
[ 237.69]              > fib(n: uint32): uint32
[ 237.70]              < return
[ 237.70]              > fib(n: uint32): uint32
[ 237.71]              < return
[ 237.72]             < return
[ 237.73]             > fib(n: uint32): uint32
[ 237.74]             < return
[ 237.74]            < return
[ 237.75]            > fib(n: uint32): uint32
[ 237.76]             > fib(n: uint32): uint32
[ 237.77]             < return
[ 237.78]             > fib(n: uint32): uint32
[ 237.78]             < return
[ 237.79]            < return
[ 237.80]           < return
[ 237.80]           > fib(n: uint32): uint32
[ 237.81]            > fib(n: uint32): uint32
[ 237.82]             > fib(n: uint32): uint32
[ 237.83]             < return
[ 237.84]             > fib(n: uint32): uint32
[ 237.85]             < return
[ 237.86]            < return
[ 237.86]            > fib(n: uint32): uint32
[ 237.87]            < return
[ 237.88]           < return
[ 237.90]          < return
[ 237.91]          > fib(n: uint32): uint32
[ 237.92]           > fib(n: uint32): uint32
[ 237.93]            > fib(n: uint32): uint32
[ 237.95]             > fib(n: uint32): uint32
[ 237.96]             < return
[ 237.98]             > fib(n: uint32): uint32
[ 237.99]             < return
[ 238.01]            < return
[ 238.03]            > fib(n: uint32): uint32
[ 238.04]            < return
[ 238.05]           < return
[ 238.06]           > fib(n: uint32): uint32
[ 238.06]            > fib(n: uint32): uint32
[ 238.07]            < return
[ 238.08]            > fib(n: uint32): uint32
[ 238.09]            < return
[ 238.10]           < return
[ 238.10]          < return
[ 238.11]         < return
[ 238.12]         > fib(n: uint32): uint32
[ 238.13]          > fib(n: uint32): uint32
[ 238.14]           > fib(n: uint32): uint32
[ 238.15]            > fib(n: uint32): uint32
[ 238.16]             > fib(n: uint32): uint32
[ 238.17]             < return
[ 238.18]             > fib(n: uint32): uint32
[ 238.18]             < return
[ 238.19]            < return
[ 238.20]            > fib(n: uint32): uint32
[ 238.21]            < return
[ 238.21]           < return
[ 238.22]           > fib(n: uint32): uint32
[ 238.23]            > fib(n: uint32): uint32
[ 238.24]            < return
[ 238.25]            > fib(n: uint32): uint32
[ 238.26]            < return
[ 238.26]           < return
[ 238.27]          < return
[ 238.28]          > fib(n: uint32): uint32
[ 238.29]           > fib(n: uint32): uint32
[ 238.31]            > fib(n: uint32): uint32
[ 238.32]            < return
[ 238.33]            > fib(n: uint32): uint32
[ 238.34]            < return
[ 238.36]           < return
[ 238.36]           > fib(n: uint32): uint32
[ 238.37]           < return
[ 238.38]          < return
[ 238.38]         < return
[ 238.39]        < return
[ 238.40]        > fib(n: uint32): uint32
[ 238.41]         > fib(n: uint32): uint32
[ 238.42]          > fib(n: uint32): uint32
[ 238.43]           > fib(n: uint32): uint32
[ 238.44]            > fib(n: uint32): uint32
[ 238.45]             > fib(n: uint32): uint32
[ 238.46]             < return
[ 238.47]             > fib(n: uint32): uint32
[ 238.47]             < return
[ 238.48]            < return
[ 238.49]            > fib(n: uint32): uint32
[ 238.50]            < return
[ 238.50]           < return
[ 238.51]           > fib(n: uint32): uint32
[ 238.52]            > fib(n: uint32): uint32
[ 238.53]            < return
[ 238.54]            > fib(n: uint32): uint32
[ 238.56]            < return
[ 238.57]           < return
[ 238.57]          < return
[ 238.59]          > fib(n: uint32): uint32
[ 238.60]           > fib(n: uint32): uint32
[ 238.61]            > fib(n: uint32): uint32
[ 238.64]            < return
[ 238.66]            > fib(n: uint32): uint32
[ 238.68]            < return
[ 238.70]           < return
[ 238.71]           > fib(n: uint32): uint32
[ 238.73]           < return
[ 238.74]          < return
[ 238.75]         < return
[ 238.75]         > fib(n: uint32): uint32
[ 238.76]          > fib(n: uint32): uint32
[ 238.77]           > fib(n: uint32): uint32
[ 238.78]            > fib(n: uint32): uint32
[ 238.79]            < return
[ 238.80]            > fib(n: uint32): uint32
[ 238.81]            < return
[ 238.82]           < return
[ 238.82]           > fib(n: uint32): uint32
[ 238.84]           < return
[ 238.85]          < return
[ 238.86]          > fib(n: uint32): uint32
[ 238.87]           > fib(n: uint32): uint32
[ 238.88]           < return
[ 238.88]           > fib(n: uint32): uint32
[ 238.89]           < return
[ 238.90]          < return
[ 238.91]         < return
[ 238.91]        < return
[ 238.92]       < return
[ 238.93]       > fib(n: uint32): uint32
[ 238.94]        > fib(n: uint32): uint32
[ 238.95]         > fib(n: uint32): uint32
[ 238.97]          > fib(n: uint32): uint32
[ 238.98]           > fib(n: uint32): uint32
[ 238.99]            > fib(n: uint32): uint32
[ 239.01]             > fib(n: uint32): uint32
[ 239.02]             < return
[ 239.03]             > fib(n: uint32): uint32
[ 239.04]             < return
[ 239.05]            < return
[ 239.05]            > fib(n: uint32): uint32
[ 239.06]            < return
[ 239.07]           < return
[ 239.08]           > fib(n: uint32): uint32
[ 239.09]            > fib(n: uint32): uint32
[ 239.09]            < return
[ 239.10]            > fib(n: uint32): uint32
[ 239.11]            < return
[ 239.12]           < return
[ 239.12]          < return
[ 239.13]          > fib(n: uint32): uint32
[ 239.14]           > fib(n: uint32): uint32
[ 239.15]            > fib(n: uint32): uint32
[ 239.16]            < return
[ 239.17]            > fib(n: uint32): uint32
[ 239.18]            < return
[ 239.18]           < return
[ 239.19]           > fib(n: uint32): uint32
[ 239.20]           < return
[ 239.21]          < return
[ 239.21]         < return
[ 239.22]         > fib(n: uint32): uint32
[ 239.23]          > fib(n: uint32): uint32
[ 239.24]           > fib(n: uint32): uint32
[ 239.28]            > fib(n: uint32): uint32
[ 239.29]            < return
[ 239.29]            > fib(n: uint32): uint32
[ 239.30]            < return
[ 239.31]           < return
[ 239.32]           > fib(n: uint32): uint32
[ 239.33]           < return
[ 239.33]          < return
[ 239.34]          > fib(n: uint32): uint32
[ 239.37]           > fib(n: uint32): uint32
[ 239.37]           < return
[ 239.38]           > fib(n: uint32): uint32
[ 239.39]           < return
[ 239.40]          < return
[ 239.40]         < return
[ 239.41]        < return
[ 239.42]        > fib(n: uint32): uint32
[ 239.43]         > fib(n: uint32): uint32
[ 239.44]          > fib(n: uint32): uint32
[ 239.45]           > fib(n: uint32): uint32
[ 239.46]            > fib(n: uint32): uint32
[ 239.47]            < return
[ 239.47]            > fib(n: uint32): uint32
[ 239.48]            < return
[ 239.49]           < return
[ 239.50]           > fib(n: uint32): uint32
[ 239.50]           < return
[ 239.51]          < return
[ 239.52]          > fib(n: uint32): uint32
[ 239.53]           > fib(n: uint32): uint32
[ 239.54]           < return
[ 239.54]           > fib(n: uint32): uint32
[ 239.55]           < return
[ 239.56]          < return
[ 239.57]         < return
[ 239.57]         > fib(n: uint32): uint32
[ 239.58]          > fib(n: uint32): uint32
[ 239.59]           > fib(n: uint32): uint32
[ 239.60]           < return
[ 239.61]           > fib(n: uint32): uint32
[ 239.63]           < return
[ 239.65]          < return
[ 239.66]          > fib(n: uint32): uint32
[ 239.67]          < return
[ 239.68]         < return
[ 239.68]        < return
[ 239.69]       < return
[ 239.70]      < return
[ 239.70]      > fib(n: uint32): uint32
[ 239.71]       > fib(n: uint32): uint32
[ 239.72]        > fib(n: uint32): uint32
[ 239.75]         > fib(n: uint32): uint32
[ 239.76]          > fib(n: uint32): uint32
[ 239.77]           > fib(n: uint32): uint32
[ 239.78]            > fib(n: uint32): uint32
[ 239.79]             > fib(n: uint32): uint32
[ 239.80]             < return
[ 239.80]             > fib(n: uint32): uint32
[ 239.81]             < return
[ 239.82]            < return
[ 239.83]            > fib(n: uint32): uint32
[ 239.84]            < return
[ 239.84]           < return
[ 239.85]           > fib(n: uint32): uint32
[ 239.86]            > fib(n: uint32): uint32
[ 239.87]            < return
[ 239.88]            > fib(n: uint32): uint32
[ 239.90]            < return
[ 239.91]           < return
[ 239.91]          < return
[ 239.93]          > fib(n: uint32): uint32
[ 239.94]           > fib(n: uint32): uint32
[ 239.95]            > fib(n: uint32): uint32
[ 239.97]            < return
[ 239.98]            > fib(n: uint32): uint32
[ 239.99]            < return
[ 240.00]           < return
[ 240.01]           > fib(n: uint32): uint32
[ 240.02]           < return
[ 240.02]          < return
[ 240.03]         < return
[ 240.04]         > fib(n: uint32): uint32
[ 240.06]          > fib(n: uint32): uint32
[ 240.07]           > fib(n: uint32): uint32
[ 240.08]            > fib(n: uint32): uint32
[ 240.09]            < return
[ 240.10]            > fib(n: uint32): uint32
[ 240.11]            < return
[ 240.13]           < return
[ 240.13]           > fib(n: uint32): uint32
[ 240.14]           < return
[ 240.15]          < return
[ 240.16]          > fib(n: uint32): uint32
[ 240.17]           > fib(n: uint32): uint32
[ 240.18]           < return
[ 240.19]           > fib(n: uint32): uint32
[ 240.20]           < return
[ 240.21]          < return
[ 240.23]         < return
[ 240.25]        < return
[ 240.26]        > fib(n: uint32): uint32
[ 240.28]         > fib(n: uint32): uint32
[ 240.29]          > fib(n: uint32): uint32
[ 240.31]           > fib(n: uint32): uint32
[ 240.33]            > fib(n: uint32): uint32
[ 240.36]            < return
[ 240.37]            > fib(n: uint32): uint32
[ 240.38]            < return
[ 240.39]           < return
[ 240.40]           > fib(n: uint32): uint32
[ 240.41]           < return
[ 240.41]          < return
[ 240.42]          > fib(n: uint32): uint32
[ 240.43]           > fib(n: uint32): uint32
[ 240.44]           < return
[ 240.45]           > fib(n: uint32): uint32
[ 240.46]           < return
[ 240.46]          < return
[ 240.47]         < return
[ 240.47]         > fib(n: uint32): uint32
[ 240.49]          > fib(n: uint32): uint32
[ 240.50]           > fib(n: uint32): uint32
[ 240.50]           < return
[ 240.51]           > fib(n: uint32): uint32
[ 240.52]           < return
[ 240.53]          < return
[ 240.53]          > fib(n: uint32): uint32
[ 240.56]          < return
[ 240.57]         < return
[ 240.59]        < return
[ 240.60]       < return
[ 240.61]       > fib(n: uint32): uint32
[ 240.62]        > fib(n: uint32): uint32
[ 240.63]         > fib(n: uint32): uint32
[ 240.64]          > fib(n: uint32): uint32
[ 240.65]           > fib(n: uint32): uint32
[ 240.66]            > fib(n: uint32): uint32
[ 240.68]            < return
[ 240.70]            > fib(n: uint32): uint32
[ 240.71]            < return
[ 240.73]           < return
[ 240.74]           > fib(n: uint32): uint32
[ 240.76]           < return
[ 240.77]          < return
[ 240.78]          > fib(n: uint32): uint32
[ 240.79]           > fib(n: uint32): uint32
[ 240.79]           < return
[ 240.80]           > fib(n: uint32): uint32
[ 240.81]           < return
[ 240.82]          < return
[ 240.82]         < return
[ 240.83]         > fib(n: uint32): uint32
[ 240.84]          > fib(n: uint32): uint32
[ 240.85]           > fib(n: uint32): uint32
[ 240.86]           < return
[ 240.87]           > fib(n: uint32): uint32
[ 240.88]           < return
[ 240.88]          < return
[ 240.89]          > fib(n: uint32): uint32
[ 240.90]          < return
[ 240.91]         < return
[ 240.91]        < return
[ 240.92]        > fib(n: uint32): uint32
[ 240.93]         > fib(n: uint32): uint32
[ 240.94]          > fib(n: uint32): uint32
[ 240.95]           > fib(n: uint32): uint32
[ 240.96]           < return
[ 240.97]           > fib(n: uint32): uint32
[ 240.98]           < return
[ 240.98]          < return
[ 240.99]          > fib(n: uint32): uint32
[ 241.00]          < return
[ 241.01]         < return
[ 241.01]         > fib(n: uint32): uint32
[ 241.02]          > fib(n: uint32): uint32
[ 241.03]          < return
[ 241.04]          > fib(n: uint32): uint32
[ 241.05]          < return
[ 241.06]         < return
[ 241.06]        < return
[ 241.08]       < return
[ 241.09]      < return
[ 241.09]     < return
[ 241.10]     > fib(n: uint32): uint32
[ 241.12]      > fib(n: uint32): uint32
[ 241.13]       > fib(n: uint32): uint32
[ 241.15]        > fib(n: uint32): uint32
[ 241.16]         > fib(n: uint32): uint32
[ 241.17]          > fib(n: uint32): uint32
[ 241.18]           > fib(n: uint32): uint32
[ 241.19]            > fib(n: uint32): uint32
[ 241.20]             > fib(n: uint32): uint32
[ 241.21]             < return
[ 241.21]             > fib(n: uint32): uint32
[ 241.22]             < return
[ 241.23]            < return
[ 241.24]            > fib(n: uint32): uint32
[ 241.25]            < return
[ 241.25]           < return
[ 241.26]           > fib(n: uint32): uint32
[ 241.27]            > fib(n: uint32): uint32
[ 241.28]            < return
[ 241.28]            > fib(n: uint32): uint32
[ 241.29]            < return
[ 241.30]           < return
[ 241.31]          < return
[ 241.33]          > fib(n: uint32): uint32
[ 241.35]           > fib(n: uint32): uint32
[ 241.36]            > fib(n: uint32): uint32
[ 241.37]            < return
[ 241.38]            > fib(n: uint32): uint32
[ 241.39]            < return
[ 241.40]           < return
[ 241.40]           > fib(n: uint32): uint32
[ 241.43]           < return
[ 241.44]          < return
[ 241.45]         < return
[ 241.46]         > fib(n: uint32): uint32
[ 241.47]          > fib(n: uint32): uint32
[ 241.48]           > fib(n: uint32): uint32
[ 241.49]            > fib(n: uint32): uint32
[ 241.50]            < return
[ 241.51]            > fib(n: uint32): uint32
[ 241.53]            < return
[ 241.54]           < return
[ 241.54]           > fib(n: uint32): uint32
[ 241.55]           < return
[ 241.56]          < return
[ 241.57]          > fib(n: uint32): uint32
[ 241.58]           > fib(n: uint32): uint32
[ 241.59]           < return
[ 241.59]           > fib(n: uint32): uint32
[ 241.60]           < return
[ 241.61]          < return
[ 241.61]         < return
[ 241.62]        < return
[ 241.63]        > fib(n: uint32): uint32
[ 241.64]         > fib(n: uint32): uint32
[ 241.65]          > fib(n: uint32): uint32
[ 241.66]           > fib(n: uint32): uint32
[ 241.68]            > fib(n: uint32): uint32
[ 241.69]            < return
[ 241.70]            > fib(n: uint32): uint32
[ 241.71]            < return
[ 241.73]           < return
[ 241.74]           > fib(n: uint32): uint32
[ 241.74]           < return
[ 241.75]          < return
[ 241.76]          > fib(n: uint32): uint32
[ 241.77]           > fib(n: uint32): uint32
[ 241.78]           < return
[ 241.78]           > fib(n: uint32): uint32
[ 241.79]           < return
[ 241.80]          < return
[ 241.81]         < return
[ 241.81]         > fib(n: uint32): uint32
[ 241.82]          > fib(n: uint32): uint32
[ 241.83]           > fib(n: uint32): uint32
[ 241.84]           < return
[ 241.85]           > fib(n: uint32): uint32
[ 241.86]           < return
[ 241.87]          < return
[ 241.87]          > fib(n: uint32): uint32
[ 241.88]          < return
[ 241.89]         < return
[ 241.89]        < return
[ 241.90]       < return
[ 241.91]       > fib(n: uint32): uint32
[ 241.92]        > fib(n: uint32): uint32
[ 241.93]         > fib(n: uint32): uint32
[ 241.94]          > fib(n: uint32): uint32
[ 241.95]           > fib(n: uint32): uint32
[ 241.96]            > fib(n: uint32): uint32
[ 241.98]            < return
[ 242.00]            > fib(n: uint32): uint32
[ 242.01]            < return
[ 242.02]           < return
[ 242.03]           > fib(n: uint32): uint32
[ 242.03]           < return
[ 242.04]          < return
[ 242.05]          > fib(n: uint32): uint32
[ 242.06]           > fib(n: uint32): uint32
[ 242.07]           < return
[ 242.09]           > fib(n: uint32): uint32
[ 242.10]           < return
[ 242.10]          < return
[ 242.11]         < return
[ 242.12]         > fib(n: uint32): uint32
[ 242.13]          > fib(n: uint32): uint32
[ 242.14]           > fib(n: uint32): uint32
[ 242.15]           < return
[ 242.15]           > fib(n: uint32): uint32
[ 242.16]           < return
[ 242.17]          < return
[ 242.18]          > fib(n: uint32): uint32
[ 242.19]          < return
[ 242.19]         < return
[ 242.20]        < return
[ 242.21]        > fib(n: uint32): uint32
[ 242.22]         > fib(n: uint32): uint32
[ 242.23]          > fib(n: uint32): uint32
[ 242.24]           > fib(n: uint32): uint32
[ 242.25]           < return
[ 242.25]           > fib(n: uint32): uint32
[ 242.26]           < return
[ 242.27]          < return
[ 242.28]          > fib(n: uint32): uint32
[ 242.28]          < return
[ 242.29]         < return
[ 242.30]         > fib(n: uint32): uint32
[ 242.31]          > fib(n: uint32): uint32
[ 242.32]          < return
[ 242.32]          > fib(n: uint32): uint32
[ 242.35]          < return
[ 242.35]         < return
[ 242.36]        < return
[ 242.37]       < return
[ 242.37]      < return
[ 242.40]      > fib(n: uint32): uint32
[ 242.41]       > fib(n: uint32): uint32
[ 242.41]        > fib(n: uint32): uint32
[ 242.43]         > fib(n: uint32): uint32
[ 242.44]          > fib(n: uint32): uint32
[ 242.44]           > fib(n: uint32): uint32
[ 242.46]            > fib(n: uint32): uint32
[ 242.46]            < return
[ 242.47]            > fib(n: uint32): uint32
[ 242.48]            < return
[ 242.49]           < return
[ 242.49]           > fib(n: uint32): uint32
[ 242.50]           < return
[ 242.51]          < return
[ 242.52]          > fib(n: uint32): uint32
[ 242.53]           > fib(n: uint32): uint32
[ 242.54]           < return
[ 242.55]           > fib(n: uint32): uint32
[ 242.56]           < return
[ 242.56]          < return
[ 242.57]         < return
[ 242.57]         > fib(n: uint32): uint32
[ 242.60]          > fib(n: uint32): uint32
[ 242.61]           > fib(n: uint32): uint32
[ 242.63]           < return
[ 242.64]           > fib(n: uint32): uint32
[ 242.65]           < return
[ 242.66]          < return
[ 242.68]          > fib(n: uint32): uint32
[ 242.69]          < return
[ 242.69]         < return
[ 242.71]        < return
[ 242.73]        > fib(n: uint32): uint32
[ 242.74]         > fib(n: uint32): uint32
[ 242.75]          > fib(n: uint32): uint32
[ 242.76]           > fib(n: uint32): uint32
[ 242.77]           < return
[ 242.79]           > fib(n: uint32): uint32
[ 242.80]           < return
[ 242.81]          < return
[ 242.82]          > fib(n: uint32): uint32
[ 242.83]          < return
[ 242.84]         < return
[ 242.84]         > fib(n: uint32): uint32
[ 242.85]          > fib(n: uint32): uint32
[ 242.86]          < return
[ 242.88]          > fib(n: uint32): uint32
[ 242.89]          < return
[ 242.90]         < return
[ 242.91]        < return
[ 242.91]       < return
[ 242.92]       > fib(n: uint32): uint32
[ 242.93]        > fib(n: uint32): uint32
[ 242.94]         > fib(n: uint32): uint32
[ 242.95]          > fib(n: uint32): uint32
[ 242.96]           > fib(n: uint32): uint32
[ 242.97]           < return
[ 242.97]           > fib(n: uint32): uint32
[ 243.00]           < return
[ 243.00]          < return
[ 243.01]          > fib(n: uint32): uint32
[ 243.02]          < return
[ 243.04]         < return
[ 243.05]         > fib(n: uint32): uint32
[ 243.06]          > fib(n: uint32): uint32
[ 243.07]          < return
[ 243.07]          > fib(n: uint32): uint32
[ 243.08]          < return
[ 243.09]         < return
[ 243.10]        < return
[ 243.10]        > fib(n: uint32): uint32
[ 243.11]         > fib(n: uint32): uint32
[ 243.12]          > fib(n: uint32): uint32
[ 243.13]          < return
[ 243.14]          > fib(n: uint32): uint32
[ 243.15]          < return
[ 243.16]         < return
[ 243.16]         > fib(n: uint32): uint32
[ 243.17]         < return
[ 243.18]        < return
[ 243.19]       < return
[ 243.19]      < return
[ 243.20]     < return
[ 243.20]    < return
[ 243.21]    > fib(n: uint32): uint32
[ 243.22]     > fib(n: uint32): uint32
[ 243.23]      > fib(n: uint32): uint32
[ 243.24]       > fib(n: uint32): uint32
[ 243.25]        > fib(n: uint32): uint32
[ 243.26]         > fib(n: uint32): uint32
[ 243.28]          > fib(n: uint32): uint32
[ 243.29]           > fib(n: uint32): uint32
[ 243.31]            > fib(n: uint32): uint32
[ 243.33]             > fib(n: uint32): uint32
[ 243.34]             < return
[ 243.35]             > fib(n: uint32): uint32
[ 243.35]             < return
[ 243.36]            < return
[ 243.37]            > fib(n: uint32): uint32
[ 243.38]            < return
[ 243.38]           < return
[ 243.39]           > fib(n: uint32): uint32
[ 243.40]            > fib(n: uint32): uint32
[ 243.41]            < return
[ 243.42]            > fib(n: uint32): uint32
[ 243.43]            < return
[ 243.43]           < return
[ 243.44]          < return
[ 243.45]          > fib(n: uint32): uint32
[ 243.46]           > fib(n: uint32): uint32
[ 243.47]            > fib(n: uint32): uint32
[ 243.48]            < return
[ 243.48]            > fib(n: uint32): uint32
[ 243.49]            < return
[ 243.50]           < return
[ 243.51]           > fib(n: uint32): uint32
[ 243.52]           < return
[ 243.52]          < return
[ 243.53]         < return
[ 243.54]         > fib(n: uint32): uint32
[ 243.55]          > fib(n: uint32): uint32
[ 243.56]           > fib(n: uint32): uint32
[ 243.57]            > fib(n: uint32): uint32
[ 243.58]            < return
[ 243.58]            > fib(n: uint32): uint32
[ 243.59]            < return
[ 243.60]           < return
[ 243.61]           > fib(n: uint32): uint32
[ 243.62]           < return
[ 243.62]          < return
[ 243.64]          > fib(n: uint32): uint32
[ 243.66]           > fib(n: uint32): uint32
[ 243.66]           < return
[ 243.69]           > fib(n: uint32): uint32
[ 243.69]           < return
[ 243.70]          < return
[ 243.71]         < return
[ 243.71]        < return
[ 243.72]        > fib(n: uint32): uint32
[ 243.73]         > fib(n: uint32): uint32
[ 243.74]          > fib(n: uint32): uint32
[ 243.75]           > fib(n: uint32): uint32
[ 243.76]            > fib(n: uint32): uint32
[ 243.77]            < return
[ 243.78]            > fib(n: uint32): uint32
[ 243.79]            < return
[ 243.79]           < return
[ 243.80]           > fib(n: uint32): uint32
[ 243.81]           < return
[ 243.82]          < return
[ 243.82]          > fib(n: uint32): uint32
[ 243.84]           > fib(n: uint32): uint32
[ 243.84]           < return
[ 243.85]           > fib(n: uint32): uint32
[ 243.86]           < return
[ 243.87]          < return
[ 243.87]         < return
[ 243.88]         > fib(n: uint32): uint32
[ 243.90]          > fib(n: uint32): uint32
[ 243.91]           > fib(n: uint32): uint32
[ 243.92]           < return
[ 243.93]           > fib(n: uint32): uint32
[ 243.94]           < return
[ 243.95]          < return
[ 243.97]          > fib(n: uint32): uint32
[ 243.98]          < return
[ 243.99]         < return
[ 243.99]        < return
[ 244.00]       < return
[ 244.00]       > fib(n: uint32): uint32
[ 244.01]        > fib(n: uint32): uint32
[ 244.03]         > fib(n: uint32): uint32
[ 244.04]          > fib(n: uint32): uint32
[ 244.05]           > fib(n: uint32): uint32
[ 244.06]            > fib(n: uint32): uint32
[ 244.07]            < return
[ 244.07]            > fib(n: uint32): uint32
[ 244.10]            < return
[ 244.10]           < return
[ 244.11]           > fib(n: uint32): uint32
[ 244.12]           < return
[ 244.13]          < return
[ 244.13]          > fib(n: uint32): uint32
[ 244.14]           > fib(n: uint32): uint32
[ 244.15]           < return
[ 244.16]           > fib(n: uint32): uint32
[ 244.17]           < return
[ 244.18]          < return
[ 244.18]         < return
[ 244.20]         > fib(n: uint32): uint32
[ 244.21]          > fib(n: uint32): uint32
[ 244.25]           > fib(n: uint32): uint32
[ 244.26]           < return
[ 244.27]           > fib(n: uint32): uint32
[ 244.29]           < return
[ 244.30]          < return
[ 244.32]          > fib(n: uint32): uint32
[ 244.33]          < return
[ 244.33]         < return
[ 244.34]        < return
[ 244.36]        > fib(n: uint32): uint32
[ 244.37]         > fib(n: uint32): uint32
[ 244.38]          > fib(n: uint32): uint32
[ 244.39]           > fib(n: uint32): uint32
[ 244.40]           < return
[ 244.41]           > fib(n: uint32): uint32
[ 244.41]           < return
[ 244.42]          < return
[ 244.43]          > fib(n: uint32): uint32
[ 244.44]          < return
[ 244.44]         < return
[ 244.45]         > fib(n: uint32): uint32
[ 244.46]          > fib(n: uint32): uint32
[ 244.47]          < return
[ 244.48]          > fib(n: uint32): uint32
[ 244.49]          < return
[ 244.49]         < return
[ 244.50]        < return
[ 244.51]       < return
[ 244.51]      < return
[ 244.52]      > fib(n: uint32): uint32
[ 244.53]       > fib(n: uint32): uint32
[ 244.54]        > fib(n: uint32): uint32
[ 244.55]         > fib(n: uint32): uint32
[ 244.56]          > fib(n: uint32): uint32
[ 244.57]           > fib(n: uint32): uint32
[ 244.58]            > fib(n: uint32): uint32
[ 244.59]            < return
[ 244.61]            > fib(n: uint32): uint32
[ 244.63]            < return
[ 244.64]           < return
[ 244.65]           > fib(n: uint32): uint32
[ 244.66]           < return
[ 244.66]          < return
[ 244.67]          > fib(n: uint32): uint32
[ 244.68]           > fib(n: uint32): uint32
[ 244.69]           < return
[ 244.71]           > fib(n: uint32): uint32
[ 244.72]           < return
[ 244.73]          < return
[ 244.74]         < return
[ 244.74]         > fib(n: uint32): uint32
[ 244.75]          > fib(n: uint32): uint32
[ 244.76]           > fib(n: uint32): uint32
[ 244.77]           < return
[ 244.78]           > fib(n: uint32): uint32
[ 244.79]           < return
[ 244.80]          < return
[ 244.80]          > fib(n: uint32): uint32
[ 244.81]          < return
[ 244.82]         < return
[ 244.82]        < return
[ 244.83]        > fib(n: uint32): uint32
[ 244.84]         > fib(n: uint32): uint32
[ 244.85]          > fib(n: uint32): uint32
[ 244.86]           > fib(n: uint32): uint32
[ 244.87]           < return
[ 244.88]           > fib(n: uint32): uint32
[ 244.89]           < return
[ 244.90]          < return
[ 244.90]          > fib(n: uint32): uint32
[ 244.91]          < return
[ 244.92]         < return
[ 244.92]         > fib(n: uint32): uint32
[ 244.93]          > fib(n: uint32): uint32
[ 244.94]          < return
[ 244.95]          > fib(n: uint32): uint32
[ 244.96]          < return
[ 244.97]         < return
[ 244.99]        < return
[ 244.99]       < return
[ 245.00]       > fib(n: uint32): uint32
[ 245.01]        > fib(n: uint32): uint32
[ 245.03]         > fib(n: uint32): uint32
[ 245.04]          > fib(n: uint32): uint32
[ 245.05]           > fib(n: uint32): uint32
[ 245.06]           < return
[ 245.07]           > fib(n: uint32): uint32
[ 245.08]           < return
[ 245.09]          < return
[ 245.09]          > fib(n: uint32): uint32
[ 245.10]          < return
[ 245.11]         < return
[ 245.12]         > fib(n: uint32): uint32
[ 245.13]          > fib(n: uint32): uint32
[ 245.13]          < return
[ 245.14]          > fib(n: uint32): uint32
[ 245.15]          < return
[ 245.16]         < return
[ 245.16]        < return
[ 245.17]        > fib(n: uint32): uint32
[ 245.18]         > fib(n: uint32): uint32
[ 245.19]          > fib(n: uint32): uint32
[ 245.22]          < return
[ 245.23]          > fib(n: uint32): uint32
[ 245.24]          < return
[ 245.24]         < return
[ 245.26]         > fib(n: uint32): uint32
[ 245.29]         < return
[ 245.31]        < return
[ 245.32]       < return
[ 245.32]      < return
[ 245.34]     < return
[ 245.35]     > fib(n: uint32): uint32
[ 245.36]      > fib(n: uint32): uint32
[ 245.38]       > fib(n: uint32): uint32
[ 245.41]        > fib(n: uint32): uint32
[ 245.42]         > fib(n: uint32): uint32
[ 245.43]          > fib(n: uint32): uint32
[ 245.44]           > fib(n: uint32): uint32
[ 245.45]            > fib(n: uint32): uint32
[ 245.46]            < return
[ 245.47]            > fib(n: uint32): uint32
[ 245.48]            < return
[ 245.48]           < return
[ 245.50]           > fib(n: uint32): uint32
[ 245.51]           < return
[ 245.52]          < return
[ 245.53]          > fib(n: uint32): uint32
[ 245.54]           > fib(n: uint32): uint32
[ 245.55]           < return
[ 245.55]           > fib(n: uint32): uint32
[ 245.56]           < return
[ 245.57]          < return
[ 245.57]         < return
[ 245.58]         > fib(n: uint32): uint32
[ 245.59]          > fib(n: uint32): uint32
[ 245.60]           > fib(n: uint32): uint32
[ 245.61]           < return
[ 245.62]           > fib(n: uint32): uint32
[ 245.63]           < return
[ 245.65]          < return
[ 245.66]          > fib(n: uint32): uint32
[ 245.66]          < return
[ 245.67]         < return
[ 245.69]        < return
[ 245.70]        > fib(n: uint32): uint32
[ 245.71]         > fib(n: uint32): uint32
[ 245.72]          > fib(n: uint32): uint32
[ 245.73]           > fib(n: uint32): uint32
[ 245.74]           < return
[ 245.75]           > fib(n: uint32): uint32
[ 245.76]           < return
[ 245.76]          < return
[ 245.78]          > fib(n: uint32): uint32
[ 245.79]          < return
[ 245.80]         < return
[ 245.81]         > fib(n: uint32): uint32
[ 245.82]          > fib(n: uint32): uint32
[ 245.83]          < return
[ 245.83]          > fib(n: uint32): uint32
[ 245.84]          < return
[ 245.85]         < return
[ 245.86]        < return
[ 245.86]       < return
[ 245.87]       > fib(n: uint32): uint32
[ 245.90]        > fib(n: uint32): uint32
[ 245.91]         > fib(n: uint32): uint32
[ 245.92]          > fib(n: uint32): uint32
[ 245.95]           > fib(n: uint32): uint32
[ 245.96]           < return
[ 245.96]           > fib(n: uint32): uint32
[ 245.97]           < return
[ 245.98]          < return
[ 245.99]          > fib(n: uint32): uint32
[ 246.01]          < return
[ 246.02]         < return
[ 246.04]         > fib(n: uint32): uint32
[ 246.06]          > fib(n: uint32): uint32
[ 246.07]          < return
[ 246.08]          > fib(n: uint32): uint32
[ 246.09]          < return
[ 246.09]         < return
[ 246.10]        < return
[ 246.11]        > fib(n: uint32): uint32
[ 246.12]         > fib(n: uint32): uint32
[ 246.13]          > fib(n: uint32): uint32
[ 246.14]          < return
[ 246.14]          > fib(n: uint32): uint32
[ 246.15]          < return
[ 246.16]         < return
[ 246.17]         > fib(n: uint32): uint32
[ 246.18]         < return
[ 246.18]        < return
[ 246.19]       < return
[ 246.20]      < return
[ 246.20]      > fib(n: uint32): uint32
[ 246.21]       > fib(n: uint32): uint32
[ 246.22]        > fib(n: uint32): uint32
[ 246.23]         > fib(n: uint32): uint32
[ 246.24]          > fib(n: uint32): uint32
[ 246.25]           > fib(n: uint32): uint32
[ 246.26]           < return
[ 246.27]           > fib(n: uint32): uint32
[ 246.28]           < return
[ 246.28]          < return
[ 246.29]          > fib(n: uint32): uint32
[ 246.30]          < return
[ 246.31]         < return
[ 246.31]         > fib(n: uint32): uint32
[ 246.32]          > fib(n: uint32): uint32
[ 246.33]          < return
[ 246.34]          > fib(n: uint32): uint32
[ 246.35]          < return
[ 246.36]         < return
[ 246.38]        < return
[ 246.38]        > fib(n: uint32): uint32
[ 246.40]         > fib(n: uint32): uint32
[ 246.41]          > fib(n: uint32): uint32
[ 246.43]          < return
[ 246.44]          > fib(n: uint32): uint32
[ 246.44]          < return
[ 246.45]         < return
[ 246.46]         > fib(n: uint32): uint32
[ 246.47]         < return
[ 246.47]        < return
[ 246.48]       < return
[ 246.49]       > fib(n: uint32): uint32
[ 246.50]        > fib(n: uint32): uint32
[ 246.51]         > fib(n: uint32): uint32
[ 246.52]          > fib(n: uint32): uint32
[ 246.53]          < return
[ 246.53]          > fib(n: uint32): uint32
[ 246.54]          < return
[ 246.55]         < return
[ 246.56]         > fib(n: uint32): uint32
[ 246.57]         < return
[ 246.57]        < return
[ 246.58]        > fib(n: uint32): uint32
[ 246.59]         > fib(n: uint32): uint32
[ 246.60]         < return
[ 246.61]         > fib(n: uint32): uint32
[ 246.63]         < return
[ 246.64]        < return
[ 246.64]       < return
[ 246.66]      < return
[ 246.67]     < return
[ 246.68]    < return
[ 246.68]   < return
[ 246.70]   > fib(n: uint32): uint32
[ 246.71]    > fib(n: uint32): uint32
[ 246.74]     > fib(n: uint32): uint32
[ 246.76]      > fib(n: uint32): uint32
[ 246.77]       > fib(n: uint32): uint32
[ 246.78]        > fib(n: uint32): uint32
[ 246.79]         > fib(n: uint32): uint32
[ 246.80]          > fib(n: uint32): uint32
[ 246.83]           > fib(n: uint32): uint32
[ 246.84]            > fib(n: uint32): uint32
[ 246.85]             > fib(n: uint32): uint32
[ 246.86]             < return
[ 246.86]             > fib(n: uint32): uint32
[ 246.87]             < return
[ 246.88]            < return
[ 246.89]            > fib(n: uint32): uint32
[ 246.90]            < return
[ 246.92]           < return
[ 246.92]           > fib(n: uint32): uint32
[ 246.93]            > fib(n: uint32): uint32
[ 246.94]            < return
[ 246.95]            > fib(n: uint32): uint32
[ 246.96]            < return
[ 246.97]           < return
[ 246.97]          < return
[ 246.98]          > fib(n: uint32): uint32
[ 246.99]           > fib(n: uint32): uint32
[ 247.00]            > fib(n: uint32): uint32
[ 247.02]            < return
[ 247.03]            > fib(n: uint32): uint32
[ 247.04]            < return
[ 247.05]           < return
[ 247.05]           > fib(n: uint32): uint32
[ 247.08]           < return
[ 247.08]          < return
[ 247.09]         < return
[ 247.10]         > fib(n: uint32): uint32
[ 247.11]          > fib(n: uint32): uint32
[ 247.12]           > fib(n: uint32): uint32
[ 247.13]            > fib(n: uint32): uint32
[ 247.14]            < return
[ 247.14]            > fib(n: uint32): uint32
[ 247.15]            < return
[ 247.16]           < return
[ 247.17]           > fib(n: uint32): uint32
[ 247.18]           < return
[ 247.18]          < return
[ 247.19]          > fib(n: uint32): uint32
[ 247.20]           > fib(n: uint32): uint32
[ 247.21]           < return
[ 247.22]           > fib(n: uint32): uint32
[ 247.23]           < return
[ 247.23]          < return
[ 247.24]         < return
[ 247.25]        < return
[ 247.25]        > fib(n: uint32): uint32
[ 247.26]         > fib(n: uint32): uint32
[ 247.27]          > fib(n: uint32): uint32
[ 247.28]           > fib(n: uint32): uint32
[ 247.29]            > fib(n: uint32): uint32
[ 247.30]            < return
[ 247.32]            > fib(n: uint32): uint32
[ 247.33]            < return
[ 247.34]           < return
[ 247.35]           > fib(n: uint32): uint32
[ 247.37]           < return
[ 247.38]          < return
[ 247.38]          > fib(n: uint32): uint32
[ 247.39]           > fib(n: uint32): uint32
[ 247.40]           < return
[ 247.41]           > fib(n: uint32): uint32
[ 247.42]           < return
[ 247.43]          < return
[ 247.43]         < return
[ 247.44]         > fib(n: uint32): uint32
[ 247.45]          > fib(n: uint32): uint32
[ 247.46]           > fib(n: uint32): uint32
[ 247.47]           < return
[ 247.47]           > fib(n: uint32): uint32
[ 247.48]           < return
[ 247.49]          < return
[ 247.50]          > fib(n: uint32): uint32
[ 247.51]          < return
[ 247.51]         < return
[ 247.52]        < return
[ 247.53]       < return
[ 247.53]       > fib(n: uint32): uint32
[ 247.54]        > fib(n: uint32): uint32
[ 247.55]         > fib(n: uint32): uint32
[ 247.56]          > fib(n: uint32): uint32
[ 247.57]           > fib(n: uint32): uint32
[ 247.58]            > fib(n: uint32): uint32
[ 247.59]            < return
[ 247.60]            > fib(n: uint32): uint32
[ 247.61]            < return
[ 247.62]           < return
[ 247.62]           > fib(n: uint32): uint32
[ 247.63]           < return
[ 247.64]          < return
[ 247.65]          > fib(n: uint32): uint32
[ 247.66]           > fib(n: uint32): uint32
[ 247.68]           < return
[ 247.69]           > fib(n: uint32): uint32
[ 247.69]           < return
[ 247.70]          < return
[ 247.72]         < return
[ 247.73]         > fib(n: uint32): uint32
[ 247.74]          > fib(n: uint32): uint32
[ 247.75]           > fib(n: uint32): uint32
[ 247.76]           < return
[ 247.77]           > fib(n: uint32): uint32
[ 247.78]           < return
[ 247.78]          < return
[ 247.79]          > fib(n: uint32): uint32
[ 247.80]          < return
[ 247.80]         < return
[ 247.83]        < return
[ 247.84]        > fib(n: uint32): uint32
[ 247.86]         > fib(n: uint32): uint32
[ 247.87]          > fib(n: uint32): uint32
[ 247.88]           > fib(n: uint32): uint32
[ 247.90]           < return
[ 247.91]           > fib(n: uint32): uint32
[ 247.92]           < return
[ 247.94]          < return
[ 247.96]          > fib(n: uint32): uint32
[ 247.97]          < return
[ 247.99]         < return
[ 248.01]         > fib(n: uint32): uint32
[ 248.03]          > fib(n: uint32): uint32
[ 248.04]          < return
[ 248.05]          > fib(n: uint32): uint32
[ 248.06]          < return
[ 248.07]         < return
[ 248.08]        < return
[ 248.10]       < return
[ 248.11]      < return
[ 248.12]      > fib(n: uint32): uint32
[ 248.14]       > fib(n: uint32): uint32
[ 248.17]        > fib(n: uint32): uint32
[ 248.18]         > fib(n: uint32): uint32
[ 248.20]          > fib(n: uint32): uint32
[ 248.21]           > fib(n: uint32): uint32
[ 248.22]            > fib(n: uint32): uint32
[ 248.23]            < return
[ 248.24]            > fib(n: uint32): uint32
[ 248.25]            < return
[ 248.28]           < return
[ 248.29]           > fib(n: uint32): uint32
[ 248.30]           < return
[ 248.31]          < return
[ 248.32]          > fib(n: uint32): uint32
[ 248.34]           > fib(n: uint32): uint32
[ 248.35]           < return
[ 248.38]           > fib(n: uint32): uint32
[ 248.39]           < return
[ 248.41]          < return
[ 248.42]         < return
[ 248.43]         > fib(n: uint32): uint32
[ 248.44]          > fib(n: uint32): uint32
[ 248.46]           > fib(n: uint32): uint32
[ 248.49]           < return
[ 248.50]           > fib(n: uint32): uint32
[ 248.52]           < return
[ 248.53]          < return
[ 248.54]          > fib(n: uint32): uint32
[ 248.56]          < return
[ 248.57]         < return
[ 248.59]        < return
[ 248.61]        > fib(n: uint32): uint32
[ 248.63]         > fib(n: uint32): uint32
[ 248.65]          > fib(n: uint32): uint32
[ 248.66]           > fib(n: uint32): uint32
[ 248.68]           < return
[ 248.69]           > fib(n: uint32): uint32
[ 248.70]           < return
[ 248.71]          < return
[ 248.72]          > fib(n: uint32): uint32
[ 248.74]          < return
[ 248.75]         < return
[ 248.76]         > fib(n: uint32): uint32
[ 248.77]          > fib(n: uint32): uint32
[ 248.79]          < return
[ 248.80]          > fib(n: uint32): uint32
[ 248.81]          < return
[ 248.82]         < return
[ 248.83]        < return
[ 248.84]       < return
[ 248.85]       > fib(n: uint32): uint32
[ 248.87]        > fib(n: uint32): uint32
[ 248.88]         > fib(n: uint32): uint32
[ 248.90]          > fib(n: uint32): uint32
[ 248.92]           > fib(n: uint32): uint32
[ 248.93]           < return
[ 248.94]           > fib(n: uint32): uint32
[ 248.96]           < return
[ 248.97]          < return
[ 248.98]          > fib(n: uint32): uint32
[ 248.99]          < return
[ 249.00]         < return
[ 249.01]         > fib(n: uint32): uint32
[ 249.03]          > fib(n: uint32): uint32
[ 249.04]          < return
[ 249.05]          > fib(n: uint32): uint32
[ 249.06]          < return
[ 249.07]         < return
[ 249.08]        < return
[ 249.09]        > fib(n: uint32): uint32
[ 249.10]         > fib(n: uint32): uint32
[ 249.11]          > fib(n: uint32): uint32
[ 249.12]          < return
[ 249.12]          > fib(n: uint32): uint32
[ 249.13]          < return
[ 249.14]         < return
[ 249.16]         > fib(n: uint32): uint32
[ 249.17]         < return
[ 249.18]        < return
[ 249.19]       < return
[ 249.20]      < return
[ 249.21]     < return
[ 249.21]     > fib(n: uint32): uint32
[ 249.22]      > fib(n: uint32): uint32
[ 249.24]       > fib(n: uint32): uint32
[ 249.25]        > fib(n: uint32): uint32
[ 249.25]         > fib(n: uint32): uint32
[ 249.27]          > fib(n: uint32): uint32
[ 249.28]           > fib(n: uint32): uint32
[ 249.29]            > fib(n: uint32): uint32
[ 249.30]            < return
[ 249.30]            > fib(n: uint32): uint32
[ 249.31]            < return
[ 249.32]           < return
[ 249.33]           > fib(n: uint32): uint32
[ 249.34]           < return
[ 249.35]          < return
[ 249.35]          > fib(n: uint32): uint32
[ 249.37]           > fib(n: uint32): uint32
[ 249.38]           < return
[ 249.39]           > fib(n: uint32): uint32
[ 249.41]           < return
[ 249.42]          < return
[ 249.43]         < return
[ 249.44]         > fib(n: uint32): uint32
[ 249.45]          > fib(n: uint32): uint32
[ 249.47]           > fib(n: uint32): uint32
[ 249.48]           < return
[ 249.51]           > fib(n: uint32): uint32
[ 249.53]           < return
[ 249.54]          < return
[ 249.56]          > fib(n: uint32): uint32
[ 249.59]          < return
[ 249.62]         < return
[ 249.63]        < return
[ 249.64]        > fib(n: uint32): uint32
[ 249.65]         > fib(n: uint32): uint32
[ 249.67]          > fib(n: uint32): uint32
[ 249.69]           > fib(n: uint32): uint32
[ 249.73]           < return
[ 249.74]           > fib(n: uint32): uint32
[ 249.75]           < return
[ 249.78]          < return
[ 249.79]          > fib(n: uint32): uint32
[ 249.80]          < return
[ 249.81]         < return
[ 249.95]         > fib(n: uint32): uint32
[ 249.96]          > fib(n: uint32): uint32
[ 249.98]          < return
[ 250.00]          > fib(n: uint32): uint32
[ 250.02]          < return
[ 250.03]         < return
[ 250.04]        < return
[ 250.05]       < return
[ 250.06]       > fib(n: uint32): uint32
[ 250.07]        > fib(n: uint32): uint32
[ 250.09]         > fib(n: uint32): uint32
[ 250.12]          > fib(n: uint32): uint32
[ 250.13]           > fib(n: uint32): uint32
[ 250.14]           < return
[ 250.14]           > fib(n: uint32): uint32
[ 250.17]           < return
[ 250.17]          < return
[ 250.18]          > fib(n: uint32): uint32
[ 250.19]          < return
[ 250.20]         < return
[ 250.22]         > fib(n: uint32): uint32
[ 250.25]          > fib(n: uint32): uint32
[ 250.26]          < return
[ 250.27]          > fib(n: uint32): uint32
[ 250.29]          < return
[ 250.30]         < return
[ 250.31]        < return
[ 250.32]        > fib(n: uint32): uint32
[ 250.34]         > fib(n: uint32): uint32
[ 250.36]          > fib(n: uint32): uint32
[ 250.37]          < return
[ 250.38]          > fib(n: uint32): uint32
[ 250.40]          < return
[ 250.41]         < return
[ 250.42]         > fib(n: uint32): uint32
[ 250.43]         < return
[ 250.44]        < return
[ 250.45]       < return
[ 250.46]      < return
[ 250.47]      > fib(n: uint32): uint32
[ 250.48]       > fib(n: uint32): uint32
[ 250.50]        > fib(n: uint32): uint32
[ 250.51]         > fib(n: uint32): uint32
[ 250.53]          > fib(n: uint32): uint32
[ 250.55]           > fib(n: uint32): uint32
[ 250.56]           < return
[ 250.57]           > fib(n: uint32): uint32
[ 250.58]           < return
[ 250.59]          < return
[ 250.60]          > fib(n: uint32): uint32
[ 250.63]          < return
[ 250.64]         < return
[ 250.64]         > fib(n: uint32): uint32
[ 250.65]          > fib(n: uint32): uint32
[ 250.66]          < return
[ 250.69]          > fib(n: uint32): uint32
[ 250.71]          < return
[ 250.72]         < return
[ 250.74]        < return
[ 250.75]        > fib(n: uint32): uint32
[ 250.76]         > fib(n: uint32): uint32
[ 250.79]          > fib(n: uint32): uint32
[ 250.80]          < return
[ 250.82]          > fib(n: uint32): uint32
[ 250.83]          < return
[ 250.84]         < return
[ 250.85]         > fib(n: uint32): uint32
[ 250.86]         < return
[ 250.89]        < return
[ 250.90]       < return
[ 250.91]       > fib(n: uint32): uint32
[ 250.94]        > fib(n: uint32): uint32
[ 250.95]         > fib(n: uint32): uint32
[ 250.97]          > fib(n: uint32): uint32
[ 250.98]          < return
[ 250.99]          > fib(n: uint32): uint32
[ 251.01]          < return
[ 251.02]         < return
[ 251.03]         > fib(n: uint32): uint32
[ 251.04]         < return
[ 251.05]        < return
[ 251.06]        > fib(n: uint32): uint32
[ 251.08]         > fib(n: uint32): uint32
[ 251.09]         < return
[ 251.10]         > fib(n: uint32): uint32
[ 251.12]         < return
[ 251.13]        < return
[ 251.14]       < return
[ 251.15]      < return
[ 251.16]     < return
[ 251.17]    < return
[ 251.18]    > fib(n: uint32): uint32
[ 251.19]     > fib(n: uint32): uint32
[ 251.21]      > fib(n: uint32): uint32
[ 251.22]       > fib(n: uint32): uint32
[ 251.24]        > fib(n: uint32): uint32
[ 251.25]         > fib(n: uint32): uint32
[ 251.27]          > fib(n: uint32): uint32
[ 251.28]           > fib(n: uint32): uint32
[ 251.30]            > fib(n: uint32): uint32
[ 251.31]            < return
[ 251.32]            > fib(n: uint32): uint32
[ 251.34]            < return
[ 251.36]           < return
[ 251.37]           > fib(n: uint32): uint32
[ 251.38]           < return
[ 251.39]          < return
[ 251.40]          > fib(n: uint32): uint32
[ 251.42]           > fib(n: uint32): uint32
[ 251.43]           < return
[ 251.44]           > fib(n: uint32): uint32
[ 251.45]           < return
[ 251.46]          < return
[ 251.46]         < return
[ 251.47]         > fib(n: uint32): uint32
[ 251.48]          > fib(n: uint32): uint32
[ 251.50]           > fib(n: uint32): uint32
[ 251.51]           < return
[ 251.52]           > fib(n: uint32): uint32
[ 251.54]           < return
[ 251.55]          < return
[ 251.56]          > fib(n: uint32): uint32
[ 251.56]          < return
[ 251.57]         < return
[ 251.58]        < return
[ 251.59]        > fib(n: uint32): uint32
[ 251.62]         > fib(n: uint32): uint32
[ 251.63]          > fib(n: uint32): uint32
[ 251.65]           > fib(n: uint32): uint32
[ 251.66]           < return
[ 251.67]           > fib(n: uint32): uint32
[ 251.68]           < return
[ 251.69]          < return
[ 251.71]          > fib(n: uint32): uint32
[ 251.72]          < return
[ 251.73]         < return
[ 251.74]         > fib(n: uint32): uint32
[ 251.75]          > fib(n: uint32): uint32
[ 251.77]          < return
[ 251.78]          > fib(n: uint32): uint32
[ 251.82]          < return
[ 251.83]         < return
[ 251.84]        < return
[ 251.85]       < return
[ 251.86]       > fib(n: uint32): uint32
[ 251.88]        > fib(n: uint32): uint32
[ 251.91]         > fib(n: uint32): uint32
[ 251.92]          > fib(n: uint32): uint32
[ 251.93]           > fib(n: uint32): uint32
[ 251.95]           < return
[ 251.96]           > fib(n: uint32): uint32
[ 251.97]           < return
[ 251.98]          < return
[ 251.99]          > fib(n: uint32): uint32
[ 252.00]          < return
[ 252.01]         < return
[ 252.02]         > fib(n: uint32): uint32
[ 252.04]          > fib(n: uint32): uint32
[ 252.05]          < return
[ 252.06]          > fib(n: uint32): uint32
[ 252.07]          < return
[ 252.08]         < return
[ 252.09]        < return
[ 252.10]        > fib(n: uint32): uint32
[ 252.12]         > fib(n: uint32): uint32
[ 252.13]          > fib(n: uint32): uint32
[ 252.14]          < return
[ 252.16]          > fib(n: uint32): uint32
[ 252.17]          < return
[ 252.18]         < return
[ 252.19]         > fib(n: uint32): uint32
[ 252.23]         < return
[ 252.24]        < return
[ 252.26]       < return
[ 252.27]      < return
[ 252.28]      > fib(n: uint32): uint32
[ 252.29]       > fib(n: uint32): uint32
[ 252.31]        > fib(n: uint32): uint32
[ 252.32]         > fib(n: uint32): uint32
[ 252.34]          > fib(n: uint32): uint32
[ 252.35]           > fib(n: uint32): uint32
[ 252.37]           < return
[ 252.38]           > fib(n: uint32): uint32
[ 252.39]           < return
[ 252.41]          < return
[ 252.41]          > fib(n: uint32): uint32
[ 252.43]          < return
[ 252.44]         < return
[ 252.45]         > fib(n: uint32): uint32
[ 252.46]          > fib(n: uint32): uint32
[ 252.48]          < return
[ 252.49]          > fib(n: uint32): uint32
[ 252.50]          < return
[ 252.51]         < return
[ 252.52]        < return
[ 252.53]        > fib(n: uint32): uint32
[ 252.54]         > fib(n: uint32): uint32
[ 252.56]          > fib(n: uint32): uint32
[ 252.57]          < return
[ 252.58]          > fib(n: uint32): uint32
[ 252.59]          < return
[ 252.60]         < return
[ 252.61]         > fib(n: uint32): uint32
[ 252.62]         < return
[ 252.65]        < return
[ 252.66]       < return
[ 252.67]       > fib(n: uint32): uint32
[ 252.70]        > fib(n: uint32): uint32
[ 252.71]         > fib(n: uint32): uint32
[ 252.72]          > fib(n: uint32): uint32
[ 252.74]          < return
[ 252.75]          > fib(n: uint32): uint32
[ 252.76]          < return
[ 252.77]         < return
[ 252.78]         > fib(n: uint32): uint32
[ 252.79]         < return
[ 252.80]        < return
[ 252.81]        > fib(n: uint32): uint32
[ 252.83]         > fib(n: uint32): uint32
[ 252.84]         < return
[ 252.85]         > fib(n: uint32): uint32
[ 252.87]         < return
[ 252.87]        < return
[ 252.88]       < return
[ 252.89]      < return
[ 252.90]     < return
[ 252.90]     > fib(n: uint32): uint32
[ 252.91]      > fib(n: uint32): uint32
[ 252.92]       > fib(n: uint32): uint32
[ 252.93]        > fib(n: uint32): uint32
[ 252.94]         > fib(n: uint32): uint32
[ 252.97]          > fib(n: uint32): uint32
[ 252.99]           > fib(n: uint32): uint32
[ 253.00]           < return
[ 253.01]           > fib(n: uint32): uint32
[ 253.02]           < return
[ 253.03]          < return
[ 253.04]          > fib(n: uint32): uint32
[ 253.05]          < return
[ 253.06]         < return
[ 253.06]         > fib(n: uint32): uint32
[ 253.09]          > fib(n: uint32): uint32
[ 253.10]          < return
[ 253.10]          > fib(n: uint32): uint32
[ 253.13]          < return
[ 253.15]         < return
[ 253.16]        < return
[ 253.17]        > fib(n: uint32): uint32
[ 253.18]         > fib(n: uint32): uint32
[ 253.19]          > fib(n: uint32): uint32
[ 253.20]          < return
[ 253.20]          > fib(n: uint32): uint32
[ 253.21]          < return
[ 253.22]         < return
[ 253.24]         > fib(n: uint32): uint32
[ 253.27]         < return
[ 253.29]        < return
[ 253.31]       < return
[ 253.33]       > fib(n: uint32): uint32
[ 253.36]        > fib(n: uint32): uint32
[ 253.38]         > fib(n: uint32): uint32
[ 253.42]          > fib(n: uint32): uint32
[ 253.43]          < return
[ 253.44]          > fib(n: uint32): uint32
[ 253.46]          < return
[ 253.46]         < return
[ 253.47]         > fib(n: uint32): uint32
[ 253.48]         < return
[ 253.49]        < return
[ 253.50]        > fib(n: uint32): uint32
[ 253.51]         > fib(n: uint32): uint32
[ 253.51]         < return
[ 253.52]         > fib(n: uint32): uint32
[ 253.53]         < return
[ 253.54]        < return
[ 253.55]       < return
[ 253.55]      < return
[ 253.56]      > fib(n: uint32): uint32
[ 253.57]       > fib(n: uint32): uint32
[ 253.58]        > fib(n: uint32): uint32
[ 253.59]         > fib(n: uint32): uint32
[ 253.60]          > fib(n: uint32): uint32
[ 253.61]          < return
[ 253.62]          > fib(n: uint32): uint32
[ 253.63]          < return
[ 253.63]         < return
[ 253.64]         > fib(n: uint32): uint32
[ 253.65]         < return
[ 253.66]        < return
[ 253.66]        > fib(n: uint32): uint32
[ 253.69]         > fib(n: uint32): uint32
[ 253.70]         < return
[ 253.70]         > fib(n: uint32): uint32
[ 253.71]         < return
[ 253.72]        < return
[ 253.73]       < return
[ 253.73]       > fib(n: uint32): uint32
[ 253.76]        > fib(n: uint32): uint32
[ 253.77]         > fib(n: uint32): uint32
[ 253.78]         < return
[ 253.78]         > fib(n: uint32): uint32
[ 253.79]         < return
[ 253.80]        < return
[ 253.81]        > fib(n: uint32): uint32
[ 253.82]        < return
[ 253.82]       < return
[ 253.83]      < return
[ 253.84]     < return
[ 253.84]    < return
[ 253.85]   < return
[ 253.86]  < return
[ 253.89]  > typename.name(type: typename): .cstr
[ 253.91]  < return
[ 253.92]  > typename.file(type: typename): .cstr
[ 253.93]  < return
[ 253.94]  > typename.line(type: typename): int32
[ 253.94]  < return
[ 253.95]  > typename.base(type: typename): typename
[ 253.96]  < return
[ 253.97]  > typename.name(type: typename): .cstr
[ 253.98]  < return
[ 253.99]  > typename.file(type: typename): .cstr
[ 254.00]  < return
[ 254.01]  > typename.line(type: typename): int32
[ 254.01]  < return
[ 254.02]  > typename.base(type: typename): typename
[ 254.03]  < return
[ 254.04]  > typename.base(type: typename): typename
[ 254.05]  < return
[ 254.09]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.10]  < return
[ 254.11]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.12]  < return
[ 254.13]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.14]  < return
[ 254.15]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.15]  < return
[ 254.16]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.17]  < return
[ 254.18]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.19]  < return
[ 254.19]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.20]  < return
[ 254.21]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.22]  < return
[ 254.23]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.25]  < return
[ 254.27]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.28]  < return
[ 254.29]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.29]  < return
[ 254.30]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.31]  < return
[ 254.34]  > float64.sin(x: float64): float64
[ 254.36]  < return
[ 254.37]  > float64.cos(x: float64): float64
[ 254.38]  < return
[ 254.39]  > float64.tan(x: float64): float64
[ 254.40]  < return
[ 254.41]  > float64.log(x: float64): float64
[ 254.42]  < return
[ 254.43]  > float64.exp(x: float64): float64
[ 254.44]  < return
[ 254.45]  > float64.pow(x: float64, y: float64): float64
[ 254.46]  < return
[ 254.46]  > float64.sqrt(x: float64): float64
[ 254.47]  < return
[ 254.48]  > float64.atan2(x: float64, y: float64): float64
[ 254.50]  < return
[ 254.53]  > float32.sin(x: float32): float32
[ 254.54]  < return
[ 254.55]  > float32.cos(x: float32): float32
[ 254.56]  < return
[ 254.56]  > float32.tan(x: float32): float32
[ 254.57]  < return
[ 254.58]  > float32.log(x: float32): float32
[ 254.59]  < return
[ 254.60]  > float32.exp(x: float32): float32
[ 254.61]  < return
[ 254.62]  > float32.pow(x: float32, y: float32): float32
[ 254.63]  < return
[ 254.63]  > float32.sqrt(x: float32): float32
[ 254.64]  < return
[ 254.65]  > float32.atan2(x: float32, y: float32): float32
[ 254.66]  < return
[ 254.67]  > uint32.pop(value: int32): int32
[ 254.68]  < return
[ 254.69]  > uint32.swap(value: int32): int32
[ 254.70]  < return
[ 254.71]  > uint32.bsr(value: int32): int32
[ 254.72]  < return
[ 254.74]  > uint32.bsf(value: int32): int32
[ 254.75]  < return
[ 254.75]  > uint32.hib(value: int32): int32
[ 254.76]  < return
[ 254.77]  > uint32.lob(value: int32): int32
[ 254.79]  < return
[ 254.80]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.81]  < return
[ 254.81]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.82]  < return
[ 254.83]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 254.84]  < return
[ 254.85]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 254.86]  < return
[ 254.87]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 254.88]  < return
[ 254.89]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 254.89]  < return
[ 254.90]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 254.91]  < return
[ 254.92]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 254.93]  < return
[ 254.94]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 254.94]  < return
[ 254.96]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 254.96]  < return
[ 254.97]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 254.98]  < return
[ 254.99]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.00]  < return
[ 255.01]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.02]  < return
[ 255.03]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.03]  < return
[ 255.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 255.07]  < return
[ 255.08]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 255.10]  < return
[ 255.11]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 255.12]  < return
[ 255.13]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 255.14]  < return
[ 255.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 255.17]  < return
[ 255.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 255.20]  < return
[ 255.21]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 255.22]   > noError(ptr: pointer): void
[ 255.23]   < return
[ 255.24]   > halt(): void
[ 255.25]   < return
[ 255.25]  < return
[ 255.26]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 255.27]  < return
[ 255.28]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 255.29]   > stackOverflow(ptr: pointer): void
[ 255.30]    > stackOverflow(ptr: pointer): void
[ 255.31]     > stackOverflow(ptr: pointer): void
[ 255.32]      > stackOverflow(ptr: pointer): void
[ 255.32]       > stackOverflow(ptr: pointer): void
[ 255.33]        > stackOverflow(ptr: pointer): void
[ 255.34]         > stackOverflow(ptr: pointer): void
[ 255.35]          > stackOverflow(ptr: pointer): void
[ 255.36]           > stackOverflow(ptr: pointer): void
[ 255.37]            > stackOverflow(ptr: pointer): void
[ 255.38]             > stackOverflow(ptr: pointer): void
[ 255.39]              > stackOverflow(ptr: pointer): void
[ 255.40]               > stackOverflow(ptr: pointer): void
[ 255.41]                > stackOverflow(ptr: pointer): void
[ 255.42]                 > stackOverflow(ptr: pointer): void
[ 255.43]                  > stackOverflow(ptr: pointer): void
[ 255.44]                   > stackOverflow(ptr: pointer): void
[ 255.45]                    > stackOverflow(ptr: pointer): void
[ 255.46]                     > stackOverflow(ptr: pointer): void
[ 255.47]                      > stackOverflow(ptr: pointer): void
[ 255.47]                       > stackOverflow(ptr: pointer): void
[ 255.48]                        > stackOverflow(ptr: pointer): void
[ 255.49]                         > stackOverflow(ptr: pointer): void
[ 255.50]                          > stackOverflow(ptr: pointer): void
[ 255.51]                           > stackOverflow(ptr: pointer): void
[ 255.52]                            > stackOverflow(ptr: pointer): void
[ 255.53]                             > stackOverflow(ptr: pointer): void
[ 255.54]                              > stackOverflow(ptr: pointer): void
[ 255.55]                               > stackOverflow(ptr: pointer): void
[ 255.56]                                > stackOverflow(ptr: pointer): void
[ 255.57]                                 > stackOverflow(ptr: pointer): void
[ 255.58]                                  > stackOverflow(ptr: pointer): void
[ 255.59]                                   > stackOverflow(ptr: pointer): void
[ 255.60]                                    > stackOverflow(ptr: pointer): void
[ 255.60]                                     > stackOverflow(ptr: pointer): void
[ 255.62]                                      > stackOverflow(ptr: pointer): void
[ 255.62]                                       > stackOverflow(ptr: pointer): void
[ 255.63]                                        > stackOverflow(ptr: pointer): void
[ 255.64]                                         > stackOverflow(ptr: pointer): void
[ 255.65]                                          > stackOverflow(ptr: pointer): void
[ 255.66]                                           > stackOverflow(ptr: pointer): void
[ 255.67]                                            > stackOverflow(ptr: pointer): void
[ 255.68]                                             > stackOverflow(ptr: pointer): void
[ 255.69]                                              > stackOverflow(ptr: pointer): void
[ 255.70]                                               > stackOverflow(ptr: pointer): void
[ 255.71]                                                > stackOverflow(ptr: pointer): void
[ 255.72]                                                 > stackOverflow(ptr: pointer): void
[ 255.73]                                                  > stackOverflow(ptr: pointer): void
[ 255.74]                                                   > stackOverflow(ptr: pointer): void
[ 255.75]                                                    > stackOverflow(ptr: pointer): void
[ 255.75]                                                     > stackOverflow(ptr: pointer): void
[ 255.76]                                                      > stackOverflow(ptr: pointer): void
[ 255.77]                                                       > stackOverflow(ptr: pointer): void
[ 255.79]                                                        > stackOverflow(ptr: pointer): void
[ 255.79]                                                         > stackOverflow(ptr: pointer): void
[ 255.81]                                                          > stackOverflow(ptr: pointer): void
[ 255.81]                                                           > stackOverflow(ptr: pointer): void
[ 255.82]                                                            > stackOverflow(ptr: pointer): void
[ 255.83]                                                             > stackOverflow(ptr: pointer): void
[ 255.84]                                                              > stackOverflow(ptr: pointer): void
[ 255.85]                                                               > stackOverflow(ptr: pointer): void
[ 255.86]                                                                > stackOverflow(ptr: pointer): void
[ 255.87]                                                                 > stackOverflow(ptr: pointer): void
[ 255.88]                                                                  > stackOverflow(ptr: pointer): void
[ 255.89]                                                                  < return
[ 255.91]                                                                 < return
[ 255.94]                                                                < return
[ 255.94]                                                               < return
[ 255.95]                                                              < return
[ 255.96]                                                             < return
[ 255.97]                                                            < return
[ 255.98]                                                           < return
[ 256.00]                                                          < return
[ 256.01]                                                         < return
[ 256.01]                                                        < return
[ 256.02]                                                       < return
[ 256.03]                                                      < return
[ 256.03]                                                     < return
[ 256.04]                                                    < return
[ 256.05]                                                   < return
[ 256.05]                                                  < return
[ 256.06]                                                 < return
[ 256.08]                                                < return
[ 256.09]                                               < return
[ 256.10]                                              < return
[ 256.10]                                             < return
[ 256.11]                                            < return
[ 256.11]                                           < return
[ 256.12]                                          < return
[ 256.13]                                         < return
[ 256.13]                                        < return
[ 256.14]                                       < return
[ 256.15]                                      < return
[ 256.15]                                     < return
[ 256.16]                                    < return
[ 256.17]                                   < return
[ 256.17]                                  < return
[ 256.18]                                 < return
[ 256.19]                                < return
[ 256.21]                               < return
[ 256.22]                              < return
[ 256.23]                             < return
[ 256.23]                            < return
[ 256.24]                           < return
[ 256.25]                          < return
[ 256.25]                         < return
[ 256.26]                        < return
[ 256.26]                       < return
[ 256.27]                      < return
[ 256.28]                     < return
[ 256.28]                    < return
[ 256.29]                   < return
[ 256.30]                  < return
[ 256.31]                 < return
[ 256.31]                < return
[ 256.32]               < return
[ 256.32]              < return
[ 256.33]             < return
[ 256.34]            < return
[ 256.34]           < return
[ 256.35]          < return
[ 256.36]         < return
[ 256.36]        < return
[ 256.37]       < return
[ 256.38]      < return
[ 256.38]     < return
[ 256.39]    < return
[ 256.39]   < return
[ 256.40]  < return
[ 256.41]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.42]   > divisionByZero(args: pointer): void
[ 256.43]   < return
[ 256.43]  < return
[ 256.44]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.45]   > invalidInstruction(args: pointer): void
[ 256.46]   < return
[ 256.47]  < return
[ 256.48]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.48]   > invalidMemoryAccess(args: pointer): void
[ 256.49]   < return
[ 256.50]  < return
[ 256.51]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.52]   > abortExecution(args: pointer): void
[ 256.53]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 256.61]    < return
[ 256.62]   < return
[ 256.63]  < return
[ 256.73]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 256.74]  < return
[ 256.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 256.82]  < return
[ 256.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 256.89]  < return
[ 256.91]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 256.93]  < return
[ 256.94]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 256.97]  < return
[ 256.98]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 257.02]  < return
[ 257.03]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 257.05]  < return
[ 257.09]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.10]  < return
[ 257.11]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.12]  < return
[ 257.13]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.14]  < return
[ 257.15]  > lenSlice(values: int64[]): int32
[ 257.16]  < return
[ 257.17]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.18]  < return
[ 257.19]  > lenSlice(values: int64[]): int32
[ 257.20]  < return
[ 257.20]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.21]  < return
[ 257.22]  > lenSlice(values: int64[]): int32
[ 257.23]  < return
[ 257.24]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.25]  < return
[ 257.26]  > lenSlice(values: int64[]): int32
[ 257.27]  < return
[ 257.28]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.29]  < return
[ 257.30]  > lenSlice(values: int64[]): int32
[ 257.31]  < return
[ 257.32]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 257.33]  < return
[ 257.36]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.38]  < return
[ 257.40]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.42]  < return
[ 257.43]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.44]  < return
[ 257.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.46]  < return
[ 257.48]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.49]  < return
[ 257.50]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.51]  < return
[ 257.53]  > nthSlice(idx: int32, values: int64[]): int64
[ 257.54]  < return
[ 257.55]  > nthSlice(idx: int32, values: int64[]): int64
[ 257.58]  < return
[ 257.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.65]  < return
[ 257.67]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.68]  < return
[ 257.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.71]  < return
[ 257.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.73]  < return
[ 257.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.75]  < return
[ 257.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.78]  < return
[ 257.79]  > nthSlice(idx: int32, values: int64[]): int64
[ 257.80]  < return
[ 257.82]  > nthSlice(idx: int32, values: int64[]): int64
[ 257.83]  < return
[ 257.87]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.88]  < return
[ 257.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.91]  < return
[ 257.92]  > nthFixed(idx: int32, values: int64[7]): int64
[ 257.93]  < return
[ 257.95]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.96]  < return
[ 257.97]  > nthArray(idx: int32, values: int64[*]): int64
[ 257.98]  < return
[ 258.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.01]  < return
[ 258.02]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.03]  < return
[ 258.05]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.06]  < return
[ 258.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.11]  < return
[ 258.12]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.14]  < return
[ 258.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.16]  < return
[ 258.17]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.19]  < return
[ 258.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.21]  < return
[ 258.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.24]  < return
[ 258.25]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.26]  < return
[ 258.27]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.29]  < return
[ 258.33]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.34]  < return
[ 258.36]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.37]  < return
[ 258.38]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.39]  < return
[ 258.40]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.42]  < return
[ 258.43]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.44]  < return
[ 258.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.46]  < return
[ 258.48]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.49]  < return
[ 258.50]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.51]  < return
[ 258.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.61]  < return
[ 258.64]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.66]  < return
[ 258.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.70]  < return
[ 258.71]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.72]  < return
[ 258.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.75]  < return
[ 258.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.79]  < return
[ 258.80]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.81]  < return
[ 258.82]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.83]  < return
[ 258.88]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.89]  < return
[ 258.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.92]  < return
[ 258.93]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.94]  < return
[ 258.95]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.96]  < return
[ 258.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.99]  < return
[ 259.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.01]  < return
[ 259.03]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.04]  < return
[ 259.05]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.06]  < return
[ 259.11]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 259.12]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(1)
	test/lang/method.ci:58: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 259.23]   < return
[ 259.24]  < return
[ 259.25]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 259.26]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(1)
	test/lang/method.ci:59: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 259.33]   < return
[ 259.34]  < return
[ 259.35]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 259.36]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:63: debug: extension.staticMethod
[ 259.38]   < return
[ 259.39]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 259.40]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(2)
	test/lang/method.ci:65: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:75: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 259.55]    < return
[ 259.56]   < return
[ 259.57]  < return
[ 259.58]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 259.59]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:69: debug: extension.virtualMethod
[ 259.62]   < return
[ 259.63]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 259.64]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(2)
	test/lang/method.ci:71: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:76: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 259.79]    < return
[ 259.80]   < return
[ 259.80]  < return
[ 259.81]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 259.82]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(3)
	test/lang/method.ci:79: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 259.94]   < return
[ 259.95]  < return
[ 259.96]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 259.97]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:80: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 260.05]   < return
[ 260.06]  < return
[ 260.07]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 260.09]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:81: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 260.18]   < return
[ 260.19]  < return
[ 261.13]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 261.15]  < return
[ 261.17]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 261.21]  < return
[ 261.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 261.27]  < return
[ 261.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 261.38]  < return
[ 261.42]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 261.46]  < return
[ 261.48]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 261.55]  < return
[ 261.58]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 261.63]  < return
[ 261.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 261.70]  < return
[ 261.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 261.77]  < return
[ 261.82]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 261.84]  < return
[ 261.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 261.96]  < return
[ 262.01]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 262.03]  < return
[ 262.10]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 262.12]  < return
[ 262.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 262.18]  < return
[ 262.21]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 262.23]  < return
[ 262.29]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 262.31]  < return
[ 262.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 262.36]  < return
[ 262.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 262.42]  < return
[ 262.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 262.46]  < return
[ 262.50]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 262.52]  < return
[ 262.55]  > Math.floor(x: float64): float64
[ 262.56]   > Math.modf(x: float64, intPart: float64): float64
[ 262.58]   < return
[ 262.59]  < return
[ 262.63]  > Math.floor(x: float64): float64
[ 262.64]   > Math.modf(x: float64, intPart: float64): float64
[ 262.65]   < return
[ 262.66]  < return
[ 262.67]  > Math.floor(x: float64): float64
[ 262.68]   > Math.modf(x: float64, intPart: float64): float64
[ 262.69]   < return
[ 262.70]  < return
[ 262.72]  > Math.floor(x: float64): float64
[ 262.73]   > Math.modf(x: float64, intPart: float64): float64
[ 262.73]    > Math.modf(x: float64, intPart: float64): float64
[ 262.74]    < return
[ 262.75]   < return
[ 262.75]  < return
[ 262.77]  > Math.floor(x: float64): float64
[ 262.77]   > Math.modf(x: float64, intPart: float64): float64
[ 262.78]    > Math.modf(x: float64, intPart: float64): float64
[ 262.80]    < return
[ 262.81]   < return
[ 262.82]  < return
[ 262.83]  > Math.floor(x: float64): float64
[ 262.84]   > Math.modf(x: float64, intPart: float64): float64
[ 262.86]    > Math.modf(x: float64, intPart: float64): float64
[ 262.87]    < return
[ 262.87]   < return
[ 262.89]  < return
[ 262.90]  > Math.sign(x: float64): int32
[ 262.93]  < return
[ 262.94]  > Math.sign(x: float64): int32
[ 262.95]  < return
[ 262.98]  > Math.sign(x: float64): int32
[ 263.00]  < return
[ 263.01]  > Math.sign(x: float32): int32
[ 263.02]  < return
[ 263.04]  > Math.sign(x: float32): int32
[ 263.04]  < return
[ 263.06]  > Math.sign(x: float32): int32
[ 263.08]  < return
[ 263.09]  > Math.abs(x: float64): float64
[ 263.10]  < return
[ 263.11]  > Math.abs(x: float64): float64
[ 263.12]  < return
[ 263.13]  > Math.abs(x: float64): float64
[ 263.14]  < return
[ 263.15]  > Math.abs(x: float32): float32
[ 263.16]  < return
[ 263.17]  > Math.abs(x: float32): float32
[ 263.19]  < return
[ 263.20]  > Math.abs(x: float32): float32
[ 263.22]  < return
[ 263.24]  > Math.min(a: float32, b: float32): float32
[ 263.25]  < return
[ 263.26]  > Math.max(a: float32, b: float32): float32
[ 263.27]  < return
[ 263.30]  > Math.min(a: float64, b: float64): float64
[ 263.31]  < return
[ 263.32]  > Math.max(a: float64, b: float64): float64
[ 263.32]  < return
[ 263.34]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 263.37]  < return
[ 263.38]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 263.41]  < return
[ 263.47]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 263.48]  < return
[ 263.52]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 263.55]  < return
[ 263.57]  > Math.min(data: float64[]): float64
[ 263.58]  < return
[ 263.60]  > Math.min(data: float64[]): float64
[ 263.66]  < return
[ 263.69]  > Math.max(data: float64[]): float64
[ 263.72]  < return
[ 263.74]  > Math.max(data: float64[]): float64
[ 263.78]  < return
[ 263.80]  > Math.sum(data: float64[]): float64
[ 263.81]  < return
[ 263.82]  > Math.sum(data: float64[]): float64
[ 263.84]  < return
[ 263.86]  > Math.sum(data: float64[]): float64
[ 263.88]  < return
[ 263.90]  > Math.sum(data: float64[]): float64
[ 263.95]  < return
[ 263.96]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 263.98]  < return
[ 264.08]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 264.11]  < return
[ 264.13]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 264.17]  < return
[ 264.18]  > Math.sinCos(arg: float64, quad: int32): float64
[ 264.22]  < return
[ 264.24]  > Math.abs(x: float64): float64
[ 264.26]  < return
[ 264.27]  > Math.sinCos(arg: float64, quad: int32): float64
[ 264.29]  < return
[ 264.31]  > Math.tan(arg: float64): float64
[ 264.32]   > Math.modf(x: float64, intPart: float64): float64
[ 264.33]   < return
[ 264.35]  < return
[ 264.37]  > Math.sinh(x: float64): float64
[ 264.38]   > float64.exp(x: float64): float64
[ 264.40]   < return
[ 264.41]   > float64.exp(x: float64): float64
[ 264.42]   < return
[ 264.43]  < return
[ 264.44]  > Math.cosh(x: float64): float64
[ 264.45]   > float64.exp(x: float64): float64
[ 264.46]   < return
[ 264.47]   > float64.exp(x: float64): float64
[ 264.47]   < return
[ 264.48]  < return
[ 264.49]  > Math.asin(x: float64): float64
[ 264.51]   > float64.sqrt(x: float64): float64
[ 264.51]   < return
[ 264.52]   > float64.atan2(x: float64, y: float64): float64
[ 264.53]   < return
[ 264.54]  < return
[ 264.55]  > Math.asin(x: float64): float64
[ 264.57]   > float64.sqrt(x: float64): float64
[ 264.57]   < return
[ 264.58]   > float64.atan2(x: float64, y: float64): float64
[ 264.59]   < return
[ 264.60]  < return
[ 264.61]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 264.65]  < return
[ 264.67]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 264.68]  < return
[ 264.70]  > Math.absMod(val: float64, mod: float64): float64
[ 264.74]  < return
[ 264.76]  > Math.absMod(val: float64, mod: float64): float64
[ 264.77]  < return
[ 264.81]  > Math.absMod(val: float64, mod: float64): float64
[ 264.82]  < return
[ 264.84]  > Math.absMod(val: float64, mod: float64): float64
[ 264.86]  < return
[ 264.90]  > Math.absMod(val: float64, mod: float64): float64
[ 264.93]  < return
[ 264.96]  > Math.absMod(val: float64, mod: float64): float64
[ 264.97]  < return
[ 264.99]  > Math.absMod(val: float64, mod: float64): float64
[ 265.01]  < return
[ 265.05]  > Math.absMod(val: float64, mod: float64): float64
[ 265.06]  < return
[ 265.08]  > Math.absMod(val: float64, mod: float64): float64
[ 265.09]  < return
[ 265.11]  > Math.absMod(val: float64, mod: float64): float64
[ 265.12]  < return
[ 265.14]  > Math.absMod(val: float64, mod: float64): float64
[ 265.15]  < return
[ 265.17]  > Math.absMod(val: float32, mod: float32): float32
[ 265.18]  < return
[ 265.20]  > Math.absMod(val: float32, mod: float32): float32
[ 265.23]  < return
[ 265.25]  > Math.absMod(val: float32, mod: float32): float32
[ 265.28]  < return
[ 265.31]  > Math.absMod(val: float32, mod: float32): float32
[ 265.32]  < return
[ 265.34]  > Math.absMod(val: float32, mod: float32): float32
[ 265.35]  < return
[ 265.38]  > Math.absMod(val: float32, mod: float32): float32
[ 265.39]  < return
[ 265.41]  > Math.absMod(val: float32, mod: float32): float32
[ 265.42]  < return
[ 265.46]  > Math.absMod(val: float32, mod: float32): float32
[ 265.47]  < return
[ 265.50]  > Math.absMod(val: float32, mod: float32): float32
[ 265.51]  < return
[ 265.53]  > Math.absMod(val: float32, mod: float32): float32
[ 265.55]  < return
[ 265.56]  > Math.absMod(val: float32, mod: float32): float32
[ 265.57]  < return
[ 265.59]  > halt(): void
[ 265.60]  < return
[ 265.61] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:39: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:46: Math.floor: function(<Math.floor>)
lib/std/math.ci:58: Math.sign: function(<Math.sign>)
lib/std/math.ci:67: Math.sign: function(<Math.sign>)
lib/std/math.ci:83: Math.abs: function(<Math.abs>)
lib/std/math.ci:89: Math.abs: function(<Math.abs>)
lib/std/math.ci:95: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:114: Math.min: function(<Math.min>)
lib/std/math.ci:120: Math.min: function(<Math.min>)
lib/std/math.ci:132: Math.max: function(<Math.max>)
lib/std/math.ci:138: Math.max: function(<Math.max>)
lib/std/math.ci:150: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:185: Math.min: function(<Math.min>)
lib/std/math.ci:197: Math.max: function(<Math.max>)
lib/std/math.ci:210: Math.sum: function(<Math.sum>)
lib/std/math.ci:228: Math.eval: function(<Math.eval>)
lib/std/math.ci:236: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:249: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:263: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:320: Math.tan: function(<Math.tan>)
lib/std/math.ci:377: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:416: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:432: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
lib/vec/vec2d.ci:3: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:8: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:3: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:21: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:3: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:13: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:25: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:33: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(136)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(196512)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(196240)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2472)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(136)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:11: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:25: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:30: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:40: globalFunction: function(<globalFunction>)
test/lang/method.ci:44: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:62: staticMethod: function(<staticMethod>)
test/lang/method.ci:68: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_0f: float64(0.000000)
test/stdc/test.math.ci:36: testMathSmooth_0F: float64(0.000000)
test/stdc/test.math.ci:37: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:38: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:40: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:42: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:43: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:45: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:46: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:47: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:48: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:50: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:51: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:52: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:53: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:54: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:55: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:56: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:57: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:59: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:61: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:62: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:63: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:65: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:66: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:69: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:70: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:73: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:78: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:83: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:87: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:92: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:97: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:98: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 304262(297.1 Kb)
memory[heap] @04a486; size: 1268344(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 288312(281.6 Kb)
memory[code] @000000; size: 15604(15.2 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @04a498; size: 1268304(1.2 Mb)

---------- Profile functions: 81/115, coverage: 70.43%
::[.0052b0, .0052b0): exec(2), time(0.019 ms): halt(): void
::[.0055a8, .0055a8): exec(3), time(0.024 ms): typename.base(type: typename): typename
::[.005778, .005778): exec(2), time(0.018 ms): typename.file(type: typename): .cstr
::[.005948, .005948): exec(2), time(0.017 ms): typename.line(type: typename): int32
::[.005b18, .005b18): exec(2), time(0.022 ms): typename.name(type: typename): .cstr
::[.0061f0, .0061f0): exec(40), time(1.827 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0069f0, .0069f0): exec(7), time(1.364 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.006c50, .006c50): exec(8), time(0.064 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.006f40, .006f40): exec(2), time(0.017 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007228, .007228): exec(2), time(0.018 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.007508, .007508): exec(1), time(0.009 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.007770, .007770): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.007948, .007948): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.007a90, .007a90): exec(0), time(0.000 ms): System.rand(): int32
::[.007bd8, .007bd8): exec(0), time(0.000 ms): System.time(): int32
::[.007d20, .007d20): exec(0), time(0.000 ms): System.clock(): int32
::[.007e68, .007e68): exec(0), time(0.000 ms): System.millis(): int64
::[.008038, .008038): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.008328, .008328): exec(7), time(0.065 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.008608, .008608): exec(7), time(0.057 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0087d8, .0087d8): exec(1), time(0.008 ms): uint32.pop(value: int32): int32
::[.0089a8, .0089a8): exec(1), time(0.008 ms): uint32.swap(value: int32): int32
::[.008b78, .008b78): exec(1), time(0.008 ms): uint32.bsr(value: int32): int32
::[.008d48, .008d48): exec(1), time(0.021 ms): uint32.bsf(value: int32): int32
::[.008f18, .008f18): exec(1), time(0.008 ms): uint32.hib(value: int32): int32
::[.0090e8, .0090e8): exec(1), time(0.021 ms): uint32.lob(value: int32): int32
::[.0093c0, .0093c0): exec(1), time(0.008 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.009698, .009698): exec(1), time(0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.009870, .009870): exec(1), time(0.010 ms): float32.sin(x: float32): float32
::[.009a40, .009a40): exec(1), time(0.008 ms): float32.cos(x: float32): float32
::[.009c10, .009c10): exec(1), time(0.011 ms): float32.tan(x: float32): float32
::[.009de0, .009de0): exec(1), time(0.008 ms): float32.log(x: float32): float32
::[.009fb0, .009fb0): exec(1), time(0.008 ms): float32.exp(x: float32): float32
::[.00a210, .00a210): exec(1), time(0.008 ms): float32.pow(x: float32, y: float32): float32
::[.00a3e0, .00a3e0): exec(1), time(0.008 ms): float32.sqrt(x: float32): float32
::[.00a638, .00a638): exec(1), time(0.010 ms): float32.atan2(x: float32, y: float32): float32
::[.00a800, .00a800): exec(1), time(0.022 ms): float64.sin(x: float64): float64
::[.00a9c8, .00a9c8): exec(1), time(0.012 ms): float64.cos(x: float64): float64
::[.00ab90, .00ab90): exec(1), time(0.008 ms): float64.tan(x: float64): float64
::[.00ad58, .00ad58): exec(1), time(0.013 ms): float64.log(x: float64): float64
::[.00af20, .00af20): exec(5), time(0.054 ms): float64.exp(x: float64): float64
::[.00b170, .00b170): exec(1), time(0.008 ms): float64.pow(x: float64, y: float64): float64
::[.00b338, .00b338): exec(3), time(0.022 ms): float64.sqrt(x: float64): float64
::[.00b588, .00b588): exec(3), time(0.039 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:39:[.046638, .046696): exec(8), time(0.072 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.046698, .0466ee): exec(10), time(0.150 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:46:[.0466f0, .046708): exec(6), time(0.274-0.140 ms): Math.floor(x: float64): float64
lib/std/math.ci:58:[.046708, .04672c): exec(3), time(0.040 ms): Math.sign(x: float32): int32
lib/std/math.ci:67:[.046730, .046754): exec(3), time(0.053 ms): Math.sign(x: float64): int32
lib/std/math.ci:83:[.046758, .04676a): exec(3), time(0.051 ms): Math.abs(x: float32): float32
lib/std/math.ci:89:[.046770, .046782): exec(4), time(0.048 ms): Math.abs(x: float64): float64
lib/std/math.ci:95:[.046788, .0467a3): exec(11), time(0.184 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.0467a8, .0467c3): exec(11), time(0.200 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:114:[.0467c8, .0467d9): exec(1), time(0.008 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:120:[.0467e0, .0467f1): exec(1), time(0.008 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:132:[.0467f8, .046809): exec(1), time(0.009 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:138:[.046810, .046821): exec(1), time(0.009 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:150:[.046828, .046846): exec(2), time(0.038 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:159:[.046848, .046866): exec(2), time(0.047 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:185:[.046868, .0468b0): exec(2), time(0.066 ms): Math.min(data: float64[]): float64
lib/std/math.ci:197:[.0468b0, .0468f8): exec(2), time(0.070 ms): Math.max(data: float64[]): float64
lib/std/math.ci:210:[.0468f8, .046920): exec(4), time(0.093 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:228:[.046920, .04694f): exec(3), time(0.097 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:236:[.046950, .046989): exec(1), time(0.038 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:249:[.046990, .0469c9): exec(1), time(0.011 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:263:[.0469d0, .046b1f): exec(2), time(0.063 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:320:[.046b20, .046c93): exec(1), time(0.046-0.010 ms): Math.tan(arg: float64): float64
lib/std/math.ci:377:[.046c98, .046d89): exec(1), time(0.060-0.031 ms): Math.sinh(x: float64): float64
lib/std/math.ci:416:[.046d90, .046ddb): exec(1), time(0.038-0.015 ms): Math.cosh(x: float64): float64
lib/std/math.ci:432:[.046de0, .046e86): exec(2), time(0.092-0.029 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:20:[.046e88, .046e8f): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:25:[.046e90, .046e97): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:66:[.046e98, .046f13): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:93:[.046f18, .046f37): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:107:[.046f38, .046f9c): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:3:[.046fa0, .046fc6): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:14:[.046fc8, .046ffa): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:24:[.047000, .047032): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:35:[.047038, .047081): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:44:[.047088, .047106): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:58:[.047108, .047147): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:71:[.047148, .04718f): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:70:[.047190, .0471b4): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:84:[.0471b8, .0471c6): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:113:[.0471c8, .04721c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:129:[.047230, .0474c1): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:192:[.0474c8, .0474df): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:196:[.0474e0, .047511): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:205:[.047528, .047541): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:8:[.047548, .04754f): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:21:[.047550, .04755d): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:13:[.047560, .047591): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:25:[.047598, .0475ad): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:33:[.0475b0, .047751): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:3:[.047760, .047761): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:6:[.047768, .047770): exec(2), time(0.021 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.047770, .047778): exec(2), time(0.018 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.047778, .0477ae): exec(753), time(16.330 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.0477b0, .0477b1): exec(1), time(0.011 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.0477b8, .0477d0): exec(64-64), time(1.106 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.0477d0, .0477dc): exec(1-1), time(0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.0477e0, .047824): exec(1-1), time(0.105-0.084 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.047828, .047835): exec(1-1), time(0.010 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.047838, .04783a): exec(1-1), time(0.010 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.047840, .047844): exec(5), time(0.051 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.047848, .047854): exec(21), time(0.283 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.047858, .047864): exec(21), time(0.240 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.047868, .047874): exec(14), time(0.175 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.0478a8, .0478cf): exec(3), time(0.425-0.368 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:25:[.0478d8, .0478ff): exec(4), time(0.476-0.389 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:30:[.047900, .047927): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.047928, .04794f): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:62:[.047950, .047992): exec(1), time(0.215-0.185 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:68:[.047998, .0479d7): exec(1), time(0.225-0.195 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.0479d7, .04a486): exec(1), time(28.673-22.738 ms): .main

---------- Profile statements: 898/1148, coverage: 78.22%
lib/stdlib.ci:41:[.046641, .046642) exec(8), time(0.041-0.041 ms): <assertEq+9>
lib/stdlib.ci:40:[.046638, .046642) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:44:[.046646, .046651) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:45:[.046651, .04665c) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:46:[.04665c, .04665f) exec(0), time(0.000 ms): <assertEq+36>
::[.04665f, .04666b) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:43:[.046642, .04666b) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:48:[.04666b, .046691) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.0466b0, .0466c1) exec(3), time(0.059-0.059 ms): <modf+24>
lib/std/math.ci:26:[.0466c1, .0466c8) exec(3), time(0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.0466c8, .0466cb) exec(3), time(0.029-0.029 ms): <modf+48>
lib/std/math.ci:24:[.0466a8, .0466cf) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.0466cf, .0466d3) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.0466d3, .0466d7) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.046698, .0466d7) exec(10-3), time(0.005-0.005 ms): <modf+0>
lib/std/math.ci:32:[.0466d7, .0466e3) exec(7), time(0.006-0.006 ms): <modf+63>
lib/std/math.ci:33:[.0466e3, .0466eb) exec(7), time(0.004-0.004 ms): <modf+75>
lib/std/math.ci:34:[.0466eb, .0466ee) exec(7), time(0.052-0.052 ms): <modf+83>
lib/std/math.ci:47:[.0466f0, .0466f1) exec(6), time(0.004-0.004 ms): <floor+0>
lib/std/math.ci:48:[.0466f1, .046705) exec(6), time(0.187-0.187 ms): <floor+1>
lib/std/math.ci:49:[.046705, .046708) exec(6), time(0.062-0.062 ms): <floor+21>
lib/std/math.ci:60:[.046710, .046714) exec(1), time(0.006-0.006 ms): <sign+8>
lib/std/math.ci:59:[.046708, .046714) exec(3-1), time(0.001-0.001 ms): <sign+0>
lib/std/math.ci:63:[.04671c, .046724) exec(1), time(0.006-0.006 ms): <sign+20>
lib/std/math.ci:62:[.046714, .046724) exec(2-1), time(0.001-0.001 ms): <sign+12>
lib/std/math.ci:65:[.046724, .04672c) exec(1), time(0.006-0.006 ms): <sign+28>
lib/std/math.ci:69:[.046738, .04673c) exec(1), time(0.006-0.006 ms): <sign+8>
lib/std/math.ci:68:[.046730, .04673c) exec(3-1), time(0.002-0.002 ms): <sign+0>
lib/std/math.ci:72:[.046744, .04674c) exec(1), time(0.006-0.006 ms): <sign+20>
lib/std/math.ci:71:[.04673c, .04674c) exec(2-1), time(0.000 ms): <sign+12>
lib/std/math.ci:74:[.04674c, .046754) exec(1), time(0.005-0.005 ms): <sign+28>
lib/std/math.ci:85:[.046760, .046766) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:84:[.046758, .046766) exec(3-1), time(0.000 ms): <abs+0>
lib/std/math.ci:87:[.046766, .04676a) exec(2), time(0.010-0.010 ms): <abs+14>
lib/std/math.ci:91:[.046778, .04677e) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:90:[.046770, .04677e) exec(4-1), time(0.015-0.015 ms): <abs+0>
lib/std/math.ci:93:[.04677e, .046782) exec(3), time(0.016-0.016 ms): <abs+14>
lib/std/math.ci:97:[.046797, .04679f) exec(4), time(0.032-0.032 ms): <absMod+15>
lib/std/math.ci:96:[.046788, .04679f) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:99:[.04679f, .0467a3) exec(7), time(0.067-0.067 ms): <absMod+23>
lib/std/math.ci:103:[.0467b7, .0467bf) exec(4), time(0.045-0.045 ms): <absMod+15>
lib/std/math.ci:102:[.0467a8, .0467bf) exec(11-4), time(0.023-0.023 ms): <absMod+0>
lib/std/math.ci:105:[.0467bf, .0467c3) exec(7), time(0.085-0.085 ms): <absMod+23>
lib/std/math.ci:116:[.0467d1, .0467d5) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:115:[.0467c8, .0467d5) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:118:[.0467d5, .0467d9) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:122:[.0467e9, .0467ed) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:121:[.0467e0, .0467ed) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:124:[.0467ed, .0467f1) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:134:[.046801, .046805) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:133:[.0467f8, .046805) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:136:[.046805, .046809) exec(1), time(0.005-0.005 ms): <max+13>
lib/std/math.ci:140:[.046819, .04681d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:139:[.046810, .04681d) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:142:[.04681d, .046821) exec(1), time(0.006-0.006 ms): <max+13>
lib/std/math.ci:152:[.046831, .046835) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:151:[.046828, .046835) exec(2), time(0.001-0.001 ms): <clamp+0>
lib/std/math.ci:155:[.04683e, .046842) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:154:[.046835, .046842) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:157:[.046842, .046846) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:161:[.046851, .046855) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.046848, .046855) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:164:[.04685e, .046862) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:163:[.046855, .046862) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:166:[.046862, .046866) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:187:[.046870, .046875) exec(1), time(0.006-0.006 ms): <min+8>
lib/std/math.ci:186:[.046868, .046875) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:189:[.046875, .046878) exec(1), time(0.001-0.001 ms): <min+13>
lib/std/math.ci:192:[.046891, .04689c) exec(2), time(0.001-0.001 ms): <min+41>
lib/std/math.ci:191:[.046881, .04689c) exec(8-2), time(0.006-0.006 ms): <min+25>
lib/std/math.ci:190:[.04689c, .0468a0) exec(8), time(0.003-0.003 ms): <min+52>
lib/std/math.ci:190:[.0468a0, .0468a9) exec(9), time(0.004-0.004 ms): <min+56>
lib/std/math.ci:190:[.046878, .0468ad) exec(1), time(0.001-0.001 ms): <min+16>
lib/std/math.ci:195:[.0468ad, .0468b0) exec(1), time(0.022-0.022 ms): <min+69>
lib/std/math.ci:199:[.0468b8, .0468bd) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:198:[.0468b0, .0468bd) exec(2-1), time(0.000 ms): <max+0>
lib/std/math.ci:201:[.0468bd, .0468c0) exec(1), time(0.000 ms): <max+13>
lib/std/math.ci:204:[.0468d9, .0468e4) exec(2), time(0.001-0.001 ms): <max+41>
lib/std/math.ci:203:[.0468c9, .0468e4) exec(8-2), time(0.004-0.004 ms): <max+25>
lib/std/math.ci:202:[.0468e4, .0468e8) exec(8), time(0.004-0.004 ms): <max+52>
lib/std/math.ci:202:[.0468e8, .0468f1) exec(9), time(0.006-0.006 ms): <max+56>
lib/std/math.ci:202:[.0468c0, .0468f5) exec(1), time(0.001-0.001 ms): <max+16>
lib/std/math.ci:207:[.0468f5, .0468f8) exec(1), time(0.006-0.006 ms): <max+69>
lib/std/math.ci:211:[.0468f8, .0468f9) exec(4), time(0.001-0.001 ms): <sum+0>
lib/std/math.ci:213:[.0468fe, .04690c) exec(13), time(0.011-0.011 ms): <sum+6>
lib/std/math.ci:212:[.04690c, .046910) exec(13), time(0.005-0.005 ms): <sum+20>
lib/std/math.ci:212:[.046910, .046919) exec(17), time(0.011-0.011 ms): <sum+24>
lib/std/math.ci:212:[.0468f9, .04691d) exec(4), time(0.004-0.004 ms): <sum+1>
lib/std/math.ci:215:[.04691d, .046920) exec(4), time(0.022-0.022 ms): <sum+37>
lib/std/math.ci:229:[.046920, .046921) exec(3), time(0.001-0.001 ms): <eval+0>
lib/std/math.ci:231:[.04692b, .04693c) exec(11), time(0.011-0.011 ms): <eval+11>
lib/std/math.ci:230:[.04693c, .046940) exec(11), time(0.005-0.005 ms): <eval+28>
lib/std/math.ci:230:[.046940, .046948) exec(14), time(0.007-0.007 ms): <eval+32>
lib/std/math.ci:230:[.046921, .04694c) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:233:[.04694c, .04694f) exec(3), time(0.032-0.032 ms): <eval+44>
lib/std/math.ci:239:[.046965, .04696d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:238:[.046959, .04696d) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:244:[.04697d, .046985) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:243:[.046971, .046985) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:237:[.046950, .046985) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:247:[.046985, .046989) exec(1), time(0.020-0.020 ms): <cmp+53>
lib/std/math.ci:252:[.0469a5, .0469ad) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:251:[.046999, .0469ad) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:257:[.0469bd, .0469c5) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:256:[.0469b1, .0469c5) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:250:[.046990, .0469c5) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:260:[.0469c5, .0469c9) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:277:[.0469d0, .0469d2) exec(2), time(0.000 ms): <sinCos+0>
lib/std/math.ci:279:[.0469da, .0469db) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:280:[.0469db, .0469e3) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:278:[.0469d2, .0469e3) exec(2), time(0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:283:[.0469e3, .0469e4) exec(2), time(0.002-0.002 ms): <sinCos+19>
lib/std/math.ci:284:[.0469e4, .0469fc) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:286:[.046a0c, .046a0d) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:287:[.046a0d, .046a1f) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:288:[.046a1f, .046a23) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:290:[.046a23, .046a24) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:291:[.046a24, .046a42) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:292:[.046a42, .046a54) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:295:[.046a5c, .046a5f) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:296:[.046a5f, .046a67) exec(2), time(0.001-0.001 ms): <sinCos+143>
lib/std/math.ci:297:[.046a67, .046a6e) exec(2), time(0.001-0.001 ms): <sinCos+151>
lib/std/math.ci:298:[.046a6e, .046a74) exec(2), time(0.001-0.001 ms): <sinCos+158>
lib/std/math.ci:285:[.0469fc, .046a78) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:301:[.046a80, .046a8e) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:300:[.046a78, .046a8e) exec(2-1), time(0.000 ms): <sinCos+168>
lib/std/math.ci:304:[.046a9a, .046a9b) exec(1), time(0.000 ms): <sinCos+202>
lib/std/math.ci:303:[.046a8e, .046a9b) exec(2-1), time(0.000 ms): <sinCos+190>
lib/std/math.ci:307:[.046a9b, .046aa0) exec(2), time(0.000 ms): <sinCos+203>
lib/std/math.ci:308:[.046aa0, .046ae0) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:309:[.046ae0, .046b13) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:310:[.046b13, .046b1f) exec(2), time(0.014-0.014 ms): <sinCos+323>
lib/std/math.ci:333:[.046b20, .046b21) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:334:[.046b21, .046b22) exec(1), time(0.000 ms): <tan+1>
lib/std/math.ci:337:[.046b2a, .046b2f) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:338:[.046b2f, .046b39) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:336:[.046b22, .046b39) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:340:[.046b39, .046b51) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:342:[.046b51, .046b52) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:343:[.046b52, .046b62) exec(1), time(0.015-0.015 ms): <tan+50>
lib/std/math.ci:344:[.046b62, .046b6b) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:348:[.046b7f, .046b8d) exec(1), time(0.000 ms): <tan+95>
lib/std/math.ci:349:[.046b8d, .046b97) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:352:[.046ba7, .046bb2) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:353:[.046bb2, .046bbc) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:356:[.046bcc, .046bda) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:357:[.046bda, .046be5) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:355:[.046bc0, .046be5) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:351:[.046b9b, .046be5) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:347:[.046b73, .046be5) exec(1), time(0.001-0.001 ms): <tan+83>
lib/std/math.ci:346:[.046b6b, .046be5) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:360:[.046be5, .046bea) exec(1), time(0.000 ms): <tan+197>
lib/std/math.ci:361:[.046bea, .046c2a) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:362:[.046c2a, .046c51) exec(1), time(0.002-0.002 ms): <tan+266>
lib/std/math.ci:366:[.046c62, .046c6b) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:365:[.046c5a, .046c6b) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:368:[.046c6b, .046c79) exec(1), time(0.001-0.001 ms): <tan+331>
lib/std/math.ci:364:[.046c51, .046c79) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:371:[.046c82, .046c8c) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:370:[.046c79, .046c8c) exec(1), time(0.000 ms): <tan+345>
lib/std/math.ci:373:[.046c8c, .046c93) exec(1), time(0.005-0.005 ms): <tan+364>
lib/std/math.ci:389:[.046c98, .046c99) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:391:[.046ca1, .046ca6) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:392:[.046ca6, .046cb0) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:390:[.046c99, .046cb0) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:396:[.046cc0, .046cd7) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:395:[.046cb0, .046cd7) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:399:[.046cd7, .046cd8) exec(1), time(0.001-0.001 ms): <sinh+63>
lib/std/math.ci:401:[.046ce8, .046d02) exec(1), time(0.045-0.045 ms): <sinh+80>
lib/std/math.ci:404:[.046d06, .046d0b) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:405:[.046d0b, .046d40) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:406:[.046d40, .046d6b) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:400:[.046cd8, .046d6f) exec(1), time(0.045-0.045 ms): <sinh+64>
lib/std/math.ci:410:[.046d78, .046d82) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:409:[.046d6f, .046d82) exec(1), time(0.001-0.001 ms): <sinh+215>
lib/std/math.ci:412:[.046d82, .046d89) exec(1), time(0.006-0.006 ms): <sinh+234>
lib/std/math.ci:418:[.046d98, .046d9d) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:417:[.046d90, .046d9d) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:421:[.046dad, .046dc0) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:420:[.046d9d, .046dc0) exec(1), time(0.000 ms): <cosh+13>
lib/std/math.ci:423:[.046dc0, .046ddb) exec(1), time(0.033-0.033 ms): <cosh+48>
lib/std/math.ci:435:[.046de8, .046dec) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:433:[.046de0, .046dec) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:438:[.046dec, .046ded) exec(2), time(0.000 ms): <asin+12>
lib/std/math.ci:440:[.046df5, .046dff) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:441:[.046dff, .046e04) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:439:[.046ded, .046e04) exec(2), time(0.001-0.001 ms): <asin+13>
lib/std/math.ci:446:[.046e14, .046e1d) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:444:[.046e04, .046e1d) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:449:[.046e1d, .046e30) exec(2), time(0.029-0.029 ms): <asin+61>
lib/std/math.ci:451:[.046e40, .046e5e) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:454:[.046e62, .046e6c) exec(2), time(0.029-0.029 ms): <asin+130>
lib/std/math.ci:450:[.046e30, .046e6c) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:458:[.046e75, .046e7f) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:457:[.046e6c, .046e7f) exec(2), time(0.000 ms): <asin+140>
lib/std/math.ci:460:[.046e7f, .046e86) exec(2), time(0.012-0.012 ms): <asin+159>
::[.046e8b, .046e8e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:21:[.046e88, .046e8f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:28:[.046e93, .046e96) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:26:[.046e90, .046e97) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:71:[.046eb7, .046ebc) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:72:[.046ebc, .046ec4) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:75:[.046ed1, .046ede) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:73:[.046ec4, .046ee3) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:70:[.046e98, .046ee7) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:78:[.046ee7, .046eec) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:79:[.046eec, .046ef4) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:82:[.046f01, .046f0e) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:80:[.046ef4, .046f13) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:94:[.046f18, .046f23) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:97:[.046f2a, .046f32) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:95:[.046f23, .046f37) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:108:[.046f38, .046f4f) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:109:[.046f4f, .046f5f) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:110:[.046f5f, .046f6e) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:111:[.046f6e, .046f81) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:114:[.046f8c, .046f97) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:112:[.046f81, .046f9c) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:5:[.046fac, .046fb0) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:4:[.046fa0, .046fb0) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:7:[.046fb0, .046fb1) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:8:[.046fb5, .046fb9) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:8:[.046fb9, .046fc3) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:8:[.046fb1, .046fc3) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:10:[.046fc3, .046fc6) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:17:[.046fdd, .046fe0) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:16:[.046fcd, .046fe0) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:15:[.046fe0, .046fe4) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:15:[.046fe4, .046fee) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:15:[.046fc8, .046ff2) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:20:[.046ff2, .046ffa) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:25:[.047000, .047005) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:28:[.04701a, .04701d) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:27:[.04700a, .04701d) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:26:[.04701d, .047021) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:26:[.047021, .04702b) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:26:[.047005, .04702f) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:31:[.04702f, .047032) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:38:[.047057, .047062) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:37:[.04703d, .047062) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:36:[.047062, .047066) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:36:[.047066, .047072) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:36:[.047038, .047076) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:41:[.047076, .047081) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:45:[.047088, .047095) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:46:[.047095, .0470a2) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:48:[.0470ab, .0470b6) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:47:[.0470a2, .0470b6) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:52:[.0470db, .0470e6) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:51:[.0470bb, .0470e6) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:50:[.0470e6, .0470ea) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:50:[.0470ea, .0470f3) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:50:[.0470b6, .0470f7) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:55:[.0470f7, .047106) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:59:[.047108, .047109) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:61:[.04710e, .047124) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:63:[.047130, .047134) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:62:[.047124, .047134) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:60:[.047134, .047138) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:60:[.047138, .047140) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:60:[.047109, .047144) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:66:[.047144, .047147) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:73:[.047157, .047162) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:72:[.047148, .047162) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:76:[.047171, .04717c) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:75:[.047162, .04717c) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:78:[.04717c, .04718f) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:81:[.047190, .0471b4) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:85:[.0471b8, .0471c6) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:116:[.0471d6, .0471da) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:115:[.0471cd, .0471da) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:118:[.0471da, .0471e6) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:119:[.0471e6, .0471ee) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:114:[.0471ee, .0471f2) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:114:[.0471f2, .0471fc) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:114:[.0471c8, .047200) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:123:[.047209, .047211) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:122:[.047200, .047211) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:125:[.047211, .047218) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:126:[.047218, .04721c) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:133:[.047230, .047231) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:134:[.047231, .047235) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:136:[.047235, .047238) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:137:[.047238, .04726e) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:138:[.04726e, .0472a3) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:142:[.0472a7, .0472c2) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:141:[.0472c2, .0472c9) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:141:[.0472c9, .0472d1) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:141:[.0472a3, .0472d1) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:145:[.0472d9, .0472ee) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:144:[.0472d1, .0472ee) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:148:[.0472ee, .0472f8) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:150:[.0472f8, .0472ff) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:152:[.04730a, .047314) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:151:[.0472ff, .047314) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:157:[.04731f, .047327) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:161:[.047345, .047379) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:162:[.047379, .047384) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:163:[.047384, .04738c) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:160:[.04738c, .047394) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:160:[.047394, .04739c) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:160:[.047341, .04739c) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:158:[.047327, .04739c) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:166:[.04739c, .0473d0) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:167:[.0473d0, .0473db) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:168:[.0473db, .0473e3) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:156:[.047314, .0473e3) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:173:[.0473e7, .04741b) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:174:[.04741b, .047426) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:175:[.047426, .04742e) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:172:[.04742e, .047436) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:172:[.047436, .04743e) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:172:[.0473e3, .04743e) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:180:[.047443, .047477) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:181:[.047477, .047488) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:182:[.047488, .047490) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:179:[.047490, .047494) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:179:[.047494, .04749d) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:179:[.04743e, .0474a1) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:186:[.0474aa, .0474b2) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:185:[.0474a1, .0474b2) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:188:[.0474b2, .0474b9) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:189:[.0474b9, .0474c1) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:193:[.0474c8, .0474df) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:197:[.0474e0, .0474e1) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:199:[.0474e9, .0474f0) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:200:[.0474f0, .0474f5) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:198:[.0474e1, .0474f5) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:202:[.0474f5, .047511) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:207:[.047528, .047541) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:11:[.04754b, .04754e) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:9:[.047548, .04754f) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:22:[.047553, .047556) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:22:[.047556, .047559) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:22:[.047559, .04755c) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:22:[.047550, .04755d) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:18:[.047563, .047566) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:18:[.047566, .047569) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:18:[.047569, .04756c) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:19:[.04756c, .04756f) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:19:[.04756f, .047572) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:19:[.047572, .047575) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:19:[.047575, .047578) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:20:[.047578, .04757b) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:20:[.04757b, .04757e) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:20:[.04757e, .047581) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:20:[.047581, .047584) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:21:[.047584, .047587) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:21:[.047587, .04758a) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:21:[.04758a, .04758d) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:21:[.04758d, .047590) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:17:[.047560, .047591) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:26:[.04759d, .0475a2) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:26:[.0475a2, .0475a7) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:26:[.0475a7, .0475ac) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:26:[.047598, .0475ad) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:35:[.0475b4, .0475b9) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:35:[.0475b9, .0475c2) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:35:[.0475c2, .0475cb) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:35:[.0475cb, .0475d4) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:36:[.0475d4, .0475dd) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:36:[.0475dd, .0475e6) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:36:[.0475e6, .0475ef) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:36:[.0475ef, .0475f8) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:37:[.0475f8, .047601) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:37:[.047601, .04760a) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:37:[.04760a, .047613) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:37:[.047613, .04761c) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:38:[.04761c, .047625) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:38:[.047625, .04762e) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:38:[.04762e, .047637) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:38:[.047637, .047640) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:34:[.0475b0, .047640) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:43:[.047680, .0476c4) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:44:[.0476c4, .047708) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:45:[.047708, .04774c) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:41:[.047640, .047751) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:7:[.047768, .047770) exec(2), time(0.014-0.014 ms): <funAdd+0>
test/lang/function.ci:33:[.047770, .047778) exec(2), time(0.014-0.014 ms): <funMul+0>
test/lang/function.ci:39:[.047784, .047788) exec(377), time(2.958-2.958 ms): <fib+12>
test/lang/function.ci:38:[.047778, .047788) exec(753-377), time(0.613-0.613 ms): <fib+0>
test/lang/function.ci:41:[.047788, .0477ae) exec(376-375), time(16.314-16.314 ms): <fib+16>
test/stdc/tryExec.ci:15:[.0477b8, .0477bc) exec(64-1), time(0.030-0.030 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.0477bc, .0477cb) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.0477d0, .0477d7) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.0477e4, .0477eb) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.0477eb, .0477f2) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.0477f2, .0477f9) exec(1), time(0.000 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.0477e0, .0477f9) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.0477f9, .04781f) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.047828, .04782d) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.04782d, .047830) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.047838, .04783a) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.047840, .047844) exec(5), time(0.030-0.030 ms): <lenSlice+0>
test/lang/array.ci:104:[.047848, .047854) exec(21), time(0.157-0.157 ms): <nthFixed+0>
test/lang/array.ci:105:[.047858, .047864) exec(21), time(0.156-0.156 ms): <nthArray+0>
test/lang/array.ci:106:[.047868, .047874) exec(14), time(0.102-0.102 ms): <nthSlice+0>
test/lang/method.ci:7:[.0478a8, .0478ce) exec(3), time(0.394-0.394 ms): <staticMethod+0>
test/lang/method.ci:26:[.0478d8, .0478fe) exec(4), time(0.422-0.422 ms): <virtualMethod+0>
test/lang/method.ci:31:[.047900, .047926) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.047928, .04794e) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:63:[.047950, .047973) exec(1), time(0.024-0.024 ms): <staticMethod+0>
test/lang/method.ci:65:[.047981, .047991) exec(1), time(0.178-0.178 ms): <staticMethod+49>
test/lang/method.ci:64:[.047973, .047991) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:69:[.047998, .0479bb) exec(1), time(0.037-0.037 ms): <virtualMethod+0>
test/lang/method.ci:71:[.0479c9, .0479d6) exec(1), time(0.175-0.175 ms): <virtualMethod+49>
test/lang/method.ci:70:[.0479bb, .0479d6) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:130:[.0479d7, .0479e5) exec(1), time(0.001-0.001 ms): <.main+0>
lib/std/string.ci:131:[.0479e5, .0479f3) exec(1), time(0.001-0.001 ms): <.main+14>
::[.0479fc, .047a03) exec(1), time(0.001-0.001 ms): <.main+37>
::[.047a03, .047a08) exec(1), time(0.001-0.001 ms): <.main+44>
::[.047a08, .047a0d) exec(1), time(0.001-0.001 ms): <.main+49>
lib/std/string.ci:206:[.0479f3, .047a0d) exec(1-1), time(0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.047a0d, .047a1a) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.047a1a, .047a1f) exec(1), time(0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.047a1f, .047a28) exec(1), time(0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.047a28, .047a31) exec(1), time(0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.047a3a, .047a43) exec(1), time(0.000 ms): <.main+99>
test/lang/member.ci:47:[.047a31, .047a43) exec(1-1), time(0.000 ms): <.main+90>
test/lang/member.ci:50:[.047a4c, .047a55) exec(1), time(0.001-0.001 ms): <.main+117>
test/lang/member.ci:50:[.047a43, .047a55) exec(1-1), time(0.000 ms): <.main+108>
test/lang/method.ci:11:[.047a55, .047a5e) exec(1), time(0.000 ms): <.main+126>
test/lang/emit.ci:3:[.047a5e, .047a5f) exec(1), time(0.000 ms): <.main+135>
test/lang/emit.ci:4:[.047a5f, .047a60) exec(1), time(0.001-0.001 ms): <.main+136>
test/lang/emit.ci:6:[.047a60, .047a65) exec(1), time(0.001-0.001 ms): <.main+137>
test/lang/emit.ci:7:[.047a65, .047a6a) exec(1), time(0.001-0.001 ms): <.main+142>
test/lang/emit.ci:9:[.047a6a, .047a6f) exec(1), time(0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.047a6f, .047a7a) exec(1), time(0.014-0.014 ms): <.main+152>
test/lang/emit.ci:17:[.047a7a, .047a7f) exec(1), time(0.000 ms): <.main+163>
test/lang/emit.ci:18:[.047a7f, .047a85) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.047a85, .047a8f) exec(1), time(0.001-0.001 ms): <.main+174>
test/lang/emit.ci:20:[.047a8f, .047a98) exec(1), time(0.000 ms): <.main+184>
test/lang/emit.ci:23:[.047a98, .047aa2) exec(1), time(0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.047aa2, .047aa7) exec(1), time(0.001-0.001 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.047aa7, .047aac) exec(1), time(0.001-0.001 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.047aac, .047ab1) exec(1), time(0.000 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.047ab1, .047ab6) exec(1), time(0.000 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.047ab6, .047ab7) exec(1), time(0.000 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.047ab7, .047ab8) exec(1), time(0.000 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.047ab8, .047ab9) exec(1), time(0.000 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.047ab9, .047abe) exec(1), time(0.000 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.047abe, .047ac0) exec(1), time(0.001-0.001 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.047ac0, .047aca) exec(1), time(0.001-0.001 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.047aca, .047ad3) exec(1), time(0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.047ad3, .047ad8) exec(1), time(0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.047ad8, .047ae9) exec(1), time(0.002-0.002 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.047ae9, .047b01) exec(1), time(0.002-0.002 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.047b01, .047b13) exec(1), time(0.002-0.002 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.047b13, .047b31) exec(1), time(0.003-0.003 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.047b31, .047b52) exec(1), time(0.004-0.004 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.047b52, .047b6d) exec(1), time(0.003-0.003 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.047b6d, .047b94) exec(1), time(0.004-0.004 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.047b94, .047bb5) exec(1), time(0.003-0.003 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.047bb5, .047bd0) exec(1), time(0.002-0.002 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.047bd0, .047bf7) exec(1), time(0.004-0.004 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.047bf7, .047c0c) exec(1), time(0.002-0.002 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.047c0c, .047c1d) exec(1), time(0.001-0.001 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.047c1d, .047c28) exec(1), time(0.002-0.002 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.047c28, .047c33) exec(1), time(0.003-0.003 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.047c33, .047c52) exec(1), time(0.004-0.004 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.047c52, .047c71) exec(1), time(0.004-0.004 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.047c71, .047caf) exec(1), time(0.002-0.002 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.047caf, .047ced) exec(1), time(0.005-0.005 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.047ced, .047d1f) exec(1), time(0.002-0.002 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.047d1f, .047d51) exec(1), time(0.005-0.005 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.047d51, .047d97) exec(1), time(0.003-0.003 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.047d97, .047ddd) exec(1), time(0.006-0.006 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.047ddd, .047e36) exec(1), time(0.009-0.009 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.047e36, .047e8f) exec(1), time(0.009-0.009 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.047e8f, .047edc) exec(1), time(0.009-0.009 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.047edc, .047f29) exec(1), time(0.010-0.010 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.047f29, .047f8a) exec(1), time(0.011-0.011 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.047f8a, .047feb) exec(1), time(0.011-0.011 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.047feb, .048044) exec(1), time(0.009-0.009 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.048044, .04809d) exec(1), time(0.022-0.022 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.04809d, .0480ea) exec(1), time(0.010-0.010 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.0480ea, .048137) exec(1), time(0.010-0.010 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.048137, .048198) exec(1), time(0.024-0.024 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.048198, .0481f9) exec(1), time(0.012-0.012 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.0481f9, .0481fe) exec(1), time(0.001-0.001 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.0481fe, .048203) exec(1), time(0.000 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.048203, .048208) exec(1), time(0.000 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.048208, .04820d) exec(1), time(0.000 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.04820d, .048212) exec(1), time(0.001-0.001 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.048212, .04821b) exec(1), time(0.000 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.04821b, .048231) exec(1), time(0.003-0.003 ms): <.main+2116>
test/lang/initByRef.ci:8:[.048231, .048236) exec(1), time(0.001-0.001 ms): <.main+2138>
test/lang/initByRef.ci:9:[.048236, .04823b) exec(1), time(0.000 ms): <.main+2143>
test/lang/initByRef.ci:10:[.04823b, .048245) exec(1), time(0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.048245, .048248) exec(1), time(0.000 ms): <.main+2158>
test/lang/initByRef.ci:13:[.048248, .04824a) exec(1), time(0.001-0.001 ms): <.main+2161>
test/lang/initByRef.ci:14:[.04824a, .04824c) exec(1), time(0.000 ms): <.main+2163>
test/lang/initByRef.ci:16:[.04824c, .048251) exec(1), time(0.000 ms): <.main+2165>
test/lang/initByRef.ci:17:[.048251, .048256) exec(1), time(0.000 ms): <.main+2170>
test/lang/initByRef.ci:18:[.048256, .048260) exec(1), time(0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.048260, .048265) exec(1), time(0.000 ms): <.main+2185>
test/lang/initByRef.ci:20:[.048265, .04826a) exec(1), time(0.001-0.001 ms): <.main+2190>
test/lang/initByRef.ci:21:[.04826a, .04826f) exec(1), time(0.000 ms): <.main+2195>
test/lang/initByRef.ci:23:[.04826f, .048274) exec(1), time(0.000 ms): <.main+2200>
test/lang/initByRef.ci:24:[.048274, .04827e) exec(1), time(0.014-0.014 ms): <.main+2205>
test/lang/initByRef.ci:25:[.04827e, .048283) exec(1), time(0.001-0.001 ms): <.main+2215>
test/lang/initByRef.ci:27:[.048283, .048287) exec(1), time(0.001-0.001 ms): <.main+2220>
test/lang/initByRef.ci:28:[.048287, .048289) exec(1), time(0.000 ms): <.main+2224>
test/lang/initByRef.ci:29:[.048289, .04828b) exec(1), time(0.000 ms): <.main+2226>
test/lang/initByRef.ci:30:[.04828b, .04828d) exec(1), time(0.000 ms): <.main+2228>
test/lang/initByRef.ci:31:[.04828d, .04828f) exec(1), time(0.001-0.001 ms): <.main+2230>
test/lang/initByRef.ci:32:[.04828f, .048291) exec(1), time(0.015-0.015 ms): <.main+2232>
test/lang/initByRef.ci:35:[.048291, .048296) exec(1), time(0.000 ms): <.main+2234>
test/lang/initByRef.ci:36:[.048296, .04829b) exec(1), time(0.000 ms): <.main+2239>
test/lang/initByRef.ci:37:[.04829b, .0482a0) exec(1), time(0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.0482a0, .0482a5) exec(1), time(0.001-0.001 ms): <.main+2249>
test/lang/initByRef.ci:39:[.0482a5, .0482aa) exec(1), time(0.001-0.001 ms): <.main+2254>
test/lang/initByRef.ci:40:[.0482aa, .0482af) exec(1), time(0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.0482af, .0482b4) exec(1), time(0.000 ms): <.main+2264>
test/lang/initByRef.ci:42:[.0482b4, .0482b9) exec(1), time(0.001-0.001 ms): <.main+2269>
test/lang/initByRef.ci:43:[.0482b9, .0482be) exec(1), time(0.001-0.001 ms): <.main+2274>
test/lang/initByRef.ci:44:[.0482be, .0482c3) exec(1), time(0.000 ms): <.main+2279>
test/lang/initByRef.ci:45:[.0482c3, .0482c8) exec(1), time(0.000 ms): <.main+2284>
test/lang/initByRef.ci:46:[.0482c8, .0482cd) exec(1), time(0.001-0.001 ms): <.main+2289>
test/lang/initByRef.ci:47:[.0482cd, .0482d2) exec(1), time(0.000 ms): <.main+2294>
test/lang/initByRef.ci:48:[.0482d2, .0482d7) exec(1), time(0.000 ms): <.main+2299>
test/lang/initByRef.ci:49:[.0482d7, .0482dc) exec(1), time(0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.0482dc, .0482e1) exec(1), time(0.001-0.001 ms): <.main+2309>
test/lang/initByRef.ci:51:[.0482e1, .0482e6) exec(1), time(0.001-0.001 ms): <.main+2314>
test/lang/initByRef.ci:52:[.0482e6, .0482eb) exec(1), time(0.000 ms): <.main+2319>
test/lang/initByRef.ci:55:[.0482eb, .0482f5) exec(1), time(0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.0482f5, .0482ff) exec(1), time(0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.0482ff, .048309) exec(1), time(0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.048309, .048313) exec(1), time(0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.048313, .04831d) exec(1), time(0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.04831d, .048327) exec(1), time(0.001-0.001 ms): <.main+2374>
test/lang/initByRef.ci:61:[.048327, .048331) exec(1), time(0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.048331, .04833b) exec(1), time(0.000 ms): <.main+2394>
test/lang/initByRef.ci:63:[.04833b, .048345) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/initByRef.ci:64:[.048345, .04834f) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.04834f, .048359) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.048359, .048363) exec(1), time(0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.048363, .04836d) exec(1), time(0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.04836d, .048377) exec(1), time(0.001-0.001 ms): <.main+2454>
test/lang/initByRef.ci:69:[.048377, .048381) exec(1), time(0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.048381, .04838b) exec(1), time(0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.04838b, .048395) exec(1), time(0.000 ms): <.main+2484>
test/lang/initByRef.ci:72:[.048395, .04839f) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.04839f, .0483a4) exec(1), time(0.001-0.001 ms): <.main+2504>
test/lang/initByRef.ci:76:[.0483a4, .0483a9) exec(1), time(0.000 ms): <.main+2509>
test/lang/initByRef.ci:77:[.0483a9, .0483ae) exec(1), time(0.000 ms): <.main+2514>
test/lang/initByRef.ci:78:[.0483ae, .0483b3) exec(1), time(0.000 ms): <.main+2519>
test/lang/initByRef.ci:79:[.0483b3, .0483b8) exec(1), time(0.001-0.001 ms): <.main+2524>
test/lang/initByRef.ci:80:[.0483b8, .0483bd) exec(1), time(0.000 ms): <.main+2529>
test/lang/initByRef.ci:81:[.0483bd, .0483c2) exec(1), time(0.000 ms): <.main+2534>
test/lang/initByRef.ci:82:[.0483c2, .0483c7) exec(1), time(0.001-0.001 ms): <.main+2539>
test/lang/initByRef.ci:83:[.0483c7, .0483cc) exec(1), time(0.001-0.001 ms): <.main+2544>
test/lang/initByRef.ci:84:[.0483cc, .0483d1) exec(1), time(0.000 ms): <.main+2549>
test/lang/initByRef.ci:85:[.0483d1, .0483d6) exec(1), time(0.000 ms): <.main+2554>
test/lang/initByRef.ci:86:[.0483d6, .0483db) exec(1), time(0.001-0.001 ms): <.main+2559>
test/lang/initByRef.ci:87:[.0483db, .0483e0) exec(1), time(0.000 ms): <.main+2564>
test/lang/initByRef.ci:88:[.0483e0, .0483e5) exec(1), time(0.000 ms): <.main+2569>
test/lang/initByRef.ci:89:[.0483e5, .0483ea) exec(1), time(0.001-0.001 ms): <.main+2574>
test/lang/initByRef.ci:90:[.0483ea, .0483ef) exec(1), time(0.001-0.001 ms): <.main+2579>
test/lang/initByRef.ci:91:[.0483ef, .0483f4) exec(1), time(0.000 ms): <.main+2584>
test/lang/initByRef.ci:92:[.0483f4, .0483f9) exec(1), time(0.000 ms): <.main+2589>
test/lang/initByRef.ci:95:[.0483f9, .0483fe) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:96:[.0483fe, .048408) exec(1), time(0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.048408, .04840d) exec(1), time(0.001-0.001 ms): <.main+2609>
test/lang/initByRef.ci:99:[.04840d, .048412) exec(1), time(0.000 ms): <.main+2614>
test/lang/initByRef.ci:105:[.048412, .048419) exec(1), time(0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.048419, .04841b) exec(1), time(0.000 ms): <.main+2626>
test/lang/function.ci:11:[.04841b, .048430) exec(1), time(0.021-0.021 ms): <.main+2628>
test/lang/function.ci:14:[.048430, .048435) exec(1), time(0.001-0.001 ms): <.main+2649>
test/lang/function.ci:17:[.048435, .048447) exec(1), time(0.017-0.017 ms): <.main+2654>
test/lang/function.ci:20:[.048447, .04844c) exec(1), time(0.001-0.001 ms): <.main+2672>
test/lang/function.ci:23:[.04844c, .04845e) exec(1), time(0.017-0.017 ms): <.main+2677>
test/lang/function.ci:26:[.04845e, .048460) exec(1), time(0.001-0.001 ms): <.main+2695>
test/lang/function.ci:29:[.048460, .048472) exec(1), time(0.018-0.018 ms): <.main+2697>
test/lang/function.ci:45:[.048472, .048482) exec(1), time(16.340-16.340 ms): <.main+2715>
test/lang/reflect.ci:3:[.048482, .048486) exec(1), time(0.000 ms): <.main+2731>
test/lang/reflect.ci:4:[.048486, .04848a) exec(1), time(0.001-0.001 ms): <.main+2735>
test/lang/reflect.ci:5:[.04848a, .04848e) exec(1), time(0.001-0.001 ms): <.main+2739>
test/lang/reflect.ci:6:[.04848e, .048492) exec(1), time(0.000 ms): <.main+2743>
test/lang/reflect.ci:7:[.048492, .048496) exec(1), time(0.000 ms): <.main+2747>
test/lang/reflect.ci:8:[.048496, .04849a) exec(1), time(0.001-0.001 ms): <.main+2751>
test/lang/reflect.ci:9:[.04849a, .04849e) exec(1), time(0.000 ms): <.main+2755>
test/lang/reflect.ci:10:[.04849e, .0484a2) exec(1), time(0.000 ms): <.main+2759>
test/lang/reflect.ci:11:[.0484a2, .0484a6) exec(1), time(0.001-0.001 ms): <.main+2763>
test/lang/reflect.ci:12:[.0484a6, .0484aa) exec(1), time(0.001-0.001 ms): <.main+2767>
test/lang/reflect.ci:13:[.0484aa, .0484ae) exec(1), time(0.000 ms): <.main+2771>
test/lang/reflect.ci:14:[.0484ae, .0484b2) exec(1), time(0.001-0.001 ms): <.main+2775>
test/lang/reflect.ci:15:[.0484b2, .0484b6) exec(1), time(0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:16:[.0484b6, .0484ba) exec(1), time(0.000 ms): <.main+2783>
test/lang/reflect.ci:17:[.0484ba, .0484be) exec(1), time(0.000 ms): <.main+2787>
test/lang/reflect.ci:18:[.0484be, .0484c2) exec(1), time(0.001-0.001 ms): <.main+2791>
test/lang/reflect.ci:19:[.0484c2, .0484c6) exec(1), time(0.000 ms): <.main+2795>
test/lang/reflect.ci:20:[.0484c6, .0484ca) exec(1), time(0.000 ms): <.main+2799>
test/lang/reflect.ci:30:[.0484ca, .0484cf) exec(1), time(0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:31:[.0484cf, .0484d5) exec(1), time(0.021-0.021 ms): <.main+2808>
test/lang/reflect.ci:32:[.0484d5, .0484dc) exec(1), time(0.002-0.002 ms): <.main+2814>
test/lang/reflect.ci:33:[.0484dc, .0484e3) exec(1), time(0.002-0.002 ms): <.main+2821>
test/lang/reflect.ci:34:[.0484e3, .0484e9) exec(1), time(0.016-0.016 ms): <.main+2828>
test/lang/reflect.ci:35:[.0484e9, .0484ef) exec(1), time(0.016-0.016 ms): <.main+2834>
test/lang/reflect.ci:37:[.0484ef, .0484f5) exec(1), time(0.015-0.015 ms): <.main+2840>
test/lang/reflect.ci:38:[.0484f5, .0484fb) exec(1), time(0.015-0.015 ms): <.main+2846>
test/lang/reflect.ci:39:[.0484fb, .048502) exec(1), time(0.002-0.002 ms): <.main+2852>
test/lang/reflect.ci:40:[.048502, .048509) exec(1), time(0.001-0.001 ms): <.main+2859>
test/lang/reflect.ci:41:[.048509, .04850f) exec(1), time(0.016-0.016 ms): <.main+2866>
test/lang/reflect.ci:42:[.04850f, .048515) exec(1), time(0.015-0.015 ms): <.main+2872>
test/lang/reflect.ci:44:[.048515, .04851b) exec(1), time(0.015-0.015 ms): <.main+2878>
test/lang/reflect.ci:45:[.04851b, .048522) exec(1), time(0.002-0.002 ms): <.main+2884>
test/lang/reflect.ci:46:[.048522, .048529) exec(1), time(0.001-0.001 ms): <.main+2891>
test/lang/reflect.ci:48:[.048529, .04852f) exec(1), time(0.015-0.015 ms): <.main+2898>
test/lang/reflect.ci:49:[.04852f, .048536) exec(1), time(0.001-0.001 ms): <.main+2904>
test/lang/reflect.ci:50:[.048536, .04853d) exec(1), time(0.002-0.002 ms): <.main+2911>
test/stdc/number.ci:3:[.04853d, .048546) exec(1), time(0.000 ms): <.main+2918>
test/stdc/number.ci:4:[.048546, .04854f) exec(1), time(0.001-0.001 ms): <.main+2927>
test/stdc/number.ci:6:[.04854f, .048552) exec(1), time(0.001-0.001 ms): <.main+2936>
test/stdc/number.ci:7:[.048552, .048555) exec(1), time(0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.048555, .04855c) exec(1), time(0.001-0.001 ms): <.main+2942>
test/stdc/number.ci:15:[.04855c, .048563) exec(1), time(0.001-0.001 ms): <.main+2949>
test/stdc/number.ci:16:[.048563, .04856a) exec(1), time(0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.04856a, .048586) exec(1), time(0.007-0.007 ms): <.main+2963>
test/stdc/number.ci:19:[.048586, .0485a0) exec(1), time(0.006-0.006 ms): <.main+2991>
test/stdc/number.ci:21:[.0485a0, .0485b0) exec(1), time(0.017-0.017 ms): <.main+3017>
test/stdc/number.ci:22:[.0485b0, .0485c0) exec(1), time(0.015-0.015 ms): <.main+3033>
test/stdc/number.ci:23:[.0485c0, .0485cc) exec(1), time(0.015-0.015 ms): <.main+3049>
test/stdc/number.ci:25:[.0485cc, .0485dc) exec(1), time(0.016-0.016 ms): <.main+3061>
test/stdc/number.ci:26:[.0485dc, .0485ec) exec(1), time(0.016-0.016 ms): <.main+3077>
test/stdc/number.ci:27:[.0485ec, .0485f8) exec(1), time(0.015-0.015 ms): <.main+3093>
test/stdc/number.ci:29:[.0485f8, .048608) exec(1), time(0.016-0.016 ms): <.main+3105>
test/stdc/number.ci:30:[.048608, .048618) exec(1), time(0.016-0.016 ms): <.main+3121>
test/stdc/number.ci:31:[.048618, .048624) exec(1), time(0.039-0.039 ms): <.main+3137>
test/stdc/number.ci:33:[.048624, .048634) exec(1), time(0.017-0.017 ms): <.main+3149>
test/stdc/number.ci:34:[.048634, .048644) exec(1), time(0.016-0.016 ms): <.main+3165>
test/stdc/number.ci:35:[.048644, .048650) exec(1), time(0.029-0.029 ms): <.main+3181>
test/stdc/number.ci:37:[.048650, .048660) exec(1), time(0.030-0.030 ms): <.main+3193>
test/stdc/number.ci:38:[.048660, .048670) exec(1), time(0.021-0.021 ms): <.main+3209>
test/stdc/number.ci:39:[.048670, .048680) exec(1), time(0.016-0.016 ms): <.main+3225>
test/stdc/number.ci:40:[.048680, .04868c) exec(1), time(0.022-0.022 ms): <.main+3241>
test/stdc/number.ci:41:[.04868c, .048699) exec(1), time(0.015-0.015 ms): <.main+3253>
test/stdc/number.ci:42:[.048699, .0486ab) exec(1), time(0.017-0.017 ms): <.main+3266>
test/stdc/number.ci:43:[.0486ab, .0486b4) exec(1), time(0.017-0.017 ms): <.main+3284>
test/stdc/number.ci:44:[.0486b4, .0486c3) exec(1), time(0.032-0.032 ms): <.main+3293>
test/stdc/number.ci:46:[.0486c3, .0486cf) exec(1), time(0.031-0.031 ms): <.main+3308>
test/stdc/number.ci:47:[.0486cf, .0486db) exec(1), time(0.016-0.016 ms): <.main+3320>
test/stdc/number.ci:48:[.0486db, .0486e7) exec(1), time(0.019-0.019 ms): <.main+3332>
test/stdc/number.ci:49:[.0486e7, .0486f3) exec(1), time(0.017-0.017 ms): <.main+3344>
test/stdc/number.ci:50:[.0486f3, .0486fc) exec(1), time(0.015-0.015 ms): <.main+3356>
test/stdc/number.ci:51:[.0486fc, .04870a) exec(1), time(0.016-0.016 ms): <.main+3365>
test/stdc/number.ci:52:[.04870a, .048713) exec(1), time(0.016-0.016 ms): <.main+3379>
test/stdc/number.ci:53:[.048713, .04871e) exec(1), time(0.019-0.019 ms): <.main+3388>
test/stdc/number.ci:55:[.04871e, .048724) exec(1), time(0.015-0.015 ms): <.main+3399>
test/stdc/number.ci:56:[.048724, .04872a) exec(1), time(0.016-0.016 ms): <.main+3405>
test/stdc/number.ci:57:[.04872a, .048730) exec(1), time(0.015-0.015 ms): <.main+3411>
test/stdc/number.ci:58:[.048730, .048736) exec(1), time(0.028-0.028 ms): <.main+3417>
test/stdc/number.ci:59:[.048736, .04873c) exec(1), time(0.014-0.014 ms): <.main+3423>
test/stdc/number.ci:60:[.04873c, .048742) exec(1), time(0.028-0.028 ms): <.main+3429>
test/stdc/number.ci:62:[.048742, .04874e) exec(1), time(0.017-0.017 ms): <.main+3435>
test/stdc/number.ci:63:[.04874e, .04875a) exec(1), time(0.016-0.016 ms): <.main+3447>
test/stdc/number.ci:65:[.04875a, .048768) exec(1), time(0.017-0.017 ms): <.main+3459>
test/stdc/number.ci:66:[.048768, .048776) exec(1), time(0.018-0.018 ms): <.main+3473>
test/stdc/memory.ci:7:[.048776, .048784) exec(1), time(0.016-0.016 ms): <.main+3487>
test/stdc/memory.ci:8:[.048784, .048792) exec(1), time(0.016-0.016 ms): <.main+3501>
test/stdc/memory.ci:9:[.048792, .0487a0) exec(1), time(0.016-0.016 ms): <.main+3515>
test/stdc/memory.ci:10:[.0487a0, .0487ae) exec(1), time(0.015-0.015 ms): <.main+3529>
test/stdc/memory.ci:13:[.0487ae, .0487be) exec(1), time(0.018-0.018 ms): <.main+3543>
test/stdc/memory.ci:14:[.0487be, .0487cf) exec(1), time(0.017-0.017 ms): <.main+3559>
test/stdc/memory.ci:17:[.0487cf, .0487da) exec(1), time(0.016-0.016 ms): <.main+3576>
test/stdc/memory.ci:18:[.0487da, .0487e5) exec(1), time(0.017-0.017 ms): <.main+3587>
test/stdc/memory.ci:19:[.0487e5, .0487f0) exec(1), time(0.016-0.016 ms): <.main+3598>
test/stdc/memory.ci:20:[.0487f0, .0487fb) exec(1), time(0.016-0.016 ms): <.main+3609>
test/stdc/memory.ci:23:[.0487fb, .048804) exec(1), time(0.001-0.001 ms): <.main+3620>
test/stdc/memory.ci:24:[.048804, .04880d) exec(1), time(0.000 ms): <.main+3629>
test/stdc/memory.ci:26:[.04880d, .04882f) exec(1), time(0.033-0.033 ms): <.main+3638>
test/stdc/memory.ci:27:[.04882f, .048851) exec(1), time(0.031-0.031 ms): <.main+3672>
test/stdc/memory.ci:29:[.048851, .048865) exec(1), time(0.017-0.017 ms): <.main+3706>
test/stdc/memory.ci:30:[.048865, .048876) exec(1), time(0.017-0.017 ms): <.main+3726>
test/stdc/memory.ci:32:[.048876, .048898) exec(1), time(0.030-0.030 ms): <.main+3743>
test/stdc/memory.ci:33:[.048898, .0488ba) exec(1), time(0.030-0.030 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.0488ba, .0488c8) exec(1), time(0.050-0.050 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.0488c8, .0488d6) exec(1), time(0.019-0.019 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.0488d6, .0488e4) exec(1), time(1.127-1.127 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.0488e4, .0488f2) exec(1), time(0.032-0.032 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.0488f2, .048900) exec(1), time(0.033-0.033 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.048900, .04890e) exec(1), time(0.032-0.032 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.04890e, .04891c) exec(1), time(0.126-0.126 ms): <.main+3895>
test/lang/array.ci:49:[.04891c, .048920) exec(1), time(0.000 ms): <.main+3909>
test/lang/array.ci:50:[.048920, .048924) exec(1), time(0.001-0.001 ms): <.main+3913>
test/lang/array.ci:51:[.048924, .048928) exec(1), time(0.000 ms): <.main+3917>
test/lang/array.ci:55:[.04892d, .048941) exec(7), time(0.032-0.032 ms): <.main+3926>
test/lang/array.ci:54:[.048941, .048945) exec(7), time(0.003-0.003 ms): <.main+3946>
test/lang/array.ci:54:[.048945, .048951) exec(8), time(0.018-0.018 ms): <.main+3950>
test/lang/array.ci:54:[.048928, .048955) exec(1), time(0.004-0.004 ms): <.main+3921>
test/lang/array.ci:59:[.048955, .04895a) exec(1), time(0.000 ms): <.main+3966>
test/lang/array.ci:60:[.04895a, .048960) exec(1), time(0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.048960, .048964) exec(1), time(0.001-0.001 ms): <.main+3977>
test/lang/array.ci:64:[.048964, .04896d) exec(1), time(0.001-0.001 ms): <.main+3981>
test/lang/array.ci:67:[.04896d, .04896f) exec(1), time(0.000 ms): <.main+3990>
test/lang/array.ci:68:[.04896f, .048971) exec(1), time(0.001-0.001 ms): <.main+3992>
test/lang/array.ci:71:[.048971, .048973) exec(1), time(0.000 ms): <.main+3994>
test/lang/array.ci:81:[.048973, .048977) exec(1), time(0.000 ms): <.main+3996>
test/lang/array.ci:82:[.048977, .04898d) exec(1), time(0.019-0.019 ms): <.main+4000>
test/lang/array.ci:83:[.04898d, .0489af) exec(1), time(0.076-0.076 ms): <.main+4022>
test/lang/array.ci:84:[.0489af, .0489d1) exec(1), time(0.075-0.075 ms): <.main+4056>
test/lang/array.ci:86:[.0489d1, .0489d6) exec(1), time(0.001-0.001 ms): <.main+4090>
test/lang/array.ci:87:[.0489d6, .0489f6) exec(1), time(0.035-0.035 ms): <.main+4095>
test/lang/array.ci:88:[.0489f6, .048a16) exec(1), time(0.035-0.035 ms): <.main+4127>
test/lang/array.ci:90:[.048a16, .048a20) exec(1), time(0.002-0.002 ms): <.main+4159>
test/lang/array.ci:91:[.048a20, .048a40) exec(1), time(0.047-0.047 ms): <.main+4169>
test/lang/array.ci:92:[.048a40, .048a60) exec(1), time(0.033-0.033 ms): <.main+4201>
test/lang/array.ci:98:[.048a60, .048a93) exec(1), time(0.003-0.003 ms): <.main+4233>
test/lang/array.ci:99:[.048a93, .048ac6) exec(1), time(0.003-0.003 ms): <.main+4284>
test/lang/array.ci:101:[.048ac6, .048b01) exec(1), time(0.003-0.003 ms): <.main+4335>
test/lang/array.ci:108:[.048b01, .048b1a) exec(1), time(0.019-0.019 ms): <.main+4394>
test/lang/array.ci:109:[.048b1a, .048b30) exec(1), time(0.018-0.018 ms): <.main+4419>
test/lang/array.ci:110:[.048b30, .048b46) exec(1), time(0.018-0.018 ms): <.main+4441>
test/lang/array.ci:112:[.048b46, .048b66) exec(1), time(0.037-0.037 ms): <.main+4463>
test/lang/array.ci:113:[.048b66, .048b83) exec(1), time(0.036-0.036 ms): <.main+4495>
test/lang/array.ci:114:[.048b83, .048bab) exec(1), time(0.037-0.037 ms): <.main+4524>
test/lang/array.ci:115:[.048bab, .048bcc) exec(1), time(0.036-0.036 ms): <.main+4564>
test/lang/array.ci:116:[.048bcc, .048bed) exec(1), time(0.038-0.038 ms): <.main+4597>
test/lang/array.ci:119:[.048bf2, .048bfb) exec(7), time(0.018-0.018 ms): <.main+4635>
test/lang/array.ci:120:[.048bfb, .048c38) exec(7), time(0.045-0.045 ms): <.main+4644>
test/lang/array.ci:121:[.048c38, .048c73) exec(7), time(0.033-0.033 ms): <.main+4705>
test/lang/array.ci:122:[.048c73, .048cae) exec(7), time(0.034-0.034 ms): <.main+4764>
test/lang/array.ci:124:[.048cae, .048cf1) exec(7), time(0.224-0.224 ms): <.main+4823>
test/lang/array.ci:125:[.048cf1, .048d32) exec(7), time(0.189-0.189 ms): <.main+4890>
test/lang/array.ci:126:[.048d32, .048d73) exec(7), time(0.164-0.164 ms): <.main+4955>
test/lang/array.ci:128:[.048d73, .048db6) exec(7), time(0.166-0.166 ms): <.main+5020>
test/lang/array.ci:129:[.048db6, .048df7) exec(7), time(0.164-0.164 ms): <.main+5087>
test/lang/array.ci:130:[.048df7, .048e38) exec(7), time(0.176-0.176 ms): <.main+5152>
test/lang/array.ci:132:[.048e38, .048e80) exec(7), time(0.167-0.167 ms): <.main+5217>
test/lang/array.ci:134:[.048e80, .048ec1) exec(7), time(0.184-0.184 ms): <.main+5289>
test/lang/array.ci:136:[.048ec1, .048efc) exec(7), time(0.035-0.035 ms): <.main+5354>
test/lang/array.ci:118:[.048f00, .048f04) exec(7), time(0.004-0.004 ms): <.main+5417>
test/lang/array.ci:118:[.048f04, .048f10) exec(8), time(0.017-0.017 ms): <.main+5421>
test/lang/array.ci:118:[.048bed, .048f14) exec(1), time(0.004-0.004 ms): <.main+4630>
test/lang/member.ci:54:[.048f18, .048f1f) exec(1), time(0.001-0.001 ms): <.main+5441>
test/lang/member.ci:55:[.048f1f, .048f26) exec(1), time(0.001-0.001 ms): <.main+5448>
test/lang/member.ci:56:[.048f26, .048f2d) exec(1), time(0.001-0.001 ms): <.main+5455>
test/lang/member.ci:57:[.048f2d, .048f34) exec(1), time(0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.048f34, .048f3b) exec(1), time(0.001-0.001 ms): <.main+5469>
test/lang/member.ci:61:[.048f3b, .048f42) exec(1), time(0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.048f42, .048f49) exec(1), time(0.001-0.001 ms): <.main+5483>
test/lang/member.ci:66:[.048f49, .048f50) exec(1), time(0.001-0.001 ms): <.main+5490>
test/lang/member.ci:53:[.048f14, .048f50) exec(1-1), time(0.000 ms): <.main+5437>
test/lang/method.ci:46:[.048f54, .048f5b) exec(1), time(0.001-0.001 ms): <.main+5501>
::[.048f5b, .048f61) exec(1), time(0.002-0.002 ms): <.main+5508>
::[.048f61, .048f68) exec(1), time(0.001-0.001 ms): <.main+5514>
test/lang/method.ci:44:[.048f50, .048f68) exec(1-1), time(0.000 ms): <.main+5497>
test/lang/method.ci:58:[.048f68, .048f7b) exec(1), time(0.132-0.132 ms): <.main+5521>
test/lang/method.ci:59:[.048f7b, .048f8b) exec(1), time(0.105-0.105 ms): <.main+5540>
test/lang/method.ci:75:[.048f8b, .048f9c) exec(1), time(0.225-0.225 ms): <.main+5556>
test/lang/method.ci:76:[.048f9c, .048fad) exec(1), time(0.234-0.234 ms): <.main+5573>
test/lang/method.ci:79:[.048fad, .048fc0) exec(1), time(0.143-0.143 ms): <.main+5590>
test/lang/method.ci:80:[.048fc0, .048fd3) exec(1), time(0.106-0.106 ms): <.main+5609>
test/lang/method.ci:81:[.048fd3, .048fe3) exec(1), time(0.134-0.134 ms): <.main+5628>
test/lang/recUnion.ci:26:[.048fe7, .048fed) exec(1), time(0.002-0.002 ms): <.main+5648>
test/lang/recUnion.ci:26:[.048fed, .048ff3) exec(1), time(0.001-0.001 ms): <.main+5654>
test/lang/recUnion.ci:26:[.048ff3, .048ff9) exec(1), time(0.017-0.017 ms): <.main+5660>
test/lang/recUnion.ci:26:[.048fe3, .048ff9) exec(1-1), time(0.000 ms): <.main+5644>
test/lang/recUnion.ci:27:[.048ffd, .049003) exec(1), time(0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:27:[.049003, .04900d) exec(1), time(0.002-0.002 ms): <.main+5676>
test/lang/recUnion.ci:27:[.04900d, .049013) exec(1), time(0.001-0.001 ms): <.main+5686>
test/lang/recUnion.ci:27:[.048ff9, .049013) exec(1-1), time(0.000 ms): <.main+5666>
test/lang/recUnion.ci:28:[.049017, .049021) exec(1), time(0.001-0.001 ms): <.main+5696>
test/lang/recUnion.ci:28:[.049021, .04902b) exec(1), time(0.002-0.002 ms): <.main+5706>
test/lang/recUnion.ci:28:[.04902b, .049035) exec(1), time(0.002-0.002 ms): <.main+5716>
test/lang/recUnion.ci:28:[.049013, .049035) exec(1-1), time(0.000 ms): <.main+5692>
test/lang/recUnion.ci:30:[.049039, .049040) exec(1), time(0.001-0.001 ms): <.main+5730>
test/lang/recUnion.ci:30:[.049035, .049040) exec(1-1), time(0.000 ms): <.main+5726>
test/lang/recUnion.ci:31:[.049044, .04904a) exec(1), time(0.002-0.002 ms): <.main+5741>
test/lang/recUnion.ci:31:[.04904a, .049050) exec(1), time(0.002-0.002 ms): <.main+5747>
test/lang/recUnion.ci:31:[.049050, .04905a) exec(1), time(0.001-0.001 ms): <.main+5753>
test/lang/recUnion.ci:31:[.049040, .04905a) exec(1-1), time(0.000 ms): <.main+5737>
test/lang/useOperator.ci:5:[.04905a, .04905f) exec(1), time(0.001-0.001 ms): <.main+5763>
test/lang/useOperator.ci:7:[.04905f, .049064) exec(1), time(0.000 ms): <.main+5768>
test/lang/useOperator.ci:8:[.049064, .049069) exec(1), time(0.001-0.001 ms): <.main+5773>
test/lang/useOperator.ci:17:[.049069, .049074) exec(1), time(0.003-0.003 ms): <.main+5778>
test/lang/useOperator.ci:18:[.049074, .04907f) exec(1), time(0.003-0.003 ms): <.main+5789>
test/lang/useOperator.ci:19:[.04907f, .04908a) exec(1), time(0.003-0.003 ms): <.main+5800>
test/lang/useOperator.ci:22:[.04908a, .049090) exec(1), time(0.002-0.002 ms): <.main+5811>
test/lang/useOperator.ci:23:[.049090, .04909b) exec(1), time(0.003-0.003 ms): <.main+5817>
test/lang/useOperator.ci:24:[.04909b, .0490a7) exec(1), time(0.004-0.004 ms): <.main+5828>
test/lang/useOperator.ci:25:[.0490a7, .0490b2) exec(1), time(0.003-0.003 ms): <.main+5840>
test/lang/useOperator.ci:26:[.0490b2, .0490be) exec(1), time(0.003-0.003 ms): <.main+5851>
test/lang/useOperator.ci:27:[.0490be, .0490c9) exec(1), time(0.003-0.003 ms): <.main+5863>
test/lang/useOperator.ci:28:[.0490c9, .0490d5) exec(1), time(0.003-0.003 ms): <.main+5874>
test/lang/useOperator.ci:30:[.0490d5, .0490da) exec(1), time(0.000 ms): <.main+5886>
test/lang/useOperator.ci:31:[.0490da, .0490df) exec(1), time(0.000 ms): <.main+5891>
test/lang/useOperator.ci:32:[.0490df, .0490e4) exec(1), time(0.002-0.002 ms): <.main+5896>
test/lang/useOperator.ci:33:[.0490e4, .0490ea) exec(1), time(0.001-0.001 ms): <.main+5901>
test/lang/useOperator.ci:34:[.0490ea, .0490f0) exec(1), time(0.002-0.002 ms): <.main+5907>
test/lang/useOperator.ci:35:[.0490f0, .0490fb) exec(1), time(0.003-0.003 ms): <.main+5913>
test/lang/useOperator.ci:36:[.0490fb, .049106) exec(1), time(0.003-0.003 ms): <.main+5924>
test/lang/useOperator.ci:37:[.049106, .049111) exec(1), time(0.003-0.003 ms): <.main+5935>
test/lang/useOperator.ci:38:[.049111, .04911c) exec(1), time(0.003-0.003 ms): <.main+5946>
test/lang/useOperator.ci:39:[.04911c, .049127) exec(1), time(0.003-0.003 ms): <.main+5957>
test/lang/useOperator.ci:40:[.049127, .049132) exec(1), time(0.003-0.003 ms): <.main+5968>
test/lang/useOperator.ci:41:[.049132, .04913d) exec(1), time(0.003-0.003 ms): <.main+5979>
test/lang/useOperator.ci:42:[.04913d, .049148) exec(1), time(0.003-0.003 ms): <.main+5990>
test/lang/useOperator.ci:43:[.049148, .049150) exec(1), time(0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:44:[.049150, .049158) exec(1), time(0.002-0.002 ms): <.main+6009>
test/lang/useOperator.ci:45:[.049158, .04915f) exec(1), time(0.003-0.003 ms): <.main+6017>
test/lang/useOperator.ci:46:[.04915f, .04916a) exec(1), time(0.003-0.003 ms): <.main+6024>
test/lang/useOperator.ci:47:[.04916a, .049176) exec(1), time(0.004-0.004 ms): <.main+6035>
test/lang/useOperator.ci:48:[.049176, .049181) exec(1), time(0.003-0.003 ms): <.main+6047>
test/lang/useOperator.ci:49:[.049181, .04918d) exec(1), time(0.004-0.004 ms): <.main+6058>
test/lang/useOperator.ci:50:[.04918d, .049198) exec(1), time(0.003-0.003 ms): <.main+6070>
test/lang/useOperator.ci:51:[.049198, .0491a4) exec(1), time(0.004-0.004 ms): <.main+6081>
test/lang/useOperator.ci:53:[.0491a4, .0491a9) exec(1), time(0.001-0.001 ms): <.main+6093>
test/lang/useOperator.ci:54:[.0491a9, .0491ae) exec(1), time(0.000 ms): <.main+6098>
test/lang/useOperator.ci:55:[.0491ae, .0491b3) exec(1), time(0.001-0.001 ms): <.main+6103>
test/lang/useOperator.ci:56:[.0491b3, .0491b9) exec(1), time(0.002-0.002 ms): <.main+6108>
test/lang/useOperator.ci:57:[.0491b9, .0491bf) exec(1), time(0.002-0.002 ms): <.main+6114>
test/lang/useOperator.ci:58:[.0491bf, .0491ca) exec(1), time(0.003-0.003 ms): <.main+6120>
test/lang/useOperator.ci:59:[.0491ca, .0491d5) exec(1), time(0.003-0.003 ms): <.main+6131>
test/lang/useOperator.ci:60:[.0491d5, .0491e0) exec(1), time(0.004-0.004 ms): <.main+6142>
test/lang/useOperator.ci:61:[.0491e0, .0491eb) exec(1), time(0.003-0.003 ms): <.main+6153>
test/lang/useOperator.ci:62:[.0491eb, .0491f6) exec(1), time(0.003-0.003 ms): <.main+6164>
test/lang/useOperator.ci:63:[.0491f6, .049201) exec(1), time(0.003-0.003 ms): <.main+6175>
test/lang/useOperator.ci:64:[.049201, .04920c) exec(1), time(0.003-0.003 ms): <.main+6186>
test/lang/useOperator.ci:65:[.04920c, .049217) exec(1), time(0.003-0.003 ms): <.main+6197>
test/lang/useOperator.ci:66:[.049217, .04921f) exec(1), time(0.002-0.002 ms): <.main+6208>
test/lang/useOperator.ci:67:[.04921f, .049227) exec(1), time(0.002-0.002 ms): <.main+6216>
test/lang/useOperator.ci:68:[.049227, .04922e) exec(1), time(0.003-0.003 ms): <.main+6224>
test/lang/useOperator.ci:69:[.04922e, .049239) exec(1), time(0.003-0.003 ms): <.main+6231>
test/lang/useOperator.ci:70:[.049239, .049245) exec(1), time(0.004-0.004 ms): <.main+6242>
test/lang/useOperator.ci:71:[.049245, .049250) exec(1), time(0.003-0.003 ms): <.main+6254>
test/lang/useOperator.ci:72:[.049250, .04925c) exec(1), time(0.004-0.004 ms): <.main+6265>
test/lang/useOperator.ci:73:[.04925c, .049267) exec(1), time(0.003-0.003 ms): <.main+6277>
test/lang/useOperator.ci:74:[.049267, .049273) exec(1), time(0.004-0.004 ms): <.main+6288>
test/lang/useOperator.ci:76:[.049273, .049278) exec(1), time(0.001-0.001 ms): <.main+6300>
test/lang/useOperator.ci:77:[.049278, .04927d) exec(1), time(0.000 ms): <.main+6305>
test/lang/useOperator.ci:78:[.04927d, .049282) exec(1), time(0.001-0.001 ms): <.main+6310>
test/lang/useOperator.ci:79:[.049282, .049288) exec(1), time(0.002-0.002 ms): <.main+6315>
test/lang/useOperator.ci:80:[.049288, .04928e) exec(1), time(0.002-0.002 ms): <.main+6321>
test/lang/useOperator.ci:81:[.04928e, .049299) exec(1), time(0.003-0.003 ms): <.main+6327>
test/lang/useOperator.ci:82:[.049299, .0492a4) exec(1), time(0.003-0.003 ms): <.main+6338>
test/lang/useOperator.ci:83:[.0492a4, .0492af) exec(1), time(0.003-0.003 ms): <.main+6349>
test/lang/useOperator.ci:84:[.0492af, .0492ba) exec(1), time(0.003-0.003 ms): <.main+6360>
test/lang/useOperator.ci:85:[.0492ba, .0492c5) exec(1), time(0.004-0.004 ms): <.main+6371>
test/lang/useOperator.ci:86:[.0492c5, .0492d0) exec(1), time(0.003-0.003 ms): <.main+6382>
test/lang/useOperator.ci:87:[.0492d0, .0492db) exec(1), time(0.003-0.003 ms): <.main+6393>
test/lang/useOperator.ci:88:[.0492db, .0492e6) exec(1), time(0.004-0.004 ms): <.main+6404>
test/lang/useOperator.ci:89:[.0492e6, .0492ee) exec(1), time(0.002-0.002 ms): <.main+6415>
test/lang/useOperator.ci:90:[.0492ee, .0492f6) exec(1), time(0.003-0.003 ms): <.main+6423>
test/lang/useOperator.ci:91:[.0492f6, .0492fd) exec(1), time(0.003-0.003 ms): <.main+6431>
test/lang/useOperator.ci:92:[.0492fd, .049308) exec(1), time(0.003-0.003 ms): <.main+6438>
test/lang/useOperator.ci:93:[.049308, .049314) exec(1), time(0.004-0.004 ms): <.main+6449>
test/lang/useOperator.ci:94:[.049314, .04931f) exec(1), time(0.004-0.004 ms): <.main+6461>
test/lang/useOperator.ci:95:[.04931f, .04932b) exec(1), time(0.004-0.004 ms): <.main+6472>
test/lang/useOperator.ci:96:[.04932b, .049336) exec(1), time(0.003-0.003 ms): <.main+6484>
test/lang/useOperator.ci:97:[.049336, .049342) exec(1), time(0.004-0.004 ms): <.main+6495>
test/lang/useOperator.ci:99:[.049342, .049347) exec(1), time(0.001-0.001 ms): <.main+6507>
test/lang/useOperator.ci:100:[.049347, .04934c) exec(1), time(0.000 ms): <.main+6512>
test/lang/useOperator.ci:101:[.04934c, .049351) exec(1), time(0.002-0.002 ms): <.main+6517>
test/lang/useOperator.ci:102:[.049351, .049357) exec(1), time(0.002-0.002 ms): <.main+6522>
test/lang/useOperator.ci:103:[.049357, .04935d) exec(1), time(0.002-0.002 ms): <.main+6528>
test/lang/useOperator.ci:104:[.04935d, .049368) exec(1), time(0.003-0.003 ms): <.main+6534>
test/lang/useOperator.ci:105:[.049368, .049373) exec(1), time(0.003-0.003 ms): <.main+6545>
test/lang/useOperator.ci:106:[.049373, .04937e) exec(1), time(0.003-0.003 ms): <.main+6556>
test/lang/useOperator.ci:107:[.04937e, .049389) exec(1), time(0.003-0.003 ms): <.main+6567>
test/lang/useOperator.ci:108:[.049389, .049394) exec(1), time(0.004-0.004 ms): <.main+6578>
test/lang/useOperator.ci:109:[.049394, .04939f) exec(1), time(0.003-0.003 ms): <.main+6589>
test/lang/useOperator.ci:110:[.04939f, .0493aa) exec(1), time(0.004-0.004 ms): <.main+6600>
test/lang/useOperator.ci:111:[.0493aa, .0493b5) exec(1), time(0.003-0.003 ms): <.main+6611>
test/lang/useOperator.ci:112:[.0493b5, .0493bd) exec(1), time(0.003-0.003 ms): <.main+6622>
test/lang/useOperator.ci:113:[.0493bd, .0493c5) exec(1), time(0.003-0.003 ms): <.main+6630>
test/lang/useOperator.ci:114:[.0493c5, .0493cc) exec(1), time(0.002-0.002 ms): <.main+6638>
test/lang/useOperator.ci:115:[.0493cc, .0493d7) exec(1), time(0.003-0.003 ms): <.main+6645>
test/lang/useOperator.ci:116:[.0493d7, .0493e3) exec(1), time(0.004-0.004 ms): <.main+6656>
test/lang/useOperator.ci:117:[.0493e3, .0493ee) exec(1), time(0.004-0.004 ms): <.main+6668>
test/lang/useOperator.ci:118:[.0493ee, .0493fa) exec(1), time(0.004-0.004 ms): <.main+6679>
test/lang/useOperator.ci:119:[.0493fa, .049405) exec(1), time(0.003-0.003 ms): <.main+6691>
test/lang/useOperator.ci:120:[.049405, .049411) exec(1), time(0.004-0.004 ms): <.main+6702>
test/lang/useOperator.ci:122:[.049411, .049416) exec(1), time(0.000 ms): <.main+6714>
test/lang/useOperator.ci:123:[.049416, .04941b) exec(1), time(0.001-0.001 ms): <.main+6719>
test/lang/useOperator.ci:124:[.04941b, .049420) exec(1), time(0.001-0.001 ms): <.main+6724>
test/lang/useOperator.ci:125:[.049420, .049426) exec(1), time(0.002-0.002 ms): <.main+6729>
test/lang/useOperator.ci:126:[.049426, .04942c) exec(1), time(0.002-0.002 ms): <.main+6735>
test/lang/useOperator.ci:127:[.04942c, .049437) exec(1), time(0.004-0.004 ms): <.main+6741>
test/lang/useOperator.ci:128:[.049437, .049442) exec(1), time(0.003-0.003 ms): <.main+6752>
test/lang/useOperator.ci:129:[.049442, .04944d) exec(1), time(0.004-0.004 ms): <.main+6763>
test/lang/useOperator.ci:130:[.04944d, .049458) exec(1), time(0.003-0.003 ms): <.main+6774>
test/lang/useOperator.ci:131:[.049458, .049463) exec(1), time(0.003-0.003 ms): <.main+6785>
test/lang/useOperator.ci:132:[.049463, .04946e) exec(1), time(0.004-0.004 ms): <.main+6796>
test/lang/useOperator.ci:133:[.04946e, .049479) exec(1), time(0.003-0.003 ms): <.main+6807>
test/lang/useOperator.ci:134:[.049479, .049484) exec(1), time(0.004-0.004 ms): <.main+6818>
test/lang/useOperator.ci:135:[.049484, .04948c) exec(1), time(0.003-0.003 ms): <.main+6829>
test/lang/useOperator.ci:136:[.04948c, .049494) exec(1), time(0.003-0.003 ms): <.main+6837>
test/lang/useOperator.ci:137:[.049494, .04949b) exec(1), time(0.003-0.003 ms): <.main+6845>
test/lang/useOperator.ci:138:[.04949b, .0494a6) exec(1), time(0.003-0.003 ms): <.main+6852>
test/lang/useOperator.ci:139:[.0494a6, .0494b2) exec(1), time(0.005-0.005 ms): <.main+6863>
test/lang/useOperator.ci:140:[.0494b2, .0494bd) exec(1), time(0.003-0.003 ms): <.main+6875>
test/lang/useOperator.ci:141:[.0494bd, .0494c9) exec(1), time(0.005-0.005 ms): <.main+6886>
test/lang/useOperator.ci:142:[.0494c9, .0494d4) exec(1), time(0.003-0.003 ms): <.main+6898>
test/lang/useOperator.ci:143:[.0494d4, .0494e0) exec(1), time(0.005-0.005 ms): <.main+6909>
test/lang/useOperator.ci:145:[.0494e0, .0494e5) exec(1), time(0.000 ms): <.main+6921>
test/lang/useOperator.ci:146:[.0494e5, .0494ea) exec(1), time(0.001-0.001 ms): <.main+6926>
test/lang/useOperator.ci:147:[.0494ea, .0494ec) exec(1), time(0.000 ms): <.main+6931>
test/lang/useOperator.ci:148:[.0494ec, .0494ef) exec(1), time(0.001-0.001 ms): <.main+6933>
test/lang/useOperator.ci:149:[.0494ef, .0494f2) exec(1), time(0.001-0.001 ms): <.main+6936>
test/lang/useOperator.ci:150:[.0494f2, .0494f7) exec(1), time(0.002-0.002 ms): <.main+6939>
test/lang/useOperator.ci:151:[.0494f7, .0494fc) exec(1), time(0.002-0.002 ms): <.main+6944>
test/lang/useOperator.ci:152:[.0494fc, .049501) exec(1), time(0.002-0.002 ms): <.main+6949>
test/lang/useOperator.ci:153:[.049501, .049506) exec(1), time(0.002-0.002 ms): <.main+6954>
test/lang/useOperator.ci:154:[.049506, .04950b) exec(1), time(0.002-0.002 ms): <.main+6959>
test/lang/useOperator.ci:155:[.04950b, .049510) exec(1), time(0.002-0.002 ms): <.main+6964>
test/lang/useOperator.ci:156:[.049510, .049515) exec(1), time(0.002-0.002 ms): <.main+6969>
test/lang/useOperator.ci:157:[.049515, .04951a) exec(1), time(0.002-0.002 ms): <.main+6974>
test/lang/useOperator.ci:158:[.04951a, .04951f) exec(1), time(0.002-0.002 ms): <.main+6979>
test/lang/useOperator.ci:159:[.04951f, .049524) exec(1), time(0.002-0.002 ms): <.main+6984>
test/lang/useOperator.ci:160:[.049524, .049528) exec(1), time(0.002-0.002 ms): <.main+6989>
test/lang/useOperator.ci:161:[.049528, .04952d) exec(1), time(0.002-0.002 ms): <.main+6993>
test/lang/useOperator.ci:162:[.04952d, .049533) exec(1), time(0.003-0.003 ms): <.main+6998>
test/lang/useOperator.ci:163:[.049533, .049538) exec(1), time(0.002-0.002 ms): <.main+7004>
test/lang/useOperator.ci:164:[.049538, .04953e) exec(1), time(0.003-0.003 ms): <.main+7009>
test/lang/useOperator.ci:165:[.04953e, .049543) exec(1), time(0.002-0.002 ms): <.main+7015>
test/lang/useOperator.ci:166:[.049543, .049549) exec(1), time(0.003-0.003 ms): <.main+7020>
test/lang/useOperator.ci:168:[.049549, .04954e) exec(1), time(0.001-0.001 ms): <.main+7026>
test/lang/useOperator.ci:169:[.04954e, .049553) exec(1), time(0.000 ms): <.main+7031>
test/lang/useOperator.ci:170:[.049553, .049555) exec(1), time(0.001-0.001 ms): <.main+7036>
test/lang/useOperator.ci:171:[.049555, .049558) exec(1), time(0.001-0.001 ms): <.main+7038>
test/lang/useOperator.ci:172:[.049558, .04955b) exec(1), time(0.001-0.001 ms): <.main+7041>
test/lang/useOperator.ci:173:[.04955b, .049560) exec(1), time(0.002-0.002 ms): <.main+7044>
test/lang/useOperator.ci:174:[.049560, .049565) exec(1), time(0.002-0.002 ms): <.main+7049>
test/lang/useOperator.ci:175:[.049565, .04956a) exec(1), time(0.002-0.002 ms): <.main+7054>
test/lang/useOperator.ci:176:[.04956a, .04956f) exec(1), time(0.002-0.002 ms): <.main+7059>
test/lang/useOperator.ci:177:[.04956f, .049574) exec(1), time(0.002-0.002 ms): <.main+7064>
test/lang/useOperator.ci:178:[.049574, .049579) exec(1), time(0.002-0.002 ms): <.main+7069>
test/lang/useOperator.ci:179:[.049579, .04957e) exec(1), time(0.002-0.002 ms): <.main+7074>
test/lang/useOperator.ci:180:[.04957e, .049583) exec(1), time(0.002-0.002 ms): <.main+7079>
test/lang/useOperator.ci:181:[.049583, .049588) exec(1), time(0.002-0.002 ms): <.main+7084>
test/lang/useOperator.ci:182:[.049588, .04958d) exec(1), time(0.002-0.002 ms): <.main+7089>
test/lang/useOperator.ci:183:[.04958d, .049591) exec(1), time(0.002-0.002 ms): <.main+7094>
test/lang/useOperator.ci:184:[.049591, .049596) exec(1), time(0.002-0.002 ms): <.main+7098>
test/lang/useOperator.ci:185:[.049596, .04959c) exec(1), time(0.003-0.003 ms): <.main+7103>
test/lang/useOperator.ci:186:[.04959c, .0495a1) exec(1), time(0.002-0.002 ms): <.main+7109>
test/lang/useOperator.ci:187:[.0495a1, .0495a7) exec(1), time(0.003-0.003 ms): <.main+7114>
test/lang/useOperator.ci:188:[.0495a7, .0495ac) exec(1), time(0.002-0.002 ms): <.main+7120>
test/lang/useOperator.ci:189:[.0495ac, .0495b2) exec(1), time(0.003-0.003 ms): <.main+7125>
test/lang/useOperator.ci:191:[.0495b2, .0495bb) exec(1), time(0.001-0.001 ms): <.main+7131>
test/lang/useOperator.ci:192:[.0495bb, .0495c4) exec(1), time(0.000 ms): <.main+7140>
test/lang/useOperator.ci:193:[.0495c4, .0495c6) exec(1), time(0.001-0.001 ms): <.main+7149>
test/lang/useOperator.ci:194:[.0495c6, .0495c9) exec(1), time(0.001-0.001 ms): <.main+7151>
test/lang/useOperator.ci:195:[.0495c9, .0495cc) exec(1), time(0.002-0.002 ms): <.main+7154>
test/lang/useOperator.ci:196:[.0495cc, .0495d1) exec(1), time(0.002-0.002 ms): <.main+7157>
test/lang/useOperator.ci:197:[.0495d1, .0495d6) exec(1), time(0.002-0.002 ms): <.main+7162>
test/lang/useOperator.ci:198:[.0495d6, .0495db) exec(1), time(0.002-0.002 ms): <.main+7167>
test/lang/useOperator.ci:199:[.0495db, .0495e0) exec(1), time(0.002-0.002 ms): <.main+7172>
test/lang/useOperator.ci:200:[.0495e0, .0495e5) exec(1), time(0.002-0.002 ms): <.main+7177>
test/lang/useOperator.ci:201:[.0495e5, .0495ea) exec(1), time(0.002-0.002 ms): <.main+7182>
test/lang/useOperator.ci:202:[.0495ea, .0495ef) exec(1), time(0.002-0.002 ms): <.main+7187>
test/lang/useOperator.ci:203:[.0495ef, .0495f4) exec(1), time(0.002-0.002 ms): <.main+7192>
test/lang/useOperator.ci:204:[.0495f4, .0495f9) exec(1), time(0.002-0.002 ms): <.main+7197>
test/lang/useOperator.ci:205:[.0495f9, .0495fe) exec(1), time(0.002-0.002 ms): <.main+7202>
test/lang/useOperator.ci:206:[.0495fe, .049602) exec(1), time(0.002-0.002 ms): <.main+7207>
test/lang/useOperator.ci:207:[.049602, .049607) exec(1), time(0.002-0.002 ms): <.main+7211>
test/lang/useOperator.ci:208:[.049607, .04960d) exec(1), time(0.002-0.002 ms): <.main+7216>
test/lang/useOperator.ci:209:[.04960d, .049612) exec(1), time(0.002-0.002 ms): <.main+7222>
test/lang/useOperator.ci:210:[.049612, .049618) exec(1), time(0.003-0.003 ms): <.main+7227>
test/lang/useOperator.ci:211:[.049618, .04961d) exec(1), time(0.002-0.002 ms): <.main+7233>
test/lang/useOperator.ci:212:[.04961d, .049623) exec(1), time(0.003-0.003 ms): <.main+7238>
test/lang/useOperator.ci:214:[.049623, .04962c) exec(1), time(0.001-0.001 ms): <.main+7244>
test/lang/useOperator.ci:215:[.04962c, .049635) exec(1), time(0.000 ms): <.main+7253>
test/lang/useOperator.ci:216:[.049635, .049637) exec(1), time(0.001-0.001 ms): <.main+7262>
test/lang/useOperator.ci:217:[.049637, .04963a) exec(1), time(0.001-0.001 ms): <.main+7264>
test/lang/useOperator.ci:218:[.04963a, .04963d) exec(1), time(0.002-0.002 ms): <.main+7267>
test/lang/useOperator.ci:219:[.04963d, .049642) exec(1), time(0.002-0.002 ms): <.main+7270>
test/lang/useOperator.ci:220:[.049642, .049647) exec(1), time(0.002-0.002 ms): <.main+7275>
test/lang/useOperator.ci:221:[.049647, .04964c) exec(1), time(0.002-0.002 ms): <.main+7280>
test/lang/useOperator.ci:222:[.04964c, .049651) exec(1), time(0.002-0.002 ms): <.main+7285>
test/lang/useOperator.ci:223:[.049651, .049656) exec(1), time(0.002-0.002 ms): <.main+7290>
test/lang/useOperator.ci:224:[.049656, .04965b) exec(1), time(0.002-0.002 ms): <.main+7295>
test/lang/useOperator.ci:225:[.04965b, .049660) exec(1), time(0.002-0.002 ms): <.main+7300>
test/lang/useOperator.ci:226:[.049660, .049665) exec(1), time(0.002-0.002 ms): <.main+7305>
test/lang/useOperator.ci:227:[.049665, .04966a) exec(1), time(0.002-0.002 ms): <.main+7310>
test/lang/useOperator.ci:228:[.04966a, .04966f) exec(1), time(0.002-0.002 ms): <.main+7315>
test/lang/useOperator.ci:229:[.04966f, .049673) exec(1), time(0.002-0.002 ms): <.main+7320>
test/lang/useOperator.ci:230:[.049673, .049678) exec(1), time(0.002-0.002 ms): <.main+7324>
test/lang/useOperator.ci:231:[.049678, .04967e) exec(1), time(0.003-0.003 ms): <.main+7329>
test/lang/useOperator.ci:232:[.04967e, .049683) exec(1), time(0.002-0.002 ms): <.main+7335>
test/lang/useOperator.ci:233:[.049683, .049689) exec(1), time(0.003-0.003 ms): <.main+7340>
test/lang/useOperator.ci:234:[.049689, .04968e) exec(1), time(0.002-0.002 ms): <.main+7346>
test/lang/useOperator.ci:235:[.04968e, .049694) exec(1), time(0.002-0.002 ms): <.main+7351>
test/lang/useOperator.ci:237:[.049694, .049699) exec(1), time(0.000 ms): <.main+7357>
test/lang/useOperator.ci:238:[.049699, .04969e) exec(1), time(0.001-0.001 ms): <.main+7362>
test/lang/useOperator.ci:239:[.04969e, .0496a0) exec(1), time(0.000 ms): <.main+7367>
test/lang/useOperator.ci:240:[.0496a0, .0496a3) exec(1), time(0.002-0.002 ms): <.main+7369>
test/lang/useOperator.ci:242:[.0496a3, .0496a8) exec(1), time(0.002-0.002 ms): <.main+7372>
test/lang/useOperator.ci:243:[.0496a8, .0496ad) exec(1), time(0.002-0.002 ms): <.main+7377>
test/lang/useOperator.ci:244:[.0496ad, .0496b2) exec(1), time(0.002-0.002 ms): <.main+7382>
test/lang/useOperator.ci:245:[.0496b2, .0496b7) exec(1), time(0.002-0.002 ms): <.main+7387>
test/lang/useOperator.ci:246:[.0496b7, .0496bc) exec(1), time(0.002-0.002 ms): <.main+7392>
test/lang/useOperator.ci:252:[.0496bc, .0496c0) exec(1), time(0.002-0.002 ms): <.main+7397>
test/lang/useOperator.ci:253:[.0496c0, .0496c5) exec(1), time(0.002-0.002 ms): <.main+7401>
test/lang/useOperator.ci:254:[.0496c5, .0496cb) exec(1), time(0.003-0.003 ms): <.main+7406>
test/lang/useOperator.ci:255:[.0496cb, .0496d0) exec(1), time(0.002-0.002 ms): <.main+7412>
test/lang/useOperator.ci:256:[.0496d0, .0496d6) exec(1), time(0.002-0.002 ms): <.main+7417>
test/lang/useOperator.ci:257:[.0496d6, .0496db) exec(1), time(0.002-0.002 ms): <.main+7423>
test/lang/useOperator.ci:258:[.0496db, .0496e1) exec(1), time(0.003-0.003 ms): <.main+7428>
test/lang/useOperator.ci:260:[.0496e1, .0496ea) exec(1), time(0.001-0.001 ms): <.main+7434>
test/lang/useOperator.ci:261:[.0496ea, .0496f3) exec(1), time(0.000 ms): <.main+7443>
test/lang/useOperator.ci:262:[.0496f3, .0496f5) exec(1), time(0.001-0.001 ms): <.main+7452>
test/lang/useOperator.ci:263:[.0496f5, .0496f8) exec(1), time(0.001-0.001 ms): <.main+7454>
test/lang/useOperator.ci:265:[.0496f8, .0496fd) exec(1), time(0.002-0.002 ms): <.main+7457>
test/lang/useOperator.ci:266:[.0496fd, .049702) exec(1), time(0.002-0.002 ms): <.main+7462>
test/lang/useOperator.ci:267:[.049702, .049707) exec(1), time(0.002-0.002 ms): <.main+7467>
test/lang/useOperator.ci:268:[.049707, .04970c) exec(1), time(0.002-0.002 ms): <.main+7472>
test/lang/useOperator.ci:269:[.04970c, .049711) exec(1), time(0.002-0.002 ms): <.main+7477>
test/lang/useOperator.ci:275:[.049711, .049715) exec(1), time(0.002-0.002 ms): <.main+7482>
test/lang/useOperator.ci:276:[.049715, .04971a) exec(1), time(0.002-0.002 ms): <.main+7486>
test/lang/useOperator.ci:277:[.04971a, .049720) exec(1), time(0.003-0.003 ms): <.main+7491>
test/lang/useOperator.ci:278:[.049720, .049725) exec(1), time(0.002-0.002 ms): <.main+7497>
test/lang/useOperator.ci:279:[.049725, .04972b) exec(1), time(0.003-0.003 ms): <.main+7502>
test/lang/useOperator.ci:280:[.04972b, .049730) exec(1), time(0.002-0.002 ms): <.main+7508>
test/lang/useOperator.ci:281:[.049730, .049736) exec(1), time(0.003-0.003 ms): <.main+7513>
test/lang/useOperator.ci:283:[.049736, .04973b) exec(1), time(0.001-0.001 ms): <.main+7519>
test/lang/useOperator.ci:284:[.04973b, .04973f) exec(1), time(0.000 ms): <.main+7524>
test/lang/useOperator.ci:299:[.04973f, .049744) exec(1), time(0.002-0.002 ms): <.main+7528>
test/lang/useOperator.ci:300:[.049744, .04974a) exec(1), time(0.003-0.003 ms): <.main+7533>
test/lang/statementIf.ci:4:[.04974a, .049771) exec(1), time(0.036-0.036 ms): <.main+7539>
test/lang/statementIf.ci:12:[.049771, .049798) exec(1), time(0.050-0.050 ms): <.main+7578>
test/lang/statementIf.ci:22:[.049798, .0497bf) exec(1), time(0.066-0.066 ms): <.main+7617>
test/lang/statementIf.ci:26:[.0497bf, .0497c0) exec(1), time(0.000 ms): <.main+7656>
test/lang/statementIf.ci:29:[.0497c8, .0497ee) exec(1), time(0.087-0.087 ms): <.main+7665>
test/lang/statementIf.ci:28:[.0497c0, .0497ee) exec(1-1), time(0.000 ms): <.main+7657>
test/lang/statementIf.ci:33:[.0497f6, .04981c) exec(0), time(0.000 ms): <.main+7711>
test/lang/statementIf.ci:32:[.0497ee, .04981c) exec(1), time(0.003-0.003 ms): <.main+7703>
test/lang/statementIf.ci:37:[.049824, .04984a) exec(1), time(0.065-0.065 ms): <.main+7757>
test/lang/statementIf.ci:40:[.04984e, .049874) exec(0), time(0.000 ms): <.main+7799>
test/lang/statementIf.ci:36:[.04981c, .049874) exec(1), time(0.067-0.067 ms): <.main+7749>
test/lang/statementIf.ci:44:[.04987c, .0498a2) exec(0), time(0.000 ms): <.main+7845>
test/lang/statementIf.ci:47:[.0498a6, .0498cc) exec(1), time(0.087-0.087 ms): <.main+7887>
test/lang/statementIf.ci:43:[.049874, .0498cc) exec(1-1), time(0.000 ms): <.main+7837>
test/lang/statementIf.ci:51:[.0498d4, .0498fa) exec(1), time(0.066-0.066 ms): <.main+7933>
test/lang/statementIf.ci:54:[.04990a, .049930) exec(0), time(0.000 ms): <.main+7987>
test/lang/statementIf.ci:57:[.049940, .049966) exec(0), time(0.000 ms): <.main+8041>
test/lang/statementIf.ci:60:[.049976, .04999c) exec(0), time(0.000 ms): <.main+8095>
test/lang/statementIf.ci:63:[.0499ac, .0499d2) exec(0), time(0.000 ms): <.main+8149>
test/lang/statementIf.ci:66:[.0499e2, .049a08) exec(0), time(0.000 ms): <.main+8203>
test/lang/statementIf.ci:69:[.049a0c, .049a32) exec(0), time(0.000 ms): <.main+8245>
test/lang/statementIf.ci:65:[.0499d6, .049a32) exec(0), time(0.000 ms): <.main+8191>
test/lang/statementIf.ci:62:[.0499a0, .049a32) exec(0), time(0.000 ms): <.main+8137>
test/lang/statementIf.ci:59:[.04996a, .049a32) exec(0), time(0.000 ms): <.main+8083>
test/lang/statementIf.ci:56:[.049934, .049a32) exec(0), time(0.000 ms): <.main+8029>
test/lang/statementIf.ci:53:[.0498fe, .049a32) exec(0), time(0.000 ms): <.main+7975>
test/lang/statementIf.ci:50:[.0498cc, .049a32) exec(1), time(0.067-0.067 ms): <.main+7925>
test/lang/statementFor.ci:4:[.049a36, .049a59) exec(1), time(0.044-0.044 ms): <.main+8287>
test/lang/statementFor.ci:5:[.049a59, .049a5d) exec(1), time(0.001-0.001 ms): <.main+8322>
::[.049a5d, .049a61) exec(1), time(0.000 ms): <.main+8326>
test/lang/statementFor.ci:3:[.049a32, .049a61) exec(1-1), time(0.000 ms): <.main+8283>
test/lang/statementFor.ci:9:[.049a66, .049a88) exec(2), time(0.113-0.113 ms): <.main+8335>
test/lang/statementFor.ci:8:[.049a88, .049a8c) exec(2), time(0.000 ms): <.main+8369>
test/lang/statementFor.ci:8:[.049a8c, .049a98) exec(3), time(0.010-0.010 ms): <.main+8373>
test/lang/statementFor.ci:8:[.049a61, .049a9c) exec(1), time(0.004-0.004 ms): <.main+8330>
test/lang/statementFor.ci:12:[.049a9c, .049a9d) exec(1), time(0.000 ms): <.main+8389>
test/lang/statementFor.ci:14:[.049aa4, .049ac6) exec(2), time(0.124-0.124 ms): <.main+8397>
test/lang/statementFor.ci:13:[.049ac6, .049aca) exec(2), time(0.000 ms): <.main+8431>
test/lang/statementFor.ci:13:[.049aca, .049ad6) exec(3), time(0.010-0.010 ms): <.main+8435>
test/lang/statementFor.ci:13:[.049a9d, .049ad6) exec(1-1), time(0.000 ms): <.main+8390>
test/lang/statementFor.ci:19:[.049ae7, .049aeb) exec(2), time(0.001-0.001 ms): <.main+8464>
test/lang/statementFor.ci:18:[.049adb, .049aeb) exec(7-2), time(0.015-0.015 ms): <.main+8452>
test/lang/statementFor.ci:21:[.049aeb, .049b0d) exec(5), time(0.187-0.187 ms): <.main+8468>
test/lang/statementFor.ci:17:[.049b0d, .049b11) exec(7), time(0.002-0.002 ms): <.main+8502>
test/lang/statementFor.ci:17:[.049b11, .049b1d) exec(8), time(0.045-0.045 ms): <.main+8506>
test/lang/statementFor.ci:17:[.049ad6, .049b21) exec(1), time(0.005-0.005 ms): <.main+8447>
test/lang/statementFor.ci:26:[.049b32, .049b36) exec(1), time(0.000 ms): <.main+8539>
test/lang/statementFor.ci:25:[.049b26, .049b36) exec(4-1), time(0.011-0.011 ms): <.main+8527>
test/lang/statementFor.ci:28:[.049b36, .049b58) exec(3), time(0.115-0.115 ms): <.main+8543>
test/lang/statementFor.ci:24:[.049b58, .049b5c) exec(3), time(0.000 ms): <.main+8577>
test/lang/statementFor.ci:24:[.049b5c, .049b68) exec(4), time(0.012-0.012 ms): <.main+8581>
test/lang/statementFor.ci:24:[.049b21, .049b6c) exec(1), time(0.001-0.001 ms): <.main+8522>
test/stdc/test.math.ci:3:[.049b6c, .049b80) exec(1), time(0.066-0.066 ms): <.main+8597>
test/stdc/test.math.ci:4:[.049b80, .049b94) exec(1), time(0.052-0.052 ms): <.main+8617>
test/stdc/test.math.ci:5:[.049b94, .049ba8) exec(1), time(0.047-0.047 ms): <.main+8637>
test/stdc/test.math.ci:6:[.049ba8, .049bbc) exec(1), time(0.048-0.048 ms): <.main+8657>
test/stdc/test.math.ci:7:[.049bbc, .049bd0) exec(1), time(0.062-0.062 ms): <.main+8677>
test/stdc/test.math.ci:8:[.049bd0, .049be4) exec(1), time(0.074-0.074 ms): <.main+8697>
test/stdc/test.math.ci:10:[.049be4, .049bf9) exec(1), time(0.033-0.033 ms): <.main+8717>
test/stdc/test.math.ci:11:[.049bf9, .049c06) exec(1), time(0.018-0.018 ms): <.main+8738>
test/stdc/test.math.ci:12:[.049c06, .049c1b) exec(1), time(0.051-0.051 ms): <.main+8751>
test/stdc/test.math.ci:13:[.049c1b, .049c2c) exec(1), time(0.020-0.020 ms): <.main+8772>
test/stdc/test.math.ci:14:[.049c2c, .049c39) exec(1), time(0.019-0.019 ms): <.main+8789>
test/stdc/test.math.ci:15:[.049c39, .049c4a) exec(1), time(0.034-0.034 ms): <.main+8802>
test/stdc/test.math.ci:17:[.049c4a, .049c5e) exec(1), time(0.019-0.019 ms): <.main+8819>
test/stdc/test.math.ci:18:[.049c5e, .049c69) exec(1), time(0.018-0.018 ms): <.main+8839>
test/stdc/test.math.ci:19:[.049c69, .049c7d) exec(1), time(0.018-0.018 ms): <.main+8850>
test/stdc/test.math.ci:20:[.049c7d, .049c8e) exec(1), time(0.019-0.019 ms): <.main+8870>
test/stdc/test.math.ci:21:[.049c8e, .049c9b) exec(1), time(0.033-0.033 ms): <.main+8887>
test/stdc/test.math.ci:22:[.049c9b, .049cac) exec(1), time(0.032-0.032 ms): <.main+8900>
test/stdc/test.math.ci:24:[.049cac, .049cc2) exec(1), time(0.020-0.020 ms): <.main+8917>
test/stdc/test.math.ci:25:[.049cc2, .049cd8) exec(1), time(0.021-0.021 ms): <.main+8939>
test/stdc/test.math.ci:26:[.049cd8, .049cf5) exec(1), time(0.035-0.035 ms): <.main+8961>
test/stdc/test.math.ci:27:[.049cf5, .049d12) exec(1), time(0.019-0.019 ms): <.main+8990>
test/stdc/test.math.ci:29:[.049d12, .049d29) exec(1), time(0.041-0.041 ms): <.main+9019>
test/stdc/test.math.ci:30:[.049d29, .049d47) exec(1), time(0.037-0.037 ms): <.main+9042>
test/stdc/test.math.ci:32:[.049d47, .049d5c) exec(1), time(0.008-0.008 ms): <.main+9072>
test/stdc/test.math.ci:33:[.049d5c, .049d78) exec(1), time(0.008-0.008 ms): <.main+9093>
test/stdc/test.math.ci:35:[.049d78, .049d90) exec(1), time(0.011-0.011 ms): <.main+9121>
test/stdc/test.math.ci:36:[.049d90, .049daf) exec(1), time(0.010-0.010 ms): <.main+9145>
test/stdc/test.math.ci:37:[.049daf, .049deb) exec(1), time(0.040-0.040 ms): <.main+9176>
test/stdc/test.math.ci:38:[.049deb, .049e39) exec(1), time(0.065-0.065 ms): <.main+9236>
test/stdc/test.math.ci:40:[.049e39, .049e4e) exec(1), time(0.023-0.023 ms): <.main+9314>
test/stdc/test.math.ci:41:[.049e4e, .049eb8) exec(1), time(0.092-0.092 ms): <.main+9335>
test/stdc/test.math.ci:42:[.049eb8, .049ecd) exec(1), time(0.042-0.042 ms): <.main+9441>
test/stdc/test.math.ci:43:[.049ecd, .049f37) exec(1), time(0.064-0.064 ms): <.main+9462>
test/stdc/test.math.ci:45:[.049f37, .049f4c) exec(1), time(0.025-0.025 ms): <.main+9568>
test/stdc/test.math.ci:46:[.049f4c, .049f6e) exec(1), time(0.031-0.031 ms): <.main+9589>
test/stdc/test.math.ci:47:[.049f6e, .049f99) exec(1), time(0.034-0.034 ms): <.main+9623>
test/stdc/test.math.ci:48:[.049f99, .04a00c) exec(1), time(0.068-0.068 ms): <.main+9666>
test/stdc/test.math.ci:50:[.04a00c, .04a015) exec(1), time(0.001-0.001 ms): <.main+9781>
test/stdc/test.math.ci:51:[.04a015, .04a02c) exec(1), time(0.041-0.041 ms): <.main+9790>
test/stdc/test.math.ci:52:[.04a02c, .04a035) exec(1), time(0.001-0.001 ms): <.main+9813>
test/stdc/test.math.ci:53:[.04a035, .04a04b) exec(1), time(0.005-0.005 ms): <.main+9822>
test/stdc/test.math.ci:54:[.04a04b, .04a072) exec(1), time(0.011-0.011 ms): <.main+9844>
test/stdc/test.math.ci:55:[.04a072, .04a0aa) exec(1), time(0.016-0.016 ms): <.main+9883>
test/stdc/test.math.ci:56:[.04a0aa, .04a0f2) exec(1), time(0.082-0.082 ms): <.main+9939>
test/stdc/test.math.ci:57:[.04a0f2, .04a143) exec(1), time(0.057-0.057 ms): <.main+10011>
test/stdc/test.math.ci:59:[.04a143, .04a162) exec(1), time(0.051-0.051 ms): <.main+10092>
test/stdc/test.math.ci:60:[.04a162, .04a18f) exec(1), time(0.072-0.072 ms): <.main+10123>
test/stdc/test.math.ci:61:[.04a18f, .04a1ad) exec(1), time(0.058-0.058 ms): <.main+10168>
test/stdc/test.math.ci:62:[.04a1ad, .04a1cb) exec(1), time(0.072-0.072 ms): <.main+10198>
test/stdc/test.math.ci:63:[.04a1cb, .04a1e9) exec(1), time(0.050-0.050 ms): <.main+10228>
test/stdc/test.math.ci:65:[.04a1e9, .04a1fd) exec(1), time(0.057-0.057 ms): <.main+10258>
test/stdc/test.math.ci:66:[.04a1fd, .04a225) exec(1), time(0.059-0.059 ms): <.main+10278>
test/stdc/test.math.ci:69:[.04a225, .04a241) exec(1), time(0.054-0.054 ms): <.main+10318>
test/stdc/test.math.ci:70:[.04a241, .04a269) exec(1), time(0.026-0.026 ms): <.main+10346>
test/stdc/test.math.ci:72:[.04a269, .04a286) exec(1), time(0.062-0.062 ms): <.main+10386>
test/stdc/test.math.ci:73:[.04a286, .04a29a) exec(1), time(0.029-0.029 ms): <.main+10415>
test/stdc/test.math.ci:74:[.04a29a, .04a2b7) exec(1), time(0.029-0.029 ms): <.main+10435>
test/stdc/test.math.ci:76:[.04a2b7, .04a2d4) exec(1), time(0.056-0.056 ms): <.main+10464>
test/stdc/test.math.ci:77:[.04a2d4, .04a2f1) exec(1), time(0.046-0.046 ms): <.main+10493>
test/stdc/test.math.ci:78:[.04a2f1, .04a30e) exec(1), time(0.028-0.028 ms): <.main+10522>
test/stdc/test.math.ci:79:[.04a30e, .04a32b) exec(1), time(0.056-0.056 ms): <.main+10551>
test/stdc/test.math.ci:81:[.04a32b, .04a348) exec(1), time(0.030-0.030 ms): <.main+10580>
test/stdc/test.math.ci:82:[.04a348, .04a365) exec(1), time(0.027-0.027 ms): <.main+10609>
test/stdc/test.math.ci:83:[.04a365, .04a382) exec(1), time(0.029-0.029 ms): <.main+10638>
test/stdc/test.math.ci:84:[.04a382, .04a39f) exec(1), time(0.028-0.028 ms): <.main+10667>
test/stdc/test.math.ci:86:[.04a39f, .04a3b4) exec(1), time(0.030-0.030 ms): <.main+10696>
test/stdc/test.math.ci:87:[.04a3b4, .04a3c5) exec(1), time(0.047-0.047 ms): <.main+10717>
test/stdc/test.math.ci:88:[.04a3c5, .04a3da) exec(1), time(0.058-0.058 ms): <.main+10734>
test/stdc/test.math.ci:90:[.04a3da, .04a3ef) exec(1), time(0.027-0.027 ms): <.main+10755>
test/stdc/test.math.ci:91:[.04a3ef, .04a404) exec(1), time(0.042-0.042 ms): <.main+10776>
test/stdc/test.math.ci:92:[.04a404, .04a419) exec(1), time(0.027-0.027 ms): <.main+10797>
test/stdc/test.math.ci:93:[.04a419, .04a42e) exec(1), time(0.027-0.027 ms): <.main+10818>
test/stdc/test.math.ci:95:[.04a42e, .04a443) exec(1), time(0.030-0.030 ms): <.main+10839>
test/stdc/test.math.ci:96:[.04a443, .04a458) exec(1), time(0.041-0.041 ms): <.main+10860>
test/stdc/test.math.ci:97:[.04a458, .04a46d) exec(1), time(0.028-0.028 ms): <.main+10881>
test/stdc/test.math.ci:98:[.04a46d, .04a482) exec(1), time(0.029-0.029 ms): <.main+10902>

---------- Exitcode: 0, time: 28.683 ms
