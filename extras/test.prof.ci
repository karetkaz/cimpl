
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (20 -> 24)
lib/stdlib.ci:43: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:44: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:45: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:55: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:72: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:75: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:81: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:84: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:91: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:97: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:157: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:157: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:161: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:161: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:184: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:184: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:185: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:185: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:281: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:287: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:288: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:291: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:295: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:295: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:299: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:304: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:339: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:343: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:351: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:359: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:358: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:354: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:350: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:371: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:393: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:398: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:399: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:404: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:420: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:423: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:424: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:426: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:436: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:442: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:447: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:493: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:494: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:498: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:56: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:109: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:115: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:122: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:123: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:123: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:125: warn: adding implicit cast char(0: int32)
lib/std/string.ci:138: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:141: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:141: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:142: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:161: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:166: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:173: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:186: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:186: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:188: warn: adding implicit cast char(0: int32)
lib/std/string.ci:199: warn: adding implicit cast int32('-': char)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:108: warn: adding implicit cast char(0: int32)
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:206: debug: using default field initializer: FormatFlags.precision := 0

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/lang/emit.ci:11: warn: adding implicit cast float64(2: int32)
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/lang/method.ci:53: debug: using default field initializer: RecordMethodTest.print(this: RecordMethodTest): void := print
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.delegateMethod(x: int32, y: int32): int32 := forwardMethod
test/lang/method.ci:63: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`

---------- Generate: byte-code
lib/std/math.ci:60: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:286: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:289: warn: using default type initializer: e := 0
lib/std/math.ci:293: warn: using default type initializer: f := 0
lib/std/math.ci:345: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:402: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:134: warn: uninitialized variable `append.digits`
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:27: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang/method.ci:73: warn: accessing static member using instance variable `RecordMethodTest.printStatic(this: RecordMethodTest): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+24>, cast: const variable)
.field offset: int32 (size: 4, offs: <+32>, cast: const variable)
.field base: function (size: 0, offs: <@0055a8>, cast: static const inline)
.field file: function (size: 0, offs: <@005778>, cast: static const inline)
.field line: function (size: 0, offs: <@005948>, cast: static const inline)
.field name: function (size: 0, offs: <@005b18>, cast: static const inline)
.references:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/stdlib.ci:53: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal references: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+24>
.name: 'size'
.owner: typename
.references:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:53: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'offset'
.print: '@%06x'
.owner: typename
.references:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0055a8>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.references:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal references: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005778>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.references:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal references: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005948>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.references:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal references: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005b18>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.references:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal references: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000a0>
.name: 'void'
.references:
	test/lang/method.ci:79: referenced as `void`
	test/lang/method.ci:75: referenced as `void`
	test/lang/method.ci:59: referenced as `void`
	test/lang/method.ci:44: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:38: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:29: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:28: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	lib/stdlib.ci:27: referenced as `void`
	internal references: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000130>
.name: 'bool'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:44: referenced as `bool`
	lib/std/string.ci:35: referenced as `bool`
	lib/std/math.ci:441: referenced as `bool`
	lib/std/math.ci:392: referenced as `bool`
	lib/std/math.ci:337: referenced as `bool`
	lib/std/math.ci:336: referenced as `bool`
	lib/stdlib.ci:29: referenced as `bool`
	lib/stdlib.ci:28: referenced as `bool`
	lib/stdlib.ci:27: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001c0>
.name: 'char'
.print: '%c'
.value: 0
.references:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:205: referenced as `char`
	lib/std/string.ci:196: referenced as `char`
	lib/std/string.ci:192: referenced as `char`
	lib/std/string.ci:150: referenced as `char`
	lib/std/string.ci:134: referenced as `char`
	lib/std/string.ci:131: referenced as `char`
	lib/std/string.ci:130: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:129: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:113: referenced as `char`
	lib/std/string.ci:108: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:90: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:89: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:84: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:71: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:70: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:58: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:44: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:35: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:24: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:14: referenced as `char`
	lib/std/string.ci:3: referenced as `char`
	lib/stdlib.ci:38: referenced as `char`
	lib/stdlib.ci:34: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:24: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	lib/stdlib.ci:14: referenced as `char`
	lib/stdlib.ci:12: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:9: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	lib/stdlib.ci:5: referenced as `char`
	internal references: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000250>
.name: 'int8'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@0002e0>
.name: 'int16'
.print: '%d'
.value: 0
.references:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000370>
.name: 'int32'
.print: '%d'
.value: 0
.references:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:49: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:31: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:26: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:20: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:16: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:12: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:205: referenced as `int32`
	lib/std/string.ci:197: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:196: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:192: referenced as `int32`
	lib/std/string.ci:179: referenced as `int32`
	lib/std/string.ci:148: referenced as `int32`
	lib/std/string.ci:136: referenced as `int32`
	lib/std/string.ci:133: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:129: referenced as `int32`
	lib/std/string.ci:114: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:110: referenced as `int32`
	lib/std/string.ci:109: referenced as `int32`
	lib/std/string.ci:107: referenced as `int32`
	lib/std/string.ci:84: referenced as `int32`
	lib/std/string.ci:70: referenced as `int32`
	lib/std/string.ci:60: referenced as `int32`
	lib/std/string.ci:59: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:58: referenced as `int32`
	lib/std/string.ci:50: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:45: referenced as `int32`
	lib/std/string.ci:44: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:35: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:24: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:14: referenced as `int32`
	lib/std/string.ci:7: referenced as `int32`
	lib/std/string.ci:3: referenced as `int32`
	lib/std/math.ci:347: referenced as `int32`
	lib/std/math.ci:347: referenced as `int32`
	lib/std/math.ci:298: referenced as `int32`
	lib/std/math.ci:266: referenced as `int32`
	lib/std/math.ci:252: referenced as `int32`
	lib/std/math.ci:239: referenced as `int32`
	lib/std/math.ci:80: referenced as `int32`
	lib/std/math.ci:71: referenced as `int32`
	lib/stdlib.ci:53: referenced as `int32`
	lib/stdlib.ci:49: referenced as `int32`
	lib/stdlib.ci:49: referenced as `int32`
	lib/stdlib.ci:38: referenced as `int32`
	lib/stdlib.ci:38: referenced as `int32`
	internal references: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000400>
.name: 'int64'
.print: '%D'
.value: 0
.references:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal references: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000490>
.name: 'uint8'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@000520>
.name: 'uint16'
.print: '%u'
.value: 0
.references:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0005b0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@008328>, cast: static const inline)
.field sxt: function (size: 0, offs: <@008608>, cast: static const inline)
.field pop: function (size: 0, offs: <@0087d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0089a8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@008b78>, cast: static const inline)
.field bsf: function (size: 0, offs: <@008d48>, cast: static const inline)
.field hib: function (size: 0, offs: <@008f18>, cast: static const inline)
.field lob: function (size: 0, offs: <@0090e8>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:205: referenced as `uint32`
	lib/std/string.ci:192: referenced as `uint32`
	lib/std/string.ci:129: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008328>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.references:
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal references: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008608>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.references:
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal references: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0087d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.references:
	internal references: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.references:
	internal references: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b78>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.references:
	internal references: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d48>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.references:
	internal references: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.references:
	internal references: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0090e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.references:
	internal references: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000640>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@0093c0>, cast: static const inline)
.field sxt: function (size: 0, offs: <@009698>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093c0>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.references:
	internal references: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009698>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.references:
	internal references: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0006d0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@009870>, cast: static const inline)
.field cos: function (size: 0, offs: <@009a40>, cast: static const inline)
.field tan: function (size: 0, offs: <@009c10>, cast: static const inline)
.field log: function (size: 0, offs: <@009de0>, cast: static const inline)
.field exp: function (size: 0, offs: <@009fb0>, cast: static const inline)
.field pow: function (size: 0, offs: <@00a210>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00a3e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00a638>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	test/lang/emit.ci:11: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:239: referenced as `float32`
	lib/std/math.ci:184: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:155: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:148: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:129: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:116: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:103: referenced as `float32`
	lib/std/math.ci:90: referenced as `float32`
	lib/std/math.ci:90: referenced as `float32`
	lib/std/math.ci:71: referenced as `float32`
	internal references: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009870>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.references:
	test/stdc/number.ci:46: referenced as `sin`
	test/lang/emit.ci:11: referenced as `sin`
	internal references: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009a40>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.references:
	test/stdc/number.ci:47: referenced as `cos`
	internal references: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009c10>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.references:
	test/stdc/number.ci:48: referenced as `tan`
	internal references: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009de0>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.references:
	test/stdc/number.ci:49: referenced as `log`
	internal references: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009fb0>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.references:
	test/stdc/number.ci:50: referenced as `exp`
	internal references: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a210>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.references:
	test/stdc/number.ci:51: referenced as `pow`
	internal references: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a3e0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.references:
	test/stdc/number.ci:52: referenced as `sqrt`
	internal references: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a638>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.references:
	test/stdc/number.ci:53: referenced as `atan2`
	internal references: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000760>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00a800>, cast: static const inline)
.field cos: function (size: 0, offs: <@00a9c8>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ab90>, cast: static const inline)
.field log: function (size: 0, offs: <@00ad58>, cast: static const inline)
.field exp: function (size: 0, offs: <@00af20>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b170>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b338>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b588>, cast: static const inline)
.value: 0
.references:
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:145: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:120: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:119: referenced as `float64`
	lib/std/math.Complex.ci:117: referenced as `float64`
	lib/std/math.Complex.ci:114: referenced as `float64`
	lib/std/math.Complex.ci:113: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:110: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:108: referenced as `float64`
	lib/std/math.Complex.ci:105: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:103: referenced as `float64`
	lib/std/math.Complex.ci:94: referenced as `float64`
	lib/std/math.Complex.ci:90: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:87: referenced as `float64`
	lib/std/math.Complex.ci:86: referenced as `float64`
	lib/std/math.Complex.ci:79: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:72: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:63: referenced as `float64`
	lib/std/math.Complex.ci:60: referenced as `float64`
	lib/std/math.Complex.ci:59: referenced as `float64`
	lib/std/math.Complex.ci:56: referenced as `float64`
	lib/std/math.Complex.ci:55: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:25: referenced as `float64`
	lib/std/math.Complex.ci:20: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.Complex.ci:4: referenced as `float64`
	lib/std/math.ci:494: referenced as `float64`
	lib/std/math.ci:494: referenced as `float64`
	lib/std/math.ci:493: referenced as `float64`
	lib/std/math.ci:493: referenced as `float64`
	lib/std/math.ci:470: referenced as `float64`
	lib/std/math.ci:457: referenced as `float64`
	lib/std/math.ci:454: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:452: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:435: referenced as `float64`
	lib/std/math.ci:426: referenced as `float64`
	lib/std/math.ci:426: referenced as `float64`
	lib/std/math.ci:424: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:419: referenced as `float64`
	lib/std/math.ci:407: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:404: referenced as `float64`
	lib/std/math.ci:402: referenced as `float64`
	lib/std/math.ci:399: referenced as `float64`
	lib/std/math.ci:382: referenced as `float64`
	lib/std/math.ci:380: referenced as `float64`
	lib/std/math.ci:380: referenced as `float64`
	lib/std/math.ci:364: referenced as `float64`
	lib/std/math.ci:363: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:345: referenced as `float64`
	lib/std/math.ci:324: referenced as `float64`
	lib/std/math.ci:323: referenced as `float64`
	lib/std/math.ci:323: referenced as `float64`
	lib/std/math.ci:320: referenced as `float64`
	lib/std/math.ci:317: referenced as `float64`
	lib/std/math.ci:312: referenced as `float64`
	lib/std/math.ci:311: referenced as `float64`
	lib/std/math.ci:310: referenced as `float64`
	lib/std/math.ci:293: referenced as `float64`
	lib/std/math.ci:289: referenced as `float64`
	lib/std/math.ci:286: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:267: referenced as `float64`
	lib/std/math.ci:266: referenced as `float64`
	lib/std/math.ci:266: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:252: referenced as `float64`
	lib/std/math.ci:185: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:159: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:151: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:138: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:122: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:109: referenced as `float64`
	lib/std/math.ci:96: referenced as `float64`
	lib/std/math.ci:96: referenced as `float64`
	lib/std/math.ci:80: referenced as `float64`
	lib/std/math.ci:65: referenced as `float64`
	lib/std/math.ci:64: referenced as `float64`
	lib/std/math.ci:60: referenced as `float64`
	lib/std/math.ci:59: referenced as `float64`
	lib/std/math.ci:59: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:6: referenced as `float64`
	internal references: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a800>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.references:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:145: referenced as `sin`
	lib/std/math.Complex.ci:120: referenced as `sin`
	lib/std/math.Complex.ci:119: referenced as `sin`
	lib/std/math.Complex.ci:114: referenced as `sin`
	lib/std/math.Complex.ci:103: referenced as `sin`
	internal references: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a9c8>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.references:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:145: referenced as `cos`
	lib/std/math.Complex.ci:120: referenced as `cos`
	lib/std/math.Complex.ci:119: referenced as `cos`
	lib/std/math.Complex.ci:113: referenced as `cos`
	lib/std/math.Complex.ci:103: referenced as `cos`
	internal references: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab90>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.references:
	test/stdc/number.ci:39: referenced as `tan`
	internal references: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad58>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.references:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:110: referenced as `log`
	lib/std/math.Complex.ci:105: referenced as `log`
	internal references: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af20>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.references:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:111: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.Complex.ci:103: referenced as `exp`
	lib/std/math.ci:426: referenced as `exp`
	lib/std/math.ci:426: referenced as `exp`
	lib/std/math.ci:424: referenced as `exp`
	lib/std/math.ci:404: referenced as `exp`
	lib/std/math.ci:404: referenced as `exp`
	lib/std/math.ci:399: referenced as `exp`
	internal references: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b170>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.references:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:111: referenced as `pow`
	internal references: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.references:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:89: referenced as `sqrt`
	lib/std/math.ci:452: referenced as `sqrt`
	internal references: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b588>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.references:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:90: referenced as `atan2`
	lib/std/math.ci:457: referenced as `atan2`
	lib/std/math.ci:454: referenced as `atan2`
	internal references: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@006c50>, cast: static const inline)
.field fill: function (size: 0, offs: <@006f40>, cast: static const inline)
.field copy: function (size: 0, offs: <@007228>, cast: static const inline)
.field move: function (size: 0, offs: <@007508>, cast: static const inline)
.references:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal references: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006c50>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.references:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal references: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f40>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.references:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal references: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007228>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.references:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal references: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007508>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.references:
	test/stdc/memory.ci:29: referenced as `move`
	internal references: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000880>
.name: 'variant'
.references:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:33: referenced as `variant`
	lib/stdlib.ci:32: referenced as `variant`
	lib/stdlib.ci:27: referenced as `variant`
	lib/stdlib.ci:23: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:17: referenced as `variant`
	lib/stdlib.ci:14: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:8: referenced as `variant`
	lib/stdlib.ci:5: referenced as `variant`
	internal references: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000910>
.name: 'function'
.references:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0009a8>
.name: 'object'
.references:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.references:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/std/string.ci:4: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:25: referenced as `null`
	lib/stdlib.ci:24: referenced as `null`
	lib/stdlib.ci:21: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:15: referenced as `null`
	lib/stdlib.ci:12: referenced as `null`
	lib/stdlib.ci:9: referenced as `null`
	lib/stdlib.ci:6: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.references:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:55: referenced as `true`
	lib/std/string.ci:41: referenced as `true`
	lib/std/math.ci:443: referenced as `true`
	lib/std/math.ci:395: referenced as `true`
	lib/std/math.ci:356: referenced as `true`
	lib/std/math.ci:352: referenced as `true`
	lib/std/math.ci:341: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.references:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:52: referenced as `false`
	lib/std/string.ci:48: referenced as `false`
	lib/std/string.ci:38: referenced as `false`
	lib/std/math.ci:441: referenced as `false`
	lib/std/math.ci:392: referenced as `false`
	lib/std/math.ci:337: referenced as `false`
	lib/std/math.ci:336: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.references:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.references:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.references:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.references:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000eb8>
.name: '.cstr'
.print: '%s'
.references:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000f48>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0012a8>, cast: static const typename(val))
.field dup: void (size: 0, offs: <@001338>, cast: static const typename(void))
.field load: void (size: 0, offs: <@001578>, cast: static const typename(void))
.field store: void (size: 0, offs: <@001a88>, cast: static const typename(void))
.field cmt: void (size: 0, offs: <@001dc0>, cast: static const typename(void))
.field and: void (size: 0, offs: <@001f70>, cast: static const typename(void))
.field or: void (size: 0, offs: <@002110>, cast: static const typename(void))
.field xor: void (size: 0, offs: <@0022b0>, cast: static const typename(void))
.field shl: void (size: 0, offs: <@002450>, cast: static const typename(void))
.field shr: void (size: 0, offs: <@0025f0>, cast: static const typename(void))
.field neg: void (size: 0, offs: <@0028a0>, cast: static const typename(void))
.field add: void (size: 0, offs: <@002c80>, cast: static const typename(void))
.field sub: void (size: 0, offs: <@003040>, cast: static const typename(void))
.field mul: void (size: 0, offs: <@003400>, cast: static const typename(void))
.field div: void (size: 0, offs: <@0038d0>, cast: static const typename(void))
.field mod: void (size: 0, offs: <@003da0>, cast: static const typename(void))
.field ceq: void (size: 0, offs: <@004160>, cast: static const typename(void))
.field clt: void (size: 0, offs: <@004520>, cast: static const typename(void))
.field cgt: void (size: 0, offs: <@0048e0>, cast: static const typename(void))
.field min: void (size: 0, offs: <@004ca0>, cast: static const typename(void))
.field max: void (size: 0, offs: <@004e40>, cast: static const typename(void))
.references:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:11: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.references:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.references:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.references:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.references:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.references:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0012a8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.references:
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.references:
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.references:
}
emit.dup: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001338>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.references:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.references:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.references:
}
emit.load: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001578>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.references:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.references:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.references:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.references:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.references:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.references:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.references:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.references:
}
emit.store: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001a88>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.references:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.references:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.references:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.references:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.references:
}
emit.cmt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001dc0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.references:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.references:
}
emit.and: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@001f70>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.references:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.references:
}
emit.or: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002110>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.references:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.references:
}
emit.xor: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0022b0>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.references:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.references:
}
emit.shl: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002450>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.references:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.references:
}
emit.shr: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0025f0>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.references:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.references:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.references:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.references:
}
emit.neg: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0028a0>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.references:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.references:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.references:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.references:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.references:
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.references:
}
emit.add: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@002c80>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:9: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.references:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.references:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.references:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.references:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.references:
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.references:
}
emit.sub: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003040>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.references:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.references:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.references:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.references:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.references:
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.references:
}
emit.mul: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003400>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.references:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.references:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.references:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.references:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.references:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.references:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.references:
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.references:
}
emit.div: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0038d0>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
	test/lang/emit.ci:10: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.references:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.references:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.references:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.references:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.references:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.references:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.references:
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.references:
}
emit.mod: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@003da0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.references:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.references:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.references:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.references:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.references:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.references:
}
emit.ceq: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004160>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.references:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.references:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.references:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.references:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.references:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.references:
}
emit.clt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004520>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.references:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.references:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.references:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.references:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.references:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.references:
}
emit.cgt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@0048e0>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.references:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.references:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.references:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.references:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.references:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.references:
}
emit.min: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004ca0>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.references:
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.references:
}
emit.max: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@004e40>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.references:
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.references:
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.references:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0052b0>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.references:
	internal references: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.references:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.references:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0061f0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.value: nfc(5)
.references:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:24: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:14: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:9: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:5: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal references: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.references:
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:25: referenced as `abort`
	lib/stdlib.ci:24: referenced as `abort`
	lib/stdlib.ci:23: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.references:
	lib/stdlib.ci:21: referenced as `error`
	lib/stdlib.ci:20: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.references:
	lib/stdlib.ci:18: referenced as `warn`
	lib/stdlib.ci:17: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.references:
	lib/stdlib.ci:15: referenced as `info`
	lib/stdlib.ci:14: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.references:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:12: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
	lib/stdlib.ci:9: referenced as `debug`
	lib/stdlib.ci:8: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.references:
	lib/stdlib.ci:6: referenced as `verbose`
	lib/stdlib.ci:5: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.references:
	lib/stdlib.ci:18: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
	lib/stdlib.ci:14: referenced as `noTrace`
	lib/stdlib.ci:12: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
	lib/stdlib.ci:5: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.references:
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
	lib/stdlib.ci:24: referenced as `defTrace`
	lib/stdlib.ci:23: referenced as `defTrace`
	lib/stdlib.ci:21: referenced as `defTrace`
	lib/stdlib.ci:20: referenced as `defTrace`
	lib/stdlib.ci:9: referenced as `defTrace`
	lib/stdlib.ci:8: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0069f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.references:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal references: 1
}
System: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.offset: <@007538>
.name: 'System'
.field exit: function (size: 0, offs: <@007770>, cast: static const inline)
.field srand: function (size: 0, offs: <@007948>, cast: static const inline)
.field rand: function (size: 0, offs: <@007a90>, cast: static const inline)
.field time: function (size: 0, offs: <@007bd8>, cast: static const inline)
.field clock: function (size: 0, offs: <@007d20>, cast: static const inline)
.field millis: function (size: 0, offs: <@007e68>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008038>, cast: static const inline)
.references:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007770>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.references:
	internal references: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007948>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.references:
	internal references: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.references:
	internal references: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bd8>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.references:
	internal references: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007d20>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.references:
	internal references: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007e68>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.references:
	internal references: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008038>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.references:
	internal references: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:5: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:6: defined as `verbose(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:8: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.references:
	test/lang/method.ci:80: referenced as `trace`
	test/lang/method.ci:76: referenced as `trace`
	test/lang/method.ci:60: referenced as `trace`
	test/lang/method.ci:45: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	lib/stdlib.ci:9: defined as `trace(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.references:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.references:
	test/lang/statementFor.ci:4: referenced as `debug`
	lib/stdlib.ci:12: defined as `debug(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:14: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:15: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.references:
	lib/stdlib.ci:17: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.references:
	lib/stdlib.ci:18: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.references:
	lib/stdlib.ci:20: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.references:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:21: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.references:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:27: referenced as `abort`
	lib/stdlib.ci:23: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.references:
	lib/stdlib.ci:29: referenced as `abort`
	lib/stdlib.ci:28: referenced as `abort`
	lib/stdlib.ci:24: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.references:
	lib/stdlib.ci:25: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.value: void(condition ? void(0) : abort(void(message, inspect)))
.references:
	lib/std/string.ci:138: referenced as `assert`
	lib/std/string.ci:137: referenced as `assert`
	lib/stdlib.ci:27: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.value: void(condition ? void(0) : abort(message))
.references:
	lib/stdlib.ci:28: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
.references:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:173: referenced as `assert`
	lib/std/string.ci:166: referenced as `assert`
	lib/std/string.ci:161: referenced as `assert`
	lib/stdlib.ci:29: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@00e058>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+16>, cast: const variable(ref))
.references:
	lib/stdlib.ci:42: referenced as `NotEquals`
	lib/stdlib.ci:31: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
.references:
	lib/stdlib.ci:43: referenced as `expected`
	lib/stdlib.ci:32: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
.references:
	lib/stdlib.ci:44: referenced as `returned`
	lib/stdlib.ci:33: defined as `returned`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+16>
.name: 'message'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
.references:
	lib/stdlib.ci:45: referenced as `message`
	lib/stdlib.ci:34: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 83
.offset: <@03c6d8>
.name: 'assertEq'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (83 bytes: <@03c6d8> - <@03c72b>)
	lib/stdlib.ci:39: (10 bytes: <@03c6d8> - <@03c6e2>): if (bool(returned == expected))
	<assertEq @03c6d8>      : 12 02                      dup.x1 sp(2)
	<assertEq+2 @03c6da>    : 12 04                      dup.x1 sp(4)
	<assertEq+4 @03c6dc>    : 57                         ceq.i32
	<assertEq+5 @03c6dd>    : 06 05 00 00                jz <assertEq+10 @03c6e2>
	lib/stdlib.ci:40: (1 byte: <@03c6e1> - <@03c6e2>): return;
	<assertEq+9 @03c6e1>    : 03                         ret
	lib/stdlib.ci:42: (30 bytes: <@03c6e2> - <@03c700>): details: NotEquals := {...}
	<assertEq+10 @03c6e2>   : 10 18 00 00                inc.sp(+24)
	lib/stdlib.ci:43: (11 bytes: <@03c6e6> - <@03c6f1>): void(details.expected := (expected));
	<assertEq+14 @03c6e6>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+19 @03c6eb>   : 11 28 00 00                load.sp(+40)
	<assertEq+23 @03c6ef>   : 16 02                      set.x2 sp(2)
	lib/stdlib.ci:44: (11 bytes: <@03c6f1> - <@03c6fc>): void(details.returned := (returned));
	<assertEq+25 @03c6f1>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<assertEq+30 @03c6f6>   : 11 24 00 00                load.sp(+36)
	<assertEq+34 @03c6fa>   : 16 04                      set.x2 sp(4)
	lib/stdlib.ci:45: (4 bytes: <@03c6fc> - <@03c700>): void(details.message := (message));
	<assertEq+36 @03c6fc>   : 12 07                      dup.x1 sp(7)
	<assertEq+38 @03c6fe>   : 15 05                      set.x1 sp(5)
	lib/stdlib.ci:47: (38 bytes: <@03c700> - <@03c726>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+40 @03c700>   : 1f b8 b5 00 00             load.ref <@00b5b8> ;"lib/stdlib.ci"
	<assertEq+45 @03c705>   : 1b 2f 00 00 00             load.c32 47
	<assertEq+50 @03c70a>   : 1b fe ff ff ff             load.c32 -2
	<assertEq+55 @03c70f>   : 1b 80 00 00 00             load.c32 128
	<assertEq+60 @03c714>   : 1f 29 b6 00 00             load.ref <@00b629> ;"assertion failed"
	<assertEq+65 @03c719>   : 1f 58 e0 00 00             load.ref <@00e058> ;NotEquals
	<assertEq+70 @03c71e>   : 11 18 00 00                load.sp(+24)
	<assertEq+74 @03c722>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+78 @03c726>   : 10 e8 ff ff                inc.sp(-24)
	<assertEq+82 @03c72a>   : 03                         ret
.references:
	lib/stdlib.ci:49: referenced as `assertEq`
	lib/stdlib.ci:38: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.value: assertEq(void(void(expected, returned), null))
.references:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:49: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:53'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.value: int32(type.size)
.references:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:53: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(val)
.base: `typename`
.size: 0
.offset: <@00ebc0>
.name: 'Math'
.file: 'lib/std/math.ci:3'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 104, offs: <@03c730>, cast: static const function)
.field floor: function (size: 35, offs: <@03c798>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 36, offs: <@03c7c0>, cast: static const function)
.field sign: function (size: 36, offs: <@03c7e8>, cast: static const function)
.field abs: function (size: 19, offs: <@03c810>, cast: static const function)
.field abs: function (size: 19, offs: <@03c828>, cast: static const function)
.field min: function (size: 19, offs: <@03c840>, cast: static const function)
.field min: function (size: 19, offs: <@03c858>, cast: static const function)
.field max: function (size: 19, offs: <@03c870>, cast: static const function)
.field max: function (size: 19, offs: <@03c888>, cast: static const function)
.field clamp: function (size: 33, offs: <@03c8a0>, cast: static const function)
.field clamp: function (size: 33, offs: <@03c8c8>, cast: static const function)
.field lerp: function (size: 14, offs: <@03c8f0>, cast: static const function)
.field lerp: function (size: 14, offs: <@03c900>, cast: static const function)
.field smooth: function (size: 53, offs: <@03c910>, cast: static const function)
.field smooth: function (size: 65, offs: <@03c948>, cast: static const function)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field cmp: function (size: 57, offs: <@03c990>, cast: static const function)
.field cmp: function (size: 57, offs: <@03c9d0>, cast: static const function)
.field sinCos: function (size: 348, offs: <@03ca10>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@03cb70>, cast: static const function)
.field sinh: function (size: 248, offs: <@03ccf0>, cast: static const function)
.field cosh: function (size: 75, offs: <@03cde8>, cast: static const function)
.field asin: function (size: 174, offs: <@03ce38>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field deg2rad: function (size: 0, offs: <@000000>, cast: static inline)
.field rad2deg: function (size: 0, offs: <@000000>, cast: static inline)
.references:
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:120: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:119: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.Complex.ci:70: referenced as `Math`
	lib/std/math.ci:3: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:7'
.owner: Math
.value: 3.141593
.references:
	lib/std/math.ci:494: referenced as `pi`
	lib/std/math.ci:493: referenced as `pi`
	lib/std/math.ci:470: referenced as `pi`
	lib/std/math.ci:454: referenced as `pi`
	lib/std/math.ci:7: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:8'
.owner: Math
.value: 2.718282
.references:
	lib/std/math.ci:8: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:9'
.owner: Math
.value: 0.693147
.references:
	lib/std/math.ci:10: referenced as `ln2`
	lib/std/math.ci:9: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:10'
.owner: Math
.value: float64(1.000000 / ln2)
.references:
	lib/std/math.ci:10: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:11'
.owner: Math
.value: 2.302585
.references:
	lib/std/math.ci:12: referenced as `ln10`
	lib/std/math.ci:11: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:12'
.owner: Math
.value: float64(1.000000 / ln10)
.references:
	lib/std/math.ci:12: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:13'
.owner: Math
.value: 1.618034
.references:
	lib/std/math.ci:13: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:14'
.owner: Math
.value: 1.414214
.references:
	lib/std/math.ci:14: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:15'
.owner: Math
.value: 1.648721
.references:
	lib/std/math.ci:15: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:16'
.owner: Math
.value: 1.772454
.references:
	lib/std/math.ci:16: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:17'
.owner: Math
.value: 1.272020
.references:
	lib/std/math.ci:17: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:18'
.owner: Math
.value: float64((0) / 0.000000)
.references:
	lib/std/math.ci:449: referenced as `nan`
	lib/std/math.ci:369: referenced as `nan`
	lib/std/math.ci:18: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:19'
.owner: Math
.value: float64((1) / 0.000000)
.references:
	lib/std/math.ci:19: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 104
.offset: <@03c730>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (104 bytes: <@03c730> - <@03c798>)
	lib/std/math.ci:23: (70 bytes: <@03c730> - <@03c776>): if (bool(x < (1)))
	<modf @03c730>      : 13 02                      dup.x2 sp(2)
	<modf+2 @03c732>    : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @03c73b>   : 88                         clt.f64
	<modf+12 @03c73c>   : 06 3a 00 00                jz <modf+70 @03c776>
	lib/std/math.ci:24: (45 bytes: <@03c740> - <@03c76d>): if (bool(x < (0)))
	<modf+16 @03c740>   : 13 02                      dup.x2 sp(2)
	<modf+18 @03c742>   : 19                         load.z64
	<modf+19 @03c743>   : 88                         clt.f64
	<modf+20 @03c744>   : 06 29 00 00                jz <modf+61 @03c76d>
	lib/std/math.ci:25: (17 bytes: <@03c748> - <@03c759>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @03c748>   : 19                         load.z64
	<modf+25 @03c749>   : 13 04                      dup.x2 sp(4)
	<modf+27 @03c74b>   : 80                         neg.f64
	<modf+28 @03c74c>   : 12 05                      dup.x1 sp(5)
	<modf+30 @03c74e>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @03c753>   : 02                         call
	<modf+36 @03c754>   : 10 f4 ff ff                inc.sp(-12)
	<modf+40 @03c758>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@03c759> - <@03c760>): float64(intPart := float64(-intPart));
	<modf+41 @03c759>   : 12 03                      dup.x1 sp(3)
	<modf+43 @03c75b>   : 23                         load.i64
	<modf+44 @03c75c>   : 80                         neg.f64
	<modf+45 @03c75d>   : 12 05                      dup.x1 sp(5)
	<modf+47 @03c75f>   : 28                         store.i64
	lib/std/math.ci:27: (9 bytes: <@03c760> - <@03c769>): return float64(.result := result);
	<modf+48 @03c760>   : 13 00                      dup.x2 sp(0)
	<modf+50 @03c762>   : 16 08                      set.x2 sp(8)
	<modf+52 @03c764>   : 10 f8 ff ff                inc.sp(-8)
	<modf+56 @03c768>   : 03                         ret
	<modf+57 @03c769>   : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@03c76d> - <@03c771>): float64(intPart := (0));
	<modf+61 @03c76d>   : 19                         load.z64
	<modf+62 @03c76e>   : 12 03                      dup.x1 sp(3)
	<modf+64 @03c770>   : 28                         store.i64
	lib/std/math.ci:30: (5 bytes: <@03c771> - <@03c776>): return float64(.result := x);
	<modf+65 @03c771>   : 13 02                      dup.x2 sp(2)
	<modf+67 @03c773>   : 16 06                      set.x2 sp(6)
	<modf+69 @03c775>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@03c776> - <@03c782>): result: float64 := float64(x % (1))
	<modf+70 @03c776>   : 13 02                      dup.x2 sp(2)
	<modf+72 @03c778>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+81 @03c781>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@03c782> - <@03c78a>): float64(intPart := float64(x - result));
	<modf+82 @03c782>   : 13 04                      dup.x2 sp(4)
	<modf+84 @03c784>   : 13 02                      dup.x2 sp(2)
	<modf+86 @03c786>   : 82                         sub.f64
	<modf+87 @03c787>   : 12 05                      dup.x1 sp(5)
	<modf+89 @03c789>   : 28                         store.i64
	lib/std/math.ci:34: (9 bytes: <@03c78a> - <@03c793>): return float64(.result := result);
	<modf+90 @03c78a>   : 13 00                      dup.x2 sp(0)
	<modf+92 @03c78c>   : 16 08                      set.x2 sp(8)
	<modf+94 @03c78e>   : 10 f8 ff ff                inc.sp(-8)
	<modf+98 @03c792>   : 03                         ret
	<modf+99 @03c793>   : 10 f8 ff ff                inc.sp(-8)
	<modf+103 @03c797>  : 03                         ret
.references:
	lib/std/math.ci:346: referenced as `modf`
	lib/std/math.ci:294: referenced as `modf`
	lib/std/math.ci:290: referenced as `modf`
	lib/std/math.ci:61: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 35
.offset: <@03c798>
.name: 'floor'
.file: 'lib/std/math.ci:59'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (35 bytes: <@03c798> - <@03c7bb>)
	lib/std/math.ci:60: (1 byte: <@03c798> - <@03c799>): result: float64
	<floor @03c798>      : 1a                         load.z128
	lib/std/math.ci:61: (20 bytes: <@03c799> - <@03c7ad>): modf(void(x, result));
	<floor+1 @03c799>    : 13 05                      dup.x2 sp(5)
	<floor+3 @03c79b>    : 11 10 00 00                load.sp(+16)
	<floor+7 @03c79f>    : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @03c7a4>   : 02                         call
	<floor+13 @03c7a5>   : 10 f4 ff ff                inc.sp(-12)
	<floor+17 @03c7a9>   : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:62: (9 bytes: <@03c7ad> - <@03c7b6>): return float64(.result := result);
	<floor+21 @03c7ad>   : 13 00                      dup.x2 sp(0)
	<floor+23 @03c7af>   : 16 07                      set.x2 sp(7)
	<floor+25 @03c7b1>   : 10 f8 ff ff                inc.sp(-8)
	<floor+29 @03c7b5>   : 03                         ret
	<floor+30 @03c7b6>   : 10 f8 ff ff                inc.sp(-8)
	<floor+34 @03c7ba>   : 03                         ret
.references:
	lib/std/math.ci:65: referenced as `floor`
	lib/std/math.ci:64: referenced as `floor`
	lib/std/math.ci:59: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(-floor(float64(-x)))
.references:
	lib/std/math.ci:64: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:65'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: floor(float64(x + 0.500000))
.references:
	lib/std/math.ci:65: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03c7c0>
.name: 'sign'
.file: 'lib/std/math.ci:71'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@03c7c0> - <@03c7e4>)
	lib/std/math.ci:72: (12 bytes: <@03c7c0> - <@03c7cc>): if (bool(x == (0)))
	<sign @03c7c0>      : 12 01                      dup.x1 sp(1)
	<sign+2 @03c7c2>    : 18                         load.z32
	<sign+3 @03c7c3>    : 77                         ceq.f32
	<sign+4 @03c7c4>    : 06 08 00 00                jz <sign+12 @03c7cc>
	lib/std/math.ci:73: (4 bytes: <@03c7c8> - <@03c7cc>): return int32(.result := 0);
	<sign+8 @03c7c8>    : 18                         load.z32
	<sign+9 @03c7c9>    : 15 03                      set.x1 sp(3)
	<sign+11 @03c7cb>   : 03                         ret
	lib/std/math.ci:75: (16 bytes: <@03c7cc> - <@03c7dc>): if (bool(x < (0)))
	<sign+12 @03c7cc>   : 12 01                      dup.x1 sp(1)
	<sign+14 @03c7ce>   : 18                         load.z32
	<sign+15 @03c7cf>   : 78                         clt.f32
	<sign+16 @03c7d0>   : 06 0c 00 00                jz <sign+28 @03c7dc>
	lib/std/math.ci:76: (8 bytes: <@03c7d4> - <@03c7dc>): return int32(.result := int32(-1));
	<sign+20 @03c7d4>   : 1b ff ff ff ff             load.c32 -1
	<sign+25 @03c7d9>   : 15 03                      set.x1 sp(3)
	<sign+27 @03c7db>   : 03                         ret
	lib/std/math.ci:78: (8 bytes: <@03c7dc> - <@03c7e4>): return int32(.result := 1);
	<sign+28 @03c7dc>   : 1b 01 00 00 00             load.c32 1
	<sign+33 @03c7e1>   : 15 03                      set.x1 sp(3)
	<sign+35 @03c7e3>   : 03                         ret
.references:
	lib/std/math.ci:71: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03c7e8>
.name: 'sign'
.file: 'lib/std/math.ci:80'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: float64 (size: 8, offs: <+12>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return int32(.result := 0);
	}
	if (bool(x < (0))) {
		return int32(.result := int32(-1));
	}
	return int32(.result := 1);
}
.instructions: (36 bytes: <@03c7e8> - <@03c80c>)
	lib/std/math.ci:81: (12 bytes: <@03c7e8> - <@03c7f4>): if (bool(x == (0)))
	<sign @03c7e8>      : 13 01                      dup.x2 sp(1)
	<sign+2 @03c7ea>    : 19                         load.z64
	<sign+3 @03c7eb>    : 87                         ceq.f64
	<sign+4 @03c7ec>    : 06 08 00 00                jz <sign+12 @03c7f4>
	lib/std/math.ci:82: (4 bytes: <@03c7f0> - <@03c7f4>): return int32(.result := 0);
	<sign+8 @03c7f0>    : 18                         load.z32
	<sign+9 @03c7f1>    : 15 04                      set.x1 sp(4)
	<sign+11 @03c7f3>   : 03                         ret
	lib/std/math.ci:84: (16 bytes: <@03c7f4> - <@03c804>): if (bool(x < (0)))
	<sign+12 @03c7f4>   : 13 01                      dup.x2 sp(1)
	<sign+14 @03c7f6>   : 19                         load.z64
	<sign+15 @03c7f7>   : 88                         clt.f64
	<sign+16 @03c7f8>   : 06 0c 00 00                jz <sign+28 @03c804>
	lib/std/math.ci:85: (8 bytes: <@03c7fc> - <@03c804>): return int32(.result := int32(-1));
	<sign+20 @03c7fc>   : 1b ff ff ff ff             load.c32 -1
	<sign+25 @03c801>   : 15 04                      set.x1 sp(4)
	<sign+27 @03c803>   : 03                         ret
	lib/std/math.ci:87: (8 bytes: <@03c804> - <@03c80c>): return int32(.result := 1);
	<sign+28 @03c804>   : 1b 01 00 00 00             load.c32 1
	<sign+33 @03c809>   : 15 04                      set.x1 sp(4)
	<sign+35 @03c80b>   : 03                         ret
.references:
	lib/std/math.ci:80: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c810>
.name: 'abs'
.file: 'lib/std/math.ci:90'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (19 bytes: <@03c810> - <@03c823>)
	lib/std/math.ci:91: (14 bytes: <@03c810> - <@03c81e>): if (bool(x < (0)))
	<abs @03c810>      : 12 01                      dup.x1 sp(1)
	<abs+2 @03c812>    : 18                         load.z32
	<abs+3 @03c813>    : 78                         clt.f32
	<abs+4 @03c814>    : 06 0a 00 00                jz <abs+14 @03c81e>
	lib/std/math.ci:92: (6 bytes: <@03c818> - <@03c81e>): return float32(.result := float32(-x));
	<abs+8 @03c818>    : 12 01                      dup.x1 sp(1)
	<abs+10 @03c81a>   : 70                         neg.f32
	<abs+11 @03c81b>   : 15 03                      set.x1 sp(3)
	<abs+13 @03c81d>   : 03                         ret
	lib/std/math.ci:94: (5 bytes: <@03c81e> - <@03c823>): return float32(.result := x);
	<abs+14 @03c81e>   : 12 01                      dup.x1 sp(1)
	<abs+16 @03c820>   : 15 03                      set.x1 sp(3)
	<abs+18 @03c822>   : 03                         ret
.references:
	lib/std/math.ci:90: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c828>
.name: 'abs'
.file: 'lib/std/math.ci:96'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (19 bytes: <@03c828> - <@03c83b>)
	lib/std/math.ci:97: (14 bytes: <@03c828> - <@03c836>): if (bool(x < (0)))
	<abs @03c828>      : 13 01                      dup.x2 sp(1)
	<abs+2 @03c82a>    : 19                         load.z64
	<abs+3 @03c82b>    : 88                         clt.f64
	<abs+4 @03c82c>    : 06 0a 00 00                jz <abs+14 @03c836>
	lib/std/math.ci:98: (6 bytes: <@03c830> - <@03c836>): return float64(.result := float64(-x));
	<abs+8 @03c830>    : 13 01                      dup.x2 sp(1)
	<abs+10 @03c832>   : 80                         neg.f64
	<abs+11 @03c833>   : 16 05                      set.x2 sp(5)
	<abs+13 @03c835>   : 03                         ret
	lib/std/math.ci:100: (5 bytes: <@03c836> - <@03c83b>): return float64(.result := x);
	<abs+14 @03c836>   : 13 01                      dup.x2 sp(1)
	<abs+16 @03c838>   : 16 05                      set.x2 sp(5)
	<abs+18 @03c83a>   : 03                         ret
.references:
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.Complex.ci:70: referenced as `abs`
	lib/std/math.ci:320: referenced as `abs`
	lib/std/math.ci:96: defined as `abs(x: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c840>
.name: 'min'
.file: 'lib/std/math.ci:103'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (19 bytes: <@03c840> - <@03c853>)
	lib/std/math.ci:104: (14 bytes: <@03c840> - <@03c84e>): if (bool(a < b))
	<min @03c840>      : 12 02                      dup.x1 sp(2)
	<min+2 @03c842>    : 12 02                      dup.x1 sp(2)
	<min+4 @03c844>    : 78                         clt.f32
	<min+5 @03c845>    : 06 09 00 00                jz <min+14 @03c84e>
	lib/std/math.ci:105: (5 bytes: <@03c849> - <@03c84e>): return float32(.result := a);
	<min+9 @03c849>    : 12 02                      dup.x1 sp(2)
	<min+11 @03c84b>   : 15 04                      set.x1 sp(4)
	<min+13 @03c84d>   : 03                         ret
	lib/std/math.ci:107: (5 bytes: <@03c84e> - <@03c853>): return float32(.result := b);
	<min+14 @03c84e>   : 12 01                      dup.x1 sp(1)
	<min+16 @03c850>   : 15 04                      set.x1 sp(4)
	<min+18 @03c852>   : 03                         ret
.references:
	lib/std/math.ci:103: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c858>
.name: 'min'
.file: 'lib/std/math.ci:109'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (19 bytes: <@03c858> - <@03c86b>)
	lib/std/math.ci:110: (14 bytes: <@03c858> - <@03c866>): if (bool(a < b))
	<min @03c858>      : 13 03                      dup.x2 sp(3)
	<min+2 @03c85a>    : 13 03                      dup.x2 sp(3)
	<min+4 @03c85c>    : 88                         clt.f64
	<min+5 @03c85d>    : 06 09 00 00                jz <min+14 @03c866>
	lib/std/math.ci:111: (5 bytes: <@03c861> - <@03c866>): return float64(.result := a);
	<min+9 @03c861>    : 13 03                      dup.x2 sp(3)
	<min+11 @03c863>   : 16 07                      set.x2 sp(7)
	<min+13 @03c865>   : 03                         ret
	lib/std/math.ci:113: (5 bytes: <@03c866> - <@03c86b>): return float64(.result := b);
	<min+14 @03c866>   : 13 01                      dup.x2 sp(1)
	<min+16 @03c868>   : 16 07                      set.x2 sp(7)
	<min+18 @03c86a>   : 03                         ret
.references:
	lib/std/math.ci:109: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c870>
.name: 'max'
.file: 'lib/std/math.ci:116'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (19 bytes: <@03c870> - <@03c883>)
	lib/std/math.ci:117: (14 bytes: <@03c870> - <@03c87e>): if (bool(a > b))
	<max @03c870>      : 12 02                      dup.x1 sp(2)
	<max+2 @03c872>    : 12 02                      dup.x1 sp(2)
	<max+4 @03c874>    : 79                         cgt.f32
	<max+5 @03c875>    : 06 09 00 00                jz <max+14 @03c87e>
	lib/std/math.ci:118: (5 bytes: <@03c879> - <@03c87e>): return float32(.result := a);
	<max+9 @03c879>    : 12 02                      dup.x1 sp(2)
	<max+11 @03c87b>   : 15 04                      set.x1 sp(4)
	<max+13 @03c87d>   : 03                         ret
	lib/std/math.ci:120: (5 bytes: <@03c87e> - <@03c883>): return float32(.result := b);
	<max+14 @03c87e>   : 12 01                      dup.x1 sp(1)
	<max+16 @03c880>   : 15 04                      set.x1 sp(4)
	<max+18 @03c882>   : 03                         ret
.references:
	lib/std/math.ci:116: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.offset: <@03c888>
.name: 'max'
.file: 'lib/std/math.ci:122'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (19 bytes: <@03c888> - <@03c89b>)
	lib/std/math.ci:123: (14 bytes: <@03c888> - <@03c896>): if (bool(a > b))
	<max @03c888>      : 13 03                      dup.x2 sp(3)
	<max+2 @03c88a>    : 13 03                      dup.x2 sp(3)
	<max+4 @03c88c>    : 89                         cgt.f64
	<max+5 @03c88d>    : 06 09 00 00                jz <max+14 @03c896>
	lib/std/math.ci:124: (5 bytes: <@03c891> - <@03c896>): return float64(.result := a);
	<max+9 @03c891>    : 13 03                      dup.x2 sp(3)
	<max+11 @03c893>   : 16 07                      set.x2 sp(7)
	<max+13 @03c895>   : 03                         ret
	lib/std/math.ci:126: (5 bytes: <@03c896> - <@03c89b>): return float64(.result := b);
	<max+14 @03c896>   : 13 01                      dup.x2 sp(1)
	<max+16 @03c898>   : 16 07                      set.x2 sp(7)
	<max+18 @03c89a>   : 03                         ret
.references:
	lib/std/math.ci:122: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 33
.offset: <@03c8a0>
.name: 'clamp'
.file: 'lib/std/math.ci:129'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (33 bytes: <@03c8a0> - <@03c8c1>)
	lib/std/math.ci:130: (14 bytes: <@03c8a0> - <@03c8ae>): if (bool(t < a))
	<clamp @03c8a0>      : 12 03                      dup.x1 sp(3)
	<clamp+2 @03c8a2>    : 12 03                      dup.x1 sp(3)
	<clamp+4 @03c8a4>    : 78                         clt.f32
	<clamp+5 @03c8a5>    : 06 09 00 00                jz <clamp+14 @03c8ae>
	lib/std/math.ci:131: (5 bytes: <@03c8a9> - <@03c8ae>): return float32(.result := a);
	<clamp+9 @03c8a9>    : 12 02                      dup.x1 sp(2)
	<clamp+11 @03c8ab>   : 15 05                      set.x1 sp(5)
	<clamp+13 @03c8ad>   : 03                         ret
	lib/std/math.ci:133: (14 bytes: <@03c8ae> - <@03c8bc>): if (bool(t > b))
	<clamp+14 @03c8ae>   : 12 03                      dup.x1 sp(3)
	<clamp+16 @03c8b0>   : 12 02                      dup.x1 sp(2)
	<clamp+18 @03c8b2>   : 79                         cgt.f32
	<clamp+19 @03c8b3>   : 06 09 00 00                jz <clamp+28 @03c8bc>
	lib/std/math.ci:134: (5 bytes: <@03c8b7> - <@03c8bc>): return float32(.result := b);
	<clamp+23 @03c8b7>   : 12 01                      dup.x1 sp(1)
	<clamp+25 @03c8b9>   : 15 05                      set.x1 sp(5)
	<clamp+27 @03c8bb>   : 03                         ret
	lib/std/math.ci:136: (5 bytes: <@03c8bc> - <@03c8c1>): return float32(.result := t);
	<clamp+28 @03c8bc>   : 12 03                      dup.x1 sp(3)
	<clamp+30 @03c8be>   : 15 05                      set.x1 sp(5)
	<clamp+32 @03c8c0>   : 03                         ret
.references:
	lib/std/math.ci:156: referenced as `clamp`
	lib/std/math.ci:129: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 33
.offset: <@03c8c8>
.name: 'clamp'
.file: 'lib/std/math.ci:138'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (33 bytes: <@03c8c8> - <@03c8e9>)
	lib/std/math.ci:139: (14 bytes: <@03c8c8> - <@03c8d6>): if (bool(t < a))
	<clamp @03c8c8>      : 13 05                      dup.x2 sp(5)
	<clamp+2 @03c8ca>    : 13 05                      dup.x2 sp(5)
	<clamp+4 @03c8cc>    : 88                         clt.f64
	<clamp+5 @03c8cd>    : 06 09 00 00                jz <clamp+14 @03c8d6>
	lib/std/math.ci:140: (5 bytes: <@03c8d1> - <@03c8d6>): return float64(.result := a);
	<clamp+9 @03c8d1>    : 13 03                      dup.x2 sp(3)
	<clamp+11 @03c8d3>   : 16 09                      set.x2 sp(9)
	<clamp+13 @03c8d5>   : 03                         ret
	lib/std/math.ci:142: (14 bytes: <@03c8d6> - <@03c8e4>): if (bool(t > b))
	<clamp+14 @03c8d6>   : 13 05                      dup.x2 sp(5)
	<clamp+16 @03c8d8>   : 13 03                      dup.x2 sp(3)
	<clamp+18 @03c8da>   : 89                         cgt.f64
	<clamp+19 @03c8db>   : 06 09 00 00                jz <clamp+28 @03c8e4>
	lib/std/math.ci:143: (5 bytes: <@03c8df> - <@03c8e4>): return float64(.result := b);
	<clamp+23 @03c8df>   : 13 01                      dup.x2 sp(1)
	<clamp+25 @03c8e1>   : 16 09                      set.x2 sp(9)
	<clamp+27 @03c8e3>   : 03                         ret
	lib/std/math.ci:145: (5 bytes: <@03c8e4> - <@03c8e9>): return float64(.result := t);
	<clamp+28 @03c8e4>   : 13 05                      dup.x2 sp(5)
	<clamp+30 @03c8e6>   : 16 09                      set.x2 sp(9)
	<clamp+32 @03c8e8>   : 03                         ret
.references:
	lib/std/math.ci:160: referenced as `clamp`
	lib/std/math.ci:138: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03c8f0>
.name: 'lerp'
.file: 'lib/std/math.ci:148'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	return float32(.result := float32(a + float32(t * (float32(b - a)))));
}
.instructions: (14 bytes: <@03c8f0> - <@03c8fe>)
	lib/std/math.ci:149: (14 bytes: <@03c8f0> - <@03c8fe>): return float32(.result := float32(a + float32(t * (float32(b - a)))));
	<lerp @03c8f0>      : 12 02                      dup.x1 sp(2)
	<lerp+2 @03c8f2>    : 12 04                      dup.x1 sp(4)
	<lerp+4 @03c8f4>    : 12 03                      dup.x1 sp(3)
	<lerp+6 @03c8f6>    : 12 05                      dup.x1 sp(5)
	<lerp+8 @03c8f8>    : 72                         sub.f32
	<lerp+9 @03c8f9>    : 73                         mul.f32
	<lerp+10 @03c8fa>   : 71                         add.f32
	<lerp+11 @03c8fb>   : 15 05                      set.x1 sp(5)
	<lerp+13 @03c8fd>   : 03                         ret
.references:
	lib/std/math.ci:148: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03c900>
.name: 'lerp'
.file: 'lib/std/math.ci:151'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return float64(.result := float64(a + float64(t * (float64(b - a)))));
}
.instructions: (14 bytes: <@03c900> - <@03c90e>)
	lib/std/math.ci:152: (14 bytes: <@03c900> - <@03c90e>): return float64(.result := float64(a + float64(t * (float64(b - a)))));
	<lerp @03c900>      : 13 03                      dup.x2 sp(3)
	<lerp+2 @03c902>    : 13 07                      dup.x2 sp(7)
	<lerp+4 @03c904>    : 13 05                      dup.x2 sp(5)
	<lerp+6 @03c906>    : 13 09                      dup.x2 sp(9)
	<lerp+8 @03c908>    : 82                         sub.f64
	<lerp+9 @03c909>    : 83                         mul.f64
	<lerp+10 @03c90a>   : 81                         add.f64
	<lerp+11 @03c90b>   : 16 09                      set.x2 sp(9)
	<lerp+13 @03c90d>   : 03                         ret
.references:
	lib/std/math.ci:151: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 53
.offset: <@03c910>
.name: 'smooth'
.file: 'lib/std/math.ci:155'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
	return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
}
.instructions: (53 bytes: <@03c910> - <@03c945>)
	lib/std/math.ci:156: (30 bytes: <@03c910> - <@03c92e>): float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
	<smooth @03c910>      : 18                         load.z32
	<smooth+1 @03c911>    : 12 04                      dup.x1 sp(4)
	<smooth+3 @03c913>    : 12 04                      dup.x1 sp(4)
	<smooth+5 @03c915>    : 72                         sub.f32
	<smooth+6 @03c916>    : 12 03                      dup.x1 sp(3)
	<smooth+8 @03c918>    : 12 05                      dup.x1 sp(5)
	<smooth+10 @03c91a>   : 72                         sub.f32
	<smooth+11 @03c91b>   : 74                         div.f32
	<smooth+12 @03c91c>   : 18                         load.z32
	<smooth+13 @03c91d>   : 1d 00 00 80 3f             load.f32 1.000000
	<smooth+18 @03c922>   : 1f a0 c8 03 00             load.ref <@03c8a0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<smooth+23 @03c927>   : 02                         call
	<smooth+24 @03c928>   : 10 f4 ff ff                inc.sp(-12)
	<smooth+28 @03c92c>   : 15 04                      set.x1 sp(4)
	lib/std/math.ci:157: (23 bytes: <@03c92e> - <@03c945>): return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
	<smooth+30 @03c92e>   : 12 03                      dup.x1 sp(3)
	<smooth+32 @03c930>   : 12 04                      dup.x1 sp(4)
	<smooth+34 @03c932>   : 73                         mul.f32
	<smooth+35 @03c933>   : 1d 00 00 40 40             load.f32 3.000000
	<smooth+40 @03c938>   : 1d 00 00 00 40             load.f32 2.000000
	<smooth+45 @03c93d>   : 12 06                      dup.x1 sp(6)
	<smooth+47 @03c93f>   : 73                         mul.f32
	<smooth+48 @03c940>   : 72                         sub.f32
	<smooth+49 @03c941>   : 73                         mul.f32
	<smooth+50 @03c942>   : 15 05                      set.x1 sp(5)
	<smooth+52 @03c944>   : 03                         ret
.references:
	lib/std/math.ci:155: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 65
.offset: <@03c948>
.name: 'smooth'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
	return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
}
.instructions: (65 bytes: <@03c948> - <@03c989>)
	lib/std/math.ci:160: (34 bytes: <@03c948> - <@03c96a>): float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
	<smooth @03c948>      : 19                         load.z64
	<smooth+1 @03c949>    : 13 07                      dup.x2 sp(7)
	<smooth+3 @03c94b>    : 13 07                      dup.x2 sp(7)
	<smooth+5 @03c94d>    : 82                         sub.f64
	<smooth+6 @03c94e>    : 13 05                      dup.x2 sp(5)
	<smooth+8 @03c950>    : 13 09                      dup.x2 sp(9)
	<smooth+10 @03c952>   : 82                         sub.f64
	<smooth+11 @03c953>   : 84                         div.f64
	<smooth+12 @03c954>   : 19                         load.z64
	<smooth+13 @03c955>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<smooth+22 @03c95e>   : 1f c8 c8 03 00             load.ref <@03c8c8> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<smooth+27 @03c963>   : 02                         call
	<smooth+28 @03c964>   : 10 e8 ff ff                inc.sp(-24)
	<smooth+32 @03c968>   : 16 07                      set.x2 sp(7)
	lib/std/math.ci:161: (31 bytes: <@03c96a> - <@03c989>): return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
	<smooth+34 @03c96a>   : 13 05                      dup.x2 sp(5)
	<smooth+36 @03c96c>   : 13 07                      dup.x2 sp(7)
	<smooth+38 @03c96e>   : 83                         mul.f64
	<smooth+39 @03c96f>   : 1e 00 00 00 00 00 00 08 40 load.f64 3.000000
	<smooth+48 @03c978>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<smooth+57 @03c981>   : 13 0b                      dup.x2 sp(11)
	<smooth+59 @03c983>   : 83                         mul.f64
	<smooth+60 @03c984>   : 82                         sub.f64
	<smooth+61 @03c985>   : 83                         mul.f64
	<smooth+62 @03c986>   : 16 09                      set.x2 sp(9)
	<smooth+64 @03c988>   : 03                         ret
.references:
	lib/std/math.ci:159: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:184'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.references:
	lib/std/math.ci:184: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:185'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.references:
	lib/std/math.ci:185: defined as `smooth(t: float64): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@03c990>
.name: 'cmp'
.file: 'lib/std/math.ci:239'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@03c990> - <@03c9c9>)
	lib/std/math.ci:240: (53 bytes: <@03c990> - <@03c9c5>): if (bool(a < b))
	<cmp @03c990>      : 12 03                      dup.x1 sp(3)
	<cmp+2 @03c992>    : 12 03                      dup.x1 sp(3)
	<cmp+4 @03c994>    : 78                         clt.f32
	<cmp+5 @03c995>    : 06 1c 00 00                jz <cmp+33 @03c9b1>
	lib/std/math.ci:241: (20 bytes: <@03c999> - <@03c9ad>): if (bool(eps < (float32(b - a))))
	<cmp+9 @03c999>    : 12 01                      dup.x1 sp(1)
	<cmp+11 @03c99b>   : 12 03                      dup.x1 sp(3)
	<cmp+13 @03c99d>   : 12 05                      dup.x1 sp(5)
	<cmp+15 @03c99f>   : 72                         sub.f32
	<cmp+16 @03c9a0>   : 78                         clt.f32
	<cmp+17 @03c9a1>   : 06 0c 00 00                jz <cmp+29 @03c9ad>
	lib/std/math.ci:242: (8 bytes: <@03c9a5> - <@03c9ad>): return int32(.result := int32(-1));
	<cmp+21 @03c9a5>   : 1b ff ff ff ff             load.c32 -1
	<cmp+26 @03c9aa>   : 15 05                      set.x1 sp(5)
	<cmp+28 @03c9ac>   : 03                         ret
	<cmp+29 @03c9ad>   : 04 18 00 00                jmp <cmp+53 @03c9c5>
	lib/std/math.ci:246: (20 bytes: <@03c9b1> - <@03c9c5>): if (bool(eps < (float32(a - b))))
	<cmp+33 @03c9b1>   : 12 01                      dup.x1 sp(1)
	<cmp+35 @03c9b3>   : 12 04                      dup.x1 sp(4)
	<cmp+37 @03c9b5>   : 12 04                      dup.x1 sp(4)
	<cmp+39 @03c9b7>   : 72                         sub.f32
	<cmp+40 @03c9b8>   : 78                         clt.f32
	<cmp+41 @03c9b9>   : 06 0c 00 00                jz <cmp+53 @03c9c5>
	lib/std/math.ci:247: (8 bytes: <@03c9bd> - <@03c9c5>): return int32(.result := int32(+1));
	<cmp+45 @03c9bd>   : 1b 01 00 00 00             load.c32 1
	<cmp+50 @03c9c2>   : 15 05                      set.x1 sp(5)
	<cmp+52 @03c9c4>   : 03                         ret
	lib/std/math.ci:250: (4 bytes: <@03c9c5> - <@03c9c9>): return int32(.result := 0);
	<cmp+53 @03c9c5>   : 18                         load.z32
	<cmp+54 @03c9c6>   : 15 05                      set.x1 sp(5)
	<cmp+56 @03c9c8>   : 03                         ret
.references:
	lib/std/math.ci:239: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@03c9d0>
.name: 'cmp'
.file: 'lib/std/math.ci:252'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@03c9d0> - <@03ca09>)
	lib/std/math.ci:253: (53 bytes: <@03c9d0> - <@03ca05>): if (bool(a < b))
	<cmp @03c9d0>      : 13 05                      dup.x2 sp(5)
	<cmp+2 @03c9d2>    : 13 05                      dup.x2 sp(5)
	<cmp+4 @03c9d4>    : 88                         clt.f64
	<cmp+5 @03c9d5>    : 06 1c 00 00                jz <cmp+33 @03c9f1>
	lib/std/math.ci:254: (20 bytes: <@03c9d9> - <@03c9ed>): if (bool(eps < (float64(b - a))))
	<cmp+9 @03c9d9>    : 13 01                      dup.x2 sp(1)
	<cmp+11 @03c9db>   : 13 05                      dup.x2 sp(5)
	<cmp+13 @03c9dd>   : 13 09                      dup.x2 sp(9)
	<cmp+15 @03c9df>   : 82                         sub.f64
	<cmp+16 @03c9e0>   : 88                         clt.f64
	<cmp+17 @03c9e1>   : 06 0c 00 00                jz <cmp+29 @03c9ed>
	lib/std/math.ci:255: (8 bytes: <@03c9e5> - <@03c9ed>): return int32(.result := int32(-1));
	<cmp+21 @03c9e5>   : 1b ff ff ff ff             load.c32 -1
	<cmp+26 @03c9ea>   : 15 08                      set.x1 sp(8)
	<cmp+28 @03c9ec>   : 03                         ret
	<cmp+29 @03c9ed>   : 04 18 00 00                jmp <cmp+53 @03ca05>
	lib/std/math.ci:259: (20 bytes: <@03c9f1> - <@03ca05>): if (bool(eps < (float64(a - b))))
	<cmp+33 @03c9f1>   : 13 01                      dup.x2 sp(1)
	<cmp+35 @03c9f3>   : 13 07                      dup.x2 sp(7)
	<cmp+37 @03c9f5>   : 13 07                      dup.x2 sp(7)
	<cmp+39 @03c9f7>   : 82                         sub.f64
	<cmp+40 @03c9f8>   : 88                         clt.f64
	<cmp+41 @03c9f9>   : 06 0c 00 00                jz <cmp+53 @03ca05>
	lib/std/math.ci:260: (8 bytes: <@03c9fd> - <@03ca05>): return int32(.result := int32(+1));
	<cmp+45 @03c9fd>   : 1b 01 00 00 00             load.c32 1
	<cmp+50 @03ca02>   : 15 08                      set.x1 sp(8)
	<cmp+52 @03ca04>   : 03                         ret
	lib/std/math.ci:263: (4 bytes: <@03ca05> - <@03ca09>): return int32(.result := 0);
	<cmp+53 @03ca05>   : 18                         load.z32
	<cmp+54 @03ca06>   : 15 08                      set.x1 sp(8)
	<cmp+56 @03ca08>   : 03                         ret
.references:
	lib/std/math.ci:252: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 348
.offset: <@03ca10>
.name: 'sinCos'
.file: 'lib/std/math.ci:266'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (348 bytes: <@03ca10> - <@03cb6c>)
	lib/std/math.ci:280: (2 bytes: <@03ca10> - <@03ca12>): x: float64 := arg
	<sinCos @03ca10>      : 13 02                      dup.x2 sp(2)
	lib/std/math.ci:281: (21 bytes: <@03ca12> - <@03ca27>): if (bool(x < (0)))
	<sinCos+2 @03ca12>    : 13 00                      dup.x2 sp(0)
	<sinCos+4 @03ca14>    : 19                         load.z64
	<sinCos+5 @03ca15>    : 88                         clt.f64
	<sinCos+6 @03ca16>    : 06 11 00 00                jz <sinCos+23 @03ca27>
	lib/std/math.ci:282: (5 bytes: <@03ca1a> - <@03ca1f>): float64(x := float64(-x));
	<sinCos+10 @03ca1a>   : 13 00                      dup.x2 sp(0)
	<sinCos+12 @03ca1c>   : 80                         neg.f64
	<sinCos+13 @03ca1d>   : 16 02                      set.x2 sp(2)
	lib/std/math.ci:283: (8 bytes: <@03ca1f> - <@03ca27>): int32(quad := int32(quad + 2));
	<sinCos+15 @03ca1f>   : 12 03                      dup.x1 sp(3)
	<sinCos+17 @03ca21>   : 0b 02 00 00                inc.i32(+2)
	<sinCos+21 @03ca25>   : 15 04                      set.x1 sp(4)
	lib/std/math.ci:286: (1 byte: <@03ca27> - <@03ca28>): y: float64
	<sinCos+23 @03ca27>   : 19                         load.z64
	lib/std/math.ci:287: (24 bytes: <@03ca28> - <@03ca40>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+24 @03ca28>   : 13 02                      dup.x2 sp(2)
	<sinCos+26 @03ca2a>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+35 @03ca33>   : 1e 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+44 @03ca3c>   : 84                         div.f64
	<sinCos+45 @03ca3d>   : 83                         mul.f64
	<sinCos+46 @03ca3e>   : 16 04                      set.x2 sp(4)
	lib/std/math.ci:288: (124 bytes: <@03ca40> - <@03cabc>): if (bool(x > (32764)))
	<sinCos+48 @03ca40>   : 13 02                      dup.x2 sp(2)
	<sinCos+50 @03ca42>   : 1e 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+59 @03ca4b>   : 89                         cgt.f64
	<sinCos+60 @03ca4c>   : 06 54 00 00                jz <sinCos+144 @03caa0>
	lib/std/math.ci:289: (1 byte: <@03ca50> - <@03ca51>): e: float64
	<sinCos+64 @03ca50>   : 1a                         load.z128
	lib/std/math.ci:290: (18 bytes: <@03ca51> - <@03ca63>): float64(y := modf(void(x, e)));
	<sinCos+65 @03ca51>   : 13 06                      dup.x2 sp(6)
	<sinCos+67 @03ca53>   : 11 10 00 00                load.sp(+16)
	<sinCos+71 @03ca57>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+76 @03ca5c>   : 02                         call
	<sinCos+77 @03ca5d>   : 10 f4 ff ff                inc.sp(-12)
	<sinCos+81 @03ca61>   : 16 04                      set.x2 sp(4)
	lib/std/math.ci:291: (4 bytes: <@03ca63> - <@03ca67>): float64(e := float64(e + (quad)));
	<sinCos+83 @03ca63>   : 12 07                      dup.x1 sp(7)
	<sinCos+85 @03ca65>   : 5d                         i32.2f64
	<sinCos+86 @03ca66>   : 81                         add.f64
	lib/std/math.ci:293: (1 byte: <@03ca67> - <@03ca68>): f: float64
	<sinCos+87 @03ca67>   : 1a                         load.z128
	lib/std/math.ci:294: (30 bytes: <@03ca68> - <@03ca86>): modf(void(float64(0.250000 * e), f));
	<sinCos+88 @03ca68>   : 1e 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+97 @03ca71>   : 13 06                      dup.x2 sp(6)
	<sinCos+99 @03ca73>   : 83                         mul.f64
	<sinCos+100 @03ca74>  : 11 10 00 00                load.sp(+16)
	<sinCos+104 @03ca78>  : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+109 @03ca7d>  : 02                         call
	<sinCos+110 @03ca7e>  : 10 f4 ff ff                inc.sp(-12)
	<sinCos+114 @03ca82>  : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:295: (18 bytes: <@03ca86> - <@03ca98>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+118 @03ca86>  : 13 02                      dup.x2 sp(2)
	<sinCos+120 @03ca88>  : 1e 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+129 @03ca91>  : 13 04                      dup.x2 sp(4)
	<sinCos+131 @03ca93>  : 83                         mul.f64
	<sinCos+132 @03ca94>  : 82                         sub.f64
	<sinCos+133 @03ca95>  : 8a                         f64.2i32
	<sinCos+134 @03ca96>  : 15 0a                      set.x1 sp(10)
	<sinCos+136 @03ca98>  : 10 f0 ff ff                inc.sp(-16)
	<sinCos+140 @03ca9c>  : 04 20 00 00                jmp <sinCos+172 @03cabc>
	lib/std/math.ci:298: (3 bytes: <@03caa0> - <@03caa3>): k: int32 := x
	<sinCos+144 @03caa0>  : 13 02                      dup.x2 sp(2)
	<sinCos+146 @03caa2>  : 8a                         f64.2i32
	lib/std/math.ci:299: (8 bytes: <@03caa3> - <@03caab>): float64(y := float64(x - (k)));
	<sinCos+147 @03caa3>  : 13 03                      dup.x2 sp(3)
	<sinCos+149 @03caa5>  : 12 02                      dup.x1 sp(2)
	<sinCos+151 @03caa7>  : 5d                         i32.2f64
	<sinCos+152 @03caa8>  : 82                         sub.f64
	<sinCos+153 @03caa9>  : 16 03                      set.x2 sp(3)
	lib/std/math.ci:300: (7 bytes: <@03caab> - <@03cab2>): int32(quad := int32(quad + k));
	<sinCos+155 @03caab>  : 12 06                      dup.x1 sp(6)
	<sinCos+157 @03caad>  : 12 01                      dup.x1 sp(1)
	<sinCos+159 @03caaf>  : 51                         add.i32
	<sinCos+160 @03cab0>  : 15 07                      set.x1 sp(7)
	lib/std/math.ci:301: (6 bytes: <@03cab2> - <@03cab8>): int32(quad := int32(quad & 3));
	<sinCos+162 @03cab2>  : 12 06                      dup.x1 sp(6)
	<sinCos+164 @03cab4>  : 3f 02                      b32.and 0x003
	<sinCos+166 @03cab6>  : 15 07                      set.x1 sp(7)
	<sinCos+168 @03cab8>  : 10 fc ff ff                inc.sp(-4)
	lib/std/math.ci:303: (22 bytes: <@03cabc> - <@03cad2>): if (int32(quad & 1))
	<sinCos+172 @03cabc>  : 12 05                      dup.x1 sp(5)
	<sinCos+174 @03cabe>  : 3f 01                      b32.and 0x001
	<sinCos+176 @03cac0>  : 06 12 00 00                jz <sinCos+194 @03cad2>
	lib/std/math.ci:304: (14 bytes: <@03cac4> - <@03cad2>): float64(y := float64((1) - y));
	<sinCos+180 @03cac4>  : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+189 @03cacd>  : 13 02                      dup.x2 sp(2)
	<sinCos+191 @03cacf>  : 82                         sub.f64
	<sinCos+192 @03cad0>  : 16 02                      set.x2 sp(2)
	lib/std/math.ci:306: (17 bytes: <@03cad2> - <@03cae3>): if (bool(quad > 1))
	<sinCos+194 @03cad2>  : 12 05                      dup.x1 sp(5)
	<sinCos+196 @03cad4>  : 1b 01 00 00 00             load.c32 1
	<sinCos+201 @03cad9>  : 59                         cgt.i32
	<sinCos+202 @03cada>  : 06 09 00 00                jz <sinCos+211 @03cae3>
	lib/std/math.ci:307: (5 bytes: <@03cade> - <@03cae3>): float64(y := float64(-y));
	<sinCos+206 @03cade>  : 13 00                      dup.x2 sp(0)
	<sinCos+208 @03cae0>  : 80                         neg.f64
	<sinCos+209 @03cae1>  : 16 02                      set.x2 sp(2)
	lib/std/math.ci:310: (5 bytes: <@03cae3> - <@03cae8>): ysq: float64 := float64(y * y)
	<sinCos+211 @03cae3>  : 13 00                      dup.x2 sp(0)
	<sinCos+213 @03cae5>  : 13 02                      dup.x2 sp(2)
	<sinCos+215 @03cae7>  : 83                         mul.f64
	lib/std/math.ci:311: (64 bytes: <@03cae8> - <@03cb28>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+216 @03cae8>  : 1e 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+225 @03caf1>  : 13 02                      dup.x2 sp(2)
	<sinCos+227 @03caf3>  : 83                         mul.f64
	<sinCos+228 @03caf4>  : 1e 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+237 @03cafd>  : 81                         add.f64
	<sinCos+238 @03cafe>  : 13 02                      dup.x2 sp(2)
	<sinCos+240 @03cb00>  : 83                         mul.f64
	<sinCos+241 @03cb01>  : 1e 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+250 @03cb0a>  : 81                         add.f64
	<sinCos+251 @03cb0b>  : 13 02                      dup.x2 sp(2)
	<sinCos+253 @03cb0d>  : 83                         mul.f64
	<sinCos+254 @03cb0e>  : 1e 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+263 @03cb17>  : 81                         add.f64
	<sinCos+264 @03cb18>  : 13 02                      dup.x2 sp(2)
	<sinCos+266 @03cb1a>  : 83                         mul.f64
	<sinCos+267 @03cb1b>  : 1e 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+276 @03cb24>  : 81                         add.f64
	<sinCos+277 @03cb25>  : 13 04                      dup.x2 sp(4)
	<sinCos+279 @03cb27>  : 83                         mul.f64
	lib/std/math.ci:312: (51 bytes: <@03cb28> - <@03cb5b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+280 @03cb28>  : 13 02                      dup.x2 sp(2)
	<sinCos+282 @03cb2a>  : 1e 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+291 @03cb33>  : 81                         add.f64
	<sinCos+292 @03cb34>  : 13 04                      dup.x2 sp(4)
	<sinCos+294 @03cb36>  : 83                         mul.f64
	<sinCos+295 @03cb37>  : 1e da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+304 @03cb40>  : 81                         add.f64
	<sinCos+305 @03cb41>  : 13 04                      dup.x2 sp(4)
	<sinCos+307 @03cb43>  : 83                         mul.f64
	<sinCos+308 @03cb44>  : 1e 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+317 @03cb4d>  : 81                         add.f64
	<sinCos+318 @03cb4e>  : 13 04                      dup.x2 sp(4)
	<sinCos+320 @03cb50>  : 83                         mul.f64
	<sinCos+321 @03cb51>  : 1e cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+330 @03cb5a>  : 81                         add.f64
	lib/std/math.ci:313: (12 bytes: <@03cb5b> - <@03cb67>): return float64(.result := float64(temp1 / temp2));
	<sinCos+331 @03cb5b>  : 13 02                      dup.x2 sp(2)
	<sinCos+333 @03cb5d>  : 13 02                      dup.x2 sp(2)
	<sinCos+335 @03cb5f>  : 84                         div.f64
	<sinCos+336 @03cb60>  : 16 10                      set.x2 sp(16)
	<sinCos+338 @03cb62>  : 10 d8 ff ff                inc.sp(-40)
	<sinCos+342 @03cb66>  : 03                         ret
	<sinCos+343 @03cb67>  : 10 d8 ff ff                inc.sp(-40)
	<sinCos+347 @03cb6b>  : 03                         ret
.references:
	lib/std/math.ci:320: referenced as `sinCos`
	lib/std/math.ci:317: referenced as `sinCos`
	lib/std/math.ci:266: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:317'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(arg, 0))
.references:
	lib/std/math.ci:317: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:320'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.value: sinCos(void(abs(arg), 1))
.references:
	lib/std/math.ci:320: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@03cb70>
.name: 'tan'
.file: 'lib/std/math.ci:323'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@03cb70> - <@03ccea>)
	lib/std/math.ci:336: (1 byte: <@03cb70> - <@03cb71>): complement: bool := false
	<tan @03cb70>      : 18                         load.z32
	lib/std/math.ci:337: (1 byte: <@03cb71> - <@03cb72>): negate: bool := false
	<tan+1 @03cb71>    : 18                         load.z32
	lib/std/math.ci:339: (23 bytes: <@03cb72> - <@03cb89>): if (bool(arg < (0)))
	<tan+2 @03cb72>    : 13 03                      dup.x2 sp(3)
	<tan+4 @03cb74>    : 19                         load.z64
	<tan+5 @03cb75>    : 88                         clt.f64
	<tan+6 @03cb76>    : 06 13 00 00                jz <tan+25 @03cb89>
	lib/std/math.ci:340: (5 bytes: <@03cb7a> - <@03cb7f>): float64(arg := float64(-arg));
	<tan+10 @03cb7a>   : 13 03                      dup.x2 sp(3)
	<tan+12 @03cb7c>   : 80                         neg.f64
	<tan+13 @03cb7d>   : 16 05                      set.x2 sp(5)
	lib/std/math.ci:341: (10 bytes: <@03cb7f> - <@03cb89>): bool(negate := true);
	<tan+15 @03cb7f>   : 1b 01 00 00 00             load.c32 1
	<tan+20 @03cb84>   : 11 04 00 00                load.sp(+4)
	<tan+24 @03cb88>   : 25                         store.i8
	lib/std/math.ci:343: (24 bytes: <@03cb89> - <@03cba1>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @03cb89>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @03cb92>   : 13 05                      dup.x2 sp(5)
	<tan+36 @03cb94>   : 83                         mul.f64
	<tan+37 @03cb95>   : 1e 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @03cb9e>   : 84                         div.f64
	<tan+47 @03cb9f>   : 16 05                      set.x2 sp(5)
	lib/std/math.ci:345: (1 byte: <@03cba1> - <@03cba2>): e: float64
	<tan+49 @03cba1>   : 1a                         load.z128
	lib/std/math.ci:346: (16 bytes: <@03cba2> - <@03cbb2>): x: float64 := modf(void(arg, e))
	<tan+50 @03cba2>   : 13 07                      dup.x2 sp(7)
	<tan+52 @03cba4>   : 11 10 00 00                load.sp(+16)
	<tan+56 @03cba8>   : 1f 30 c7 03 00             load.ref <@03c730> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @03cbad>   : 02                         call
	<tan+62 @03cbae>   : 10 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:347: (9 bytes: <@03cbb2> - <@03cbbb>): i: int32 := int32(int32(e) % 4)
	<tan+66 @03cbb2>   : 13 02                      dup.x2 sp(2)
	<tan+68 @03cbb4>   : 8a                         f64.2i32
	<tan+69 @03cbb5>   : 1b 04 00 00 00             load.c32 4
	<tan+74 @03cbba>   : 55                         mod.i32
	lib/std/math.ci:349: (122 bytes: <@03cbbb> - <@03cc35>): if (bool(i == 0))
	<tan+75 @03cbbb>   : 12 00                      dup.x1 sp(0)
	<tan+77 @03cbbd>   : 18                         load.z32
	<tan+78 @03cbbe>   : 57                         ceq.i32
	<tan+79 @03cbbf>   : 05 76 00 00                jnz <tan+197 @03cc35>
	lib/std/math.ci:350: (114 bytes: <@03cbc3> - <@03cc35>): if (bool(i == 1))
	<tan+83 @03cbc3>   : 12 00                      dup.x1 sp(0)
	<tan+85 @03cbc5>   : 1b 01 00 00 00             load.c32 1
	<tan+90 @03cbca>   : 57                         ceq.i32
	<tan+91 @03cbcb>   : 06 20 00 00                jz <tan+123 @03cbeb>
	lib/std/math.ci:351: (14 bytes: <@03cbcf> - <@03cbdd>): float64(x := float64((1) - x));
	<tan+95 @03cbcf>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @03cbd8>  : 13 03                      dup.x2 sp(3)
	<tan+106 @03cbda>  : 82                         sub.f64
	<tan+107 @03cbdb>  : 16 03                      set.x2 sp(3)
	lib/std/math.ci:352: (10 bytes: <@03cbdd> - <@03cbe7>): bool(complement := true);
	<tan+109 @03cbdd>  : 1b 01 00 00 00             load.c32 1
	<tan+114 @03cbe2>  : 11 1c 00 00                load.sp(+28)
	<tan+118 @03cbe6>  : 25                         store.i8
	<tan+119 @03cbe7>  : 04 4e 00 00                jmp <tan+197 @03cc35>
	lib/std/math.ci:354: (74 bytes: <@03cbeb> - <@03cc35>): if (bool(i == 2))
	<tan+123 @03cbeb>  : 12 00                      dup.x1 sp(0)
	<tan+125 @03cbed>  : 1b 02 00 00 00             load.c32 2
	<tan+130 @03cbf2>  : 57                         ceq.i32
	<tan+131 @03cbf3>  : 06 1d 00 00                jz <tan+160 @03cc10>
	lib/std/math.ci:355: (11 bytes: <@03cbf7> - <@03cc02>): bool(negate := bool(!negate));
	<tan+135 @03cbf7>  : 11 14 00 00                load.sp(+20)
	<tan+139 @03cbfb>  : 20                         load.i8
	<tan+140 @03cbfc>  : 0a                         not.b32
	<tan+141 @03cbfd>  : 11 18 00 00                load.sp(+24)
	<tan+145 @03cc01>  : 25                         store.i8
	lib/std/math.ci:356: (10 bytes: <@03cc02> - <@03cc0c>): bool(complement := true);
	<tan+146 @03cc02>  : 1b 01 00 00 00             load.c32 1
	<tan+151 @03cc07>  : 11 1c 00 00                load.sp(+28)
	<tan+155 @03cc0b>  : 25                         store.i8
	<tan+156 @03cc0c>  : 04 29 00 00                jmp <tan+197 @03cc35>
	lib/std/math.ci:358: (37 bytes: <@03cc10> - <@03cc35>): if (bool(i == 3))
	<tan+160 @03cc10>  : 12 00                      dup.x1 sp(0)
	<tan+162 @03cc12>  : 1b 03 00 00 00             load.c32 3
	<tan+167 @03cc17>  : 57                         ceq.i32
	<tan+168 @03cc18>  : 06 1d 00 00                jz <tan+197 @03cc35>
	lib/std/math.ci:359: (14 bytes: <@03cc1c> - <@03cc2a>): float64(x := float64((1) - x));
	<tan+172 @03cc1c>  : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @03cc25>  : 13 03                      dup.x2 sp(3)
	<tan+183 @03cc27>  : 82                         sub.f64
	<tan+184 @03cc28>  : 16 03                      set.x2 sp(3)
	lib/std/math.ci:360: (11 bytes: <@03cc2a> - <@03cc35>): bool(negate := bool(!negate));
	<tan+186 @03cc2a>  : 11 14 00 00                load.sp(+20)
	<tan+190 @03cc2e>  : 20                         load.i8
	<tan+191 @03cc2f>  : 0a                         not.b32
	<tan+192 @03cc30>  : 11 18 00 00                load.sp(+24)
	<tan+196 @03cc34>  : 25                         store.i8
	lib/std/math.ci:363: (5 bytes: <@03cc35> - <@03cc3a>): xsq: float64 := float64(x * x)
	<tan+197 @03cc35>  : 13 01                      dup.x2 sp(1)
	<tan+199 @03cc37>  : 13 03                      dup.x2 sp(3)
	<tan+201 @03cc39>  : 83                         mul.f64
	lib/std/math.ci:364: (64 bytes: <@03cc3a> - <@03cc7a>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @03cc3a>  : 1e 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @03cc43>  : 13 02                      dup.x2 sp(2)
	<tan+213 @03cc45>  : 83                         mul.f64
	<tan+214 @03cc46>  : 1e 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @03cc4f>  : 81                         add.f64
	<tan+224 @03cc50>  : 13 02                      dup.x2 sp(2)
	<tan+226 @03cc52>  : 83                         mul.f64
	<tan+227 @03cc53>  : 1e 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @03cc5c>  : 81                         add.f64
	<tan+237 @03cc5d>  : 13 02                      dup.x2 sp(2)
	<tan+239 @03cc5f>  : 83                         mul.f64
	<tan+240 @03cc60>  : 1e 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @03cc69>  : 81                         add.f64
	<tan+250 @03cc6a>  : 13 02                      dup.x2 sp(2)
	<tan+252 @03cc6c>  : 83                         mul.f64
	<tan+253 @03cc6d>  : 1e 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @03cc76>  : 81                         add.f64
	<tan+263 @03cc77>  : 13 05                      dup.x2 sp(5)
	<tan+265 @03cc79>  : 83                         mul.f64
	lib/std/math.ci:365: (39 bytes: <@03cc7a> - <@03cca1>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @03cc7a>  : 13 02                      dup.x2 sp(2)
	<tan+268 @03cc7c>  : 1e 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @03cc85>  : 81                         add.f64
	<tan+278 @03cc86>  : 13 04                      dup.x2 sp(4)
	<tan+280 @03cc88>  : 83                         mul.f64
	<tan+281 @03cc89>  : 1e ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @03cc92>  : 81                         add.f64
	<tan+291 @03cc93>  : 13 04                      dup.x2 sp(4)
	<tan+293 @03cc95>  : 83                         mul.f64
	<tan+294 @03cc96>  : 1e f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @03cc9f>  : 81                         add.f64
	<tan+304 @03cca0>  : 84                         div.f64
	lib/std/math.ci:367: (40 bytes: <@03cca1> - <@03ccc9>): if (complement)
	<tan+305 @03cca1>  : 11 28 00 00                load.sp(+40)
	<tan+309 @03cca5>  : 20                         load.i8
	<tan+310 @03cca6>  : 06 23 00 00                jz <tan+345 @03ccc9>
	lib/std/math.ci:368: (17 bytes: <@03ccaa> - <@03ccbb>): if (bool(result == (0)))
	<tan+314 @03ccaa>  : 13 00                      dup.x2 sp(0)
	<tan+316 @03ccac>  : 19                         load.z64
	<tan+317 @03ccad>  : 87                         ceq.f64
	<tan+318 @03ccae>  : 06 0d 00 00                jz <tan+331 @03ccbb>
	lib/std/math.ci:369: (9 bytes: <@03ccb2> - <@03ccbb>): return float64(.result := nan);
	<tan+322 @03ccb2>  : 1a                         load.z128
	<tan+323 @03ccb3>  : 84                         div.f64
	<tan+324 @03ccb4>  : 16 10                      set.x2 sp(16)
	<tan+326 @03ccb6>  : 10 d4 ff ff                inc.sp(-44)
	<tan+330 @03ccba>  : 03                         ret
	lib/std/math.ci:371: (14 bytes: <@03ccbb> - <@03ccc9>): float64(result := float64((1) / result));
	<tan+331 @03ccbb>  : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @03ccc4>  : 13 02                      dup.x2 sp(2)
	<tan+342 @03ccc6>  : 84                         div.f64
	<tan+343 @03ccc7>  : 16 02                      set.x2 sp(2)
	lib/std/math.ci:373: (19 bytes: <@03ccc9> - <@03ccdc>): if (negate)
	<tan+345 @03ccc9>  : 11 24 00 00                load.sp(+36)
	<tan+349 @03cccd>  : 20                         load.i8
	<tan+350 @03ccce>  : 06 0e 00 00                jz <tan+364 @03ccdc>
	lib/std/math.ci:374: (10 bytes: <@03ccd2> - <@03ccdc>): return float64(.result := float64(-result));
	<tan+354 @03ccd2>  : 13 00                      dup.x2 sp(0)
	<tan+356 @03ccd4>  : 80                         neg.f64
	<tan+357 @03ccd5>  : 16 10                      set.x2 sp(16)
	<tan+359 @03ccd7>  : 10 d4 ff ff                inc.sp(-44)
	<tan+363 @03ccdb>  : 03                         ret
	lib/std/math.ci:376: (9 bytes: <@03ccdc> - <@03cce5>): return float64(.result := result);
	<tan+364 @03ccdc>  : 13 00                      dup.x2 sp(0)
	<tan+366 @03ccde>  : 16 10                      set.x2 sp(16)
	<tan+368 @03cce0>  : 10 d4 ff ff                inc.sp(-44)
	<tan+372 @03cce4>  : 03                         ret
	<tan+373 @03cce5>  : 10 d4 ff ff                inc.sp(-44)
	<tan+377 @03cce9>  : 03                         ret
.references:
	lib/std/math.ci:323: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 248
.offset: <@03ccf0>
.name: 'sinh'
.file: 'lib/std/math.ci:380'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (248 bytes: <@03ccf0> - <@03cde8>)
	lib/std/math.ci:392: (1 byte: <@03ccf0> - <@03ccf1>): negate: bool := false
	<sinh @03ccf0>      : 18                         load.z32
	lib/std/math.ci:393: (23 bytes: <@03ccf1> - <@03cd08>): if (bool(x < (0)))
	<sinh+1 @03ccf1>    : 13 02                      dup.x2 sp(2)
	<sinh+3 @03ccf3>    : 19                         load.z64
	<sinh+4 @03ccf4>    : 88                         clt.f64
	<sinh+5 @03ccf5>    : 06 13 00 00                jz <sinh+24 @03cd08>
	lib/std/math.ci:394: (5 bytes: <@03ccf9> - <@03ccfe>): float64(x := float64(-x));
	<sinh+9 @03ccf9>    : 13 02                      dup.x2 sp(2)
	<sinh+11 @03ccfb>   : 80                         neg.f64
	<sinh+12 @03ccfc>   : 16 04                      set.x2 sp(4)
	lib/std/math.ci:395: (10 bytes: <@03ccfe> - <@03cd08>): bool(negate := true);
	<sinh+14 @03ccfe>   : 1b 01 00 00 00             load.c32 1
	<sinh+19 @03cd03>   : 11 04 00 00                load.sp(+4)
	<sinh+23 @03cd07>   : 25                         store.i8
	lib/std/math.ci:398: (39 bytes: <@03cd08> - <@03cd2f>): if (bool(x > (21)))
	<sinh+24 @03cd08>   : 13 02                      dup.x2 sp(2)
	<sinh+26 @03cd0a>   : 1e 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @03cd13>   : 89                         cgt.f64
	<sinh+36 @03cd14>   : 06 1b 00 00                jz <sinh+63 @03cd2f>
	lib/std/math.ci:399: (23 bytes: <@03cd18> - <@03cd2f>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @03cd18>   : 13 02                      dup.x2 sp(2)
	<sinh+42 @03cd1a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @03cd1e>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @03cd27>   : 84                         div.f64
	<sinh+56 @03cd28>   : 16 06                      set.x2 sp(6)
	<sinh+58 @03cd2a>   : 10 fc ff ff                inc.sp(-4)
	<sinh+62 @03cd2e>   : 03                         ret
	lib/std/math.ci:402: (1 byte: <@03cd2f> - <@03cd30>): result: float64
	<sinh+63 @03cd2f>   : 19                         load.z64
	lib/std/math.ci:403: (151 bytes: <@03cd30> - <@03cdc7>): if (bool(x > 0.500000))
	<sinh+64 @03cd30>   : 13 04                      dup.x2 sp(4)
	<sinh+66 @03cd32>   : 1e 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @03cd3b>   : 89                         cgt.f64
	<sinh+76 @03cd3c>   : 06 22 00 00                jz <sinh+110 @03cd5e>
	lib/std/math.ci:404: (26 bytes: <@03cd40> - <@03cd5a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @03cd40>   : 13 04                      dup.x2 sp(4)
	<sinh+82 @03cd42>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @03cd46>   : 13 06                      dup.x2 sp(6)
	<sinh+88 @03cd48>   : 80                         neg.f64
	<sinh+89 @03cd49>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @03cd4d>   : 82                         sub.f64
	<sinh+94 @03cd4e>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @03cd57>  : 84                         div.f64
	<sinh+104 @03cd58>  : 16 02                      set.x2 sp(2)
	<sinh+106 @03cd5a>  : 04 6d 00 00                jmp <sinh+215 @03cdc7>
	lib/std/math.ci:407: (5 bytes: <@03cd5e> - <@03cd63>): sq: float64 := float64(x * x)
	<sinh+110 @03cd5e>  : 13 04                      dup.x2 sp(4)
	<sinh+112 @03cd60>  : 13 06                      dup.x2 sp(6)
	<sinh+114 @03cd62>  : 83                         mul.f64
	lib/std/math.ci:408: (53 bytes: <@03cd63> - <@03cd98>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @03cd63>  : 1e 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @03cd6c>  : 13 02                      dup.x2 sp(2)
	<sinh+126 @03cd6e>  : 83                         mul.f64
	<sinh+127 @03cd6f>  : 1e fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @03cd78>  : 81                         add.f64
	<sinh+137 @03cd79>  : 13 02                      dup.x2 sp(2)
	<sinh+139 @03cd7b>  : 83                         mul.f64
	<sinh+140 @03cd7c>  : 1e 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @03cd85>  : 81                         add.f64
	<sinh+150 @03cd86>  : 13 02                      dup.x2 sp(2)
	<sinh+152 @03cd88>  : 83                         mul.f64
	<sinh+153 @03cd89>  : 1e 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @03cd92>  : 81                         add.f64
	<sinh+163 @03cd93>  : 13 08                      dup.x2 sp(8)
	<sinh+165 @03cd95>  : 83                         mul.f64
	<sinh+166 @03cd96>  : 16 04                      set.x2 sp(4)
	lib/std/math.ci:409: (43 bytes: <@03cd98> - <@03cdc3>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @03cd98>  : 13 02                      dup.x2 sp(2)
	<sinh+170 @03cd9a>  : 13 02                      dup.x2 sp(2)
	<sinh+172 @03cd9c>  : 1e bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @03cda5>  : 81                         add.f64
	<sinh+182 @03cda6>  : 13 04                      dup.x2 sp(4)
	<sinh+184 @03cda8>  : 83                         mul.f64
	<sinh+185 @03cda9>  : 1e e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @03cdb2>  : 81                         add.f64
	<sinh+195 @03cdb3>  : 13 04                      dup.x2 sp(4)
	<sinh+197 @03cdb5>  : 83                         mul.f64
	<sinh+198 @03cdb6>  : 1e 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @03cdbf>  : 81                         add.f64
	<sinh+208 @03cdc0>  : 84                         div.f64
	<sinh+209 @03cdc1>  : 16 04                      set.x2 sp(4)
	<sinh+211 @03cdc3>  : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:412: (19 bytes: <@03cdc7> - <@03cdda>): if (negate)
	<sinh+215 @03cdc7>  : 11 08 00 00                load.sp(+8)
	<sinh+219 @03cdcb>  : 20                         load.i8
	<sinh+220 @03cdcc>  : 06 0e 00 00                jz <sinh+234 @03cdda>
	lib/std/math.ci:413: (10 bytes: <@03cdd0> - <@03cdda>): return float64(.result := float64(-result));
	<sinh+224 @03cdd0>  : 13 00                      dup.x2 sp(0)
	<sinh+226 @03cdd2>  : 80                         neg.f64
	<sinh+227 @03cdd3>  : 16 08                      set.x2 sp(8)
	<sinh+229 @03cdd5>  : 10 f4 ff ff                inc.sp(-12)
	<sinh+233 @03cdd9>  : 03                         ret
	lib/std/math.ci:415: (9 bytes: <@03cdda> - <@03cde3>): return float64(.result := result);
	<sinh+234 @03cdda>  : 13 00                      dup.x2 sp(0)
	<sinh+236 @03cddc>  : 16 08                      set.x2 sp(8)
	<sinh+238 @03cdde>  : 10 f4 ff ff                inc.sp(-12)
	<sinh+242 @03cde2>  : 03                         ret
	<sinh+243 @03cde3>  : 10 f4 ff ff                inc.sp(-12)
	<sinh+247 @03cde7>  : 03                         ret
.references:
	lib/std/math.Complex.ci:120: referenced as `sinh`
	lib/std/math.Complex.ci:119: referenced as `sinh`
	lib/std/math.ci:380: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@03cde8>
.name: 'cosh'
.file: 'lib/std/math.ci:419'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@03cde8> - <@03ce33>)
	lib/std/math.ci:420: (13 bytes: <@03cde8> - <@03cdf5>): if (bool(x < (0)))
	<cosh @03cde8>      : 13 01                      dup.x2 sp(1)
	<cosh+2 @03cdea>    : 19                         load.z64
	<cosh+3 @03cdeb>    : 88                         clt.f64
	<cosh+4 @03cdec>    : 06 09 00 00                jz <cosh+13 @03cdf5>
	lib/std/math.ci:421: (5 bytes: <@03cdf0> - <@03cdf5>): float64(x := float64(-x));
	<cosh+8 @03cdf0>    : 13 01                      dup.x2 sp(1)
	<cosh+10 @03cdf2>   : 80                         neg.f64
	<cosh+11 @03cdf3>   : 16 03                      set.x2 sp(3)
	lib/std/math.ci:423: (35 bytes: <@03cdf5> - <@03ce18>): if (bool(x > (21)))
	<cosh+13 @03cdf5>   : 13 01                      dup.x2 sp(1)
	<cosh+15 @03cdf7>   : 1e 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @03ce00>   : 89                         cgt.f64
	<cosh+25 @03ce01>   : 06 17 00 00                jz <cosh+48 @03ce18>
	lib/std/math.ci:424: (19 bytes: <@03ce05> - <@03ce18>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @03ce05>   : 13 01                      dup.x2 sp(1)
	<cosh+31 @03ce07>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @03ce0b>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @03ce14>   : 84                         div.f64
	<cosh+45 @03ce15>   : 16 05                      set.x2 sp(5)
	<cosh+47 @03ce17>   : 03                         ret
	lib/std/math.ci:426: (27 bytes: <@03ce18> - <@03ce33>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @03ce18>   : 13 01                      dup.x2 sp(1)
	<cosh+50 @03ce1a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @03ce1e>   : 13 03                      dup.x2 sp(3)
	<cosh+56 @03ce20>   : 80                         neg.f64
	<cosh+57 @03ce21>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @03ce25>   : 81                         add.f64
	<cosh+62 @03ce26>   : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @03ce2f>   : 84                         div.f64
	<cosh+72 @03ce30>   : 16 05                      set.x2 sp(5)
	<cosh+74 @03ce32>   : 03                         ret
.references:
	lib/std/math.Complex.ci:120: referenced as `cosh`
	lib/std/math.Complex.ci:119: referenced as `cosh`
	lib/std/math.ci:419: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 174
.offset: <@03ce38>
.name: 'asin'
.file: 'lib/std/math.ci:435'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (174 bytes: <@03ce38> - <@03cee6>)
	lib/std/math.ci:436: (13 bytes: <@03ce38> - <@03ce45>): if (bool(x == (0)))
	<asin @03ce38>      : 13 01                      dup.x2 sp(1)
	<asin+2 @03ce3a>    : 19                         load.z64
	<asin+3 @03ce3b>    : 87                         ceq.f64
	<asin+4 @03ce3c>    : 06 09 00 00                jz <asin+13 @03ce45>
	lib/std/math.ci:438: (5 bytes: <@03ce40> - <@03ce45>): return float64(.result := x);
	<asin+8 @03ce40>    : 13 01                      dup.x2 sp(1)
	<asin+10 @03ce42>   : 16 05                      set.x2 sp(5)
	<asin+12 @03ce44>   : 03                         ret
	lib/std/math.ci:441: (1 byte: <@03ce45> - <@03ce46>): negate: bool := false
	<asin+13 @03ce45>   : 18                         load.z32
	lib/std/math.ci:442: (23 bytes: <@03ce46> - <@03ce5d>): if (bool(x < (0)))
	<asin+14 @03ce46>   : 13 02                      dup.x2 sp(2)
	<asin+16 @03ce48>   : 19                         load.z64
	<asin+17 @03ce49>   : 88                         clt.f64
	<asin+18 @03ce4a>   : 06 13 00 00                jz <asin+37 @03ce5d>
	lib/std/math.ci:443: (10 bytes: <@03ce4e> - <@03ce58>): bool(negate := true);
	<asin+22 @03ce4e>   : 1b 01 00 00 00             load.c32 1
	<asin+27 @03ce53>   : 11 04 00 00                load.sp(+4)
	<asin+31 @03ce57>   : 25                         store.i8
	lib/std/math.ci:444: (5 bytes: <@03ce58> - <@03ce5d>): float64(x := float64(-x));
	<asin+32 @03ce58>   : 13 02                      dup.x2 sp(2)
	<asin+34 @03ce5a>   : 80                         neg.f64
	<asin+35 @03ce5b>   : 16 04                      set.x2 sp(4)
	lib/std/math.ci:447: (25 bytes: <@03ce5d> - <@03ce76>): if (bool(x > (1)))
	<asin+37 @03ce5d>   : 13 02                      dup.x2 sp(2)
	<asin+39 @03ce5f>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+48 @03ce68>   : 89                         cgt.f64
	<asin+49 @03ce69>   : 06 0d 00 00                jz <asin+62 @03ce76>
	lib/std/math.ci:449: (9 bytes: <@03ce6d> - <@03ce76>): return float64(.result := nan);
	<asin+53 @03ce6d>   : 1a                         load.z128
	<asin+54 @03ce6e>   : 84                         div.f64
	<asin+55 @03ce6f>   : 16 06                      set.x2 sp(6)
	<asin+57 @03ce71>   : 10 fc ff ff                inc.sp(-4)
	<asin+61 @03ce75>   : 03                         ret
	lib/std/math.ci:452: (19 bytes: <@03ce76> - <@03ce89>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+62 @03ce76>   : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+71 @03ce7f>   : 13 04                      dup.x2 sp(4)
	<asin+73 @03ce81>   : 13 06                      dup.x2 sp(6)
	<asin+75 @03ce83>   : 83                         mul.f64
	<asin+76 @03ce84>   : 82                         sub.f64
	<asin+77 @03ce85>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:453: (60 bytes: <@03ce89> - <@03cec5>): if (bool(x > 0.700000))
	<asin+81 @03ce89>   : 13 04                      dup.x2 sp(4)
	<asin+83 @03ce8b>   : 1e 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+92 @03ce94>   : 89                         cgt.f64
	<asin+93 @03ce95>   : 06 26 00 00                jz <asin+131 @03cebb>
	lib/std/math.ci:454: (30 bytes: <@03ce99> - <@03ceb7>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+97 @03ce99>   : 1e 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+106 @03cea2>  : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+115 @03ceab>  : 84                         div.f64
	<asin+116 @03ceac>  : 13 02                      dup.x2 sp(2)
	<asin+118 @03ceae>  : 13 08                      dup.x2 sp(8)
	<asin+120 @03ceb0>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+124 @03ceb4>  : 82                         sub.f64
	<asin+125 @03ceb5>  : 16 02                      set.x2 sp(2)
	<asin+127 @03ceb7>  : 04 0e 00 00                jmp <asin+141 @03cec5>
	lib/std/math.ci:457: (10 bytes: <@03cebb> - <@03cec5>): float64(result := float64.atan2(void(x, result)));
	<asin+131 @03cebb>  : 13 04                      dup.x2 sp(4)
	<asin+133 @03cebd>  : 13 02                      dup.x2 sp(2)
	<asin+135 @03cebf>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+139 @03cec3>  : 16 02                      set.x2 sp(2)
	lib/std/math.ci:460: (19 bytes: <@03cec5> - <@03ced8>): if (negate)
	<asin+141 @03cec5>  : 11 08 00 00                load.sp(+8)
	<asin+145 @03cec9>  : 20                         load.i8
	<asin+146 @03ceca>  : 06 0e 00 00                jz <asin+160 @03ced8>
	lib/std/math.ci:461: (10 bytes: <@03cece> - <@03ced8>): return float64(.result := float64(-result));
	<asin+150 @03cece>  : 13 00                      dup.x2 sp(0)
	<asin+152 @03ced0>  : 80                         neg.f64
	<asin+153 @03ced1>  : 16 08                      set.x2 sp(8)
	<asin+155 @03ced3>  : 10 f4 ff ff                inc.sp(-12)
	<asin+159 @03ced7>  : 03                         ret
	lib/std/math.ci:463: (9 bytes: <@03ced8> - <@03cee1>): return float64(.result := result);
	<asin+160 @03ced8>  : 13 00                      dup.x2 sp(0)
	<asin+162 @03ceda>  : 16 08                      set.x2 sp(8)
	<asin+164 @03cedc>  : 10 f4 ff ff                inc.sp(-12)
	<asin+168 @03cee0>  : 03                         ret
	<asin+169 @03cee1>  : 10 f4 ff ff                inc.sp(-12)
	<asin+173 @03cee5>  : 03                         ret
.references:
	lib/std/math.ci:470: referenced as `asin`
	lib/std/math.ci:435: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:470'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: (float64(float64(pi / (2)) - asin(x)))
.references:
	lib/std/math.ci:470: defined as `acos(x: float64): float64`
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'deg2rad'
.file: 'lib/std/math.ci:493'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * pi) / (180)))
.references:
	lib/std/math.ci:493: defined as `deg2rad(x: float64): float64`
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rad2deg'
.file: 'lib/std/math.ci:494'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.value: float64(float64(float64(x * (180)) / pi))
.references:
	lib/std/math.ci:494: defined as `rad2deg(x: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@014c58>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:3'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:142: referenced as `Complex`
	lib/std/math.Complex.ci:141: referenced as `Complex`
	lib/std/math.Complex.ci:140: referenced as `Complex`
	lib/std/math.Complex.ci:138: referenced as `Complex`
	lib/std/math.Complex.ci:137: referenced as `Complex`
	lib/std/math.Complex.ci:136: referenced as `Complex`
	lib/std/math.Complex.ci:135: referenced as `Complex`
	lib/std/math.Complex.ci:133: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:107: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:93: referenced as `Complex`
	lib/std/math.Complex.ci:90: referenced as `Complex`
	lib/std/math.Complex.ci:89: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: referenced as `Complex`
	lib/std/math.Complex.ci:20: referenced as `Complex`
	lib/std/math.Complex.ci:3: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:4'
.owner: Complex
.references:
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:145: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:120: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:119: referenced as `re`
	lib/std/math.Complex.ci:113: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:110: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:103: referenced as `re`
	lib/std/math.Complex.ci:101: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:94: referenced as `re`
	lib/std/math.Complex.ci:90: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:82: referenced as `re`
	lib/std/math.Complex.ci:81: referenced as `re`
	lib/std/math.Complex.ci:79: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:75: referenced as `re`
	lib/std/math.Complex.ci:74: referenced as `re`
	lib/std/math.Complex.ci:72: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:70: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:63: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:60: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:58: referenced as `re`
	lib/std/math.Complex.ci:56: referenced as `re`
	lib/std/math.Complex.ci:55: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:54: referenced as `re`
	lib/std/math.Complex.ci:52: referenced as `re`
	lib/std/math.Complex.ci:27: referenced as `re`
	lib/std/math.Complex.ci:22: referenced as `re`
	lib/std/math.Complex.ci:4: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.value: 0
.references:
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:145: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:120: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:119: referenced as `im`
	lib/std/math.Complex.ci:114: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:110: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:103: referenced as `im`
	lib/std/math.Complex.ci:101: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:97: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:94: referenced as `im`
	lib/std/math.Complex.ci:90: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:82: referenced as `im`
	lib/std/math.Complex.ci:81: referenced as `im`
	lib/std/math.Complex.ci:79: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:75: referenced as `im`
	lib/std/math.Complex.ci:74: referenced as `im`
	lib/std/math.Complex.ci:72: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:70: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:63: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:60: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:58: referenced as `im`
	lib/std/math.Complex.ci:56: referenced as `im`
	lib/std/math.Complex.ci:55: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:54: referenced as `im`
	lib/std/math.Complex.ci:52: referenced as `im`
	lib/std/math.Complex.ci:28: referenced as `im`
	lib/std/math.Complex.ci:5: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03cee8>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:20'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (8 bytes: <@03cee8> - <@03cef0>)
	lib/std/math.Complex.ci:21: (8 bytes: <@03cee8> - <@03cef0>): return void(.result := {...});
	<Complex @03cee8>      : 13 01                      dup.x2 sp(1)
	<Complex+2 @03ceea>    : 16 05                      set.x2 sp(5)
	:: (3 bytes: <@03ceec> - <@03ceef>): void(.result.im := (0))
	<Complex+4 @03ceec>    : 19                         load.z64
	<Complex+5 @03ceed>    : 16 07                      set.x2 sp(7)
	<Complex+7 @03ceef>    : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `Complex`
	lib/std/math.Complex.ci:87: referenced as `Complex`
	lib/std/math.Complex.ci:86: referenced as `Complex`
	lib/std/math.Complex.ci:20: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 9
.offset: <@03cef0>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:25'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (9 bytes: <@03cef0> - <@03cef9>)
	lib/std/math.Complex.ci:26: (9 bytes: <@03cef0> - <@03cef9>): return void(.result := {...});
	<Complex @03cef0>      : 13 03                      dup.x2 sp(3)
	<Complex+2 @03cef2>    : 16 07                      set.x2 sp(7)
	lib/std/math.Complex.ci:28: (4 bytes: <@03cef4> - <@03cef8>): void(.result.im := im);
	<Complex+4 @03cef4>    : 13 01                      dup.x2 sp(1)
	<Complex+6 @03cef6>    : 16 09                      set.x2 sp(9)
	<Complex+8 @03cef8>    : 03                         ret
.references:
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:145: referenced as `Complex`
	lib/std/math.Complex.ci:120: referenced as `Complex`
	lib/std/math.Complex.ci:119: referenced as `Complex`
	lib/std/math.Complex.ci:105: referenced as `Complex`
	lib/std/math.Complex.ci:103: referenced as `Complex`
	lib/std/math.Complex.ci:101: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:63: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:60: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:58: referenced as `Complex`
	lib/std/math.Complex.ci:56: referenced as `Complex`
	lib/std/math.Complex.ci:55: referenced as `Complex`
	lib/std/math.Complex.ci:54: referenced as `Complex`
	lib/std/math.Complex.ci:52: referenced as `Complex`
	lib/std/math.Complex.ci:25: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:52'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(-a.re), float64(-a.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `neg`
	lib/std/math.Complex.ci:135: referenced as `neg`
	lib/std/math.Complex.ci:52: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:54'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.references:
	lib/std/math.Complex.ci:136: referenced as `add`
	lib/std/math.Complex.ci:54: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:55'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re + b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `add`
	lib/std/math.Complex.ci:137: referenced as `add`
	lib/std/math.Complex.ci:55: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:56'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a + b.re), b.im))
.references:
	lib/std/math.Complex.ci:56: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:58'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.references:
	lib/std/math.Complex.ci:135: referenced as `sub`
	lib/std/math.Complex.ci:58: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: Complex(void(float64(a.re - b), a.im))
.references:
	lib/std/math.Complex.ci:138: referenced as `sub`
	lib/std/math.Complex.ci:137: referenced as `sub`
	lib/std/math.Complex.ci:59: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:60'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(a - b.re), b.im))
.references:
	lib/std/math.Complex.ci:60: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.references:
	lib/std/math.Complex.ci:62: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:63'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.references:
	lib/std/math.Complex.ci:63: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.references:
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:138: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:137: referenced as `mul`
	lib/std/math.Complex.ci:64: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 128
.offset: <@03cf00>
.name: 'div'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (128 bytes: <@03cf00> - <@03cf80>)
	lib/std/math.Complex.ci:70: (79 bytes: <@03cf00> - <@03cf4f>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @03cf00>      : 19                         load.z64
	<div+1 @03cf01>    : 13 03                      dup.x2 sp(3)
	<div+3 @03cf03>    : 1f 28 c8 03 00             load.ref <@03c828> ;Math.abs(x: float64): float64
	<div+8 @03cf08>    : 02                         call
	<div+9 @03cf09>    : 10 f8 ff ff                inc.sp(-8)
	<div+13 @03cf0d>   : 19                         load.z64
	<div+14 @03cf0e>   : 13 07                      dup.x2 sp(7)
	<div+16 @03cf10>   : 1f 28 c8 03 00             load.ref <@03c828> ;Math.abs(x: float64): float64
	<div+21 @03cf15>   : 02                         call
	<div+22 @03cf16>   : 10 f8 ff ff                inc.sp(-8)
	<div+26 @03cf1a>   : 88                         clt.f64
	<div+27 @03cf1b>   : 05 34 00 00                jnz <div+79 @03cf4f>
	lib/std/math.Complex.ci:71: (5 bytes: <@03cf1f> - <@03cf24>): r: float64 := float64(b.im / b.re)
	<div+31 @03cf1f>   : 13 03                      dup.x2 sp(3)
	<div+33 @03cf21>   : 13 03                      dup.x2 sp(3)
	<div+35 @03cf23>   : 84                         div.f64
	lib/std/math.Complex.ci:72: (8 bytes: <@03cf24> - <@03cf2c>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @03cf24>   : 13 03                      dup.x2 sp(3)
	<div+38 @03cf26>   : 13 02                      dup.x2 sp(2)
	<div+40 @03cf28>   : 13 09                      dup.x2 sp(9)
	<div+42 @03cf2a>   : 83                         mul.f64
	<div+43 @03cf2b>   : 81                         add.f64
	lib/std/math.Complex.ci:73: (31 bytes: <@03cf2c> - <@03cf4b>): return void(.result := {...});
	<div+44 @03cf2c>   : 13 09                      dup.x2 sp(9)
	<div+46 @03cf2e>   : 13 04                      dup.x2 sp(4)
	<div+48 @03cf30>   : 13 0f                      dup.x2 sp(15)
	<div+50 @03cf32>   : 83                         mul.f64
	<div+51 @03cf33>   : 81                         add.f64
	<div+52 @03cf34>   : 13 02                      dup.x2 sp(2)
	<div+54 @03cf36>   : 84                         div.f64
	<div+55 @03cf37>   : 16 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:75: (13 bytes: <@03cf39> - <@03cf46>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @03cf39>   : 13 0b                      dup.x2 sp(11)
	<div+59 @03cf3b>   : 13 04                      dup.x2 sp(4)
	<div+61 @03cf3d>   : 13 0d                      dup.x2 sp(13)
	<div+63 @03cf3f>   : 83                         mul.f64
	<div+64 @03cf40>   : 82                         sub.f64
	<div+65 @03cf41>   : 13 02                      dup.x2 sp(2)
	<div+67 @03cf43>   : 84                         div.f64
	<div+68 @03cf44>   : 16 11                      set.x2 sp(17)
	<div+70 @03cf46>   : 10 f0 ff ff                inc.sp(-16)
	<div+74 @03cf4a>   : 03                         ret
	<div+75 @03cf4b>   : 10 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:78: (5 bytes: <@03cf4f> - <@03cf54>): r: float64 := float64(b.re / b.im)
	<div+79 @03cf4f>   : 13 01                      dup.x2 sp(1)
	<div+81 @03cf51>   : 13 05                      dup.x2 sp(5)
	<div+83 @03cf53>   : 84                         div.f64
	lib/std/math.Complex.ci:79: (8 bytes: <@03cf54> - <@03cf5c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @03cf54>   : 13 05                      dup.x2 sp(5)
	<div+86 @03cf56>   : 13 02                      dup.x2 sp(2)
	<div+88 @03cf58>   : 13 07                      dup.x2 sp(7)
	<div+90 @03cf5a>   : 83                         mul.f64
	<div+91 @03cf5b>   : 81                         add.f64
	lib/std/math.Complex.ci:80: (31 bytes: <@03cf5c> - <@03cf7b>): return void(.result := {...});
	<div+92 @03cf5c>   : 13 09                      dup.x2 sp(9)
	<div+94 @03cf5e>   : 13 04                      dup.x2 sp(4)
	<div+96 @03cf60>   : 83                         mul.f64
	<div+97 @03cf61>   : 13 0d                      dup.x2 sp(13)
	<div+99 @03cf63>   : 81                         add.f64
	<div+100 @03cf64>  : 13 02                      dup.x2 sp(2)
	<div+102 @03cf66>  : 84                         div.f64
	<div+103 @03cf67>  : 16 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:82: (13 bytes: <@03cf69> - <@03cf76>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @03cf69>  : 13 0b                      dup.x2 sp(11)
	<div+107 @03cf6b>  : 13 04                      dup.x2 sp(4)
	<div+109 @03cf6d>  : 83                         mul.f64
	<div+110 @03cf6e>  : 13 0b                      dup.x2 sp(11)
	<div+112 @03cf70>  : 82                         sub.f64
	<div+113 @03cf71>  : 13 02                      dup.x2 sp(2)
	<div+115 @03cf73>  : 84                         div.f64
	<div+116 @03cf74>  : 16 11                      set.x2 sp(17)
	<div+118 @03cf76>  : 10 f0 ff ff                inc.sp(-16)
	<div+122 @03cf7a>  : 03                         ret
	<div+123 @03cf7b>  : 10 f0 ff ff                inc.sp(-16)
	<div+127 @03cf7f>  : 03                         ret
.references:
	lib/std/math.Complex.ci:138: referenced as `div`
	lib/std/math.Complex.ci:137: referenced as `div`
	lib/std/math.Complex.ci:133: referenced as `div`
	lib/std/math.Complex.ci:132: referenced as `div`
	lib/std/math.Complex.ci:87: referenced as `div`
	lib/std/math.Complex.ci:86: referenced as `div`
	lib/std/math.Complex.ci:66: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:86'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: div(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:136: referenced as `div`
	lib/std/math.Complex.ci:135: referenced as `div`
	lib/std/math.Complex.ci:86: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:87'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.value: div(void(Complex(a), b))
.references:
	lib/std/math.Complex.ci:87: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:89'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.references:
	lib/std/math.Complex.ci:146: referenced as `abs`
	lib/std/math.Complex.ci:108: referenced as `abs`
	lib/std/math.Complex.ci:105: referenced as `abs`
	lib/std/math.Complex.ci:89: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:90'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: float64.atan2(void(a.re, a.im))
.references:
	lib/std/math.Complex.ci:146: referenced as `arg`
	lib/std/math.Complex.ci:109: referenced as `arg`
	lib/std/math.Complex.ci:105: referenced as `arg`
	lib/std/math.Complex.ci:90: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03cf80>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:93'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (36 bytes: <@03cf80> - <@03cfa4>)
	lib/std/math.Complex.ci:94: (11 bytes: <@03cf80> - <@03cf8b>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @03cf80>      : 13 01                      dup.x2 sp(1)
	<inv+2 @03cf82>    : 13 03                      dup.x2 sp(3)
	<inv+4 @03cf84>    : 83                         mul.f64
	<inv+5 @03cf85>    : 13 05                      dup.x2 sp(5)
	<inv+7 @03cf87>    : 13 07                      dup.x2 sp(7)
	<inv+9 @03cf89>    : 83                         mul.f64
	<inv+10 @03cf8a>   : 81                         add.f64
	lib/std/math.Complex.ci:95: (20 bytes: <@03cf8b> - <@03cf9f>): return void(.result := {...});
	<inv+11 @03cf8b>   : 13 03                      dup.x2 sp(3)
	<inv+13 @03cf8d>   : 13 02                      dup.x2 sp(2)
	<inv+15 @03cf8f>   : 84                         div.f64
	<inv+16 @03cf90>   : 16 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:97: (8 bytes: <@03cf92> - <@03cf9a>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @03cf92>   : 13 05                      dup.x2 sp(5)
	<inv+20 @03cf94>   : 80                         neg.f64
	<inv+21 @03cf95>   : 13 02                      dup.x2 sp(2)
	<inv+23 @03cf97>   : 84                         div.f64
	<inv+24 @03cf98>   : 16 0b                      set.x2 sp(11)
	<inv+26 @03cf9a>   : 10 f8 ff ff                inc.sp(-8)
	<inv+30 @03cf9e>   : 03                         ret
	<inv+31 @03cf9f>   : 10 f8 ff ff                inc.sp(-8)
	<inv+35 @03cfa3>   : 03                         ret
.references:
	lib/std/math.Complex.ci:143: referenced as `inv`
	lib/std/math.Complex.ci:142: referenced as `inv`
	lib/std/math.Complex.ci:141: referenced as `inv`
	lib/std/math.Complex.ci:140: referenced as `inv`
	lib/std/math.Complex.ci:93: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:101'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(a.re, float64(-a.im)))
.references:
	lib/std/math.Complex.ci:101: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:103'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.references:
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:138: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:137: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:135: referenced as `exp`
	lib/std/math.Complex.ci:103: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:105'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64.log(abs(a)), arg(a)))
.references:
	lib/std/math.Complex.ci:105: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 105
.offset: <@03cfa8>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:107'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (105 bytes: <@03cfa8> - <@03d011>)
	lib/std/math.Complex.ci:108: (23 bytes: <@03cfa8> - <@03cfbf>): r: float64 := abs(a)
	<pow @03cfa8>      : 14 05                      dup.x4 sp(5)
	<pow+2 @03cfaa>    : 13 00                      dup.x2 sp(0)
	<pow+4 @03cfac>    : 13 02                      dup.x2 sp(2)
	<pow+6 @03cfae>    : 83                         mul.f64
	<pow+7 @03cfaf>    : 13 04                      dup.x2 sp(4)
	<pow+9 @03cfb1>    : 13 06                      dup.x2 sp(6)
	<pow+11 @03cfb3>   : 83                         mul.f64
	<pow+12 @03cfb4>   : 81                         add.f64
	<pow+13 @03cfb5>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @03cfb9>   : 16 04                      set.x2 sp(4)
	<pow+19 @03cfbb>   : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:109: (16 bytes: <@03cfbf> - <@03cfcf>): t: float64 := arg(a)
	<pow+23 @03cfbf>   : 14 07                      dup.x4 sp(7)
	<pow+25 @03cfc1>   : 13 00                      dup.x2 sp(0)
	<pow+27 @03cfc3>   : 13 04                      dup.x2 sp(4)
	<pow+29 @03cfc5>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @03cfc9>   : 16 04                      set.x2 sp(4)
	<pow+35 @03cfcb>   : 10 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:110: (15 bytes: <@03cfcf> - <@03cfde>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @03cfcf>   : 13 05                      dup.x2 sp(5)
	<pow+41 @03cfd1>   : 13 02                      dup.x2 sp(2)
	<pow+43 @03cfd3>   : 83                         mul.f64
	<pow+44 @03cfd4>   : 13 09                      dup.x2 sp(9)
	<pow+46 @03cfd6>   : 13 06                      dup.x2 sp(6)
	<pow+48 @03cfd8>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @03cfdc>   : 83                         mul.f64
	<pow+53 @03cfdd>   : 81                         add.f64
	lib/std/math.Complex.ci:111: (19 bytes: <@03cfde> - <@03cff1>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @03cfde>   : 13 04                      dup.x2 sp(4)
	<pow+56 @03cfe0>   : 13 09                      dup.x2 sp(9)
	<pow+58 @03cfe2>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @03cfe6>   : 13 0b                      dup.x2 sp(11)
	<pow+64 @03cfe8>   : 80                         neg.f64
	<pow+65 @03cfe9>   : 13 06                      dup.x2 sp(6)
	<pow+67 @03cfeb>   : 83                         mul.f64
	<pow+68 @03cfec>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @03cff0>   : 83                         mul.f64
	lib/std/math.Complex.ci:112: (27 bytes: <@03cff1> - <@03d00c>): return void(.result := {...});
	<pow+73 @03cff1>   : 13 00                      dup.x2 sp(0)
	<pow+75 @03cff3>   : 13 04                      dup.x2 sp(4)
	<pow+77 @03cff5>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @03cff9>   : 83                         mul.f64
	<pow+82 @03cffa>   : 16 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:114: (11 bytes: <@03cffc> - <@03d007>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @03cffc>   : 13 00                      dup.x2 sp(0)
	<pow+86 @03cffe>   : 13 04                      dup.x2 sp(4)
	<pow+88 @03d000>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @03d004>   : 83                         mul.f64
	<pow+93 @03d005>   : 16 15                      set.x2 sp(21)
	<pow+95 @03d007>   : 10 e0 ff ff                inc.sp(-32)
	<pow+99 @03d00b>   : 03                         ret
	<pow+100 @03d00c>  : 10 e0 ff ff                inc.sp(-32)
	<pow+104 @03d010>  : 03                         ret
.references:
	lib/std/math.Complex.ci:117: referenced as `pow`
	lib/std/math.Complex.ci:107: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:117'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.value: pow(void(a, Complex(b)))
.references:
	lib/std/math.Complex.ci:117: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:119'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:141: referenced as `sin`
	lib/std/math.Complex.ci:133: referenced as `sin`
	lib/std/math.Complex.ci:132: referenced as `sin`
	lib/std/math.Complex.ci:119: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:120'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.references:
	lib/std/math.Complex.ci:140: referenced as `cos`
	lib/std/math.Complex.ci:133: referenced as `cos`
	lib/std/math.Complex.ci:132: referenced as `cos`
	lib/std/math.Complex.ci:120: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sin(a), cos(a)))
.references:
	lib/std/math.Complex.ci:132: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:133'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(cos(a), sin(a)))
.references:
	lib/std/math.Complex.ci:133: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:135'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:143: referenced as `sinh`
	lib/std/math.Complex.ci:135: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:136'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.references:
	lib/std/math.Complex.ci:142: referenced as `cosh`
	lib/std/math.Complex.ci:136: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:137'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:137: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:138'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.references:
	lib/std/math.Complex.ci:138: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:140'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cos(a))
.references:
	lib/std/math.Complex.ci:140: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:141'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sin(a))
.references:
	lib/std/math.Complex.ci:141: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:142'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(cosh(a))
.references:
	lib/std/math.Complex.ci:142: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.value: inv(sinh(a))
.references:
	lib/std/math.Complex.ci:143: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:145'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.references:
	lib/std/math.Complex.ci:145: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.value: Complex(void(abs(x), arg(x)))
.references:
	lib/std/math.Complex.ci:146: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@03d018>
.name: 'length'
.file: 'lib/std/string.ci:3'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (49 bytes: <@03d018> - <@03d049>)
	lib/std/string.ci:4: (16 bytes: <@03d018> - <@03d028>): if (bool((str) == null))
	<length @03d018>      : 12 01                      dup.x1 sp(1)
	<length+2 @03d01a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @03d01f>    : 57                         ceq.i32
	<length+8 @03d020>    : 06 08 00 00                jz <length+16 @03d028>
	lib/std/string.ci:5: (4 bytes: <@03d024> - <@03d028>): return int32(.result := 0);
	<length+12 @03d024>   : 18                         load.z32
	<length+13 @03d025>   : 15 03                      set.x1 sp(3)
	<length+15 @03d027>   : 03                         ret
	lib/std/string.ci:7: (1 byte: <@03d028> - <@03d029>): result: int32 := 0
	<length+16 @03d028>   : 18                         load.z32
	lib/std/string.ci:8: (18 bytes: <@03d029> - <@03d03b>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @03d029>   : 04 08 00 00                jmp <length+25 @03d031>
	lib/std/string.ci:8: (4 bytes: <@03d02d> - <@03d031>): int32(result := int32(result + 1))
	<length+21 @03d02d>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:8: (10 bytes: <@03d031> - <@03d03b>): str[result]
	<length+25 @03d031>   : 12 02                      dup.x1 sp(2)
	<length+27 @03d033>   : 12 01                      dup.x1 sp(1)
	<length+29 @03d035>   : 51                         add.i32
	<length+30 @03d036>   : 20                         load.i8
	<length+31 @03d037>   : 05 f6 ff ff                jnz <length+21 @03d02d>
	lib/std/string.ci:10: (9 bytes: <@03d03b> - <@03d044>): return int32(.result := result);
	<length+35 @03d03b>   : 12 00                      dup.x1 sp(0)
	<length+37 @03d03d>   : 15 04                      set.x1 sp(4)
	<length+39 @03d03f>   : 10 fc ff ff                inc.sp(-4)
	<length+43 @03d043>   : 03                         ret
	<length+44 @03d044>   : 10 fc ff ff                inc.sp(-4)
	<length+48 @03d048>   : 03                         ret
.references:
	lib/std/string.ci:46: referenced as `length`
	lib/std/string.ci:45: referenced as `length`
	lib/std/string.ci:3: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 56
.offset: <@03d050>
.name: 'indexOf'
.file: 'lib/std/string.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (56 bytes: <@03d050> - <@03d088>)
	lib/std/string.ci:15: (48 bytes: <@03d050> - <@03d080>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @03d050>      : 18                         load.z32
	<indexOf+1 @03d051>    : 04 21 00 00                jmp <indexOf+34 @03d072>
	lib/std/string.ci:16: (25 bytes: <@03d055> - <@03d06e>): if (bool(str[i] == chr))
	<indexOf+5 @03d055>    : 12 03                      dup.x1 sp(3)
	<indexOf+7 @03d057>    : 12 01                      dup.x1 sp(1)
	<indexOf+9 @03d059>    : 51                         add.i32
	<indexOf+10 @03d05a>   : 20                         load.i8
	<indexOf+11 @03d05b>   : 11 0c 00 00                load.sp(+12)
	<indexOf+15 @03d05f>   : 20                         load.i8
	<indexOf+16 @03d060>   : 57                         ceq.i32
	<indexOf+17 @03d061>   : 06 0d 00 00                jz <indexOf+30 @03d06e>
	lib/std/string.ci:17: (9 bytes: <@03d065> - <@03d06e>): return int32(.result := i);
	<indexOf+21 @03d065>   : 12 00                      dup.x1 sp(0)
	<indexOf+23 @03d067>   : 15 05                      set.x1 sp(5)
	<indexOf+25 @03d069>   : 10 fc ff ff                inc.sp(-4)
	<indexOf+29 @03d06d>   : 03                         ret
	lib/std/string.ci:15: (4 bytes: <@03d06e> - <@03d072>): int32(i := int32(i + 1))
	<indexOf+30 @03d06e>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:15: (10 bytes: <@03d072> - <@03d07c>): str[i]
	<indexOf+34 @03d072>   : 12 03                      dup.x1 sp(3)
	<indexOf+36 @03d074>   : 12 01                      dup.x1 sp(1)
	<indexOf+38 @03d076>   : 51                         add.i32
	<indexOf+39 @03d077>   : 20                         load.i8
	<indexOf+40 @03d078>   : 05 dd ff ff                jnz <indexOf+5 @03d055>
	<indexOf+44 @03d07c>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:20: (8 bytes: <@03d080> - <@03d088>): return int32(.result := int32(-1));
	<indexOf+48 @03d080>   : 1b ff ff ff ff             load.c32 -1
	<indexOf+53 @03d085>   : 15 04                      set.x1 sp(4)
	<indexOf+55 @03d087>   : 03                         ret
.references:
	lib/std/string.ci:92: referenced as `indexOf`
	lib/std/string.ci:14: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 62
.offset: <@03d088>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:24'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (62 bytes: <@03d088> - <@03d0c6>)
	lib/std/string.ci:25: (5 bytes: <@03d088> - <@03d08d>): result: int32 := int32(-1)
	<lastIndexOf @03d088>      : 1b ff ff ff ff             load.c32 -1
	lib/std/string.ci:26: (43 bytes: <@03d08d> - <@03d0b8>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @03d08d>    : 18                         load.z32
	<lastIndexOf+6 @03d08e>    : 04 1c 00 00                jmp <lastIndexOf+34 @03d0aa>
	lib/std/string.ci:27: (20 bytes: <@03d092> - <@03d0a6>): if (bool(str[i] == chr))
	<lastIndexOf+10 @03d092>   : 12 04                      dup.x1 sp(4)
	<lastIndexOf+12 @03d094>   : 12 01                      dup.x1 sp(1)
	<lastIndexOf+14 @03d096>   : 51                         add.i32
	<lastIndexOf+15 @03d097>   : 20                         load.i8
	<lastIndexOf+16 @03d098>   : 11 10 00 00                load.sp(+16)
	<lastIndexOf+20 @03d09c>   : 20                         load.i8
	<lastIndexOf+21 @03d09d>   : 57                         ceq.i32
	<lastIndexOf+22 @03d09e>   : 06 08 00 00                jz <lastIndexOf+30 @03d0a6>
	lib/std/string.ci:28: (4 bytes: <@03d0a2> - <@03d0a6>): int32(result := i);
	<lastIndexOf+26 @03d0a2>   : 12 00                      dup.x1 sp(0)
	<lastIndexOf+28 @03d0a4>   : 15 02                      set.x1 sp(2)
	lib/std/string.ci:26: (4 bytes: <@03d0a6> - <@03d0aa>): int32(i := int32(i + 1))
	<lastIndexOf+30 @03d0a6>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:26: (10 bytes: <@03d0aa> - <@03d0b4>): str[i]
	<lastIndexOf+34 @03d0aa>   : 12 04                      dup.x1 sp(4)
	<lastIndexOf+36 @03d0ac>   : 12 01                      dup.x1 sp(1)
	<lastIndexOf+38 @03d0ae>   : 51                         add.i32
	<lastIndexOf+39 @03d0af>   : 20                         load.i8
	<lastIndexOf+40 @03d0b0>   : 05 e2 ff ff                jnz <lastIndexOf+10 @03d092>
	<lastIndexOf+44 @03d0b4>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:31: (9 bytes: <@03d0b8> - <@03d0c1>): return int32(.result := result);
	<lastIndexOf+48 @03d0b8>   : 12 00                      dup.x1 sp(0)
	<lastIndexOf+50 @03d0ba>   : 15 05                      set.x1 sp(5)
	<lastIndexOf+52 @03d0bc>   : 10 fc ff ff                inc.sp(-4)
	<lastIndexOf+56 @03d0c0>   : 03                         ret
	<lastIndexOf+57 @03d0c1>   : 10 fc ff ff                inc.sp(-4)
	<lastIndexOf+61 @03d0c5>   : 03                         ret
.references:
	lib/std/string.ci:24: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@03d0c8>
.name: 'startsWith'
.file: 'lib/std/string.ci:35'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@03d0c8> - <@03d111>)
	lib/std/string.ci:36: (62 bytes: <@03d0c8> - <@03d106>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @03d0c8>      : 18                         load.z32
	<startsWith+1 @03d0c9>    : 04 2d 00 00                jmp <startsWith+46 @03d0f6>
	lib/std/string.ci:37: (37 bytes: <@03d0cd> - <@03d0f2>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @03d0cd>    : 18                         load.z32
	<startsWith+6 @03d0ce>    : 12 05                      dup.x1 sp(5)
	<startsWith+8 @03d0d0>    : 12 02                      dup.x1 sp(2)
	<startsWith+10 @03d0d2>   : 51                         add.i32
	<startsWith+11 @03d0d3>   : 20                         load.i8
	<startsWith+12 @03d0d4>   : 12 05                      dup.x1 sp(5)
	<startsWith+14 @03d0d6>   : 12 03                      dup.x1 sp(3)
	<startsWith+16 @03d0d8>   : 51                         add.i32
	<startsWith+17 @03d0d9>   : 20                         load.i8
	<startsWith+18 @03d0da>   : 12 05                      dup.x1 sp(5)
	<startsWith+20 @03d0dc>   : 02                         call
	<startsWith+21 @03d0dd>   : 10 f8 ff ff                inc.sp(-8)
	<startsWith+25 @03d0e1>   : 18                         load.z32
	<startsWith+26 @03d0e2>   : 57                         ceq.i32
	<startsWith+27 @03d0e3>   : 05 0f 00 00                jnz <startsWith+42 @03d0f2>
	lib/std/string.ci:38: (11 bytes: <@03d0e7> - <@03d0f2>): return bool(.result := false);
	<startsWith+31 @03d0e7>   : 18                         load.z32
	<startsWith+32 @03d0e8>   : 11 18 00 00                load.sp(+24)
	<startsWith+36 @03d0ec>   : 25                         store.i8
	<startsWith+37 @03d0ed>   : 10 fc ff ff                inc.sp(-4)
	<startsWith+41 @03d0f1>   : 03                         ret
	lib/std/string.ci:36: (4 bytes: <@03d0f2> - <@03d0f6>): int32(i := int32(i + 1))
	<startsWith+42 @03d0f2>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:36: (12 bytes: <@03d0f6> - <@03d102>): bool((with[i]) != 0)
	<startsWith+46 @03d0f6>   : 12 03                      dup.x1 sp(3)
	<startsWith+48 @03d0f8>   : 12 01                      dup.x1 sp(1)
	<startsWith+50 @03d0fa>   : 51                         add.i32
	<startsWith+51 @03d0fb>   : 20                         load.i8
	<startsWith+52 @03d0fc>   : 18                         load.z32
	<startsWith+53 @03d0fd>   : 57                         ceq.i32
	<startsWith+54 @03d0fe>   : 06 cf ff ff                jz <startsWith+5 @03d0cd>
	<startsWith+58 @03d102>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:41: (11 bytes: <@03d106> - <@03d111>): return bool(.result := true);
	<startsWith+62 @03d106>   : 1b 01 00 00 00             load.c32 1
	<startsWith+67 @03d10b>   : 11 14 00 00                load.sp(+20)
	<startsWith+71 @03d10f>   : 25                         store.i8
	<startsWith+72 @03d110>   : 03                         ret
.references:
	lib/std/string.ci:88: referenced as `startsWith`
	lib/std/string.ci:35: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 131
.offset: <@03d118>
.name: 'endsWith'
.file: 'lib/std/string.ci:44'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (131 bytes: <@03d118> - <@03d19b>)
	lib/std/string.ci:45: (13 bytes: <@03d118> - <@03d125>): withLen: int32 := length(with)
	<endsWith @03d118>      : 18                         load.z32
	<endsWith+1 @03d119>    : 12 03                      dup.x1 sp(3)
	<endsWith+3 @03d11b>    : 1f 18 d0 03 00             load.ref <@03d018> ;length(str: char[*]): int32
	<endsWith+8 @03d120>    : 02                         call
	<endsWith+9 @03d121>    : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:46: (13 bytes: <@03d125> - <@03d132>): strLen: int32 := length(str)
	<endsWith+13 @03d125>   : 18                         load.z32
	<endsWith+14 @03d126>   : 12 05                      dup.x1 sp(5)
	<endsWith+16 @03d128>   : 1f 18 d0 03 00             load.ref <@03d018> ;length(str: char[*]): int32
	<endsWith+21 @03d12d>   : 02                         call
	<endsWith+22 @03d12e>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:47: (20 bytes: <@03d132> - <@03d146>): if (bool(strLen < withLen))
	<endsWith+26 @03d132>   : 12 00                      dup.x1 sp(0)
	<endsWith+28 @03d134>   : 12 02                      dup.x1 sp(2)
	<endsWith+30 @03d136>   : 58                         clt.i32
	<endsWith+31 @03d137>   : 06 0f 00 00                jz <endsWith+46 @03d146>
	lib/std/string.ci:48: (11 bytes: <@03d13b> - <@03d146>): return bool(.result := false);
	<endsWith+35 @03d13b>   : 18                         load.z32
	<endsWith+36 @03d13c>   : 11 1c 00 00                load.sp(+28)
	<endsWith+40 @03d140>   : 25                         store.i8
	<endsWith+41 @03d141>   : 10 f8 ff ff                inc.sp(-8)
	<endsWith+45 @03d145>   : 03                         ret
	lib/std/string.ci:50: (65 bytes: <@03d146> - <@03d187>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @03d146>   : 18                         load.z32
	<endsWith+47 @03d147>   : 04 33 00 00                jmp <endsWith+98 @03d17a>
	lib/std/string.ci:51: (43 bytes: <@03d14b> - <@03d176>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @03d14b>   : 18                         load.z32
	<endsWith+52 @03d14c>   : 12 07                      dup.x1 sp(7)
	<endsWith+54 @03d14e>   : 12 03                      dup.x1 sp(3)
	<endsWith+56 @03d150>   : 12 05                      dup.x1 sp(5)
	<endsWith+58 @03d152>   : 52                         sub.i32
	<endsWith+59 @03d153>   : 12 03                      dup.x1 sp(3)
	<endsWith+61 @03d155>   : 51                         add.i32
	<endsWith+62 @03d156>   : 51                         add.i32
	<endsWith+63 @03d157>   : 20                         load.i8
	<endsWith+64 @03d158>   : 12 07                      dup.x1 sp(7)
	<endsWith+66 @03d15a>   : 12 03                      dup.x1 sp(3)
	<endsWith+68 @03d15c>   : 51                         add.i32
	<endsWith+69 @03d15d>   : 20                         load.i8
	<endsWith+70 @03d15e>   : 12 07                      dup.x1 sp(7)
	<endsWith+72 @03d160>   : 02                         call
	<endsWith+73 @03d161>   : 10 f8 ff ff                inc.sp(-8)
	<endsWith+77 @03d165>   : 18                         load.z32
	<endsWith+78 @03d166>   : 57                         ceq.i32
	<endsWith+79 @03d167>   : 05 0f 00 00                jnz <endsWith+94 @03d176>
	lib/std/string.ci:52: (11 bytes: <@03d16b> - <@03d176>): return bool(.result := false);
	<endsWith+83 @03d16b>   : 18                         load.z32
	<endsWith+84 @03d16c>   : 11 20 00 00                load.sp(+32)
	<endsWith+88 @03d170>   : 25                         store.i8
	<endsWith+89 @03d171>   : 10 f4 ff ff                inc.sp(-12)
	<endsWith+93 @03d175>   : 03                         ret
	lib/std/string.ci:50: (4 bytes: <@03d176> - <@03d17a>): int32(i := int32(i + 1))
	<endsWith+94 @03d176>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:50: (9 bytes: <@03d17a> - <@03d183>): bool(i < withLen)
	<endsWith+98 @03d17a>   : 12 00                      dup.x1 sp(0)
	<endsWith+100 @03d17c>  : 12 03                      dup.x1 sp(3)
	<endsWith+102 @03d17e>  : 58                         clt.i32
	<endsWith+103 @03d17f>  : 05 cc ff ff                jnz <endsWith+51 @03d14b>
	<endsWith+107 @03d183>  : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:55: (15 bytes: <@03d187> - <@03d196>): return bool(.result := true);
	<endsWith+111 @03d187>  : 1b 01 00 00 00             load.c32 1
	<endsWith+116 @03d18c>  : 11 1c 00 00                load.sp(+28)
	<endsWith+120 @03d190>  : 25                         store.i8
	<endsWith+121 @03d191>  : 10 f8 ff ff                inc.sp(-8)
	<endsWith+125 @03d195>  : 03                         ret
	<endsWith+126 @03d196>  : 10 f8 ff ff                inc.sp(-8)
	<endsWith+130 @03d19a>  : 03                         ret
.references:
	lib/std/string.ci:89: referenced as `endsWith`
	lib/std/string.ci:44: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 74
.offset: <@03d1a0>
.name: 'compare'
.file: 'lib/std/string.ci:58'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (74 bytes: <@03d1a0> - <@03d1ea>)
	lib/std/string.ci:59: (1 byte: <@03d1a0> - <@03d1a1>): result: int32 := 0
	<compare @03d1a0>      : 18                         load.z32
	lib/std/string.ci:60: (59 bytes: <@03d1a1> - <@03d1dc>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @03d1a1>    : 18                         load.z32
	<compare+2 @03d1a2>    : 04 2e 00 00                jmp <compare+48 @03d1d0>
	lib/std/string.ci:61: (22 bytes: <@03d1a6> - <@03d1bc>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @03d1a6>    : 18                         load.z32
	<compare+7 @03d1a7>    : 12 06                      dup.x1 sp(6)
	<compare+9 @03d1a9>    : 12 02                      dup.x1 sp(2)
	<compare+11 @03d1ab>   : 51                         add.i32
	<compare+12 @03d1ac>   : 20                         load.i8
	<compare+13 @03d1ad>   : 12 06                      dup.x1 sp(6)
	<compare+15 @03d1af>   : 12 03                      dup.x1 sp(3)
	<compare+17 @03d1b1>   : 51                         add.i32
	<compare+18 @03d1b2>   : 20                         load.i8
	<compare+19 @03d1b3>   : 12 06                      dup.x1 sp(6)
	<compare+21 @03d1b5>   : 02                         call
	<compare+22 @03d1b6>   : 10 f8 ff ff                inc.sp(-8)
	<compare+26 @03d1ba>   : 15 02                      set.x1 sp(2)
	lib/std/string.ci:62: (16 bytes: <@03d1bc> - <@03d1cc>): if (bool((str[i]) == 0))
	<compare+28 @03d1bc>   : 12 05                      dup.x1 sp(5)
	<compare+30 @03d1be>   : 12 01                      dup.x1 sp(1)
	<compare+32 @03d1c0>   : 51                         add.i32
	<compare+33 @03d1c1>   : 20                         load.i8
	<compare+34 @03d1c2>   : 18                         load.z32
	<compare+35 @03d1c3>   : 57                         ceq.i32
	<compare+36 @03d1c4>   : 06 08 00 00                jz <compare+44 @03d1cc>
	lib/std/string.ci:63: (4 bytes: <@03d1c8> - <@03d1cc>): break;
	<compare+40 @03d1c8>   : 04 10 00 00                jmp <compare+56 @03d1d8>
	lib/std/string.ci:60: (4 bytes: <@03d1cc> - <@03d1d0>): int32(i := int32(i + 1))
	<compare+44 @03d1cc>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:60: (8 bytes: <@03d1d0> - <@03d1d8>): bool(result == 0)
	<compare+48 @03d1d0>   : 12 01                      dup.x1 sp(1)
	<compare+50 @03d1d2>   : 18                         load.z32
	<compare+51 @03d1d3>   : 57                         ceq.i32
	<compare+52 @03d1d4>   : 05 d2 ff ff                jnz <compare+6 @03d1a6>
	<compare+56 @03d1d8>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:66: (9 bytes: <@03d1dc> - <@03d1e5>): return int32(.result := result);
	<compare+60 @03d1dc>   : 12 00                      dup.x1 sp(0)
	<compare+62 @03d1de>   : 15 06                      set.x1 sp(6)
	<compare+64 @03d1e0>   : 10 fc ff ff                inc.sp(-4)
	<compare+68 @03d1e4>   : 03                         ret
	<compare+69 @03d1e5>   : 10 fc ff ff                inc.sp(-4)
	<compare+73 @03d1e9>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `compare`
	lib/std/string.ci:58: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@03d238>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:70'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@03d238> - <@03d25c>)
	lib/std/string.ci:81: (36 bytes: <@03d238> - <@03d25c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @03d238>      : 18                         load.z32
	<ignCaseCmp+1 @03d239>    : 11 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @03d23d>    : 20                         load.i8
	<ignCaseCmp+6 @03d23e>    : 1f f0 d1 03 00             load.ref <@03d1f0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @03d243>   : 02                         call
	<ignCaseCmp+12 @03d244>   : 10 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @03d248>   : 18                         load.z32
	<ignCaseCmp+17 @03d249>   : 11 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @03d24d>   : 20                         load.i8
	<ignCaseCmp+22 @03d24e>   : 1f f0 d1 03 00             load.ref <@03d1f0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @03d253>   : 02                         call
	<ignCaseCmp+28 @03d254>   : 10 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @03d258>   : 52                         sub.i32
	<ignCaseCmp+33 @03d259>   : 15 04                      set.x1 sp(4)
	<ignCaseCmp+35 @03d25b>   : 03                         ret
.references:
	lib/std/string.ci:70: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@03d260>
.name: 'caseCmp'
.file: 'lib/std/string.ci:84'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@03d260> - <@03d26e>)
	lib/std/string.ci:85: (14 bytes: <@03d260> - <@03d26e>): return char(.result := char(chr - with));
	<caseCmp @03d260>      : 11 08 00 00                load.sp(+8)
	<caseCmp+4 @03d264>    : 20                         load.i8
	<caseCmp+5 @03d265>    : 11 08 00 00                load.sp(+8)
	<caseCmp+9 @03d269>    : 20                         load.i8
	<caseCmp+10 @03d26a>   : 52                         sub.i32
	<caseCmp+11 @03d26b>   : 15 04                      set.x1 sp(4)
	<caseCmp+13 @03d26d>   : 03                         ret
.references:
	lib/std/string.ci:90: referenced as `caseCmp`
	lib/std/string.ci:89: referenced as `caseCmp`
	lib/std/string.ci:88: referenced as `caseCmp`
	lib/std/string.ci:84: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:88'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:88: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:89'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:89: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:90'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.references:
	lib/std/string.ci:90: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.value: bool(indexOf(void(str, chr)) >= 0)
.references:
	lib/std/string.ci:158: referenced as `contains`
	lib/std/string.ci:92: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01c5a8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:106'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.references:
	lib/std/string.ci:206: referenced as `FormatFlags`
	lib/std/string.ci:196: referenced as `FormatFlags`
	lib/std/string.ci:192: referenced as `FormatFlags`
	lib/std/string.ci:129: referenced as `FormatFlags`
	lib/std/string.ci:106: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:107'
.owner: FormatFlags
.value: 10
.references:
	lib/std/string.ci:136: referenced as `radix`
	lib/std/string.ci:107: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:108'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:150: referenced as `padChr`
	lib/std/string.ci:108: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:109'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:148: referenced as `padLen`
	lib/std/string.ci:109: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:110'
.owner: FormatFlags
.value: 0
.references:
	lib/std/string.ci:110: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 85
.offset: <@03d270>
.name: 'append'
.file: 'lib/std/string.ci:113'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (85 bytes: <@03d270> - <@03d2c5>)
	lib/std/string.ci:114: (56 bytes: <@03d270> - <@03d2a8>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @03d270>      : 18                         load.z32
	<append+1 @03d271>    : 04 29 00 00                jmp <append+42 @03d29a>
	lib/std/string.ci:115: (13 bytes: <@03d275> - <@03d282>): if (bool(pos >= (output.length)))
	<append+5 @03d275>    : 12 03                      dup.x1 sp(3)
	<append+7 @03d277>    : 12 06                      dup.x1 sp(6)
	<append+9 @03d279>    : 58                         clt.i32
	<append+10 @03d27a>   : 05 08 00 00                jnz <append+18 @03d282>
	lib/std/string.ci:116: (4 bytes: <@03d27e> - <@03d282>): break;
	<append+14 @03d27e>   : 04 26 00 00                jmp <append+52 @03d2a4>
	lib/std/string.ci:118: (12 bytes: <@03d282> - <@03d28e>): char(output[pos] := value[i]);
	<append+18 @03d282>   : 12 02                      dup.x1 sp(2)
	<append+20 @03d284>   : 12 01                      dup.x1 sp(1)
	<append+22 @03d286>   : 51                         add.i32
	<append+23 @03d287>   : 20                         load.i8
	<append+24 @03d288>   : 12 05                      dup.x1 sp(5)
	<append+26 @03d28a>   : 12 05                      dup.x1 sp(5)
	<append+28 @03d28c>   : 51                         add.i32
	<append+29 @03d28d>   : 25                         store.i8
	lib/std/string.ci:119: (8 bytes: <@03d28e> - <@03d296>): int32(pos := int32(pos + 1));
	<append+30 @03d28e>   : 12 03                      dup.x1 sp(3)
	<append+32 @03d290>   : 0b 01 00 00                inc.i32(+1)
	<append+36 @03d294>   : 15 04                      set.x1 sp(4)
	lib/std/string.ci:114: (4 bytes: <@03d296> - <@03d29a>): int32(i := int32(i + 1))
	<append+38 @03d296>   : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:114: (10 bytes: <@03d29a> - <@03d2a4>): value[i]
	<append+42 @03d29a>   : 12 02                      dup.x1 sp(2)
	<append+44 @03d29c>   : 12 01                      dup.x1 sp(1)
	<append+46 @03d29e>   : 51                         add.i32
	<append+47 @03d29f>   : 20                         load.i8
	<append+48 @03d2a0>   : 05 d5 ff ff                jnz <append+5 @03d275>
	<append+52 @03d2a4>   : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:122: (17 bytes: <@03d2a8> - <@03d2b9>): if (bool(pos >= (output.length)))
	<append+56 @03d2a8>   : 12 02                      dup.x1 sp(2)
	<append+58 @03d2aa>   : 12 05                      dup.x1 sp(5)
	<append+60 @03d2ac>   : 58                         clt.i32
	<append+61 @03d2ad>   : 05 0c 00 00                jnz <append+73 @03d2b9>
	lib/std/string.ci:123: (8 bytes: <@03d2b1> - <@03d2b9>): int32(pos := (uint32(output.length - (1))));
	<append+65 @03d2b1>   : 12 04                      dup.x1 sp(4)
	<append+67 @03d2b3>   : 0b ff ff ff                inc.i32(-1)
	<append+71 @03d2b7>   : 15 03                      set.x1 sp(3)
	lib/std/string.ci:125: (7 bytes: <@03d2b9> - <@03d2c0>): char(output[pos] := (0));
	<append+73 @03d2b9>   : 18                         load.z32
	<append+74 @03d2ba>   : 12 04                      dup.x1 sp(4)
	<append+76 @03d2bc>   : 12 04                      dup.x1 sp(4)
	<append+78 @03d2be>   : 51                         add.i32
	<append+79 @03d2bf>   : 25                         store.i8
	lib/std/string.ci:126: (5 bytes: <@03d2c0> - <@03d2c5>): return int32(.result := pos);
	<append+80 @03d2c0>   : 12 02                      dup.x1 sp(2)
	<append+82 @03d2c2>   : 15 06                      set.x1 sp(6)
	<append+84 @03d2c4>   : 03                         ret
.references:
	lib/std/string.ci:113: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 663
.offset: <@03d2d8>
.name: 'append'
.file: 'lib/std/string.ci:129'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (663 bytes: <@03d2d8> - <@03d56f>)
	lib/std/string.ci:133: (1 byte: <@03d2d8> - <@03d2d9>): len: int32 := 0
	<append @03d2d8>      : 18                         load.z32
	lib/std/string.ci:134: (4 bytes: <@03d2d9> - <@03d2dd>): digits: char[80]
	<append+1 @03d2d9>    : 10 50 00 00                inc.sp(+80)
	lib/std/string.ci:136: (3 bytes: <@03d2dd> - <@03d2e0>): radix: int32 := format.radix
	<append+5 @03d2dd>    : 12 16                      dup.x1 sp(22)
	<append+7 @03d2df>    : 22                         load.i32
	lib/std/string.ci:137: (54 bytes: <@03d2e0> - <@03d316>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @03d2e0>    : 12 00                      dup.x1 sp(0)
	<append+10 @03d2e2>   : 1b 01 00 00 00             load.c32 1
	<append+15 @03d2e7>   : 59                         cgt.i32
	<append+16 @03d2e8>   : 06 08 00 00                jz <append+24 @03d2f0>
	<append+20 @03d2ec>   : 04 2a 00 00                jmp <append+62 @03d316>
	<append+24 @03d2f0>   : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+29 @03d2f5>   : 1b 89 00 00 00             load.c32 137
	<append+34 @03d2fa>   : 1b fe ff ff ff             load.c32 -2
	<append+39 @03d2ff>   : 1b 80 00 00 00             load.c32 128
	<append+44 @03d304>   : 1f b9 96 01 00             load.ref <@0196b9> ;"radix is too small"
	<append+49 @03d309>   : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+54 @03d30e>   : 11 18 00 00                load.sp(+24)
	<append+58 @03d312>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:138: (53 bytes: <@03d316> - <@03d34b>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @03d316>   : 12 00                      dup.x1 sp(0)
	<append+64 @03d318>   : 2a d4 d2 03                load.m32 <@03d2d4> ;append.radixDigits+4
	<append+68 @03d31c>   : 58                         clt.i32
	<append+69 @03d31d>   : 06 08 00 00                jz <append+77 @03d325>
	<append+73 @03d321>   : 04 2a 00 00                jmp <append+115 @03d34b>
	<append+77 @03d325>   : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+82 @03d32a>   : 1b 8a 00 00 00             load.c32 138
	<append+87 @03d32f>   : 1b fe ff ff ff             load.c32 -2
	<append+92 @03d334>   : 1b 80 00 00 00             load.c32 128
	<append+97 @03d339>   : 1f cc 96 01 00             load.ref <@0196cc> ;"radix is too big"
	<append+102 @03d33e>  : 1f 70 03 00 00             load.ref <@000370> ;int32
	<append+107 @03d343>  : 11 18 00 00                load.sp(+24)
	<append+111 @03d347>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:141: (46 bytes: <@03d34b> - <@03d379>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @03d34b>  : 04 26 00 00                jmp <append+153 @03d371>
	lib/std/string.ci:142: (27 bytes: <@03d34f> - <@03d36a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @03d34f>  : 2a d0 d2 03                load.m32 <@03d2d0> ;append.radixDigits
	<append+123 @03d353>  : 12 19                      dup.x1 sp(25)
	<append+125 @03d355>  : 12 02                      dup.x1 sp(2)
	<append+127 @03d357>  : 35                         mod.u32
	<append+128 @03d358>  : 51                         add.i32
	<append+129 @03d359>  : 20                         load.i8
	<append+130 @03d35a>  : 11 08 00 00                load.sp(+8)
	<append+134 @03d35e>  : 12 17                      dup.x1 sp(23)
	<append+136 @03d360>  : 0b 01 00 00                inc.i32(+1)
	<append+140 @03d364>  : 12 00                      dup.x1 sp(0)
	<append+142 @03d366>  : 15 19                      set.x1 sp(25)
	<append+144 @03d368>  : 51                         add.i32
	<append+145 @03d369>  : 25                         store.i8
	lib/std/string.ci:141: (7 bytes: <@03d36a> - <@03d371>): uint32(value := uint32(value / (radix)))
	<append+146 @03d36a>  : 12 18                      dup.x1 sp(24)
	<append+148 @03d36c>  : 12 01                      dup.x1 sp(1)
	<append+150 @03d36e>  : 34                         div.u32
	<append+151 @03d36f>  : 15 19                      set.x1 sp(25)
	lib/std/string.ci:141: (8 bytes: <@03d371> - <@03d379>): bool(value > (0))
	<append+153 @03d371>  : 12 18                      dup.x1 sp(24)
	<append+155 @03d373>  : 18                         load.z32
	<append+156 @03d374>  : 39                         cgt.u32
	<append+157 @03d375>  : 05 da ff ff                jnz <append+119 @03d34f>
	lib/std/string.ci:144: (29 bytes: <@03d379> - <@03d396>): if (bool(len == 0))
	<append+161 @03d379>  : 12 15                      dup.x1 sp(21)
	<append+163 @03d37b>  : 18                         load.z32
	<append+164 @03d37c>  : 57                         ceq.i32
	<append+165 @03d37d>  : 06 19 00 00                jz <append+190 @03d396>
	lib/std/string.ci:145: (21 bytes: <@03d381> - <@03d396>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @03d381>  : 1b 30 00 00 00             load.c32 48
	<append+174 @03d386>  : 11 08 00 00                load.sp(+8)
	<append+178 @03d38a>  : 12 17                      dup.x1 sp(23)
	<append+180 @03d38c>  : 0b 01 00 00                inc.i32(+1)
	<append+184 @03d390>  : 12 00                      dup.x1 sp(0)
	<append+186 @03d392>  : 15 19                      set.x1 sp(25)
	<append+188 @03d394>  : 51                         add.i32
	<append+189 @03d395>  : 25                         store.i8
	lib/std/string.ci:148: (10 bytes: <@03d396> - <@03d3a0>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @03d396>  : 12 17                      dup.x1 sp(23)
	<append+192 @03d398>  : 0b 08 00 00                inc.i32(+8)
	<append+196 @03d39c>  : 22                         load.i32
	<append+197 @03d39d>  : 12 16                      dup.x1 sp(22)
	<append+199 @03d39f>  : 52                         sub.i32
	lib/std/string.ci:150: (7 bytes: <@03d3a0> - <@03d3a7>): padChr: char := format.padChr
	<append+200 @03d3a0>  : 12 18                      dup.x1 sp(24)
	<append+202 @03d3a2>  : 0b 04 00 00                inc.i32(+4)
	<append+206 @03d3a6>  : 20                         load.i8
	lib/std/string.ci:151: (21 bytes: <@03d3a7> - <@03d3bc>): if (bool(padChr == ''))
	<append+207 @03d3a7>  : 11 00 00 00                load.sp(+0)
	<append+211 @03d3ab>  : 20                         load.i8
	<append+212 @03d3ac>  : 18                         load.z32
	<append+213 @03d3ad>  : 57                         ceq.i32
	<append+214 @03d3ae>  : 06 0e 00 00                jz <append+228 @03d3bc>
	lib/std/string.ci:152: (10 bytes: <@03d3b2> - <@03d3bc>): char(padChr := ' ');
	<append+218 @03d3b2>  : 1b 20 00 00 00             load.c32 32
	<append+223 @03d3b7>  : 11 04 00 00                load.sp(+4)
	<append+227 @03d3bb>  : 25                         store.i8
	lib/std/string.ci:156: (207 bytes: <@03d3bc> - <@03d48b>): if (bool((sign) != 0))
	<append+228 @03d3bc>  : 11 6c 00 00                load.sp(+108)
	<append+232 @03d3c0>  : 20                         load.i8
	<append+233 @03d3c1>  : 18                         load.z32
	<append+234 @03d3c2>  : 57                         ceq.i32
	<append+235 @03d3c3>  : 05 c8 00 00                jnz <append+435 @03d48b>
	lib/std/string.ci:157: (8 bytes: <@03d3c7> - <@03d3cf>): int32(maxLen := int32(maxLen - 1));
	<append+239 @03d3c7>  : 12 01                      dup.x1 sp(1)
	<append+241 @03d3c9>  : 0b ff ff ff                inc.i32(-1)
	<append+245 @03d3cd>  : 15 02                      set.x1 sp(2)
	lib/std/string.ci:158: (117 bytes: <@03d3cf> - <@03d444>): if (contains(void(whiteSpace, padChr)))
	<append+247 @03d3cf>  : 18                         load.z32
	<append+248 @03d3d0>  : 2a c8 d2 03                load.m32 <@03d2c8> ;append.whiteSpace
	<append+252 @03d3d4>  : 11 08 00 00                load.sp(+8)
	<append+256 @03d3d8>  : 20                         load.i8
	<append+257 @03d3d9>  : 1f 50 d0 03 00             load.ref <@03d050> ;indexOf(str: char[*], chr: char): int32
	<append+262 @03d3de>  : 02                         call
	<append+263 @03d3df>  : 10 f8 ff ff                inc.sp(-8)
	<append+267 @03d3e3>  : 18                         load.z32
	<append+268 @03d3e4>  : 58                         clt.i32
	<append+269 @03d3e5>  : 05 5f 00 00                jnz <append+364 @03d444>
	lib/std/string.ci:160: (91 bytes: <@03d3e9> - <@03d444>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @03d3e9>  : 04 53 00 00                jmp <append+356 @03d43c>
	lib/std/string.ci:161: (52 bytes: <@03d3ed> - <@03d421>): assert(bool(pos < (output.length)));
	<append+277 @03d3ed>  : 12 1c                      dup.x1 sp(28)
	<append+279 @03d3ef>  : 12 1f                      dup.x1 sp(31)
	<append+281 @03d3f1>  : 58                         clt.i32
	<append+282 @03d3f2>  : 06 08 00 00                jz <append+290 @03d3fa>
	<append+286 @03d3f6>  : 04 2b 00 00                jmp <append+329 @03d421>
	<append+290 @03d3fa>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+295 @03d3ff>  : 1b a1 00 00 00             load.c32 161
	<append+300 @03d404>  : 1b fe ff ff ff             load.c32 -2
	<append+305 @03d409>  : 1b 80 00 00 00             load.c32 128
	<append+310 @03d40e>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+315 @03d413>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+320 @03d418>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @03d41d>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:162: (11 bytes: <@03d421> - <@03d42c>): char(output[pos] := padChr);
	<append+329 @03d421>  : 11 00 00 00                load.sp(+0)
	<append+333 @03d425>  : 20                         load.i8
	<append+334 @03d426>  : 12 1e                      dup.x1 sp(30)
	<append+336 @03d428>  : 12 1e                      dup.x1 sp(30)
	<append+338 @03d42a>  : 51                         add.i32
	<append+339 @03d42b>  : 25                         store.i8
	lib/std/string.ci:163: (8 bytes: <@03d42c> - <@03d434>): int32(pos := int32(pos + 1));
	<append+340 @03d42c>  : 12 1c                      dup.x1 sp(28)
	<append+342 @03d42e>  : 0b 01 00 00                inc.i32(+1)
	<append+346 @03d432>  : 15 1d                      set.x1 sp(29)
	lib/std/string.ci:160: (8 bytes: <@03d434> - <@03d43c>): int32(maxLen := int32(maxLen - 1))
	<append+348 @03d434>  : 12 01                      dup.x1 sp(1)
	<append+350 @03d436>  : 0b ff ff ff                inc.i32(-1)
	<append+354 @03d43a>  : 15 02                      set.x1 sp(2)
	lib/std/string.ci:160: (8 bytes: <@03d43c> - <@03d444>): bool(maxLen > 0)
	<append+356 @03d43c>  : 12 01                      dup.x1 sp(1)
	<append+358 @03d43e>  : 18                         load.z32
	<append+359 @03d43f>  : 59                         cgt.i32
	<append+360 @03d440>  : 05 ad ff ff                jnz <append+277 @03d3ed>
	lib/std/string.ci:166: (52 bytes: <@03d444> - <@03d478>): assert(bool(pos < (output.length)));
	<append+364 @03d444>  : 12 1c                      dup.x1 sp(28)
	<append+366 @03d446>  : 12 1f                      dup.x1 sp(31)
	<append+368 @03d448>  : 58                         clt.i32
	<append+369 @03d449>  : 06 08 00 00                jz <append+377 @03d451>
	<append+373 @03d44d>  : 04 2b 00 00                jmp <append+416 @03d478>
	<append+377 @03d451>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+382 @03d456>  : 1b a6 00 00 00             load.c32 166
	<append+387 @03d45b>  : 1b fe ff ff ff             load.c32 -2
	<append+392 @03d460>  : 1b 80 00 00 00             load.c32 128
	<append+397 @03d465>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+402 @03d46a>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+407 @03d46f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @03d474>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:167: (11 bytes: <@03d478> - <@03d483>): char(output[pos] := sign);
	<append+416 @03d478>  : 11 6c 00 00                load.sp(+108)
	<append+420 @03d47c>  : 20                         load.i8
	<append+421 @03d47d>  : 12 1e                      dup.x1 sp(30)
	<append+423 @03d47f>  : 12 1e                      dup.x1 sp(30)
	<append+425 @03d481>  : 51                         add.i32
	<append+426 @03d482>  : 25                         store.i8
	lib/std/string.ci:168: (8 bytes: <@03d483> - <@03d48b>): int32(pos := int32(pos + 1));
	<append+427 @03d483>  : 12 1c                      dup.x1 sp(28)
	<append+429 @03d485>  : 0b 01 00 00                inc.i32(+1)
	<append+433 @03d489>  : 15 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (91 bytes: <@03d48b> - <@03d4e6>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @03d48b>  : 04 53 00 00                jmp <append+518 @03d4de>
	lib/std/string.ci:173: (52 bytes: <@03d48f> - <@03d4c3>): assert(bool(pos < (output.length)));
	<append+439 @03d48f>  : 12 1c                      dup.x1 sp(28)
	<append+441 @03d491>  : 12 1f                      dup.x1 sp(31)
	<append+443 @03d493>  : 58                         clt.i32
	<append+444 @03d494>  : 06 08 00 00                jz <append+452 @03d49c>
	<append+448 @03d498>  : 04 2b 00 00                jmp <append+491 @03d4c3>
	<append+452 @03d49c>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+457 @03d4a1>  : 1b ad 00 00 00             load.c32 173
	<append+462 @03d4a6>  : 1b fe ff ff ff             load.c32 -2
	<append+467 @03d4ab>  : 1b 80 00 00 00             load.c32 128
	<append+472 @03d4b0>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+477 @03d4b5>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+482 @03d4ba>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @03d4bf>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:174: (11 bytes: <@03d4c3> - <@03d4ce>): char(output[pos] := padChr);
	<append+491 @03d4c3>  : 11 00 00 00                load.sp(+0)
	<append+495 @03d4c7>  : 20                         load.i8
	<append+496 @03d4c8>  : 12 1e                      dup.x1 sp(30)
	<append+498 @03d4ca>  : 12 1e                      dup.x1 sp(30)
	<append+500 @03d4cc>  : 51                         add.i32
	<append+501 @03d4cd>  : 25                         store.i8
	lib/std/string.ci:175: (8 bytes: <@03d4ce> - <@03d4d6>): int32(pos := int32(pos + 1));
	<append+502 @03d4ce>  : 12 1c                      dup.x1 sp(28)
	<append+504 @03d4d0>  : 0b 01 00 00                inc.i32(+1)
	<append+508 @03d4d4>  : 15 1d                      set.x1 sp(29)
	lib/std/string.ci:172: (8 bytes: <@03d4d6> - <@03d4de>): int32(maxLen := int32(maxLen - 1))
	<append+510 @03d4d6>  : 12 01                      dup.x1 sp(1)
	<append+512 @03d4d8>  : 0b ff ff ff                inc.i32(-1)
	<append+516 @03d4dc>  : 15 02                      set.x1 sp(2)
	lib/std/string.ci:172: (8 bytes: <@03d4de> - <@03d4e6>): bool(maxLen > 0)
	<append+518 @03d4de>  : 12 01                      dup.x1 sp(1)
	<append+520 @03d4e0>  : 18                         load.z32
	<append+521 @03d4e1>  : 59                         cgt.i32
	<append+522 @03d4e2>  : 05 ad ff ff                jnz <append+439 @03d48f>
	lib/std/string.ci:179: (99 bytes: <@03d4e6> - <@03d549>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @03d4e6>  : 18                         load.z32
	<append+527 @03d4e7>  : 04 55 00 00                jmp <append+612 @03d53c>
	lib/std/string.ci:180: (52 bytes: <@03d4eb> - <@03d51f>): assert(bool(i < (output.length)));
	<append+531 @03d4eb>  : 12 00                      dup.x1 sp(0)
	<append+533 @03d4ed>  : 12 20                      dup.x1 sp(32)
	<append+535 @03d4ef>  : 58                         clt.i32
	<append+536 @03d4f0>  : 06 08 00 00                jz <append+544 @03d4f8>
	<append+540 @03d4f4>  : 04 2b 00 00                jmp <append+583 @03d51f>
	<append+544 @03d4f8>  : 1f a8 95 01 00             load.ref <@0195a8> ;"lib/std/string.ci"
	<append+549 @03d4fd>  : 1b b4 00 00 00             load.c32 180
	<append+554 @03d502>  : 1b fe ff ff ff             load.c32 -2
	<append+559 @03d507>  : 1b 80 00 00 00             load.c32 128
	<append+564 @03d50c>  : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<append+569 @03d511>  : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<append+574 @03d516>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @03d51b>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (17 bytes: <@03d51f> - <@03d530>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @03d51f>  : 11 10 00 00                load.sp(+16)
	<append+587 @03d523>  : 12 19                      dup.x1 sp(25)
	<append+589 @03d525>  : 12 02                      dup.x1 sp(2)
	<append+591 @03d527>  : 52                         sub.i32
	<append+592 @03d528>  : 51                         add.i32
	<append+593 @03d529>  : 20                         load.i8
	<append+594 @03d52a>  : 12 1f                      dup.x1 sp(31)
	<append+596 @03d52c>  : 12 1f                      dup.x1 sp(31)
	<append+598 @03d52e>  : 51                         add.i32
	<append+599 @03d52f>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@03d530> - <@03d538>): int32(pos := int32(pos + 1));
	<append+600 @03d530>  : 12 1d                      dup.x1 sp(29)
	<append+602 @03d532>  : 0b 01 00 00                inc.i32(+1)
	<append+606 @03d536>  : 15 1e                      set.x1 sp(30)
	lib/std/string.ci:179: (4 bytes: <@03d538> - <@03d53c>): int32(i := int32(i + 1))
	<append+608 @03d538>  : 0b 01 00 00                inc.i32(+1)
	lib/std/string.ci:179: (9 bytes: <@03d53c> - <@03d545>): bool(i < len)
	<append+612 @03d53c>  : 12 00                      dup.x1 sp(0)
	<append+614 @03d53e>  : 12 19                      dup.x1 sp(25)
	<append+616 @03d540>  : 58                         clt.i32
	<append+617 @03d541>  : 05 aa ff ff                jnz <append+531 @03d4eb>
	<append+621 @03d545>  : 10 fc ff ff                inc.sp(-4)
	lib/std/string.ci:185: (17 bytes: <@03d549> - <@03d55a>): if (bool(pos >= (output.length)))
	<append+625 @03d549>  : 12 1c                      dup.x1 sp(28)
	<append+627 @03d54b>  : 12 1f                      dup.x1 sp(31)
	<append+629 @03d54d>  : 58                         clt.i32
	<append+630 @03d54e>  : 05 0c 00 00                jnz <append+642 @03d55a>
	lib/std/string.ci:186: (8 bytes: <@03d552> - <@03d55a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @03d552>  : 12 1e                      dup.x1 sp(30)
	<append+636 @03d554>  : 0b ff ff ff                inc.i32(-1)
	<append+640 @03d558>  : 15 1d                      set.x1 sp(29)
	lib/std/string.ci:188: (7 bytes: <@03d55a> - <@03d561>): char(output[pos] := (0));
	<append+642 @03d55a>  : 18                         load.z32
	<append+643 @03d55b>  : 12 1e                      dup.x1 sp(30)
	<append+645 @03d55d>  : 12 1e                      dup.x1 sp(30)
	<append+647 @03d55f>  : 51                         add.i32
	<append+648 @03d560>  : 25                         store.i8
	lib/std/string.ci:189: (9 bytes: <@03d561> - <@03d56a>): return int32(.result := pos);
	<append+649 @03d561>  : 12 1c                      dup.x1 sp(28)
	<append+651 @03d563>  : 15 20                      set.x1 sp(32)
	<append+653 @03d565>  : 10 a0 ff ff                inc.sp(-96)
	<append+657 @03d569>  : 03                         ret
	<append+658 @03d56a>  : 10 a0 ff ff                inc.sp(-96)
	<append+662 @03d56e>  : 03                         ret
.references:
	lib/std/string.ci:202: referenced as `append`
	lib/std/string.ci:193: referenced as `append`
	lib/std/string.ci:129: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@03d570>
.name: 'append'
.file: 'lib/std/string.ci:192'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@03d570> - <@03d587>)
	lib/std/string.ci:193: (23 bytes: <@03d570> - <@03d587>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @03d570>      : 18                         load.z32
	<append+1 @03d571>    : 13 05                      dup.x2 sp(5)
	<append+3 @03d573>    : 12 06                      dup.x1 sp(6)
	<append+5 @03d575>    : 18                         load.z32
	<append+6 @03d576>    : 12 07                      dup.x1 sp(7)
	<append+8 @03d578>    : 12 07                      dup.x1 sp(7)
	<append+10 @03d57a>   : 1f d8 d2 03 00             load.ref <@03d2d8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @03d57f>   : 02                         call
	<append+16 @03d580>   : 10 e8 ff ff                inc.sp(-24)
	<append+20 @03d584>   : 15 07                      set.x1 sp(7)
	<append+22 @03d586>   : 03                         ret
.references:
	lib/std/string.ci:207: referenced as `append`
	lib/std/string.ci:192: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@03d588>
.name: 'append'
.file: 'lib/std/string.ci:196'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (54 bytes: <@03d588> - <@03d5be>)
	lib/std/string.ci:197: (1 byte: <@03d588> - <@03d589>): sign: int32 := 0
	<append @03d588>      : 18                         load.z32
	lib/std/string.ci:198: (20 bytes: <@03d589> - <@03d59d>): if (bool(value < 0))
	<append+1 @03d589>    : 12 03                      dup.x1 sp(3)
	<append+3 @03d58b>    : 18                         load.z32
	<append+4 @03d58c>    : 58                         clt.i32
	<append+5 @03d58d>    : 06 10 00 00                jz <append+21 @03d59d>
	lib/std/string.ci:199: (7 bytes: <@03d591> - <@03d598>): int32(sign := ('-'));
	<append+9 @03d591>    : 1b 2d 00 00 00             load.c32 45
	<append+14 @03d596>   : 15 01                      set.x1 sp(1)
	lib/std/string.ci:200: (5 bytes: <@03d598> - <@03d59d>): int32(value := int32(-value));
	<append+16 @03d598>   : 12 03                      dup.x1 sp(3)
	<append+18 @03d59a>   : 50                         neg.i32
	<append+19 @03d59b>   : 15 04                      set.x1 sp(4)
	lib/std/string.ci:202: (28 bytes: <@03d59d> - <@03d5b9>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @03d59d>   : 18                         load.z32
	<append+22 @03d59e>   : 13 06                      dup.x2 sp(6)
	<append+24 @03d5a0>   : 12 07                      dup.x1 sp(7)
	<append+26 @03d5a2>   : 12 04                      dup.x1 sp(4)
	<append+28 @03d5a4>   : 12 08                      dup.x1 sp(8)
	<append+30 @03d5a6>   : 12 08                      dup.x1 sp(8)
	<append+32 @03d5a8>   : 1f d8 d2 03 00             load.ref <@03d2d8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @03d5ad>   : 02                         call
	<append+38 @03d5ae>   : 10 e8 ff ff                inc.sp(-24)
	<append+42 @03d5b2>   : 15 08                      set.x1 sp(8)
	<append+44 @03d5b4>   : 10 fc ff ff                inc.sp(-4)
	<append+48 @03d5b8>   : 03                         ret
	<append+49 @03d5b9>   : 10 fc ff ff                inc.sp(-4)
	<append+53 @03d5bd>   : 03                         ret
.references:
	lib/std/string.ci:196: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@03d5d0>
.name: 'append'
.file: 'lib/std/string.ci:205'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@03d5d0> - <@03d5e9>)
	lib/std/string.ci:207: (25 bytes: <@03d5d0> - <@03d5e9>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @03d5d0>      : 18                         load.z32
	<append+1 @03d5d1>    : 13 04                      dup.x2 sp(4)
	<append+3 @03d5d3>    : 12 05                      dup.x1 sp(5)
	<append+5 @03d5d5>    : 12 05                      dup.x1 sp(5)
	<append+7 @03d5d7>    : 1f c0 d5 03 00             load.ref <@03d5c0> ;append.format
	<append+12 @03d5dc>   : 1f 70 d5 03 00             load.ref <@03d570> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @03d5e1>   : 02                         call
	<append+18 @03d5e2>   : 10 ec ff ff                inc.sp(-20)
	<append+22 @03d5e6>   : 15 06                      set.x1 sp(6)
	<append+24 @03d5e8>   : 03                         ret
.references:
	lib/std/string.ci:205: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.references:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.references:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.references:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.references:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.references:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.references:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.references:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'emitNfcF32'
.file: 'test/lang/emit.ci:11'
.value: emit(void(float32(float64(3.140000 / (2))), float32.sin))
.references:
	test/lang/emit.ci:11: defined as `emitNfcF32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.references:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.references:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+36>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+44>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.references:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+48>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+56>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.references:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+64>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.references:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.references:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.references:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.references:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.references:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.references:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.references:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.references:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.references:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.references:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.references:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.references:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.references:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.references:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.references:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.references:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.references:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.references:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.references:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.references:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.references:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.references:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.references:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.references:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.references:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+248>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.references:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.references:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.references:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.references:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.references:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.references:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.references:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.references:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.references:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.references:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+268>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.references:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@023a10>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.references:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@023b20>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.references:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.references:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.references:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.references:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+276>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.references:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+284>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.references:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@03d5f0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.references:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+288>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.references:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+292>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.references:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+300>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.references:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+308>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.references:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.references:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.references:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+320>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.references:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+324>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.references:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+332>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.references:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+336>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.references:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+340>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.references:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+344>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.references:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+348>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.references:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+356>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.references:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+360>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.references:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+368>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.references:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+376>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.references:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+380>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.references:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+384>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.references:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+392>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.references:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+396>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.references:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.references:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.references:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.references:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.references:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.references:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.references:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.references:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.references:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.references:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.references:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.references:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.references:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.references:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.references:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.references:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.references:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.references:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+468>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.references:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+476>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.references:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+484>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.references:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+492>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.references:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+500>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.references:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+508>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.references:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+516>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.references:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+524>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.references:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+532>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.references:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+540>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.references:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+548>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.references:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+556>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.references:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+564>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.references:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+572>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.references:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+580>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.references:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+588>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.references:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+596>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.references:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+604>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.references:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+612>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.references:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.references:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.references:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.references:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.references:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.references:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.references:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.references:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.references:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.references:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.references:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.references:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.references:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.references:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.references:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.references:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.references:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.references:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+684>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.references:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+688>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.references:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+696>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.references:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.references:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+704>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.references:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+712>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.references:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+716>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.references:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@03d5f8>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@03d5f8> - <@03d5f9>)
	<empty @03d5f8>      : 03                         ret
.references:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d600>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@03d600> - <@03d608>)
	test/lang/function.ci:7: (8 bytes: <@03d600> - <@03d608>): return int32(.result := int32(x + y));
	<funAdd @03d600>      : 12 02                      dup.x1 sp(2)
	<funAdd+2 @03d602>    : 12 02                      dup.x1 sp(2)
	<funAdd+4 @03d604>    : 51                         add.i32
	<funAdd+5 @03d605>    : 15 04                      set.x1 sp(4)
	<funAdd+7 @03d607>    : 03                         ret
.references:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+720>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.references:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+724>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.references:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+728>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.references:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+732>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+736>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.references:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+740>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.references:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+744>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.references:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d608>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d608> - <@03d610>)
	test/lang/function.ci:33: (8 bytes: <@03d608> - <@03d610>): return int32(.result := int32(x * y));
	<funMul @03d608>      : 12 02                      dup.x1 sp(2)
	<funMul+2 @03d60a>    : 12 02                      dup.x1 sp(2)
	<funMul+4 @03d60c>    : 53                         mul.i32
	<funMul+5 @03d60d>    : 15 04                      set.x1 sp(4)
	<funMul+7 @03d60f>    : 03                         ret
.references:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 55
.offset: <@03d610>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (55 bytes: <@03d610> - <@03d647>)
	test/lang/function.ci:38: (17 bytes: <@03d610> - <@03d621>): if (bool(n <= (1)))
	<fib @03d610>      : 12 01                      dup.x1 sp(1)
	<fib+2 @03d612>    : 1b 01 00 00 00             load.c32 1
	<fib+7 @03d617>    : 39                         cgt.u32
	<fib+8 @03d618>    : 05 09 00 00                jnz <fib+17 @03d621>
	test/lang/function.ci:39: (5 bytes: <@03d61c> - <@03d621>): return uint32(.result := n);
	<fib+12 @03d61c>   : 12 01                      dup.x1 sp(1)
	<fib+14 @03d61e>   : 15 03                      set.x1 sp(3)
	<fib+16 @03d620>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@03d621> - <@03d647>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+17 @03d621>   : 18                         load.z32
	<fib+18 @03d622>   : 12 02                      dup.x1 sp(2)
	<fib+20 @03d624>   : 0b ff ff ff                inc.i32(-1)
	<fib+24 @03d628>   : 1f 10 d6 03 00             load.ref <@03d610> ;fib(n: uint32): uint32
	<fib+29 @03d62d>   : 02                         call
	<fib+30 @03d62e>   : 10 fc ff ff                inc.sp(-4)
	<fib+34 @03d632>   : 18                         load.z32
	<fib+35 @03d633>   : 12 03                      dup.x1 sp(3)
	<fib+37 @03d635>   : 0b fe ff ff                inc.i32(-2)
	<fib+41 @03d639>   : 1f 10 d6 03 00             load.ref <@03d610> ;fib(n: uint32): uint32
	<fib+46 @03d63e>   : 02                         call
	<fib+47 @03d63f>   : 10 fc ff ff                inc.sp(-4)
	<fib+51 @03d643>   : 51                         add.i32
	<fib+52 @03d644>   : 15 03                      set.x1 sp(3)
	<fib+54 @03d646>   : 03                         ret
.references:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+748>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.references:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.references:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.references:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.references:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.references:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.references:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.references:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.references:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.references:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.references:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.references:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.references:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.references:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.references:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.references:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.references:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.references:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.references:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+820>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.references:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@028ee0>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.references:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.references:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@028ff0>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.references:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+824>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.references:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+828>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.references:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.references:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+836>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.references:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+840>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.references:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+844>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.references:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+848>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.references:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+852>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.references:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.references:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+860>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.references:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+864>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.references:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+868>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.references:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+872>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.references:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.references:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+880>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.references:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+884>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.references:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.references:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+892>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.references:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+900>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.references:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+908>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.references:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.references:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+916>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.references:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.references:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.references:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.references:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.references:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.references:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.references:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.references:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.references:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.references:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.references:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.references:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+984>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.references:
	test/stdc/number.ci:35: defined as `sxtB8`
}
sinF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+992>
.name: 'sinF64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:37: defined as `sinF64`
}
cosF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1000>
.name: 'cosF64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.references:
	test/stdc/number.ci:38: defined as `cosF64`
}
tanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1008>
.name: 'tanF64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.references:
	test/stdc/number.ci:39: defined as `tanF64`
}
logF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1016>
.name: 'logF64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.references:
	test/stdc/number.ci:40: defined as `logF64`
}
expF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1024>
.name: 'expF64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.references:
	test/stdc/number.ci:41: defined as `expF64`
}
powF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1032>
.name: 'powF64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.references:
	test/stdc/number.ci:42: defined as `powF64`
}
sqrtF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1040>
.name: 'sqrtF64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.references:
	test/stdc/number.ci:43: defined as `sqrtF64`
}
atanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1048>
.name: 'atanF64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.references:
	test/stdc/number.ci:44: defined as `atanF64`
}
sinF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'sinF32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:46: defined as `sinF32`
}
cosF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'cosF32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.references:
	test/stdc/number.ci:47: defined as `cosF32`
}
tanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'tanF32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.references:
	test/stdc/number.ci:48: defined as `tanF32`
}
logF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'logF32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.references:
	test/stdc/number.ci:49: defined as `logF32`
}
expF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'expF32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.references:
	test/stdc/number.ci:50: defined as `expF32`
}
powF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'powF32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.references:
	test/stdc/number.ci:51: defined as `powF32`
}
sqrtF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'sqrtF32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.references:
	test/stdc/number.ci:52: defined as `sqrtF32`
}
atanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1080>
.name: 'atanF32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.references:
	test/stdc/number.ci:53: defined as `atanF32`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.references:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.references:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.references:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1084>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.references:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1088>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.references:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1092>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.references:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1096>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.references:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1104>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.references:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1112>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.references:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@03d648>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@03d648> - <@03d649>)
	<noError @03d648>      : 03                         ret
.references:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@03d650>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@03d650> - <@03d668>)
	test/stdc/tryExec.ci:15: (4 bytes: <@03d650> - <@03d654>): data: uint8[8192]
	<stackOverflow @03d650>      : 10 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@03d654> - <@03d663>): stackOverflow(ptr);
	<stackOverflow+4 @03d654>    : 11 04 20 00                load.sp(+8196)
	<stackOverflow+8 @03d658>    : 22                         load.i32
	<stackOverflow+9 @03d659>    : 1f 50 d6 03 00             load.ref <@03d650> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @03d65e>   : 02                         call
	<stackOverflow+15 @03d65f>   : 10 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @03d663>   : 10 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @03d667>   : 03                         ret
.references:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d668>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@03d668> - <@03d674>)
	test/stdc/tryExec.ci:20: (7 bytes: <@03d668> - <@03d66f>): value: int32 := int32(3 / 0)
	<divisionByZero @03d668>      : 1b 03 00 00 00             load.c32 3
	<divisionByZero+5 @03d66d>    : 18                         load.z32
	<divisionByZero+6 @03d66e>    : 54                         div.i32
	<divisionByZero+7 @03d66f>    : 10 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @03d673>   : 03                         ret
.references:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@03d678>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@03d678> - <@03d6bc>)
	test/stdc/tryExec.ci:29: (25 bytes: <@03d678> - <@03d691>): details: NotEquals := {...}
	<abortExecution @03d678>      : 10 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@03d67c> - <@03d683>): void(details.message := ("assertion failed"));
	<abortExecution+4 @03d67c>    : 1f 29 b6 00 00             load.ref <@00b629> ;"assertion failed"
	<abortExecution+9 @03d681>    : 15 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@03d683> - <@03d68a>): void(details.expected := 97);
	<abortExecution+11 @03d683>   : 1b 61 00 00 00             load.c32 97
	<abortExecution+16 @03d688>   : 15 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@03d68a> - <@03d691>): void(details.returned := 77);
	<abortExecution+18 @03d68a>   : 1b 4d 00 00 00             load.c32 77
	<abortExecution+23 @03d68f>   : 15 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@03d691> - <@03d6b7>): abort(void("fatal error", details));
	<abortExecution+25 @03d691>   : 1f 78 bf 02 00             load.ref <@02bf78> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @03d696>   : 1b 22 00 00 00             load.c32 34
	<abortExecution+35 @03d69b>   : 1b fe ff ff ff             load.c32 -2
	<abortExecution+40 @03d6a0>   : 1b 80 00 00 00             load.c32 128
	<abortExecution+45 @03d6a5>   : 1f c1 bf 02 00             load.ref <@02bfc1> ;"fatal error"
	<abortExecution+50 @03d6aa>   : 1f d8 c8 02 00             load.ref <@02c8d8> ;abortExecution.NotEquals
	<abortExecution+55 @03d6af>   : 11 18 00 00                load.sp(+24)
	<abortExecution+59 @03d6b3>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @03d6b7>   : 10 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @03d6bb>   : 03                         ret
.references:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@03d6c0>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@03d6c0> - <@03d6cd>)
	test/stdc/tryExec.ci:38: (5 bytes: <@03d6c0> - <@03d6c5>): i32Ref: int32 := null
	<invalidMemoryAccess @03d6c0>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@03d6c5> - <@03d6c8>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @03d6c5>    : 12 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @03d6c7>    : 22                         load.i32
	<invalidMemoryAccess+8 @03d6c8>    : 10 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @03d6cc>   : 03                         ret
.references:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@03d6d0>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@03d6d0> - <@03d6d2>)
	test/stdc/tryExec.ci:43: (2 bytes: <@03d6d0> - <@03d6d2>): emit(void(load.z32, ret));
	<invalidInstruction @03d6d0>      : 18                         load.z32
	<invalidInstruction+1 @03d6d1>    : 03                         ret
.references:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.references:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1120>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.references:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1124>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.references:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1128>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.references:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1132>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.references:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1136>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.references:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1140>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.references:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1196>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.references:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1200>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.references:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1208>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.references:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1212>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.references:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1220>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.references:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1224>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1232>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.references:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.references:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.references:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1256>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.references:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1260>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.references:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1268>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.references:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 5
.offset: <@03d6d8>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (5 bytes: <@03d6d8> - <@03d6dd>)
	test/lang/array.ci:103: (5 bytes: <@03d6d8> - <@03d6dd>): return uint32(.result := values.length);
	<lenSlice @03d6d8>      : 12 02                      dup.x1 sp(2)
	<lenSlice+2 @03d6da>    : 15 04                      set.x1 sp(4)
	<lenSlice+4 @03d6dc>    : 03                         ret
.references:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d6e0>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d6e0> - <@03d6ec>)
	test/lang/array.ci:104: (12 bytes: <@03d6e0> - <@03d6ec>): return int64(.result := values[idx]);
	<nthFixed @03d6e0>      : 12 01                      dup.x1 sp(1)
	<nthFixed+2 @03d6e2>    : 12 03                      dup.x1 sp(3)
	<nthFixed+4 @03d6e4>    : 0c 08 00 00                mad.u32 8
	<nthFixed+8 @03d6e8>    : 23                         load.i64
	<nthFixed+9 @03d6e9>    : 16 05                      set.x2 sp(5)
	<nthFixed+11 @03d6eb>   : 03                         ret
.references:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d6f0>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d6f0> - <@03d6fc>)
	test/lang/array.ci:105: (12 bytes: <@03d6f0> - <@03d6fc>): return int64(.result := values[idx]);
	<nthArray @03d6f0>      : 12 01                      dup.x1 sp(1)
	<nthArray+2 @03d6f2>    : 12 03                      dup.x1 sp(3)
	<nthArray+4 @03d6f4>    : 0c 08 00 00                mad.u32 8
	<nthArray+8 @03d6f8>    : 23                         load.i64
	<nthArray+9 @03d6f9>    : 16 05                      set.x2 sp(5)
	<nthArray+11 @03d6fb>   : 03                         ret
.references:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@03d700>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@03d700> - <@03d70c>)
	test/lang/array.ci:106: (12 bytes: <@03d700> - <@03d70c>): return int64(.result := values[idx]);
	<nthSlice @03d700>      : 12 01                      dup.x1 sp(1)
	<nthSlice+2 @03d702>    : 12 04                      dup.x1 sp(4)
	<nthSlice+4 @03d704>    : 0c 08 00 00                mad.u32 8
	<nthSlice+8 @03d708>    : 23                         load.i64
	<nthSlice+9 @03d709>    : 16 06                      set.x2 sp(6)
	<nthSlice+11 @03d70b>   : 03                         ret
.references:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@02f190>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@02f218>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@03d710>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@03d718>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@03d720>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@03d728>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@03d730>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@03d738>, cast: static const variable(val))
.references:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@02f218>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.references:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.references:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.references:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.references:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@03d710>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@03d718>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 5
.references:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@03d720>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 6
.references:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d728>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.references:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d730>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 51);
	void(globalRecInit.constant := 52);
}
.references:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@03d738>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 61);
	void(globalConstantRec.constant := 62);
}
.references:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1300>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 6);
	void(recordMemberTest.constant := 7);
	void(recordMemberTest.memberInit := 8);
	void(recordMemberTest.constantInit := 9);
	void(recordMemberTest.memberRec.member := 61);
	void(recordMemberTest.memberRec.constant := 62);
	void(recordMemberTest.constantRec.member := 71);
	void(recordMemberTest.constantRec.constant := 72);
}
.references:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02fb88>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 8, offs: <@03d740>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@03d748>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 8, offs: <@03d750>, cast: static const function)
.field forwardMethod: function (size: 8, offs: <@03d758>, cast: static const function)
.field print: function (size: 4, offs: <+12>, cast: const variable(ref))
.field print: function (size: 40, offs: <@03d760>, cast: static const function)
.field printStatic: function (size: 40, offs: <@03d788>, cast: static const function)
.references:
	test/lang/method.ci:91: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:89: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:75: referenced as `RecordMethodTest`
	test/lang/method.ci:63: referenced as `RecordMethodTest`
	test/lang/method.ci:59: referenced as `RecordMethodTest`
	test/lang/method.ci:55: referenced as `RecordMethodTest`
	test/lang/method.ci:53: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d740>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@03d740> - <@03d748>)
	test/lang/method.ci:7: (8 bytes: <@03d740> - <@03d748>): return int32(.result := int32(x + y));
	<staticMethod @03d740>      : 12 02                      dup.x1 sp(2)
	<staticMethod+2 @03d742>    : 12 02                      dup.x1 sp(2)
	<staticMethod+4 @03d744>    : 51                         add.i32
	<staticMethod+5 @03d745>    : 15 04                      set.x1 sp(4)
	<staticMethod+7 @03d747>    : 03                         ret
.references:
	test/lang/method.ci:55: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@03d748>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:12'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:20: referenced as `forwardMethod`
	test/lang/method.ci:12: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.abstractMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:16'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.references:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:55: referenced as `abstractMethod`
	test/lang/method.ci:16: defined as `abstractMethod(x: int32, y: int32): int32`
}
RecordMethodTest.delegateMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:20'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: forwardMethod
.references:
	test/lang/method.ci:54: referenced as `delegateMethod`
	test/lang/method.ci:20: defined as `delegateMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: virtualMethod
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d750>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d750> - <@03d758>)
	test/lang/method.ci:27: (8 bytes: <@03d750> - <@03d758>): return int32(.result := int32(x * y));
	<virtualMethod @03d750>      : 12 02                      dup.x1 sp(2)
	<virtualMethod+2 @03d752>    : 12 02                      dup.x1 sp(2)
	<virtualMethod+4 @03d754>    : 53                         mul.i32
	<virtualMethod+5 @03d755>    : 15 04                      set.x1 sp(4)
	<virtualMethod+7 @03d757>    : 03                         ret
.references:
	test/lang/method.ci:26: defined as `virtualMethod(x: int32, y: int32): int32`
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d758>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:31'
.owner: RecordMethodTest
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d758> - <@03d760>)
	test/lang/method.ci:32: (8 bytes: <@03d758> - <@03d760>): return int32(.result := int32(x * y));
	<forwardMethod @03d758>      : 12 02                      dup.x1 sp(2)
	<forwardMethod+2 @03d75a>    : 12 02                      dup.x1 sp(2)
	<forwardMethod+4 @03d75c>    : 53                         mul.i32
	<forwardMethod+5 @03d75d>    : 15 04                      set.x1 sp(4)
	<forwardMethod+7 @03d75f>    : 03                         ret
.references:
	test/lang/method.ci:31: defined as `forwardMethod(x: int32, y: int32): int32`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+12>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: print
.references:
	test/lang/method.ci:70: referenced as `print`
	test/lang/method.ci:69: referenced as `print`
	test/lang/method.ci:65: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d760>
.name: 'print'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("virtual");
}
.instructions: (40 bytes: <@03d760> - <@03d788>)
	test/lang/method.ci:41: (39 bytes: <@03d760> - <@03d787>): trace("virtual");
	<print @03d760>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<print+5 @03d765>    : 1b 29 00 00 00             load.c32 41
	<print+10 @03d76a>   : 1b 0e 00 00 00             load.c32 14
	<print+15 @03d76f>   : 1b 80 00 00 00             load.c32 128
	<print+20 @03d774>   : 1f 0f fb 02 00             load.ref <@02fb0f> ;"virtual"
	<print+25 @03d779>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @03d77e>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @03d783>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @03d787>   : 03                         ret
.references:
	test/lang/method.ci:91: referenced as `print`
	test/lang/method.ci:89: referenced as `print`
	test/lang/method.ci:40: defined as `print(this: RecordMethodTest): void`
}
RecordMethodTest.printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d788>
.name: 'printStatic'
.file: 'test/lang/method.ci:44'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("static");
}
.instructions: (40 bytes: <@03d788> - <@03d7b0>)
	test/lang/method.ci:45: (39 bytes: <@03d788> - <@03d7af>): trace("static");
	<printStatic @03d788>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<printStatic+5 @03d78d>    : 1b 2d 00 00 00             load.c32 45
	<printStatic+10 @03d792>   : 1b 0e 00 00 00             load.c32 14
	<printStatic+15 @03d797>   : 1b 80 00 00 00             load.c32 128
	<printStatic+20 @03d79c>   : 1f 23 fb 02 00             load.ref <@02fb23> ;"static"
	<printStatic+25 @03d7a1>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @03d7a6>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @03d7ab>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @03d7af>   : 03                         ret
.references:
	test/lang/method.ci:90: referenced as `printStatic`
	test/lang/method.ci:73: referenced as `printStatic`
	test/lang/method.ci:44: defined as `printStatic(this: RecordMethodTest): void`
}
globalFunction(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@03d7b0>
.name: 'globalFunction'
.file: 'test/lang/method.ci:49'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@03d7b0> - <@03d7b8>)
	test/lang/method.ci:50: (8 bytes: <@03d7b0> - <@03d7b8>): return int32(.result := int32(x * y));
	<globalFunction @03d7b0>      : 12 02                      dup.x1 sp(2)
	<globalFunction+2 @03d7b2>    : 12 02                      dup.x1 sp(2)
	<globalFunction+4 @03d7b4>    : 53                         mul.i32
	<globalFunction+5 @03d7b5>    : 15 04                      set.x1 sp(4)
	<globalFunction+7 @03d7b7>    : 03                         ret
.references:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:54: referenced as `globalFunction`
	test/lang/method.ci:49: defined as `globalFunction(x: int32, y: int32): int32`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1316>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:53'
.value: {
	void(recordMethodTest.delegateMethod := globalFunction);
	void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
	void(recordMethodTest.print := print);
}
.references:
	test/lang/method.ci:90: referenced as `recordMethodTest`
	test/lang/method.ci:89: referenced as `recordMethodTest`
	test/lang/method.ci:85: referenced as `recordMethodTest`
	test/lang/method.ci:84: referenced as `recordMethodTest`
	test/lang/method.ci:73: referenced as `recordMethodTest`
	test/lang/method.ci:69: referenced as `recordMethodTest`
	test/lang/method.ci:53: defined as `recordMethodTest`
}
customPrint(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d7b8>
.name: 'customPrint'
.file: 'test/lang/method.ci:59'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("override");
}
.instructions: (40 bytes: <@03d7b8> - <@03d7e0>)
	test/lang/method.ci:60: (39 bytes: <@03d7b8> - <@03d7df>): trace("override");
	<customPrint @03d7b8>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<customPrint+5 @03d7bd>    : 1b 3c 00 00 00             load.c32 60
	<customPrint+10 @03d7c2>   : 1b 0e 00 00 00             load.c32 14
	<customPrint+15 @03d7c7>   : 1b 80 00 00 00             load.c32 128
	<customPrint+20 @03d7cc>   : 1f 56 fb 02 00             load.ref <@02fb56> ;"override"
	<customPrint+25 @03d7d1>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<customPrint+30 @03d7d6>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<customPrint+35 @03d7db>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<customPrint+39 @03d7df>   : 03                         ret
.references:
	test/lang/method.ci:65: referenced as `customPrint`
	test/lang/method.ci:59: defined as `customPrint(this: RecordMethodTest): void`
}
recordMethodTestCustomPrint: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1332>
.name: 'recordMethodTestCustomPrint'
.file: 'test/lang/method.ci:63'
.value: {
	void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	void(recordMethodTestCustomPrint.print := customPrint);
	void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
	void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
}
.references:
	test/lang/method.ci:91: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:86: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:70: referenced as `recordMethodTestCustomPrint`
	test/lang/method.ci:63: defined as `recordMethodTestCustomPrint`
}
print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d7e0>
.name: 'print'
.file: 'test/lang/method.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@03d7e0> - <@03d808>)
	test/lang/method.ci:76: (39 bytes: <@03d7e0> - <@03d807>): trace("extension");
	<print @03d7e0>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<print+5 @03d7e5>    : 1b 4c 00 00 00             load.c32 76
	<print+10 @03d7ea>   : 1b 0e 00 00 00             load.c32 14
	<print+15 @03d7ef>   : 1b 80 00 00 00             load.c32 128
	<print+20 @03d7f4>   : 1f 7b fb 02 00             load.ref <@02fb7b> ;"extension"
	<print+25 @03d7f9>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<print+30 @03d7fe>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<print+35 @03d803>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+39 @03d807>   : 03                         ret
.references:
	test/lang/method.ci:86: referenced as `print`
	test/lang/method.ci:84: referenced as `print`
	test/lang/method.ci:75: defined as `print(this: RecordMethodTest): void`
}
printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@03d808>
.name: 'printStatic'
.file: 'test/lang/method.ci:79'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes: <@03d808> - <@03d830>)
	test/lang/method.ci:80: (39 bytes: <@03d808> - <@03d82f>): trace("extension");
	<printStatic @03d808>      : 1f 98 fa 02 00             load.ref <@02fa98> ;"test/lang/method.ci"
	<printStatic+5 @03d80d>    : 1b 50 00 00 00             load.c32 80
	<printStatic+10 @03d812>   : 1b 0e 00 00 00             load.c32 14
	<printStatic+15 @03d817>   : 1b 80 00 00 00             load.c32 128
	<printStatic+20 @03d81c>   : 1f 7b fb 02 00             load.ref <@02fb7b> ;"extension"
	<printStatic+25 @03d821>   : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<printStatic+30 @03d826>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<printStatic+35 @03d82b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+39 @03d82f>   : 03                         ret
.references:
	test/lang/method.ci:85: referenced as `printStatic`
	test/lang/method.ci:79: defined as `printStatic(this: RecordMethodTest): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@031560>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.references:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.references:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@031780>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.references:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.references:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@0319a0>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.references:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.references:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.references:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@031b38>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.references:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.references:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1336>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.references:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1340>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.references:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1344>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.references:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1348>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.references:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1352>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.references:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031f68>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.references:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@032320>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.references:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0326d8>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.references:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@032a90>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.references:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@032e48>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.references:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@033200>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.references:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.references:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.references:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.references:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1356>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.references:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1360>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.references:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1364>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.references:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1368>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.references:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1372>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.references:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1376>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.references:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.references:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.references:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.references:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.references:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.references:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.references:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.references:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1408>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.references:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1412>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.references:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1416>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.references:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1420>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.references:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1424>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.references:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.references:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.references:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.references:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.references:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.references:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.references:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.references:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.references:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.references:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.references:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1468>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.references:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1472>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.references:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1476>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.references:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1480>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.references:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1484>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.references:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.references:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.references:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1496>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.references:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1500>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.references:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1504>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.references:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1508>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.references:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1512>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.references:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.references:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.references:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.references:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.references:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.references:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.references:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.references:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.references:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.references:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.references:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1556>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.references:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1560>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.references:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1564>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.references:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1568>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.references:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1572>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.references:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.references:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.references:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1584>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.references:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1588>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.references:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1592>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.references:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1596>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.references:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1600>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.references:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.references:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.references:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.references:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.references:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.references:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.references:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.references:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.references:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.references:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.references:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1644>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.references:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1648>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.references:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1652>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.references:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1656>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.references:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1660>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.references:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.references:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.references:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1672>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.references:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1676>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.references:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1680>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.references:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1684>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.references:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1688>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.references:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.references:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.references:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.references:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.references:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.references:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.references:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.references:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.references:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.references:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.references:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1732>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.references:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1736>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.references:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1740>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.references:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1744>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.references:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1748>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.references:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.references:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.references:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1760>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.references:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1764>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.references:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1768>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.references:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1772>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.references:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1776>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.references:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.references:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.references:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.references:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.references:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.references:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.references:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.references:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.references:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.references:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.references:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1820>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.references:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1824>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.references:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1828>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.references:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1832>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.references:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1836>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.references:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.references:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.references:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1848>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.references:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1852>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.references:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1856>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.references:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1860>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.references:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1864>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.references:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.references:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.references:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.references:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.references:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.references:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.references:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.references:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.references:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.references:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.references:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1908>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.references:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1912>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.references:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1916>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.references:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1920>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.references:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1924>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.references:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.references:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.references:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1936>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.references:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1940>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.references:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1944>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.references:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1948>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.references:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1952>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.references:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.references:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.references:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.references:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.references:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.references:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.references:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.references:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.references:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.references:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.references:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1996>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.references:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2000>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.references:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2004>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.references:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2008>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.references:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2012>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.references:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.references:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.references:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2028>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.references:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2036>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.references:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2044>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.references:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2052>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.references:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2060>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.references:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2068>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.references:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2076>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.references:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2084>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.references:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2092>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.references:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2100>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.references:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2108>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.references:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2116>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.references:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2124>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.references:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2132>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.references:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2140>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.references:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2144>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.references:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2148>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.references:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2152>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.references:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2156>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.references:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2160>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.references:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.references:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.references:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2176>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.references:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2184>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.references:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2192>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.references:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2200>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.references:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2208>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.references:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2216>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.references:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2224>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.references:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2232>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.references:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2240>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.references:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2248>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.references:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2256>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.references:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2264>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.references:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2272>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.references:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2280>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.references:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2288>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.references:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2292>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.references:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2296>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.references:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2300>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.references:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2304>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.references:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2308>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.references:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.references:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.references:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2320>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.references:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2324>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.references:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2328>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.references:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2332>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.references:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2336>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.references:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.references:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.references:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.references:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.references:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2356>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.references:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2360>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.references:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2364>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.references:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2368>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.references:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2372>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.references:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.references:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.references:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2388>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.references:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2396>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.references:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2404>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.references:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2412>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.references:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2420>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.references:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2428>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.references:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2436>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.references:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2444>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.references:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2452>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.references:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2456>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.references:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2460>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.references:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2464>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.references:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2468>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.references:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2472>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.references:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.references:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.references:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2484>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.references:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2488>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.references:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.references:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.references:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2500>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.references:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2504>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.references:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
.main: function {
.kind: static function
.base: `function`
.size: 8555
.offset: <@03d830>
.name: '.main'
.print: '.main'
.field typename: typename (size: 136, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000a0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000130>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001c0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000250>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@0002e0>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000370>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000400>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000490>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@000520>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0005b0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000640>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0006d0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000760>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0007f0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000880>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000910>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@0009a8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000eb8>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000f48>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@0052b0>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0061f0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0069f0>, cast: static const inline)
.field System: void (size: 0, offs: <@007538>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 24, offs: <@00e058>, cast: static const typename(val))
.field assertEq: function (size: 83, offs: <@03c6d8>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@00ebc0>, cast: static const typename(val))
.field Complex: typename (size: 16, offs: <@014c58>, cast: static const typename(val))
.field Complex: function (size: 8, offs: <@03cee8>, cast: static const function)
.field Complex: function (size: 9, offs: <@03cef0>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 128, offs: <@03cf00>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 36, offs: <@03cf80>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 105, offs: <@03cfa8>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 49, offs: <@03d018>, cast: static const function)
.field indexOf: function (size: 56, offs: <@03d050>, cast: static const function)
.field lastIndexOf: function (size: 62, offs: <@03d088>, cast: static const function)
.field startsWith: function (size: 73, offs: <@03d0c8>, cast: static const function)
.field endsWith: function (size: 131, offs: <@03d118>, cast: static const function)
.field compare: function (size: 74, offs: <@03d1a0>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@03d238>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@03d260>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@01c5a8>, cast: static const typename(val))
.field append: function (size: 85, offs: <@03d270>, cast: static const function)
.field append: function (size: 663, offs: <@03d2d8>, cast: static const function)
.field append: function (size: 23, offs: <@03d570>, cast: static const function)
.field append: function (size: 54, offs: <@03d588>, cast: static const function)
.field append: function (size: 25, offs: <@03d5d0>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+36>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+44>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+48>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+56>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+64>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+248>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+268>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@023a10>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@023b20>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+276>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+284>, cast: variable(val))
.field value: int64 (size: 8, offs: <@03d5f0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+288>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+292>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+300>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+308>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+320>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+324>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+332>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+336>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+340>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+344>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+348>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+356>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+360>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+368>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+376>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+380>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+384>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+392>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+396>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+468>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+476>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+484>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+492>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+500>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+508>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+516>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+524>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+532>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+540>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+548>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+556>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+564>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+572>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+580>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+588>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+596>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+604>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+612>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+680>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+688>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+696>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+700>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+704>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+712>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+716>, cast: variable(ref))
.field empty: function (size: 1, offs: <@03d5f8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@03d600>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+720>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+724>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+728>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+732>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+736>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+740>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+744>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@03d608>, cast: static const function)
.field fib: function (size: 55, offs: <@03d610>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+748>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+820>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@028ee0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@028ff0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+824>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+828>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+836>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+840>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+844>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+848>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+852>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+860>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+864>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+868>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+872>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+880>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+884>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+892>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+900>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+908>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+916>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+984>, cast: variable(i32))
.field sinF64: float64 (size: 8, offs: <+992>, cast: variable(f64))
.field cosF64: float64 (size: 8, offs: <+1000>, cast: variable(f64))
.field tanF64: float64 (size: 8, offs: <+1008>, cast: variable(f64))
.field logF64: float64 (size: 8, offs: <+1016>, cast: variable(f64))
.field expF64: float64 (size: 8, offs: <+1024>, cast: variable(f64))
.field powF64: float64 (size: 8, offs: <+1032>, cast: variable(f64))
.field sqrtF64: float64 (size: 8, offs: <+1040>, cast: variable(f64))
.field atanF64: float64 (size: 8, offs: <+1048>, cast: variable(f64))
.field sinF32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field cosF32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field tanF32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field logF32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field expF32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field powF32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field sqrtF32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field atanF32: float32 (size: 4, offs: <+1080>, cast: variable(f32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1084>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1088>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1092>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1096>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1104>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1112>, cast: variable(i64))
.field noError: function (size: 1, offs: <@03d648>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@03d650>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@03d668>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@03d678>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@03d6c0>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@03d6d0>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1120>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1124>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1128>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1132>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1136>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1140>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1196>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1200>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1208>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1212>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1220>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1224>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1232>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1256>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1268>, cast: variable(arr))
.field lenSlice: function (size: 5, offs: <@03d6d8>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@03d6e0>, cast: static const function)
.field nthArray: function (size: 12, offs: <@03d6f0>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@03d700>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@02f190>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1300>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@02fb88>, cast: static const typename(val))
.field globalFunction: function (size: 8, offs: <@03d7b0>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1316>, cast: variable(val))
.field customPrint: function (size: 40, offs: <@03d7b8>, cast: static const function)
.field recordMethodTestCustomPrint: RecordMethodTest (size: 16, offs: <+1332>, cast: variable(val))
.field print: function (size: 40, offs: <@03d7e0>, cast: static const function)
.field printStatic: function (size: 40, offs: <@03d808>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@031560>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@031780>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@0319a0>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@031b38>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1336>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1340>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1344>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1348>, cast: variable(val))
.field blue: color (size: 4, offs: <+1352>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@031f68>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@032320>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0326d8>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@032a90>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@032e48>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@033200>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1356>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1360>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1364>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1368>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1372>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1376>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1408>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1412>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1416>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1420>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1424>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1468>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1472>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1476>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1480>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1484>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1496>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1500>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1504>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1508>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1512>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1556>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1560>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1564>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1568>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1572>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1584>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1588>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1592>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1596>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1600>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1644>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1648>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1652>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1656>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1660>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1672>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1676>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1680>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1684>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1688>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1732>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1736>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1740>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1744>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1748>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1760>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1764>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1768>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1772>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1776>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1820>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1824>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1828>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1832>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1836>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1848>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1852>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1856>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1860>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1864>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1908>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1912>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1916>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1920>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1924>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1936>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1940>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1944>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1948>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1952>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+1996>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2000>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2004>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2008>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2012>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2028>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2036>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2044>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2052>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2060>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2068>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2076>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2084>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2092>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2100>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2108>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2116>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2124>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2132>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2140>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2144>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2148>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2152>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2156>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2160>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2176>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2184>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2192>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2200>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2208>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2216>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2224>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2232>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2240>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2248>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2256>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2264>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2272>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2280>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2288>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2292>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2296>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2300>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2304>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2308>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2320>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2324>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2328>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2332>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2336>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2356>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2360>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2364>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2368>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2372>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2388>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2396>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2404>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2412>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2420>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2428>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2436>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2444>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2452>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2456>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2460>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2464>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2468>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2472>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2484>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2488>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2500>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2504>, cast: variable(i32))
.field .main: function (size: 8555, offs: <@03d830>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const message: char[*];
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static const sign(x: float32): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const sign(x: float64): int32 := {
				if (bool(x == (0))) {
					return int32(.result := 0);
				}
				if (bool(x < (0))) {
					return int32(.result := int32(-1));
				}
				return int32(.result := 1);
			};
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static const lerp(t: float32, a: float32, b: float32): float32 := {
				return float32(.result := float32(a + float32(t * (float32(b - a)))));
			};
			static const lerp(t: float64, a: float64, b: float64): float64 := {
				return float64(.result := float64(a + float64(t * (float64(b - a)))));
			};
			static const smooth(t: float32, a: float32, b: float32): float32 := {
				float32(t := clamp(void(void(float32((float32(t - a)) / (float32(b - a))), 0.000000), 1.000000)));
				return float32(.result := float32(float32(t * t) * (float32((3) - float32((2) * t)))));
			};
			static const smooth(t: float64, a: float64, b: float64): float64 := {
				float64(t := clamp(void(void(float64((float64(t - a)) / (float64(b - a))), 0.000000), 1.000000)));
				return float64(.result := float64(float64(t * t) * (float64((3) - float64((2) * t)))));
			};
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static deg2rad(x: float64): float64 := float64(float64(float64(x * pi) / (180)));
			static rad2deg(x: float64): float64 := float64(float64(float64(x * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		emitNfcF32: float32 := emit(void(float32(float64(3.140000 / (2))), float32.sin));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		sinF64: float64 := float64.sin(float64(pi64 / (2)));
		cosF64: float64 := float64.cos(float64(pi64 / (2)));
		tanF64: float64 := float64.tan(float64(pi64 / (4)));
		logF64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		sqrtF64: float64 := float64.sqrt(float64(pi64 * pi64));
		atanF64: float64 := float64.atan2(void(pi64, 1.000000));
		sinF32: float32 := float32.sin(float32(pi32 / (2)));
		cosF32: float32 := float32.cos(float32(pi32 / (2)));
		tanF32: float32 := float32.tan(float32(pi32 / (4)));
		logF32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		sqrtF32: float32 := float32.sqrt(float32(pi32 * pi32));
		atanF32: float32 := float32.atan2(void(pi32, 1.000000));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 5;
			static const globalConstant: int32 := 6;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 51);
				void(globalRecInit.constant := 52);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 61);
				void(globalConstantRec.constant := 62);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 6);
			void(recordMemberTest.constant := 7);
			void(recordMemberTest.memberInit := 8);
			void(recordMemberTest.constantInit := 9);
			void(recordMemberTest.memberRec.member := 61);
			void(recordMemberTest.memberRec.constant := 62);
			void(recordMemberTest.constantRec.member := 71);
			void(recordMemberTest.constantRec.constant := 72);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x + y));
			};
			static forwardMethod(x: int32, y: int32): int32 := forwardMethod;
			abstractMethod(x: int32, y: int32): int32;
			delegateMethod(x: int32, y: int32): int32 := forwardMethod;
			const virtualMethod(x: int32, y: int32): int32 := virtualMethod;
			static const virtualMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			static const forwardMethod(x: int32, y: int32): int32 := {
				return int32(.result := int32(x * y));
			};
			const print(this: RecordMethodTest): void := print;
			static const print(this: RecordMethodTest): void := {
				trace("virtual");
			};
			static const printStatic(this: RecordMethodTest): void := {
				trace("static");
			};
		};
		static const globalFunction(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.delegateMethod := globalFunction);
			void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
			void(recordMethodTest.print := print);
		};
		static const customPrint(this: RecordMethodTest): void := {
			trace("override");
		};
		recordMethodTestCustomPrint: RecordMethodTest := {
			void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
			void(recordMethodTestCustomPrint.print := customPrint);
			void(recordMethodTestCustomPrint.delegateMethod := forwardMethod);
			void(recordMethodTestCustomPrint.virtualMethod := virtualMethod);
		};
		recordMethodTest.print(recordMethodTest);
		recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
		recordMethodTest.printStatic(recordMethodTest);
		static const print(this: RecordMethodTest): void := {
			trace("extension");
		};
		static const printStatic(this: RecordMethodTest): void := {
			trace("extension");
		};
		print(recordMethodTest);
		printStatic(recordMethodTest);
		print(recordMethodTestCustomPrint);
		RecordMethodTest.print(recordMethodTest);
		RecordMethodTest.printStatic(recordMethodTest);
		RecordMethodTest.print(recordMethodTestCustomPrint);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
	}
}
.instructions: (8555 bytes: <@03d830> - <@03f99b>)
	lib/std/string.ci:130: (14 bytes: <@03d830> - <@03d83e>): static const whiteSpace: char[] := " \t\n\r"
	<.main @03d830>      : 1b 04 00 00 00             load.c32 4
	<.main+5 @03d835>    : 1f 78 96 01 00             load.ref <@019678> ;" \t\n\r"
	<.main+10 @03d83a>   : 2e c8 d2 03                store.m64 <@03d2c8> ;append.whiteSpace
	lib/std/string.ci:131: (14 bytes: <@03d83e> - <@03d84c>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @03d83e>   : 1b 24 00 00 00             load.c32 36
	<.main+19 @03d843>   : 1f 89 96 01 00             load.ref <@019689> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @03d848>   : 2e d0 d2 03                store.m64 <@03d2d0> ;append.radixDigits
	lib/std/string.ci:206: (26 bytes: <@03d84c> - <@03d866>): static const format: FormatFlags := {...}
	<.main+28 @03d84c>   : 1b 0a 00 00 00             load.c32 10
	<.main+33 @03d851>   : 2d c0 d5 03                store.m32 <@03d5c0> ;append.format
	:: (7 bytes: <@03d855> - <@03d85c>): void(format.padChr := (0))
	<.main+37 @03d855>   : 18                         load.z32
	<.main+38 @03d856>   : 1f c4 d5 03 00             load.ref <@03d5c4> ;append.format+4
	<.main+43 @03d85b>   : 25                         store.i8
	:: (5 bytes: <@03d85c> - <@03d861>): void(format.padLen := 0)
	<.main+44 @03d85c>   : 18                         load.z32
	<.main+45 @03d85d>   : 2d c8 d5 03                store.m32 <@03d5c8> ;append.format+8
	:: (5 bytes: <@03d861> - <@03d866>): void(format.precision := 0)
	<.main+49 @03d861>   : 18                         load.z32
	<.main+50 @03d862>   : 2d cc d5 03                store.m32 <@03d5cc> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@03d866> - <@03d873>): static value: int64 := 42
	<.main+54 @03d866>   : 1c 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @03d86f>   : 2e f0 d5 03                store.m64 <@03d5f0> ;value
	test/lang/member.ci:35: (5 bytes: <@03d873> - <@03d878>): static global: int32
	<.main+67 @03d873>   : 18                         load.z32
	<.main+68 @03d874>   : 2d 10 d7 03                store.m32 <@03d710> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@03d878> - <@03d881>): static globalInit: int32 := 5
	<.main+72 @03d878>   : 1b 05 00 00 00             load.c32 5
	<.main+77 @03d87d>   : 2d 18 d7 03                store.m32 <@03d718> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@03d881> - <@03d88a>): static const globalConstant: int32 := 6
	<.main+81 @03d881>   : 1b 06 00 00 00             load.c32 6
	<.main+86 @03d886>   : 2d 20 d7 03                store.m32 <@03d720> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@03d88a> - <@03d89c>): static globalRecInit: Inner := {...}
	<.main+90 @03d88a>   : 1b 33 00 00 00             load.c32 51
	<.main+95 @03d88f>   : 2d 30 d7 03                store.m32 <@03d730> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@03d893> - <@03d89c>): void(globalRecInit.constant := 52);
	<.main+99 @03d893>   : 1b 34 00 00 00             load.c32 52
	<.main+104 @03d898>  : 2d 34 d7 03                store.m32 <@03d734> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@03d89c> - <@03d8ae>): static const globalConstantRec: Inner := {...}
	<.main+108 @03d89c>  : 1b 3d 00 00 00             load.c32 61
	<.main+113 @03d8a1>  : 2d 38 d7 03                store.m32 <@03d738> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@03d8a5> - <@03d8ae>): void(globalConstantRec.constant := 62);
	<.main+117 @03d8a5>  : 1b 3e 00 00 00             load.c32 62
	<.main+122 @03d8aa>  : 2d 3c d7 03                store.m32 <@03d73c> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:12: (9 bytes: <@03d8ae> - <@03d8b7>): static forwardMethod(x: int32, y: int32): int32 := forwardMethod
	<.main+126 @03d8ae>  : 1f 58 d7 03 00             load.ref <@03d758> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+131 @03d8b3>  : 2d 48 d7 03                store.m32 <@03d748> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	test/lang/emit.ci:3: (1 byte: <@03d8b7> - <@03d8b8>): emitldz32: int32 := emit(load.z32)
	<.main+135 @03d8b7>  : 18                         load.z32
	test/lang/emit.ci:4: (1 byte: <@03d8b8> - <@03d8b9>): emitldz64: int64 := emit(load.z64)
	<.main+136 @03d8b8>  : 19                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@03d8b9> - <@03d8be>): emitA: int32 := 42
	<.main+137 @03d8b9>  : 1b 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@03d8be> - <@03d8c3>): emitB: int32 := 96
	<.main+142 @03d8be>  : 1b 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@03d8c3> - <@03d8c8>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @03d8c3>  : 12 01                      dup.x1 sp(1)
	<.main+149 @03d8c5>  : 12 01                      dup.x1 sp(1)
	<.main+151 @03d8c7>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@03d8c8> - <@03d8d3>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @03d8c8>  : 1b 0a 00 00 00             load.c32 10
	<.main+157 @03d8cd>  : 1b 05 00 00 00             load.c32 5
	<.main+162 @03d8d2>  : 54                         div.i32
	test/lang/emit.ci:11: (24 bytes: <@03d8d3> - <@03d8eb>): emitNfcF32: float32 := emit(void(float32(float64(3.140000 / (2))), float32.sin))
	<.main+163 @03d8d3>  : 1e 1f 85 eb 51 b8 1e 09 40 load.f64 3.140000
	<.main+172 @03d8dc>  : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+181 @03d8e5>  : 84                         div.f64
	<.main+182 @03d8e6>  : 8b                         f64.2f32
	<.main+183 @03d8e7>  : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/lang/emit.ci:17: (5 bytes: <@03d8eb> - <@03d8f0>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+187 @03d8eb>  : 1d 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@03d8f0> - <@03d8f6>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+192 @03d8f0>  : 1d 00 00 fa 43             load.f32 500.000000
	<.main+197 @03d8f5>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@03d8f6> - <@03d900>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+198 @03d8f6>  : 1e 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+207 @03d8ff>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@03d900> - <@03d909>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+208 @03d900>  : 1e 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@03d909> - <@03d913>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+217 @03d909>  : 1b 03 00 00 00             load.c32 3
	<.main+222 @03d90e>  : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@03d913> - <@03d918>): i3: int32 := 3
	<.main+227 @03d913>  : 1b 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@03d918> - <@03d91d>): i6: int32 := 6
	<.main+232 @03d918>  : 1b 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@03d91d> - <@03d922>): i2: int32 := 2
	<.main+237 @03d91d>  : 1b 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@03d922> - <@03d927>): i8: int32 := 8
	<.main+242 @03d922>  : 1b 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@03d927> - <@03d928>): zeroVal: int32 := zero(void(3, 6))
	<.main+247 @03d927>  : 18                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@03d928> - <@03d929>): zeroVar: int32 := zero(void(i3, i6))
	<.main+248 @03d928>  : 18                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@03d929> - <@03d92a>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+249 @03d929>  : 18                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@03d92a> - <@03d92f>): lastVal: int32 := last(void(3, 6))
	<.main+250 @03d92a>  : 1b 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@03d92f> - <@03d931>): lastVar: int32 := last(void(i3, i6))
	<.main+255 @03d92f>  : 12 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@03d931> - <@03d93b>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+257 @03d931>  : 12 07                      dup.x1 sp(7)
	<.main+259 @03d933>  : 0b 01 00 00                inc.i32(+1)
	<.main+263 @03d937>  : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@03d93b> - <@03d944>): sum2Val: int32 := sum(void(3, 6))
	<.main+267 @03d93b>  : 1b 03 00 00 00             load.c32 3
	<.main+272 @03d940>  : 0b 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@03d944> - <@03d949>): sum2Var: int32 := sum(void(i3, i6))
	<.main+276 @03d944>  : 12 0a                      dup.x1 sp(10)
	<.main+278 @03d946>  : 12 0a                      dup.x1 sp(10)
	<.main+280 @03d948>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@03d949> - <@03d95a>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+281 @03d949>  : 12 0b                      dup.x1 sp(11)
	<.main+283 @03d94b>  : 0b 01 00 00                inc.i32(+1)
	<.main+287 @03d94f>  : 12 0b                      dup.x1 sp(11)
	<.main+289 @03d951>  : 0b 01 00 00                inc.i32(+1)
	<.main+293 @03d955>  : 51                         add.i32
	<.main+294 @03d956>  : 0b fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@03d95a> - <@03d972>): any2Val: int32 := any(void(3, 6))
	<.main+298 @03d95a>  : 1b 03 00 00 00             load.c32 3
	<.main+303 @03d95f>  : 12 00                      dup.x1 sp(0)
	<.main+305 @03d961>  : 06 0a 00 00                jz <.main+315 @03d96b>
	<.main+309 @03d965>  : 12 00                      dup.x1 sp(0)
	<.main+311 @03d967>  : 04 09 00 00                jmp <.main+320 @03d970>
	<.main+315 @03d96b>  : 1b 06 00 00 00             load.c32 6
	<.main+320 @03d970>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@03d972> - <@03d984>): any2Var: int32 := any(void(i3, i6))
	<.main+322 @03d972>  : 12 0d                      dup.x1 sp(13)
	<.main+324 @03d974>  : 12 00                      dup.x1 sp(0)
	<.main+326 @03d976>  : 06 0a 00 00                jz <.main+336 @03d980>
	<.main+330 @03d97a>  : 12 00                      dup.x1 sp(0)
	<.main+332 @03d97c>  : 04 06 00 00                jmp <.main+338 @03d982>
	<.main+336 @03d980>  : 12 0d                      dup.x1 sp(13)
	<.main+338 @03d982>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@03d984> - <@03d9a2>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+340 @03d984>  : 12 0e                      dup.x1 sp(14)
	<.main+342 @03d986>  : 0b 01 00 00                inc.i32(+1)
	<.main+346 @03d98a>  : 12 00                      dup.x1 sp(0)
	<.main+348 @03d98c>  : 06 0a 00 00                jz <.main+358 @03d996>
	<.main+352 @03d990>  : 12 00                      dup.x1 sp(0)
	<.main+354 @03d992>  : 04 0a 00 00                jmp <.main+364 @03d99c>
	<.main+358 @03d996>  : 12 0e                      dup.x1 sp(14)
	<.main+360 @03d998>  : 0b 01 00 00                inc.i32(+1)
	<.main+364 @03d99c>  : 15 01                      set.x1 sp(1)
	<.main+366 @03d99e>  : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@03d9a2> - <@03d9c3>): min2Val: int32 := min(void(3, 6))
	<.main+370 @03d9a2>  : 1b 03 00 00 00             load.c32 3
	<.main+375 @03d9a7>  : 1b 06 00 00 00             load.c32 6
	<.main+380 @03d9ac>  : 12 01                      dup.x1 sp(1)
	<.main+382 @03d9ae>  : 12 01                      dup.x1 sp(1)
	<.main+384 @03d9b0>  : 58                         clt.i32
	<.main+385 @03d9b1>  : 06 0a 00 00                jz <.main+395 @03d9bb>
	<.main+389 @03d9b5>  : 12 01                      dup.x1 sp(1)
	<.main+391 @03d9b7>  : 04 06 00 00                jmp <.main+397 @03d9bd>
	<.main+395 @03d9bb>  : 12 00                      dup.x1 sp(0)
	<.main+397 @03d9bd>  : 15 02                      set.x1 sp(2)
	<.main+399 @03d9bf>  : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@03d9c3> - <@03d9de>): min2Var: int32 := min(void(i3, i6))
	<.main+403 @03d9c3>  : 12 10                      dup.x1 sp(16)
	<.main+405 @03d9c5>  : 12 10                      dup.x1 sp(16)
	<.main+407 @03d9c7>  : 12 01                      dup.x1 sp(1)
	<.main+409 @03d9c9>  : 12 01                      dup.x1 sp(1)
	<.main+411 @03d9cb>  : 58                         clt.i32
	<.main+412 @03d9cc>  : 06 0a 00 00                jz <.main+422 @03d9d6>
	<.main+416 @03d9d0>  : 12 01                      dup.x1 sp(1)
	<.main+418 @03d9d2>  : 04 06 00 00                jmp <.main+424 @03d9d8>
	<.main+422 @03d9d6>  : 12 00                      dup.x1 sp(0)
	<.main+424 @03d9d8>  : 15 02                      set.x1 sp(2)
	<.main+426 @03d9da>  : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@03d9de> - <@03da05>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+430 @03d9de>  : 12 11                      dup.x1 sp(17)
	<.main+432 @03d9e0>  : 0b 01 00 00                inc.i32(+1)
	<.main+436 @03d9e4>  : 12 11                      dup.x1 sp(17)
	<.main+438 @03d9e6>  : 0b 01 00 00                inc.i32(+1)
	<.main+442 @03d9ea>  : 12 01                      dup.x1 sp(1)
	<.main+444 @03d9ec>  : 12 01                      dup.x1 sp(1)
	<.main+446 @03d9ee>  : 58                         clt.i32
	<.main+447 @03d9ef>  : 06 0a 00 00                jz <.main+457 @03d9f9>
	<.main+451 @03d9f3>  : 12 01                      dup.x1 sp(1)
	<.main+453 @03d9f5>  : 04 06 00 00                jmp <.main+459 @03d9fb>
	<.main+457 @03d9f9>  : 12 00                      dup.x1 sp(0)
	<.main+459 @03d9fb>  : 15 02                      set.x1 sp(2)
	<.main+461 @03d9fd>  : 10 fc ff ff                inc.sp(-4)
	<.main+465 @03da01>  : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@03da05> - <@03da26>): max2Val: int32 := max(void(3, 6))
	<.main+469 @03da05>  : 1b 03 00 00 00             load.c32 3
	<.main+474 @03da0a>  : 1b 06 00 00 00             load.c32 6
	<.main+479 @03da0f>  : 12 01                      dup.x1 sp(1)
	<.main+481 @03da11>  : 12 01                      dup.x1 sp(1)
	<.main+483 @03da13>  : 59                         cgt.i32
	<.main+484 @03da14>  : 06 0a 00 00                jz <.main+494 @03da1e>
	<.main+488 @03da18>  : 12 01                      dup.x1 sp(1)
	<.main+490 @03da1a>  : 04 06 00 00                jmp <.main+496 @03da20>
	<.main+494 @03da1e>  : 12 00                      dup.x1 sp(0)
	<.main+496 @03da20>  : 15 02                      set.x1 sp(2)
	<.main+498 @03da22>  : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@03da26> - <@03da41>): max2Var: int32 := max(void(i3, i6))
	<.main+502 @03da26>  : 12 13                      dup.x1 sp(19)
	<.main+504 @03da28>  : 12 13                      dup.x1 sp(19)
	<.main+506 @03da2a>  : 12 01                      dup.x1 sp(1)
	<.main+508 @03da2c>  : 12 01                      dup.x1 sp(1)
	<.main+510 @03da2e>  : 59                         cgt.i32
	<.main+511 @03da2f>  : 06 0a 00 00                jz <.main+521 @03da39>
	<.main+515 @03da33>  : 12 01                      dup.x1 sp(1)
	<.main+517 @03da35>  : 04 06 00 00                jmp <.main+523 @03da3b>
	<.main+521 @03da39>  : 12 00                      dup.x1 sp(0)
	<.main+523 @03da3b>  : 15 02                      set.x1 sp(2)
	<.main+525 @03da3d>  : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@03da41> - <@03da68>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+529 @03da41>  : 12 14                      dup.x1 sp(20)
	<.main+531 @03da43>  : 0b 01 00 00                inc.i32(+1)
	<.main+535 @03da47>  : 12 14                      dup.x1 sp(20)
	<.main+537 @03da49>  : 0b 01 00 00                inc.i32(+1)
	<.main+541 @03da4d>  : 12 01                      dup.x1 sp(1)
	<.main+543 @03da4f>  : 12 01                      dup.x1 sp(1)
	<.main+545 @03da51>  : 59                         cgt.i32
	<.main+546 @03da52>  : 06 0a 00 00                jz <.main+556 @03da5c>
	<.main+550 @03da56>  : 12 01                      dup.x1 sp(1)
	<.main+552 @03da58>  : 04 06 00 00                jmp <.main+558 @03da5e>
	<.main+556 @03da5c>  : 12 00                      dup.x1 sp(0)
	<.main+558 @03da5e>  : 15 02                      set.x1 sp(2)
	<.main+560 @03da60>  : 10 fc ff ff                inc.sp(-4)
	<.main+564 @03da64>  : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@03da68> - <@03da7d>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+568 @03da68>  : 1b 03 00 00 00             load.c32 3
	<.main+573 @03da6d>  : 1b 06 00 00 00             load.c32 6
	<.main+578 @03da72>  : 1b 02 00 00 00             load.c32 2
	<.main+583 @03da77>  : 0b 08 00 00                inc.i32(+8)
	<.main+587 @03da7b>  : 51                         add.i32
	<.main+588 @03da7c>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@03da7d> - <@03da8e>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+589 @03da7d>  : 1b 03 00 00 00             load.c32 3
	<.main+594 @03da82>  : 0b 06 00 00                inc.i32(+6)
	<.main+598 @03da86>  : 0b 02 00 00                inc.i32(+2)
	<.main+602 @03da8a>  : 0b 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@03da8e> - <@03da99>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+606 @03da8e>  : 12 17                      dup.x1 sp(23)
	<.main+608 @03da90>  : 12 17                      dup.x1 sp(23)
	<.main+610 @03da92>  : 12 17                      dup.x1 sp(23)
	<.main+612 @03da94>  : 12 17                      dup.x1 sp(23)
	<.main+614 @03da96>  : 51                         add.i32
	<.main+615 @03da97>  : 51                         add.i32
	<.main+616 @03da98>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@03da99> - <@03daa4>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+617 @03da99>  : 12 18                      dup.x1 sp(24)
	<.main+619 @03da9b>  : 12 18                      dup.x1 sp(24)
	<.main+621 @03da9d>  : 51                         add.i32
	<.main+622 @03da9e>  : 12 17                      dup.x1 sp(23)
	<.main+624 @03daa0>  : 51                         add.i32
	<.main+625 @03daa1>  : 12 16                      dup.x1 sp(22)
	<.main+627 @03daa3>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@03daa4> - <@03dac3>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+628 @03daa4>  : 12 19                      dup.x1 sp(25)
	<.main+630 @03daa6>  : 0b 01 00 00                inc.i32(+1)
	<.main+634 @03daaa>  : 12 19                      dup.x1 sp(25)
	<.main+636 @03daac>  : 0b 01 00 00                inc.i32(+1)
	<.main+640 @03dab0>  : 12 19                      dup.x1 sp(25)
	<.main+642 @03dab2>  : 0b 01 00 00                inc.i32(+1)
	<.main+646 @03dab6>  : 12 19                      dup.x1 sp(25)
	<.main+648 @03dab8>  : 0b 01 00 00                inc.i32(+1)
	<.main+652 @03dabc>  : 51                         add.i32
	<.main+653 @03dabd>  : 51                         add.i32
	<.main+654 @03dabe>  : 51                         add.i32
	<.main+655 @03dabf>  : 0b fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@03dac3> - <@03dae2>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+659 @03dac3>  : 12 1a                      dup.x1 sp(26)
	<.main+661 @03dac5>  : 0b 01 00 00                inc.i32(+1)
	<.main+665 @03dac9>  : 12 1a                      dup.x1 sp(26)
	<.main+667 @03dacb>  : 0b 01 00 00                inc.i32(+1)
	<.main+671 @03dacf>  : 51                         add.i32
	<.main+672 @03dad0>  : 12 19                      dup.x1 sp(25)
	<.main+674 @03dad2>  : 0b 01 00 00                inc.i32(+1)
	<.main+678 @03dad6>  : 51                         add.i32
	<.main+679 @03dad7>  : 12 18                      dup.x1 sp(24)
	<.main+681 @03dad9>  : 0b 01 00 00                inc.i32(+1)
	<.main+685 @03dadd>  : 51                         add.i32
	<.main+686 @03dade>  : 0b fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@03dae2> - <@03db20>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+690 @03dae2>  : 1b 03 00 00 00             load.c32 3
	<.main+695 @03dae7>  : 12 00                      dup.x1 sp(0)
	<.main+697 @03dae9>  : 06 0a 00 00                jz <.main+707 @03daf3>
	<.main+701 @03daed>  : 12 00                      dup.x1 sp(0)
	<.main+703 @03daef>  : 04 2f 00 00                jmp <.main+750 @03db1e>
	<.main+707 @03daf3>  : 1b 06 00 00 00             load.c32 6
	<.main+712 @03daf8>  : 12 00                      dup.x1 sp(0)
	<.main+714 @03dafa>  : 06 0a 00 00                jz <.main+724 @03db04>
	<.main+718 @03dafe>  : 12 00                      dup.x1 sp(0)
	<.main+720 @03db00>  : 04 1c 00 00                jmp <.main+748 @03db1c>
	<.main+724 @03db04>  : 1b 02 00 00 00             load.c32 2
	<.main+729 @03db09>  : 12 00                      dup.x1 sp(0)
	<.main+731 @03db0b>  : 06 0a 00 00                jz <.main+741 @03db15>
	<.main+735 @03db0f>  : 12 00                      dup.x1 sp(0)
	<.main+737 @03db11>  : 04 09 00 00                jmp <.main+746 @03db1a>
	<.main+741 @03db15>  : 1b 08 00 00 00             load.c32 8
	<.main+746 @03db1a>  : 15 01                      set.x1 sp(1)
	<.main+748 @03db1c>  : 15 01                      set.x1 sp(1)
	<.main+750 @03db1e>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@03db20> - <@03db5e>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+752 @03db20>  : 1b 03 00 00 00             load.c32 3
	<.main+757 @03db25>  : 12 00                      dup.x1 sp(0)
	<.main+759 @03db27>  : 06 0a 00 00                jz <.main+769 @03db31>
	<.main+763 @03db2b>  : 12 00                      dup.x1 sp(0)
	<.main+765 @03db2d>  : 04 09 00 00                jmp <.main+774 @03db36>
	<.main+769 @03db31>  : 1b 06 00 00 00             load.c32 6
	<.main+774 @03db36>  : 15 01                      set.x1 sp(1)
	<.main+776 @03db38>  : 12 00                      dup.x1 sp(0)
	<.main+778 @03db3a>  : 06 0a 00 00                jz <.main+788 @03db44>
	<.main+782 @03db3e>  : 12 00                      dup.x1 sp(0)
	<.main+784 @03db40>  : 04 09 00 00                jmp <.main+793 @03db49>
	<.main+788 @03db44>  : 1b 02 00 00 00             load.c32 2
	<.main+793 @03db49>  : 15 01                      set.x1 sp(1)
	<.main+795 @03db4b>  : 12 00                      dup.x1 sp(0)
	<.main+797 @03db4d>  : 06 0a 00 00                jz <.main+807 @03db57>
	<.main+801 @03db51>  : 12 00                      dup.x1 sp(0)
	<.main+803 @03db53>  : 04 09 00 00                jmp <.main+812 @03db5c>
	<.main+807 @03db57>  : 1b 08 00 00 00             load.c32 8
	<.main+812 @03db5c>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@03db5e> - <@03db90>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+814 @03db5e>  : 12 1d                      dup.x1 sp(29)
	<.main+816 @03db60>  : 12 00                      dup.x1 sp(0)
	<.main+818 @03db62>  : 06 0a 00 00                jz <.main+828 @03db6c>
	<.main+822 @03db66>  : 12 00                      dup.x1 sp(0)
	<.main+824 @03db68>  : 04 26 00 00                jmp <.main+862 @03db8e>
	<.main+828 @03db6c>  : 12 1d                      dup.x1 sp(29)
	<.main+830 @03db6e>  : 12 00                      dup.x1 sp(0)
	<.main+832 @03db70>  : 06 0a 00 00                jz <.main+842 @03db7a>
	<.main+836 @03db74>  : 12 00                      dup.x1 sp(0)
	<.main+838 @03db76>  : 04 16 00 00                jmp <.main+860 @03db8c>
	<.main+842 @03db7a>  : 12 1d                      dup.x1 sp(29)
	<.main+844 @03db7c>  : 12 00                      dup.x1 sp(0)
	<.main+846 @03db7e>  : 06 0a 00 00                jz <.main+856 @03db88>
	<.main+850 @03db82>  : 12 00                      dup.x1 sp(0)
	<.main+852 @03db84>  : 04 06 00 00                jmp <.main+858 @03db8a>
	<.main+856 @03db88>  : 12 1d                      dup.x1 sp(29)
	<.main+858 @03db8a>  : 15 01                      set.x1 sp(1)
	<.main+860 @03db8c>  : 15 01                      set.x1 sp(1)
	<.main+862 @03db8e>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@03db90> - <@03dbc2>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+864 @03db90>  : 12 1e                      dup.x1 sp(30)
	<.main+866 @03db92>  : 12 00                      dup.x1 sp(0)
	<.main+868 @03db94>  : 06 0a 00 00                jz <.main+878 @03db9e>
	<.main+872 @03db98>  : 12 00                      dup.x1 sp(0)
	<.main+874 @03db9a>  : 04 06 00 00                jmp <.main+880 @03dba0>
	<.main+878 @03db9e>  : 12 1e                      dup.x1 sp(30)
	<.main+880 @03dba0>  : 15 01                      set.x1 sp(1)
	<.main+882 @03dba2>  : 12 00                      dup.x1 sp(0)
	<.main+884 @03dba4>  : 06 0a 00 00                jz <.main+894 @03dbae>
	<.main+888 @03dba8>  : 12 00                      dup.x1 sp(0)
	<.main+890 @03dbaa>  : 04 06 00 00                jmp <.main+896 @03dbb0>
	<.main+894 @03dbae>  : 12 1d                      dup.x1 sp(29)
	<.main+896 @03dbb0>  : 15 01                      set.x1 sp(1)
	<.main+898 @03dbb2>  : 12 00                      dup.x1 sp(0)
	<.main+900 @03dbb4>  : 06 0a 00 00                jz <.main+910 @03dbbe>
	<.main+904 @03dbb8>  : 12 00                      dup.x1 sp(0)
	<.main+906 @03dbba>  : 04 06 00 00                jmp <.main+912 @03dbc0>
	<.main+910 @03dbbe>  : 12 1c                      dup.x1 sp(28)
	<.main+912 @03dbc0>  : 15 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@03dbc2> - <@03dc08>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+914 @03dbc2>  : 12 1f                      dup.x1 sp(31)
	<.main+916 @03dbc4>  : 0b 01 00 00                inc.i32(+1)
	<.main+920 @03dbc8>  : 12 00                      dup.x1 sp(0)
	<.main+922 @03dbca>  : 06 0a 00 00                jz <.main+932 @03dbd4>
	<.main+926 @03dbce>  : 12 00                      dup.x1 sp(0)
	<.main+928 @03dbd0>  : 04 32 00 00                jmp <.main+978 @03dc02>
	<.main+932 @03dbd4>  : 12 1f                      dup.x1 sp(31)
	<.main+934 @03dbd6>  : 0b 01 00 00                inc.i32(+1)
	<.main+938 @03dbda>  : 12 00                      dup.x1 sp(0)
	<.main+940 @03dbdc>  : 06 0a 00 00                jz <.main+950 @03dbe6>
	<.main+944 @03dbe0>  : 12 00                      dup.x1 sp(0)
	<.main+946 @03dbe2>  : 04 1e 00 00                jmp <.main+976 @03dc00>
	<.main+950 @03dbe6>  : 12 1f                      dup.x1 sp(31)
	<.main+952 @03dbe8>  : 0b 01 00 00                inc.i32(+1)
	<.main+956 @03dbec>  : 12 00                      dup.x1 sp(0)
	<.main+958 @03dbee>  : 06 0a 00 00                jz <.main+968 @03dbf8>
	<.main+962 @03dbf2>  : 12 00                      dup.x1 sp(0)
	<.main+964 @03dbf4>  : 04 0a 00 00                jmp <.main+974 @03dbfe>
	<.main+968 @03dbf8>  : 12 1f                      dup.x1 sp(31)
	<.main+970 @03dbfa>  : 0b 01 00 00                inc.i32(+1)
	<.main+974 @03dbfe>  : 15 01                      set.x1 sp(1)
	<.main+976 @03dc00>  : 15 01                      set.x1 sp(1)
	<.main+978 @03dc02>  : 15 01                      set.x1 sp(1)
	<.main+980 @03dc04>  : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@03dc08> - <@03dc4e>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+984 @03dc08>  : 12 20                      dup.x1 sp(32)
	<.main+986 @03dc0a>  : 0b 01 00 00                inc.i32(+1)
	<.main+990 @03dc0e>  : 12 00                      dup.x1 sp(0)
	<.main+992 @03dc10>  : 06 0a 00 00                jz <.main+1002 @03dc1a>
	<.main+996 @03dc14>  : 12 00                      dup.x1 sp(0)
	<.main+998 @03dc16>  : 04 0a 00 00                jmp <.main+1008 @03dc20>
	<.main+1002 @03dc1a> : 12 20                      dup.x1 sp(32)
	<.main+1004 @03dc1c> : 0b 01 00 00                inc.i32(+1)
	<.main+1008 @03dc20> : 15 01                      set.x1 sp(1)
	<.main+1010 @03dc22> : 12 00                      dup.x1 sp(0)
	<.main+1012 @03dc24> : 06 0a 00 00                jz <.main+1022 @03dc2e>
	<.main+1016 @03dc28> : 12 00                      dup.x1 sp(0)
	<.main+1018 @03dc2a> : 04 0a 00 00                jmp <.main+1028 @03dc34>
	<.main+1022 @03dc2e> : 12 1f                      dup.x1 sp(31)
	<.main+1024 @03dc30> : 0b 01 00 00                inc.i32(+1)
	<.main+1028 @03dc34> : 15 01                      set.x1 sp(1)
	<.main+1030 @03dc36> : 12 00                      dup.x1 sp(0)
	<.main+1032 @03dc38> : 06 0a 00 00                jz <.main+1042 @03dc42>
	<.main+1036 @03dc3c> : 12 00                      dup.x1 sp(0)
	<.main+1038 @03dc3e> : 04 0a 00 00                jmp <.main+1048 @03dc48>
	<.main+1042 @03dc42> : 12 1e                      dup.x1 sp(30)
	<.main+1044 @03dc44> : 0b 01 00 00                inc.i32(+1)
	<.main+1048 @03dc48> : 15 01                      set.x1 sp(1)
	<.main+1050 @03dc4a> : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@03dc4e> - <@03dca7>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1054 @03dc4e> : 1b 03 00 00 00             load.c32 3
	<.main+1059 @03dc53> : 1b 06 00 00 00             load.c32 6
	<.main+1064 @03dc58> : 1b 02 00 00 00             load.c32 2
	<.main+1069 @03dc5d> : 1b 08 00 00 00             load.c32 8
	<.main+1074 @03dc62> : 12 01                      dup.x1 sp(1)
	<.main+1076 @03dc64> : 12 01                      dup.x1 sp(1)
	<.main+1078 @03dc66> : 58                         clt.i32
	<.main+1079 @03dc67> : 06 0a 00 00                jz <.main+1089 @03dc71>
	<.main+1083 @03dc6b> : 12 01                      dup.x1 sp(1)
	<.main+1085 @03dc6d> : 04 06 00 00                jmp <.main+1091 @03dc73>
	<.main+1089 @03dc71> : 12 00                      dup.x1 sp(0)
	<.main+1091 @03dc73> : 15 02                      set.x1 sp(2)
	<.main+1093 @03dc75> : 10 fc ff ff                inc.sp(-4)
	<.main+1097 @03dc79> : 12 01                      dup.x1 sp(1)
	<.main+1099 @03dc7b> : 12 01                      dup.x1 sp(1)
	<.main+1101 @03dc7d> : 58                         clt.i32
	<.main+1102 @03dc7e> : 06 0a 00 00                jz <.main+1112 @03dc88>
	<.main+1106 @03dc82> : 12 01                      dup.x1 sp(1)
	<.main+1108 @03dc84> : 04 06 00 00                jmp <.main+1114 @03dc8a>
	<.main+1112 @03dc88> : 12 00                      dup.x1 sp(0)
	<.main+1114 @03dc8a> : 15 02                      set.x1 sp(2)
	<.main+1116 @03dc8c> : 10 fc ff ff                inc.sp(-4)
	<.main+1120 @03dc90> : 12 01                      dup.x1 sp(1)
	<.main+1122 @03dc92> : 12 01                      dup.x1 sp(1)
	<.main+1124 @03dc94> : 58                         clt.i32
	<.main+1125 @03dc95> : 06 0a 00 00                jz <.main+1135 @03dc9f>
	<.main+1129 @03dc99> : 12 01                      dup.x1 sp(1)
	<.main+1131 @03dc9b> : 04 06 00 00                jmp <.main+1137 @03dca1>
	<.main+1135 @03dc9f> : 12 00                      dup.x1 sp(0)
	<.main+1137 @03dca1> : 15 02                      set.x1 sp(2)
	<.main+1139 @03dca3> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@03dca7> - <@03dd00>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1143 @03dca7> : 1b 03 00 00 00             load.c32 3
	<.main+1148 @03dcac> : 1b 06 00 00 00             load.c32 6
	<.main+1153 @03dcb1> : 12 01                      dup.x1 sp(1)
	<.main+1155 @03dcb3> : 12 01                      dup.x1 sp(1)
	<.main+1157 @03dcb5> : 58                         clt.i32
	<.main+1158 @03dcb6> : 06 0a 00 00                jz <.main+1168 @03dcc0>
	<.main+1162 @03dcba> : 12 01                      dup.x1 sp(1)
	<.main+1164 @03dcbc> : 04 06 00 00                jmp <.main+1170 @03dcc2>
	<.main+1168 @03dcc0> : 12 00                      dup.x1 sp(0)
	<.main+1170 @03dcc2> : 15 02                      set.x1 sp(2)
	<.main+1172 @03dcc4> : 10 fc ff ff                inc.sp(-4)
	<.main+1176 @03dcc8> : 1b 02 00 00 00             load.c32 2
	<.main+1181 @03dccd> : 12 01                      dup.x1 sp(1)
	<.main+1183 @03dccf> : 12 01                      dup.x1 sp(1)
	<.main+1185 @03dcd1> : 58                         clt.i32
	<.main+1186 @03dcd2> : 06 0a 00 00                jz <.main+1196 @03dcdc>
	<.main+1190 @03dcd6> : 12 01                      dup.x1 sp(1)
	<.main+1192 @03dcd8> : 04 06 00 00                jmp <.main+1198 @03dcde>
	<.main+1196 @03dcdc> : 12 00                      dup.x1 sp(0)
	<.main+1198 @03dcde> : 15 02                      set.x1 sp(2)
	<.main+1200 @03dce0> : 10 fc ff ff                inc.sp(-4)
	<.main+1204 @03dce4> : 1b 08 00 00 00             load.c32 8
	<.main+1209 @03dce9> : 12 01                      dup.x1 sp(1)
	<.main+1211 @03dceb> : 12 01                      dup.x1 sp(1)
	<.main+1213 @03dced> : 58                         clt.i32
	<.main+1214 @03dcee> : 06 0a 00 00                jz <.main+1224 @03dcf8>
	<.main+1218 @03dcf2> : 12 01                      dup.x1 sp(1)
	<.main+1220 @03dcf4> : 04 06 00 00                jmp <.main+1226 @03dcfa>
	<.main+1224 @03dcf8> : 12 00                      dup.x1 sp(0)
	<.main+1226 @03dcfa> : 15 02                      set.x1 sp(2)
	<.main+1228 @03dcfc> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@03dd00> - <@03dd4d>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1232 @03dd00> : 12 23                      dup.x1 sp(35)
	<.main+1234 @03dd02> : 12 23                      dup.x1 sp(35)
	<.main+1236 @03dd04> : 12 23                      dup.x1 sp(35)
	<.main+1238 @03dd06> : 12 23                      dup.x1 sp(35)
	<.main+1240 @03dd08> : 12 01                      dup.x1 sp(1)
	<.main+1242 @03dd0a> : 12 01                      dup.x1 sp(1)
	<.main+1244 @03dd0c> : 58                         clt.i32
	<.main+1245 @03dd0d> : 06 0a 00 00                jz <.main+1255 @03dd17>
	<.main+1249 @03dd11> : 12 01                      dup.x1 sp(1)
	<.main+1251 @03dd13> : 04 06 00 00                jmp <.main+1257 @03dd19>
	<.main+1255 @03dd17> : 12 00                      dup.x1 sp(0)
	<.main+1257 @03dd19> : 15 02                      set.x1 sp(2)
	<.main+1259 @03dd1b> : 10 fc ff ff                inc.sp(-4)
	<.main+1263 @03dd1f> : 12 01                      dup.x1 sp(1)
	<.main+1265 @03dd21> : 12 01                      dup.x1 sp(1)
	<.main+1267 @03dd23> : 58                         clt.i32
	<.main+1268 @03dd24> : 06 0a 00 00                jz <.main+1278 @03dd2e>
	<.main+1272 @03dd28> : 12 01                      dup.x1 sp(1)
	<.main+1274 @03dd2a> : 04 06 00 00                jmp <.main+1280 @03dd30>
	<.main+1278 @03dd2e> : 12 00                      dup.x1 sp(0)
	<.main+1280 @03dd30> : 15 02                      set.x1 sp(2)
	<.main+1282 @03dd32> : 10 fc ff ff                inc.sp(-4)
	<.main+1286 @03dd36> : 12 01                      dup.x1 sp(1)
	<.main+1288 @03dd38> : 12 01                      dup.x1 sp(1)
	<.main+1290 @03dd3a> : 58                         clt.i32
	<.main+1291 @03dd3b> : 06 0a 00 00                jz <.main+1301 @03dd45>
	<.main+1295 @03dd3f> : 12 01                      dup.x1 sp(1)
	<.main+1297 @03dd41> : 04 06 00 00                jmp <.main+1303 @03dd47>
	<.main+1301 @03dd45> : 12 00                      dup.x1 sp(0)
	<.main+1303 @03dd47> : 15 02                      set.x1 sp(2)
	<.main+1305 @03dd49> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@03dd4d> - <@03dd9a>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1309 @03dd4d> : 12 24                      dup.x1 sp(36)
	<.main+1311 @03dd4f> : 12 24                      dup.x1 sp(36)
	<.main+1313 @03dd51> : 12 01                      dup.x1 sp(1)
	<.main+1315 @03dd53> : 12 01                      dup.x1 sp(1)
	<.main+1317 @03dd55> : 58                         clt.i32
	<.main+1318 @03dd56> : 06 0a 00 00                jz <.main+1328 @03dd60>
	<.main+1322 @03dd5a> : 12 01                      dup.x1 sp(1)
	<.main+1324 @03dd5c> : 04 06 00 00                jmp <.main+1330 @03dd62>
	<.main+1328 @03dd60> : 12 00                      dup.x1 sp(0)
	<.main+1330 @03dd62> : 15 02                      set.x1 sp(2)
	<.main+1332 @03dd64> : 10 fc ff ff                inc.sp(-4)
	<.main+1336 @03dd68> : 12 23                      dup.x1 sp(35)
	<.main+1338 @03dd6a> : 12 01                      dup.x1 sp(1)
	<.main+1340 @03dd6c> : 12 01                      dup.x1 sp(1)
	<.main+1342 @03dd6e> : 58                         clt.i32
	<.main+1343 @03dd6f> : 06 0a 00 00                jz <.main+1353 @03dd79>
	<.main+1347 @03dd73> : 12 01                      dup.x1 sp(1)
	<.main+1349 @03dd75> : 04 06 00 00                jmp <.main+1355 @03dd7b>
	<.main+1353 @03dd79> : 12 00                      dup.x1 sp(0)
	<.main+1355 @03dd7b> : 15 02                      set.x1 sp(2)
	<.main+1357 @03dd7d> : 10 fc ff ff                inc.sp(-4)
	<.main+1361 @03dd81> : 12 22                      dup.x1 sp(34)
	<.main+1363 @03dd83> : 12 01                      dup.x1 sp(1)
	<.main+1365 @03dd85> : 12 01                      dup.x1 sp(1)
	<.main+1367 @03dd87> : 58                         clt.i32
	<.main+1368 @03dd88> : 06 0a 00 00                jz <.main+1378 @03dd92>
	<.main+1372 @03dd8c> : 12 01                      dup.x1 sp(1)
	<.main+1374 @03dd8e> : 04 06 00 00                jmp <.main+1380 @03dd94>
	<.main+1378 @03dd92> : 12 00                      dup.x1 sp(0)
	<.main+1380 @03dd94> : 15 02                      set.x1 sp(2)
	<.main+1382 @03dd96> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@03dd9a> - <@03ddfb>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1386 @03dd9a> : 12 25                      dup.x1 sp(37)
	<.main+1388 @03dd9c> : 0b 01 00 00                inc.i32(+1)
	<.main+1392 @03dda0> : 12 25                      dup.x1 sp(37)
	<.main+1394 @03dda2> : 0b 01 00 00                inc.i32(+1)
	<.main+1398 @03dda6> : 12 25                      dup.x1 sp(37)
	<.main+1400 @03dda8> : 0b 01 00 00                inc.i32(+1)
	<.main+1404 @03ddac> : 12 25                      dup.x1 sp(37)
	<.main+1406 @03ddae> : 0b 01 00 00                inc.i32(+1)
	<.main+1410 @03ddb2> : 12 01                      dup.x1 sp(1)
	<.main+1412 @03ddb4> : 12 01                      dup.x1 sp(1)
	<.main+1414 @03ddb6> : 58                         clt.i32
	<.main+1415 @03ddb7> : 06 0a 00 00                jz <.main+1425 @03ddc1>
	<.main+1419 @03ddbb> : 12 01                      dup.x1 sp(1)
	<.main+1421 @03ddbd> : 04 06 00 00                jmp <.main+1427 @03ddc3>
	<.main+1425 @03ddc1> : 12 00                      dup.x1 sp(0)
	<.main+1427 @03ddc3> : 15 02                      set.x1 sp(2)
	<.main+1429 @03ddc5> : 10 fc ff ff                inc.sp(-4)
	<.main+1433 @03ddc9> : 12 01                      dup.x1 sp(1)
	<.main+1435 @03ddcb> : 12 01                      dup.x1 sp(1)
	<.main+1437 @03ddcd> : 58                         clt.i32
	<.main+1438 @03ddce> : 06 0a 00 00                jz <.main+1448 @03ddd8>
	<.main+1442 @03ddd2> : 12 01                      dup.x1 sp(1)
	<.main+1444 @03ddd4> : 04 06 00 00                jmp <.main+1450 @03ddda>
	<.main+1448 @03ddd8> : 12 00                      dup.x1 sp(0)
	<.main+1450 @03ddda> : 15 02                      set.x1 sp(2)
	<.main+1452 @03dddc> : 10 fc ff ff                inc.sp(-4)
	<.main+1456 @03dde0> : 12 01                      dup.x1 sp(1)
	<.main+1458 @03dde2> : 12 01                      dup.x1 sp(1)
	<.main+1460 @03dde4> : 58                         clt.i32
	<.main+1461 @03dde5> : 06 0a 00 00                jz <.main+1471 @03ddef>
	<.main+1465 @03dde9> : 12 01                      dup.x1 sp(1)
	<.main+1467 @03ddeb> : 04 06 00 00                jmp <.main+1473 @03ddf1>
	<.main+1471 @03ddef> : 12 00                      dup.x1 sp(0)
	<.main+1473 @03ddf1> : 15 02                      set.x1 sp(2)
	<.main+1475 @03ddf3> : 10 fc ff ff                inc.sp(-4)
	<.main+1479 @03ddf7> : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@03ddfb> - <@03de5c>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1483 @03ddfb> : 12 26                      dup.x1 sp(38)
	<.main+1485 @03ddfd> : 0b 01 00 00                inc.i32(+1)
	<.main+1489 @03de01> : 12 26                      dup.x1 sp(38)
	<.main+1491 @03de03> : 0b 01 00 00                inc.i32(+1)
	<.main+1495 @03de07> : 12 01                      dup.x1 sp(1)
	<.main+1497 @03de09> : 12 01                      dup.x1 sp(1)
	<.main+1499 @03de0b> : 58                         clt.i32
	<.main+1500 @03de0c> : 06 0a 00 00                jz <.main+1510 @03de16>
	<.main+1504 @03de10> : 12 01                      dup.x1 sp(1)
	<.main+1506 @03de12> : 04 06 00 00                jmp <.main+1512 @03de18>
	<.main+1510 @03de16> : 12 00                      dup.x1 sp(0)
	<.main+1512 @03de18> : 15 02                      set.x1 sp(2)
	<.main+1514 @03de1a> : 10 fc ff ff                inc.sp(-4)
	<.main+1518 @03de1e> : 12 25                      dup.x1 sp(37)
	<.main+1520 @03de20> : 0b 01 00 00                inc.i32(+1)
	<.main+1524 @03de24> : 12 01                      dup.x1 sp(1)
	<.main+1526 @03de26> : 12 01                      dup.x1 sp(1)
	<.main+1528 @03de28> : 58                         clt.i32
	<.main+1529 @03de29> : 06 0a 00 00                jz <.main+1539 @03de33>
	<.main+1533 @03de2d> : 12 01                      dup.x1 sp(1)
	<.main+1535 @03de2f> : 04 06 00 00                jmp <.main+1541 @03de35>
	<.main+1539 @03de33> : 12 00                      dup.x1 sp(0)
	<.main+1541 @03de35> : 15 02                      set.x1 sp(2)
	<.main+1543 @03de37> : 10 fc ff ff                inc.sp(-4)
	<.main+1547 @03de3b> : 12 24                      dup.x1 sp(36)
	<.main+1549 @03de3d> : 0b 01 00 00                inc.i32(+1)
	<.main+1553 @03de41> : 12 01                      dup.x1 sp(1)
	<.main+1555 @03de43> : 12 01                      dup.x1 sp(1)
	<.main+1557 @03de45> : 58                         clt.i32
	<.main+1558 @03de46> : 06 0a 00 00                jz <.main+1568 @03de50>
	<.main+1562 @03de4a> : 12 01                      dup.x1 sp(1)
	<.main+1564 @03de4c> : 04 06 00 00                jmp <.main+1570 @03de52>
	<.main+1568 @03de50> : 12 00                      dup.x1 sp(0)
	<.main+1570 @03de52> : 15 02                      set.x1 sp(2)
	<.main+1572 @03de54> : 10 fc ff ff                inc.sp(-4)
	<.main+1576 @03de58> : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@03de5c> - <@03deb5>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1580 @03de5c> : 1b 03 00 00 00             load.c32 3
	<.main+1585 @03de61> : 1b 06 00 00 00             load.c32 6
	<.main+1590 @03de66> : 1b 02 00 00 00             load.c32 2
	<.main+1595 @03de6b> : 1b 08 00 00 00             load.c32 8
	<.main+1600 @03de70> : 12 01                      dup.x1 sp(1)
	<.main+1602 @03de72> : 12 01                      dup.x1 sp(1)
	<.main+1604 @03de74> : 59                         cgt.i32
	<.main+1605 @03de75> : 06 0a 00 00                jz <.main+1615 @03de7f>
	<.main+1609 @03de79> : 12 01                      dup.x1 sp(1)
	<.main+1611 @03de7b> : 04 06 00 00                jmp <.main+1617 @03de81>
	<.main+1615 @03de7f> : 12 00                      dup.x1 sp(0)
	<.main+1617 @03de81> : 15 02                      set.x1 sp(2)
	<.main+1619 @03de83> : 10 fc ff ff                inc.sp(-4)
	<.main+1623 @03de87> : 12 01                      dup.x1 sp(1)
	<.main+1625 @03de89> : 12 01                      dup.x1 sp(1)
	<.main+1627 @03de8b> : 59                         cgt.i32
	<.main+1628 @03de8c> : 06 0a 00 00                jz <.main+1638 @03de96>
	<.main+1632 @03de90> : 12 01                      dup.x1 sp(1)
	<.main+1634 @03de92> : 04 06 00 00                jmp <.main+1640 @03de98>
	<.main+1638 @03de96> : 12 00                      dup.x1 sp(0)
	<.main+1640 @03de98> : 15 02                      set.x1 sp(2)
	<.main+1642 @03de9a> : 10 fc ff ff                inc.sp(-4)
	<.main+1646 @03de9e> : 12 01                      dup.x1 sp(1)
	<.main+1648 @03dea0> : 12 01                      dup.x1 sp(1)
	<.main+1650 @03dea2> : 59                         cgt.i32
	<.main+1651 @03dea3> : 06 0a 00 00                jz <.main+1661 @03dead>
	<.main+1655 @03dea7> : 12 01                      dup.x1 sp(1)
	<.main+1657 @03dea9> : 04 06 00 00                jmp <.main+1663 @03deaf>
	<.main+1661 @03dead> : 12 00                      dup.x1 sp(0)
	<.main+1663 @03deaf> : 15 02                      set.x1 sp(2)
	<.main+1665 @03deb1> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@03deb5> - <@03df0e>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1669 @03deb5> : 1b 03 00 00 00             load.c32 3
	<.main+1674 @03deba> : 1b 06 00 00 00             load.c32 6
	<.main+1679 @03debf> : 12 01                      dup.x1 sp(1)
	<.main+1681 @03dec1> : 12 01                      dup.x1 sp(1)
	<.main+1683 @03dec3> : 59                         cgt.i32
	<.main+1684 @03dec4> : 06 0a 00 00                jz <.main+1694 @03dece>
	<.main+1688 @03dec8> : 12 01                      dup.x1 sp(1)
	<.main+1690 @03deca> : 04 06 00 00                jmp <.main+1696 @03ded0>
	<.main+1694 @03dece> : 12 00                      dup.x1 sp(0)
	<.main+1696 @03ded0> : 15 02                      set.x1 sp(2)
	<.main+1698 @03ded2> : 10 fc ff ff                inc.sp(-4)
	<.main+1702 @03ded6> : 1b 02 00 00 00             load.c32 2
	<.main+1707 @03dedb> : 12 01                      dup.x1 sp(1)
	<.main+1709 @03dedd> : 12 01                      dup.x1 sp(1)
	<.main+1711 @03dedf> : 59                         cgt.i32
	<.main+1712 @03dee0> : 06 0a 00 00                jz <.main+1722 @03deea>
	<.main+1716 @03dee4> : 12 01                      dup.x1 sp(1)
	<.main+1718 @03dee6> : 04 06 00 00                jmp <.main+1724 @03deec>
	<.main+1722 @03deea> : 12 00                      dup.x1 sp(0)
	<.main+1724 @03deec> : 15 02                      set.x1 sp(2)
	<.main+1726 @03deee> : 10 fc ff ff                inc.sp(-4)
	<.main+1730 @03def2> : 1b 08 00 00 00             load.c32 8
	<.main+1735 @03def7> : 12 01                      dup.x1 sp(1)
	<.main+1737 @03def9> : 12 01                      dup.x1 sp(1)
	<.main+1739 @03defb> : 59                         cgt.i32
	<.main+1740 @03defc> : 06 0a 00 00                jz <.main+1750 @03df06>
	<.main+1744 @03df00> : 12 01                      dup.x1 sp(1)
	<.main+1746 @03df02> : 04 06 00 00                jmp <.main+1752 @03df08>
	<.main+1750 @03df06> : 12 00                      dup.x1 sp(0)
	<.main+1752 @03df08> : 15 02                      set.x1 sp(2)
	<.main+1754 @03df0a> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@03df0e> - <@03df5b>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1758 @03df0e> : 12 29                      dup.x1 sp(41)
	<.main+1760 @03df10> : 12 29                      dup.x1 sp(41)
	<.main+1762 @03df12> : 12 29                      dup.x1 sp(41)
	<.main+1764 @03df14> : 12 29                      dup.x1 sp(41)
	<.main+1766 @03df16> : 12 01                      dup.x1 sp(1)
	<.main+1768 @03df18> : 12 01                      dup.x1 sp(1)
	<.main+1770 @03df1a> : 59                         cgt.i32
	<.main+1771 @03df1b> : 06 0a 00 00                jz <.main+1781 @03df25>
	<.main+1775 @03df1f> : 12 01                      dup.x1 sp(1)
	<.main+1777 @03df21> : 04 06 00 00                jmp <.main+1783 @03df27>
	<.main+1781 @03df25> : 12 00                      dup.x1 sp(0)
	<.main+1783 @03df27> : 15 02                      set.x1 sp(2)
	<.main+1785 @03df29> : 10 fc ff ff                inc.sp(-4)
	<.main+1789 @03df2d> : 12 01                      dup.x1 sp(1)
	<.main+1791 @03df2f> : 12 01                      dup.x1 sp(1)
	<.main+1793 @03df31> : 59                         cgt.i32
	<.main+1794 @03df32> : 06 0a 00 00                jz <.main+1804 @03df3c>
	<.main+1798 @03df36> : 12 01                      dup.x1 sp(1)
	<.main+1800 @03df38> : 04 06 00 00                jmp <.main+1806 @03df3e>
	<.main+1804 @03df3c> : 12 00                      dup.x1 sp(0)
	<.main+1806 @03df3e> : 15 02                      set.x1 sp(2)
	<.main+1808 @03df40> : 10 fc ff ff                inc.sp(-4)
	<.main+1812 @03df44> : 12 01                      dup.x1 sp(1)
	<.main+1814 @03df46> : 12 01                      dup.x1 sp(1)
	<.main+1816 @03df48> : 59                         cgt.i32
	<.main+1817 @03df49> : 06 0a 00 00                jz <.main+1827 @03df53>
	<.main+1821 @03df4d> : 12 01                      dup.x1 sp(1)
	<.main+1823 @03df4f> : 04 06 00 00                jmp <.main+1829 @03df55>
	<.main+1827 @03df53> : 12 00                      dup.x1 sp(0)
	<.main+1829 @03df55> : 15 02                      set.x1 sp(2)
	<.main+1831 @03df57> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@03df5b> - <@03dfa8>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1835 @03df5b> : 12 2a                      dup.x1 sp(42)
	<.main+1837 @03df5d> : 12 2a                      dup.x1 sp(42)
	<.main+1839 @03df5f> : 12 01                      dup.x1 sp(1)
	<.main+1841 @03df61> : 12 01                      dup.x1 sp(1)
	<.main+1843 @03df63> : 59                         cgt.i32
	<.main+1844 @03df64> : 06 0a 00 00                jz <.main+1854 @03df6e>
	<.main+1848 @03df68> : 12 01                      dup.x1 sp(1)
	<.main+1850 @03df6a> : 04 06 00 00                jmp <.main+1856 @03df70>
	<.main+1854 @03df6e> : 12 00                      dup.x1 sp(0)
	<.main+1856 @03df70> : 15 02                      set.x1 sp(2)
	<.main+1858 @03df72> : 10 fc ff ff                inc.sp(-4)
	<.main+1862 @03df76> : 12 29                      dup.x1 sp(41)
	<.main+1864 @03df78> : 12 01                      dup.x1 sp(1)
	<.main+1866 @03df7a> : 12 01                      dup.x1 sp(1)
	<.main+1868 @03df7c> : 59                         cgt.i32
	<.main+1869 @03df7d> : 06 0a 00 00                jz <.main+1879 @03df87>
	<.main+1873 @03df81> : 12 01                      dup.x1 sp(1)
	<.main+1875 @03df83> : 04 06 00 00                jmp <.main+1881 @03df89>
	<.main+1879 @03df87> : 12 00                      dup.x1 sp(0)
	<.main+1881 @03df89> : 15 02                      set.x1 sp(2)
	<.main+1883 @03df8b> : 10 fc ff ff                inc.sp(-4)
	<.main+1887 @03df8f> : 12 28                      dup.x1 sp(40)
	<.main+1889 @03df91> : 12 01                      dup.x1 sp(1)
	<.main+1891 @03df93> : 12 01                      dup.x1 sp(1)
	<.main+1893 @03df95> : 59                         cgt.i32
	<.main+1894 @03df96> : 06 0a 00 00                jz <.main+1904 @03dfa0>
	<.main+1898 @03df9a> : 12 01                      dup.x1 sp(1)
	<.main+1900 @03df9c> : 04 06 00 00                jmp <.main+1906 @03dfa2>
	<.main+1904 @03dfa0> : 12 00                      dup.x1 sp(0)
	<.main+1906 @03dfa2> : 15 02                      set.x1 sp(2)
	<.main+1908 @03dfa4> : 10 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@03dfa8> - <@03e009>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1912 @03dfa8> : 12 2b                      dup.x1 sp(43)
	<.main+1914 @03dfaa> : 0b 01 00 00                inc.i32(+1)
	<.main+1918 @03dfae> : 12 2b                      dup.x1 sp(43)
	<.main+1920 @03dfb0> : 0b 01 00 00                inc.i32(+1)
	<.main+1924 @03dfb4> : 12 2b                      dup.x1 sp(43)
	<.main+1926 @03dfb6> : 0b 01 00 00                inc.i32(+1)
	<.main+1930 @03dfba> : 12 2b                      dup.x1 sp(43)
	<.main+1932 @03dfbc> : 0b 01 00 00                inc.i32(+1)
	<.main+1936 @03dfc0> : 12 01                      dup.x1 sp(1)
	<.main+1938 @03dfc2> : 12 01                      dup.x1 sp(1)
	<.main+1940 @03dfc4> : 59                         cgt.i32
	<.main+1941 @03dfc5> : 06 0a 00 00                jz <.main+1951 @03dfcf>
	<.main+1945 @03dfc9> : 12 01                      dup.x1 sp(1)
	<.main+1947 @03dfcb> : 04 06 00 00                jmp <.main+1953 @03dfd1>
	<.main+1951 @03dfcf> : 12 00                      dup.x1 sp(0)
	<.main+1953 @03dfd1> : 15 02                      set.x1 sp(2)
	<.main+1955 @03dfd3> : 10 fc ff ff                inc.sp(-4)
	<.main+1959 @03dfd7> : 12 01                      dup.x1 sp(1)
	<.main+1961 @03dfd9> : 12 01                      dup.x1 sp(1)
	<.main+1963 @03dfdb> : 59                         cgt.i32
	<.main+1964 @03dfdc> : 06 0a 00 00                jz <.main+1974 @03dfe6>
	<.main+1968 @03dfe0> : 12 01                      dup.x1 sp(1)
	<.main+1970 @03dfe2> : 04 06 00 00                jmp <.main+1976 @03dfe8>
	<.main+1974 @03dfe6> : 12 00                      dup.x1 sp(0)
	<.main+1976 @03dfe8> : 15 02                      set.x1 sp(2)
	<.main+1978 @03dfea> : 10 fc ff ff                inc.sp(-4)
	<.main+1982 @03dfee> : 12 01                      dup.x1 sp(1)
	<.main+1984 @03dff0> : 12 01                      dup.x1 sp(1)
	<.main+1986 @03dff2> : 59                         cgt.i32
	<.main+1987 @03dff3> : 06 0a 00 00                jz <.main+1997 @03dffd>
	<.main+1991 @03dff7> : 12 01                      dup.x1 sp(1)
	<.main+1993 @03dff9> : 04 06 00 00                jmp <.main+1999 @03dfff>
	<.main+1997 @03dffd> : 12 00                      dup.x1 sp(0)
	<.main+1999 @03dfff> : 15 02                      set.x1 sp(2)
	<.main+2001 @03e001> : 10 fc ff ff                inc.sp(-4)
	<.main+2005 @03e005> : 0b ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@03e009> - <@03e06a>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2009 @03e009> : 12 2c                      dup.x1 sp(44)
	<.main+2011 @03e00b> : 0b 01 00 00                inc.i32(+1)
	<.main+2015 @03e00f> : 12 2c                      dup.x1 sp(44)
	<.main+2017 @03e011> : 0b 01 00 00                inc.i32(+1)
	<.main+2021 @03e015> : 12 01                      dup.x1 sp(1)
	<.main+2023 @03e017> : 12 01                      dup.x1 sp(1)
	<.main+2025 @03e019> : 59                         cgt.i32
	<.main+2026 @03e01a> : 06 0a 00 00                jz <.main+2036 @03e024>
	<.main+2030 @03e01e> : 12 01                      dup.x1 sp(1)
	<.main+2032 @03e020> : 04 06 00 00                jmp <.main+2038 @03e026>
	<.main+2036 @03e024> : 12 00                      dup.x1 sp(0)
	<.main+2038 @03e026> : 15 02                      set.x1 sp(2)
	<.main+2040 @03e028> : 10 fc ff ff                inc.sp(-4)
	<.main+2044 @03e02c> : 12 2b                      dup.x1 sp(43)
	<.main+2046 @03e02e> : 0b 01 00 00                inc.i32(+1)
	<.main+2050 @03e032> : 12 01                      dup.x1 sp(1)
	<.main+2052 @03e034> : 12 01                      dup.x1 sp(1)
	<.main+2054 @03e036> : 59                         cgt.i32
	<.main+2055 @03e037> : 06 0a 00 00                jz <.main+2065 @03e041>
	<.main+2059 @03e03b> : 12 01                      dup.x1 sp(1)
	<.main+2061 @03e03d> : 04 06 00 00                jmp <.main+2067 @03e043>
	<.main+2065 @03e041> : 12 00                      dup.x1 sp(0)
	<.main+2067 @03e043> : 15 02                      set.x1 sp(2)
	<.main+2069 @03e045> : 10 fc ff ff                inc.sp(-4)
	<.main+2073 @03e049> : 12 2a                      dup.x1 sp(42)
	<.main+2075 @03e04b> : 0b 01 00 00                inc.i32(+1)
	<.main+2079 @03e04f> : 12 01                      dup.x1 sp(1)
	<.main+2081 @03e051> : 12 01                      dup.x1 sp(1)
	<.main+2083 @03e053> : 59                         cgt.i32
	<.main+2084 @03e054> : 06 0a 00 00                jz <.main+2094 @03e05e>
	<.main+2088 @03e058> : 12 01                      dup.x1 sp(1)
	<.main+2090 @03e05a> : 04 06 00 00                jmp <.main+2096 @03e060>
	<.main+2094 @03e05e> : 12 00                      dup.x1 sp(0)
	<.main+2096 @03e060> : 15 02                      set.x1 sp(2)
	<.main+2098 @03e062> : 10 fc ff ff                inc.sp(-4)
	<.main+2102 @03e066> : 0b ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@03e06a> - <@03e06f>): overload1: float32 := overload
	<.main+2106 @03e06a> : 1d 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@03e06f> - <@03e074>): overload2: float32 := overload()
	<.main+2111 @03e06f> : 1d 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@03e074> - <@03e079>): overload3: float32 := overload(0)
	<.main+2116 @03e074> : 1d 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@03e079> - <@03e07e>): overload4: float32 := overload(0.000000)
	<.main+2121 @03e079> : 1d 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@03e07e> - <@03e083>): overload5: float32 := overload(void(0, 0))
	<.main+2126 @03e07e> : 1d 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@03e083> - <@03e08c>): boilC: Celsius := Celsius(100.000000)
	<.main+2131 @03e083> : 1e 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@03e08c> - <@03e0a2>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2140 @03e08c> : 13 00                      dup.x2 sp(0)
	<.main+2142 @03e08e> : 1e cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2151 @03e097> : 83                         mul.f64
	<.main+2152 @03e098> : 1e 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2161 @03e0a1> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@03e0a2> - <@03e0a7>): valueRef: int64 := value
	<.main+2162 @03e0a2> : 1f f0 d5 03 00             load.ref <@03d5f0> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@03e0a7> - <@03e0ac>): valuePtr: pointer := value
	<.main+2167 @03e0a7> : 1f f0 d5 03 00             load.ref <@03d5f0> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@03e0ac> - <@03e0b6>): valueVar: variant := value
	<.main+2172 @03e0ac> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2177 @03e0b1> : 1f f0 d5 03 00             load.ref <@03d5f0> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@03e0b6> - <@03e0b9>): fromRef: int64 := valueRef
	<.main+2182 @03e0b6> : 12 03                      dup.x1 sp(3)
	<.main+2184 @03e0b8> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@03e0b9> - <@03e0bb>): fromPtr: int64 := valuePtr
	<.main+2185 @03e0b9> : 12 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@03e0bb> - <@03e0bd>): fromVar: int64 := valueVar
	<.main+2187 @03e0bb> : 12 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@03e0bd> - <@03e0c2>): nullRef: int64 := null
	<.main+2189 @03e0bd> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@03e0c2> - <@03e0c7>): nullPtr: pointer := null
	<.main+2194 @03e0c2> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@03e0c7> - <@03e0d1>): nullVar: variant := null
	<.main+2199 @03e0c7> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2204 @03e0cc> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@03e0d1> - <@03e0d6>): nullTyp: typename := null
	<.main+2209 @03e0d1> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@03e0d6> - <@03e0db>): nullFun: function := null
	<.main+2214 @03e0d6> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@03e0db> - <@03e0e0>): nullObj: object := null
	<.main+2219 @03e0db> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@03e0e0> - <@03e0e5>): typePtr: pointer := int64
	<.main+2224 @03e0e0> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@03e0e5> - <@03e0ef>): typeVar: variant := int64
	<.main+2229 @03e0e5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2234 @03e0ea> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@03e0ef> - <@03e0f4>): typeTyp: typename := int64
	<.main+2239 @03e0ef> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@03e0f4> - <@03e0f8>): local: int64 := value
	<.main+2244 @03e0f4> : 2b f0 d5 03                load.m64 <@03d5f0> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@03e0f8> - <@03e0fa>): copyVal: int64 := local
	<.main+2248 @03e0f8> : 13 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@03e0fa> - <@03e0fc>): copyRef: int64 := valueRef
	<.main+2250 @03e0fa> : 12 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@03e0fc> - <@03e0fe>): copyPtr: pointer := valuePtr
	<.main+2252 @03e0fc> : 12 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@03e0fe> - <@03e100>): copyVar: variant := valueVar
	<.main+2254 @03e0fe> : 13 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@03e100> - <@03e102>): copyTyp: typename := typeTyp
	<.main+2256 @03e100> : 12 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@03e102> - <@03e107>): ptrVoid: pointer := void
	<.main+2258 @03e102> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@03e107> - <@03e10c>): ptrBool: pointer := bool
	<.main+2263 @03e107> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@03e10c> - <@03e111>): ptrChar: pointer := char
	<.main+2268 @03e10c> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@03e111> - <@03e116>): ptrInt8: pointer := int8
	<.main+2273 @03e111> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@03e116> - <@03e11b>): ptrInt16: pointer := int16
	<.main+2278 @03e116> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@03e11b> - <@03e120>): ptrInt32: pointer := int32
	<.main+2283 @03e11b> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@03e120> - <@03e125>): ptrInt64: pointer := int64
	<.main+2288 @03e120> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@03e125> - <@03e12a>): ptrUint8: pointer := uint8
	<.main+2293 @03e125> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@03e12a> - <@03e12f>): ptrUint16: pointer := uint16
	<.main+2298 @03e12a> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@03e12f> - <@03e134>): ptrUint32: pointer := uint32
	<.main+2303 @03e12f> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@03e134> - <@03e139>): ptrUint64: pointer := uint64
	<.main+2308 @03e134> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@03e139> - <@03e13e>): ptrFloat32: pointer := float32
	<.main+2313 @03e139> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@03e13e> - <@03e143>): ptrFloat64: pointer := float64
	<.main+2318 @03e13e> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@03e143> - <@03e148>): ptrTypename: pointer := typename
	<.main+2323 @03e143> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@03e148> - <@03e14d>): ptrFunction: pointer := function
	<.main+2328 @03e148> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@03e14d> - <@03e152>): ptrPointer: pointer := pointer
	<.main+2333 @03e14d> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@03e152> - <@03e157>): ptrVariant: pointer := variant
	<.main+2338 @03e152> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@03e157> - <@03e15c>): ptrObject: pointer := object
	<.main+2343 @03e157> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@03e15c> - <@03e166>): varVoid: variant := void
	<.main+2348 @03e15c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2353 @03e161> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@03e166> - <@03e170>): varBool: variant := bool
	<.main+2358 @03e166> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2363 @03e16b> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@03e170> - <@03e17a>): varChar: variant := char
	<.main+2368 @03e170> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2373 @03e175> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@03e17a> - <@03e184>): varInt8: variant := int8
	<.main+2378 @03e17a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2383 @03e17f> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@03e184> - <@03e18e>): varInt16: variant := int16
	<.main+2388 @03e184> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2393 @03e189> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@03e18e> - <@03e198>): varInt32: variant := int32
	<.main+2398 @03e18e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2403 @03e193> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@03e198> - <@03e1a2>): varInt64: variant := int64
	<.main+2408 @03e198> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2413 @03e19d> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@03e1a2> - <@03e1ac>): varUint8: variant := uint8
	<.main+2418 @03e1a2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2423 @03e1a7> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@03e1ac> - <@03e1b6>): varUint16: variant := uint16
	<.main+2428 @03e1ac> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2433 @03e1b1> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@03e1b6> - <@03e1c0>): varUint32: variant := uint32
	<.main+2438 @03e1b6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2443 @03e1bb> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@03e1c0> - <@03e1ca>): varUint64: variant := uint64
	<.main+2448 @03e1c0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2453 @03e1c5> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@03e1ca> - <@03e1d4>): varFloat32: variant := float32
	<.main+2458 @03e1ca> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2463 @03e1cf> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@03e1d4> - <@03e1de>): varFloat64: variant := float64
	<.main+2468 @03e1d4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2473 @03e1d9> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@03e1de> - <@03e1e8>): varTypename: variant := typename
	<.main+2478 @03e1de> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2483 @03e1e3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@03e1e8> - <@03e1f2>): varFunction: variant := function
	<.main+2488 @03e1e8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2493 @03e1ed> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@03e1f2> - <@03e1fc>): varPointer: variant := pointer
	<.main+2498 @03e1f2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2503 @03e1f7> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@03e1fc> - <@03e206>): varVariant: variant := variant
	<.main+2508 @03e1fc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2513 @03e201> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@03e206> - <@03e210>): varObject: variant := object
	<.main+2518 @03e206> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2523 @03e20b> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@03e210> - <@03e215>): typVoid: typename := void
	<.main+2528 @03e210> : 1f a0 00 00 00             load.ref <@0000a0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@03e215> - <@03e21a>): typBool: typename := bool
	<.main+2533 @03e215> : 1f 30 01 00 00             load.ref <@000130> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@03e21a> - <@03e21f>): typChar: typename := char
	<.main+2538 @03e21a> : 1f c0 01 00 00             load.ref <@0001c0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@03e21f> - <@03e224>): typInt8: typename := int8
	<.main+2543 @03e21f> : 1f 50 02 00 00             load.ref <@000250> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@03e224> - <@03e229>): typInt16: typename := int16
	<.main+2548 @03e224> : 1f e0 02 00 00             load.ref <@0002e0> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@03e229> - <@03e22e>): typInt32: typename := int32
	<.main+2553 @03e229> : 1f 70 03 00 00             load.ref <@000370> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@03e22e> - <@03e233>): typInt64: typename := int64
	<.main+2558 @03e22e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@03e233> - <@03e238>): typUint8: typename := uint8
	<.main+2563 @03e233> : 1f 90 04 00 00             load.ref <@000490> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@03e238> - <@03e23d>): typUint16: typename := uint16
	<.main+2568 @03e238> : 1f 20 05 00 00             load.ref <@000520> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@03e23d> - <@03e242>): typUint32: typename := uint32
	<.main+2573 @03e23d> : 1f b0 05 00 00             load.ref <@0005b0> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@03e242> - <@03e247>): typUint64: typename := uint64
	<.main+2578 @03e242> : 1f 40 06 00 00             load.ref <@000640> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@03e247> - <@03e24c>): typFloat32: typename := float32
	<.main+2583 @03e247> : 1f d0 06 00 00             load.ref <@0006d0> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@03e24c> - <@03e251>): typFloat64: typename := float64
	<.main+2588 @03e24c> : 1f 60 07 00 00             load.ref <@000760> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@03e251> - <@03e256>): typTypename: typename := typename
	<.main+2593 @03e251> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@03e256> - <@03e25b>): typFunction: typename := function
	<.main+2598 @03e256> : 1f 10 09 00 00             load.ref <@000910> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@03e25b> - <@03e260>): typPointer: typename := pointer
	<.main+2603 @03e25b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@03e260> - <@03e265>): typVariant: typename := variant
	<.main+2608 @03e260> : 1f 80 08 00 00             load.ref <@000880> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@03e265> - <@03e26a>): typObject: typename := object
	<.main+2613 @03e265> : 1f a8 09 00 00             load.ref <@0009a8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@03e26a> - <@03e26f>): valueOfPtr: pointer := pointer(value)
	<.main+2618 @03e26a> : 1f f0 d5 03 00             load.ref <@03d5f0> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@03e26f> - <@03e279>): valueOfVar: variant := variant(value)
	<.main+2623 @03e26f> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+2628 @03e274> : 1f f0 d5 03 00             load.ref <@03d5f0> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@03e279> - <@03e27e>): valueOfTyp: typename := typename(value)
	<.main+2633 @03e279> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@03e27e> - <@03e283>): typeOfValue: typename := typename(value)
	<.main+2638 @03e27e> : 1f 00 04 00 00             load.ref <@000400> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@03e283> - <@03e28a>): copyPtrFloat64: variant := ptrFloat64
	<.main+2643 @03e283> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+2648 @03e288> : 12 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@03e28a> - <@03e28c>): copyVarFloat64: pointer := varFloat64
	<.main+2650 @03e28a> : 12 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@03e28c> - <@03e2a1>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2652 @03e28c> : 18                         load.z32
	<.main+2653 @03e28d> : 1b 02 00 00 00             load.c32 2
	<.main+2658 @03e292> : 1b 07 00 00 00             load.c32 7
	<.main+2663 @03e297> : 1f 00 d6 03 00             load.ref <@03d600> ;funAdd(x: int32, y: int32): int32
	<.main+2668 @03e29c> : 02                         call
	<.main+2669 @03e29d> : 10 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@03e2a1> - <@03e2a6>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2673 @03e2a1> : 1f 00 d6 03 00             load.ref <@03d600> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@03e2a6> - <@03e2b8>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2678 @03e2a6> : 18                         load.z32
	<.main+2679 @03e2a7> : 1b 02 00 00 00             load.c32 2
	<.main+2684 @03e2ac> : 1b 08 00 00 00             load.c32 8
	<.main+2689 @03e2b1> : 12 03                      dup.x1 sp(3)
	<.main+2691 @03e2b3> : 02                         call
	<.main+2692 @03e2b4> : 10 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@03e2b8> - <@03e2bd>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2696 @03e2b8> : 1f 08 d6 03 00             load.ref <@03d608> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@03e2bd> - <@03e2cf>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2701 @03e2bd> : 18                         load.z32
	<.main+2702 @03e2be> : 1b 02 00 00 00             load.c32 2
	<.main+2707 @03e2c3> : 1b 06 00 00 00             load.c32 6
	<.main+2712 @03e2c8> : 12 03                      dup.x1 sp(3)
	<.main+2714 @03e2ca> : 02                         call
	<.main+2715 @03e2cb> : 10 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@03e2cf> - <@03e2d1>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2719 @03e2cf> : 12 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@03e2d1> - <@03e2e3>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2721 @03e2d1> : 18                         load.z32
	<.main+2722 @03e2d2> : 1b 02 00 00 00             load.c32 2
	<.main+2727 @03e2d7> : 1b 07 00 00 00             load.c32 7
	<.main+2732 @03e2dc> : 12 03                      dup.x1 sp(3)
	<.main+2734 @03e2de> : 02                         call
	<.main+2735 @03e2df> : 10 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@03e2e3> - <@03e2f3>): fibonacci_13: uint32 := fib(13)
	<.main+2739 @03e2e3> : 18                         load.z32
	<.main+2740 @03e2e4> : 1b 0d 00 00 00             load.c32 13
	<.main+2745 @03e2e9> : 1f 10 d6 03 00             load.ref <@03d610> ;fib(n: uint32): uint32
	<.main+2750 @03e2ee> : 02                         call
	<.main+2751 @03e2ef> : 10 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@03e2f3> - <@03e2f7>): sizeofVoid: int32 := sizeof(void)
	<.main+2755 @03e2f3> : 2a b8 00 00                load.m32 <@0000b8>
	test/lang/reflect.ci:4: (4 bytes: <@03e2f7> - <@03e2fb>): sizeofBool: int32 := sizeof(bool)
	<.main+2759 @03e2f7> : 2a 48 01 00                load.m32 <@000148>
	test/lang/reflect.ci:5: (4 bytes: <@03e2fb> - <@03e2ff>): sizeofChar: int32 := sizeof(char)
	<.main+2763 @03e2fb> : 2a d8 01 00                load.m32 <@0001d8>
	test/lang/reflect.ci:6: (4 bytes: <@03e2ff> - <@03e303>): sizeofInt8: int32 := sizeof(int8)
	<.main+2767 @03e2ff> : 2a 68 02 00                load.m32 <@000268>
	test/lang/reflect.ci:7: (4 bytes: <@03e303> - <@03e307>): sizeofInt16: int32 := sizeof(int16)
	<.main+2771 @03e303> : 2a f8 02 00                load.m32 <@0002f8>
	test/lang/reflect.ci:8: (4 bytes: <@03e307> - <@03e30b>): sizeofInt32: int32 := sizeof(int32)
	<.main+2775 @03e307> : 2a 88 03 00                load.m32 <@000388>
	test/lang/reflect.ci:9: (4 bytes: <@03e30b> - <@03e30f>): sizeofInt64: int32 := sizeof(int64)
	<.main+2779 @03e30b> : 2a 18 04 00                load.m32 <@000418>
	test/lang/reflect.ci:10: (4 bytes: <@03e30f> - <@03e313>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2783 @03e30f> : 2a a8 04 00                load.m32 <@0004a8>
	test/lang/reflect.ci:11: (4 bytes: <@03e313> - <@03e317>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2787 @03e313> : 2a 38 05 00                load.m32 <@000538>
	test/lang/reflect.ci:12: (4 bytes: <@03e317> - <@03e31b>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2791 @03e317> : 2a c8 05 00                load.m32 <@0005c8>
	test/lang/reflect.ci:13: (4 bytes: <@03e31b> - <@03e31f>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2795 @03e31b> : 2a 58 06 00                load.m32 <@000658>
	test/lang/reflect.ci:14: (4 bytes: <@03e31f> - <@03e323>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2799 @03e31f> : 2a e8 06 00                load.m32 <@0006e8>
	test/lang/reflect.ci:15: (4 bytes: <@03e323> - <@03e327>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2803 @03e323> : 2a 78 07 00                load.m32 <@000778>
	test/lang/reflect.ci:16: (4 bytes: <@03e327> - <@03e32b>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2807 @03e327> : 2a 08 08 00                load.m32 <@000808>
	test/lang/reflect.ci:17: (4 bytes: <@03e32b> - <@03e32f>): sizeofVariant: int32 := sizeof(variant)
	<.main+2811 @03e32b> : 2a 98 08 00                load.m32 <@000898>
	test/lang/reflect.ci:18: (4 bytes: <@03e32f> - <@03e333>): sizeofTypename: int32 := sizeof(typename)
	<.main+2815 @03e32f> : 2a 20 00 00                load.m32 <@000020> ;typename+24
	test/lang/reflect.ci:19: (4 bytes: <@03e333> - <@03e337>): sizeofFunction: int32 := sizeof(function)
	<.main+2819 @03e333> : 2a 28 09 00                load.m32 <@000928>
	test/lang/reflect.ci:20: (4 bytes: <@03e337> - <@03e33b>): sizeofObject: int32 := sizeof(object)
	<.main+2823 @03e337> : 2a c0 09 00                load.m32 <@0009c0>
	test/lang/reflect.ci:30: (5 bytes: <@03e33b> - <@03e340>): typeofRecord: typename := RecordSizeofExt
	<.main+2827 @03e33b> : 1f f0 8f 02 00             load.ref <@028ff0> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@03e340> - <@03e346>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2832 @03e340> : 12 00                      dup.x1 sp(0)
	<.main+2834 @03e342> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@03e346> - <@03e34d>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2838 @03e346> : 12 01                      dup.x1 sp(1)
	<.main+2840 @03e348> : 0b 20 00 00                inc.i32(+32)
	<.main+2844 @03e34c> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@03e34d> - <@03e354>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2845 @03e34d> : 12 02                      dup.x1 sp(2)
	<.main+2847 @03e34f> : 0b 18 00 00                inc.i32(+24)
	<.main+2851 @03e353> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@03e354> - <@03e35a>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2852 @03e354> : 12 03                      dup.x1 sp(3)
	<.main+2854 @03e356> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@03e35a> - <@03e360>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2858 @03e35a> : 12 04                      dup.x1 sp(4)
	<.main+2860 @03e35c> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@03e360> - <@03e366>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2864 @03e360> : 12 05                      dup.x1 sp(5)
	<.main+2866 @03e362> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@03e366> - <@03e36c>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2870 @03e366> : 12 00                      dup.x1 sp(0)
	<.main+2872 @03e368> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@03e36c> - <@03e373>): offsetOfBase: int32 := typeofBase.offset
	<.main+2876 @03e36c> : 12 01                      dup.x1 sp(1)
	<.main+2878 @03e36e> : 0b 20 00 00                inc.i32(+32)
	<.main+2882 @03e372> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@03e373> - <@03e37a>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2883 @03e373> : 12 02                      dup.x1 sp(2)
	<.main+2885 @03e375> : 0b 18 00 00                inc.i32(+24)
	<.main+2889 @03e379> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@03e37a> - <@03e380>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2890 @03e37a> : 12 03                      dup.x1 sp(3)
	<.main+2892 @03e37c> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@03e380> - <@03e386>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2896 @03e380> : 12 04                      dup.x1 sp(4)
	<.main+2898 @03e382> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@03e386> - <@03e38c>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2902 @03e386> : 12 05                      dup.x1 sp(5)
	<.main+2904 @03e388> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@03e38c> - <@03e393>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2908 @03e38c> : 12 00                      dup.x1 sp(0)
	<.main+2910 @03e38e> : 0b 20 00 00                inc.i32(+32)
	<.main+2914 @03e392> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@03e393> - <@03e39a>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2915 @03e393> : 12 01                      dup.x1 sp(1)
	<.main+2917 @03e395> : 0b 18 00 00                inc.i32(+24)
	<.main+2921 @03e399> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@03e39a> - <@03e3a0>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2922 @03e39a> : 12 02                      dup.x1 sp(2)
	<.main+2924 @03e39c> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@03e3a0> - <@03e3a7>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2928 @03e3a0> : 12 00                      dup.x1 sp(0)
	<.main+2930 @03e3a2> : 0b 20 00 00                inc.i32(+32)
	<.main+2934 @03e3a6> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@03e3a7> - <@03e3ae>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2935 @03e3a7> : 12 01                      dup.x1 sp(1)
	<.main+2937 @03e3a9> : 0b 18 00 00                inc.i32(+24)
	<.main+2941 @03e3ad> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@03e3ae> - <@03e3b7>): pi64: float64 := 3.141593
	<.main+2942 @03e3ae> : 1e 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@03e3b7> - <@03e3c0>): e64: float64 := 2.718282
	<.main+2951 @03e3b7> : 1e 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@03e3c0> - <@03e3c3>): pi32: float32 := pi64
	<.main+2960 @03e3c0> : 13 02                      dup.x2 sp(2)
	<.main+2962 @03e3c2> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@03e3c3> - <@03e3c6>): e32: float32 := e64
	<.main+2963 @03e3c3> : 13 01                      dup.x2 sp(1)
	<.main+2965 @03e3c5> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@03e3c6> - <@03e3cd>): r_comp: int32 := int32(14 << 3)
	<.main+2966 @03e3c6> : 1b 0e 00 00 00             load.c32 14
	<.main+2971 @03e3cb> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@03e3cd> - <@03e3d4>): g_comp: int32 := int32(63 << 2)
	<.main+2973 @03e3cd> : 1b 3f 00 00 00             load.c32 63
	<.main+2978 @03e3d2> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@03e3d4> - <@03e3db>): b_comp: int32 := int32(31 << 3)
	<.main+2980 @03e3d4> : 1b 1f 00 00 00             load.c32 31
	<.main+2985 @03e3d9> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@03e3db> - <@03e3f7>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2987 @03e3db> : 12 02                      dup.x1 sp(2)
	<.main+2989 @03e3dd> : 3f 48                      b32.shl 0x008
	<.main+2991 @03e3df> : 1b 00 f8 00 00             load.c32 63488
	<.main+2996 @03e3e4> : 31                         and.b32
	<.main+2997 @03e3e5> : 12 02                      dup.x1 sp(2)
	<.main+2999 @03e3e7> : 3f 43                      b32.shl 0x003
	<.main+3001 @03e3e9> : 1b e0 07 00 00             load.c32 2016
	<.main+3006 @03e3ee> : 31                         and.b32
	<.main+3007 @03e3ef> : 32                         or.b32
	<.main+3008 @03e3f0> : 12 01                      dup.x1 sp(1)
	<.main+3010 @03e3f2> : 3f c3                      b32.sar 0x003
	<.main+3012 @03e3f4> : 3f 05                      b32.and 0x01f
	<.main+3014 @03e3f6> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@03e3f7> - <@03e411>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3015 @03e3f7> : 12 03                      dup.x1 sp(3)
	<.main+3017 @03e3f9> : 3f 50                      b32.shl 0x010
	<.main+3019 @03e3fb> : 1b 00 00 ff 00             load.c32 16711680
	<.main+3024 @03e400> : 31                         and.b32
	<.main+3025 @03e401> : 12 03                      dup.x1 sp(3)
	<.main+3027 @03e403> : 3f 48                      b32.shl 0x008
	<.main+3029 @03e405> : 1b 00 ff 00 00             load.c32 65280
	<.main+3034 @03e40a> : 31                         and.b32
	<.main+3035 @03e40b> : 32                         or.b32
	<.main+3036 @03e40c> : 12 02                      dup.x1 sp(2)
	<.main+3038 @03e40e> : 3f 08                      b32.and 0x0ff
	<.main+3040 @03e410> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@03e411> - <@03e421>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3041 @03e411> : 12 01                      dup.x1 sp(1)
	<.main+3043 @03e413> : 1b 0b 00 00 00             load.c32 11
	<.main+3048 @03e418> : 1b 05 00 00 00             load.c32 5
	<.main+3053 @03e41d> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@03e421> - <@03e431>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3057 @03e421> : 12 02                      dup.x1 sp(2)
	<.main+3059 @03e423> : 1b 05 00 00 00             load.c32 5
	<.main+3064 @03e428> : 1b 06 00 00 00             load.c32 6
	<.main+3069 @03e42d> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@03e431> - <@03e43d>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3073 @03e431> : 12 03                      dup.x1 sp(3)
	<.main+3075 @03e433> : 18                         load.z32
	<.main+3076 @03e434> : 1b 05 00 00 00             load.c32 5
	<.main+3081 @03e439> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@03e43d> - <@03e44d>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3085 @03e43d> : 12 04                      dup.x1 sp(4)
	<.main+3087 @03e43f> : 1b 0b 00 00 00             load.c32 11
	<.main+3092 @03e444> : 1b 05 00 00 00             load.c32 5
	<.main+3097 @03e449> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@03e44d> - <@03e45d>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3101 @03e44d> : 12 05                      dup.x1 sp(5)
	<.main+3103 @03e44f> : 1b 05 00 00 00             load.c32 5
	<.main+3108 @03e454> : 1b 06 00 00 00             load.c32 6
	<.main+3113 @03e459> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@03e45d> - <@03e469>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3117 @03e45d> : 12 06                      dup.x1 sp(6)
	<.main+3119 @03e45f> : 18                         load.z32
	<.main+3120 @03e460> : 1b 05 00 00 00             load.c32 5
	<.main+3125 @03e465> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@03e469> - <@03e479>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3129 @03e469> : 12 06                      dup.x1 sp(6)
	<.main+3131 @03e46b> : 1b 10 00 00 00             load.c32 16
	<.main+3136 @03e470> : 1b 08 00 00 00             load.c32 8
	<.main+3141 @03e475> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@03e479> - <@03e489>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3145 @03e479> : 12 07                      dup.x1 sp(7)
	<.main+3147 @03e47b> : 1b 08 00 00 00             load.c32 8
	<.main+3152 @03e480> : 1b 08 00 00 00             load.c32 8
	<.main+3157 @03e485> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@03e489> - <@03e495>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3161 @03e489> : 12 08                      dup.x1 sp(8)
	<.main+3163 @03e48b> : 18                         load.z32
	<.main+3164 @03e48c> : 1b 08 00 00 00             load.c32 8
	<.main+3169 @03e491> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@03e495> - <@03e4a5>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3173 @03e495> : 12 09                      dup.x1 sp(9)
	<.main+3175 @03e497> : 1b 10 00 00 00             load.c32 16
	<.main+3180 @03e49c> : 1b 08 00 00 00             load.c32 8
	<.main+3185 @03e4a1> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@03e4a5> - <@03e4b5>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3189 @03e4a5> : 12 0a                      dup.x1 sp(10)
	<.main+3191 @03e4a7> : 1b 08 00 00 00             load.c32 8
	<.main+3196 @03e4ac> : 1b 08 00 00 00             load.c32 8
	<.main+3201 @03e4b1> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@03e4b5> - <@03e4c1>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3205 @03e4b5> : 12 0b                      dup.x1 sp(11)
	<.main+3207 @03e4b7> : 18                         load.z32
	<.main+3208 @03e4b8> : 1b 08 00 00 00             load.c32 8
	<.main+3213 @03e4bd> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@03e4c1> - <@03e4d1>): sinF64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3217 @03e4c1> : 13 15                      dup.x2 sp(21)
	<.main+3219 @03e4c3> : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3228 @03e4cc> : 84                         div.f64
	<.main+3229 @03e4cd> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@03e4d1> - <@03e4e1>): cosF64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3233 @03e4d1> : 13 17                      dup.x2 sp(23)
	<.main+3235 @03e4d3> : 1e 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3244 @03e4dc> : 84                         div.f64
	<.main+3245 @03e4dd> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@03e4e1> - <@03e4f1>): tanF64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3249 @03e4e1> : 13 19                      dup.x2 sp(25)
	<.main+3251 @03e4e3> : 1e 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3260 @03e4ec> : 84                         div.f64
	<.main+3261 @03e4ed> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@03e4f1> - <@03e4fd>): logF64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3265 @03e4f1> : 13 19                      dup.x2 sp(25)
	<.main+3267 @03e4f3> : 13 1b                      dup.x2 sp(27)
	<.main+3269 @03e4f5> : 83                         mul.f64
	<.main+3270 @03e4f6> : 13 1b                      dup.x2 sp(27)
	<.main+3272 @03e4f8> : 83                         mul.f64
	<.main+3273 @03e4f9> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@03e4fd> - <@03e50a>): expF64: float64 := float64.exp(1.000000)
	<.main+3277 @03e4fd> : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3286 @03e506> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@03e50a> - <@03e51c>): powF64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3290 @03e50a> : 13 1f                      dup.x2 sp(31)
	<.main+3292 @03e50c> : 13 21                      dup.x2 sp(33)
	<.main+3294 @03e50e> : 83                         mul.f64
	<.main+3295 @03e50f> : 1e 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3304 @03e518> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@03e51c> - <@03e525>): sqrtF64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3308 @03e51c> : 13 21                      dup.x2 sp(33)
	<.main+3310 @03e51e> : 13 23                      dup.x2 sp(35)
	<.main+3312 @03e520> : 83                         mul.f64
	<.main+3313 @03e521> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@03e525> - <@03e534>): atanF64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3317 @03e525> : 13 23                      dup.x2 sp(35)
	<.main+3319 @03e527> : 1e 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3328 @03e530> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@03e534> - <@03e540>): sinF32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3332 @03e534> : 12 22                      dup.x1 sp(34)
	<.main+3334 @03e536> : 1d 00 00 00 40             load.f32 2.000000
	<.main+3339 @03e53b> : 74                         div.f32
	<.main+3340 @03e53c> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@03e540> - <@03e54c>): cosF32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3344 @03e540> : 12 23                      dup.x1 sp(35)
	<.main+3346 @03e542> : 1d 00 00 00 40             load.f32 2.000000
	<.main+3351 @03e547> : 74                         div.f32
	<.main+3352 @03e548> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@03e54c> - <@03e558>): tanF32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3356 @03e54c> : 12 24                      dup.x1 sp(36)
	<.main+3358 @03e54e> : 1d 00 00 80 40             load.f32 4.000000
	<.main+3363 @03e553> : 74                         div.f32
	<.main+3364 @03e554> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@03e558> - <@03e564>): logF32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3368 @03e558> : 12 24                      dup.x1 sp(36)
	<.main+3370 @03e55a> : 12 25                      dup.x1 sp(37)
	<.main+3372 @03e55c> : 73                         mul.f32
	<.main+3373 @03e55d> : 12 25                      dup.x1 sp(37)
	<.main+3375 @03e55f> : 73                         mul.f32
	<.main+3376 @03e560> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@03e564> - <@03e56d>): expF32: float32 := float32.exp(1.000000)
	<.main+3380 @03e564> : 1d 00 00 80 3f             load.f32 1.000000
	<.main+3385 @03e569> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@03e56d> - <@03e57b>): powF32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3389 @03e56d> : 12 27                      dup.x1 sp(39)
	<.main+3391 @03e56f> : 12 28                      dup.x1 sp(40)
	<.main+3393 @03e571> : 73                         mul.f32
	<.main+3394 @03e572> : 1d 00 00 00 3f             load.f32 0.500000
	<.main+3399 @03e577> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@03e57b> - <@03e584>): sqrtF32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3403 @03e57b> : 12 28                      dup.x1 sp(40)
	<.main+3405 @03e57d> : 12 29                      dup.x1 sp(41)
	<.main+3407 @03e57f> : 73                         mul.f32
	<.main+3408 @03e580> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@03e584> - <@03e58f>): atanF32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3412 @03e584> : 12 29                      dup.x1 sp(41)
	<.main+3414 @03e586> : 1d 00 00 80 3f             load.f32 1.000000
	<.main+3419 @03e58b> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/memory.ci:7: (14 bytes: <@03e58f> - <@03e59d>): p1: pointer := malloc(1024)
	<.main+3423 @03e58f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3428 @03e594> : 1b 00 04 00 00             load.c32 1024
	<.main+3433 @03e599> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@03e59d> - <@03e5ab>): p2: pointer := malloc(80)
	<.main+3437 @03e59d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3442 @03e5a2> : 1b 50 00 00 00             load.c32 80
	<.main+3447 @03e5a7> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@03e5ab> - <@03e5b9>): p3: pointer := malloc(160)
	<.main+3451 @03e5ab> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3456 @03e5b0> : 1b a0 00 00 00             load.c32 160
	<.main+3461 @03e5b5> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@03e5b9> - <@03e5c7>): p4: pointer := malloc(820)
	<.main+3465 @03e5b9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3470 @03e5be> : 1b 34 03 00 00             load.c32 820
	<.main+3475 @03e5c3> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@03e5c7> - <@03e5d7>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3479 @03e5c7> : 12 03                      dup.x1 sp(3)
	<.main+3481 @03e5c9> : 18                         load.z32
	<.main+3482 @03e5ca> : 1b 00 04 00 00             load.c32 1024
	<.main+3487 @03e5cf> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3491 @03e5d3> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@03e5d7> - <@03e5e8>): pointer.copy(void(void(p1, p3), 160));
	<.main+3495 @03e5d7> : 12 03                      dup.x1 sp(3)
	<.main+3497 @03e5d9> : 12 02                      dup.x1 sp(2)
	<.main+3499 @03e5db> : 1b a0 00 00 00             load.c32 160
	<.main+3504 @03e5e0> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3508 @03e5e4> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@03e5e8> - <@03e5f3>): free(p1);
	<.main+3512 @03e5e8> : 12 03                      dup.x1 sp(3)
	<.main+3514 @03e5ea> : 18                         load.z32
	<.main+3515 @03e5eb> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3519 @03e5ef> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@03e5f3> - <@03e5fe>): free(p2);
	<.main+3523 @03e5f3> : 12 02                      dup.x1 sp(2)
	<.main+3525 @03e5f5> : 18                         load.z32
	<.main+3526 @03e5f6> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3530 @03e5fa> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@03e5fe> - <@03e609>): free(p3);
	<.main+3534 @03e5fe> : 12 01                      dup.x1 sp(1)
	<.main+3536 @03e600> : 18                         load.z32
	<.main+3537 @03e601> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3541 @03e605> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@03e609> - <@03e614>): free(p4);
	<.main+3545 @03e609> : 12 00                      dup.x1 sp(0)
	<.main+3547 @03e60b> : 18                         load.z32
	<.main+3548 @03e60c> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3552 @03e610> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@03e614> - <@03e61d>): val1: int64 := 42
	<.main+3556 @03e614> : 1c 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@03e61d> - <@03e626>): val2: int64 := 96
	<.main+3565 @03e61d> : 1c 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@03e626> - <@03e648>): debug(void("val1", val1));
	<.main+3574 @03e626> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3579 @03e62b> : 1b 1a 00 00 00             load.c32 26
	<.main+3584 @03e630> : 1b 0e 00 00 00             load.c32 14
	<.main+3589 @03e635> : 18                         load.z32
	<.main+3590 @03e636> : 1f ed b6 02 00             load.ref <@02b6ed> ;"val1"
	<.main+3595 @03e63b> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3600 @03e640> : 11 20 00 00                load.sp(+32)
	<.main+3604 @03e644> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@03e648> - <@03e66a>): debug(void("val2", val2));
	<.main+3608 @03e648> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3613 @03e64d> : 1b 1b 00 00 00             load.c32 27
	<.main+3618 @03e652> : 1b 0e 00 00 00             load.c32 14
	<.main+3623 @03e657> : 18                         load.z32
	<.main+3624 @03e658> : 1f f2 b6 02 00             load.ref <@02b6f2> ;"val2"
	<.main+3629 @03e65d> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3634 @03e662> : 11 18 00 00                load.sp(+24)
	<.main+3638 @03e666> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@03e66a> - <@03e67e>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3642 @03e66a> : 11 00 00 00                load.sp(+0)
	<.main+3646 @03e66e> : 11 0c 00 00                load.sp(+12)
	<.main+3650 @03e672> : 2a 18 04 00                load.m32 <@000418>
	<.main+3654 @03e676> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3658 @03e67a> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@03e67e> - <@03e68f>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3662 @03e67e> : 11 08 00 00                load.sp(+8)
	<.main+3666 @03e682> : 18                         load.z32
	<.main+3667 @03e683> : 2a 18 04 00                load.m32 <@000418>
	<.main+3671 @03e687> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3675 @03e68b> : 10 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@03e68f> - <@03e6b1>): debug(void("val1", val1));
	<.main+3679 @03e68f> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3684 @03e694> : 1b 20 00 00 00             load.c32 32
	<.main+3689 @03e699> : 1b 0e 00 00 00             load.c32 14
	<.main+3694 @03e69e> : 18                         load.z32
	<.main+3695 @03e69f> : 1f ed b6 02 00             load.ref <@02b6ed> ;"val1"
	<.main+3700 @03e6a4> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3705 @03e6a9> : 11 20 00 00                load.sp(+32)
	<.main+3709 @03e6ad> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@03e6b1> - <@03e6d3>): debug(void("val2", val2));
	<.main+3713 @03e6b1> : 1f c0 b6 02 00             load.ref <@02b6c0> ;"test/stdc/memory.ci"
	<.main+3718 @03e6b6> : 1b 21 00 00 00             load.c32 33
	<.main+3723 @03e6bb> : 1b 0e 00 00 00             load.c32 14
	<.main+3728 @03e6c0> : 18                         load.z32
	<.main+3729 @03e6c1> : 1f f2 b6 02 00             load.ref <@02b6f2> ;"val2"
	<.main+3734 @03e6c6> : 1f 00 04 00 00             load.ref <@000400> ;int64
	<.main+3739 @03e6cb> : 11 18 00 00                load.sp(+24)
	<.main+3743 @03e6cf> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@03e6d3> - <@03e6e1>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3747 @03e6d3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3752 @03e6d8> : 1f 48 d6 03 00             load.ref <@03d648> ;noError(ptr: pointer): void
	<.main+3757 @03e6dd> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@03e6e1> - <@03e6ef>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3761 @03e6e1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3766 @03e6e6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3771 @03e6eb> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@03e6ef> - <@03e6fd>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3775 @03e6ef> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3780 @03e6f4> : 1f 50 d6 03 00             load.ref <@03d650> ;stackOverflow(ptr: pointer): void
	<.main+3785 @03e6f9> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@03e6fd> - <@03e70b>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3789 @03e6fd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3794 @03e702> : 1f 68 d6 03 00             load.ref <@03d668> ;divisionByZero(args: pointer): void
	<.main+3799 @03e707> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@03e70b> - <@03e719>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3803 @03e70b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3808 @03e710> : 1f d0 d6 03 00             load.ref <@03d6d0> ;invalidInstruction(args: pointer): void
	<.main+3813 @03e715> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@03e719> - <@03e727>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3817 @03e719> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3822 @03e71e> : 1f c0 d6 03 00             load.ref <@03d6c0> ;invalidMemoryAccess(args: pointer): void
	<.main+3827 @03e723> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@03e727> - <@03e735>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3831 @03e727> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3836 @03e72c> : 1f 78 d6 03 00             load.ref <@03d678> ;abortExecution(args: pointer): void
	<.main+3841 @03e731> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@03e735> - <@03e739>): arrFixedNoInit: int64[7]
	<.main+3845 @03e735> : 10 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@03e739> - <@03e73d>): arrArrayNoInit: int64[*]
	<.main+3849 @03e739> : 10 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@03e73d> - <@03e741>): arrSliceNoInit: int64[]
	<.main+3853 @03e73d> : 10 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@03e741> - <@03e76e>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3857 @03e741> : 18                         load.z32
	<.main+3858 @03e742> : 04 1c 00 00                jmp <.main+3886 @03e75e>
	test/lang/array.ci:55: (20 bytes: <@03e746> - <@03e75a>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3862 @03e746> : 1b 2a 00 00 00             load.c32 42
	<.main+3867 @03e74b> : 12 01                      dup.x1 sp(1)
	<.main+3869 @03e74d> : 51                         add.i32
	<.main+3870 @03e74e> : 5c                         i32.2i64
	<.main+3871 @03e74f> : 11 18 00 00                load.sp(+24)
	<.main+3875 @03e753> : 12 03                      dup.x1 sp(3)
	<.main+3877 @03e755> : 0c 08 00 00                mad.u32 8
	<.main+3881 @03e759> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@03e75a> - <@03e75e>): int32(i := int32(i + 1))
	<.main+3882 @03e75a> : 0b 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@03e75e> - <@03e76a>): bool(i < arrFixedNoInit.length)
	<.main+3886 @03e75e> : 12 00                      dup.x1 sp(0)
	<.main+3888 @03e760> : 1b 07 00 00 00             load.c32 7
	<.main+3893 @03e765> : 58                         clt.i32
	<.main+3894 @03e766> : 05 e0 ff ff                jnz <.main+3862 @03e746>
	<.main+3898 @03e76a> : 10 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@03e76e> - <@03e773>): arrArrayInitNull: int64[*] := null
	<.main+3902 @03e76e> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@03e773> - <@03e779>): arrSliceInitNull: int64[] := null
	<.main+3907 @03e773> : 18                         load.z32
	<.main+3908 @03e774> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@03e779> - <@03e77d>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3913 @03e779> : 11 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@03e77d> - <@03e786>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3917 @03e77d> : 1b 07 00 00 00             load.c32 7
	<.main+3922 @03e782> : 11 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@03e786> - <@03e788>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3926 @03e786> : 12 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@03e788> - <@03e78a>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3928 @03e788> : 13 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@03e78a> - <@03e78c>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3930 @03e78a> : 12 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@03e78c> - <@03e790>): strFixed: char[7]
	<.main+3932 @03e78c> : 10 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@03e790> - <@03e7a6>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+3936 @03e790> : 11 00 00 00                load.sp(+0)
	<.main+3940 @03e794> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	<.main+3945 @03e799> : 1b 07 00 00 00             load.c32 7
	<.main+3950 @03e79e> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3954 @03e7a2> : 10 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@03e7a6> - <@03e7c8>): debug(void("string as variant", strFixed));
	<.main+3958 @03e7a6> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+3963 @03e7ab> : 1b 53 00 00 00             load.c32 83
	<.main+3968 @03e7b0> : 1b 0e 00 00 00             load.c32 14
	<.main+3973 @03e7b5> : 18                         load.z32
	<.main+3974 @03e7b6> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+3979 @03e7bb> : 1f 60 e1 02 00             load.ref <@02e160>
	<.main+3984 @03e7c0> : 11 18 00 00                load.sp(+24)
	<.main+3988 @03e7c4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@03e7c8> - <@03e7ea>): debug(void("string to variant", variant(strFixed)));
	<.main+3992 @03e7c8> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+3997 @03e7cd> : 1b 54 00 00 00             load.c32 84
	<.main+4002 @03e7d2> : 1b 0e 00 00 00             load.c32 14
	<.main+4007 @03e7d7> : 18                         load.z32
	<.main+4008 @03e7d8> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4013 @03e7dd> : 1f 60 e1 02 00             load.ref <@02e160>
	<.main+4018 @03e7e2> : 11 18 00 00                load.sp(+24)
	<.main+4022 @03e7e6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@03e7ea> - <@03e7ef>): strArray: char[*] := "string"
	<.main+4026 @03e7ea> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/array.ci:87: (32 bytes: <@03e7ef> - <@03e80f>): debug(void("string as variant", strArray));
	<.main+4031 @03e7ef> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4036 @03e7f4> : 1b 57 00 00 00             load.c32 87
	<.main+4041 @03e7f9> : 1b 0e 00 00 00             load.c32 14
	<.main+4046 @03e7fe> : 18                         load.z32
	<.main+4047 @03e7ff> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+4052 @03e804> : 1f f8 e2 02 00             load.ref <@02e2f8>
	<.main+4057 @03e809> : 12 06                      dup.x1 sp(6)
	<.main+4059 @03e80b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@03e80f> - <@03e82f>): debug(void("string to variant", variant(strArray)));
	<.main+4063 @03e80f> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4068 @03e814> : 1b 58 00 00 00             load.c32 88
	<.main+4073 @03e819> : 1b 0e 00 00 00             load.c32 14
	<.main+4078 @03e81e> : 18                         load.z32
	<.main+4079 @03e81f> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4084 @03e824> : 1f f8 e2 02 00             load.ref <@02e2f8>
	<.main+4089 @03e829> : 12 06                      dup.x1 sp(6)
	<.main+4091 @03e82b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@03e82f> - <@03e839>): strSlice: char[] := "string"
	<.main+4095 @03e82f> : 1b 06 00 00 00             load.c32 6
	<.main+4100 @03e834> : 1f 5f e5 01 00             load.ref <@01e55f> ;"string"
	test/lang/array.ci:91: (32 bytes: <@03e839> - <@03e859>): debug(void("string as variant", strSlice));
	<.main+4105 @03e839> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4110 @03e83e> : 1b 5b 00 00 00             load.c32 91
	<.main+4115 @03e843> : 1b 0e 00 00 00             load.c32 14
	<.main+4120 @03e848> : 18                         load.z32
	<.main+4121 @03e849> : 1f c3 d4 02 00             load.ref <@02d4c3> ;"string as variant"
	<.main+4126 @03e84e> : 1f 08 e4 02 00             load.ref <@02e408>
	<.main+4131 @03e853> : 12 06                      dup.x1 sp(6)
	<.main+4133 @03e855> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@03e859> - <@03e879>): debug(void("string to variant", variant(strSlice)));
	<.main+4137 @03e859> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4142 @03e85e> : 1b 5c 00 00 00             load.c32 92
	<.main+4147 @03e863> : 1b 0e 00 00 00             load.c32 14
	<.main+4152 @03e868> : 18                         load.z32
	<.main+4153 @03e869> : 1f d5 d4 02 00             load.ref <@02d4d5> ;"string to variant"
	<.main+4158 @03e86e> : 1f 08 e4 02 00             load.ref <@02e408>
	<.main+4163 @03e873> : 12 06                      dup.x1 sp(6)
	<.main+4165 @03e875> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@03e879> - <@03e8ac>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4169 @03e879> : 12 10                      dup.x1 sp(16)
	<.main+4171 @03e87b> : 18                         load.z32
	<.main+4172 @03e87c> : 38                         clt.u32
	<.main+4173 @03e87d> : 05 08 00 00                jnz <.main+4181 @03e885>
	<.main+4177 @03e881> : 04 2b 00 00                jmp <.main+4220 @03e8ac>
	<.main+4181 @03e885> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4186 @03e88a> : 1b 62 00 00 00             load.c32 98
	<.main+4191 @03e88f> : 1b fe ff ff ff             load.c32 -2
	<.main+4196 @03e894> : 1b 80 00 00 00             load.c32 128
	<.main+4201 @03e899> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4206 @03e89e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4211 @03e8a3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4216 @03e8a8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@03e8ac> - <@03e8df>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4220 @03e8ac> : 12 0d                      dup.x1 sp(13)
	<.main+4222 @03e8ae> : 18                         load.z32
	<.main+4223 @03e8af> : 57                         ceq.i32
	<.main+4224 @03e8b0> : 06 08 00 00                jz <.main+4232 @03e8b8>
	<.main+4228 @03e8b4> : 04 2b 00 00                jmp <.main+4271 @03e8df>
	<.main+4232 @03e8b8> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4237 @03e8bd> : 1b 63 00 00 00             load.c32 99
	<.main+4242 @03e8c2> : 1b fe ff ff ff             load.c32 -2
	<.main+4247 @03e8c7> : 1b 80 00 00 00             load.c32 128
	<.main+4252 @03e8cc> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4257 @03e8d1> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4262 @03e8d6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4267 @03e8db> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@03e8df> - <@03e91a>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4271 @03e8df> : 13 12                      dup.x2 sp(18)
	<.main+4273 @03e8e1> : 1c 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4282 @03e8ea> : 67                         ceq.i64
	<.main+4283 @03e8eb> : 06 08 00 00                jz <.main+4291 @03e8f3>
	<.main+4287 @03e8ef> : 04 2b 00 00                jmp <.main+4330 @03e91a>
	<.main+4291 @03e8f3> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4296 @03e8f8> : 1b 65 00 00 00             load.c32 101
	<.main+4301 @03e8fd> : 1b fe ff ff ff             load.c32 -2
	<.main+4306 @03e902> : 1b 80 00 00 00             load.c32 128
	<.main+4311 @03e907> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4316 @03e90c> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4321 @03e911> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4326 @03e916> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@03e91a> - <@03e933>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4330 @03e91a> : 1b 07 00 00 00             load.c32 7
	<.main+4335 @03e91f> : 1b 07 00 00 00             load.c32 7
	<.main+4340 @03e924> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4345 @03e929> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4350 @03e92e> : 02                         call
	<.main+4351 @03e92f> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@03e933> - <@03e949>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4355 @03e933> : 1b 07 00 00 00             load.c32 7
	<.main+4360 @03e938> : 12 0b                      dup.x1 sp(11)
	<.main+4362 @03e93a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4367 @03e93f> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4372 @03e944> : 02                         call
	<.main+4373 @03e945> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@03e949> - <@03e95f>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4377 @03e949> : 1b 07 00 00 00             load.c32 7
	<.main+4382 @03e94e> : 12 08                      dup.x1 sp(8)
	<.main+4384 @03e950> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4389 @03e955> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4394 @03e95a> : 02                         call
	<.main+4395 @03e95b> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@03e95f> - <@03e97f>): assertEq(void(0, lenSlice(null)));
	<.main+4399 @03e95f> : 18                         load.z32
	<.main+4400 @03e960> : 19                         load.z64
	<.main+4401 @03e961> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4406 @03e966> : 1f d8 d6 03 00             load.ref <@03d6d8> ;lenSlice(values: int64[]): int32
	<.main+4411 @03e96b> : 02                         call
	<.main+4412 @03e96c> : 10 f8 ff ff                inc.sp(-8)
	<.main+4416 @03e970> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4421 @03e975> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4426 @03e97a> : 02                         call
	<.main+4427 @03e97b> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@03e97f> - <@03e99c>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4431 @03e97f> : 18                         load.z32
	<.main+4432 @03e980> : 18                         load.z32
	<.main+4433 @03e981> : 13 0e                      dup.x2 sp(14)
	<.main+4435 @03e983> : 1f d8 d6 03 00             load.ref <@03d6d8> ;lenSlice(values: int64[]): int32
	<.main+4440 @03e988> : 02                         call
	<.main+4441 @03e989> : 10 f8 ff ff                inc.sp(-8)
	<.main+4445 @03e98d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4450 @03e992> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4455 @03e997> : 02                         call
	<.main+4456 @03e998> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@03e99c> - <@03e9c4>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4460 @03e99c> : 1b 07 00 00 00             load.c32 7
	<.main+4465 @03e9a1> : 18                         load.z32
	<.main+4466 @03e9a2> : 1b 07 00 00 00             load.c32 7
	<.main+4471 @03e9a7> : 11 54 00 00                load.sp(+84)
	<.main+4475 @03e9ab> : 1f d8 d6 03 00             load.ref <@03d6d8> ;lenSlice(values: int64[]): int32
	<.main+4480 @03e9b0> : 02                         call
	<.main+4481 @03e9b1> : 10 f8 ff ff                inc.sp(-8)
	<.main+4485 @03e9b5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4490 @03e9ba> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4495 @03e9bf> : 02                         call
	<.main+4496 @03e9c0> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@03e9c4> - <@03e9e5>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4500 @03e9c4> : 1b 07 00 00 00             load.c32 7
	<.main+4505 @03e9c9> : 18                         load.z32
	<.main+4506 @03e9ca> : 13 0b                      dup.x2 sp(11)
	<.main+4508 @03e9cc> : 1f d8 d6 03 00             load.ref <@03d6d8> ;lenSlice(values: int64[]): int32
	<.main+4513 @03e9d1> : 02                         call
	<.main+4514 @03e9d2> : 10 f8 ff ff                inc.sp(-8)
	<.main+4518 @03e9d6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4523 @03e9db> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4528 @03e9e0> : 02                         call
	<.main+4529 @03e9e1> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@03e9e5> - <@03ea06>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4533 @03e9e5> : 1b 07 00 00 00             load.c32 7
	<.main+4538 @03e9ea> : 18                         load.z32
	<.main+4539 @03e9eb> : 13 08                      dup.x2 sp(8)
	<.main+4541 @03e9ed> : 1f d8 d6 03 00             load.ref <@03d6d8> ;lenSlice(values: int64[]): int32
	<.main+4546 @03e9f2> : 02                         call
	<.main+4547 @03e9f3> : 10 f8 ff ff                inc.sp(-8)
	<.main+4551 @03e9f7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4556 @03e9fc> : 1f d8 c6 03 00             load.ref <@03c6d8> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4561 @03ea01> : 02                         call
	<.main+4562 @03ea02> : 10 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@03ea06> - <@03ed2d>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4566 @03ea06> : 18                         load.z32
	<.main+4567 @03ea07> : 04 16 03 00                jmp <.main+5357 @03ed1d>
	test/lang/array.ci:119: (9 bytes: <@03ea0b> - <@03ea14>): expected: int64 := int32(42 + i)
	<.main+4571 @03ea0b> : 1b 2a 00 00 00             load.c32 42
	<.main+4576 @03ea10> : 12 01                      dup.x1 sp(1)
	<.main+4578 @03ea12> : 51                         add.i32
	<.main+4579 @03ea13> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@03ea14> - <@03ea51>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4580 @03ea14> : 13 00                      dup.x2 sp(0)
	<.main+4582 @03ea16> : 11 5c 00 00                load.sp(+92)
	<.main+4586 @03ea1a> : 12 05                      dup.x1 sp(5)
	<.main+4588 @03ea1c> : 0c 08 00 00                mad.u32 8
	<.main+4592 @03ea20> : 23                         load.i64
	<.main+4593 @03ea21> : 67                         ceq.i64
	<.main+4594 @03ea22> : 06 08 00 00                jz <.main+4602 @03ea2a>
	<.main+4598 @03ea26> : 04 2b 00 00                jmp <.main+4641 @03ea51>
	<.main+4602 @03ea2a> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4607 @03ea2f> : 1b 78 00 00 00             load.c32 120
	<.main+4612 @03ea34> : 1b fe ff ff ff             load.c32 -2
	<.main+4617 @03ea39> : 1b 80 00 00 00             load.c32 128
	<.main+4622 @03ea3e> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4627 @03ea43> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4632 @03ea48> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4637 @03ea4d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@03ea51> - <@03ea8c>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4641 @03ea51> : 13 00                      dup.x2 sp(0)
	<.main+4643 @03ea53> : 12 10                      dup.x1 sp(16)
	<.main+4645 @03ea55> : 12 05                      dup.x1 sp(5)
	<.main+4647 @03ea57> : 0c 08 00 00                mad.u32 8
	<.main+4651 @03ea5b> : 23                         load.i64
	<.main+4652 @03ea5c> : 67                         ceq.i64
	<.main+4653 @03ea5d> : 06 08 00 00                jz <.main+4661 @03ea65>
	<.main+4657 @03ea61> : 04 2b 00 00                jmp <.main+4700 @03ea8c>
	<.main+4661 @03ea65> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4666 @03ea6a> : 1b 79 00 00 00             load.c32 121
	<.main+4671 @03ea6f> : 1b fe ff ff ff             load.c32 -2
	<.main+4676 @03ea74> : 1b 80 00 00 00             load.c32 128
	<.main+4681 @03ea79> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4686 @03ea7e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4691 @03ea83> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4696 @03ea88> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@03ea8c> - <@03eac7>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4700 @03ea8c> : 13 00                      dup.x2 sp(0)
	<.main+4702 @03ea8e> : 12 0e                      dup.x1 sp(14)
	<.main+4704 @03ea90> : 12 05                      dup.x1 sp(5)
	<.main+4706 @03ea92> : 0c 08 00 00                mad.u32 8
	<.main+4710 @03ea96> : 23                         load.i64
	<.main+4711 @03ea97> : 67                         ceq.i64
	<.main+4712 @03ea98> : 06 08 00 00                jz <.main+4720 @03eaa0>
	<.main+4716 @03ea9c> : 04 2b 00 00                jmp <.main+4759 @03eac7>
	<.main+4720 @03eaa0> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4725 @03eaa5> : 1b 7a 00 00 00             load.c32 122
	<.main+4730 @03eaaa> : 1b fe ff ff ff             load.c32 -2
	<.main+4735 @03eaaf> : 1b 80 00 00 00             load.c32 128
	<.main+4740 @03eab4> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4745 @03eab9> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4750 @03eabe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4755 @03eac3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@03eac7> - <@03eb0a>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4759 @03eac7> : 13 00                      dup.x2 sp(0)
	<.main+4761 @03eac9> : 19                         load.z64
	<.main+4762 @03eaca> : 12 06                      dup.x1 sp(6)
	<.main+4764 @03eacc> : 11 68 00 00                load.sp(+104)
	<.main+4768 @03ead0> : 1f e0 d6 03 00             load.ref <@03d6e0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4773 @03ead5> : 02                         call
	<.main+4774 @03ead6> : 10 f8 ff ff                inc.sp(-8)
	<.main+4778 @03eada> : 67                         ceq.i64
	<.main+4779 @03eadb> : 06 08 00 00                jz <.main+4787 @03eae3>
	<.main+4783 @03eadf> : 04 2b 00 00                jmp <.main+4826 @03eb0a>
	<.main+4787 @03eae3> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4792 @03eae8> : 1b 7c 00 00 00             load.c32 124
	<.main+4797 @03eaed> : 1b fe ff ff ff             load.c32 -2
	<.main+4802 @03eaf2> : 1b 80 00 00 00             load.c32 128
	<.main+4807 @03eaf7> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4812 @03eafc> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4817 @03eb01> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4822 @03eb06> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@03eb0a> - <@03eb4b>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4826 @03eb0a> : 13 00                      dup.x2 sp(0)
	<.main+4828 @03eb0c> : 19                         load.z64
	<.main+4829 @03eb0d> : 12 06                      dup.x1 sp(6)
	<.main+4831 @03eb0f> : 12 13                      dup.x1 sp(19)
	<.main+4833 @03eb11> : 1f e0 d6 03 00             load.ref <@03d6e0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4838 @03eb16> : 02                         call
	<.main+4839 @03eb17> : 10 f8 ff ff                inc.sp(-8)
	<.main+4843 @03eb1b> : 67                         ceq.i64
	<.main+4844 @03eb1c> : 06 08 00 00                jz <.main+4852 @03eb24>
	<.main+4848 @03eb20> : 04 2b 00 00                jmp <.main+4891 @03eb4b>
	<.main+4852 @03eb24> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4857 @03eb29> : 1b 7d 00 00 00             load.c32 125
	<.main+4862 @03eb2e> : 1b fe ff ff ff             load.c32 -2
	<.main+4867 @03eb33> : 1b 80 00 00 00             load.c32 128
	<.main+4872 @03eb38> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4877 @03eb3d> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4882 @03eb42> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4887 @03eb47> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@03eb4b> - <@03eb8c>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4891 @03eb4b> : 13 00                      dup.x2 sp(0)
	<.main+4893 @03eb4d> : 19                         load.z64
	<.main+4894 @03eb4e> : 12 06                      dup.x1 sp(6)
	<.main+4896 @03eb50> : 12 11                      dup.x1 sp(17)
	<.main+4898 @03eb52> : 1f e0 d6 03 00             load.ref <@03d6e0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4903 @03eb57> : 02                         call
	<.main+4904 @03eb58> : 10 f8 ff ff                inc.sp(-8)
	<.main+4908 @03eb5c> : 67                         ceq.i64
	<.main+4909 @03eb5d> : 06 08 00 00                jz <.main+4917 @03eb65>
	<.main+4913 @03eb61> : 04 2b 00 00                jmp <.main+4956 @03eb8c>
	<.main+4917 @03eb65> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4922 @03eb6a> : 1b 7e 00 00 00             load.c32 126
	<.main+4927 @03eb6f> : 1b fe ff ff ff             load.c32 -2
	<.main+4932 @03eb74> : 1b 80 00 00 00             load.c32 128
	<.main+4937 @03eb79> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+4942 @03eb7e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+4947 @03eb83> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4952 @03eb88> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@03eb8c> - <@03ebcf>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+4956 @03eb8c> : 13 00                      dup.x2 sp(0)
	<.main+4958 @03eb8e> : 19                         load.z64
	<.main+4959 @03eb8f> : 12 06                      dup.x1 sp(6)
	<.main+4961 @03eb91> : 11 68 00 00                load.sp(+104)
	<.main+4965 @03eb95> : 1f f0 d6 03 00             load.ref <@03d6f0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+4970 @03eb9a> : 02                         call
	<.main+4971 @03eb9b> : 10 f8 ff ff                inc.sp(-8)
	<.main+4975 @03eb9f> : 67                         ceq.i64
	<.main+4976 @03eba0> : 06 08 00 00                jz <.main+4984 @03eba8>
	<.main+4980 @03eba4> : 04 2b 00 00                jmp <.main+5023 @03ebcf>
	<.main+4984 @03eba8> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+4989 @03ebad> : 1b 80 00 00 00             load.c32 128
	<.main+4994 @03ebb2> : 1b fe ff ff ff             load.c32 -2
	<.main+4999 @03ebb7> : 1b 80 00 00 00             load.c32 128
	<.main+5004 @03ebbc> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5009 @03ebc1> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5014 @03ebc6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5019 @03ebcb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@03ebcf> - <@03ec10>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5023 @03ebcf> : 13 00                      dup.x2 sp(0)
	<.main+5025 @03ebd1> : 19                         load.z64
	<.main+5026 @03ebd2> : 12 06                      dup.x1 sp(6)
	<.main+5028 @03ebd4> : 12 13                      dup.x1 sp(19)
	<.main+5030 @03ebd6> : 1f f0 d6 03 00             load.ref <@03d6f0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5035 @03ebdb> : 02                         call
	<.main+5036 @03ebdc> : 10 f8 ff ff                inc.sp(-8)
	<.main+5040 @03ebe0> : 67                         ceq.i64
	<.main+5041 @03ebe1> : 06 08 00 00                jz <.main+5049 @03ebe9>
	<.main+5045 @03ebe5> : 04 2b 00 00                jmp <.main+5088 @03ec10>
	<.main+5049 @03ebe9> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5054 @03ebee> : 1b 81 00 00 00             load.c32 129
	<.main+5059 @03ebf3> : 1b fe ff ff ff             load.c32 -2
	<.main+5064 @03ebf8> : 1b 80 00 00 00             load.c32 128
	<.main+5069 @03ebfd> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5074 @03ec02> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5079 @03ec07> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5084 @03ec0c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@03ec10> - <@03ec51>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5088 @03ec10> : 13 00                      dup.x2 sp(0)
	<.main+5090 @03ec12> : 19                         load.z64
	<.main+5091 @03ec13> : 12 06                      dup.x1 sp(6)
	<.main+5093 @03ec15> : 12 11                      dup.x1 sp(17)
	<.main+5095 @03ec17> : 1f f0 d6 03 00             load.ref <@03d6f0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5100 @03ec1c> : 02                         call
	<.main+5101 @03ec1d> : 10 f8 ff ff                inc.sp(-8)
	<.main+5105 @03ec21> : 67                         ceq.i64
	<.main+5106 @03ec22> : 06 08 00 00                jz <.main+5114 @03ec2a>
	<.main+5110 @03ec26> : 04 2b 00 00                jmp <.main+5153 @03ec51>
	<.main+5114 @03ec2a> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5119 @03ec2f> : 1b 82 00 00 00             load.c32 130
	<.main+5124 @03ec34> : 1b fe ff ff ff             load.c32 -2
	<.main+5129 @03ec39> : 1b 80 00 00 00             load.c32 128
	<.main+5134 @03ec3e> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5139 @03ec43> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5144 @03ec48> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5149 @03ec4d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@03ec51> - <@03ec99>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5153 @03ec51> : 13 00                      dup.x2 sp(0)
	<.main+5155 @03ec53> : 19                         load.z64
	<.main+5156 @03ec54> : 12 06                      dup.x1 sp(6)
	<.main+5158 @03ec56> : 1b 07 00 00 00             load.c32 7
	<.main+5163 @03ec5b> : 11 6c 00 00                load.sp(+108)
	<.main+5167 @03ec5f> : 1f 00 d7 03 00             load.ref <@03d700> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5172 @03ec64> : 02                         call
	<.main+5173 @03ec65> : 10 f4 ff ff                inc.sp(-12)
	<.main+5177 @03ec69> : 67                         ceq.i64
	<.main+5178 @03ec6a> : 06 08 00 00                jz <.main+5186 @03ec72>
	<.main+5182 @03ec6e> : 04 2b 00 00                jmp <.main+5225 @03ec99>
	<.main+5186 @03ec72> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5191 @03ec77> : 1b 84 00 00 00             load.c32 132
	<.main+5196 @03ec7c> : 1b fe ff ff ff             load.c32 -2
	<.main+5201 @03ec81> : 1b 80 00 00 00             load.c32 128
	<.main+5206 @03ec86> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5211 @03ec8b> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5216 @03ec90> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5221 @03ec95> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@03ec99> - <@03ecda>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5225 @03ec99> : 13 00                      dup.x2 sp(0)
	<.main+5227 @03ec9b> : 19                         load.z64
	<.main+5228 @03ec9c> : 12 06                      dup.x1 sp(6)
	<.main+5230 @03ec9e> : 13 11                      dup.x2 sp(17)
	<.main+5232 @03eca0> : 1f 00 d7 03 00             load.ref <@03d700> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5237 @03eca5> : 02                         call
	<.main+5238 @03eca6> : 10 f4 ff ff                inc.sp(-12)
	<.main+5242 @03ecaa> : 67                         ceq.i64
	<.main+5243 @03ecab> : 06 08 00 00                jz <.main+5251 @03ecb3>
	<.main+5247 @03ecaf> : 04 2b 00 00                jmp <.main+5290 @03ecda>
	<.main+5251 @03ecb3> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5256 @03ecb8> : 1b 86 00 00 00             load.c32 134
	<.main+5261 @03ecbd> : 1b fe ff ff ff             load.c32 -2
	<.main+5266 @03ecc2> : 1b 80 00 00 00             load.c32 128
	<.main+5271 @03ecc7> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5276 @03eccc> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5281 @03ecd1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5286 @03ecd6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@03ecda> - <@03ed15>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5290 @03ecda> : 13 00                      dup.x2 sp(0)
	<.main+5292 @03ecdc> : 12 0b                      dup.x1 sp(11)
	<.main+5294 @03ecde> : 12 05                      dup.x1 sp(5)
	<.main+5296 @03ece0> : 0c 08 00 00                mad.u32 8
	<.main+5300 @03ece4> : 23                         load.i64
	<.main+5301 @03ece5> : 67                         ceq.i64
	<.main+5302 @03ece6> : 06 08 00 00                jz <.main+5310 @03ecee>
	<.main+5306 @03ecea> : 04 2b 00 00                jmp <.main+5349 @03ed15>
	<.main+5310 @03ecee> : 1f 00 d4 02 00             load.ref <@02d400> ;"test/lang/array.ci"
	<.main+5315 @03ecf3> : 1b 88 00 00 00             load.c32 136
	<.main+5320 @03ecf8> : 1b fe ff ff ff             load.c32 -2
	<.main+5325 @03ecfd> : 1b 80 00 00 00             load.c32 128
	<.main+5330 @03ed02> : 1f ea b5 00 00             load.ref <@00b5ea> ;"assertion failed!"
	<.main+5335 @03ed07> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+5340 @03ed0c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5345 @03ed11> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5349 @03ed15> : 10 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@03ed19> - <@03ed1d>): int32(i := int32(i + 1))
	<.main+5353 @03ed19> : 0b 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@03ed1d> - <@03ed29>): bool(i < arrFixedNoInit.length)
	<.main+5357 @03ed1d> : 12 00                      dup.x1 sp(0)
	<.main+5359 @03ed1f> : 1b 07 00 00 00             load.c32 7
	<.main+5364 @03ed24> : 58                         clt.i32
	<.main+5365 @03ed25> : 05 e6 fc ff                jnz <.main+4571 @03ea0b>
	<.main+5369 @03ed29> : 10 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@03ed2d> - <@03ed69>): recordMemberTest: RecordMemberTest := {...}
	<.main+5373 @03ed2d> : 10 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@03ed31> - <@03ed38>): void(recordMemberTest.member := 6);
	<.main+5377 @03ed31> : 1b 06 00 00 00             load.c32 6
	<.main+5382 @03ed36> : 15 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@03ed38> - <@03ed3f>): void(recordMemberTest.constant := 7);
	<.main+5384 @03ed38> : 1b 07 00 00 00             load.c32 7
	<.main+5389 @03ed3d> : 15 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@03ed3f> - <@03ed46>): void(recordMemberTest.memberInit := 8);
	<.main+5391 @03ed3f> : 1b 08 00 00 00             load.c32 8
	<.main+5396 @03ed44> : 15 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@03ed46> - <@03ed4d>): void(recordMemberTest.constantInit := 9);
	<.main+5398 @03ed46> : 1b 09 00 00 00             load.c32 9
	<.main+5403 @03ed4b> : 15 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@03ed4d> - <@03ed54>): void(recordMemberTest.memberRec.member := 61);
	<.main+5405 @03ed4d> : 1b 3d 00 00 00             load.c32 61
	<.main+5410 @03ed52> : 15 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@03ed54> - <@03ed5b>): void(recordMemberTest.memberRec.constant := 62);
	<.main+5412 @03ed54> : 1b 3e 00 00 00             load.c32 62
	<.main+5417 @03ed59> : 15 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@03ed5b> - <@03ed62>): void(recordMemberTest.constantRec.member := 71);
	<.main+5419 @03ed5b> : 1b 47 00 00 00             load.c32 71
	<.main+5424 @03ed60> : 15 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@03ed62> - <@03ed69>): void(recordMemberTest.constantRec.constant := 72);
	<.main+5426 @03ed62> : 1b 48 00 00 00             load.c32 72
	<.main+5431 @03ed67> : 15 08                      set.x1 sp(8)
	test/lang/method.ci:53: (32 bytes: <@03ed69> - <@03ed89>): recordMethodTest: RecordMethodTest := {...}
	<.main+5433 @03ed69> : 10 10 00 00                inc.sp(+16)
	test/lang/method.ci:54: (7 bytes: <@03ed6d> - <@03ed74>): void(recordMethodTest.delegateMethod := globalFunction);
	<.main+5437 @03ed6d> : 1f b0 d7 03 00             load.ref <@03d7b0> ;globalFunction(x: int32, y: int32): int32
	<.main+5442 @03ed72> : 15 02                      set.x1 sp(2)
	test/lang/method.ci:55: (7 bytes: <@03ed74> - <@03ed7b>): void(recordMethodTest.abstractMethod := RecordMethodTest.staticMethod);
	<.main+5444 @03ed74> : 1f 40 d7 03 00             load.ref <@03d740> ;RecordMethodTest.staticMethod(x: int32, y: int32): int32
	<.main+5449 @03ed79> : 15 01                      set.x1 sp(1)
	:: (7 bytes: <@03ed7b> - <@03ed82>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5451 @03ed7b> : 1f 50 d7 03 00             load.ref <@03d750> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5456 @03ed80> : 15 03                      set.x1 sp(3)
	:: (7 bytes: <@03ed82> - <@03ed89>): void(recordMethodTest.print := print)
	<.main+5458 @03ed82> : 1f 60 d7 03 00             load.ref <@03d760> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5463 @03ed87> : 15 04                      set.x1 sp(4)
	test/lang/method.ci:63: (31 bytes: <@03ed89> - <@03eda8>): recordMethodTestCustomPrint: RecordMethodTest := {...}
	<.main+5465 @03ed89> : 10 10 00 00                inc.sp(+16)
	test/lang/method.ci:64: (7 bytes: <@03ed8d> - <@03ed94>): void(recordMethodTestCustomPrint.abstractMethod := globalFunction);
	<.main+5469 @03ed8d> : 1f b0 d7 03 00             load.ref <@03d7b0> ;globalFunction(x: int32, y: int32): int32
	<.main+5474 @03ed92> : 15 01                      set.x1 sp(1)
	test/lang/method.ci:65: (7 bytes: <@03ed94> - <@03ed9b>): void(recordMethodTestCustomPrint.print := customPrint);
	<.main+5476 @03ed94> : 1f b8 d7 03 00             load.ref <@03d7b8> ;customPrint(this: RecordMethodTest): void
	<.main+5481 @03ed99> : 15 04                      set.x1 sp(4)
	:: (6 bytes: <@03ed9b> - <@03eda1>): void(recordMethodTestCustomPrint.delegateMethod := forwardMethod)
	<.main+5483 @03ed9b> : 2a 48 d7 03                load.m32 <@03d748> ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+5487 @03ed9f> : 15 02                      set.x1 sp(2)
	:: (7 bytes: <@03eda1> - <@03eda8>): void(recordMethodTestCustomPrint.virtualMethod := virtualMethod)
	<.main+5489 @03eda1> : 1f 50 d7 03 00             load.ref <@03d750> ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+5494 @03eda6> : 15 03                      set.x1 sp(3)
	test/lang/method.ci:69: (9 bytes: <@03eda8> - <@03edb1>): recordMethodTest.print(recordMethodTest);
	<.main+5496 @03eda8> : 14 04                      dup.x4 sp(4)
	<.main+5498 @03edaa> : 12 0b                      dup.x1 sp(11)
	<.main+5500 @03edac> : 02                         call
	<.main+5501 @03edad> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:70: (9 bytes: <@03edb1> - <@03edba>): recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
	<.main+5505 @03edb1> : 14 00                      dup.x4 sp(0)
	<.main+5507 @03edb3> : 12 07                      dup.x1 sp(7)
	<.main+5509 @03edb5> : 02                         call
	<.main+5510 @03edb6> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:73: (12 bytes: <@03edba> - <@03edc6>): recordMethodTest.printStatic(recordMethodTest);
	<.main+5514 @03edba> : 14 04                      dup.x4 sp(4)
	<.main+5516 @03edbc> : 1f 88 d7 03 00             load.ref <@03d788> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5521 @03edc1> : 02                         call
	<.main+5522 @03edc2> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:84: (12 bytes: <@03edc6> - <@03edd2>): print(recordMethodTest);
	<.main+5526 @03edc6> : 14 04                      dup.x4 sp(4)
	<.main+5528 @03edc8> : 1f e0 d7 03 00             load.ref <@03d7e0> ;print(this: RecordMethodTest): void
	<.main+5533 @03edcd> : 02                         call
	<.main+5534 @03edce> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:85: (12 bytes: <@03edd2> - <@03edde>): printStatic(recordMethodTest);
	<.main+5538 @03edd2> : 14 04                      dup.x4 sp(4)
	<.main+5540 @03edd4> : 1f 08 d8 03 00             load.ref <@03d808> ;printStatic(this: RecordMethodTest): void
	<.main+5545 @03edd9> : 02                         call
	<.main+5546 @03edda> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:86: (12 bytes: <@03edde> - <@03edea>): print(recordMethodTestCustomPrint);
	<.main+5550 @03edde> : 14 00                      dup.x4 sp(0)
	<.main+5552 @03ede0> : 1f e0 d7 03 00             load.ref <@03d7e0> ;print(this: RecordMethodTest): void
	<.main+5557 @03ede5> : 02                         call
	<.main+5558 @03ede6> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:89: (12 bytes: <@03edea> - <@03edf6>): RecordMethodTest.print(recordMethodTest);
	<.main+5562 @03edea> : 14 04                      dup.x4 sp(4)
	<.main+5564 @03edec> : 1f 60 d7 03 00             load.ref <@03d760> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5569 @03edf1> : 02                         call
	<.main+5570 @03edf2> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:90: (12 bytes: <@03edf6> - <@03ee02>): RecordMethodTest.printStatic(recordMethodTest);
	<.main+5574 @03edf6> : 14 04                      dup.x4 sp(4)
	<.main+5576 @03edf8> : 1f 88 d7 03 00             load.ref <@03d788> ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+5581 @03edfd> : 02                         call
	<.main+5582 @03edfe> : 10 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:91: (12 bytes: <@03ee02> - <@03ee0e>): RecordMethodTest.print(recordMethodTestCustomPrint);
	<.main+5586 @03ee02> : 14 00                      dup.x4 sp(0)
	<.main+5588 @03ee04> : 1f 60 d7 03 00             load.ref <@03d760> ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+5593 @03ee09> : 02                         call
	<.main+5594 @03ee0a> : 10 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@03ee0e> - <@03ee24>): black: rgbU8 := {...}
	<.main+5598 @03ee0e> : 10 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@03ee12> - <@03ee18>): void(black.r := (0));
	<.main+5602 @03ee12> : 18                         load.z32
	<.main+5603 @03ee13> : 11 06 00 00                load.sp(+6)
	<.main+5607 @03ee17> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@03ee18> - <@03ee1e>): void(black.g := (0));
	<.main+5608 @03ee18> : 18                         load.z32
	<.main+5609 @03ee19> : 11 05 00 00                load.sp(+5)
	<.main+5613 @03ee1d> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@03ee1e> - <@03ee24>): void(black.b := (0));
	<.main+5614 @03ee1e> : 18                         load.z32
	<.main+5615 @03ee1f> : 11 04 00 00                load.sp(+4)
	<.main+5619 @03ee23> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@03ee24> - <@03ee3e>): green: rgbU8 := {...}
	<.main+5620 @03ee24> : 10 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@03ee28> - <@03ee2e>): void(green.r := (0));
	<.main+5624 @03ee28> : 18                         load.z32
	<.main+5625 @03ee29> : 11 06 00 00                load.sp(+6)
	<.main+5629 @03ee2d> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@03ee2e> - <@03ee38>): void(green.g := (255));
	<.main+5630 @03ee2e> : 1b ff 00 00 00             load.c32 255
	<.main+5635 @03ee33> : 11 05 00 00                load.sp(+5)
	<.main+5639 @03ee37> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@03ee38> - <@03ee3e>): void(green.b := (0));
	<.main+5640 @03ee38> : 18                         load.z32
	<.main+5641 @03ee39> : 11 04 00 00                load.sp(+4)
	<.main+5645 @03ee3d> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@03ee3e> - <@03ee60>): white: rgbU8 := {...}
	<.main+5646 @03ee3e> : 10 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@03ee42> - <@03ee4c>): void(white.r := (255));
	<.main+5650 @03ee42> : 1b ff 00 00 00             load.c32 255
	<.main+5655 @03ee47> : 11 06 00 00                load.sp(+6)
	<.main+5659 @03ee4b> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@03ee4c> - <@03ee56>): void(white.g := (255));
	<.main+5660 @03ee4c> : 1b ff 00 00 00             load.c32 255
	<.main+5665 @03ee51> : 11 05 00 00                load.sp(+5)
	<.main+5669 @03ee55> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@03ee56> - <@03ee60>): void(white.b := (255));
	<.main+5670 @03ee56> : 1b ff 00 00 00             load.c32 255
	<.main+5675 @03ee5b> : 11 04 00 00                load.sp(+4)
	<.main+5679 @03ee5f> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@03ee60> - <@03ee6b>): cyan: color := {...}
	<.main+5680 @03ee60> : 10 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@03ee64> - <@03ee6b>): void(cyan.col := (65535));
	<.main+5684 @03ee64> : 1b ff ff 00 00             load.c32 65535
	<.main+5689 @03ee69> : 15 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@03ee6b> - <@03ee85>): blue: color := {...}
	<.main+5691 @03ee6b> : 10 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@03ee6f> - <@03ee75>): void(blue.rgb.r := (0));
	<.main+5695 @03ee6f> : 18                         load.z32
	<.main+5696 @03ee70> : 11 06 00 00                load.sp(+6)
	<.main+5700 @03ee74> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@03ee75> - <@03ee7b>): void(blue.rgb.g := (0));
	<.main+5701 @03ee75> : 18                         load.z32
	<.main+5702 @03ee76> : 11 05 00 00                load.sp(+5)
	<.main+5706 @03ee7a> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@03ee7b> - <@03ee85>): void(blue.rgb.b := (255));
	<.main+5707 @03ee7b> : 1b ff 00 00 00             load.c32 255
	<.main+5712 @03ee80> : 11 04 00 00                load.sp(+4)
	<.main+5716 @03ee84> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@03ee85> - <@03ee8a>): shift: int32 := 2
	<.main+5717 @03ee85> : 1b 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@03ee8a> - <@03ee8f>): boolA: bool := true
	<.main+5722 @03ee8a> : 1b 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@03ee8f> - <@03ee94>): boolB: bool := bool(!false)
	<.main+5727 @03ee8f> : 1b 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@03ee94> - <@03ee9f>): boolAnd: bool := bool(boolA & boolB)
	<.main+5732 @03ee94> : 11 04 00 00                load.sp(+4)
	<.main+5736 @03ee98> : 20                         load.i8
	<.main+5737 @03ee99> : 11 04 00 00                load.sp(+4)
	<.main+5741 @03ee9d> : 20                         load.i8
	<.main+5742 @03ee9e> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@03ee9f> - <@03eeaa>): boolIor: bool := bool(boolA | boolB)
	<.main+5743 @03ee9f> : 11 08 00 00                load.sp(+8)
	<.main+5747 @03eea3> : 20                         load.i8
	<.main+5748 @03eea4> : 11 08 00 00                load.sp(+8)
	<.main+5752 @03eea8> : 20                         load.i8
	<.main+5753 @03eea9> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@03eeaa> - <@03eeb5>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5754 @03eeaa> : 11 0c 00 00                load.sp(+12)
	<.main+5758 @03eeae> : 20                         load.i8
	<.main+5759 @03eeaf> : 11 0c 00 00                load.sp(+12)
	<.main+5763 @03eeb3> : 20                         load.i8
	<.main+5764 @03eeb4> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@03eeb5> - <@03eebb>): boolNot: bool := bool(!boolB)
	<.main+5765 @03eeb5> : 11 0c 00 00                load.sp(+12)
	<.main+5769 @03eeb9> : 20                         load.i8
	<.main+5770 @03eeba> : 0a                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@03eebb> - <@03eec6>): boolCeq: bool := bool(boolA == boolB)
	<.main+5771 @03eebb> : 11 14 00 00                load.sp(+20)
	<.main+5775 @03eebf> : 20                         load.i8
	<.main+5776 @03eec0> : 11 14 00 00                load.sp(+20)
	<.main+5780 @03eec4> : 20                         load.i8
	<.main+5781 @03eec5> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@03eec6> - <@03eed2>): boolCne: bool := bool(boolA != boolB)
	<.main+5782 @03eec6> : 11 18 00 00                load.sp(+24)
	<.main+5786 @03eeca> : 20                         load.i8
	<.main+5787 @03eecb> : 11 18 00 00                load.sp(+24)
	<.main+5791 @03eecf> : 20                         load.i8
	<.main+5792 @03eed0> : 57                         ceq.i32
	<.main+5793 @03eed1> : 0a                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@03eed2> - <@03eedd>): boolClt: bool := bool(boolA < boolB)
	<.main+5794 @03eed2> : 11 1c 00 00                load.sp(+28)
	<.main+5798 @03eed6> : 20                         load.i8
	<.main+5799 @03eed7> : 11 1c 00 00                load.sp(+28)
	<.main+5803 @03eedb> : 20                         load.i8
	<.main+5804 @03eedc> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@03eedd> - <@03eee9>): boolCle: bool := bool(boolA <= boolB)
	<.main+5805 @03eedd> : 11 20 00 00                load.sp(+32)
	<.main+5809 @03eee1> : 20                         load.i8
	<.main+5810 @03eee2> : 11 20 00 00                load.sp(+32)
	<.main+5814 @03eee6> : 20                         load.i8
	<.main+5815 @03eee7> : 59                         cgt.i32
	<.main+5816 @03eee8> : 0a                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@03eee9> - <@03eef4>): boolCgt: bool := bool(boolA > boolB)
	<.main+5817 @03eee9> : 11 24 00 00                load.sp(+36)
	<.main+5821 @03eeed> : 20                         load.i8
	<.main+5822 @03eeee> : 11 24 00 00                load.sp(+36)
	<.main+5826 @03eef2> : 20                         load.i8
	<.main+5827 @03eef3> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@03eef4> - <@03ef00>): boolCge: bool := bool(boolA >= boolB)
	<.main+5828 @03eef4> : 11 28 00 00                load.sp(+40)
	<.main+5832 @03eef8> : 20                         load.i8
	<.main+5833 @03eef9> : 11 28 00 00                load.sp(+40)
	<.main+5837 @03eefd> : 20                         load.i8
	<.main+5838 @03eefe> : 58                         clt.i32
	<.main+5839 @03eeff> : 0a                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@03ef00> - <@03ef05>): chrA: char := 'a'
	<.main+5840 @03ef00> : 1b 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@03ef05> - <@03ef0a>): chrB: char := 'b'
	<.main+5845 @03ef05> : 1b 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@03ef0a> - <@03ef0f>): chrPls: char := char(+chrB)
	<.main+5850 @03ef0a> : 11 00 00 00                load.sp(+0)
	<.main+5854 @03ef0e> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@03ef0f> - <@03ef15>): chrNeg: char := char(-chrB)
	<.main+5855 @03ef0f> : 11 04 00 00                load.sp(+4)
	<.main+5859 @03ef13> : 20                         load.i8
	<.main+5860 @03ef14> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@03ef15> - <@03ef1b>): chrCmt: char := char(~chrB)
	<.main+5861 @03ef15> : 11 08 00 00                load.sp(+8)
	<.main+5865 @03ef19> : 20                         load.i8
	<.main+5866 @03ef1a> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@03ef1b> - <@03ef26>): chrAdd: char := char(chrA + chrB)
	<.main+5867 @03ef1b> : 11 10 00 00                load.sp(+16)
	<.main+5871 @03ef1f> : 20                         load.i8
	<.main+5872 @03ef20> : 11 10 00 00                load.sp(+16)
	<.main+5876 @03ef24> : 20                         load.i8
	<.main+5877 @03ef25> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@03ef26> - <@03ef31>): chrSub: char := char(chrA - chrB)
	<.main+5878 @03ef26> : 11 14 00 00                load.sp(+20)
	<.main+5882 @03ef2a> : 20                         load.i8
	<.main+5883 @03ef2b> : 11 14 00 00                load.sp(+20)
	<.main+5887 @03ef2f> : 20                         load.i8
	<.main+5888 @03ef30> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@03ef31> - <@03ef3c>): chrMul: char := char(chrA * chrB)
	<.main+5889 @03ef31> : 11 18 00 00                load.sp(+24)
	<.main+5893 @03ef35> : 20                         load.i8
	<.main+5894 @03ef36> : 11 18 00 00                load.sp(+24)
	<.main+5898 @03ef3a> : 20                         load.i8
	<.main+5899 @03ef3b> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@03ef3c> - <@03ef47>): chrDiv: char := char(chrA / chrB)
	<.main+5900 @03ef3c> : 11 1c 00 00                load.sp(+28)
	<.main+5904 @03ef40> : 20                         load.i8
	<.main+5905 @03ef41> : 11 1c 00 00                load.sp(+28)
	<.main+5909 @03ef45> : 20                         load.i8
	<.main+5910 @03ef46> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@03ef47> - <@03ef52>): chrMod: char := char(chrA % chrB)
	<.main+5911 @03ef47> : 11 20 00 00                load.sp(+32)
	<.main+5915 @03ef4b> : 20                         load.i8
	<.main+5916 @03ef4c> : 11 20 00 00                load.sp(+32)
	<.main+5920 @03ef50> : 20                         load.i8
	<.main+5921 @03ef51> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@03ef52> - <@03ef5d>): chrAnd: char := char(chrA & chrB)
	<.main+5922 @03ef52> : 11 24 00 00                load.sp(+36)
	<.main+5926 @03ef56> : 20                         load.i8
	<.main+5927 @03ef57> : 11 24 00 00                load.sp(+36)
	<.main+5931 @03ef5b> : 20                         load.i8
	<.main+5932 @03ef5c> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@03ef5d> - <@03ef68>): chrIor: char := char(chrA | chrB)
	<.main+5933 @03ef5d> : 11 28 00 00                load.sp(+40)
	<.main+5937 @03ef61> : 20                         load.i8
	<.main+5938 @03ef62> : 11 28 00 00                load.sp(+40)
	<.main+5942 @03ef66> : 20                         load.i8
	<.main+5943 @03ef67> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@03ef68> - <@03ef73>): chrXor: char := char(chrA ^ chrB)
	<.main+5944 @03ef68> : 11 2c 00 00                load.sp(+44)
	<.main+5948 @03ef6c> : 20                         load.i8
	<.main+5949 @03ef6d> : 11 2c 00 00                load.sp(+44)
	<.main+5953 @03ef71> : 20                         load.i8
	<.main+5954 @03ef72> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@03ef73> - <@03ef7b>): chrShl: char := int32((chrA) << shift)
	<.main+5955 @03ef73> : 11 30 00 00                load.sp(+48)
	<.main+5959 @03ef77> : 20                         load.i8
	<.main+5960 @03ef78> : 12 1a                      dup.x1 sp(26)
	<.main+5962 @03ef7a> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@03ef7b> - <@03ef83>): chrShr: char := int32((chrA) >> shift)
	<.main+5963 @03ef7b> : 11 34 00 00                load.sp(+52)
	<.main+5967 @03ef7f> : 20                         load.i8
	<.main+5968 @03ef80> : 12 1b                      dup.x1 sp(27)
	<.main+5970 @03ef82> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@03ef83> - <@03ef8a>): chrNot: bool := bool(!(chrB))
	<.main+5971 @03ef83> : 11 34 00 00                load.sp(+52)
	<.main+5975 @03ef87> : 20                         load.i8
	<.main+5976 @03ef88> : 5a                         i32.2bool
	<.main+5977 @03ef89> : 0a                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@03ef8a> - <@03ef95>): chrCeq: bool := bool(chrA == chrB)
	<.main+5978 @03ef8a> : 11 3c 00 00                load.sp(+60)
	<.main+5982 @03ef8e> : 20                         load.i8
	<.main+5983 @03ef8f> : 11 3c 00 00                load.sp(+60)
	<.main+5987 @03ef93> : 20                         load.i8
	<.main+5988 @03ef94> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@03ef95> - <@03efa1>): chrCne: bool := bool(chrA != chrB)
	<.main+5989 @03ef95> : 11 40 00 00                load.sp(+64)
	<.main+5993 @03ef99> : 20                         load.i8
	<.main+5994 @03ef9a> : 11 40 00 00                load.sp(+64)
	<.main+5998 @03ef9e> : 20                         load.i8
	<.main+5999 @03ef9f> : 57                         ceq.i32
	<.main+6000 @03efa0> : 0a                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@03efa1> - <@03efac>): chrClt: bool := bool(chrA < chrB)
	<.main+6001 @03efa1> : 11 44 00 00                load.sp(+68)
	<.main+6005 @03efa5> : 20                         load.i8
	<.main+6006 @03efa6> : 11 44 00 00                load.sp(+68)
	<.main+6010 @03efaa> : 20                         load.i8
	<.main+6011 @03efab> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@03efac> - <@03efb8>): chrCle: bool := bool(chrA <= chrB)
	<.main+6012 @03efac> : 11 48 00 00                load.sp(+72)
	<.main+6016 @03efb0> : 20                         load.i8
	<.main+6017 @03efb1> : 11 48 00 00                load.sp(+72)
	<.main+6021 @03efb5> : 20                         load.i8
	<.main+6022 @03efb6> : 59                         cgt.i32
	<.main+6023 @03efb7> : 0a                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@03efb8> - <@03efc3>): chrCgt: bool := bool(chrA > chrB)
	<.main+6024 @03efb8> : 11 4c 00 00                load.sp(+76)
	<.main+6028 @03efbc> : 20                         load.i8
	<.main+6029 @03efbd> : 11 4c 00 00                load.sp(+76)
	<.main+6033 @03efc1> : 20                         load.i8
	<.main+6034 @03efc2> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@03efc3> - <@03efcf>): chrCge: bool := bool(chrA >= chrB)
	<.main+6035 @03efc3> : 11 50 00 00                load.sp(+80)
	<.main+6039 @03efc7> : 20                         load.i8
	<.main+6040 @03efc8> : 11 50 00 00                load.sp(+80)
	<.main+6044 @03efcc> : 20                         load.i8
	<.main+6045 @03efcd> : 58                         clt.i32
	<.main+6046 @03efce> : 0a                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@03efcf> - <@03efd4>): i8A: int8 := a
	<.main+6047 @03efcf> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@03efd4> - <@03efd9>): i8B: int8 := b
	<.main+6052 @03efd4> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@03efd9> - <@03efde>): i8Pls: int8 := int8(+i8B)
	<.main+6057 @03efd9> : 11 00 00 00                load.sp(+0)
	<.main+6061 @03efdd> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@03efde> - <@03efe4>): i8Neg: int8 := int8(-i8B)
	<.main+6062 @03efde> : 11 04 00 00                load.sp(+4)
	<.main+6066 @03efe2> : 20                         load.i8
	<.main+6067 @03efe3> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@03efe4> - <@03efea>): i8Cmt: int8 := int8(~i8B)
	<.main+6068 @03efe4> : 11 08 00 00                load.sp(+8)
	<.main+6072 @03efe8> : 20                         load.i8
	<.main+6073 @03efe9> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@03efea> - <@03eff5>): i8Add: int8 := int8(i8A + i8B)
	<.main+6074 @03efea> : 11 10 00 00                load.sp(+16)
	<.main+6078 @03efee> : 20                         load.i8
	<.main+6079 @03efef> : 11 10 00 00                load.sp(+16)
	<.main+6083 @03eff3> : 20                         load.i8
	<.main+6084 @03eff4> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@03eff5> - <@03f000>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6085 @03eff5> : 11 14 00 00                load.sp(+20)
	<.main+6089 @03eff9> : 20                         load.i8
	<.main+6090 @03effa> : 11 14 00 00                load.sp(+20)
	<.main+6094 @03effe> : 20                         load.i8
	<.main+6095 @03efff> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@03f000> - <@03f00b>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6096 @03f000> : 11 18 00 00                load.sp(+24)
	<.main+6100 @03f004> : 20                         load.i8
	<.main+6101 @03f005> : 11 18 00 00                load.sp(+24)
	<.main+6105 @03f009> : 20                         load.i8
	<.main+6106 @03f00a> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@03f00b> - <@03f016>): i8Div: int8 := int8(i8A / i8B)
	<.main+6107 @03f00b> : 11 1c 00 00                load.sp(+28)
	<.main+6111 @03f00f> : 20                         load.i8
	<.main+6112 @03f010> : 11 1c 00 00                load.sp(+28)
	<.main+6116 @03f014> : 20                         load.i8
	<.main+6117 @03f015> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@03f016> - <@03f021>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6118 @03f016> : 11 20 00 00                load.sp(+32)
	<.main+6122 @03f01a> : 20                         load.i8
	<.main+6123 @03f01b> : 11 20 00 00                load.sp(+32)
	<.main+6127 @03f01f> : 20                         load.i8
	<.main+6128 @03f020> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@03f021> - <@03f02c>): i8And: int8 := int8(i8A & i8B)
	<.main+6129 @03f021> : 11 24 00 00                load.sp(+36)
	<.main+6133 @03f025> : 20                         load.i8
	<.main+6134 @03f026> : 11 24 00 00                load.sp(+36)
	<.main+6138 @03f02a> : 20                         load.i8
	<.main+6139 @03f02b> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@03f02c> - <@03f037>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6140 @03f02c> : 11 28 00 00                load.sp(+40)
	<.main+6144 @03f030> : 20                         load.i8
	<.main+6145 @03f031> : 11 28 00 00                load.sp(+40)
	<.main+6149 @03f035> : 20                         load.i8
	<.main+6150 @03f036> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@03f037> - <@03f042>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6151 @03f037> : 11 2c 00 00                load.sp(+44)
	<.main+6155 @03f03b> : 20                         load.i8
	<.main+6156 @03f03c> : 11 2c 00 00                load.sp(+44)
	<.main+6160 @03f040> : 20                         load.i8
	<.main+6161 @03f041> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@03f042> - <@03f04a>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6162 @03f042> : 11 30 00 00                load.sp(+48)
	<.main+6166 @03f046> : 20                         load.i8
	<.main+6167 @03f047> : 12 30                      dup.x1 sp(48)
	<.main+6169 @03f049> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@03f04a> - <@03f052>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6170 @03f04a> : 11 34 00 00                load.sp(+52)
	<.main+6174 @03f04e> : 20                         load.i8
	<.main+6175 @03f04f> : 12 31                      dup.x1 sp(49)
	<.main+6177 @03f051> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@03f052> - <@03f059>): i8Not: bool := bool(!(i8B))
	<.main+6178 @03f052> : 11 34 00 00                load.sp(+52)
	<.main+6182 @03f056> : 20                         load.i8
	<.main+6183 @03f057> : 5a                         i32.2bool
	<.main+6184 @03f058> : 0a                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@03f059> - <@03f064>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6185 @03f059> : 11 3c 00 00                load.sp(+60)
	<.main+6189 @03f05d> : 20                         load.i8
	<.main+6190 @03f05e> : 11 3c 00 00                load.sp(+60)
	<.main+6194 @03f062> : 20                         load.i8
	<.main+6195 @03f063> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@03f064> - <@03f070>): i8Cne: bool := bool(i8A != i8B)
	<.main+6196 @03f064> : 11 40 00 00                load.sp(+64)
	<.main+6200 @03f068> : 20                         load.i8
	<.main+6201 @03f069> : 11 40 00 00                load.sp(+64)
	<.main+6205 @03f06d> : 20                         load.i8
	<.main+6206 @03f06e> : 57                         ceq.i32
	<.main+6207 @03f06f> : 0a                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@03f070> - <@03f07b>): i8Clt: bool := bool(i8A < i8B)
	<.main+6208 @03f070> : 11 44 00 00                load.sp(+68)
	<.main+6212 @03f074> : 20                         load.i8
	<.main+6213 @03f075> : 11 44 00 00                load.sp(+68)
	<.main+6217 @03f079> : 20                         load.i8
	<.main+6218 @03f07a> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@03f07b> - <@03f087>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6219 @03f07b> : 11 48 00 00                load.sp(+72)
	<.main+6223 @03f07f> : 20                         load.i8
	<.main+6224 @03f080> : 11 48 00 00                load.sp(+72)
	<.main+6228 @03f084> : 20                         load.i8
	<.main+6229 @03f085> : 59                         cgt.i32
	<.main+6230 @03f086> : 0a                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@03f087> - <@03f092>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6231 @03f087> : 11 4c 00 00                load.sp(+76)
	<.main+6235 @03f08b> : 20                         load.i8
	<.main+6236 @03f08c> : 11 4c 00 00                load.sp(+76)
	<.main+6240 @03f090> : 20                         load.i8
	<.main+6241 @03f091> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@03f092> - <@03f09e>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6242 @03f092> : 11 50 00 00                load.sp(+80)
	<.main+6246 @03f096> : 20                         load.i8
	<.main+6247 @03f097> : 11 50 00 00                load.sp(+80)
	<.main+6251 @03f09b> : 20                         load.i8
	<.main+6252 @03f09c> : 58                         clt.i32
	<.main+6253 @03f09d> : 0a                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@03f09e> - <@03f0a3>): u8A: uint8 := a
	<.main+6254 @03f09e> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@03f0a3> - <@03f0a8>): u8B: uint8 := b
	<.main+6259 @03f0a3> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@03f0a8> - <@03f0ad>): u8Pls: uint8 := uint8(+u8B)
	<.main+6264 @03f0a8> : 11 00 00 00                load.sp(+0)
	<.main+6268 @03f0ac> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@03f0ad> - <@03f0b3>): u8Neg: uint8 := uint8(-u8B)
	<.main+6269 @03f0ad> : 11 04 00 00                load.sp(+4)
	<.main+6273 @03f0b1> : 20                         load.i8
	<.main+6274 @03f0b2> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@03f0b3> - <@03f0b9>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6275 @03f0b3> : 11 08 00 00                load.sp(+8)
	<.main+6279 @03f0b7> : 20                         load.i8
	<.main+6280 @03f0b8> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@03f0b9> - <@03f0c4>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6281 @03f0b9> : 11 10 00 00                load.sp(+16)
	<.main+6285 @03f0bd> : 20                         load.i8
	<.main+6286 @03f0be> : 11 10 00 00                load.sp(+16)
	<.main+6290 @03f0c2> : 20                         load.i8
	<.main+6291 @03f0c3> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@03f0c4> - <@03f0cf>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6292 @03f0c4> : 11 14 00 00                load.sp(+20)
	<.main+6296 @03f0c8> : 20                         load.i8
	<.main+6297 @03f0c9> : 11 14 00 00                load.sp(+20)
	<.main+6301 @03f0cd> : 20                         load.i8
	<.main+6302 @03f0ce> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@03f0cf> - <@03f0da>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6303 @03f0cf> : 11 18 00 00                load.sp(+24)
	<.main+6307 @03f0d3> : 20                         load.i8
	<.main+6308 @03f0d4> : 11 18 00 00                load.sp(+24)
	<.main+6312 @03f0d8> : 20                         load.i8
	<.main+6313 @03f0d9> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@03f0da> - <@03f0e5>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6314 @03f0da> : 11 1c 00 00                load.sp(+28)
	<.main+6318 @03f0de> : 20                         load.i8
	<.main+6319 @03f0df> : 11 1c 00 00                load.sp(+28)
	<.main+6323 @03f0e3> : 20                         load.i8
	<.main+6324 @03f0e4> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@03f0e5> - <@03f0f0>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6325 @03f0e5> : 11 20 00 00                load.sp(+32)
	<.main+6329 @03f0e9> : 20                         load.i8
	<.main+6330 @03f0ea> : 11 20 00 00                load.sp(+32)
	<.main+6334 @03f0ee> : 20                         load.i8
	<.main+6335 @03f0ef> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@03f0f0> - <@03f0fb>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6336 @03f0f0> : 11 24 00 00                load.sp(+36)
	<.main+6340 @03f0f4> : 20                         load.i8
	<.main+6341 @03f0f5> : 11 24 00 00                load.sp(+36)
	<.main+6345 @03f0f9> : 20                         load.i8
	<.main+6346 @03f0fa> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@03f0fb> - <@03f106>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6347 @03f0fb> : 11 28 00 00                load.sp(+40)
	<.main+6351 @03f0ff> : 20                         load.i8
	<.main+6352 @03f100> : 11 28 00 00                load.sp(+40)
	<.main+6356 @03f104> : 20                         load.i8
	<.main+6357 @03f105> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@03f106> - <@03f111>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6358 @03f106> : 11 2c 00 00                load.sp(+44)
	<.main+6362 @03f10a> : 20                         load.i8
	<.main+6363 @03f10b> : 11 2c 00 00                load.sp(+44)
	<.main+6367 @03f10f> : 20                         load.i8
	<.main+6368 @03f110> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@03f111> - <@03f119>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6369 @03f111> : 11 30 00 00                load.sp(+48)
	<.main+6373 @03f115> : 20                         load.i8
	<.main+6374 @03f116> : 12 46                      dup.x1 sp(70)
	<.main+6376 @03f118> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@03f119> - <@03f121>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6377 @03f119> : 11 34 00 00                load.sp(+52)
	<.main+6381 @03f11d> : 20                         load.i8
	<.main+6382 @03f11e> : 12 47                      dup.x1 sp(71)
	<.main+6384 @03f120> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@03f121> - <@03f128>): u8Not: bool := bool(!(u8B))
	<.main+6385 @03f121> : 11 34 00 00                load.sp(+52)
	<.main+6389 @03f125> : 20                         load.i8
	<.main+6390 @03f126> : 5a                         i32.2bool
	<.main+6391 @03f127> : 0a                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@03f128> - <@03f133>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6392 @03f128> : 11 3c 00 00                load.sp(+60)
	<.main+6396 @03f12c> : 20                         load.i8
	<.main+6397 @03f12d> : 11 3c 00 00                load.sp(+60)
	<.main+6401 @03f131> : 20                         load.i8
	<.main+6402 @03f132> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@03f133> - <@03f13f>): u8Cne: bool := bool(u8A != u8B)
	<.main+6403 @03f133> : 11 40 00 00                load.sp(+64)
	<.main+6407 @03f137> : 20                         load.i8
	<.main+6408 @03f138> : 11 40 00 00                load.sp(+64)
	<.main+6412 @03f13c> : 20                         load.i8
	<.main+6413 @03f13d> : 57                         ceq.i32
	<.main+6414 @03f13e> : 0a                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@03f13f> - <@03f14a>): u8Clt: bool := bool(u8A < u8B)
	<.main+6415 @03f13f> : 11 44 00 00                load.sp(+68)
	<.main+6419 @03f143> : 20                         load.i8
	<.main+6420 @03f144> : 11 44 00 00                load.sp(+68)
	<.main+6424 @03f148> : 20                         load.i8
	<.main+6425 @03f149> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@03f14a> - <@03f156>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6426 @03f14a> : 11 48 00 00                load.sp(+72)
	<.main+6430 @03f14e> : 20                         load.i8
	<.main+6431 @03f14f> : 11 48 00 00                load.sp(+72)
	<.main+6435 @03f153> : 20                         load.i8
	<.main+6436 @03f154> : 39                         cgt.u32
	<.main+6437 @03f155> : 0a                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@03f156> - <@03f161>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6438 @03f156> : 11 4c 00 00                load.sp(+76)
	<.main+6442 @03f15a> : 20                         load.i8
	<.main+6443 @03f15b> : 11 4c 00 00                load.sp(+76)
	<.main+6447 @03f15f> : 20                         load.i8
	<.main+6448 @03f160> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@03f161> - <@03f16d>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6449 @03f161> : 11 50 00 00                load.sp(+80)
	<.main+6453 @03f165> : 20                         load.i8
	<.main+6454 @03f166> : 11 50 00 00                load.sp(+80)
	<.main+6458 @03f16a> : 20                         load.i8
	<.main+6459 @03f16b> : 38                         clt.u32
	<.main+6460 @03f16c> : 0a                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@03f16d> - <@03f172>): i16A: int16 := a
	<.main+6461 @03f16d> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@03f172> - <@03f177>): i16B: int16 := b
	<.main+6466 @03f172> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@03f177> - <@03f17c>): i16Pls: int16 := int16(+i16B)
	<.main+6471 @03f177> : 11 00 00 00                load.sp(+0)
	<.main+6475 @03f17b> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@03f17c> - <@03f182>): i16Neg: int16 := int16(-i16B)
	<.main+6476 @03f17c> : 11 04 00 00                load.sp(+4)
	<.main+6480 @03f180> : 21                         load.i16
	<.main+6481 @03f181> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@03f182> - <@03f188>): i16Cmt: int16 := int16(~i16B)
	<.main+6482 @03f182> : 11 08 00 00                load.sp(+8)
	<.main+6486 @03f186> : 21                         load.i16
	<.main+6487 @03f187> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@03f188> - <@03f193>): i16Add: int16 := int16(i16A + i16B)
	<.main+6488 @03f188> : 11 10 00 00                load.sp(+16)
	<.main+6492 @03f18c> : 21                         load.i16
	<.main+6493 @03f18d> : 11 10 00 00                load.sp(+16)
	<.main+6497 @03f191> : 21                         load.i16
	<.main+6498 @03f192> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@03f193> - <@03f19e>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6499 @03f193> : 11 14 00 00                load.sp(+20)
	<.main+6503 @03f197> : 21                         load.i16
	<.main+6504 @03f198> : 11 14 00 00                load.sp(+20)
	<.main+6508 @03f19c> : 21                         load.i16
	<.main+6509 @03f19d> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@03f19e> - <@03f1a9>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6510 @03f19e> : 11 18 00 00                load.sp(+24)
	<.main+6514 @03f1a2> : 21                         load.i16
	<.main+6515 @03f1a3> : 11 18 00 00                load.sp(+24)
	<.main+6519 @03f1a7> : 21                         load.i16
	<.main+6520 @03f1a8> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@03f1a9> - <@03f1b4>): i16Div: int16 := int16(i16A / i16B)
	<.main+6521 @03f1a9> : 11 1c 00 00                load.sp(+28)
	<.main+6525 @03f1ad> : 21                         load.i16
	<.main+6526 @03f1ae> : 11 1c 00 00                load.sp(+28)
	<.main+6530 @03f1b2> : 21                         load.i16
	<.main+6531 @03f1b3> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@03f1b4> - <@03f1bf>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6532 @03f1b4> : 11 20 00 00                load.sp(+32)
	<.main+6536 @03f1b8> : 21                         load.i16
	<.main+6537 @03f1b9> : 11 20 00 00                load.sp(+32)
	<.main+6541 @03f1bd> : 21                         load.i16
	<.main+6542 @03f1be> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@03f1bf> - <@03f1ca>): i16And: int16 := int16(i16A & i16B)
	<.main+6543 @03f1bf> : 11 24 00 00                load.sp(+36)
	<.main+6547 @03f1c3> : 21                         load.i16
	<.main+6548 @03f1c4> : 11 24 00 00                load.sp(+36)
	<.main+6552 @03f1c8> : 21                         load.i16
	<.main+6553 @03f1c9> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@03f1ca> - <@03f1d5>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6554 @03f1ca> : 11 28 00 00                load.sp(+40)
	<.main+6558 @03f1ce> : 21                         load.i16
	<.main+6559 @03f1cf> : 11 28 00 00                load.sp(+40)
	<.main+6563 @03f1d3> : 21                         load.i16
	<.main+6564 @03f1d4> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@03f1d5> - <@03f1e0>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6565 @03f1d5> : 11 2c 00 00                load.sp(+44)
	<.main+6569 @03f1d9> : 21                         load.i16
	<.main+6570 @03f1da> : 11 2c 00 00                load.sp(+44)
	<.main+6574 @03f1de> : 21                         load.i16
	<.main+6575 @03f1df> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@03f1e0> - <@03f1e8>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6576 @03f1e0> : 11 30 00 00                load.sp(+48)
	<.main+6580 @03f1e4> : 21                         load.i16
	<.main+6581 @03f1e5> : 12 5c                      dup.x1 sp(92)
	<.main+6583 @03f1e7> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@03f1e8> - <@03f1f0>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6584 @03f1e8> : 11 34 00 00                load.sp(+52)
	<.main+6588 @03f1ec> : 21                         load.i16
	<.main+6589 @03f1ed> : 12 5d                      dup.x1 sp(93)
	<.main+6591 @03f1ef> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@03f1f0> - <@03f1f7>): i16Not: bool := bool(!(i16B))
	<.main+6592 @03f1f0> : 11 34 00 00                load.sp(+52)
	<.main+6596 @03f1f4> : 21                         load.i16
	<.main+6597 @03f1f5> : 5a                         i32.2bool
	<.main+6598 @03f1f6> : 0a                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@03f1f7> - <@03f202>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6599 @03f1f7> : 11 3c 00 00                load.sp(+60)
	<.main+6603 @03f1fb> : 21                         load.i16
	<.main+6604 @03f1fc> : 11 3c 00 00                load.sp(+60)
	<.main+6608 @03f200> : 21                         load.i16
	<.main+6609 @03f201> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@03f202> - <@03f20e>): i16Cne: bool := bool(i16A != i16B)
	<.main+6610 @03f202> : 11 40 00 00                load.sp(+64)
	<.main+6614 @03f206> : 21                         load.i16
	<.main+6615 @03f207> : 11 40 00 00                load.sp(+64)
	<.main+6619 @03f20b> : 21                         load.i16
	<.main+6620 @03f20c> : 57                         ceq.i32
	<.main+6621 @03f20d> : 0a                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@03f20e> - <@03f219>): i16Clt: bool := bool(i16A < i16B)
	<.main+6622 @03f20e> : 11 44 00 00                load.sp(+68)
	<.main+6626 @03f212> : 21                         load.i16
	<.main+6627 @03f213> : 11 44 00 00                load.sp(+68)
	<.main+6631 @03f217> : 21                         load.i16
	<.main+6632 @03f218> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@03f219> - <@03f225>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6633 @03f219> : 11 48 00 00                load.sp(+72)
	<.main+6637 @03f21d> : 21                         load.i16
	<.main+6638 @03f21e> : 11 48 00 00                load.sp(+72)
	<.main+6642 @03f222> : 21                         load.i16
	<.main+6643 @03f223> : 59                         cgt.i32
	<.main+6644 @03f224> : 0a                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@03f225> - <@03f230>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6645 @03f225> : 11 4c 00 00                load.sp(+76)
	<.main+6649 @03f229> : 21                         load.i16
	<.main+6650 @03f22a> : 11 4c 00 00                load.sp(+76)
	<.main+6654 @03f22e> : 21                         load.i16
	<.main+6655 @03f22f> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@03f230> - <@03f23c>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6656 @03f230> : 11 50 00 00                load.sp(+80)
	<.main+6660 @03f234> : 21                         load.i16
	<.main+6661 @03f235> : 11 50 00 00                load.sp(+80)
	<.main+6665 @03f239> : 21                         load.i16
	<.main+6666 @03f23a> : 58                         clt.i32
	<.main+6667 @03f23b> : 0a                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@03f23c> - <@03f241>): u16A: uint16 := a
	<.main+6668 @03f23c> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@03f241> - <@03f246>): u16B: uint16 := b
	<.main+6673 @03f241> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@03f246> - <@03f24b>): u16Pls: uint16 := uint16(+u16B)
	<.main+6678 @03f246> : 11 00 00 00                load.sp(+0)
	<.main+6682 @03f24a> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@03f24b> - <@03f251>): u16Neg: uint16 := uint16(-u16B)
	<.main+6683 @03f24b> : 11 04 00 00                load.sp(+4)
	<.main+6687 @03f24f> : 21                         load.i16
	<.main+6688 @03f250> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@03f251> - <@03f257>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6689 @03f251> : 11 08 00 00                load.sp(+8)
	<.main+6693 @03f255> : 21                         load.i16
	<.main+6694 @03f256> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@03f257> - <@03f262>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6695 @03f257> : 11 10 00 00                load.sp(+16)
	<.main+6699 @03f25b> : 21                         load.i16
	<.main+6700 @03f25c> : 11 10 00 00                load.sp(+16)
	<.main+6704 @03f260> : 21                         load.i16
	<.main+6705 @03f261> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@03f262> - <@03f26d>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6706 @03f262> : 11 14 00 00                load.sp(+20)
	<.main+6710 @03f266> : 21                         load.i16
	<.main+6711 @03f267> : 11 14 00 00                load.sp(+20)
	<.main+6715 @03f26b> : 21                         load.i16
	<.main+6716 @03f26c> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@03f26d> - <@03f278>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6717 @03f26d> : 11 18 00 00                load.sp(+24)
	<.main+6721 @03f271> : 21                         load.i16
	<.main+6722 @03f272> : 11 18 00 00                load.sp(+24)
	<.main+6726 @03f276> : 21                         load.i16
	<.main+6727 @03f277> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@03f278> - <@03f283>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6728 @03f278> : 11 1c 00 00                load.sp(+28)
	<.main+6732 @03f27c> : 21                         load.i16
	<.main+6733 @03f27d> : 11 1c 00 00                load.sp(+28)
	<.main+6737 @03f281> : 21                         load.i16
	<.main+6738 @03f282> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@03f283> - <@03f28e>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6739 @03f283> : 11 20 00 00                load.sp(+32)
	<.main+6743 @03f287> : 21                         load.i16
	<.main+6744 @03f288> : 11 20 00 00                load.sp(+32)
	<.main+6748 @03f28c> : 21                         load.i16
	<.main+6749 @03f28d> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@03f28e> - <@03f299>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6750 @03f28e> : 11 24 00 00                load.sp(+36)
	<.main+6754 @03f292> : 21                         load.i16
	<.main+6755 @03f293> : 11 24 00 00                load.sp(+36)
	<.main+6759 @03f297> : 21                         load.i16
	<.main+6760 @03f298> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@03f299> - <@03f2a4>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6761 @03f299> : 11 28 00 00                load.sp(+40)
	<.main+6765 @03f29d> : 21                         load.i16
	<.main+6766 @03f29e> : 11 28 00 00                load.sp(+40)
	<.main+6770 @03f2a2> : 21                         load.i16
	<.main+6771 @03f2a3> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@03f2a4> - <@03f2af>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6772 @03f2a4> : 11 2c 00 00                load.sp(+44)
	<.main+6776 @03f2a8> : 21                         load.i16
	<.main+6777 @03f2a9> : 11 2c 00 00                load.sp(+44)
	<.main+6781 @03f2ad> : 21                         load.i16
	<.main+6782 @03f2ae> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@03f2af> - <@03f2b7>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6783 @03f2af> : 11 30 00 00                load.sp(+48)
	<.main+6787 @03f2b3> : 21                         load.i16
	<.main+6788 @03f2b4> : 12 72                      dup.x1 sp(114)
	<.main+6790 @03f2b6> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@03f2b7> - <@03f2bf>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6791 @03f2b7> : 11 34 00 00                load.sp(+52)
	<.main+6795 @03f2bb> : 21                         load.i16
	<.main+6796 @03f2bc> : 12 73                      dup.x1 sp(115)
	<.main+6798 @03f2be> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@03f2bf> - <@03f2c6>): u16Not: bool := bool(!(u16B))
	<.main+6799 @03f2bf> : 11 34 00 00                load.sp(+52)
	<.main+6803 @03f2c3> : 21                         load.i16
	<.main+6804 @03f2c4> : 5a                         i32.2bool
	<.main+6805 @03f2c5> : 0a                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@03f2c6> - <@03f2d1>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6806 @03f2c6> : 11 3c 00 00                load.sp(+60)
	<.main+6810 @03f2ca> : 21                         load.i16
	<.main+6811 @03f2cb> : 11 3c 00 00                load.sp(+60)
	<.main+6815 @03f2cf> : 21                         load.i16
	<.main+6816 @03f2d0> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@03f2d1> - <@03f2dd>): u16Cne: bool := bool(u16A != u16B)
	<.main+6817 @03f2d1> : 11 40 00 00                load.sp(+64)
	<.main+6821 @03f2d5> : 21                         load.i16
	<.main+6822 @03f2d6> : 11 40 00 00                load.sp(+64)
	<.main+6826 @03f2da> : 21                         load.i16
	<.main+6827 @03f2db> : 57                         ceq.i32
	<.main+6828 @03f2dc> : 0a                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@03f2dd> - <@03f2e8>): u16Clt: bool := bool(u16A < u16B)
	<.main+6829 @03f2dd> : 11 44 00 00                load.sp(+68)
	<.main+6833 @03f2e1> : 21                         load.i16
	<.main+6834 @03f2e2> : 11 44 00 00                load.sp(+68)
	<.main+6838 @03f2e6> : 21                         load.i16
	<.main+6839 @03f2e7> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@03f2e8> - <@03f2f4>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6840 @03f2e8> : 11 48 00 00                load.sp(+72)
	<.main+6844 @03f2ec> : 21                         load.i16
	<.main+6845 @03f2ed> : 11 48 00 00                load.sp(+72)
	<.main+6849 @03f2f1> : 21                         load.i16
	<.main+6850 @03f2f2> : 39                         cgt.u32
	<.main+6851 @03f2f3> : 0a                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@03f2f4> - <@03f2ff>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6852 @03f2f4> : 11 4c 00 00                load.sp(+76)
	<.main+6856 @03f2f8> : 21                         load.i16
	<.main+6857 @03f2f9> : 11 4c 00 00                load.sp(+76)
	<.main+6861 @03f2fd> : 21                         load.i16
	<.main+6862 @03f2fe> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@03f2ff> - <@03f30b>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6863 @03f2ff> : 11 50 00 00                load.sp(+80)
	<.main+6867 @03f303> : 21                         load.i16
	<.main+6868 @03f304> : 11 50 00 00                load.sp(+80)
	<.main+6872 @03f308> : 21                         load.i16
	<.main+6873 @03f309> : 38                         clt.u32
	<.main+6874 @03f30a> : 0a                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@03f30b> - <@03f310>): i32A: int32 := a
	<.main+6875 @03f30b> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@03f310> - <@03f315>): i32B: int32 := b
	<.main+6880 @03f310> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@03f315> - <@03f317>): i32Pls: int32 := int32(+i32B)
	<.main+6885 @03f315> : 12 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@03f317> - <@03f31a>): i32Neg: int32 := int32(-i32B)
	<.main+6887 @03f317> : 12 01                      dup.x1 sp(1)
	<.main+6889 @03f319> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@03f31a> - <@03f31d>): i32Cmt: int32 := int32(~i32B)
	<.main+6890 @03f31a> : 12 02                      dup.x1 sp(2)
	<.main+6892 @03f31c> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@03f31d> - <@03f322>): i32Add: int32 := int32(i32A + i32B)
	<.main+6893 @03f31d> : 12 04                      dup.x1 sp(4)
	<.main+6895 @03f31f> : 12 04                      dup.x1 sp(4)
	<.main+6897 @03f321> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@03f322> - <@03f327>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6898 @03f322> : 12 05                      dup.x1 sp(5)
	<.main+6900 @03f324> : 12 05                      dup.x1 sp(5)
	<.main+6902 @03f326> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@03f327> - <@03f32c>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6903 @03f327> : 12 06                      dup.x1 sp(6)
	<.main+6905 @03f329> : 12 06                      dup.x1 sp(6)
	<.main+6907 @03f32b> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@03f32c> - <@03f331>): i32Div: int32 := int32(i32A / i32B)
	<.main+6908 @03f32c> : 12 07                      dup.x1 sp(7)
	<.main+6910 @03f32e> : 12 07                      dup.x1 sp(7)
	<.main+6912 @03f330> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@03f331> - <@03f336>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6913 @03f331> : 12 08                      dup.x1 sp(8)
	<.main+6915 @03f333> : 12 08                      dup.x1 sp(8)
	<.main+6917 @03f335> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@03f336> - <@03f33b>): i32And: int32 := int32(i32A & i32B)
	<.main+6918 @03f336> : 12 09                      dup.x1 sp(9)
	<.main+6920 @03f338> : 12 09                      dup.x1 sp(9)
	<.main+6922 @03f33a> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@03f33b> - <@03f340>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6923 @03f33b> : 12 0a                      dup.x1 sp(10)
	<.main+6925 @03f33d> : 12 0a                      dup.x1 sp(10)
	<.main+6927 @03f33f> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@03f340> - <@03f345>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6928 @03f340> : 12 0b                      dup.x1 sp(11)
	<.main+6930 @03f342> : 12 0b                      dup.x1 sp(11)
	<.main+6932 @03f344> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@03f345> - <@03f34a>): i32Shl: int32 := int32(i32A << shift)
	<.main+6933 @03f345> : 12 0c                      dup.x1 sp(12)
	<.main+6935 @03f347> : 12 88                      dup.x1 sp(136)
	<.main+6937 @03f349> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@03f34a> - <@03f34f>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6938 @03f34a> : 12 0d                      dup.x1 sp(13)
	<.main+6940 @03f34c> : 12 89                      dup.x1 sp(137)
	<.main+6942 @03f34e> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@03f34f> - <@03f353>): i32Not: bool := bool(!(i32B))
	<.main+6943 @03f34f> : 12 0d                      dup.x1 sp(13)
	<.main+6945 @03f351> : 5a                         i32.2bool
	<.main+6946 @03f352> : 0a                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@03f353> - <@03f358>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6947 @03f353> : 12 0f                      dup.x1 sp(15)
	<.main+6949 @03f355> : 12 0f                      dup.x1 sp(15)
	<.main+6951 @03f357> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@03f358> - <@03f35e>): i32Cne: bool := bool(i32A != i32B)
	<.main+6952 @03f358> : 12 10                      dup.x1 sp(16)
	<.main+6954 @03f35a> : 12 10                      dup.x1 sp(16)
	<.main+6956 @03f35c> : 57                         ceq.i32
	<.main+6957 @03f35d> : 0a                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@03f35e> - <@03f363>): i32Clt: bool := bool(i32A < i32B)
	<.main+6958 @03f35e> : 12 11                      dup.x1 sp(17)
	<.main+6960 @03f360> : 12 11                      dup.x1 sp(17)
	<.main+6962 @03f362> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@03f363> - <@03f369>): i32Cle: bool := bool(i32A <= i32B)
	<.main+6963 @03f363> : 12 12                      dup.x1 sp(18)
	<.main+6965 @03f365> : 12 12                      dup.x1 sp(18)
	<.main+6967 @03f367> : 59                         cgt.i32
	<.main+6968 @03f368> : 0a                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@03f369> - <@03f36e>): i32Cgt: bool := bool(i32A > i32B)
	<.main+6969 @03f369> : 12 13                      dup.x1 sp(19)
	<.main+6971 @03f36b> : 12 13                      dup.x1 sp(19)
	<.main+6973 @03f36d> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@03f36e> - <@03f374>): i32Cge: bool := bool(i32A >= i32B)
	<.main+6974 @03f36e> : 12 14                      dup.x1 sp(20)
	<.main+6976 @03f370> : 12 14                      dup.x1 sp(20)
	<.main+6978 @03f372> : 58                         clt.i32
	<.main+6979 @03f373> : 0a                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@03f374> - <@03f379>): u32A: uint32 := a
	<.main+6980 @03f374> : 1b 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@03f379> - <@03f37e>): u32B: uint32 := b
	<.main+6985 @03f379> : 1b 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@03f37e> - <@03f380>): u32Pls: uint32 := uint32(+u32B)
	<.main+6990 @03f37e> : 12 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@03f380> - <@03f383>): u32Neg: uint32 := uint32(-u32B)
	<.main+6992 @03f380> : 12 01                      dup.x1 sp(1)
	<.main+6994 @03f382> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@03f383> - <@03f386>): u32Cmt: uint32 := uint32(~u32B)
	<.main+6995 @03f383> : 12 02                      dup.x1 sp(2)
	<.main+6997 @03f385> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@03f386> - <@03f38b>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+6998 @03f386> : 12 04                      dup.x1 sp(4)
	<.main+7000 @03f388> : 12 04                      dup.x1 sp(4)
	<.main+7002 @03f38a> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@03f38b> - <@03f390>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7003 @03f38b> : 12 05                      dup.x1 sp(5)
	<.main+7005 @03f38d> : 12 05                      dup.x1 sp(5)
	<.main+7007 @03f38f> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@03f390> - <@03f395>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7008 @03f390> : 12 06                      dup.x1 sp(6)
	<.main+7010 @03f392> : 12 06                      dup.x1 sp(6)
	<.main+7012 @03f394> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@03f395> - <@03f39a>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7013 @03f395> : 12 07                      dup.x1 sp(7)
	<.main+7015 @03f397> : 12 07                      dup.x1 sp(7)
	<.main+7017 @03f399> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@03f39a> - <@03f39f>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7018 @03f39a> : 12 08                      dup.x1 sp(8)
	<.main+7020 @03f39c> : 12 08                      dup.x1 sp(8)
	<.main+7022 @03f39e> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@03f39f> - <@03f3a4>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7023 @03f39f> : 12 09                      dup.x1 sp(9)
	<.main+7025 @03f3a1> : 12 09                      dup.x1 sp(9)
	<.main+7027 @03f3a3> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@03f3a4> - <@03f3a9>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7028 @03f3a4> : 12 0a                      dup.x1 sp(10)
	<.main+7030 @03f3a6> : 12 0a                      dup.x1 sp(10)
	<.main+7032 @03f3a8> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@03f3a9> - <@03f3ae>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7033 @03f3a9> : 12 0b                      dup.x1 sp(11)
	<.main+7035 @03f3ab> : 12 0b                      dup.x1 sp(11)
	<.main+7037 @03f3ad> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@03f3ae> - <@03f3b3>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7038 @03f3ae> : 12 0c                      dup.x1 sp(12)
	<.main+7040 @03f3b0> : 12 9e                      dup.x1 sp(158)
	<.main+7042 @03f3b2> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@03f3b3> - <@03f3b8>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7043 @03f3b3> : 12 0d                      dup.x1 sp(13)
	<.main+7045 @03f3b5> : 12 9f                      dup.x1 sp(159)
	<.main+7047 @03f3b7> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@03f3b8> - <@03f3bc>): u32Not: bool := bool(!(u32B))
	<.main+7048 @03f3b8> : 12 0d                      dup.x1 sp(13)
	<.main+7050 @03f3ba> : 5a                         i32.2bool
	<.main+7051 @03f3bb> : 0a                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@03f3bc> - <@03f3c1>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7052 @03f3bc> : 12 0f                      dup.x1 sp(15)
	<.main+7054 @03f3be> : 12 0f                      dup.x1 sp(15)
	<.main+7056 @03f3c0> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@03f3c1> - <@03f3c7>): u32Cne: bool := bool(u32A != u32B)
	<.main+7057 @03f3c1> : 12 10                      dup.x1 sp(16)
	<.main+7059 @03f3c3> : 12 10                      dup.x1 sp(16)
	<.main+7061 @03f3c5> : 57                         ceq.i32
	<.main+7062 @03f3c6> : 0a                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@03f3c7> - <@03f3cc>): u32Clt: bool := bool(u32A < u32B)
	<.main+7063 @03f3c7> : 12 11                      dup.x1 sp(17)
	<.main+7065 @03f3c9> : 12 11                      dup.x1 sp(17)
	<.main+7067 @03f3cb> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@03f3cc> - <@03f3d2>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7068 @03f3cc> : 12 12                      dup.x1 sp(18)
	<.main+7070 @03f3ce> : 12 12                      dup.x1 sp(18)
	<.main+7072 @03f3d0> : 39                         cgt.u32
	<.main+7073 @03f3d1> : 0a                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@03f3d2> - <@03f3d7>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7074 @03f3d2> : 12 13                      dup.x1 sp(19)
	<.main+7076 @03f3d4> : 12 13                      dup.x1 sp(19)
	<.main+7078 @03f3d6> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@03f3d7> - <@03f3dd>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7079 @03f3d7> : 12 14                      dup.x1 sp(20)
	<.main+7081 @03f3d9> : 12 14                      dup.x1 sp(20)
	<.main+7083 @03f3db> : 38                         clt.u32
	<.main+7084 @03f3dc> : 0a                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@03f3dd> - <@03f3e6>): i64A: int64 := a
	<.main+7085 @03f3dd> : 1c 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@03f3e6> - <@03f3ef>): i64B: int64 := b
	<.main+7094 @03f3e6> : 1c 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@03f3ef> - <@03f3f1>): i64Pls: int64 := int64(+i64B)
	<.main+7103 @03f3ef> : 13 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@03f3f1> - <@03f3f4>): i64Neg: int64 := int64(-i64B)
	<.main+7105 @03f3f1> : 13 02                      dup.x2 sp(2)
	<.main+7107 @03f3f3> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@03f3f4> - <@03f3f7>): i64Cmt: int64 := int64(~i64B)
	<.main+7108 @03f3f4> : 13 04                      dup.x2 sp(4)
	<.main+7110 @03f3f6> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@03f3f7> - <@03f3fc>): i64Add: int64 := int64(i64A + i64B)
	<.main+7111 @03f3f7> : 13 08                      dup.x2 sp(8)
	<.main+7113 @03f3f9> : 13 08                      dup.x2 sp(8)
	<.main+7115 @03f3fb> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@03f3fc> - <@03f401>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7116 @03f3fc> : 13 0a                      dup.x2 sp(10)
	<.main+7118 @03f3fe> : 13 0a                      dup.x2 sp(10)
	<.main+7120 @03f400> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@03f401> - <@03f406>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7121 @03f401> : 13 0c                      dup.x2 sp(12)
	<.main+7123 @03f403> : 13 0c                      dup.x2 sp(12)
	<.main+7125 @03f405> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@03f406> - <@03f40b>): i64Div: int64 := int64(i64A / i64B)
	<.main+7126 @03f406> : 13 0e                      dup.x2 sp(14)
	<.main+7128 @03f408> : 13 0e                      dup.x2 sp(14)
	<.main+7130 @03f40a> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@03f40b> - <@03f410>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7131 @03f40b> : 13 10                      dup.x2 sp(16)
	<.main+7133 @03f40d> : 13 10                      dup.x2 sp(16)
	<.main+7135 @03f40f> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@03f410> - <@03f415>): i64And: int64 := int64(i64A & i64B)
	<.main+7136 @03f410> : 13 12                      dup.x2 sp(18)
	<.main+7138 @03f412> : 13 12                      dup.x2 sp(18)
	<.main+7140 @03f414> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@03f415> - <@03f41a>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7141 @03f415> : 13 14                      dup.x2 sp(20)
	<.main+7143 @03f417> : 13 14                      dup.x2 sp(20)
	<.main+7145 @03f419> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@03f41a> - <@03f41f>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7146 @03f41a> : 13 16                      dup.x2 sp(22)
	<.main+7148 @03f41c> : 13 16                      dup.x2 sp(22)
	<.main+7150 @03f41e> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@03f41f> - <@03f424>): i64Shl: int64 := int64(i64A << shift)
	<.main+7151 @03f41f> : 13 18                      dup.x2 sp(24)
	<.main+7153 @03f421> : 12 c2                      dup.x1 sp(194)
	<.main+7155 @03f423> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@03f424> - <@03f429>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7156 @03f424> : 13 1a                      dup.x2 sp(26)
	<.main+7158 @03f426> : 12 c4                      dup.x1 sp(196)
	<.main+7160 @03f428> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@03f429> - <@03f42d>): i64Not: bool := bool(!(i64B))
	<.main+7161 @03f429> : 13 1a                      dup.x2 sp(26)
	<.main+7163 @03f42b> : 6c                         i64.2bool
	<.main+7164 @03f42c> : 0a                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@03f42d> - <@03f432>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7165 @03f42d> : 13 1d                      dup.x2 sp(29)
	<.main+7167 @03f42f> : 13 1d                      dup.x2 sp(29)
	<.main+7169 @03f431> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@03f432> - <@03f438>): i64Cne: bool := bool(i64A != i64B)
	<.main+7170 @03f432> : 13 1e                      dup.x2 sp(30)
	<.main+7172 @03f434> : 13 1e                      dup.x2 sp(30)
	<.main+7174 @03f436> : 67                         ceq.i64
	<.main+7175 @03f437> : 0a                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@03f438> - <@03f43d>): i64Clt: bool := bool(i64A < i64B)
	<.main+7176 @03f438> : 13 1f                      dup.x2 sp(31)
	<.main+7178 @03f43a> : 13 1f                      dup.x2 sp(31)
	<.main+7180 @03f43c> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@03f43d> - <@03f443>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7181 @03f43d> : 13 20                      dup.x2 sp(32)
	<.main+7183 @03f43f> : 13 20                      dup.x2 sp(32)
	<.main+7185 @03f441> : 69                         cgt.i64
	<.main+7186 @03f442> : 0a                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@03f443> - <@03f448>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7187 @03f443> : 13 21                      dup.x2 sp(33)
	<.main+7189 @03f445> : 13 21                      dup.x2 sp(33)
	<.main+7191 @03f447> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@03f448> - <@03f44e>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7192 @03f448> : 13 22                      dup.x2 sp(34)
	<.main+7194 @03f44a> : 13 22                      dup.x2 sp(34)
	<.main+7196 @03f44c> : 68                         clt.i64
	<.main+7197 @03f44d> : 0a                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@03f44e> - <@03f457>): u64A: uint64 := a
	<.main+7198 @03f44e> : 1c 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@03f457> - <@03f460>): u64B: uint64 := b
	<.main+7207 @03f457> : 1c 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@03f460> - <@03f462>): u64Pls: uint64 := uint64(+u64B)
	<.main+7216 @03f460> : 13 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@03f462> - <@03f465>): u64Neg: uint64 := uint64(-u64B)
	<.main+7218 @03f462> : 13 02                      dup.x2 sp(2)
	<.main+7220 @03f464> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@03f465> - <@03f468>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7221 @03f465> : 13 04                      dup.x2 sp(4)
	<.main+7223 @03f467> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@03f468> - <@03f46d>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7224 @03f468> : 13 08                      dup.x2 sp(8)
	<.main+7226 @03f46a> : 13 08                      dup.x2 sp(8)
	<.main+7228 @03f46c> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@03f46d> - <@03f472>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7229 @03f46d> : 13 0a                      dup.x2 sp(10)
	<.main+7231 @03f46f> : 13 0a                      dup.x2 sp(10)
	<.main+7233 @03f471> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@03f472> - <@03f477>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7234 @03f472> : 13 0c                      dup.x2 sp(12)
	<.main+7236 @03f474> : 13 0c                      dup.x2 sp(12)
	<.main+7238 @03f476> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@03f477> - <@03f47c>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7239 @03f477> : 13 0e                      dup.x2 sp(14)
	<.main+7241 @03f479> : 13 0e                      dup.x2 sp(14)
	<.main+7243 @03f47b> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@03f47c> - <@03f481>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7244 @03f47c> : 13 10                      dup.x2 sp(16)
	<.main+7246 @03f47e> : 13 10                      dup.x2 sp(16)
	<.main+7248 @03f480> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@03f481> - <@03f486>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7249 @03f481> : 13 12                      dup.x2 sp(18)
	<.main+7251 @03f483> : 13 12                      dup.x2 sp(18)
	<.main+7253 @03f485> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@03f486> - <@03f48b>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7254 @03f486> : 13 14                      dup.x2 sp(20)
	<.main+7256 @03f488> : 13 14                      dup.x2 sp(20)
	<.main+7258 @03f48a> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@03f48b> - <@03f490>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7259 @03f48b> : 13 16                      dup.x2 sp(22)
	<.main+7261 @03f48d> : 13 16                      dup.x2 sp(22)
	<.main+7263 @03f48f> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@03f490> - <@03f495>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7264 @03f490> : 13 18                      dup.x2 sp(24)
	<.main+7266 @03f492> : 12 e7                      dup.x1 sp(231)
	<.main+7268 @03f494> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@03f495> - <@03f49a>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7269 @03f495> : 13 1a                      dup.x2 sp(26)
	<.main+7271 @03f497> : 12 e9                      dup.x1 sp(233)
	<.main+7273 @03f499> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@03f49a> - <@03f49e>): u64Not: bool := bool(!(u64B))
	<.main+7274 @03f49a> : 13 1a                      dup.x2 sp(26)
	<.main+7276 @03f49c> : 6c                         i64.2bool
	<.main+7277 @03f49d> : 0a                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@03f49e> - <@03f4a3>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7278 @03f49e> : 13 1d                      dup.x2 sp(29)
	<.main+7280 @03f4a0> : 13 1d                      dup.x2 sp(29)
	<.main+7282 @03f4a2> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@03f4a3> - <@03f4a9>): u64Cne: bool := bool(u64A != u64B)
	<.main+7283 @03f4a3> : 13 1e                      dup.x2 sp(30)
	<.main+7285 @03f4a5> : 13 1e                      dup.x2 sp(30)
	<.main+7287 @03f4a7> : 67                         ceq.i64
	<.main+7288 @03f4a8> : 0a                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@03f4a9> - <@03f4ae>): u64Clt: bool := bool(u64A < u64B)
	<.main+7289 @03f4a9> : 13 1f                      dup.x2 sp(31)
	<.main+7291 @03f4ab> : 13 1f                      dup.x2 sp(31)
	<.main+7293 @03f4ad> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@03f4ae> - <@03f4b4>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7294 @03f4ae> : 13 20                      dup.x2 sp(32)
	<.main+7296 @03f4b0> : 13 20                      dup.x2 sp(32)
	<.main+7298 @03f4b2> : 49                         cgt.u64
	<.main+7299 @03f4b3> : 0a                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@03f4b4> - <@03f4b9>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7300 @03f4b4> : 13 21                      dup.x2 sp(33)
	<.main+7302 @03f4b6> : 13 21                      dup.x2 sp(33)
	<.main+7304 @03f4b8> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@03f4b9> - <@03f4bf>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7305 @03f4b9> : 13 22                      dup.x2 sp(34)
	<.main+7307 @03f4bb> : 13 22                      dup.x2 sp(34)
	<.main+7309 @03f4bd> : 48                         clt.u64
	<.main+7310 @03f4be> : 0a                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@03f4bf> - <@03f4c4>): f32A: float32 := a
	<.main+7311 @03f4bf> : 1d 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@03f4c4> - <@03f4c9>): f32B: float32 := b
	<.main+7316 @03f4c4> : 1d 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@03f4c9> - <@03f4cb>): f32Pls: float32 := float32(+f32B)
	<.main+7321 @03f4c9> : 12 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@03f4cb> - <@03f4ce>): f32Neg: float32 := float32(-f32B)
	<.main+7323 @03f4cb> : 12 01                      dup.x1 sp(1)
	<.main+7325 @03f4cd> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@03f4ce> - <@03f4d3>): f32Add: float32 := float32(f32A + f32B)
	<.main+7326 @03f4ce> : 12 03                      dup.x1 sp(3)
	<.main+7328 @03f4d0> : 12 03                      dup.x1 sp(3)
	<.main+7330 @03f4d2> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@03f4d3> - <@03f4d8>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7331 @03f4d3> : 12 04                      dup.x1 sp(4)
	<.main+7333 @03f4d5> : 12 04                      dup.x1 sp(4)
	<.main+7335 @03f4d7> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@03f4d8> - <@03f4dd>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7336 @03f4d8> : 12 05                      dup.x1 sp(5)
	<.main+7338 @03f4da> : 12 05                      dup.x1 sp(5)
	<.main+7340 @03f4dc> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@03f4dd> - <@03f4e2>): f32Div: float32 := float32(f32A / f32B)
	<.main+7341 @03f4dd> : 12 06                      dup.x1 sp(6)
	<.main+7343 @03f4df> : 12 06                      dup.x1 sp(6)
	<.main+7345 @03f4e1> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@03f4e2> - <@03f4e7>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7346 @03f4e2> : 12 07                      dup.x1 sp(7)
	<.main+7348 @03f4e4> : 12 07                      dup.x1 sp(7)
	<.main+7350 @03f4e6> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@03f4e7> - <@03f4eb>): f32Not: bool := bool(!(f32B))
	<.main+7351 @03f4e7> : 12 07                      dup.x1 sp(7)
	<.main+7353 @03f4e9> : 7b                         f32.2bool
	<.main+7354 @03f4ea> : 0a                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@03f4eb> - <@03f4f0>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7355 @03f4eb> : 12 09                      dup.x1 sp(9)
	<.main+7357 @03f4ed> : 12 09                      dup.x1 sp(9)
	<.main+7359 @03f4ef> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@03f4f0> - <@03f4f6>): f32Cne: bool := bool(f32A != f32B)
	<.main+7360 @03f4f0> : 12 0a                      dup.x1 sp(10)
	<.main+7362 @03f4f2> : 12 0a                      dup.x1 sp(10)
	<.main+7364 @03f4f4> : 77                         ceq.f32
	<.main+7365 @03f4f5> : 0a                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@03f4f6> - <@03f4fb>): f32Clt: bool := bool(f32A < f32B)
	<.main+7366 @03f4f6> : 12 0b                      dup.x1 sp(11)
	<.main+7368 @03f4f8> : 12 0b                      dup.x1 sp(11)
	<.main+7370 @03f4fa> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@03f4fb> - <@03f501>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7371 @03f4fb> : 12 0c                      dup.x1 sp(12)
	<.main+7373 @03f4fd> : 12 0c                      dup.x1 sp(12)
	<.main+7375 @03f4ff> : 79                         cgt.f32
	<.main+7376 @03f500> : 0a                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@03f501> - <@03f506>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7377 @03f501> : 12 0d                      dup.x1 sp(13)
	<.main+7379 @03f503> : 12 0d                      dup.x1 sp(13)
	<.main+7381 @03f505> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@03f506> - <@03f50c>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7382 @03f506> : 12 0e                      dup.x1 sp(14)
	<.main+7384 @03f508> : 12 0e                      dup.x1 sp(14)
	<.main+7386 @03f50a> : 78                         clt.f32
	<.main+7387 @03f50b> : 0a                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@03f50c> - <@03f515>): f64A: float64 := a
	<.main+7388 @03f50c> : 1e 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@03f515> - <@03f51e>): f64B: float64 := b
	<.main+7397 @03f515> : 1e 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@03f51e> - <@03f520>): f64Pls: float64 := float64(+f64B)
	<.main+7406 @03f51e> : 13 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@03f520> - <@03f523>): f64Neg: float64 := float64(-f64B)
	<.main+7408 @03f520> : 13 02                      dup.x2 sp(2)
	<.main+7410 @03f522> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@03f523> - <@03f528>): f64Add: float64 := float64(f64A + f64B)
	<.main+7411 @03f523> : 13 06                      dup.x2 sp(6)
	<.main+7413 @03f525> : 13 06                      dup.x2 sp(6)
	<.main+7415 @03f527> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@03f528> - <@03f52d>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7416 @03f528> : 13 08                      dup.x2 sp(8)
	<.main+7418 @03f52a> : 13 08                      dup.x2 sp(8)
	<.main+7420 @03f52c> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@03f52d> - <@03f532>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7421 @03f52d> : 13 0a                      dup.x2 sp(10)
	<.main+7423 @03f52f> : 13 0a                      dup.x2 sp(10)
	<.main+7425 @03f531> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@03f532> - <@03f537>): f64Div: float64 := float64(f64A / f64B)
	<.main+7426 @03f532> : 13 0c                      dup.x2 sp(12)
	<.main+7428 @03f534> : 13 0c                      dup.x2 sp(12)
	<.main+7430 @03f536> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@03f537> - <@03f53c>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7431 @03f537> : 13 0e                      dup.x2 sp(14)
	<.main+7433 @03f539> : 13 0e                      dup.x2 sp(14)
	<.main+7435 @03f53b> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@03f53c> - <@03f540>): f64Not: bool := bool(!(f64B))
	<.main+7436 @03f53c> : 13 0e                      dup.x2 sp(14)
	<.main+7438 @03f53e> : 8d                         f64.2bool
	<.main+7439 @03f53f> : 0a                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@03f540> - <@03f545>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7440 @03f540> : 13 11                      dup.x2 sp(17)
	<.main+7442 @03f542> : 13 11                      dup.x2 sp(17)
	<.main+7444 @03f544> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@03f545> - <@03f54b>): f64Cne: bool := bool(f64A != f64B)
	<.main+7445 @03f545> : 13 12                      dup.x2 sp(18)
	<.main+7447 @03f547> : 13 12                      dup.x2 sp(18)
	<.main+7449 @03f549> : 87                         ceq.f64
	<.main+7450 @03f54a> : 0a                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@03f54b> - <@03f550>): f64Clt: bool := bool(f64A < f64B)
	<.main+7451 @03f54b> : 13 13                      dup.x2 sp(19)
	<.main+7453 @03f54d> : 13 13                      dup.x2 sp(19)
	<.main+7455 @03f54f> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@03f550> - <@03f556>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7456 @03f550> : 13 14                      dup.x2 sp(20)
	<.main+7458 @03f552> : 13 14                      dup.x2 sp(20)
	<.main+7460 @03f554> : 89                         cgt.f64
	<.main+7461 @03f555> : 0a                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@03f556> - <@03f55b>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7462 @03f556> : 13 15                      dup.x2 sp(21)
	<.main+7464 @03f558> : 13 15                      dup.x2 sp(21)
	<.main+7466 @03f55a> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@03f55b> - <@03f561>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7467 @03f55b> : 13 16                      dup.x2 sp(22)
	<.main+7469 @03f55d> : 13 16                      dup.x2 sp(22)
	<.main+7471 @03f55f> : 88                         clt.f64
	<.main+7472 @03f560> : 0a                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@03f561> - <@03f566>): ptrA: pointer := null
	<.main+7473 @03f561> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@03f566> - <@03f56a>): ptrB: pointer := pointer(shift)
	<.main+7478 @03f566> : 11 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@03f56a> - <@03f56f>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7482 @03f56a> : 12 01                      dup.x1 sp(1)
	<.main+7484 @03f56c> : 12 01                      dup.x1 sp(1)
	<.main+7486 @03f56e> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@03f56f> - <@03f575>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7487 @03f56f> : 12 02                      dup.x1 sp(2)
	<.main+7489 @03f571> : 12 02                      dup.x1 sp(2)
	<.main+7491 @03f573> : 57                         ceq.i32
	<.main+7492 @03f574> : 0a                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@03f575> - <@03f59c>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7493 @03f575> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7498 @03f57a> : 1b 04 00 00 00             load.c32 4
	<.main+7503 @03f57f> : 1b 0e 00 00 00             load.c32 14
	<.main+7508 @03f584> : 1b 01 00 00 00             load.c32 1
	<.main+7513 @03f589> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7518 @03f58e> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7523 @03f593> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7528 @03f598> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@03f59c> - <@03f5c3>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7532 @03f59c> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7537 @03f5a1> : 1b 0c 00 00 00             load.c32 12
	<.main+7542 @03f5a6> : 1b 0e 00 00 00             load.c32 14
	<.main+7547 @03f5ab> : 1b 03 00 00 00             load.c32 3
	<.main+7552 @03f5b0> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7557 @03f5b5> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7562 @03f5ba> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7567 @03f5bf> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@03f5c3> - <@03f5ea>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7571 @03f5c3> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7576 @03f5c8> : 1b 16 00 00 00             load.c32 22
	<.main+7581 @03f5cd> : 1b 0e 00 00 00             load.c32 14
	<.main+7586 @03f5d2> : 1b 06 00 00 00             load.c32 6
	<.main+7591 @03f5d7> : 1f a1 c0 03 00             load.ref <@03c0a1> ;"0 == 0"
	<.main+7596 @03f5dc> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+7601 @03f5e1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7606 @03f5e6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@03f5ea> - <@03f5eb>): t: int32 := 0
	<.main+7610 @03f5ea> : 18                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@03f5eb> - <@03f619>): if (bool(t == 0))
	<.main+7611 @03f5eb> : 12 00                      dup.x1 sp(0)
	<.main+7613 @03f5ed> : 18                         load.z32
	<.main+7614 @03f5ee> : 57                         ceq.i32
	<.main+7615 @03f5ef> : 06 2a 00 00                jz <.main+7657 @03f619>
	test/lang/statementIf.ci:29: (38 bytes: <@03f5f3> - <@03f619>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7619 @03f5f3> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7624 @03f5f8> : 1b 1d 00 00 00             load.c32 29
	<.main+7629 @03f5fd> : 1b 0e 00 00 00             load.c32 14
	<.main+7634 @03f602> : 1b 07 00 00 00             load.c32 7
	<.main+7639 @03f607> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7644 @03f60c> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7649 @03f611> : 11 18 00 00                load.sp(+24)
	<.main+7653 @03f615> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@03f619> - <@03f647>): if (bool(t != 0))
	<.main+7657 @03f619> : 12 00                      dup.x1 sp(0)
	<.main+7659 @03f61b> : 18                         load.z32
	<.main+7660 @03f61c> : 57                         ceq.i32
	<.main+7661 @03f61d> : 05 2a 00 00                jnz <.main+7703 @03f647>
	test/lang/statementIf.ci:33: (38 bytes: <@03f621> - <@03f647>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7665 @03f621> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7670 @03f626> : 1b 21 00 00 00             load.c32 33
	<.main+7675 @03f62b> : 1b 0e 00 00 00             load.c32 14
	<.main+7680 @03f630> : 1b 08 00 00 00             load.c32 8
	<.main+7685 @03f635> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7690 @03f63a> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7695 @03f63f> : 11 18 00 00                load.sp(+24)
	<.main+7699 @03f643> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@03f647> - <@03f69f>): if (bool(t == 0))
	<.main+7703 @03f647> : 12 00                      dup.x1 sp(0)
	<.main+7705 @03f649> : 18                         load.z32
	<.main+7706 @03f64a> : 57                         ceq.i32
	<.main+7707 @03f64b> : 06 2e 00 00                jz <.main+7753 @03f679>
	test/lang/statementIf.ci:37: (38 bytes: <@03f64f> - <@03f675>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7711 @03f64f> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7716 @03f654> : 1b 25 00 00 00             load.c32 37
	<.main+7721 @03f659> : 1b 0e 00 00 00             load.c32 14
	<.main+7726 @03f65e> : 1b 09 00 00 00             load.c32 9
	<.main+7731 @03f663> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7736 @03f668> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7741 @03f66d> : 11 18 00 00                load.sp(+24)
	<.main+7745 @03f671> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7749 @03f675> : 04 2a 00 00                jmp <.main+7791 @03f69f>
	test/lang/statementIf.ci:40: (38 bytes: <@03f679> - <@03f69f>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7753 @03f679> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7758 @03f67e> : 1b 28 00 00 00             load.c32 40
	<.main+7763 @03f683> : 1b 0e 00 00 00             load.c32 14
	<.main+7768 @03f688> : 1b 0a 00 00 00             load.c32 10
	<.main+7773 @03f68d> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7778 @03f692> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7783 @03f697> : 11 18 00 00                load.sp(+24)
	<.main+7787 @03f69b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@03f69f> - <@03f6f7>): if (bool(t != 0))
	<.main+7791 @03f69f> : 12 00                      dup.x1 sp(0)
	<.main+7793 @03f6a1> : 18                         load.z32
	<.main+7794 @03f6a2> : 57                         ceq.i32
	<.main+7795 @03f6a3> : 05 2e 00 00                jnz <.main+7841 @03f6d1>
	test/lang/statementIf.ci:44: (38 bytes: <@03f6a7> - <@03f6cd>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7799 @03f6a7> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7804 @03f6ac> : 1b 2c 00 00 00             load.c32 44
	<.main+7809 @03f6b1> : 1b 0e 00 00 00             load.c32 14
	<.main+7814 @03f6b6> : 1b 0b 00 00 00             load.c32 11
	<.main+7819 @03f6bb> : 1f b6 c0 03 00             load.ref <@03c0b6> ;"t != 0"
	<.main+7824 @03f6c0> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7829 @03f6c5> : 11 18 00 00                load.sp(+24)
	<.main+7833 @03f6c9> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7837 @03f6cd> : 04 2a 00 00                jmp <.main+7879 @03f6f7>
	test/lang/statementIf.ci:47: (38 bytes: <@03f6d1> - <@03f6f7>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7841 @03f6d1> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7846 @03f6d6> : 1b 2f 00 00 00             load.c32 47
	<.main+7851 @03f6db> : 1b 0e 00 00 00             load.c32 14
	<.main+7856 @03f6e0> : 1b 0c 00 00 00             load.c32 12
	<.main+7861 @03f6e5> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7866 @03f6ea> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7871 @03f6ef> : 11 18 00 00                load.sp(+24)
	<.main+7875 @03f6f3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@03f6f7> - <@03f85d>): if (bool(t == 0))
	<.main+7879 @03f6f7> : 12 00                      dup.x1 sp(0)
	<.main+7881 @03f6f9> : 18                         load.z32
	<.main+7882 @03f6fa> : 57                         ceq.i32
	<.main+7883 @03f6fb> : 06 2e 00 00                jz <.main+7929 @03f729>
	test/lang/statementIf.ci:51: (38 bytes: <@03f6ff> - <@03f725>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7887 @03f6ff> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7892 @03f704> : 1b 33 00 00 00             load.c32 51
	<.main+7897 @03f709> : 1b 0e 00 00 00             load.c32 14
	<.main+7902 @03f70e> : 1b 09 00 00 00             load.c32 9
	<.main+7907 @03f713> : 1f af c0 03 00             load.ref <@03c0af> ;"t == 0"
	<.main+7912 @03f718> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7917 @03f71d> : 11 18 00 00                load.sp(+24)
	<.main+7921 @03f721> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7925 @03f725> : 04 38 01 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:53: (308 bytes: <@03f729> - <@03f85d>): if (bool(t == 1))
	<.main+7929 @03f729> : 12 00                      dup.x1 sp(0)
	<.main+7931 @03f72b> : 1b 01 00 00 00             load.c32 1
	<.main+7936 @03f730> : 57                         ceq.i32
	<.main+7937 @03f731> : 06 2e 00 00                jz <.main+7983 @03f75f>
	test/lang/statementIf.ci:54: (38 bytes: <@03f735> - <@03f75b>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7941 @03f735> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+7946 @03f73a> : 1b 36 00 00 00             load.c32 54
	<.main+7951 @03f73f> : 1b 0e 00 00 00             load.c32 14
	<.main+7956 @03f744> : 1b 0a 00 00 00             load.c32 10
	<.main+7961 @03f749> : 1f bd c0 03 00             load.ref <@03c0bd> ;"t == 1"
	<.main+7966 @03f74e> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+7971 @03f753> : 11 18 00 00                load.sp(+24)
	<.main+7975 @03f757> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7979 @03f75b> : 04 02 01 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:56: (254 bytes: <@03f75f> - <@03f85d>): if (bool(t == 2))
	<.main+7983 @03f75f> : 12 00                      dup.x1 sp(0)
	<.main+7985 @03f761> : 1b 02 00 00 00             load.c32 2
	<.main+7990 @03f766> : 57                         ceq.i32
	<.main+7991 @03f767> : 06 2e 00 00                jz <.main+8037 @03f795>
	test/lang/statementIf.ci:57: (38 bytes: <@03f76b> - <@03f791>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+7995 @03f76b> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8000 @03f770> : 1b 39 00 00 00             load.c32 57
	<.main+8005 @03f775> : 1b 0e 00 00 00             load.c32 14
	<.main+8010 @03f77a> : 1b 0a 00 00 00             load.c32 10
	<.main+8015 @03f77f> : 1f c4 c0 03 00             load.ref <@03c0c4> ;"t == 2"
	<.main+8020 @03f784> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8025 @03f789> : 11 18 00 00                load.sp(+24)
	<.main+8029 @03f78d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8033 @03f791> : 04 cc 00 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:59: (200 bytes: <@03f795> - <@03f85d>): if (bool(t == 3))
	<.main+8037 @03f795> : 12 00                      dup.x1 sp(0)
	<.main+8039 @03f797> : 1b 03 00 00 00             load.c32 3
	<.main+8044 @03f79c> : 57                         ceq.i32
	<.main+8045 @03f79d> : 06 2e 00 00                jz <.main+8091 @03f7cb>
	test/lang/statementIf.ci:60: (38 bytes: <@03f7a1> - <@03f7c7>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8049 @03f7a1> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8054 @03f7a6> : 1b 3c 00 00 00             load.c32 60
	<.main+8059 @03f7ab> : 1b 0e 00 00 00             load.c32 14
	<.main+8064 @03f7b0> : 1b 0a 00 00 00             load.c32 10
	<.main+8069 @03f7b5> : 1f cb c0 03 00             load.ref <@03c0cb> ;"t == 3"
	<.main+8074 @03f7ba> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8079 @03f7bf> : 11 18 00 00                load.sp(+24)
	<.main+8083 @03f7c3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8087 @03f7c7> : 04 96 00 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:62: (146 bytes: <@03f7cb> - <@03f85d>): if (bool(t == 4))
	<.main+8091 @03f7cb> : 12 00                      dup.x1 sp(0)
	<.main+8093 @03f7cd> : 1b 04 00 00 00             load.c32 4
	<.main+8098 @03f7d2> : 57                         ceq.i32
	<.main+8099 @03f7d3> : 06 2e 00 00                jz <.main+8145 @03f801>
	test/lang/statementIf.ci:63: (38 bytes: <@03f7d7> - <@03f7fd>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8103 @03f7d7> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8108 @03f7dc> : 1b 3f 00 00 00             load.c32 63
	<.main+8113 @03f7e1> : 1b 0e 00 00 00             load.c32 14
	<.main+8118 @03f7e6> : 1b 0a 00 00 00             load.c32 10
	<.main+8123 @03f7eb> : 1f d2 c0 03 00             load.ref <@03c0d2> ;"t == 4"
	<.main+8128 @03f7f0> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8133 @03f7f5> : 11 18 00 00                load.sp(+24)
	<.main+8137 @03f7f9> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8141 @03f7fd> : 04 60 00 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:65: (92 bytes: <@03f801> - <@03f85d>): if (bool(t == 5))
	<.main+8145 @03f801> : 12 00                      dup.x1 sp(0)
	<.main+8147 @03f803> : 1b 05 00 00 00             load.c32 5
	<.main+8152 @03f808> : 57                         ceq.i32
	<.main+8153 @03f809> : 06 2e 00 00                jz <.main+8199 @03f837>
	test/lang/statementIf.ci:66: (38 bytes: <@03f80d> - <@03f833>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8157 @03f80d> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8162 @03f812> : 1b 42 00 00 00             load.c32 66
	<.main+8167 @03f817> : 1b 0e 00 00 00             load.c32 14
	<.main+8172 @03f81c> : 1b 0a 00 00 00             load.c32 10
	<.main+8177 @03f821> : 1f d9 c0 03 00             load.ref <@03c0d9> ;"t == 5"
	<.main+8182 @03f826> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8187 @03f82b> : 11 18 00 00                load.sp(+24)
	<.main+8191 @03f82f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8195 @03f833> : 04 2a 00 00                jmp <.main+8237 @03f85d>
	test/lang/statementIf.ci:69: (38 bytes: <@03f837> - <@03f85d>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8199 @03f837> : 1f 88 c0 03 00             load.ref <@03c088> ;"test/lang/statementIf.ci"
	<.main+8204 @03f83c> : 1b 45 00 00 00             load.c32 69
	<.main+8209 @03f841> : 1b 0e 00 00 00             load.c32 14
	<.main+8214 @03f846> : 1b 0a 00 00 00             load.c32 10
	<.main+8219 @03f84b> : 1f e0 c0 03 00             load.ref <@03c0e0> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8224 @03f850> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8229 @03f855> : 11 18 00 00                load.sp(+24)
	<.main+8233 @03f859> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@03f85d> - <@03f88c>): for ( ; ; )
	<.main+8237 @03f85d> : 04 2b 00 00                jmp <.main+8280 @03f888>
	test/lang/statementFor.ci:4: (35 bytes: <@03f861> - <@03f884>): debug("for ( ; ; )");
	<.main+8241 @03f861> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8246 @03f866> : 1b 04 00 00 00             load.c32 4
	<.main+8251 @03f86b> : 1b 0e 00 00 00             load.c32 14
	<.main+8256 @03f870> : 18                         load.z32
	<.main+8257 @03f871> : 1f d2 c1 03 00             load.ref <@03c1d2> ;"for ( ; ; )"
	<.main+8262 @03f876> : 1f f0 07 00 00             load.ref <@0007f0> ;pointer
	<.main+8267 @03f87b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8272 @03f880> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@03f884> - <@03f888>): break;
	<.main+8276 @03f884> : 04 08 00 00                jmp <.main+8284 @03f88c>
	:: (4 bytes: <@03f888> - <@03f88c>)
	<.main+8280 @03f888> : 04 d9 ff ff                jmp <.main+8241 @03f861>
	test/lang/statementFor.ci:8: (59 bytes: <@03f88c> - <@03f8c7>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8284 @03f88c> : 18                         load.z32
	<.main+8285 @03f88d> : 04 2a 00 00                jmp <.main+8327 @03f8b7>
	test/lang/statementFor.ci:9: (34 bytes: <@03f891> - <@03f8b3>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8289 @03f891> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8294 @03f896> : 1b 09 00 00 00             load.c32 9
	<.main+8299 @03f89b> : 1b 0e 00 00 00             load.c32 14
	<.main+8304 @03f8a0> : 18                         load.z32
	<.main+8305 @03f8a1> : 1f de c1 03 00             load.ref <@03c1de> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8310 @03f8a6> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8315 @03f8ab> : 11 18 00 00                load.sp(+24)
	<.main+8319 @03f8af> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@03f8b3> - <@03f8b7>): int32(i := int32(i + 1))
	<.main+8323 @03f8b3> : 0b 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@03f8b7> - <@03f8c3>): bool(i < 2)
	<.main+8327 @03f8b7> : 12 00                      dup.x1 sp(0)
	<.main+8329 @03f8b9> : 1b 02 00 00 00             load.c32 2
	<.main+8334 @03f8be> : 58                         clt.i32
	<.main+8335 @03f8bf> : 05 d2 ff ff                jnz <.main+8289 @03f891>
	<.main+8339 @03f8c3> : 10 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@03f8c7> - <@03f8c8>): forIdx: int32
	<.main+8343 @03f8c7> : 18                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@03f8c8> - <@03f901>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8344 @03f8c8> : 18                         load.z32
	<.main+8345 @03f8c9> : 15 01                      set.x1 sp(1)
	<.main+8347 @03f8cb> : 04 2a 00 00                jmp <.main+8389 @03f8f5>
	test/lang/statementFor.ci:14: (34 bytes: <@03f8cf> - <@03f8f1>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8351 @03f8cf> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8356 @03f8d4> : 1b 0e 00 00 00             load.c32 14
	<.main+8361 @03f8d9> : 1b 0e 00 00 00             load.c32 14
	<.main+8366 @03f8de> : 18                         load.z32
	<.main+8367 @03f8df> : 1f 04 c2 03 00             load.ref <@03c204> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8372 @03f8e4> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8377 @03f8e9> : 11 18 00 00                load.sp(+24)
	<.main+8381 @03f8ed> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@03f8f1> - <@03f8f5>): int32(forIdx := int32(forIdx + 1))
	<.main+8385 @03f8f1> : 0b 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@03f8f5> - <@03f901>): bool(forIdx < 2)
	<.main+8389 @03f8f5> : 12 00                      dup.x1 sp(0)
	<.main+8391 @03f8f7> : 1b 02 00 00 00             load.c32 2
	<.main+8396 @03f8fc> : 58                         clt.i32
	<.main+8397 @03f8fd> : 05 d2 ff ff                jnz <.main+8351 @03f8cf>
	test/lang/statementFor.ci:17: (75 bytes: <@03f901> - <@03f94c>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8401 @03f901> : 18                         load.z32
	<.main+8402 @03f902> : 04 3a 00 00                jmp <.main+8460 @03f93c>
	test/lang/statementFor.ci:18: (16 bytes: <@03f906> - <@03f916>): if (bool(i < 2))
	<.main+8406 @03f906> : 12 00                      dup.x1 sp(0)
	<.main+8408 @03f908> : 1b 02 00 00 00             load.c32 2
	<.main+8413 @03f90d> : 58                         clt.i32
	<.main+8414 @03f90e> : 06 08 00 00                jz <.main+8422 @03f916>
	test/lang/statementFor.ci:19: (4 bytes: <@03f912> - <@03f916>): continue;
	<.main+8418 @03f912> : 04 26 00 00                jmp <.main+8456 @03f938>
	test/lang/statementFor.ci:21: (34 bytes: <@03f916> - <@03f938>): debug(void("for with continue", i));
	<.main+8422 @03f916> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8427 @03f91b> : 1b 15 00 00 00             load.c32 21
	<.main+8432 @03f920> : 1b 0e 00 00 00             load.c32 14
	<.main+8437 @03f925> : 18                         load.z32
	<.main+8438 @03f926> : 1f 2e c2 03 00             load.ref <@03c22e> ;"for with continue"
	<.main+8443 @03f92b> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8448 @03f930> : 11 18 00 00                load.sp(+24)
	<.main+8452 @03f934> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@03f938> - <@03f93c>): int32(i := int32(i + 1))
	<.main+8456 @03f938> : 0b 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@03f93c> - <@03f948>): bool(i < 7)
	<.main+8460 @03f93c> : 12 00                      dup.x1 sp(0)
	<.main+8462 @03f93e> : 1b 07 00 00 00             load.c32 7
	<.main+8467 @03f943> : 58                         clt.i32
	<.main+8468 @03f944> : 05 c2 ff ff                jnz <.main+8406 @03f906>
	<.main+8472 @03f948> : 10 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@03f94c> - <@03f997>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8476 @03f94c> : 18                         load.z32
	<.main+8477 @03f94d> : 04 3a 00 00                jmp <.main+8535 @03f987>
	test/lang/statementFor.ci:25: (16 bytes: <@03f951> - <@03f961>): if (bool(i > 2))
	<.main+8481 @03f951> : 12 00                      dup.x1 sp(0)
	<.main+8483 @03f953> : 1b 02 00 00 00             load.c32 2
	<.main+8488 @03f958> : 59                         cgt.i32
	<.main+8489 @03f959> : 06 08 00 00                jz <.main+8497 @03f961>
	test/lang/statementFor.ci:26: (4 bytes: <@03f95d> - <@03f961>): break;
	<.main+8493 @03f95d> : 04 36 00 00                jmp <.main+8547 @03f993>
	test/lang/statementFor.ci:28: (34 bytes: <@03f961> - <@03f983>): debug(void("for with break", i));
	<.main+8497 @03f961> : 1f b8 c1 03 00             load.ref <@03c1b8> ;"test/lang/statementFor.ci"
	<.main+8502 @03f966> : 1b 1c 00 00 00             load.c32 28
	<.main+8507 @03f96b> : 1b 0e 00 00 00             load.c32 14
	<.main+8512 @03f970> : 18                         load.z32
	<.main+8513 @03f971> : 1f 40 c2 03 00             load.ref <@03c240> ;"for with break"
	<.main+8518 @03f976> : 1f 70 03 00 00             load.ref <@000370> ;int32
	<.main+8523 @03f97b> : 11 18 00 00                load.sp(+24)
	<.main+8527 @03f97f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@03f983> - <@03f987>): int32(i := int32(i + 1))
	<.main+8531 @03f983> : 0b 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@03f987> - <@03f993>): bool(i < 7)
	<.main+8535 @03f987> : 12 00                      dup.x1 sp(0)
	<.main+8537 @03f989> : 1b 07 00 00 00             load.c32 7
	<.main+8542 @03f98e> : 58                         clt.i32
	<.main+8543 @03f98f> : 05 c2 ff ff                jnz <.main+8481 @03f951>
	<.main+8547 @03f993> : 10 fc ff ff                inc.sp(-4)
	<.main+8551 @03f997> : 01 00 00 00                nfc(0) ;halt(): void
.references:
}

---------- Execute: byte-code
[ 288.36] > .main
[ 288.42]  > float32.sin(x: float32): float32
[ 288.45]  < return
[ 288.92]  > funAdd(x: int32, y: int32): int32
[ 288.95]  < return
[ 288.96]  > funAdd(x: int32, y: int32): int32
[ 288.98]  < return
[ 288.99]  > funMul(x: int32, y: int32): int32
[ 289.01]  < return
[ 289.02]  > funMul(x: int32, y: int32): int32
[ 289.04]  < return
[ 289.05]  > fib(n: uint32): uint32
[ 289.07]   > fib(n: uint32): uint32
[ 289.08]    > fib(n: uint32): uint32
[ 289.10]     > fib(n: uint32): uint32
[ 289.11]      > fib(n: uint32): uint32
[ 289.13]       > fib(n: uint32): uint32
[ 289.14]        > fib(n: uint32): uint32
[ 289.16]         > fib(n: uint32): uint32
[ 289.17]          > fib(n: uint32): uint32
[ 289.19]           > fib(n: uint32): uint32
[ 289.20]            > fib(n: uint32): uint32
[ 289.22]             > fib(n: uint32): uint32
[ 289.23]              > fib(n: uint32): uint32
[ 289.24]              < return
[ 289.26]              > fib(n: uint32): uint32
[ 289.27]              < return
[ 289.28]             < return
[ 289.29]             > fib(n: uint32): uint32
[ 289.31]             < return
[ 289.32]            < return
[ 289.33]            > fib(n: uint32): uint32
[ 289.34]             > fib(n: uint32): uint32
[ 289.36]             < return
[ 289.37]             > fib(n: uint32): uint32
[ 289.38]             < return
[ 289.39]            < return
[ 289.40]           < return
[ 289.41]           > fib(n: uint32): uint32
[ 289.43]            > fib(n: uint32): uint32
[ 289.44]             > fib(n: uint32): uint32
[ 289.45]             < return
[ 289.46]             > fib(n: uint32): uint32
[ 289.48]             < return
[ 289.49]            < return
[ 289.50]            > fib(n: uint32): uint32
[ 289.51]            < return
[ 289.52]           < return
[ 289.54]          < return
[ 289.55]          > fib(n: uint32): uint32
[ 289.56]           > fib(n: uint32): uint32
[ 289.57]            > fib(n: uint32): uint32
[ 289.59]             > fib(n: uint32): uint32
[ 289.61]             < return
[ 289.62]             > fib(n: uint32): uint32
[ 289.63]             < return
[ 289.64]            < return
[ 289.65]            > fib(n: uint32): uint32
[ 289.66]            < return
[ 289.68]           < return
[ 289.69]           > fib(n: uint32): uint32
[ 289.70]            > fib(n: uint32): uint32
[ 289.71]            < return
[ 289.73]            > fib(n: uint32): uint32
[ 289.74]            < return
[ 289.75]           < return
[ 289.76]          < return
[ 289.77]         < return
[ 289.78]         > fib(n: uint32): uint32
[ 289.79]          > fib(n: uint32): uint32
[ 289.81]           > fib(n: uint32): uint32
[ 289.82]            > fib(n: uint32): uint32
[ 289.84]             > fib(n: uint32): uint32
[ 289.85]             < return
[ 289.86]             > fib(n: uint32): uint32
[ 289.88]             < return
[ 289.89]            < return
[ 289.90]            > fib(n: uint32): uint32
[ 289.92]            < return
[ 289.93]           < return
[ 289.94]           > fib(n: uint32): uint32
[ 289.96]            > fib(n: uint32): uint32
[ 289.97]            < return
[ 289.98]            > fib(n: uint32): uint32
[ 290.00]            < return
[ 290.01]           < return
[ 290.02]          < return
[ 290.03]          > fib(n: uint32): uint32
[ 290.04]           > fib(n: uint32): uint32
[ 290.06]            > fib(n: uint32): uint32
[ 290.07]            < return
[ 290.08]            > fib(n: uint32): uint32
[ 290.10]            < return
[ 290.11]           < return
[ 290.12]           > fib(n: uint32): uint32
[ 290.13]           < return
[ 290.14]          < return
[ 290.15]         < return
[ 290.16]        < return
[ 290.18]        > fib(n: uint32): uint32
[ 290.19]         > fib(n: uint32): uint32
[ 290.20]          > fib(n: uint32): uint32
[ 290.22]           > fib(n: uint32): uint32
[ 290.24]            > fib(n: uint32): uint32
[ 290.26]             > fib(n: uint32): uint32
[ 290.27]             < return
[ 290.28]             > fib(n: uint32): uint32
[ 290.30]             < return
[ 290.31]            < return
[ 290.32]            > fib(n: uint32): uint32
[ 290.33]            < return
[ 290.35]           < return
[ 290.36]           > fib(n: uint32): uint32
[ 290.37]            > fib(n: uint32): uint32
[ 290.38]            < return
[ 290.40]            > fib(n: uint32): uint32
[ 290.41]            < return
[ 290.42]           < return
[ 290.43]          < return
[ 290.44]          > fib(n: uint32): uint32
[ 290.46]           > fib(n: uint32): uint32
[ 290.47]            > fib(n: uint32): uint32
[ 290.49]            < return
[ 290.50]            > fib(n: uint32): uint32
[ 290.51]            < return
[ 290.52]           < return
[ 290.53]           > fib(n: uint32): uint32
[ 290.55]           < return
[ 290.56]          < return
[ 290.57]         < return
[ 290.58]         > fib(n: uint32): uint32
[ 290.59]          > fib(n: uint32): uint32
[ 290.61]           > fib(n: uint32): uint32
[ 290.62]            > fib(n: uint32): uint32
[ 290.63]            < return
[ 290.65]            > fib(n: uint32): uint32
[ 290.66]            < return
[ 290.67]           < return
[ 290.68]           > fib(n: uint32): uint32
[ 290.69]           < return
[ 290.71]          < return
[ 290.72]          > fib(n: uint32): uint32
[ 290.73]           > fib(n: uint32): uint32
[ 290.75]           < return
[ 290.76]           > fib(n: uint32): uint32
[ 290.77]           < return
[ 290.78]          < return
[ 290.79]         < return
[ 290.80]        < return
[ 290.81]       < return
[ 290.82]       > fib(n: uint32): uint32
[ 290.84]        > fib(n: uint32): uint32
[ 290.85]         > fib(n: uint32): uint32
[ 290.87]          > fib(n: uint32): uint32
[ 290.88]           > fib(n: uint32): uint32
[ 290.89]            > fib(n: uint32): uint32
[ 290.91]             > fib(n: uint32): uint32
[ 290.92]             < return
[ 290.94]             > fib(n: uint32): uint32
[ 290.95]             < return
[ 290.96]            < return
[ 290.97]            > fib(n: uint32): uint32
[ 290.98]            < return
[ 291.00]           < return
[ 291.00]           > fib(n: uint32): uint32
[ 291.02]            > fib(n: uint32): uint32
[ 291.03]            < return
[ 291.05]            > fib(n: uint32): uint32
[ 291.06]            < return
[ 291.07]           < return
[ 291.08]          < return
[ 291.09]          > fib(n: uint32): uint32
[ 291.11]           > fib(n: uint32): uint32
[ 291.12]            > fib(n: uint32): uint32
[ 291.13]            < return
[ 291.15]            > fib(n: uint32): uint32
[ 291.16]            < return
[ 291.17]           < return
[ 291.18]           > fib(n: uint32): uint32
[ 291.19]           < return
[ 291.21]          < return
[ 291.22]         < return
[ 291.23]         > fib(n: uint32): uint32
[ 291.24]          > fib(n: uint32): uint32
[ 291.26]           > fib(n: uint32): uint32
[ 291.27]            > fib(n: uint32): uint32
[ 291.29]            < return
[ 291.30]            > fib(n: uint32): uint32
[ 291.31]            < return
[ 291.32]           < return
[ 291.33]           > fib(n: uint32): uint32
[ 291.35]           < return
[ 291.36]          < return
[ 291.37]          > fib(n: uint32): uint32
[ 291.38]           > fib(n: uint32): uint32
[ 291.40]           < return
[ 291.41]           > fib(n: uint32): uint32
[ 291.42]           < return
[ 291.43]          < return
[ 291.44]         < return
[ 291.45]        < return
[ 291.46]        > fib(n: uint32): uint32
[ 291.48]         > fib(n: uint32): uint32
[ 291.50]          > fib(n: uint32): uint32
[ 291.51]           > fib(n: uint32): uint32
[ 291.52]            > fib(n: uint32): uint32
[ 291.54]            < return
[ 291.55]            > fib(n: uint32): uint32
[ 291.56]            < return
[ 291.57]           < return
[ 291.58]           > fib(n: uint32): uint32
[ 291.60]           < return
[ 291.61]          < return
[ 291.62]          > fib(n: uint32): uint32
[ 291.64]           > fib(n: uint32): uint32
[ 291.66]           < return
[ 291.67]           > fib(n: uint32): uint32
[ 291.68]           < return
[ 291.69]          < return
[ 291.70]         < return
[ 291.71]         > fib(n: uint32): uint32
[ 291.73]          > fib(n: uint32): uint32
[ 291.74]           > fib(n: uint32): uint32
[ 291.76]           < return
[ 291.77]           > fib(n: uint32): uint32
[ 291.78]           < return
[ 291.79]          < return
[ 291.80]          > fib(n: uint32): uint32
[ 291.82]          < return
[ 291.83]         < return
[ 291.84]        < return
[ 291.85]       < return
[ 291.86]      < return
[ 291.87]      > fib(n: uint32): uint32
[ 291.88]       > fib(n: uint32): uint32
[ 291.90]        > fib(n: uint32): uint32
[ 291.91]         > fib(n: uint32): uint32
[ 291.93]          > fib(n: uint32): uint32
[ 291.94]           > fib(n: uint32): uint32
[ 291.96]            > fib(n: uint32): uint32
[ 291.97]             > fib(n: uint32): uint32
[ 291.98]             < return
[ 292.00]             > fib(n: uint32): uint32
[ 292.01]             < return
[ 292.02]            < return
[ 292.03]            > fib(n: uint32): uint32
[ 292.05]            < return
[ 292.06]           < return
[ 292.07]           > fib(n: uint32): uint32
[ 292.08]            > fib(n: uint32): uint32
[ 292.10]            < return
[ 292.11]            > fib(n: uint32): uint32
[ 292.12]            < return
[ 292.13]           < return
[ 292.14]          < return
[ 292.15]          > fib(n: uint32): uint32
[ 292.17]           > fib(n: uint32): uint32
[ 292.18]            > fib(n: uint32): uint32
[ 292.20]            < return
[ 292.21]            > fib(n: uint32): uint32
[ 292.22]            < return
[ 292.23]           < return
[ 292.24]           > fib(n: uint32): uint32
[ 292.25]           < return
[ 292.27]          < return
[ 292.28]         < return
[ 292.29]         > fib(n: uint32): uint32
[ 292.30]          > fib(n: uint32): uint32
[ 292.32]           > fib(n: uint32): uint32
[ 292.33]            > fib(n: uint32): uint32
[ 292.35]            < return
[ 292.36]            > fib(n: uint32): uint32
[ 292.37]            < return
[ 292.38]           < return
[ 292.39]           > fib(n: uint32): uint32
[ 292.41]           < return
[ 292.42]          < return
[ 292.43]          > fib(n: uint32): uint32
[ 292.44]           > fib(n: uint32): uint32
[ 292.46]           < return
[ 292.47]           > fib(n: uint32): uint32
[ 292.48]           < return
[ 292.49]          < return
[ 292.50]         < return
[ 292.51]        < return
[ 292.52]        > fib(n: uint32): uint32
[ 292.54]         > fib(n: uint32): uint32
[ 292.55]          > fib(n: uint32): uint32
[ 292.57]           > fib(n: uint32): uint32
[ 292.58]            > fib(n: uint32): uint32
[ 292.60]            < return
[ 292.63]            > fib(n: uint32): uint32
[ 292.65]            < return
[ 292.66]           < return
[ 292.67]           > fib(n: uint32): uint32
[ 292.68]           < return
[ 292.69]          < return
[ 292.71]          > fib(n: uint32): uint32
[ 292.72]           > fib(n: uint32): uint32
[ 292.73]           < return
[ 292.75]           > fib(n: uint32): uint32
[ 292.76]           < return
[ 292.77]          < return
[ 292.78]         < return
[ 292.79]         > fib(n: uint32): uint32
[ 292.81]          > fib(n: uint32): uint32
[ 292.82]           > fib(n: uint32): uint32
[ 292.83]           < return
[ 292.85]           > fib(n: uint32): uint32
[ 292.86]           < return
[ 292.87]          < return
[ 292.88]          > fib(n: uint32): uint32
[ 292.89]          < return
[ 292.90]         < return
[ 292.91]        < return
[ 292.92]       < return
[ 292.93]       > fib(n: uint32): uint32
[ 292.95]        > fib(n: uint32): uint32
[ 292.97]         > fib(n: uint32): uint32
[ 292.98]          > fib(n: uint32): uint32
[ 293.00]           > fib(n: uint32): uint32
[ 293.01]            > fib(n: uint32): uint32
[ 293.03]            < return
[ 293.04]            > fib(n: uint32): uint32
[ 293.05]            < return
[ 293.06]           < return
[ 293.07]           > fib(n: uint32): uint32
[ 293.09]           < return
[ 293.11]          < return
[ 293.12]          > fib(n: uint32): uint32
[ 293.13]           > fib(n: uint32): uint32
[ 293.14]           < return
[ 293.16]           > fib(n: uint32): uint32
[ 293.17]           < return
[ 293.18]          < return
[ 293.19]         < return
[ 293.20]         > fib(n: uint32): uint32
[ 293.22]          > fib(n: uint32): uint32
[ 293.23]           > fib(n: uint32): uint32
[ 293.25]           < return
[ 293.26]           > fib(n: uint32): uint32
[ 293.27]           < return
[ 293.28]          < return
[ 293.29]          > fib(n: uint32): uint32
[ 293.31]          < return
[ 293.32]         < return
[ 293.33]        < return
[ 293.34]        > fib(n: uint32): uint32
[ 293.35]         > fib(n: uint32): uint32
[ 293.37]          > fib(n: uint32): uint32
[ 293.38]           > fib(n: uint32): uint32
[ 293.39]           < return
[ 293.41]           > fib(n: uint32): uint32
[ 293.42]           < return
[ 293.43]          < return
[ 293.44]          > fib(n: uint32): uint32
[ 293.45]          < return
[ 293.47]         < return
[ 293.48]         > fib(n: uint32): uint32
[ 293.49]          > fib(n: uint32): uint32
[ 293.51]          < return
[ 293.52]          > fib(n: uint32): uint32
[ 293.53]          < return
[ 293.54]         < return
[ 293.55]        < return
[ 293.56]       < return
[ 293.57]      < return
[ 293.58]     < return
[ 293.59]     > fib(n: uint32): uint32
[ 293.61]      > fib(n: uint32): uint32
[ 293.62]       > fib(n: uint32): uint32
[ 293.64]        > fib(n: uint32): uint32
[ 293.65]         > fib(n: uint32): uint32
[ 293.67]          > fib(n: uint32): uint32
[ 293.68]           > fib(n: uint32): uint32
[ 293.70]            > fib(n: uint32): uint32
[ 293.71]             > fib(n: uint32): uint32
[ 293.73]             < return
[ 293.74]             > fib(n: uint32): uint32
[ 293.75]             < return
[ 293.76]            < return
[ 293.77]            > fib(n: uint32): uint32
[ 293.79]            < return
[ 293.80]           < return
[ 293.81]           > fib(n: uint32): uint32
[ 293.82]            > fib(n: uint32): uint32
[ 293.84]            < return
[ 293.85]            > fib(n: uint32): uint32
[ 293.86]            < return
[ 293.87]           < return
[ 293.88]          < return
[ 293.90]          > fib(n: uint32): uint32
[ 293.92]           > fib(n: uint32): uint32
[ 293.93]            > fib(n: uint32): uint32
[ 293.94]            < return
[ 293.96]            > fib(n: uint32): uint32
[ 293.97]            < return
[ 293.98]           < return
[ 293.99]           > fib(n: uint32): uint32
[ 294.01]           < return
[ 294.02]          < return
[ 294.03]         < return
[ 294.04]         > fib(n: uint32): uint32
[ 294.05]          > fib(n: uint32): uint32
[ 294.07]           > fib(n: uint32): uint32
[ 294.08]            > fib(n: uint32): uint32
[ 294.10]            < return
[ 294.11]            > fib(n: uint32): uint32
[ 294.12]            < return
[ 294.13]           < return
[ 294.14]           > fib(n: uint32): uint32
[ 294.16]           < return
[ 294.17]          < return
[ 294.18]          > fib(n: uint32): uint32
[ 294.19]           > fib(n: uint32): uint32
[ 294.21]           < return
[ 294.22]           > fib(n: uint32): uint32
[ 294.23]           < return
[ 294.24]          < return
[ 294.25]         < return
[ 294.26]        < return
[ 294.27]        > fib(n: uint32): uint32
[ 294.29]         > fib(n: uint32): uint32
[ 294.30]          > fib(n: uint32): uint32
[ 294.32]           > fib(n: uint32): uint32
[ 294.33]            > fib(n: uint32): uint32
[ 294.35]            < return
[ 294.36]            > fib(n: uint32): uint32
[ 294.37]            < return
[ 294.38]           < return
[ 294.39]           > fib(n: uint32): uint32
[ 294.41]           < return
[ 294.42]          < return
[ 294.43]          > fib(n: uint32): uint32
[ 294.44]           > fib(n: uint32): uint32
[ 294.46]           < return
[ 294.47]           > fib(n: uint32): uint32
[ 294.48]           < return
[ 294.49]          < return
[ 294.50]         < return
[ 294.52]         > fib(n: uint32): uint32
[ 294.53]          > fib(n: uint32): uint32
[ 294.55]           > fib(n: uint32): uint32
[ 294.56]           < return
[ 294.57]           > fib(n: uint32): uint32
[ 294.59]           < return
[ 294.60]          < return
[ 294.61]          > fib(n: uint32): uint32
[ 294.62]          < return
[ 294.63]         < return
[ 294.64]        < return
[ 294.65]       < return
[ 294.66]       > fib(n: uint32): uint32
[ 294.68]        > fib(n: uint32): uint32
[ 294.69]         > fib(n: uint32): uint32
[ 294.71]          > fib(n: uint32): uint32
[ 294.72]           > fib(n: uint32): uint32
[ 294.74]            > fib(n: uint32): uint32
[ 294.75]            < return
[ 294.76]            > fib(n: uint32): uint32
[ 294.77]            < return
[ 294.79]           < return
[ 294.80]           > fib(n: uint32): uint32
[ 294.81]           < return
[ 294.82]          < return
[ 294.83]          > fib(n: uint32): uint32
[ 294.85]           > fib(n: uint32): uint32
[ 294.86]           < return
[ 294.87]           > fib(n: uint32): uint32
[ 294.88]           < return
[ 294.90]          < return
[ 294.91]         < return
[ 294.92]         > fib(n: uint32): uint32
[ 294.93]          > fib(n: uint32): uint32
[ 294.95]           > fib(n: uint32): uint32
[ 294.96]           < return
[ 294.97]           > fib(n: uint32): uint32
[ 294.99]           < return
[ 295.00]          < return
[ 295.01]          > fib(n: uint32): uint32
[ 295.02]          < return
[ 295.03]         < return
[ 295.04]        < return
[ 295.05]        > fib(n: uint32): uint32
[ 295.06]         > fib(n: uint32): uint32
[ 295.08]          > fib(n: uint32): uint32
[ 295.10]           > fib(n: uint32): uint32
[ 295.11]           < return
[ 295.12]           > fib(n: uint32): uint32
[ 295.13]           < return
[ 295.14]          < return
[ 295.15]          > fib(n: uint32): uint32
[ 295.17]          < return
[ 295.18]         < return
[ 295.19]         > fib(n: uint32): uint32
[ 295.20]          > fib(n: uint32): uint32
[ 295.22]          < return
[ 295.23]          > fib(n: uint32): uint32
[ 295.25]          < return
[ 295.26]         < return
[ 295.27]        < return
[ 295.27]       < return
[ 295.29]      < return
[ 295.30]      > fib(n: uint32): uint32
[ 295.31]       > fib(n: uint32): uint32
[ 295.33]        > fib(n: uint32): uint32
[ 295.34]         > fib(n: uint32): uint32
[ 295.36]          > fib(n: uint32): uint32
[ 295.37]           > fib(n: uint32): uint32
[ 295.38]            > fib(n: uint32): uint32
[ 295.40]            < return
[ 295.41]            > fib(n: uint32): uint32
[ 295.42]            < return
[ 295.43]           < return
[ 295.44]           > fib(n: uint32): uint32
[ 295.46]           < return
[ 295.47]          < return
[ 295.48]          > fib(n: uint32): uint32
[ 295.50]           > fib(n: uint32): uint32
[ 295.51]           < return
[ 295.52]           > fib(n: uint32): uint32
[ 295.54]           < return
[ 295.55]          < return
[ 295.56]         < return
[ 295.57]         > fib(n: uint32): uint32
[ 295.58]          > fib(n: uint32): uint32
[ 295.60]           > fib(n: uint32): uint32
[ 295.61]           < return
[ 295.62]           > fib(n: uint32): uint32
[ 295.63]           < return
[ 295.65]          < return
[ 295.66]          > fib(n: uint32): uint32
[ 295.67]          < return
[ 295.68]         < return
[ 295.69]        < return
[ 295.70]        > fib(n: uint32): uint32
[ 295.72]         > fib(n: uint32): uint32
[ 295.73]          > fib(n: uint32): uint32
[ 295.75]           > fib(n: uint32): uint32
[ 295.76]           < return
[ 295.77]           > fib(n: uint32): uint32
[ 295.79]           < return
[ 295.80]          < return
[ 295.81]          > fib(n: uint32): uint32
[ 295.82]          < return
[ 295.83]         < return
[ 295.84]         > fib(n: uint32): uint32
[ 295.86]          > fib(n: uint32): uint32
[ 295.87]          < return
[ 295.88]          > fib(n: uint32): uint32
[ 295.90]          < return
[ 295.91]         < return
[ 295.92]        < return
[ 295.93]       < return
[ 295.94]       > fib(n: uint32): uint32
[ 295.96]        > fib(n: uint32): uint32
[ 295.97]         > fib(n: uint32): uint32
[ 295.99]          > fib(n: uint32): uint32
[ 296.00]           > fib(n: uint32): uint32
[ 296.02]           < return
[ 296.03]           > fib(n: uint32): uint32
[ 296.04]           < return
[ 296.05]          < return
[ 296.06]          > fib(n: uint32): uint32
[ 296.10]          < return
[ 296.11]         < return
[ 296.12]         > fib(n: uint32): uint32
[ 296.15]          > fib(n: uint32): uint32
[ 296.18]          < return
[ 296.19]          > fib(n: uint32): uint32
[ 296.21]          < return
[ 296.23]         < return
[ 296.24]        < return
[ 296.25]        > fib(n: uint32): uint32
[ 296.26]         > fib(n: uint32): uint32
[ 296.28]          > fib(n: uint32): uint32
[ 296.29]          < return
[ 296.31]          > fib(n: uint32): uint32
[ 296.32]          < return
[ 296.33]         < return
[ 296.34]         > fib(n: uint32): uint32
[ 296.36]         < return
[ 296.37]        < return
[ 296.38]       < return
[ 296.39]      < return
[ 296.40]     < return
[ 296.41]    < return
[ 296.42]    > fib(n: uint32): uint32
[ 296.43]     > fib(n: uint32): uint32
[ 296.45]      > fib(n: uint32): uint32
[ 296.46]       > fib(n: uint32): uint32
[ 296.48]        > fib(n: uint32): uint32
[ 296.49]         > fib(n: uint32): uint32
[ 296.51]          > fib(n: uint32): uint32
[ 296.52]           > fib(n: uint32): uint32
[ 296.54]            > fib(n: uint32): uint32
[ 296.55]             > fib(n: uint32): uint32
[ 296.56]             < return
[ 296.58]             > fib(n: uint32): uint32
[ 296.59]             < return
[ 296.60]            < return
[ 296.61]            > fib(n: uint32): uint32
[ 296.62]            < return
[ 296.64]           < return
[ 296.65]           > fib(n: uint32): uint32
[ 296.66]            > fib(n: uint32): uint32
[ 296.68]            < return
[ 296.69]            > fib(n: uint32): uint32
[ 296.70]            < return
[ 296.71]           < return
[ 296.72]          < return
[ 296.73]          > fib(n: uint32): uint32
[ 296.75]           > fib(n: uint32): uint32
[ 296.76]            > fib(n: uint32): uint32
[ 296.78]            < return
[ 296.79]            > fib(n: uint32): uint32
[ 296.80]            < return
[ 296.81]           < return
[ 296.82]           > fib(n: uint32): uint32
[ 296.84]           < return
[ 296.85]          < return
[ 296.86]         < return
[ 296.87]         > fib(n: uint32): uint32
[ 296.88]          > fib(n: uint32): uint32
[ 296.90]           > fib(n: uint32): uint32
[ 296.91]            > fib(n: uint32): uint32
[ 296.93]            < return
[ 296.94]            > fib(n: uint32): uint32
[ 296.95]            < return
[ 296.96]           < return
[ 296.97]           > fib(n: uint32): uint32
[ 296.99]           < return
[ 297.00]          < return
[ 297.01]          > fib(n: uint32): uint32
[ 297.02]           > fib(n: uint32): uint32
[ 297.04]           < return
[ 297.05]           > fib(n: uint32): uint32
[ 297.06]           < return
[ 297.07]          < return
[ 297.08]         < return
[ 297.09]        < return
[ 297.10]        > fib(n: uint32): uint32
[ 297.12]         > fib(n: uint32): uint32
[ 297.13]          > fib(n: uint32): uint32
[ 297.15]           > fib(n: uint32): uint32
[ 297.16]            > fib(n: uint32): uint32
[ 297.17]            < return
[ 297.19]            > fib(n: uint32): uint32
[ 297.20]            < return
[ 297.21]           < return
[ 297.22]           > fib(n: uint32): uint32
[ 297.23]           < return
[ 297.24]          < return
[ 297.25]          > fib(n: uint32): uint32
[ 297.27]           > fib(n: uint32): uint32
[ 297.28]           < return
[ 297.29]           > fib(n: uint32): uint32
[ 297.31]           < return
[ 297.32]          < return
[ 297.33]         < return
[ 297.34]         > fib(n: uint32): uint32
[ 297.35]          > fib(n: uint32): uint32
[ 297.37]           > fib(n: uint32): uint32
[ 297.38]           < return
[ 297.39]           > fib(n: uint32): uint32
[ 297.41]           < return
[ 297.42]          < return
[ 297.43]          > fib(n: uint32): uint32
[ 297.45]          < return
[ 297.46]         < return
[ 297.47]        < return
[ 297.48]       < return
[ 297.49]       > fib(n: uint32): uint32
[ 297.50]        > fib(n: uint32): uint32
[ 297.52]         > fib(n: uint32): uint32
[ 297.54]          > fib(n: uint32): uint32
[ 297.55]           > fib(n: uint32): uint32
[ 297.56]            > fib(n: uint32): uint32
[ 297.58]            < return
[ 297.59]            > fib(n: uint32): uint32
[ 297.60]            < return
[ 297.61]           < return
[ 297.62]           > fib(n: uint32): uint32
[ 297.64]           < return
[ 297.65]          < return
[ 297.66]          > fib(n: uint32): uint32
[ 297.68]           > fib(n: uint32): uint32
[ 297.69]           < return
[ 297.70]           > fib(n: uint32): uint32
[ 297.71]           < return
[ 297.72]          < return
[ 297.73]         < return
[ 297.74]         > fib(n: uint32): uint32
[ 297.76]          > fib(n: uint32): uint32
[ 297.77]           > fib(n: uint32): uint32
[ 297.79]           < return
[ 297.80]           > fib(n: uint32): uint32
[ 297.81]           < return
[ 297.82]          < return
[ 297.83]          > fib(n: uint32): uint32
[ 297.85]          < return
[ 297.86]         < return
[ 297.87]        < return
[ 297.89]        > fib(n: uint32): uint32
[ 297.90]         > fib(n: uint32): uint32
[ 297.92]          > fib(n: uint32): uint32
[ 297.93]           > fib(n: uint32): uint32
[ 297.95]           < return
[ 297.96]           > fib(n: uint32): uint32
[ 297.97]           < return
[ 297.98]          < return
[ 297.99]          > fib(n: uint32): uint32
[ 298.00]          < return
[ 298.02]         < return
[ 298.03]         > fib(n: uint32): uint32
[ 298.04]          > fib(n: uint32): uint32
[ 298.05]          < return
[ 298.06]          > fib(n: uint32): uint32
[ 298.08]          < return
[ 298.09]         < return
[ 298.10]        < return
[ 298.11]       < return
[ 298.12]      < return
[ 298.13]      > fib(n: uint32): uint32
[ 298.15]       > fib(n: uint32): uint32
[ 298.16]        > fib(n: uint32): uint32
[ 298.17]         > fib(n: uint32): uint32
[ 298.19]          > fib(n: uint32): uint32
[ 298.20]           > fib(n: uint32): uint32
[ 298.22]            > fib(n: uint32): uint32
[ 298.23]            < return
[ 298.24]            > fib(n: uint32): uint32
[ 298.26]            < return
[ 298.27]           < return
[ 298.28]           > fib(n: uint32): uint32
[ 298.29]           < return
[ 298.30]          < return
[ 298.31]          > fib(n: uint32): uint32
[ 298.33]           > fib(n: uint32): uint32
[ 298.34]           < return
[ 298.36]           > fib(n: uint32): uint32
[ 298.37]           < return
[ 298.38]          < return
[ 298.39]         < return
[ 298.40]         > fib(n: uint32): uint32
[ 298.42]          > fib(n: uint32): uint32
[ 298.43]           > fib(n: uint32): uint32
[ 298.44]           < return
[ 298.46]           > fib(n: uint32): uint32
[ 298.47]           < return
[ 298.48]          < return
[ 298.49]          > fib(n: uint32): uint32
[ 298.50]          < return
[ 298.51]         < return
[ 298.52]        < return
[ 298.54]        > fib(n: uint32): uint32
[ 298.55]         > fib(n: uint32): uint32
[ 298.56]          > fib(n: uint32): uint32
[ 298.58]           > fib(n: uint32): uint32
[ 298.59]           < return
[ 298.61]           > fib(n: uint32): uint32
[ 298.62]           < return
[ 298.63]          < return
[ 298.64]          > fib(n: uint32): uint32
[ 298.65]          < return
[ 298.66]         < return
[ 298.68]         > fib(n: uint32): uint32
[ 298.69]          > fib(n: uint32): uint32
[ 298.70]          < return
[ 298.71]          > fib(n: uint32): uint32
[ 298.73]          < return
[ 298.74]         < return
[ 298.75]        < return
[ 298.76]       < return
[ 298.77]       > fib(n: uint32): uint32
[ 298.79]        > fib(n: uint32): uint32
[ 298.80]         > fib(n: uint32): uint32
[ 298.81]          > fib(n: uint32): uint32
[ 298.83]           > fib(n: uint32): uint32
[ 298.84]           < return
[ 298.86]           > fib(n: uint32): uint32
[ 298.87]           < return
[ 298.88]          < return
[ 298.90]          > fib(n: uint32): uint32
[ 298.91]          < return
[ 298.92]         < return
[ 298.93]         > fib(n: uint32): uint32
[ 298.95]          > fib(n: uint32): uint32
[ 298.96]          < return
[ 298.97]          > fib(n: uint32): uint32
[ 298.99]          < return
[ 299.00]         < return
[ 299.00]        < return
[ 299.01]        > fib(n: uint32): uint32
[ 299.03]         > fib(n: uint32): uint32
[ 299.05]          > fib(n: uint32): uint32
[ 299.06]          < return
[ 299.07]          > fib(n: uint32): uint32
[ 299.08]          < return
[ 299.09]         < return
[ 299.11]         > fib(n: uint32): uint32
[ 299.12]         < return
[ 299.13]        < return
[ 299.14]       < return
[ 299.15]      < return
[ 299.16]     < return
[ 299.17]     > fib(n: uint32): uint32
[ 299.19]      > fib(n: uint32): uint32
[ 299.20]       > fib(n: uint32): uint32
[ 299.22]        > fib(n: uint32): uint32
[ 299.23]         > fib(n: uint32): uint32
[ 299.25]          > fib(n: uint32): uint32
[ 299.26]           > fib(n: uint32): uint32
[ 299.27]            > fib(n: uint32): uint32
[ 299.29]            < return
[ 299.30]            > fib(n: uint32): uint32
[ 299.31]            < return
[ 299.32]           < return
[ 299.33]           > fib(n: uint32): uint32
[ 299.35]           < return
[ 299.36]          < return
[ 299.37]          > fib(n: uint32): uint32
[ 299.38]           > fib(n: uint32): uint32
[ 299.40]           < return
[ 299.41]           > fib(n: uint32): uint32
[ 299.42]           < return
[ 299.43]          < return
[ 299.44]         < return
[ 299.45]         > fib(n: uint32): uint32
[ 299.47]          > fib(n: uint32): uint32
[ 299.48]           > fib(n: uint32): uint32
[ 299.50]           < return
[ 299.51]           > fib(n: uint32): uint32
[ 299.52]           < return
[ 299.53]          < return
[ 299.55]          > fib(n: uint32): uint32
[ 299.56]          < return
[ 299.57]         < return
[ 299.58]        < return
[ 299.59]        > fib(n: uint32): uint32
[ 299.61]         > fib(n: uint32): uint32
[ 299.62]          > fib(n: uint32): uint32
[ 299.63]           > fib(n: uint32): uint32
[ 299.65]           < return
[ 299.66]           > fib(n: uint32): uint32
[ 299.67]           < return
[ 299.68]          < return
[ 299.69]          > fib(n: uint32): uint32
[ 299.71]          < return
[ 299.72]         < return
[ 299.73]         > fib(n: uint32): uint32
[ 299.74]          > fib(n: uint32): uint32
[ 299.76]          < return
[ 299.77]          > fib(n: uint32): uint32
[ 299.78]          < return
[ 299.79]         < return
[ 299.80]        < return
[ 299.81]       < return
[ 299.82]       > fib(n: uint32): uint32
[ 299.84]        > fib(n: uint32): uint32
[ 299.85]         > fib(n: uint32): uint32
[ 299.87]          > fib(n: uint32): uint32
[ 299.88]           > fib(n: uint32): uint32
[ 299.89]           < return
[ 299.91]           > fib(n: uint32): uint32
[ 299.92]           < return
[ 299.93]          < return
[ 299.94]          > fib(n: uint32): uint32
[ 299.95]          < return
[ 299.97]         < return
[ 299.98]         > fib(n: uint32): uint32
[ 299.99]          > fib(n: uint32): uint32
[ 300.00]          < return
[ 300.01]          > fib(n: uint32): uint32
[ 300.03]          < return
[ 300.04]         < return
[ 300.05]        < return
[ 300.06]        > fib(n: uint32): uint32
[ 300.08]         > fib(n: uint32): uint32
[ 300.09]          > fib(n: uint32): uint32
[ 300.10]          < return
[ 300.12]          > fib(n: uint32): uint32
[ 300.13]          < return
[ 300.14]         < return
[ 300.15]         > fib(n: uint32): uint32
[ 300.17]         < return
[ 300.18]        < return
[ 300.19]       < return
[ 300.19]      < return
[ 300.20]      > fib(n: uint32): uint32
[ 300.22]       > fib(n: uint32): uint32
[ 300.24]        > fib(n: uint32): uint32
[ 300.25]         > fib(n: uint32): uint32
[ 300.26]          > fib(n: uint32): uint32
[ 300.28]           > fib(n: uint32): uint32
[ 300.29]           < return
[ 300.31]           > fib(n: uint32): uint32
[ 300.32]           < return
[ 300.34]          < return
[ 300.35]          > fib(n: uint32): uint32
[ 300.36]          < return
[ 300.37]         < return
[ 300.38]         > fib(n: uint32): uint32
[ 300.40]          > fib(n: uint32): uint32
[ 300.41]          < return
[ 300.42]          > fib(n: uint32): uint32
[ 300.44]          < return
[ 300.44]         < return
[ 300.45]        < return
[ 300.47]        > fib(n: uint32): uint32
[ 300.48]         > fib(n: uint32): uint32
[ 300.50]          > fib(n: uint32): uint32
[ 300.51]          < return
[ 300.52]          > fib(n: uint32): uint32
[ 300.54]          < return
[ 300.55]         < return
[ 300.56]         > fib(n: uint32): uint32
[ 300.57]         < return
[ 300.58]        < return
[ 300.59]       < return
[ 300.60]       > fib(n: uint32): uint32
[ 300.62]        > fib(n: uint32): uint32
[ 300.63]         > fib(n: uint32): uint32
[ 300.65]          > fib(n: uint32): uint32
[ 300.66]          < return
[ 300.67]          > fib(n: uint32): uint32
[ 300.68]          < return
[ 300.69]         < return
[ 300.70]         > fib(n: uint32): uint32
[ 300.72]         < return
[ 300.73]        < return
[ 300.74]        > fib(n: uint32): uint32
[ 300.75]         > fib(n: uint32): uint32
[ 300.77]         < return
[ 300.78]         > fib(n: uint32): uint32
[ 300.80]         < return
[ 300.81]        < return
[ 300.81]       < return
[ 300.82]      < return
[ 300.83]     < return
[ 300.85]    < return
[ 300.85]   < return
[ 300.87]   > fib(n: uint32): uint32
[ 300.88]    > fib(n: uint32): uint32
[ 300.89]     > fib(n: uint32): uint32
[ 300.91]      > fib(n: uint32): uint32
[ 300.92]       > fib(n: uint32): uint32
[ 300.94]        > fib(n: uint32): uint32
[ 300.95]         > fib(n: uint32): uint32
[ 300.97]          > fib(n: uint32): uint32
[ 300.98]           > fib(n: uint32): uint32
[ 301.00]            > fib(n: uint32): uint32
[ 301.01]             > fib(n: uint32): uint32
[ 301.03]             < return
[ 301.04]             > fib(n: uint32): uint32
[ 301.05]             < return
[ 301.06]            < return
[ 301.07]            > fib(n: uint32): uint32
[ 301.09]            < return
[ 301.10]           < return
[ 301.11]           > fib(n: uint32): uint32
[ 301.12]            > fib(n: uint32): uint32
[ 301.14]            < return
[ 301.15]            > fib(n: uint32): uint32
[ 301.16]            < return
[ 301.18]           < return
[ 301.19]          < return
[ 301.19]          > fib(n: uint32): uint32
[ 301.21]           > fib(n: uint32): uint32
[ 301.23]            > fib(n: uint32): uint32
[ 301.24]            < return
[ 301.25]            > fib(n: uint32): uint32
[ 301.26]            < return
[ 301.28]           < return
[ 301.29]           > fib(n: uint32): uint32
[ 301.30]           < return
[ 301.31]          < return
[ 301.32]         < return
[ 301.33]         > fib(n: uint32): uint32
[ 301.35]          > fib(n: uint32): uint32
[ 301.36]           > fib(n: uint32): uint32
[ 301.38]            > fib(n: uint32): uint32
[ 301.39]            < return
[ 301.40]            > fib(n: uint32): uint32
[ 301.42]            < return
[ 301.43]           < return
[ 301.44]           > fib(n: uint32): uint32
[ 301.45]           < return
[ 301.46]          < return
[ 301.47]          > fib(n: uint32): uint32
[ 301.49]           > fib(n: uint32): uint32
[ 301.50]           < return
[ 301.51]           > fib(n: uint32): uint32
[ 301.53]           < return
[ 301.54]          < return
[ 301.55]         < return
[ 301.56]        < return
[ 301.57]        > fib(n: uint32): uint32
[ 301.58]         > fib(n: uint32): uint32
[ 301.60]          > fib(n: uint32): uint32
[ 301.61]           > fib(n: uint32): uint32
[ 301.63]            > fib(n: uint32): uint32
[ 301.64]            < return
[ 301.65]            > fib(n: uint32): uint32
[ 301.67]            < return
[ 301.68]           < return
[ 301.69]           > fib(n: uint32): uint32
[ 301.70]           < return
[ 301.71]          < return
[ 301.72]          > fib(n: uint32): uint32
[ 301.74]           > fib(n: uint32): uint32
[ 301.76]           < return
[ 301.77]           > fib(n: uint32): uint32
[ 301.78]           < return
[ 301.79]          < return
[ 301.80]         < return
[ 301.81]         > fib(n: uint32): uint32
[ 301.83]          > fib(n: uint32): uint32
[ 301.84]           > fib(n: uint32): uint32
[ 301.86]           < return
[ 301.87]           > fib(n: uint32): uint32
[ 301.89]           < return
[ 301.90]          < return
[ 301.93]          > fib(n: uint32): uint32
[ 301.95]          < return
[ 301.96]         < return
[ 301.97]        < return
[ 301.98]       < return
[ 301.99]       > fib(n: uint32): uint32
[ 302.01]        > fib(n: uint32): uint32
[ 302.02]         > fib(n: uint32): uint32
[ 302.04]          > fib(n: uint32): uint32
[ 302.05]           > fib(n: uint32): uint32
[ 302.07]            > fib(n: uint32): uint32
[ 302.08]            < return
[ 302.09]            > fib(n: uint32): uint32
[ 302.11]            < return
[ 302.12]           < return
[ 302.13]           > fib(n: uint32): uint32
[ 302.14]           < return
[ 302.15]          < return
[ 302.16]          > fib(n: uint32): uint32
[ 302.18]           > fib(n: uint32): uint32
[ 302.19]           < return
[ 302.20]           > fib(n: uint32): uint32
[ 302.21]           < return
[ 302.23]          < return
[ 302.24]         < return
[ 302.25]         > fib(n: uint32): uint32
[ 302.26]          > fib(n: uint32): uint32
[ 302.28]           > fib(n: uint32): uint32
[ 302.29]           < return
[ 302.30]           > fib(n: uint32): uint32
[ 302.31]           < return
[ 302.32]          < return
[ 302.34]          > fib(n: uint32): uint32
[ 302.35]          < return
[ 302.36]         < return
[ 302.37]        < return
[ 302.38]        > fib(n: uint32): uint32
[ 302.40]         > fib(n: uint32): uint32
[ 302.41]          > fib(n: uint32): uint32
[ 302.43]           > fib(n: uint32): uint32
[ 302.44]           < return
[ 302.45]           > fib(n: uint32): uint32
[ 302.46]           < return
[ 302.48]          < return
[ 302.49]          > fib(n: uint32): uint32
[ 302.50]          < return
[ 302.51]         < return
[ 302.52]         > fib(n: uint32): uint32
[ 302.54]          > fib(n: uint32): uint32
[ 302.55]          < return
[ 302.56]          > fib(n: uint32): uint32
[ 302.57]          < return
[ 302.58]         < return
[ 302.59]        < return
[ 302.60]       < return
[ 302.61]      < return
[ 302.62]      > fib(n: uint32): uint32
[ 302.64]       > fib(n: uint32): uint32
[ 302.65]        > fib(n: uint32): uint32
[ 302.67]         > fib(n: uint32): uint32
[ 302.68]          > fib(n: uint32): uint32
[ 302.70]           > fib(n: uint32): uint32
[ 302.71]            > fib(n: uint32): uint32
[ 302.73]            < return
[ 302.74]            > fib(n: uint32): uint32
[ 302.75]            < return
[ 302.76]           < return
[ 302.77]           > fib(n: uint32): uint32
[ 302.79]           < return
[ 302.80]          < return
[ 302.81]          > fib(n: uint32): uint32
[ 302.82]           > fib(n: uint32): uint32
[ 302.84]           < return
[ 302.85]           > fib(n: uint32): uint32
[ 302.86]           < return
[ 302.87]          < return
[ 302.88]         < return
[ 302.89]         > fib(n: uint32): uint32
[ 302.91]          > fib(n: uint32): uint32
[ 302.92]           > fib(n: uint32): uint32
[ 302.94]           < return
[ 302.95]           > fib(n: uint32): uint32
[ 302.96]           < return
[ 302.97]          < return
[ 302.98]          > fib(n: uint32): uint32
[ 303.00]          < return
[ 303.01]         < return
[ 303.02]        < return
[ 303.03]        > fib(n: uint32): uint32
[ 303.04]         > fib(n: uint32): uint32
[ 303.06]          > fib(n: uint32): uint32
[ 303.07]           > fib(n: uint32): uint32
[ 303.08]           < return
[ 303.10]           > fib(n: uint32): uint32
[ 303.11]           < return
[ 303.12]          < return
[ 303.13]          > fib(n: uint32): uint32
[ 303.14]          < return
[ 303.15]         < return
[ 303.16]         > fib(n: uint32): uint32
[ 303.18]          > fib(n: uint32): uint32
[ 303.20]          < return
[ 303.21]          > fib(n: uint32): uint32
[ 303.23]          < return
[ 303.24]         < return
[ 303.25]        < return
[ 303.26]       < return
[ 303.27]       > fib(n: uint32): uint32
[ 303.28]        > fib(n: uint32): uint32
[ 303.30]         > fib(n: uint32): uint32
[ 303.31]          > fib(n: uint32): uint32
[ 303.33]           > fib(n: uint32): uint32
[ 303.34]           < return
[ 303.35]           > fib(n: uint32): uint32
[ 303.37]           < return
[ 303.38]          < return
[ 303.39]          > fib(n: uint32): uint32
[ 303.40]          < return
[ 303.41]         < return
[ 303.42]         > fib(n: uint32): uint32
[ 303.44]          > fib(n: uint32): uint32
[ 303.45]          < return
[ 303.46]          > fib(n: uint32): uint32
[ 303.48]          < return
[ 303.49]         < return
[ 303.50]        < return
[ 303.50]        > fib(n: uint32): uint32
[ 303.52]         > fib(n: uint32): uint32
[ 303.54]          > fib(n: uint32): uint32
[ 303.55]          < return
[ 303.56]          > fib(n: uint32): uint32
[ 303.57]          < return
[ 303.58]         < return
[ 303.60]         > fib(n: uint32): uint32
[ 303.61]         < return
[ 303.62]        < return
[ 303.63]       < return
[ 303.64]      < return
[ 303.65]     < return
[ 303.66]     > fib(n: uint32): uint32
[ 303.67]      > fib(n: uint32): uint32
[ 303.69]       > fib(n: uint32): uint32
[ 303.70]        > fib(n: uint32): uint32
[ 303.72]         > fib(n: uint32): uint32
[ 303.73]          > fib(n: uint32): uint32
[ 303.75]           > fib(n: uint32): uint32
[ 303.76]            > fib(n: uint32): uint32
[ 303.78]            < return
[ 303.79]            > fib(n: uint32): uint32
[ 303.80]            < return
[ 303.81]           < return
[ 303.82]           > fib(n: uint32): uint32
[ 303.84]           < return
[ 303.85]          < return
[ 303.86]          > fib(n: uint32): uint32
[ 303.87]           > fib(n: uint32): uint32
[ 303.89]           < return
[ 303.90]           > fib(n: uint32): uint32
[ 303.91]           < return
[ 303.92]          < return
[ 303.93]         < return
[ 303.94]         > fib(n: uint32): uint32
[ 303.96]          > fib(n: uint32): uint32
[ 303.97]           > fib(n: uint32): uint32
[ 303.99]           < return
[ 304.00]           > fib(n: uint32): uint32
[ 304.01]           < return
[ 304.02]          < return
[ 304.03]          > fib(n: uint32): uint32
[ 304.05]          < return
[ 304.06]         < return
[ 304.07]        < return
[ 304.08]        > fib(n: uint32): uint32
[ 304.09]         > fib(n: uint32): uint32
[ 304.11]          > fib(n: uint32): uint32
[ 304.12]           > fib(n: uint32): uint32
[ 304.14]           < return
[ 304.15]           > fib(n: uint32): uint32
[ 304.16]           < return
[ 304.17]          < return
[ 304.18]          > fib(n: uint32): uint32
[ 304.20]          < return
[ 304.21]         < return
[ 304.22]         > fib(n: uint32): uint32
[ 304.24]          > fib(n: uint32): uint32
[ 304.25]          < return
[ 304.26]          > fib(n: uint32): uint32
[ 304.28]          < return
[ 304.29]         < return
[ 304.30]        < return
[ 304.31]       < return
[ 304.32]       > fib(n: uint32): uint32
[ 304.33]        > fib(n: uint32): uint32
[ 304.35]         > fib(n: uint32): uint32
[ 304.36]          > fib(n: uint32): uint32
[ 304.38]           > fib(n: uint32): uint32
[ 304.39]           < return
[ 304.40]           > fib(n: uint32): uint32
[ 304.42]           < return
[ 304.43]          < return
[ 304.44]          > fib(n: uint32): uint32
[ 304.45]          < return
[ 304.46]         < return
[ 304.47]         > fib(n: uint32): uint32
[ 304.49]          > fib(n: uint32): uint32
[ 304.50]          < return
[ 304.51]          > fib(n: uint32): uint32
[ 304.53]          < return
[ 304.54]         < return
[ 304.55]        < return
[ 304.56]        > fib(n: uint32): uint32
[ 304.57]         > fib(n: uint32): uint32
[ 304.59]          > fib(n: uint32): uint32
[ 304.60]          < return
[ 304.61]          > fib(n: uint32): uint32
[ 304.63]          < return
[ 304.64]         < return
[ 304.65]         > fib(n: uint32): uint32
[ 304.67]         < return
[ 304.68]        < return
[ 304.69]       < return
[ 304.70]      < return
[ 304.71]      > fib(n: uint32): uint32
[ 304.72]       > fib(n: uint32): uint32
[ 304.74]        > fib(n: uint32): uint32
[ 304.75]         > fib(n: uint32): uint32
[ 304.77]          > fib(n: uint32): uint32
[ 304.78]           > fib(n: uint32): uint32
[ 304.80]           < return
[ 304.81]           > fib(n: uint32): uint32
[ 304.82]           < return
[ 304.83]          < return
[ 304.84]          > fib(n: uint32): uint32
[ 304.86]          < return
[ 304.87]         < return
[ 304.88]         > fib(n: uint32): uint32
[ 304.89]          > fib(n: uint32): uint32
[ 304.91]          < return
[ 304.92]          > fib(n: uint32): uint32
[ 304.93]          < return
[ 304.94]         < return
[ 304.95]        < return
[ 304.96]        > fib(n: uint32): uint32
[ 304.98]         > fib(n: uint32): uint32
[ 304.99]          > fib(n: uint32): uint32
[ 305.01]          < return
[ 305.02]          > fib(n: uint32): uint32
[ 305.03]          < return
[ 305.04]         < return
[ 305.05]         > fib(n: uint32): uint32
[ 305.07]         < return
[ 305.08]        < return
[ 305.09]       < return
[ 305.10]       > fib(n: uint32): uint32
[ 305.11]        > fib(n: uint32): uint32
[ 305.13]         > fib(n: uint32): uint32
[ 305.14]          > fib(n: uint32): uint32
[ 305.16]          < return
[ 305.17]          > fib(n: uint32): uint32
[ 305.18]          < return
[ 305.19]         < return
[ 305.20]         > fib(n: uint32): uint32
[ 305.22]         < return
[ 305.23]        < return
[ 305.24]        > fib(n: uint32): uint32
[ 305.25]         > fib(n: uint32): uint32
[ 305.27]         < return
[ 305.28]         > fib(n: uint32): uint32
[ 305.29]         < return
[ 305.30]        < return
[ 305.31]       < return
[ 305.32]      < return
[ 305.33]     < return
[ 305.34]    < return
[ 305.35]    > fib(n: uint32): uint32
[ 305.37]     > fib(n: uint32): uint32
[ 305.38]      > fib(n: uint32): uint32
[ 305.40]       > fib(n: uint32): uint32
[ 305.41]        > fib(n: uint32): uint32
[ 305.43]         > fib(n: uint32): uint32
[ 305.44]          > fib(n: uint32): uint32
[ 305.46]           > fib(n: uint32): uint32
[ 305.47]            > fib(n: uint32): uint32
[ 305.49]            < return
[ 305.50]            > fib(n: uint32): uint32
[ 305.51]            < return
[ 305.54]           < return
[ 305.56]           > fib(n: uint32): uint32
[ 305.57]           < return
[ 305.58]          < return
[ 305.59]          > fib(n: uint32): uint32
[ 305.61]           > fib(n: uint32): uint32
[ 305.62]           < return
[ 305.66]           > fib(n: uint32): uint32
[ 305.68]           < return
[ 305.69]          < return
[ 305.72]         < return
[ 305.73]         > fib(n: uint32): uint32
[ 305.75]          > fib(n: uint32): uint32
[ 305.76]           > fib(n: uint32): uint32
[ 305.77]           < return
[ 305.78]           > fib(n: uint32): uint32
[ 305.80]           < return
[ 305.81]          < return
[ 305.82]          > fib(n: uint32): uint32
[ 305.83]          < return
[ 305.85]         < return
[ 305.86]        < return
[ 305.87]        > fib(n: uint32): uint32
[ 305.89]         > fib(n: uint32): uint32
[ 305.90]          > fib(n: uint32): uint32
[ 305.92]           > fib(n: uint32): uint32
[ 305.93]           < return
[ 305.94]           > fib(n: uint32): uint32
[ 305.96]           < return
[ 305.97]          < return
[ 305.98]          > fib(n: uint32): uint32
[ 305.99]          < return
[ 306.00]         < return
[ 306.01]         > fib(n: uint32): uint32
[ 306.03]          > fib(n: uint32): uint32
[ 306.04]          < return
[ 306.05]          > fib(n: uint32): uint32
[ 306.07]          < return
[ 306.08]         < return
[ 306.09]        < return
[ 306.10]       < return
[ 306.11]       > fib(n: uint32): uint32
[ 306.12]        > fib(n: uint32): uint32
[ 306.14]         > fib(n: uint32): uint32
[ 306.15]          > fib(n: uint32): uint32
[ 306.17]           > fib(n: uint32): uint32
[ 306.19]           < return
[ 306.20]           > fib(n: uint32): uint32
[ 306.22]           < return
[ 306.23]          < return
[ 306.24]          > fib(n: uint32): uint32
[ 306.25]          < return
[ 306.26]         < return
[ 306.27]         > fib(n: uint32): uint32
[ 306.29]          > fib(n: uint32): uint32
[ 306.30]          < return
[ 306.31]          > fib(n: uint32): uint32
[ 306.33]          < return
[ 306.34]         < return
[ 306.35]        < return
[ 306.36]        > fib(n: uint32): uint32
[ 306.37]         > fib(n: uint32): uint32
[ 306.39]          > fib(n: uint32): uint32
[ 306.40]          < return
[ 306.41]          > fib(n: uint32): uint32
[ 306.43]          < return
[ 306.44]         < return
[ 306.45]         > fib(n: uint32): uint32
[ 306.46]         < return
[ 306.47]        < return
[ 306.48]       < return
[ 306.49]      < return
[ 306.50]      > fib(n: uint32): uint32
[ 306.52]       > fib(n: uint32): uint32
[ 306.53]        > fib(n: uint32): uint32
[ 306.55]         > fib(n: uint32): uint32
[ 306.56]          > fib(n: uint32): uint32
[ 306.58]           > fib(n: uint32): uint32
[ 306.59]           < return
[ 306.60]           > fib(n: uint32): uint32
[ 306.62]           < return
[ 306.63]          < return
[ 306.64]          > fib(n: uint32): uint32
[ 306.65]          < return
[ 306.66]         < return
[ 306.67]         > fib(n: uint32): uint32
[ 306.69]          > fib(n: uint32): uint32
[ 306.70]          < return
[ 306.71]          > fib(n: uint32): uint32
[ 306.73]          < return
[ 306.74]         < return
[ 306.75]        < return
[ 306.76]        > fib(n: uint32): uint32
[ 306.77]         > fib(n: uint32): uint32
[ 306.79]          > fib(n: uint32): uint32
[ 306.80]          < return
[ 306.81]          > fib(n: uint32): uint32
[ 306.82]          < return
[ 306.84]         < return
[ 306.85]         > fib(n: uint32): uint32
[ 306.86]         < return
[ 306.87]        < return
[ 306.88]       < return
[ 306.89]       > fib(n: uint32): uint32
[ 306.90]        > fib(n: uint32): uint32
[ 306.92]         > fib(n: uint32): uint32
[ 306.94]          > fib(n: uint32): uint32
[ 306.95]          < return
[ 306.96]          > fib(n: uint32): uint32
[ 306.97]          < return
[ 306.98]         < return
[ 307.00]         > fib(n: uint32): uint32
[ 307.01]         < return
[ 307.02]        < return
[ 307.03]        > fib(n: uint32): uint32
[ 307.05]         > fib(n: uint32): uint32
[ 307.06]         < return
[ 307.07]         > fib(n: uint32): uint32
[ 307.08]         < return
[ 307.09]        < return
[ 307.10]       < return
[ 307.11]      < return
[ 307.12]     < return
[ 307.13]     > fib(n: uint32): uint32
[ 307.15]      > fib(n: uint32): uint32
[ 307.17]       > fib(n: uint32): uint32
[ 307.18]        > fib(n: uint32): uint32
[ 307.19]         > fib(n: uint32): uint32
[ 307.21]          > fib(n: uint32): uint32
[ 307.22]           > fib(n: uint32): uint32
[ 307.24]           < return
[ 307.25]           > fib(n: uint32): uint32
[ 307.26]           < return
[ 307.27]          < return
[ 307.28]          > fib(n: uint32): uint32
[ 307.30]          < return
[ 307.31]         < return
[ 307.32]         > fib(n: uint32): uint32
[ 307.33]          > fib(n: uint32): uint32
[ 307.35]          < return
[ 307.36]          > fib(n: uint32): uint32
[ 307.37]          < return
[ 307.38]         < return
[ 307.39]        < return
[ 307.40]        > fib(n: uint32): uint32
[ 307.42]         > fib(n: uint32): uint32
[ 307.43]          > fib(n: uint32): uint32
[ 307.45]          < return
[ 307.46]          > fib(n: uint32): uint32
[ 307.47]          < return
[ 307.48]         < return
[ 307.49]         > fib(n: uint32): uint32
[ 307.50]         < return
[ 307.52]        < return
[ 307.53]       < return
[ 307.54]       > fib(n: uint32): uint32
[ 307.55]        > fib(n: uint32): uint32
[ 307.57]         > fib(n: uint32): uint32
[ 307.58]          > fib(n: uint32): uint32
[ 307.60]          < return
[ 307.61]          > fib(n: uint32): uint32
[ 307.62]          < return
[ 307.63]         < return
[ 307.64]         > fib(n: uint32): uint32
[ 307.66]         < return
[ 307.67]        < return
[ 307.68]        > fib(n: uint32): uint32
[ 307.70]         > fib(n: uint32): uint32
[ 307.71]         < return
[ 307.72]         > fib(n: uint32): uint32
[ 307.74]         < return
[ 307.75]        < return
[ 307.76]       < return
[ 307.77]      < return
[ 307.78]      > fib(n: uint32): uint32
[ 307.79]       > fib(n: uint32): uint32
[ 307.81]        > fib(n: uint32): uint32
[ 307.82]         > fib(n: uint32): uint32
[ 307.84]          > fib(n: uint32): uint32
[ 307.85]          < return
[ 307.86]          > fib(n: uint32): uint32
[ 307.88]          < return
[ 307.88]         < return
[ 307.89]         > fib(n: uint32): uint32
[ 307.91]         < return
[ 307.92]        < return
[ 307.93]        > fib(n: uint32): uint32
[ 307.94]         > fib(n: uint32): uint32
[ 307.96]         < return
[ 307.97]         > fib(n: uint32): uint32
[ 307.98]         < return
[ 307.99]        < return
[ 308.00]       < return
[ 308.01]       > fib(n: uint32): uint32
[ 308.03]        > fib(n: uint32): uint32
[ 308.04]         > fib(n: uint32): uint32
[ 308.06]         < return
[ 308.07]         > fib(n: uint32): uint32
[ 308.08]         < return
[ 308.09]        < return
[ 308.10]        > fib(n: uint32): uint32
[ 308.12]        < return
[ 308.13]       < return
[ 308.14]      < return
[ 308.15]     < return
[ 308.16]    < return
[ 308.17]   < return
[ 308.18]  < return
[ 308.22]  > typename.name(type: typename): .cstr
[ 308.25]  < return
[ 308.26]  > typename.file(type: typename): .cstr
[ 308.28]  < return
[ 308.29]  > typename.line(type: typename): int32
[ 308.30]  < return
[ 308.31]  > typename.base(type: typename): typename
[ 308.33]  < return
[ 308.34]  > typename.name(type: typename): .cstr
[ 308.36]  < return
[ 308.37]  > typename.file(type: typename): .cstr
[ 308.39]  < return
[ 308.40]  > typename.line(type: typename): int32
[ 308.41]  < return
[ 308.42]  > typename.base(type: typename): typename
[ 308.44]  < return
[ 308.46]  > typename.base(type: typename): typename
[ 308.47]  < return
[ 308.52]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.54]  < return
[ 308.56]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.57]  < return
[ 308.58]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.60]  < return
[ 308.61]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.62]  < return
[ 308.64]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.65]  < return
[ 308.66]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.68]  < return
[ 308.69]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.70]  < return
[ 308.72]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.73]  < return
[ 308.74]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 308.76]  < return
[ 308.77]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.78]  < return
[ 308.80]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.81]  < return
[ 308.82]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 308.84]  < return
[ 308.85]  > float64.sin(x: float64): float64
[ 308.88]  < return
[ 308.89]  > float64.cos(x: float64): float64
[ 308.91]  < return
[ 308.92]  > float64.tan(x: float64): float64
[ 308.94]  < return
[ 308.95]  > float64.log(x: float64): float64
[ 308.97]  < return
[ 308.98]  > float64.exp(x: float64): float64
[ 309.00]  < return
[ 309.01]  > float64.pow(x: float64, y: float64): float64
[ 309.03]  < return
[ 309.05]  > float64.sqrt(x: float64): float64
[ 309.06]  < return
[ 309.07]  > float64.atan2(x: float64, y: float64): float64
[ 309.09]  < return
[ 309.10]  > float32.sin(x: float32): float32
[ 309.12]  < return
[ 309.13]  > float32.cos(x: float32): float32
[ 309.14]  < return
[ 309.16]  > float32.tan(x: float32): float32
[ 309.17]  < return
[ 309.19]  > float32.log(x: float32): float32
[ 309.20]  < return
[ 309.21]  > float32.exp(x: float32): float32
[ 309.22]  < return
[ 309.24]  > float32.pow(x: float32, y: float32): float32
[ 309.26]  < return
[ 309.27]  > float32.sqrt(x: float32): float32
[ 309.29]  < return
[ 309.30]  > float32.atan2(x: float32, y: float32): float32
[ 309.31]  < return
[ 309.33]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.35]  < return
[ 309.36]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.37]  < return
[ 309.38]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.40]  < return
[ 309.41]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.43]  < return
[ 309.44]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 309.46]  < return
[ 309.47]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 309.49]  < return
[ 309.50]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.51]  < return
[ 309.53]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.54]  < return
[ 309.56]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.57]  < return
[ 309.58]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 309.60]  < return
[ 309.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 309.65]  < return
[ 309.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 309.70]  < return
[ 309.72]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 309.73]  < return
[ 309.75]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 309.76]  < return
[ 309.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 309.81]  < return
[ 309.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 309.87]  < return
[ 309.89]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 309.90]   > noError(ptr: pointer): void
[ 309.92]   < return
[ 309.93]   > halt(): void
[ 309.94]   < return
[ 309.95]  < return
[ 309.96]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 309.98]  < return
[ 310.00]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 310.01]   > stackOverflow(ptr: pointer): void
[ 310.03]    > stackOverflow(ptr: pointer): void
[ 310.04]     > stackOverflow(ptr: pointer): void
[ 310.05]      > stackOverflow(ptr: pointer): void
[ 310.07]       > stackOverflow(ptr: pointer): void
[ 310.08]        > stackOverflow(ptr: pointer): void
[ 310.09]         > stackOverflow(ptr: pointer): void
[ 310.11]          > stackOverflow(ptr: pointer): void
[ 310.12]           > stackOverflow(ptr: pointer): void
[ 310.13]            > stackOverflow(ptr: pointer): void
[ 310.15]             > stackOverflow(ptr: pointer): void
[ 310.16]              > stackOverflow(ptr: pointer): void
[ 310.17]               > stackOverflow(ptr: pointer): void
[ 310.19]                > stackOverflow(ptr: pointer): void
[ 310.20]                 > stackOverflow(ptr: pointer): void
[ 310.22]                  > stackOverflow(ptr: pointer): void
[ 310.23]                   > stackOverflow(ptr: pointer): void
[ 310.24]                    > stackOverflow(ptr: pointer): void
[ 310.26]                     > stackOverflow(ptr: pointer): void
[ 310.27]                      > stackOverflow(ptr: pointer): void
[ 310.29]                       > stackOverflow(ptr: pointer): void
[ 310.30]                        > stackOverflow(ptr: pointer): void
[ 310.31]                         > stackOverflow(ptr: pointer): void
[ 310.33]                          > stackOverflow(ptr: pointer): void
[ 310.34]                           > stackOverflow(ptr: pointer): void
[ 310.35]                            > stackOverflow(ptr: pointer): void
[ 310.37]                             > stackOverflow(ptr: pointer): void
[ 310.41]                              > stackOverflow(ptr: pointer): void
[ 310.42]                               > stackOverflow(ptr: pointer): void
[ 310.44]                                > stackOverflow(ptr: pointer): void
[ 310.45]                                 > stackOverflow(ptr: pointer): void
[ 310.47]                                  > stackOverflow(ptr: pointer): void
[ 310.48]                                   > stackOverflow(ptr: pointer): void
[ 310.50]                                    > stackOverflow(ptr: pointer): void
[ 310.51]                                     > stackOverflow(ptr: pointer): void
[ 310.52]                                      > stackOverflow(ptr: pointer): void
[ 310.54]                                       > stackOverflow(ptr: pointer): void
[ 310.55]                                        > stackOverflow(ptr: pointer): void
[ 310.56]                                         > stackOverflow(ptr: pointer): void
[ 310.58]                                          > stackOverflow(ptr: pointer): void
[ 310.59]                                           > stackOverflow(ptr: pointer): void
[ 310.61]                                            > stackOverflow(ptr: pointer): void
[ 310.62]                                             > stackOverflow(ptr: pointer): void
[ 310.63]                                              > stackOverflow(ptr: pointer): void
[ 310.65]                                               > stackOverflow(ptr: pointer): void
[ 310.66]                                                > stackOverflow(ptr: pointer): void
[ 310.68]                                                 > stackOverflow(ptr: pointer): void
[ 310.69]                                                  > stackOverflow(ptr: pointer): void
[ 310.70]                                                   > stackOverflow(ptr: pointer): void
[ 310.71]                                                    > stackOverflow(ptr: pointer): void
[ 310.73]                                                     > stackOverflow(ptr: pointer): void
[ 310.74]                                                      > stackOverflow(ptr: pointer): void
[ 310.76]                                                       > stackOverflow(ptr: pointer): void
[ 310.77]                                                        > stackOverflow(ptr: pointer): void
[ 310.79]                                                         > stackOverflow(ptr: pointer): void
[ 310.80]                                                          > stackOverflow(ptr: pointer): void
[ 310.81]                                                           > stackOverflow(ptr: pointer): void
[ 310.83]                                                            > stackOverflow(ptr: pointer): void
[ 310.84]                                                             > stackOverflow(ptr: pointer): void
[ 310.86]                                                              > stackOverflow(ptr: pointer): void
[ 310.87]                                                               > stackOverflow(ptr: pointer): void
[ 310.88]                                                                > stackOverflow(ptr: pointer): void
[ 310.90]                                                                 > stackOverflow(ptr: pointer): void
[ 310.91]                                                                  > stackOverflow(ptr: pointer): void
[ 310.92]                                                                  < return
[ 310.94]                                                                 < return
[ 310.95]                                                                < return
[ 310.96]                                                               < return
[ 310.97]                                                              < return
[ 310.98]                                                             < return
[ 310.99]                                                            < return
[ 311.00]                                                           < return
[ 311.01]                                                          < return
[ 311.02]                                                         < return
[ 311.04]                                                        < return
[ 311.05]                                                       < return
[ 311.06]                                                      < return
[ 311.07]                                                     < return
[ 311.08]                                                    < return
[ 311.09]                                                   < return
[ 311.10]                                                  < return
[ 311.11]                                                 < return
[ 311.14]                                                < return
[ 311.15]                                               < return
[ 311.16]                                              < return
[ 311.17]                                             < return
[ 311.18]                                            < return
[ 311.19]                                           < return
[ 311.20]                                          < return
[ 311.21]                                         < return
[ 311.22]                                        < return
[ 311.23]                                       < return
[ 311.24]                                      < return
[ 311.25]                                     < return
[ 311.26]                                    < return
[ 311.27]                                   < return
[ 311.28]                                  < return
[ 311.29]                                 < return
[ 311.30]                                < return
[ 311.31]                               < return
[ 311.32]                              < return
[ 311.33]                             < return
[ 311.35]                            < return
[ 311.36]                           < return
[ 311.37]                          < return
[ 311.38]                         < return
[ 311.39]                        < return
[ 311.40]                       < return
[ 311.41]                      < return
[ 311.42]                     < return
[ 311.43]                    < return
[ 311.44]                   < return
[ 311.45]                  < return
[ 311.46]                 < return
[ 311.47]                < return
[ 311.48]               < return
[ 311.49]              < return
[ 311.50]             < return
[ 311.51]            < return
[ 311.52]           < return
[ 311.53]          < return
[ 311.54]         < return
[ 311.55]        < return
[ 311.56]       < return
[ 311.57]      < return
[ 311.58]     < return
[ 311.59]    < return
[ 311.60]   < return
[ 311.61]  < return
[ 311.62]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 311.64]   > divisionByZero(args: pointer): void
[ 311.65]   < return
[ 311.66]  < return
[ 311.68]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 311.69]   > invalidInstruction(args: pointer): void
[ 311.70]   < return
[ 311.71]  < return
[ 311.73]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 311.74]   > invalidMemoryAccess(args: pointer): void
[ 311.76]   < return
[ 311.77]  < return
[ 311.78]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 311.79]   > abortExecution(args: pointer): void
[ 311.81]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 311.95]    < return
[ 311.96]   < return
[ 311.97]  < return
[ 312.11]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 312.13]  < return
[ 312.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 312.25]  < return
[ 312.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 312.38]  < return
[ 312.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 312.45]  < return
[ 312.46]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 312.51]  < return
[ 312.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 312.56]  < return
[ 312.58]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 312.62]  < return
[ 312.65]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.67]  < return
[ 312.69]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.70]  < return
[ 312.72]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.73]  < return
[ 312.75]  > lenSlice(values: int64[]): int32
[ 312.76]  < return
[ 312.77]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.79]  < return
[ 312.80]  > lenSlice(values: int64[]): int32
[ 312.82]  < return
[ 312.83]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.85]  < return
[ 312.86]  > lenSlice(values: int64[]): int32
[ 312.88]  < return
[ 312.89]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.91]  < return
[ 312.92]  > lenSlice(values: int64[]): int32
[ 312.94]  < return
[ 312.95]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 312.96]  < return
[ 312.98]  > lenSlice(values: int64[]): int32
[ 313.00]  < return
[ 313.01]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 313.02]  < return
[ 313.08]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.10]  < return
[ 313.12]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.13]  < return
[ 313.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.17]  < return
[ 313.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.21]  < return
[ 313.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.25]  < return
[ 313.27]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.29]  < return
[ 313.31]  > nthSlice(idx: int32, values: int64[]): int64
[ 313.32]  < return
[ 313.34]  > nthSlice(idx: int32, values: int64[]): int64
[ 313.36]  < return
[ 313.42]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.44]  < return
[ 313.46]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.48]  < return
[ 313.50]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.52]  < return
[ 313.54]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.56]  < return
[ 313.58]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.60]  < return
[ 313.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.63]  < return
[ 313.65]  > nthSlice(idx: int32, values: int64[]): int64
[ 313.67]  < return
[ 313.70]  > nthSlice(idx: int32, values: int64[]): int64
[ 313.72]  < return
[ 313.78]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.80]  < return
[ 313.82]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.85]  < return
[ 313.87]  > nthFixed(idx: int32, values: int64[7]): int64
[ 313.89]  < return
[ 313.91]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.92]  < return
[ 313.94]  > nthArray(idx: int32, values: int64[*]): int64
[ 313.96]  < return
[ 313.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.00]  < return
[ 314.02]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.04]  < return
[ 314.06]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.08]  < return
[ 314.14]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.16]  < return
[ 314.18]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.20]  < return
[ 314.22]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.24]  < return
[ 314.26]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.28]  < return
[ 314.30]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.32]  < return
[ 314.34]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.35]  < return
[ 314.38]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.39]  < return
[ 314.41]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.43]  < return
[ 314.49]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.51]  < return
[ 314.53]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.55]  < return
[ 314.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.59]  < return
[ 314.61]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.63]  < return
[ 314.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.66]  < return
[ 314.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.70]  < return
[ 314.72]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.74]  < return
[ 314.76]  > nthSlice(idx: int32, values: int64[]): int64
[ 314.78]  < return
[ 314.84]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.86]  < return
[ 314.88]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.90]  < return
[ 314.92]  > nthFixed(idx: int32, values: int64[7]): int64
[ 314.94]  < return
[ 314.96]  > nthArray(idx: int32, values: int64[*]): int64
[ 314.98]  < return
[ 315.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 315.01]  < return
[ 315.03]  > nthArray(idx: int32, values: int64[*]): int64
[ 315.05]  < return
[ 315.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 315.09]  < return
[ 315.11]  > nthSlice(idx: int32, values: int64[]): int64
[ 315.13]  < return
[ 315.19]  > nthFixed(idx: int32, values: int64[7]): int64
[ 315.21]  < return
[ 315.23]  > nthFixed(idx: int32, values: int64[7]): int64
[ 315.25]  < return
[ 315.27]  > nthFixed(idx: int32, values: int64[7]): int64
[ 315.29]  < return
[ 315.31]  > nthArray(idx: int32, values: int64[*]): int64
[ 315.32]  < return
[ 315.34]  > nthArray(idx: int32, values: int64[*]): int64
[ 315.36]  < return
[ 315.38]  > nthArray(idx: int32, values: int64[*]): int64
[ 315.40]  < return
[ 315.42]  > nthSlice(idx: int32, values: int64[]): int64
[ 315.44]  < return
[ 315.46]  > nthSlice(idx: int32, values: int64[]): int64
[ 315.48]  < return
[ 315.56]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 315.58]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:69: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 315.70]   < return
[ 315.71]  < return
[ 315.73]  > customPrint(this: RecordMethodTest): void
[ 315.74]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:60: debug: override
	test/lang/method.ci:70: customPrint(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 315.86]   < return
[ 315.88]  < return
[ 315.89]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 315.91]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:73: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 316.02]   < return
[ 316.04]  < return
[ 316.05]  > print(this: RecordMethodTest): void
[ 316.07]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:84: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 316.19]   < return
[ 316.21]  < return
[ 316.22]  > printStatic(this: RecordMethodTest): void
[ 316.26]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:80: debug: extension
	test/lang/method.ci:85: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 316.38]   < return
[ 316.39]  < return
[ 316.41]  > print(this: RecordMethodTest): void
[ 316.42]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:76: debug: extension
	test/lang/method.ci:86: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 316.54]   < return
[ 316.55]  < return
[ 316.57]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 316.58]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:89: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 316.70]   < return
[ 316.71]  < return
[ 316.73]  > RecordMethodTest.printStatic(this: RecordMethodTest): void
[ 316.75]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:45: debug: static
	test/lang/method.ci:90: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod>,
		delegateMethod: <globalFunction>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <RecordMethodTest.print>
	})
	native.code:: .main
[ 316.86]   < return
[ 316.88]  < return
[ 316.89]  > RecordMethodTest.print(this: RecordMethodTest): void
[ 316.91]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtual
	test/lang/method.ci:91: print(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>,
		print: <customPrint>
	})
	native.code:: .main
[ 317.02]   < return
[ 317.04]  < return
[ 318.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 318.37]  < return
[ 318.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 318.43]  < return
[ 318.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 318.49]  < return
[ 318.52]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 318.56]  < return
[ 318.60]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 318.64]  < return
[ 318.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 318.72]  < return
[ 318.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 318.80]  < return
[ 318.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 318.86]  < return
[ 318.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 318.93]  < return
[ 318.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 318.99]  < return
[ 319.04]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 319.08]  < return
[ 319.11]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 319.14]  < return
[ 319.23]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 319.26]  < return
[ 319.30]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 319.34]  < return
[ 319.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 319.44]  < return
[ 319.49]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 319.53]  < return
[ 319.57]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 319.60]  < return
[ 319.65]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 319.69]  < return
[ 319.73]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 319.77]  < return
[ 319.81]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 319.84]  < return
[ 319.87]  > halt(): void
[ 319.89]  < return
[ 319.90] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:38: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:59: Math.floor: function(<Math.floor>)
lib/std/math.ci:71: Math.sign: function(<Math.sign>)
lib/std/math.ci:80: Math.sign: function(<Math.sign>)
lib/std/math.ci:90: Math.abs: function(<Math.abs>)
lib/std/math.ci:96: Math.abs: function(<Math.abs>)
lib/std/math.ci:103: Math.min: function(<Math.min>)
lib/std/math.ci:109: Math.min: function(<Math.min>)
lib/std/math.ci:116: Math.max: function(<Math.max>)
lib/std/math.ci:122: Math.max: function(<Math.max>)
lib/std/math.ci:129: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:138: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:148: Math.lerp: function(<Math.lerp>)
lib/std/math.ci:151: Math.lerp: function(<Math.lerp>)
lib/std/math.ci:155: Math.smooth: function(<Math.smooth>)
lib/std/math.ci:159: Math.smooth: function(<Math.smooth>)
lib/std/math.ci:239: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:252: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:266: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:323: Math.tan: function(<Math.tan>)
lib/std/math.ci:380: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:419: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:435: Math.asin: function(<Math.asin>)
lib/std/math.ci:3: Math: typename(<Math>)
lib/std/math.Complex.ci:3: Complex: typename(<Complex>)
lib/std/math.Complex.ci:20: Complex: function(<Complex>)
lib/std/math.Complex.ci:25: Complex: function(<Complex>)
lib/std/math.Complex.ci:66: div: function(<div>)
lib/std/math.Complex.ci:93: inv: function(<inv>)
lib/std/math.Complex.ci:107: pow: function(<pow>)
lib/std/string.ci:3: length: function(<length>)
lib/std/string.ci:14: indexOf: function(<indexOf>)
lib/std/string.ci:24: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:35: startsWith: function(<startsWith>)
lib/std/string.ci:44: endsWith: function(<endsWith>)
lib/std/string.ci:58: compare: function(<compare>)
lib/std/string.ci:70: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:84: caseCmp: function(<caseCmp>)
lib/std/string.ci:106: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:113: append: function(<append>)
lib/std/string.ci:129: append: function(<append>)
lib/std/string.ci:192: append: function(<append>)
lib/std/string.ci:196: append: function(<append>)
lib/std/string.ci:205: append: function(<append>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:11: emitNfcF32: float32(1.000000)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(136)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(167920)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(167648)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2472)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(136)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: sinF64: float64(1.000000)
test/stdc/number.ci:38: cosF64: float64(0.000000)
test/stdc/number.ci:39: tanF64: float64(1.000000)
test/stdc/number.ci:40: logF64: float64(3.000000)
test/stdc/number.ci:41: expF64: float64(2.718282)
test/stdc/number.ci:42: powF64: float64(3.141593)
test/stdc/number.ci:43: sqrtF64: float64(3.141593)
test/stdc/number.ci:44: atanF64: float64(1.262627)
test/stdc/number.ci:46: sinF32: float32(1.000000)
test/stdc/number.ci:47: cosF32: float32(-0.000000)
test/stdc/number.ci:48: tanF32: float32(1.000000)
test/stdc/number.ci:49: logF32: float32(3.000000)
test/stdc/number.ci:50: expF32: float32(2.718282)
test/stdc/number.ci:51: powF32: float32(3.141593)
test/stdc/number.ci:52: sqrtF32: float32(3.141593)
test/stdc/number.ci:53: atanF32: float32(1.262627)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](BadRef)
test/lang/array.ci:51: arrSliceNoInit: int64[](BadRef)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(5)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(6)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 51,
	constant: 52
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 61,
	constant: 62
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 6,
	constant: 7,
	memberInit: 8,
	constantInit: 9,
	memberRec: {
		member: 61,
		constant: 62
	},
	constantRec: {
		member: 71,
		constant: 72
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:12: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:26: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:31: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.print: function(<RecordMethodTest.print>)
test/lang/method.ci:44: RecordMethodTest.printStatic: function(<RecordMethodTest.printStatic>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:49: globalFunction: function(<globalFunction>)
test/lang/method.ci:53: recordMethodTest: RecordMethodTest({
	abstractMethod: <RecordMethodTest.staticMethod>,
	delegateMethod: <globalFunction>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <RecordMethodTest.print>
})
test/lang/method.ci:59: customPrint: function(<customPrint>)
test/lang/method.ci:63: recordMethodTestCustomPrint: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>,
	print: <customPrint>
})
test/lang/method.ci:75: print: function(<print>)
test/lang/method.ci:79: printStatic: function(<printStatic>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 260507(254.4 Kb)
memory[heap] @03f99b; size: 1312099(1.3 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 247512(241.7 Kb)
memory[code] @000000; size: 12679(12.4 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @03f9b8; size: 1312048(1.3 Mb)

---------- Profile functions: 49/111, coverage: 44.14%
::[.0052b0, .0052b0): exec(2), time(23 / 0.023 ms): halt(): void
::[.0055a8, .0055a8): exec(3), time(40 / 0.040 ms): typename.base(type: typename): typename
::[.005778, .005778): exec(2), time(27 / 0.027 ms): typename.file(type: typename): .cstr
::[.005948, .005948): exec(2), time(27 / 0.027 ms): typename.line(type: typename): int32
::[.005b18, .005b18): exec(2), time(37 / 0.037 ms): typename.name(type: typename): .cstr
::[.0061f0, .0061f0): exec(40), time(2444 / 2.444 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0069f0, .0069f0): exec(7), time(2003 / 2.003 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.006c50, .006c50): exec(8), time(110 / 0.110 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.006f40, .006f40): exec(2), time(26 / 0.026 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007228, .007228): exec(2), time(32 / 0.032 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.007508, .007508): exec(1), time(14 / 0.014 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.007770, .007770): exec(0), time(0 / 0.000 ms): System.exit(code: int32): void
::[.007948, .007948): exec(0), time(0 / 0.000 ms): System.srand(seed: int32): void
::[.007a90, .007a90): exec(0), time(0 / 0.000 ms): System.rand(): int32
::[.007bd8, .007bd8): exec(0), time(0 / 0.000 ms): System.time(): int32
::[.007d20, .007d20): exec(0), time(0 / 0.000 ms): System.clock(): int32
::[.007e68, .007e68): exec(0), time(0 / 0.000 ms): System.millis(): int64
::[.008038, .008038): exec(0), time(0 / 0.000 ms): System.sleep(millis: int64): void
::[.008328, .008328): exec(6), time(80 / 0.080 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.008608, .008608): exec(6), time(76 / 0.076 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0087d8, .0087d8): exec(0), time(0 / 0.000 ms): uint32.pop(value: int32): int32
::[.0089a8, .0089a8): exec(0), time(0 / 0.000 ms): uint32.swap(value: int32): int32
::[.008b78, .008b78): exec(0), time(0 / 0.000 ms): uint32.bsr(value: int32): int32
::[.008d48, .008d48): exec(0), time(0 / 0.000 ms): uint32.bsf(value: int32): int32
::[.008f18, .008f18): exec(0), time(0 / 0.000 ms): uint32.hib(value: int32): int32
::[.0090e8, .0090e8): exec(0), time(0 / 0.000 ms): uint32.lob(value: int32): int32
::[.0093c0, .0093c0): exec(0), time(0 / 0.000 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.009698, .009698): exec(0), time(0 / 0.000 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.009870, .009870): exec(2), time(41 / 0.041 ms): float32.sin(x: float32): float32
::[.009a40, .009a40): exec(1), time(13 / 0.013 ms): float32.cos(x: float32): float32
::[.009c10, .009c10): exec(1), time(12 / 0.012 ms): float32.tan(x: float32): float32
::[.009de0, .009de0): exec(1), time(12 / 0.012 ms): float32.log(x: float32): float32
::[.009fb0, .009fb0): exec(1), time(12 / 0.012 ms): float32.exp(x: float32): float32
::[.00a210, .00a210): exec(1), time(19 / 0.019 ms): float32.pow(x: float32, y: float32): float32
::[.00a3e0, .00a3e0): exec(1), time(13 / 0.013 ms): float32.sqrt(x: float32): float32
::[.00a638, .00a638): exec(1), time(17 / 0.017 ms): float32.atan2(x: float32, y: float32): float32
::[.00a800, .00a800): exec(1), time(24 / 0.024 ms): float64.sin(x: float64): float64
::[.00a9c8, .00a9c8): exec(1), time(17 / 0.017 ms): float64.cos(x: float64): float64
::[.00ab90, .00ab90): exec(1), time(13 / 0.013 ms): float64.tan(x: float64): float64
::[.00ad58, .00ad58): exec(1), time(18 / 0.018 ms): float64.log(x: float64): float64
::[.00af20, .00af20): exec(1), time(13 / 0.013 ms): float64.exp(x: float64): float64
::[.00b170, .00b170): exec(1), time(17 / 0.017 ms): float64.pow(x: float64, y: float64): float64
::[.00b338, .00b338): exec(1), time(12 / 0.012 ms): float64.sqrt(x: float64): float64
::[.00b588, .00b588): exec(1), time(16 / 0.016 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:38:[.03c6d8, .03c72b): exec(8), time(118 / 0.118 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.03c730, .03c798): exec(0), time(0 / 0.000 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:59:[.03c798, .03c7bb): exec(0), time(0 / 0.000 ms): Math.floor(x: float64): float64
lib/std/math.ci:71:[.03c7c0, .03c7e4): exec(0), time(0 / 0.000 ms): Math.sign(x: float32): int32
lib/std/math.ci:80:[.03c7e8, .03c80c): exec(0), time(0 / 0.000 ms): Math.sign(x: float64): int32
lib/std/math.ci:90:[.03c810, .03c823): exec(0), time(0 / 0.000 ms): Math.abs(x: float32): float32
lib/std/math.ci:96:[.03c828, .03c83b): exec(0), time(0 / 0.000 ms): Math.abs(x: float64): float64
lib/std/math.ci:103:[.03c840, .03c853): exec(0), time(0 / 0.000 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:109:[.03c858, .03c86b): exec(0), time(0 / 0.000 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:116:[.03c870, .03c883): exec(0), time(0 / 0.000 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:122:[.03c888, .03c89b): exec(0), time(0 / 0.000 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:129:[.03c8a0, .03c8c1): exec(0), time(0 / 0.000 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:138:[.03c8c8, .03c8e9): exec(0), time(0 / 0.000 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:148:[.03c8f0, .03c8fe): exec(0), time(0 / 0.000 ms): Math.lerp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:151:[.03c900, .03c90e): exec(0), time(0 / 0.000 ms): Math.lerp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:155:[.03c910, .03c945): exec(0), time(0 / 0.000 ms): Math.smooth(t: float32, a: float32, b: float32): float32
lib/std/math.ci:159:[.03c948, .03c989): exec(0), time(0 / 0.000 ms): Math.smooth(t: float64, a: float64, b: float64): float64
lib/std/math.ci:239:[.03c990, .03c9c9): exec(0), time(0 / 0.000 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:252:[.03c9d0, .03ca09): exec(0), time(0 / 0.000 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:266:[.03ca10, .03cb6c): exec(0), time(0 / 0.000 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:323:[.03cb70, .03ccea): exec(0), time(0 / 0.000 ms): Math.tan(arg: float64): float64
lib/std/math.ci:380:[.03ccf0, .03cde8): exec(0), time(0 / 0.000 ms): Math.sinh(x: float64): float64
lib/std/math.ci:419:[.03cde8, .03ce33): exec(0), time(0 / 0.000 ms): Math.cosh(x: float64): float64
lib/std/math.ci:435:[.03ce38, .03cee6): exec(0), time(0 / 0.000 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:20:[.03cee8, .03cef0): exec(0), time(0 / 0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:25:[.03cef0, .03cef9): exec(0), time(0 / 0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:66:[.03cf00, .03cf80): exec(0), time(0 / 0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:93:[.03cf80, .03cfa4): exec(0), time(0 / 0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:107:[.03cfa8, .03d011): exec(0), time(0 / 0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:3:[.03d018, .03d049): exec(0), time(0 / 0.000 ms): length(str: char[*]): int32
lib/std/string.ci:14:[.03d050, .03d088): exec(0), time(0 / 0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:24:[.03d088, .03d0c6): exec(0), time(0 / 0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:35:[.03d0c8, .03d111): exec(0), time(0 / 0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:44:[.03d118, .03d19b): exec(0), time(0 / 0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:58:[.03d1a0, .03d1ea): exec(0), time(0 / 0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:71:[.03d1f0, .03d237): exec(0), time(0 / 0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:70:[.03d238, .03d25c): exec(0), time(0 / 0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:84:[.03d260, .03d26e): exec(0), time(0 / 0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:113:[.03d270, .03d2c5): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:129:[.03d2d8, .03d56f): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:192:[.03d570, .03d587): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:196:[.03d588, .03d5be): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:205:[.03d5d0, .03d5e9): exec(0), time(0 / 0.000 ms): append(output: char[], pos: int32, value: uint32): int32
test/lang/function.ci:3:[.03d5f8, .03d5f9): exec(0), time(0 / 0.000 ms): empty(): void
test/lang/function.ci:6:[.03d600, .03d608): exec(2), time(38 / 0.038 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.03d608, .03d610): exec(2), time(28 / 0.028 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.03d610, .03d647): exec(753), time(19124 / 19.124 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.03d648, .03d649): exec(1), time(18 / 0.018 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.03d650, .03d668): exec(64-64), time(1592 / 1.592 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.03d668, .03d674): exec(1-1), time(14 / 0.014 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.03d678, .03d6bc): exec(1-1), time(170-137 / 0.170-0.137 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.03d6c0, .03d6cd): exec(1-1), time(16 / 0.016 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.03d6d0, .03d6d2): exec(1-1), time(14 / 0.014 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.03d6d8, .03d6dd): exec(5), time(79 / 0.079 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.03d6e0, .03d6ec): exec(21), time(414 / 0.414 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.03d6f0, .03d6fc): exec(21), time(375 / 0.375 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.03d700, .03d70c): exec(14), time(251 / 0.251 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.03d740, .03d748): exec(0), time(0 / 0.000 ms): RecordMethodTest.staticMethod(x: int32, y: int32): int32
test/lang/method.ci:26:[.03d750, .03d758): exec(0), time(0 / 0.000 ms): RecordMethodTest.virtualMethod(x: int32, y: int32): int32
test/lang/method.ci:31:[.03d758, .03d760): exec(0), time(0 / 0.000 ms): RecordMethodTest.forwardMethod(x: int32, y: int32): int32
test/lang/method.ci:40:[.03d760, .03d788): exec(3), time(443-352 / 0.443-0.352 ms): RecordMethodTest.print(this: RecordMethodTest): void
test/lang/method.ci:44:[.03d788, .03d7b0): exec(2), time(291-232 / 0.291-0.232 ms): RecordMethodTest.printStatic(this: RecordMethodTest): void
test/lang/method.ci:49:[.03d7b0, .03d7b8): exec(0), time(0 / 0.000 ms): globalFunction(x: int32, y: int32): int32
test/lang/method.ci:59:[.03d7b8, .03d7e0): exec(1), time(146-117 / 0.146-0.117 ms): customPrint(this: RecordMethodTest): void
test/lang/method.ci:75:[.03d7e0, .03d808): exec(2), time(301-242 / 0.301-0.242 ms): print(this: RecordMethodTest): void
test/lang/method.ci:79:[.03d808, .03d830): exec(1), time(169-119 / 0.169-0.119 ms): printStatic(this: RecordMethodTest): void
::[.03d830, .03f99b): exec(1), time(31537-25786 / 31.537-25.786 ms): .main

---------- Profile statements: 676/991, coverage: 68.21%
lib/stdlib.ci:40:[.03c6e1, .03c6e2) exec(8), time(65-65 / 0.065-0.065 ms): <assertEq+9>
lib/stdlib.ci:39:[.03c6d8, .03c6e2) exec(8-8), time(0 / 0.000 ms): <assertEq+0>
lib/stdlib.ci:43:[.03c6e6, .03c6f1) exec(0), time(0 / 0.000 ms): <assertEq+14>
lib/stdlib.ci:44:[.03c6f1, .03c6fc) exec(0), time(0 / 0.000 ms): <assertEq+25>
lib/stdlib.ci:45:[.03c6fc, .03c700) exec(0), time(0 / 0.000 ms): <assertEq+36>
lib/stdlib.ci:42:[.03c6e2, .03c700) exec(0), time(0 / 0.000 ms): <assertEq+10>
lib/stdlib.ci:47:[.03c700, .03c726) exec(0), time(0 / 0.000 ms): <assertEq+40>
lib/std/math.ci:25:[.03c748, .03c759) exec(0), time(0 / 0.000 ms): <modf+24>
lib/std/math.ci:26:[.03c759, .03c760) exec(0), time(0 / 0.000 ms): <modf+41>
lib/std/math.ci:27:[.03c760, .03c769) exec(0), time(0 / 0.000 ms): <modf+48>
lib/std/math.ci:24:[.03c740, .03c76d) exec(0), time(0 / 0.000 ms): <modf+16>
lib/std/math.ci:29:[.03c76d, .03c771) exec(0), time(0 / 0.000 ms): <modf+61>
lib/std/math.ci:30:[.03c771, .03c776) exec(0), time(0 / 0.000 ms): <modf+65>
lib/std/math.ci:23:[.03c730, .03c776) exec(0), time(0 / 0.000 ms): <modf+0>
lib/std/math.ci:32:[.03c776, .03c782) exec(0), time(0 / 0.000 ms): <modf+70>
lib/std/math.ci:33:[.03c782, .03c78a) exec(0), time(0 / 0.000 ms): <modf+82>
lib/std/math.ci:34:[.03c78a, .03c793) exec(0), time(0 / 0.000 ms): <modf+90>
lib/std/math.ci:60:[.03c798, .03c799) exec(0), time(0 / 0.000 ms): <floor+0>
lib/std/math.ci:61:[.03c799, .03c7ad) exec(0), time(0 / 0.000 ms): <floor+1>
lib/std/math.ci:62:[.03c7ad, .03c7b6) exec(0), time(0 / 0.000 ms): <floor+21>
lib/std/math.ci:73:[.03c7c8, .03c7cc) exec(0), time(0 / 0.000 ms): <sign+8>
lib/std/math.ci:72:[.03c7c0, .03c7cc) exec(0), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:76:[.03c7d4, .03c7dc) exec(0), time(0 / 0.000 ms): <sign+20>
lib/std/math.ci:75:[.03c7cc, .03c7dc) exec(0), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:78:[.03c7dc, .03c7e4) exec(0), time(0 / 0.000 ms): <sign+28>
lib/std/math.ci:82:[.03c7f0, .03c7f4) exec(0), time(0 / 0.000 ms): <sign+8>
lib/std/math.ci:81:[.03c7e8, .03c7f4) exec(0), time(0 / 0.000 ms): <sign+0>
lib/std/math.ci:85:[.03c7fc, .03c804) exec(0), time(0 / 0.000 ms): <sign+20>
lib/std/math.ci:84:[.03c7f4, .03c804) exec(0), time(0 / 0.000 ms): <sign+12>
lib/std/math.ci:87:[.03c804, .03c80c) exec(0), time(0 / 0.000 ms): <sign+28>
lib/std/math.ci:92:[.03c818, .03c81e) exec(0), time(0 / 0.000 ms): <abs+8>
lib/std/math.ci:91:[.03c810, .03c81e) exec(0), time(0 / 0.000 ms): <abs+0>
lib/std/math.ci:94:[.03c81e, .03c823) exec(0), time(0 / 0.000 ms): <abs+14>
lib/std/math.ci:98:[.03c830, .03c836) exec(0), time(0 / 0.000 ms): <abs+8>
lib/std/math.ci:97:[.03c828, .03c836) exec(0), time(0 / 0.000 ms): <abs+0>
lib/std/math.ci:100:[.03c836, .03c83b) exec(0), time(0 / 0.000 ms): <abs+14>
lib/std/math.ci:105:[.03c849, .03c84e) exec(0), time(0 / 0.000 ms): <min+9>
lib/std/math.ci:104:[.03c840, .03c84e) exec(0), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:107:[.03c84e, .03c853) exec(0), time(0 / 0.000 ms): <min+14>
lib/std/math.ci:111:[.03c861, .03c866) exec(0), time(0 / 0.000 ms): <min+9>
lib/std/math.ci:110:[.03c858, .03c866) exec(0), time(0 / 0.000 ms): <min+0>
lib/std/math.ci:113:[.03c866, .03c86b) exec(0), time(0 / 0.000 ms): <min+14>
lib/std/math.ci:118:[.03c879, .03c87e) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:117:[.03c870, .03c87e) exec(0), time(0 / 0.000 ms): <max+0>
lib/std/math.ci:120:[.03c87e, .03c883) exec(0), time(0 / 0.000 ms): <max+14>
lib/std/math.ci:124:[.03c891, .03c896) exec(0), time(0 / 0.000 ms): <max+9>
lib/std/math.ci:123:[.03c888, .03c896) exec(0), time(0 / 0.000 ms): <max+0>
lib/std/math.ci:126:[.03c896, .03c89b) exec(0), time(0 / 0.000 ms): <max+14>
lib/std/math.ci:131:[.03c8a9, .03c8ae) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:130:[.03c8a0, .03c8ae) exec(0), time(0 / 0.000 ms): <clamp+0>
lib/std/math.ci:134:[.03c8b7, .03c8bc) exec(0), time(0 / 0.000 ms): <clamp+23>
lib/std/math.ci:133:[.03c8ae, .03c8bc) exec(0), time(0 / 0.000 ms): <clamp+14>
lib/std/math.ci:136:[.03c8bc, .03c8c1) exec(0), time(0 / 0.000 ms): <clamp+28>
lib/std/math.ci:140:[.03c8d1, .03c8d6) exec(0), time(0 / 0.000 ms): <clamp+9>
lib/std/math.ci:139:[.03c8c8, .03c8d6) exec(0), time(0 / 0.000 ms): <clamp+0>
lib/std/math.ci:143:[.03c8df, .03c8e4) exec(0), time(0 / 0.000 ms): <clamp+23>
lib/std/math.ci:142:[.03c8d6, .03c8e4) exec(0), time(0 / 0.000 ms): <clamp+14>
lib/std/math.ci:145:[.03c8e4, .03c8e9) exec(0), time(0 / 0.000 ms): <clamp+28>
lib/std/math.ci:149:[.03c8f0, .03c8fe) exec(0), time(0 / 0.000 ms): <lerp+0>
lib/std/math.ci:152:[.03c900, .03c90e) exec(0), time(0 / 0.000 ms): <lerp+0>
lib/std/math.ci:156:[.03c910, .03c92e) exec(0), time(0 / 0.000 ms): <smooth+0>
lib/std/math.ci:157:[.03c92e, .03c945) exec(0), time(0 / 0.000 ms): <smooth+30>
lib/std/math.ci:160:[.03c948, .03c96a) exec(0), time(0 / 0.000 ms): <smooth+0>
lib/std/math.ci:161:[.03c96a, .03c989) exec(0), time(0 / 0.000 ms): <smooth+34>
lib/std/math.ci:242:[.03c9a5, .03c9ad) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:241:[.03c999, .03c9ad) exec(0), time(0 / 0.000 ms): <cmp+9>
lib/std/math.ci:247:[.03c9bd, .03c9c5) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:246:[.03c9b1, .03c9c5) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:240:[.03c990, .03c9c5) exec(0), time(0 / 0.000 ms): <cmp+0>
lib/std/math.ci:250:[.03c9c5, .03c9c9) exec(0), time(0 / 0.000 ms): <cmp+53>
lib/std/math.ci:255:[.03c9e5, .03c9ed) exec(0), time(0 / 0.000 ms): <cmp+21>
lib/std/math.ci:254:[.03c9d9, .03c9ed) exec(0), time(0 / 0.000 ms): <cmp+9>
lib/std/math.ci:260:[.03c9fd, .03ca05) exec(0), time(0 / 0.000 ms): <cmp+45>
lib/std/math.ci:259:[.03c9f1, .03ca05) exec(0), time(0 / 0.000 ms): <cmp+33>
lib/std/math.ci:253:[.03c9d0, .03ca05) exec(0), time(0 / 0.000 ms): <cmp+0>
lib/std/math.ci:263:[.03ca05, .03ca09) exec(0), time(0 / 0.000 ms): <cmp+53>
lib/std/math.ci:280:[.03ca10, .03ca12) exec(0), time(0 / 0.000 ms): <sinCos+0>
lib/std/math.ci:282:[.03ca1a, .03ca1f) exec(0), time(0 / 0.000 ms): <sinCos+10>
lib/std/math.ci:283:[.03ca1f, .03ca27) exec(0), time(0 / 0.000 ms): <sinCos+15>
lib/std/math.ci:281:[.03ca12, .03ca27) exec(0), time(0 / 0.000 ms): <sinCos+2>
lib/std/math.ci:286:[.03ca27, .03ca28) exec(0), time(0 / 0.000 ms): <sinCos+23>
lib/std/math.ci:287:[.03ca28, .03ca40) exec(0), time(0 / 0.000 ms): <sinCos+24>
lib/std/math.ci:289:[.03ca50, .03ca51) exec(0), time(0 / 0.000 ms): <sinCos+64>
lib/std/math.ci:290:[.03ca51, .03ca63) exec(0), time(0 / 0.000 ms): <sinCos+65>
lib/std/math.ci:291:[.03ca63, .03ca67) exec(0), time(0 / 0.000 ms): <sinCos+83>
lib/std/math.ci:293:[.03ca67, .03ca68) exec(0), time(0 / 0.000 ms): <sinCos+87>
lib/std/math.ci:294:[.03ca68, .03ca86) exec(0), time(0 / 0.000 ms): <sinCos+88>
lib/std/math.ci:295:[.03ca86, .03ca98) exec(0), time(0 / 0.000 ms): <sinCos+118>
lib/std/math.ci:298:[.03caa0, .03caa3) exec(0), time(0 / 0.000 ms): <sinCos+144>
lib/std/math.ci:299:[.03caa3, .03caab) exec(0), time(0 / 0.000 ms): <sinCos+147>
lib/std/math.ci:300:[.03caab, .03cab2) exec(0), time(0 / 0.000 ms): <sinCos+155>
lib/std/math.ci:301:[.03cab2, .03cab8) exec(0), time(0 / 0.000 ms): <sinCos+162>
lib/std/math.ci:288:[.03ca40, .03cabc) exec(0), time(0 / 0.000 ms): <sinCos+48>
lib/std/math.ci:304:[.03cac4, .03cad2) exec(0), time(0 / 0.000 ms): <sinCos+180>
lib/std/math.ci:303:[.03cabc, .03cad2) exec(0), time(0 / 0.000 ms): <sinCos+172>
lib/std/math.ci:307:[.03cade, .03cae3) exec(0), time(0 / 0.000 ms): <sinCos+206>
lib/std/math.ci:306:[.03cad2, .03cae3) exec(0), time(0 / 0.000 ms): <sinCos+194>
lib/std/math.ci:310:[.03cae3, .03cae8) exec(0), time(0 / 0.000 ms): <sinCos+211>
lib/std/math.ci:311:[.03cae8, .03cb28) exec(0), time(0 / 0.000 ms): <sinCos+216>
lib/std/math.ci:312:[.03cb28, .03cb5b) exec(0), time(0 / 0.000 ms): <sinCos+280>
lib/std/math.ci:313:[.03cb5b, .03cb67) exec(0), time(0 / 0.000 ms): <sinCos+331>
lib/std/math.ci:336:[.03cb70, .03cb71) exec(0), time(0 / 0.000 ms): <tan+0>
lib/std/math.ci:337:[.03cb71, .03cb72) exec(0), time(0 / 0.000 ms): <tan+1>
lib/std/math.ci:340:[.03cb7a, .03cb7f) exec(0), time(0 / 0.000 ms): <tan+10>
lib/std/math.ci:341:[.03cb7f, .03cb89) exec(0), time(0 / 0.000 ms): <tan+15>
lib/std/math.ci:339:[.03cb72, .03cb89) exec(0), time(0 / 0.000 ms): <tan+2>
lib/std/math.ci:343:[.03cb89, .03cba1) exec(0), time(0 / 0.000 ms): <tan+25>
lib/std/math.ci:345:[.03cba1, .03cba2) exec(0), time(0 / 0.000 ms): <tan+49>
lib/std/math.ci:346:[.03cba2, .03cbb2) exec(0), time(0 / 0.000 ms): <tan+50>
lib/std/math.ci:347:[.03cbb2, .03cbbb) exec(0), time(0 / 0.000 ms): <tan+66>
lib/std/math.ci:351:[.03cbcf, .03cbdd) exec(0), time(0 / 0.000 ms): <tan+95>
lib/std/math.ci:352:[.03cbdd, .03cbe7) exec(0), time(0 / 0.000 ms): <tan+109>
lib/std/math.ci:355:[.03cbf7, .03cc02) exec(0), time(0 / 0.000 ms): <tan+135>
lib/std/math.ci:356:[.03cc02, .03cc0c) exec(0), time(0 / 0.000 ms): <tan+146>
lib/std/math.ci:359:[.03cc1c, .03cc2a) exec(0), time(0 / 0.000 ms): <tan+172>
lib/std/math.ci:360:[.03cc2a, .03cc35) exec(0), time(0 / 0.000 ms): <tan+186>
lib/std/math.ci:358:[.03cc10, .03cc35) exec(0), time(0 / 0.000 ms): <tan+160>
lib/std/math.ci:354:[.03cbeb, .03cc35) exec(0), time(0 / 0.000 ms): <tan+123>
lib/std/math.ci:350:[.03cbc3, .03cc35) exec(0), time(0 / 0.000 ms): <tan+83>
lib/std/math.ci:349:[.03cbbb, .03cc35) exec(0), time(0 / 0.000 ms): <tan+75>
lib/std/math.ci:363:[.03cc35, .03cc3a) exec(0), time(0 / 0.000 ms): <tan+197>
lib/std/math.ci:364:[.03cc3a, .03cc7a) exec(0), time(0 / 0.000 ms): <tan+202>
lib/std/math.ci:365:[.03cc7a, .03cca1) exec(0), time(0 / 0.000 ms): <tan+266>
lib/std/math.ci:369:[.03ccb2, .03ccbb) exec(0), time(0 / 0.000 ms): <tan+322>
lib/std/math.ci:368:[.03ccaa, .03ccbb) exec(0), time(0 / 0.000 ms): <tan+314>
lib/std/math.ci:371:[.03ccbb, .03ccc9) exec(0), time(0 / 0.000 ms): <tan+331>
lib/std/math.ci:367:[.03cca1, .03ccc9) exec(0), time(0 / 0.000 ms): <tan+305>
lib/std/math.ci:374:[.03ccd2, .03ccdc) exec(0), time(0 / 0.000 ms): <tan+354>
lib/std/math.ci:373:[.03ccc9, .03ccdc) exec(0), time(0 / 0.000 ms): <tan+345>
lib/std/math.ci:376:[.03ccdc, .03cce5) exec(0), time(0 / 0.000 ms): <tan+364>
lib/std/math.ci:392:[.03ccf0, .03ccf1) exec(0), time(0 / 0.000 ms): <sinh+0>
lib/std/math.ci:394:[.03ccf9, .03ccfe) exec(0), time(0 / 0.000 ms): <sinh+9>
lib/std/math.ci:395:[.03ccfe, .03cd08) exec(0), time(0 / 0.000 ms): <sinh+14>
lib/std/math.ci:393:[.03ccf1, .03cd08) exec(0), time(0 / 0.000 ms): <sinh+1>
lib/std/math.ci:399:[.03cd18, .03cd2f) exec(0), time(0 / 0.000 ms): <sinh+40>
lib/std/math.ci:398:[.03cd08, .03cd2f) exec(0), time(0 / 0.000 ms): <sinh+24>
lib/std/math.ci:402:[.03cd2f, .03cd30) exec(0), time(0 / 0.000 ms): <sinh+63>
lib/std/math.ci:404:[.03cd40, .03cd5a) exec(0), time(0 / 0.000 ms): <sinh+80>
lib/std/math.ci:407:[.03cd5e, .03cd63) exec(0), time(0 / 0.000 ms): <sinh+110>
lib/std/math.ci:408:[.03cd63, .03cd98) exec(0), time(0 / 0.000 ms): <sinh+115>
lib/std/math.ci:409:[.03cd98, .03cdc3) exec(0), time(0 / 0.000 ms): <sinh+168>
lib/std/math.ci:403:[.03cd30, .03cdc7) exec(0), time(0 / 0.000 ms): <sinh+64>
lib/std/math.ci:413:[.03cdd0, .03cdda) exec(0), time(0 / 0.000 ms): <sinh+224>
lib/std/math.ci:412:[.03cdc7, .03cdda) exec(0), time(0 / 0.000 ms): <sinh+215>
lib/std/math.ci:415:[.03cdda, .03cde3) exec(0), time(0 / 0.000 ms): <sinh+234>
lib/std/math.ci:421:[.03cdf0, .03cdf5) exec(0), time(0 / 0.000 ms): <cosh+8>
lib/std/math.ci:420:[.03cde8, .03cdf5) exec(0), time(0 / 0.000 ms): <cosh+0>
lib/std/math.ci:424:[.03ce05, .03ce18) exec(0), time(0 / 0.000 ms): <cosh+29>
lib/std/math.ci:423:[.03cdf5, .03ce18) exec(0), time(0 / 0.000 ms): <cosh+13>
lib/std/math.ci:426:[.03ce18, .03ce33) exec(0), time(0 / 0.000 ms): <cosh+48>
lib/std/math.ci:438:[.03ce40, .03ce45) exec(0), time(0 / 0.000 ms): <asin+8>
lib/std/math.ci:436:[.03ce38, .03ce45) exec(0), time(0 / 0.000 ms): <asin+0>
lib/std/math.ci:441:[.03ce45, .03ce46) exec(0), time(0 / 0.000 ms): <asin+13>
lib/std/math.ci:443:[.03ce4e, .03ce58) exec(0), time(0 / 0.000 ms): <asin+22>
lib/std/math.ci:444:[.03ce58, .03ce5d) exec(0), time(0 / 0.000 ms): <asin+32>
lib/std/math.ci:442:[.03ce46, .03ce5d) exec(0), time(0 / 0.000 ms): <asin+14>
lib/std/math.ci:449:[.03ce6d, .03ce76) exec(0), time(0 / 0.000 ms): <asin+53>
lib/std/math.ci:447:[.03ce5d, .03ce76) exec(0), time(0 / 0.000 ms): <asin+37>
lib/std/math.ci:452:[.03ce76, .03ce89) exec(0), time(0 / 0.000 ms): <asin+62>
lib/std/math.ci:454:[.03ce99, .03ceb7) exec(0), time(0 / 0.000 ms): <asin+97>
lib/std/math.ci:457:[.03cebb, .03cec5) exec(0), time(0 / 0.000 ms): <asin+131>
lib/std/math.ci:453:[.03ce89, .03cec5) exec(0), time(0 / 0.000 ms): <asin+81>
lib/std/math.ci:461:[.03cece, .03ced8) exec(0), time(0 / 0.000 ms): <asin+150>
lib/std/math.ci:460:[.03cec5, .03ced8) exec(0), time(0 / 0.000 ms): <asin+141>
lib/std/math.ci:463:[.03ced8, .03cee1) exec(0), time(0 / 0.000 ms): <asin+160>
::[.03ceec, .03ceef) exec(0), time(0 / 0.000 ms): <Complex+4>
lib/std/math.Complex.ci:21:[.03cee8, .03cef0) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:28:[.03cef4, .03cef8) exec(0), time(0 / 0.000 ms): <Complex+4>
lib/std/math.Complex.ci:26:[.03cef0, .03cef9) exec(0), time(0 / 0.000 ms): <Complex+0>
lib/std/math.Complex.ci:71:[.03cf1f, .03cf24) exec(0), time(0 / 0.000 ms): <div+31>
lib/std/math.Complex.ci:72:[.03cf24, .03cf2c) exec(0), time(0 / 0.000 ms): <div+36>
lib/std/math.Complex.ci:75:[.03cf39, .03cf46) exec(0), time(0 / 0.000 ms): <div+57>
lib/std/math.Complex.ci:73:[.03cf2c, .03cf4b) exec(0), time(0 / 0.000 ms): <div+44>
lib/std/math.Complex.ci:70:[.03cf00, .03cf4f) exec(0), time(0 / 0.000 ms): <div+0>
lib/std/math.Complex.ci:78:[.03cf4f, .03cf54) exec(0), time(0 / 0.000 ms): <div+79>
lib/std/math.Complex.ci:79:[.03cf54, .03cf5c) exec(0), time(0 / 0.000 ms): <div+84>
lib/std/math.Complex.ci:82:[.03cf69, .03cf76) exec(0), time(0 / 0.000 ms): <div+105>
lib/std/math.Complex.ci:80:[.03cf5c, .03cf7b) exec(0), time(0 / 0.000 ms): <div+92>
lib/std/math.Complex.ci:94:[.03cf80, .03cf8b) exec(0), time(0 / 0.000 ms): <inv+0>
lib/std/math.Complex.ci:97:[.03cf92, .03cf9a) exec(0), time(0 / 0.000 ms): <inv+18>
lib/std/math.Complex.ci:95:[.03cf8b, .03cf9f) exec(0), time(0 / 0.000 ms): <inv+11>
lib/std/math.Complex.ci:108:[.03cfa8, .03cfbf) exec(0), time(0 / 0.000 ms): <pow+0>
lib/std/math.Complex.ci:109:[.03cfbf, .03cfcf) exec(0), time(0 / 0.000 ms): <pow+23>
lib/std/math.Complex.ci:110:[.03cfcf, .03cfde) exec(0), time(0 / 0.000 ms): <pow+39>
lib/std/math.Complex.ci:111:[.03cfde, .03cff1) exec(0), time(0 / 0.000 ms): <pow+54>
lib/std/math.Complex.ci:114:[.03cffc, .03d007) exec(0), time(0 / 0.000 ms): <pow+84>
lib/std/math.Complex.ci:112:[.03cff1, .03d00c) exec(0), time(0 / 0.000 ms): <pow+73>
lib/std/string.ci:5:[.03d024, .03d028) exec(0), time(0 / 0.000 ms): <length+12>
lib/std/string.ci:4:[.03d018, .03d028) exec(0), time(0 / 0.000 ms): <length+0>
lib/std/string.ci:7:[.03d028, .03d029) exec(0), time(0 / 0.000 ms): <length+16>
lib/std/string.ci:8:[.03d02d, .03d031) exec(0), time(0 / 0.000 ms): <length+21>
lib/std/string.ci:8:[.03d031, .03d03b) exec(0), time(0 / 0.000 ms): <length+25>
lib/std/string.ci:8:[.03d029, .03d03b) exec(0), time(0 / 0.000 ms): <length+17>
lib/std/string.ci:10:[.03d03b, .03d044) exec(0), time(0 / 0.000 ms): <length+35>
lib/std/string.ci:17:[.03d065, .03d06e) exec(0), time(0 / 0.000 ms): <indexOf+21>
lib/std/string.ci:16:[.03d055, .03d06e) exec(0), time(0 / 0.000 ms): <indexOf+5>
lib/std/string.ci:15:[.03d06e, .03d072) exec(0), time(0 / 0.000 ms): <indexOf+30>
lib/std/string.ci:15:[.03d072, .03d07c) exec(0), time(0 / 0.000 ms): <indexOf+34>
lib/std/string.ci:15:[.03d050, .03d080) exec(0), time(0 / 0.000 ms): <indexOf+0>
lib/std/string.ci:20:[.03d080, .03d088) exec(0), time(0 / 0.000 ms): <indexOf+48>
lib/std/string.ci:25:[.03d088, .03d08d) exec(0), time(0 / 0.000 ms): <lastIndexOf+0>
lib/std/string.ci:28:[.03d0a2, .03d0a6) exec(0), time(0 / 0.000 ms): <lastIndexOf+26>
lib/std/string.ci:27:[.03d092, .03d0a6) exec(0), time(0 / 0.000 ms): <lastIndexOf+10>
lib/std/string.ci:26:[.03d0a6, .03d0aa) exec(0), time(0 / 0.000 ms): <lastIndexOf+30>
lib/std/string.ci:26:[.03d0aa, .03d0b4) exec(0), time(0 / 0.000 ms): <lastIndexOf+34>
lib/std/string.ci:26:[.03d08d, .03d0b8) exec(0), time(0 / 0.000 ms): <lastIndexOf+5>
lib/std/string.ci:31:[.03d0b8, .03d0c1) exec(0), time(0 / 0.000 ms): <lastIndexOf+48>
lib/std/string.ci:38:[.03d0e7, .03d0f2) exec(0), time(0 / 0.000 ms): <startsWith+31>
lib/std/string.ci:37:[.03d0cd, .03d0f2) exec(0), time(0 / 0.000 ms): <startsWith+5>
lib/std/string.ci:36:[.03d0f2, .03d0f6) exec(0), time(0 / 0.000 ms): <startsWith+42>
lib/std/string.ci:36:[.03d0f6, .03d102) exec(0), time(0 / 0.000 ms): <startsWith+46>
lib/std/string.ci:36:[.03d0c8, .03d106) exec(0), time(0 / 0.000 ms): <startsWith+0>
lib/std/string.ci:41:[.03d106, .03d111) exec(0), time(0 / 0.000 ms): <startsWith+62>
lib/std/string.ci:45:[.03d118, .03d125) exec(0), time(0 / 0.000 ms): <endsWith+0>
lib/std/string.ci:46:[.03d125, .03d132) exec(0), time(0 / 0.000 ms): <endsWith+13>
lib/std/string.ci:48:[.03d13b, .03d146) exec(0), time(0 / 0.000 ms): <endsWith+35>
lib/std/string.ci:47:[.03d132, .03d146) exec(0), time(0 / 0.000 ms): <endsWith+26>
lib/std/string.ci:52:[.03d16b, .03d176) exec(0), time(0 / 0.000 ms): <endsWith+83>
lib/std/string.ci:51:[.03d14b, .03d176) exec(0), time(0 / 0.000 ms): <endsWith+51>
lib/std/string.ci:50:[.03d176, .03d17a) exec(0), time(0 / 0.000 ms): <endsWith+94>
lib/std/string.ci:50:[.03d17a, .03d183) exec(0), time(0 / 0.000 ms): <endsWith+98>
lib/std/string.ci:50:[.03d146, .03d187) exec(0), time(0 / 0.000 ms): <endsWith+46>
lib/std/string.ci:55:[.03d187, .03d196) exec(0), time(0 / 0.000 ms): <endsWith+111>
lib/std/string.ci:59:[.03d1a0, .03d1a1) exec(0), time(0 / 0.000 ms): <compare+0>
lib/std/string.ci:61:[.03d1a6, .03d1bc) exec(0), time(0 / 0.000 ms): <compare+6>
lib/std/string.ci:63:[.03d1c8, .03d1cc) exec(0), time(0 / 0.000 ms): <compare+40>
lib/std/string.ci:62:[.03d1bc, .03d1cc) exec(0), time(0 / 0.000 ms): <compare+28>
lib/std/string.ci:60:[.03d1cc, .03d1d0) exec(0), time(0 / 0.000 ms): <compare+44>
lib/std/string.ci:60:[.03d1d0, .03d1d8) exec(0), time(0 / 0.000 ms): <compare+48>
lib/std/string.ci:60:[.03d1a1, .03d1dc) exec(0), time(0 / 0.000 ms): <compare+1>
lib/std/string.ci:66:[.03d1dc, .03d1e5) exec(0), time(0 / 0.000 ms): <compare+60>
lib/std/string.ci:73:[.03d1ff, .03d20a) exec(0), time(0 / 0.000 ms): <ignCase+15>
lib/std/string.ci:72:[.03d1f0, .03d20a) exec(0), time(0 / 0.000 ms): <ignCase+0>
lib/std/string.ci:76:[.03d219, .03d224) exec(0), time(0 / 0.000 ms): <ignCase+41>
lib/std/string.ci:75:[.03d20a, .03d224) exec(0), time(0 / 0.000 ms): <ignCase+26>
lib/std/string.ci:78:[.03d224, .03d237) exec(0), time(0 / 0.000 ms): <ignCase+52>
lib/std/string.ci:81:[.03d238, .03d25c) exec(0), time(0 / 0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:85:[.03d260, .03d26e) exec(0), time(0 / 0.000 ms): <caseCmp+0>
lib/std/string.ci:116:[.03d27e, .03d282) exec(0), time(0 / 0.000 ms): <append+14>
lib/std/string.ci:115:[.03d275, .03d282) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:118:[.03d282, .03d28e) exec(0), time(0 / 0.000 ms): <append+18>
lib/std/string.ci:119:[.03d28e, .03d296) exec(0), time(0 / 0.000 ms): <append+30>
lib/std/string.ci:114:[.03d296, .03d29a) exec(0), time(0 / 0.000 ms): <append+38>
lib/std/string.ci:114:[.03d29a, .03d2a4) exec(0), time(0 / 0.000 ms): <append+42>
lib/std/string.ci:114:[.03d270, .03d2a8) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:123:[.03d2b1, .03d2b9) exec(0), time(0 / 0.000 ms): <append+65>
lib/std/string.ci:122:[.03d2a8, .03d2b9) exec(0), time(0 / 0.000 ms): <append+56>
lib/std/string.ci:125:[.03d2b9, .03d2c0) exec(0), time(0 / 0.000 ms): <append+73>
lib/std/string.ci:126:[.03d2c0, .03d2c5) exec(0), time(0 / 0.000 ms): <append+80>
lib/std/string.ci:133:[.03d2d8, .03d2d9) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:134:[.03d2d9, .03d2dd) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:136:[.03d2dd, .03d2e0) exec(0), time(0 / 0.000 ms): <append+5>
lib/std/string.ci:137:[.03d2e0, .03d316) exec(0), time(0 / 0.000 ms): <append+8>
lib/std/string.ci:138:[.03d316, .03d34b) exec(0), time(0 / 0.000 ms): <append+62>
lib/std/string.ci:142:[.03d34f, .03d36a) exec(0), time(0 / 0.000 ms): <append+119>
lib/std/string.ci:141:[.03d36a, .03d371) exec(0), time(0 / 0.000 ms): <append+146>
lib/std/string.ci:141:[.03d371, .03d379) exec(0), time(0 / 0.000 ms): <append+153>
lib/std/string.ci:141:[.03d34b, .03d379) exec(0), time(0 / 0.000 ms): <append+115>
lib/std/string.ci:145:[.03d381, .03d396) exec(0), time(0 / 0.000 ms): <append+169>
lib/std/string.ci:144:[.03d379, .03d396) exec(0), time(0 / 0.000 ms): <append+161>
lib/std/string.ci:148:[.03d396, .03d3a0) exec(0), time(0 / 0.000 ms): <append+190>
lib/std/string.ci:150:[.03d3a0, .03d3a7) exec(0), time(0 / 0.000 ms): <append+200>
lib/std/string.ci:152:[.03d3b2, .03d3bc) exec(0), time(0 / 0.000 ms): <append+218>
lib/std/string.ci:151:[.03d3a7, .03d3bc) exec(0), time(0 / 0.000 ms): <append+207>
lib/std/string.ci:157:[.03d3c7, .03d3cf) exec(0), time(0 / 0.000 ms): <append+239>
lib/std/string.ci:161:[.03d3ed, .03d421) exec(0), time(0 / 0.000 ms): <append+277>
lib/std/string.ci:162:[.03d421, .03d42c) exec(0), time(0 / 0.000 ms): <append+329>
lib/std/string.ci:163:[.03d42c, .03d434) exec(0), time(0 / 0.000 ms): <append+340>
lib/std/string.ci:160:[.03d434, .03d43c) exec(0), time(0 / 0.000 ms): <append+348>
lib/std/string.ci:160:[.03d43c, .03d444) exec(0), time(0 / 0.000 ms): <append+356>
lib/std/string.ci:160:[.03d3e9, .03d444) exec(0), time(0 / 0.000 ms): <append+273>
lib/std/string.ci:158:[.03d3cf, .03d444) exec(0), time(0 / 0.000 ms): <append+247>
lib/std/string.ci:166:[.03d444, .03d478) exec(0), time(0 / 0.000 ms): <append+364>
lib/std/string.ci:167:[.03d478, .03d483) exec(0), time(0 / 0.000 ms): <append+416>
lib/std/string.ci:168:[.03d483, .03d48b) exec(0), time(0 / 0.000 ms): <append+427>
lib/std/string.ci:156:[.03d3bc, .03d48b) exec(0), time(0 / 0.000 ms): <append+228>
lib/std/string.ci:173:[.03d48f, .03d4c3) exec(0), time(0 / 0.000 ms): <append+439>
lib/std/string.ci:174:[.03d4c3, .03d4ce) exec(0), time(0 / 0.000 ms): <append+491>
lib/std/string.ci:175:[.03d4ce, .03d4d6) exec(0), time(0 / 0.000 ms): <append+502>
lib/std/string.ci:172:[.03d4d6, .03d4de) exec(0), time(0 / 0.000 ms): <append+510>
lib/std/string.ci:172:[.03d4de, .03d4e6) exec(0), time(0 / 0.000 ms): <append+518>
lib/std/string.ci:172:[.03d48b, .03d4e6) exec(0), time(0 / 0.000 ms): <append+435>
lib/std/string.ci:180:[.03d4eb, .03d51f) exec(0), time(0 / 0.000 ms): <append+531>
lib/std/string.ci:181:[.03d51f, .03d530) exec(0), time(0 / 0.000 ms): <append+583>
lib/std/string.ci:182:[.03d530, .03d538) exec(0), time(0 / 0.000 ms): <append+600>
lib/std/string.ci:179:[.03d538, .03d53c) exec(0), time(0 / 0.000 ms): <append+608>
lib/std/string.ci:179:[.03d53c, .03d545) exec(0), time(0 / 0.000 ms): <append+612>
lib/std/string.ci:179:[.03d4e6, .03d549) exec(0), time(0 / 0.000 ms): <append+526>
lib/std/string.ci:186:[.03d552, .03d55a) exec(0), time(0 / 0.000 ms): <append+634>
lib/std/string.ci:185:[.03d549, .03d55a) exec(0), time(0 / 0.000 ms): <append+625>
lib/std/string.ci:188:[.03d55a, .03d561) exec(0), time(0 / 0.000 ms): <append+642>
lib/std/string.ci:189:[.03d561, .03d56a) exec(0), time(0 / 0.000 ms): <append+649>
lib/std/string.ci:193:[.03d570, .03d587) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:197:[.03d588, .03d589) exec(0), time(0 / 0.000 ms): <append+0>
lib/std/string.ci:199:[.03d591, .03d598) exec(0), time(0 / 0.000 ms): <append+9>
lib/std/string.ci:200:[.03d598, .03d59d) exec(0), time(0 / 0.000 ms): <append+16>
lib/std/string.ci:198:[.03d589, .03d59d) exec(0), time(0 / 0.000 ms): <append+1>
lib/std/string.ci:202:[.03d59d, .03d5b9) exec(0), time(0 / 0.000 ms): <append+21>
lib/std/string.ci:207:[.03d5d0, .03d5e9) exec(0), time(0 / 0.000 ms): <append+0>
test/lang/function.ci:7:[.03d600, .03d608) exec(2), time(23-23 / 0.023-0.023 ms): <funAdd+0>
test/lang/function.ci:33:[.03d608, .03d610) exec(2), time(22-22 / 0.022-0.022 ms): <funMul+0>
test/lang/function.ci:39:[.03d61c, .03d621) exec(377), time(3731-3731 / 3.731-3.731 ms): <fib+12>
test/lang/function.ci:38:[.03d610, .03d621) exec(753-377), time(608-608 / 0.608-0.608 ms): <fib+0>
test/lang/function.ci:41:[.03d621, .03d647) exec(376-375), time(19118-19118 / 19.118-19.118 ms): <fib+17>
test/stdc/tryExec.ci:15:[.03d650, .03d654) exec(64-1), time(36-36 / 0.036-0.036 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.03d654, .03d663) exec(63-63), time(0 / 0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.03d668, .03d66f) exec(1-1), time(0 / 0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.03d67c, .03d683) exec(1), time(1-1 / 0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.03d683, .03d68a) exec(1), time(1-1 / 0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.03d68a, .03d691) exec(1), time(1-1 / 0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.03d678, .03d691) exec(1-1), time(0 / 0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.03d691, .03d6b7) exec(1-1), time(0 / 0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.03d6c0, .03d6c5) exec(1), time(0 / 0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.03d6c5, .03d6c8) exec(1-1), time(0 / 0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.03d6d0, .03d6d2) exec(1-1), time(0 / 0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.03d6d8, .03d6dd) exec(5), time(52-52 / 0.052-0.052 ms): <lenSlice+0>
test/lang/array.ci:104:[.03d6e0, .03d6ec) exec(21), time(239-239 / 0.239-0.239 ms): <nthFixed+0>
test/lang/array.ci:105:[.03d6f0, .03d6fc) exec(21), time(235-235 / 0.235-0.235 ms): <nthArray+0>
test/lang/array.ci:106:[.03d700, .03d70c) exec(14), time(156-156 / 0.156-0.156 ms): <nthSlice+0>
test/lang/method.ci:7:[.03d740, .03d748) exec(0), time(0 / 0.000 ms): <staticMethod+0>
test/lang/method.ci:27:[.03d750, .03d758) exec(0), time(0 / 0.000 ms): <virtualMethod+0>
test/lang/method.ci:32:[.03d758, .03d760) exec(0), time(0 / 0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.03d760, .03d787) exec(3), time(391-391 / 0.391-0.391 ms): <print+0>
test/lang/method.ci:45:[.03d788, .03d7af) exec(2), time(259-259 / 0.259-0.259 ms): <printStatic+0>
test/lang/method.ci:50:[.03d7b0, .03d7b8) exec(0), time(0 / 0.000 ms): <globalFunction+0>
test/lang/method.ci:60:[.03d7b8, .03d7df) exec(1), time(131-131 / 0.131-0.131 ms): <customPrint+0>
test/lang/method.ci:76:[.03d7e0, .03d807) exec(2), time(269-269 / 0.269-0.269 ms): <print+0>
test/lang/method.ci:80:[.03d808, .03d82f) exec(1), time(133-133 / 0.133-0.133 ms): <printStatic+0>
lib/std/string.ci:130:[.03d830, .03d83e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+0>
lib/std/string.ci:131:[.03d83e, .03d84c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+14>
::[.03d855, .03d85c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+37>
::[.03d85c, .03d861) exec(1), time(1-1 / 0.001-0.001 ms): <.main+44>
::[.03d861, .03d866) exec(1), time(1-1 / 0.001-0.001 ms): <.main+49>
lib/std/string.ci:206:[.03d84c, .03d866) exec(1-1), time(0 / 0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.03d866, .03d873) exec(1), time(1-1 / 0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.03d873, .03d878) exec(1), time(1-1 / 0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.03d878, .03d881) exec(1), time(1-1 / 0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.03d881, .03d88a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.03d893, .03d89c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+99>
test/lang/member.ci:47:[.03d88a, .03d89c) exec(1-1), time(0 / 0.000 ms): <.main+90>
test/lang/member.ci:50:[.03d8a5, .03d8ae) exec(1), time(1-1 / 0.001-0.001 ms): <.main+117>
test/lang/member.ci:50:[.03d89c, .03d8ae) exec(1-1), time(0 / 0.000 ms): <.main+108>
test/lang/method.ci:12:[.03d8ae, .03d8b7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.03d8b7, .03d8b8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+135>
test/lang/emit.ci:4:[.03d8b8, .03d8b9) exec(1), time(0 / 0.000 ms): <.main+136>
test/lang/emit.ci:6:[.03d8b9, .03d8be) exec(1), time(0 / 0.000 ms): <.main+137>
test/lang/emit.ci:7:[.03d8be, .03d8c3) exec(1), time(1-1 / 0.001-0.001 ms): <.main+142>
test/lang/emit.ci:9:[.03d8c3, .03d8c8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.03d8c8, .03d8d3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+152>
test/lang/emit.ci:11:[.03d8d3, .03d8eb) exec(1), time(43-43 / 0.043-0.043 ms): <.main+163>
test/lang/emit.ci:17:[.03d8eb, .03d8f0) exec(1), time(0 / 0.000 ms): <.main+187>
test/lang/emit.ci:18:[.03d8f0, .03d8f6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+192>
test/lang/emit.ci:19:[.03d8f6, .03d900) exec(1), time(1-1 / 0.001-0.001 ms): <.main+198>
test/lang/emit.ci:20:[.03d900, .03d909) exec(1), time(0 / 0.000 ms): <.main+208>
test/lang/emit.ci:23:[.03d909, .03d913) exec(1), time(1-1 / 0.001-0.001 ms): <.main+217>
test/lang/inlineMacros.ci:10:[.03d913, .03d918) exec(1), time(1-1 / 0.001-0.001 ms): <.main+227>
test/lang/inlineMacros.ci:11:[.03d918, .03d91d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+232>
test/lang/inlineMacros.ci:12:[.03d91d, .03d922) exec(1), time(0 / 0.000 ms): <.main+237>
test/lang/inlineMacros.ci:13:[.03d922, .03d927) exec(1), time(0 / 0.000 ms): <.main+242>
test/lang/inlineMacros.ci:15:[.03d927, .03d928) exec(1), time(1-1 / 0.001-0.001 ms): <.main+247>
test/lang/inlineMacros.ci:16:[.03d928, .03d929) exec(1), time(0 / 0.000 ms): <.main+248>
test/lang/inlineMacros.ci:17:[.03d929, .03d92a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+249>
test/lang/inlineMacros.ci:19:[.03d92a, .03d92f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+250>
test/lang/inlineMacros.ci:20:[.03d92f, .03d931) exec(1), time(0 / 0.000 ms): <.main+255>
test/lang/inlineMacros.ci:21:[.03d931, .03d93b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+257>
test/lang/inlineMacros.ci:23:[.03d93b, .03d944) exec(1), time(1-1 / 0.001-0.001 ms): <.main+267>
test/lang/inlineMacros.ci:24:[.03d944, .03d949) exec(1), time(1-1 / 0.001-0.001 ms): <.main+276>
test/lang/inlineMacros.ci:25:[.03d949, .03d95a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+281>
test/lang/inlineMacros.ci:27:[.03d95a, .03d972) exec(1), time(3-3 / 0.003-0.003 ms): <.main+298>
test/lang/inlineMacros.ci:28:[.03d972, .03d984) exec(1), time(2-2 / 0.002-0.002 ms): <.main+322>
test/lang/inlineMacros.ci:29:[.03d984, .03d9a2) exec(1), time(4-4 / 0.004-0.004 ms): <.main+340>
test/lang/inlineMacros.ci:31:[.03d9a2, .03d9c3) exec(1), time(4-4 / 0.004-0.004 ms): <.main+370>
test/lang/inlineMacros.ci:32:[.03d9c3, .03d9de) exec(1), time(4-4 / 0.004-0.004 ms): <.main+403>
test/lang/inlineMacros.ci:33:[.03d9de, .03da05) exec(1), time(6-6 / 0.006-0.006 ms): <.main+430>
test/lang/inlineMacros.ci:35:[.03da05, .03da26) exec(1), time(4-4 / 0.004-0.004 ms): <.main+469>
test/lang/inlineMacros.ci:36:[.03da26, .03da41) exec(1), time(4-4 / 0.004-0.004 ms): <.main+502>
test/lang/inlineMacros.ci:37:[.03da41, .03da68) exec(1), time(6-6 / 0.006-0.006 ms): <.main+529>
test/lang/inlineMacros.ci:41:[.03da68, .03da7d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+568>
test/lang/inlineMacros.ci:42:[.03da7d, .03da8e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+589>
test/lang/inlineMacros.ci:43:[.03da8e, .03da99) exec(1), time(3-3 / 0.003-0.003 ms): <.main+606>
test/lang/inlineMacros.ci:44:[.03da99, .03daa4) exec(1), time(3-3 / 0.003-0.003 ms): <.main+617>
test/lang/inlineMacros.ci:45:[.03daa4, .03dac3) exec(1), time(5-5 / 0.005-0.005 ms): <.main+628>
test/lang/inlineMacros.ci:46:[.03dac3, .03dae2) exec(1), time(5-5 / 0.005-0.005 ms): <.main+659>
test/lang/inlineMacros.ci:50:[.03dae2, .03db20) exec(1), time(3-3 / 0.003-0.003 ms): <.main+690>
test/lang/inlineMacros.ci:51:[.03db20, .03db5e) exec(1), time(7-7 / 0.007-0.007 ms): <.main+752>
test/lang/inlineMacros.ci:52:[.03db5e, .03db90) exec(1), time(3-3 / 0.003-0.003 ms): <.main+814>
test/lang/inlineMacros.ci:53:[.03db90, .03dbc2) exec(1), time(8-8 / 0.008-0.008 ms): <.main+864>
test/lang/inlineMacros.ci:54:[.03dbc2, .03dc08) exec(1), time(3-3 / 0.003-0.003 ms): <.main+914>
test/lang/inlineMacros.ci:55:[.03dc08, .03dc4e) exec(1), time(9-9 / 0.009-0.009 ms): <.main+984>
test/lang/inlineMacros.ci:59:[.03dc4e, .03dca7) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1054>
test/lang/inlineMacros.ci:60:[.03dca7, .03dd00) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1143>
test/lang/inlineMacros.ci:61:[.03dd00, .03dd4d) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1232>
test/lang/inlineMacros.ci:62:[.03dd4d, .03dd9a) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1309>
test/lang/inlineMacros.ci:63:[.03dd9a, .03ddfb) exec(1), time(15-15 / 0.015-0.015 ms): <.main+1386>
test/lang/inlineMacros.ci:64:[.03ddfb, .03de5c) exec(1), time(15-15 / 0.015-0.015 ms): <.main+1483>
test/lang/inlineMacros.ci:68:[.03de5c, .03deb5) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1580>
test/lang/inlineMacros.ci:69:[.03deb5, .03df0e) exec(1), time(13-13 / 0.013-0.013 ms): <.main+1669>
test/lang/inlineMacros.ci:70:[.03df0e, .03df5b) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1758>
test/lang/inlineMacros.ci:71:[.03df5b, .03dfa8) exec(1), time(12-12 / 0.012-0.012 ms): <.main+1835>
test/lang/inlineMacros.ci:72:[.03dfa8, .03e009) exec(1), time(14-14 / 0.014-0.014 ms): <.main+1912>
test/lang/inlineMacros.ci:73:[.03e009, .03e06a) exec(1), time(15-15 / 0.015-0.015 ms): <.main+2009>
test/lang/overload.inline.ci:9:[.03e06a, .03e06f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2106>
test/lang/overload.inline.ci:10:[.03e06f, .03e074) exec(1), time(0 / 0.000 ms): <.main+2111>
test/lang/overload.inline.ci:11:[.03e074, .03e079) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2116>
test/lang/overload.inline.ci:12:[.03e079, .03e07e) exec(1), time(0 / 0.000 ms): <.main+2121>
test/lang/overload.inline.ci:13:[.03e07e, .03e083) exec(1), time(0 / 0.000 ms): <.main+2126>
test/lang/overload.inline.ci:28:[.03e083, .03e08c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2131>
test/lang/overload.inline.ci:29:[.03e08c, .03e0a2) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2140>
test/lang/initByRef.ci:8:[.03e0a2, .03e0a7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2162>
test/lang/initByRef.ci:9:[.03e0a7, .03e0ac) exec(1), time(0 / 0.000 ms): <.main+2167>
test/lang/initByRef.ci:10:[.03e0ac, .03e0b6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2172>
test/lang/initByRef.ci:12:[.03e0b6, .03e0b9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2182>
test/lang/initByRef.ci:13:[.03e0b9, .03e0bb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2185>
test/lang/initByRef.ci:14:[.03e0bb, .03e0bd) exec(1), time(0 / 0.000 ms): <.main+2187>
test/lang/initByRef.ci:16:[.03e0bd, .03e0c2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2189>
test/lang/initByRef.ci:17:[.03e0c2, .03e0c7) exec(1), time(0 / 0.000 ms): <.main+2194>
test/lang/initByRef.ci:18:[.03e0c7, .03e0d1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2199>
test/lang/initByRef.ci:19:[.03e0d1, .03e0d6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2209>
test/lang/initByRef.ci:20:[.03e0d6, .03e0db) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2214>
test/lang/initByRef.ci:21:[.03e0db, .03e0e0) exec(1), time(0 / 0.000 ms): <.main+2219>
test/lang/initByRef.ci:23:[.03e0e0, .03e0e5) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2224>
test/lang/initByRef.ci:24:[.03e0e5, .03e0ef) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2229>
test/lang/initByRef.ci:25:[.03e0ef, .03e0f4) exec(1), time(0 / 0.000 ms): <.main+2239>
test/lang/initByRef.ci:27:[.03e0f4, .03e0f8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2244>
test/lang/initByRef.ci:28:[.03e0f8, .03e0fa) exec(1), time(0 / 0.000 ms): <.main+2248>
test/lang/initByRef.ci:29:[.03e0fa, .03e0fc) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2250>
test/lang/initByRef.ci:30:[.03e0fc, .03e0fe) exec(1), time(0 / 0.000 ms): <.main+2252>
test/lang/initByRef.ci:31:[.03e0fe, .03e100) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2254>
test/lang/initByRef.ci:32:[.03e100, .03e102) exec(1), time(0 / 0.000 ms): <.main+2256>
test/lang/initByRef.ci:35:[.03e102, .03e107) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2258>
test/lang/initByRef.ci:36:[.03e107, .03e10c) exec(1), time(0 / 0.000 ms): <.main+2263>
test/lang/initByRef.ci:37:[.03e10c, .03e111) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2268>
test/lang/initByRef.ci:38:[.03e111, .03e116) exec(1), time(0 / 0.000 ms): <.main+2273>
test/lang/initByRef.ci:39:[.03e116, .03e11b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2278>
test/lang/initByRef.ci:40:[.03e11b, .03e120) exec(1), time(0 / 0.000 ms): <.main+2283>
test/lang/initByRef.ci:41:[.03e120, .03e125) exec(1), time(0 / 0.000 ms): <.main+2288>
test/lang/initByRef.ci:42:[.03e125, .03e12a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2293>
test/lang/initByRef.ci:43:[.03e12a, .03e12f) exec(1), time(0 / 0.000 ms): <.main+2298>
test/lang/initByRef.ci:44:[.03e12f, .03e134) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2303>
test/lang/initByRef.ci:45:[.03e134, .03e139) exec(1), time(0 / 0.000 ms): <.main+2308>
test/lang/initByRef.ci:46:[.03e139, .03e13e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2313>
test/lang/initByRef.ci:47:[.03e13e, .03e143) exec(1), time(0 / 0.000 ms): <.main+2318>
test/lang/initByRef.ci:48:[.03e143, .03e148) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2323>
test/lang/initByRef.ci:49:[.03e148, .03e14d) exec(1), time(0 / 0.000 ms): <.main+2328>
test/lang/initByRef.ci:50:[.03e14d, .03e152) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2333>
test/lang/initByRef.ci:51:[.03e152, .03e157) exec(1), time(0 / 0.000 ms): <.main+2338>
test/lang/initByRef.ci:52:[.03e157, .03e15c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2343>
test/lang/initByRef.ci:55:[.03e15c, .03e166) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2348>
test/lang/initByRef.ci:56:[.03e166, .03e170) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2358>
test/lang/initByRef.ci:57:[.03e170, .03e17a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2368>
test/lang/initByRef.ci:58:[.03e17a, .03e184) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2378>
test/lang/initByRef.ci:59:[.03e184, .03e18e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2388>
test/lang/initByRef.ci:60:[.03e18e, .03e198) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2398>
test/lang/initByRef.ci:61:[.03e198, .03e1a2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2408>
test/lang/initByRef.ci:62:[.03e1a2, .03e1ac) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2418>
test/lang/initByRef.ci:63:[.03e1ac, .03e1b6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2428>
test/lang/initByRef.ci:64:[.03e1b6, .03e1c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2438>
test/lang/initByRef.ci:65:[.03e1c0, .03e1ca) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2448>
test/lang/initByRef.ci:66:[.03e1ca, .03e1d4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2458>
test/lang/initByRef.ci:67:[.03e1d4, .03e1de) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2468>
test/lang/initByRef.ci:68:[.03e1de, .03e1e8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2478>
test/lang/initByRef.ci:69:[.03e1e8, .03e1f2) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2488>
test/lang/initByRef.ci:70:[.03e1f2, .03e1fc) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2498>
test/lang/initByRef.ci:71:[.03e1fc, .03e206) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2508>
test/lang/initByRef.ci:72:[.03e206, .03e210) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2518>
test/lang/initByRef.ci:75:[.03e210, .03e215) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2528>
test/lang/initByRef.ci:76:[.03e215, .03e21a) exec(1), time(0 / 0.000 ms): <.main+2533>
test/lang/initByRef.ci:77:[.03e21a, .03e21f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2538>
test/lang/initByRef.ci:78:[.03e21f, .03e224) exec(1), time(0 / 0.000 ms): <.main+2543>
test/lang/initByRef.ci:79:[.03e224, .03e229) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2548>
test/lang/initByRef.ci:80:[.03e229, .03e22e) exec(1), time(0 / 0.000 ms): <.main+2553>
test/lang/initByRef.ci:81:[.03e22e, .03e233) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2558>
test/lang/initByRef.ci:82:[.03e233, .03e238) exec(1), time(0 / 0.000 ms): <.main+2563>
test/lang/initByRef.ci:83:[.03e238, .03e23d) exec(1), time(0 / 0.000 ms): <.main+2568>
test/lang/initByRef.ci:84:[.03e23d, .03e242) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2573>
test/lang/initByRef.ci:85:[.03e242, .03e247) exec(1), time(0 / 0.000 ms): <.main+2578>
test/lang/initByRef.ci:86:[.03e247, .03e24c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2583>
test/lang/initByRef.ci:87:[.03e24c, .03e251) exec(1), time(0 / 0.000 ms): <.main+2588>
test/lang/initByRef.ci:88:[.03e251, .03e256) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2593>
test/lang/initByRef.ci:89:[.03e256, .03e25b) exec(1), time(0 / 0.000 ms): <.main+2598>
test/lang/initByRef.ci:90:[.03e25b, .03e260) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2603>
test/lang/initByRef.ci:91:[.03e260, .03e265) exec(1), time(0 / 0.000 ms): <.main+2608>
test/lang/initByRef.ci:92:[.03e265, .03e26a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2613>
test/lang/initByRef.ci:95:[.03e26a, .03e26f) exec(1), time(0 / 0.000 ms): <.main+2618>
test/lang/initByRef.ci:96:[.03e26f, .03e279) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2623>
test/lang/initByRef.ci:97:[.03e279, .03e27e) exec(1), time(0 / 0.000 ms): <.main+2633>
test/lang/initByRef.ci:99:[.03e27e, .03e283) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2638>
test/lang/initByRef.ci:105:[.03e283, .03e28a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2643>
test/lang/initByRef.ci:108:[.03e28a, .03e28c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2650>
test/lang/function.ci:11:[.03e28c, .03e2a1) exec(1), time(37-37 / 0.037-0.037 ms): <.main+2652>
test/lang/function.ci:14:[.03e2a1, .03e2a6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2673>
test/lang/function.ci:17:[.03e2a6, .03e2b8) exec(1), time(28-28 / 0.028-0.028 ms): <.main+2678>
test/lang/function.ci:20:[.03e2b8, .03e2bd) exec(1), time(0 / 0.000 ms): <.main+2696>
test/lang/function.ci:23:[.03e2bd, .03e2cf) exec(1), time(28-28 / 0.028-0.028 ms): <.main+2701>
test/lang/function.ci:26:[.03e2cf, .03e2d1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2719>
test/lang/function.ci:29:[.03e2d1, .03e2e3) exec(1), time(28-28 / 0.028-0.028 ms): <.main+2721>
test/lang/function.ci:45:[.03e2e3, .03e2f3) exec(1), time(19138-19138 / 19.138-19.138 ms): <.main+2739>
test/lang/reflect.ci:3:[.03e2f3, .03e2f7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:4:[.03e2f7, .03e2fb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2759>
test/lang/reflect.ci:5:[.03e2fb, .03e2ff) exec(1), time(0 / 0.000 ms): <.main+2763>
test/lang/reflect.ci:6:[.03e2ff, .03e303) exec(1), time(0 / 0.000 ms): <.main+2767>
test/lang/reflect.ci:7:[.03e303, .03e307) exec(1), time(0 / 0.000 ms): <.main+2771>
test/lang/reflect.ci:8:[.03e307, .03e30b) exec(1), time(0 / 0.000 ms): <.main+2775>
test/lang/reflect.ci:9:[.03e30b, .03e30f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:10:[.03e30f, .03e313) exec(1), time(0 / 0.000 ms): <.main+2783>
test/lang/reflect.ci:11:[.03e313, .03e317) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2787>
test/lang/reflect.ci:12:[.03e317, .03e31b) exec(1), time(0 / 0.000 ms): <.main+2791>
test/lang/reflect.ci:13:[.03e31b, .03e31f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2795>
test/lang/reflect.ci:14:[.03e31f, .03e323) exec(1), time(0 / 0.000 ms): <.main+2799>
test/lang/reflect.ci:15:[.03e323, .03e327) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:16:[.03e327, .03e32b) exec(1), time(0 / 0.000 ms): <.main+2807>
test/lang/reflect.ci:17:[.03e32b, .03e32f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2811>
test/lang/reflect.ci:18:[.03e32f, .03e333) exec(1), time(0 / 0.000 ms): <.main+2815>
test/lang/reflect.ci:19:[.03e333, .03e337) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2819>
test/lang/reflect.ci:20:[.03e337, .03e33b) exec(1), time(0 / 0.000 ms): <.main+2823>
test/lang/reflect.ci:30:[.03e33b, .03e340) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2827>
test/lang/reflect.ci:31:[.03e340, .03e346) exec(1), time(35-35 / 0.035-0.035 ms): <.main+2832>
test/lang/reflect.ci:32:[.03e346, .03e34d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2838>
test/lang/reflect.ci:33:[.03e34d, .03e354) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2845>
test/lang/reflect.ci:34:[.03e354, .03e35a) exec(1), time(25-25 / 0.025-0.025 ms): <.main+2852>
test/lang/reflect.ci:35:[.03e35a, .03e360) exec(1), time(24-24 / 0.024-0.024 ms): <.main+2858>
test/lang/reflect.ci:37:[.03e360, .03e366) exec(1), time(24-24 / 0.024-0.024 ms): <.main+2864>
test/lang/reflect.ci:38:[.03e366, .03e36c) exec(1), time(23-23 / 0.023-0.023 ms): <.main+2870>
test/lang/reflect.ci:39:[.03e36c, .03e373) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2876>
test/lang/reflect.ci:40:[.03e373, .03e37a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2883>
test/lang/reflect.ci:41:[.03e37a, .03e380) exec(1), time(24-24 / 0.024-0.024 ms): <.main+2890>
test/lang/reflect.ci:42:[.03e380, .03e386) exec(1), time(25-25 / 0.025-0.025 ms): <.main+2896>
test/lang/reflect.ci:44:[.03e386, .03e38c) exec(1), time(24-24 / 0.024-0.024 ms): <.main+2902>
test/lang/reflect.ci:45:[.03e38c, .03e393) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2908>
test/lang/reflect.ci:46:[.03e393, .03e39a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2915>
test/lang/reflect.ci:48:[.03e39a, .03e3a0) exec(1), time(24-24 / 0.024-0.024 ms): <.main+2922>
test/lang/reflect.ci:49:[.03e3a0, .03e3a7) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2928>
test/lang/reflect.ci:50:[.03e3a7, .03e3ae) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2935>
test/stdc/number.ci:3:[.03e3ae, .03e3b7) exec(1), time(0 / 0.000 ms): <.main+2942>
test/stdc/number.ci:4:[.03e3b7, .03e3c0) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2951>
test/stdc/number.ci:6:[.03e3c0, .03e3c3) exec(1), time(2-2 / 0.002-0.002 ms): <.main+2960>
test/stdc/number.ci:7:[.03e3c3, .03e3c6) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2963>
test/stdc/number.ci:14:[.03e3c6, .03e3cd) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2966>
test/stdc/number.ci:15:[.03e3cd, .03e3d4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2973>
test/stdc/number.ci:16:[.03e3d4, .03e3db) exec(1), time(1-1 / 0.001-0.001 ms): <.main+2980>
test/stdc/number.ci:18:[.03e3db, .03e3f7) exec(1), time(10-10 / 0.010-0.010 ms): <.main+2987>
test/stdc/number.ci:19:[.03e3f7, .03e411) exec(1), time(9-9 / 0.009-0.009 ms): <.main+3015>
test/stdc/number.ci:21:[.03e411, .03e421) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3041>
test/stdc/number.ci:22:[.03e421, .03e431) exec(1), time(27-27 / 0.027-0.027 ms): <.main+3057>
test/stdc/number.ci:23:[.03e431, .03e43d) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3073>
test/stdc/number.ci:25:[.03e43d, .03e44d) exec(1), time(24-24 / 0.024-0.024 ms): <.main+3085>
test/stdc/number.ci:26:[.03e44d, .03e45d) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3101>
test/stdc/number.ci:27:[.03e45d, .03e469) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3117>
test/stdc/number.ci:29:[.03e469, .03e479) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3129>
test/stdc/number.ci:30:[.03e479, .03e489) exec(1), time(24-24 / 0.024-0.024 ms): <.main+3145>
test/stdc/number.ci:31:[.03e489, .03e495) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3161>
test/stdc/number.ci:33:[.03e495, .03e4a5) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3173>
test/stdc/number.ci:34:[.03e4a5, .03e4b5) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3189>
test/stdc/number.ci:35:[.03e4b5, .03e4c1) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3205>
test/stdc/number.ci:37:[.03e4c1, .03e4d1) exec(1), time(38-38 / 0.038-0.038 ms): <.main+3217>
test/stdc/number.ci:38:[.03e4d1, .03e4e1) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3233>
test/stdc/number.ci:39:[.03e4e1, .03e4f1) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3249>
test/stdc/number.ci:40:[.03e4f1, .03e4fd) exec(1), time(33-33 / 0.033-0.033 ms): <.main+3265>
test/stdc/number.ci:41:[.03e4fd, .03e50a) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3277>
test/stdc/number.ci:42:[.03e50a, .03e51c) exec(1), time(31-31 / 0.031-0.031 ms): <.main+3290>
test/stdc/number.ci:43:[.03e51c, .03e525) exec(1), time(24-24 / 0.024-0.024 ms): <.main+3308>
test/stdc/number.ci:44:[.03e525, .03e534) exec(1), time(28-28 / 0.028-0.028 ms): <.main+3317>
test/stdc/number.ci:46:[.03e534, .03e540) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3332>
test/stdc/number.ci:47:[.03e540, .03e54c) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3344>
test/stdc/number.ci:48:[.03e54c, .03e558) exec(1), time(24-24 / 0.024-0.024 ms): <.main+3356>
test/stdc/number.ci:49:[.03e558, .03e564) exec(1), time(27-27 / 0.027-0.027 ms): <.main+3368>
test/stdc/number.ci:50:[.03e564, .03e56d) exec(1), time(24-24 / 0.024-0.024 ms): <.main+3380>
test/stdc/number.ci:51:[.03e56d, .03e57b) exec(1), time(33-33 / 0.033-0.033 ms): <.main+3389>
test/stdc/number.ci:52:[.03e57b, .03e584) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3403>
test/stdc/number.ci:53:[.03e584, .03e58f) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3412>
test/stdc/memory.ci:7:[.03e58f, .03e59d) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3423>
test/stdc/memory.ci:8:[.03e59d, .03e5ab) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3437>
test/stdc/memory.ci:9:[.03e5ab, .03e5b9) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3451>
test/stdc/memory.ci:10:[.03e5b9, .03e5c7) exec(1), time(29-29 / 0.029-0.029 ms): <.main+3465>
test/stdc/memory.ci:13:[.03e5c7, .03e5d7) exec(1), time(27-27 / 0.027-0.027 ms): <.main+3479>
test/stdc/memory.ci:14:[.03e5d7, .03e5e8) exec(1), time(28-28 / 0.028-0.028 ms): <.main+3495>
test/stdc/memory.ci:17:[.03e5e8, .03e5f3) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3512>
test/stdc/memory.ci:18:[.03e5f3, .03e5fe) exec(1), time(26-26 / 0.026-0.026 ms): <.main+3523>
test/stdc/memory.ci:19:[.03e5fe, .03e609) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3534>
test/stdc/memory.ci:20:[.03e609, .03e614) exec(1), time(25-25 / 0.025-0.025 ms): <.main+3545>
test/stdc/memory.ci:23:[.03e614, .03e61d) exec(1), time(0 / 0.000 ms): <.main+3556>
test/stdc/memory.ci:24:[.03e61d, .03e626) exec(1), time(0 / 0.000 ms): <.main+3565>
test/stdc/memory.ci:26:[.03e626, .03e648) exec(1), time(53-53 / 0.053-0.053 ms): <.main+3574>
test/stdc/memory.ci:27:[.03e648, .03e66a) exec(1), time(49-49 / 0.049-0.049 ms): <.main+3608>
test/stdc/memory.ci:29:[.03e66a, .03e67e) exec(1), time(29-29 / 0.029-0.029 ms): <.main+3642>
test/stdc/memory.ci:30:[.03e67e, .03e68f) exec(1), time(27-27 / 0.027-0.027 ms): <.main+3662>
test/stdc/memory.ci:32:[.03e68f, .03e6b1) exec(1), time(49-49 / 0.049-0.049 ms): <.main+3679>
test/stdc/memory.ci:33:[.03e6b1, .03e6d3) exec(1), time(59-59 / 0.059-0.059 ms): <.main+3713>
test/stdc/tryExec.ci:46:[.03e6d3, .03e6e1) exec(1), time(75-75 / 0.075-0.075 ms): <.main+3747>
test/stdc/tryExec.ci:47:[.03e6e1, .03e6ef) exec(1), time(30-30 / 0.030-0.030 ms): <.main+3761>
test/stdc/tryExec.ci:48:[.03e6ef, .03e6fd) exec(1), time(1626-1626 / 1.626-1.626 ms): <.main+3775>
test/stdc/tryExec.ci:49:[.03e6fd, .03e70b) exec(1), time(50-50 / 0.050-0.050 ms): <.main+3789>
test/stdc/tryExec.ci:50:[.03e70b, .03e719) exec(1), time(50-50 / 0.050-0.050 ms): <.main+3803>
test/stdc/tryExec.ci:51:[.03e719, .03e727) exec(1), time(51-51 / 0.051-0.051 ms): <.main+3817>
test/stdc/tryExec.ci:52:[.03e727, .03e735) exec(1), time(206-206 / 0.206-0.206 ms): <.main+3831>
test/lang/array.ci:49:[.03e735, .03e739) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3845>
test/lang/array.ci:50:[.03e739, .03e73d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3849>
test/lang/array.ci:51:[.03e73d, .03e741) exec(1), time(0 / 0.000 ms): <.main+3853>
test/lang/array.ci:55:[.03e746, .03e75a) exec(7), time(44-44 / 0.044-0.044 ms): <.main+3862>
test/lang/array.ci:54:[.03e75a, .03e75e) exec(7), time(2-2 / 0.002-0.002 ms): <.main+3882>
test/lang/array.ci:54:[.03e75e, .03e76a) exec(8), time(24-24 / 0.024-0.024 ms): <.main+3886>
test/lang/array.ci:54:[.03e741, .03e76e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+3857>
test/lang/array.ci:59:[.03e76e, .03e773) exec(1), time(0 / 0.000 ms): <.main+3902>
test/lang/array.ci:60:[.03e773, .03e779) exec(1), time(2-2 / 0.002-0.002 ms): <.main+3907>
test/lang/array.ci:63:[.03e779, .03e77d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3913>
test/lang/array.ci:64:[.03e77d, .03e786) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3917>
test/lang/array.ci:67:[.03e786, .03e788) exec(1), time(0 / 0.000 ms): <.main+3926>
test/lang/array.ci:68:[.03e788, .03e78a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3928>
test/lang/array.ci:71:[.03e78a, .03e78c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+3930>
test/lang/array.ci:81:[.03e78c, .03e790) exec(1), time(0 / 0.000 ms): <.main+3932>
test/lang/array.ci:82:[.03e790, .03e7a6) exec(1), time(34-34 / 0.034-0.034 ms): <.main+3936>
test/lang/array.ci:83:[.03e7a6, .03e7c8) exec(1), time(119-119 / 0.119-0.119 ms): <.main+3958>
test/lang/array.ci:84:[.03e7c8, .03e7ea) exec(1), time(126-126 / 0.126-0.126 ms): <.main+3992>
test/lang/array.ci:86:[.03e7ea, .03e7ef) exec(1), time(0 / 0.000 ms): <.main+4026>
test/lang/array.ci:87:[.03e7ef, .03e80f) exec(1), time(58-58 / 0.058-0.058 ms): <.main+4031>
test/lang/array.ci:88:[.03e80f, .03e82f) exec(1), time(58-58 / 0.058-0.058 ms): <.main+4063>
test/lang/array.ci:90:[.03e82f, .03e839) exec(1), time(1-1 / 0.001-0.001 ms): <.main+4095>
test/lang/array.ci:91:[.03e839, .03e859) exec(1), time(56-56 / 0.056-0.056 ms): <.main+4105>
test/lang/array.ci:92:[.03e859, .03e879) exec(1), time(56-56 / 0.056-0.056 ms): <.main+4137>
test/lang/array.ci:98:[.03e879, .03e8ac) exec(1), time(4-4 / 0.004-0.004 ms): <.main+4169>
test/lang/array.ci:99:[.03e8ac, .03e8df) exec(1), time(3-3 / 0.003-0.003 ms): <.main+4220>
test/lang/array.ci:101:[.03e8df, .03e91a) exec(1), time(4-4 / 0.004-0.004 ms): <.main+4271>
test/lang/array.ci:108:[.03e91a, .03e933) exec(1), time(31-31 / 0.031-0.031 ms): <.main+4330>
test/lang/array.ci:109:[.03e933, .03e949) exec(1), time(28-28 / 0.028-0.028 ms): <.main+4355>
test/lang/array.ci:110:[.03e949, .03e95f) exec(1), time(28-28 / 0.028-0.028 ms): <.main+4377>
test/lang/array.ci:112:[.03e95f, .03e97f) exec(1), time(57-57 / 0.057-0.057 ms): <.main+4399>
test/lang/array.ci:113:[.03e97f, .03e99c) exec(1), time(56-56 / 0.056-0.056 ms): <.main+4431>
test/lang/array.ci:114:[.03e99c, .03e9c4) exec(1), time(59-59 / 0.059-0.059 ms): <.main+4460>
test/lang/array.ci:115:[.03e9c4, .03e9e5) exec(1), time(57-57 / 0.057-0.057 ms): <.main+4500>
test/lang/array.ci:116:[.03e9e5, .03ea06) exec(1), time(58-58 / 0.058-0.058 ms): <.main+4533>
test/lang/array.ci:119:[.03ea0b, .03ea14) exec(7), time(23-23 / 0.023-0.023 ms): <.main+4571>
test/lang/array.ci:120:[.03ea14, .03ea51) exec(7), time(46-46 / 0.046-0.046 ms): <.main+4580>
test/lang/array.ci:121:[.03ea51, .03ea8c) exec(7), time(42-42 / 0.042-0.042 ms): <.main+4641>
test/lang/array.ci:122:[.03ea8c, .03eac7) exec(7), time(44-44 / 0.044-0.044 ms): <.main+4700>
test/lang/array.ci:124:[.03eac7, .03eb0a) exec(7), time(274-274 / 0.274-0.274 ms): <.main+4759>
test/lang/array.ci:125:[.03eb0a, .03eb4b) exec(7), time(274-274 / 0.274-0.274 ms): <.main+4826>
test/lang/array.ci:126:[.03eb4b, .03eb8c) exec(7), time(258-258 / 0.258-0.258 ms): <.main+4891>
test/lang/array.ci:128:[.03eb8c, .03ebcf) exec(7), time(255-255 / 0.255-0.255 ms): <.main+4956>
test/lang/array.ci:129:[.03ebcf, .03ec10) exec(7), time(255-255 / 0.255-0.255 ms): <.main+5023>
test/lang/array.ci:130:[.03ec10, .03ec51) exec(7), time(257-257 / 0.257-0.257 ms): <.main+5088>
test/lang/array.ci:132:[.03ec51, .03ec99) exec(7), time(266-266 / 0.266-0.266 ms): <.main+5153>
test/lang/array.ci:134:[.03ec99, .03ecda) exec(7), time(250-250 / 0.250-0.250 ms): <.main+5225>
test/lang/array.ci:136:[.03ecda, .03ed15) exec(7), time(48-48 / 0.048-0.048 ms): <.main+5290>
test/lang/array.ci:118:[.03ed19, .03ed1d) exec(7), time(6-6 / 0.006-0.006 ms): <.main+5353>
test/lang/array.ci:118:[.03ed1d, .03ed29) exec(8), time(26-26 / 0.026-0.026 ms): <.main+5357>
test/lang/array.ci:118:[.03ea06, .03ed2d) exec(1), time(5-5 / 0.005-0.005 ms): <.main+4566>
test/lang/member.ci:54:[.03ed31, .03ed38) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5377>
test/lang/member.ci:55:[.03ed38, .03ed3f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5384>
test/lang/member.ci:56:[.03ed3f, .03ed46) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5391>
test/lang/member.ci:57:[.03ed46, .03ed4d) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5398>
test/lang/member.ci:60:[.03ed4d, .03ed54) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5405>
test/lang/member.ci:61:[.03ed54, .03ed5b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5412>
test/lang/member.ci:65:[.03ed5b, .03ed62) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5419>
test/lang/member.ci:66:[.03ed62, .03ed69) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5426>
test/lang/member.ci:53:[.03ed2d, .03ed69) exec(1-1), time(0 / 0.000 ms): <.main+5373>
test/lang/method.ci:54:[.03ed6d, .03ed74) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5437>
test/lang/method.ci:55:[.03ed74, .03ed7b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5444>
::[.03ed7b, .03ed82) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5451>
::[.03ed82, .03ed89) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5458>
test/lang/method.ci:53:[.03ed69, .03ed89) exec(1-1), time(0 / 0.000 ms): <.main+5433>
test/lang/method.ci:64:[.03ed8d, .03ed94) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5469>
test/lang/method.ci:65:[.03ed94, .03ed9b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5476>
::[.03ed9b, .03eda1) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5483>
::[.03eda1, .03eda8) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5489>
test/lang/method.ci:63:[.03ed89, .03eda8) exec(1-1), time(0 / 0.000 ms): <.main+5465>
test/lang/method.ci:69:[.03eda8, .03edb1) exec(1), time(167-167 / 0.167-0.167 ms): <.main+5496>
test/lang/method.ci:70:[.03edb1, .03edba) exec(1), time(161-161 / 0.161-0.161 ms): <.main+5505>
test/lang/method.ci:73:[.03edba, .03edc6) exec(1), time(160-160 / 0.160-0.160 ms): <.main+5514>
test/lang/method.ci:84:[.03edc6, .03edd2) exec(1), time(168-168 / 0.168-0.168 ms): <.main+5526>
test/lang/method.ci:85:[.03edd2, .03edde) exec(1), time(184-184 / 0.184-0.184 ms): <.main+5538>
test/lang/method.ci:86:[.03edde, .03edea) exec(1), time(162-162 / 0.162-0.162 ms): <.main+5550>
test/lang/method.ci:89:[.03edea, .03edf6) exec(1), time(160-160 / 0.160-0.160 ms): <.main+5562>
test/lang/method.ci:90:[.03edf6, .03ee02) exec(1), time(159-159 / 0.159-0.159 ms): <.main+5574>
test/lang/method.ci:91:[.03ee02, .03ee0e) exec(1), time(159-159 / 0.159-0.159 ms): <.main+5586>
test/lang/recUnion.ci:26:[.03ee12, .03ee18) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5602>
test/lang/recUnion.ci:26:[.03ee18, .03ee1e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5608>
test/lang/recUnion.ci:26:[.03ee1e, .03ee24) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5614>
test/lang/recUnion.ci:26:[.03ee0e, .03ee24) exec(1-1), time(0 / 0.000 ms): <.main+5598>
test/lang/recUnion.ci:27:[.03ee28, .03ee2e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5624>
test/lang/recUnion.ci:27:[.03ee2e, .03ee38) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5630>
test/lang/recUnion.ci:27:[.03ee38, .03ee3e) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5640>
test/lang/recUnion.ci:27:[.03ee24, .03ee3e) exec(1-1), time(0 / 0.000 ms): <.main+5620>
test/lang/recUnion.ci:28:[.03ee42, .03ee4c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5650>
test/lang/recUnion.ci:28:[.03ee4c, .03ee56) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5660>
test/lang/recUnion.ci:28:[.03ee56, .03ee60) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:28:[.03ee3e, .03ee60) exec(1-1), time(0 / 0.000 ms): <.main+5646>
test/lang/recUnion.ci:30:[.03ee64, .03ee6b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5684>
test/lang/recUnion.ci:30:[.03ee60, .03ee6b) exec(1-1), time(0 / 0.000 ms): <.main+5680>
test/lang/recUnion.ci:31:[.03ee6f, .03ee75) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5695>
test/lang/recUnion.ci:31:[.03ee75, .03ee7b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5701>
test/lang/recUnion.ci:31:[.03ee7b, .03ee85) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5707>
test/lang/recUnion.ci:31:[.03ee6b, .03ee85) exec(1-1), time(0 / 0.000 ms): <.main+5691>
test/lang/useOperator.ci:5:[.03ee85, .03ee8a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5717>
test/lang/useOperator.ci:7:[.03ee8a, .03ee8f) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5722>
test/lang/useOperator.ci:8:[.03ee8f, .03ee94) exec(1), time(0 / 0.000 ms): <.main+5727>
test/lang/useOperator.ci:17:[.03ee94, .03ee9f) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5732>
test/lang/useOperator.ci:18:[.03ee9f, .03eeaa) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5743>
test/lang/useOperator.ci:19:[.03eeaa, .03eeb5) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5754>
test/lang/useOperator.ci:22:[.03eeb5, .03eebb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5765>
test/lang/useOperator.ci:23:[.03eebb, .03eec6) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5771>
test/lang/useOperator.ci:24:[.03eec6, .03eed2) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5782>
test/lang/useOperator.ci:25:[.03eed2, .03eedd) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5794>
test/lang/useOperator.ci:26:[.03eedd, .03eee9) exec(1), time(6-6 / 0.006-0.006 ms): <.main+5805>
test/lang/useOperator.ci:27:[.03eee9, .03eef4) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5817>
test/lang/useOperator.ci:28:[.03eef4, .03ef00) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5828>
test/lang/useOperator.ci:30:[.03ef00, .03ef05) exec(1), time(0 / 0.000 ms): <.main+5840>
test/lang/useOperator.ci:31:[.03ef05, .03ef0a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+5845>
test/lang/useOperator.ci:32:[.03ef0a, .03ef0f) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5850>
test/lang/useOperator.ci:33:[.03ef0f, .03ef15) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5855>
test/lang/useOperator.ci:34:[.03ef15, .03ef1b) exec(1), time(2-2 / 0.002-0.002 ms): <.main+5861>
test/lang/useOperator.ci:35:[.03ef1b, .03ef26) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5867>
test/lang/useOperator.ci:36:[.03ef26, .03ef31) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5878>
test/lang/useOperator.ci:37:[.03ef31, .03ef3c) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5889>
test/lang/useOperator.ci:38:[.03ef3c, .03ef47) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5900>
test/lang/useOperator.ci:39:[.03ef47, .03ef52) exec(1), time(5-5 / 0.005-0.005 ms): <.main+5911>
test/lang/useOperator.ci:40:[.03ef52, .03ef5d) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5922>
test/lang/useOperator.ci:41:[.03ef5d, .03ef68) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5933>
test/lang/useOperator.ci:42:[.03ef68, .03ef73) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5944>
test/lang/useOperator.ci:43:[.03ef73, .03ef7b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5955>
test/lang/useOperator.ci:44:[.03ef7b, .03ef83) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5963>
test/lang/useOperator.ci:45:[.03ef83, .03ef8a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+5971>
test/lang/useOperator.ci:46:[.03ef8a, .03ef95) exec(1), time(4-4 / 0.004-0.004 ms): <.main+5978>
test/lang/useOperator.ci:47:[.03ef95, .03efa1) exec(1), time(6-6 / 0.006-0.006 ms): <.main+5989>
test/lang/useOperator.ci:48:[.03efa1, .03efac) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6001>
test/lang/useOperator.ci:49:[.03efac, .03efb8) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6012>
test/lang/useOperator.ci:50:[.03efb8, .03efc3) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6024>
test/lang/useOperator.ci:51:[.03efc3, .03efcf) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6035>
test/lang/useOperator.ci:53:[.03efcf, .03efd4) exec(1), time(0 / 0.000 ms): <.main+6047>
test/lang/useOperator.ci:54:[.03efd4, .03efd9) exec(1), time(0 / 0.000 ms): <.main+6052>
test/lang/useOperator.ci:55:[.03efd9, .03efde) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6057>
test/lang/useOperator.ci:56:[.03efde, .03efe4) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6062>
test/lang/useOperator.ci:57:[.03efe4, .03efea) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6068>
test/lang/useOperator.ci:58:[.03efea, .03eff5) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6074>
test/lang/useOperator.ci:59:[.03eff5, .03f000) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6085>
test/lang/useOperator.ci:60:[.03f000, .03f00b) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6096>
test/lang/useOperator.ci:61:[.03f00b, .03f016) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6107>
test/lang/useOperator.ci:62:[.03f016, .03f021) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6118>
test/lang/useOperator.ci:63:[.03f021, .03f02c) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6129>
test/lang/useOperator.ci:64:[.03f02c, .03f037) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6140>
test/lang/useOperator.ci:65:[.03f037, .03f042) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6151>
test/lang/useOperator.ci:66:[.03f042, .03f04a) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6162>
test/lang/useOperator.ci:67:[.03f04a, .03f052) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6170>
test/lang/useOperator.ci:68:[.03f052, .03f059) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6178>
test/lang/useOperator.ci:69:[.03f059, .03f064) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6185>
test/lang/useOperator.ci:70:[.03f064, .03f070) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6196>
test/lang/useOperator.ci:71:[.03f070, .03f07b) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6208>
test/lang/useOperator.ci:72:[.03f07b, .03f087) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6219>
test/lang/useOperator.ci:73:[.03f087, .03f092) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6231>
test/lang/useOperator.ci:74:[.03f092, .03f09e) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6242>
test/lang/useOperator.ci:76:[.03f09e, .03f0a3) exec(1), time(0 / 0.000 ms): <.main+6254>
test/lang/useOperator.ci:77:[.03f0a3, .03f0a8) exec(1), time(0 / 0.000 ms): <.main+6259>
test/lang/useOperator.ci:78:[.03f0a8, .03f0ad) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6264>
test/lang/useOperator.ci:79:[.03f0ad, .03f0b3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6269>
test/lang/useOperator.ci:80:[.03f0b3, .03f0b9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6275>
test/lang/useOperator.ci:81:[.03f0b9, .03f0c4) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6281>
test/lang/useOperator.ci:82:[.03f0c4, .03f0cf) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6292>
test/lang/useOperator.ci:83:[.03f0cf, .03f0da) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6303>
test/lang/useOperator.ci:84:[.03f0da, .03f0e5) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6314>
test/lang/useOperator.ci:85:[.03f0e5, .03f0f0) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6325>
test/lang/useOperator.ci:86:[.03f0f0, .03f0fb) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6336>
test/lang/useOperator.ci:87:[.03f0fb, .03f106) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6347>
test/lang/useOperator.ci:88:[.03f106, .03f111) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6358>
test/lang/useOperator.ci:89:[.03f111, .03f119) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6369>
test/lang/useOperator.ci:90:[.03f119, .03f121) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6377>
test/lang/useOperator.ci:91:[.03f121, .03f128) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6385>
test/lang/useOperator.ci:92:[.03f128, .03f133) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6392>
test/lang/useOperator.ci:93:[.03f133, .03f13f) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6403>
test/lang/useOperator.ci:94:[.03f13f, .03f14a) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6415>
test/lang/useOperator.ci:95:[.03f14a, .03f156) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6426>
test/lang/useOperator.ci:96:[.03f156, .03f161) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6438>
test/lang/useOperator.ci:97:[.03f161, .03f16d) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6449>
test/lang/useOperator.ci:99:[.03f16d, .03f172) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6461>
test/lang/useOperator.ci:100:[.03f172, .03f177) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6466>
test/lang/useOperator.ci:101:[.03f177, .03f17c) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6471>
test/lang/useOperator.ci:102:[.03f17c, .03f182) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6476>
test/lang/useOperator.ci:103:[.03f182, .03f188) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6482>
test/lang/useOperator.ci:104:[.03f188, .03f193) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6488>
test/lang/useOperator.ci:105:[.03f193, .03f19e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6499>
test/lang/useOperator.ci:106:[.03f19e, .03f1a9) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6510>
test/lang/useOperator.ci:107:[.03f1a9, .03f1b4) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6521>
test/lang/useOperator.ci:108:[.03f1b4, .03f1bf) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6532>
test/lang/useOperator.ci:109:[.03f1bf, .03f1ca) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6543>
test/lang/useOperator.ci:110:[.03f1ca, .03f1d5) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6554>
test/lang/useOperator.ci:111:[.03f1d5, .03f1e0) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6565>
test/lang/useOperator.ci:112:[.03f1e0, .03f1e8) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6576>
test/lang/useOperator.ci:113:[.03f1e8, .03f1f0) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6584>
test/lang/useOperator.ci:114:[.03f1f0, .03f1f7) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6592>
test/lang/useOperator.ci:115:[.03f1f7, .03f202) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6599>
test/lang/useOperator.ci:116:[.03f202, .03f20e) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6610>
test/lang/useOperator.ci:117:[.03f20e, .03f219) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6622>
test/lang/useOperator.ci:118:[.03f219, .03f225) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6633>
test/lang/useOperator.ci:119:[.03f225, .03f230) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6645>
test/lang/useOperator.ci:120:[.03f230, .03f23c) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6656>
test/lang/useOperator.ci:122:[.03f23c, .03f241) exec(1), time(0 / 0.000 ms): <.main+6668>
test/lang/useOperator.ci:123:[.03f241, .03f246) exec(1), time(0 / 0.000 ms): <.main+6673>
test/lang/useOperator.ci:124:[.03f246, .03f24b) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6678>
test/lang/useOperator.ci:125:[.03f24b, .03f251) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6683>
test/lang/useOperator.ci:126:[.03f251, .03f257) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6689>
test/lang/useOperator.ci:127:[.03f257, .03f262) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6695>
test/lang/useOperator.ci:128:[.03f262, .03f26d) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6706>
test/lang/useOperator.ci:129:[.03f26d, .03f278) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6717>
test/lang/useOperator.ci:130:[.03f278, .03f283) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6728>
test/lang/useOperator.ci:131:[.03f283, .03f28e) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6739>
test/lang/useOperator.ci:132:[.03f28e, .03f299) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6750>
test/lang/useOperator.ci:133:[.03f299, .03f2a4) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6761>
test/lang/useOperator.ci:134:[.03f2a4, .03f2af) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6772>
test/lang/useOperator.ci:135:[.03f2af, .03f2b7) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6783>
test/lang/useOperator.ci:136:[.03f2b7, .03f2bf) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6791>
test/lang/useOperator.ci:137:[.03f2bf, .03f2c6) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6799>
test/lang/useOperator.ci:138:[.03f2c6, .03f2d1) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6806>
test/lang/useOperator.ci:139:[.03f2d1, .03f2dd) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6817>
test/lang/useOperator.ci:140:[.03f2dd, .03f2e8) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6829>
test/lang/useOperator.ci:141:[.03f2e8, .03f2f4) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6840>
test/lang/useOperator.ci:142:[.03f2f4, .03f2ff) exec(1), time(5-5 / 0.005-0.005 ms): <.main+6852>
test/lang/useOperator.ci:143:[.03f2ff, .03f30b) exec(1), time(6-6 / 0.006-0.006 ms): <.main+6863>
test/lang/useOperator.ci:145:[.03f30b, .03f310) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6875>
test/lang/useOperator.ci:146:[.03f310, .03f315) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6880>
test/lang/useOperator.ci:147:[.03f315, .03f317) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6885>
test/lang/useOperator.ci:148:[.03f317, .03f31a) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6887>
test/lang/useOperator.ci:149:[.03f31a, .03f31d) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6890>
test/lang/useOperator.ci:150:[.03f31d, .03f322) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6893>
test/lang/useOperator.ci:151:[.03f322, .03f327) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6898>
test/lang/useOperator.ci:152:[.03f327, .03f32c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6903>
test/lang/useOperator.ci:153:[.03f32c, .03f331) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6908>
test/lang/useOperator.ci:154:[.03f331, .03f336) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6913>
test/lang/useOperator.ci:155:[.03f336, .03f33b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6918>
test/lang/useOperator.ci:156:[.03f33b, .03f340) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6923>
test/lang/useOperator.ci:157:[.03f340, .03f345) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6928>
test/lang/useOperator.ci:158:[.03f345, .03f34a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6933>
test/lang/useOperator.ci:159:[.03f34a, .03f34f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6938>
test/lang/useOperator.ci:160:[.03f34f, .03f353) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6943>
test/lang/useOperator.ci:161:[.03f353, .03f358) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6947>
test/lang/useOperator.ci:162:[.03f358, .03f35e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6952>
test/lang/useOperator.ci:163:[.03f35e, .03f363) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6958>
test/lang/useOperator.ci:164:[.03f363, .03f369) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6963>
test/lang/useOperator.ci:165:[.03f369, .03f36e) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6969>
test/lang/useOperator.ci:166:[.03f36e, .03f374) exec(1), time(4-4 / 0.004-0.004 ms): <.main+6974>
test/lang/useOperator.ci:168:[.03f374, .03f379) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6980>
test/lang/useOperator.ci:169:[.03f379, .03f37e) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6985>
test/lang/useOperator.ci:170:[.03f37e, .03f380) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6990>
test/lang/useOperator.ci:171:[.03f380, .03f383) exec(1), time(2-2 / 0.002-0.002 ms): <.main+6992>
test/lang/useOperator.ci:172:[.03f383, .03f386) exec(1), time(1-1 / 0.001-0.001 ms): <.main+6995>
test/lang/useOperator.ci:173:[.03f386, .03f38b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+6998>
test/lang/useOperator.ci:174:[.03f38b, .03f390) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7003>
test/lang/useOperator.ci:175:[.03f390, .03f395) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7008>
test/lang/useOperator.ci:176:[.03f395, .03f39a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7013>
test/lang/useOperator.ci:177:[.03f39a, .03f39f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7018>
test/lang/useOperator.ci:178:[.03f39f, .03f3a4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7023>
test/lang/useOperator.ci:179:[.03f3a4, .03f3a9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7028>
test/lang/useOperator.ci:180:[.03f3a9, .03f3ae) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7033>
test/lang/useOperator.ci:181:[.03f3ae, .03f3b3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7038>
test/lang/useOperator.ci:182:[.03f3b3, .03f3b8) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7043>
test/lang/useOperator.ci:183:[.03f3b8, .03f3bc) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7048>
test/lang/useOperator.ci:184:[.03f3bc, .03f3c1) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7052>
test/lang/useOperator.ci:185:[.03f3c1, .03f3c7) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7057>
test/lang/useOperator.ci:186:[.03f3c7, .03f3cc) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7063>
test/lang/useOperator.ci:187:[.03f3cc, .03f3d2) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7068>
test/lang/useOperator.ci:188:[.03f3d2, .03f3d7) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7074>
test/lang/useOperator.ci:189:[.03f3d7, .03f3dd) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7079>
test/lang/useOperator.ci:191:[.03f3dd, .03f3e6) exec(1), time(0 / 0.000 ms): <.main+7085>
test/lang/useOperator.ci:192:[.03f3e6, .03f3ef) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7094>
test/lang/useOperator.ci:193:[.03f3ef, .03f3f1) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7103>
test/lang/useOperator.ci:194:[.03f3f1, .03f3f4) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7105>
test/lang/useOperator.ci:195:[.03f3f4, .03f3f7) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7108>
test/lang/useOperator.ci:196:[.03f3f7, .03f3fc) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7111>
test/lang/useOperator.ci:197:[.03f3fc, .03f401) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7116>
test/lang/useOperator.ci:198:[.03f401, .03f406) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7121>
test/lang/useOperator.ci:199:[.03f406, .03f40b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7126>
test/lang/useOperator.ci:200:[.03f40b, .03f410) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7131>
test/lang/useOperator.ci:201:[.03f410, .03f415) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7136>
test/lang/useOperator.ci:202:[.03f415, .03f41a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7141>
test/lang/useOperator.ci:203:[.03f41a, .03f41f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7146>
test/lang/useOperator.ci:204:[.03f41f, .03f424) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7151>
test/lang/useOperator.ci:205:[.03f424, .03f429) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7156>
test/lang/useOperator.ci:206:[.03f429, .03f42d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7161>
test/lang/useOperator.ci:207:[.03f42d, .03f432) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7165>
test/lang/useOperator.ci:208:[.03f432, .03f438) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7170>
test/lang/useOperator.ci:209:[.03f438, .03f43d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7176>
test/lang/useOperator.ci:210:[.03f43d, .03f443) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7181>
test/lang/useOperator.ci:211:[.03f443, .03f448) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7187>
test/lang/useOperator.ci:212:[.03f448, .03f44e) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7192>
test/lang/useOperator.ci:214:[.03f44e, .03f457) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7198>
test/lang/useOperator.ci:215:[.03f457, .03f460) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7207>
test/lang/useOperator.ci:216:[.03f460, .03f462) exec(1), time(0 / 0.000 ms): <.main+7216>
test/lang/useOperator.ci:217:[.03f462, .03f465) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7218>
test/lang/useOperator.ci:218:[.03f465, .03f468) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7221>
test/lang/useOperator.ci:219:[.03f468, .03f46d) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7224>
test/lang/useOperator.ci:220:[.03f46d, .03f472) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7229>
test/lang/useOperator.ci:221:[.03f472, .03f477) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7234>
test/lang/useOperator.ci:222:[.03f477, .03f47c) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7239>
test/lang/useOperator.ci:223:[.03f47c, .03f481) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7244>
test/lang/useOperator.ci:224:[.03f481, .03f486) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7249>
test/lang/useOperator.ci:225:[.03f486, .03f48b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7254>
test/lang/useOperator.ci:226:[.03f48b, .03f490) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7259>
test/lang/useOperator.ci:227:[.03f490, .03f495) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7264>
test/lang/useOperator.ci:228:[.03f495, .03f49a) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7269>
test/lang/useOperator.ci:229:[.03f49a, .03f49e) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7274>
test/lang/useOperator.ci:230:[.03f49e, .03f4a3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7278>
test/lang/useOperator.ci:231:[.03f4a3, .03f4a9) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7283>
test/lang/useOperator.ci:232:[.03f4a9, .03f4ae) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7289>
test/lang/useOperator.ci:233:[.03f4ae, .03f4b4) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7294>
test/lang/useOperator.ci:234:[.03f4b4, .03f4b9) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7300>
test/lang/useOperator.ci:235:[.03f4b9, .03f4bf) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7305>
test/lang/useOperator.ci:237:[.03f4bf, .03f4c4) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7311>
test/lang/useOperator.ci:238:[.03f4c4, .03f4c9) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7316>
test/lang/useOperator.ci:239:[.03f4c9, .03f4cb) exec(1), time(0 / 0.000 ms): <.main+7321>
test/lang/useOperator.ci:240:[.03f4cb, .03f4ce) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7323>
test/lang/useOperator.ci:242:[.03f4ce, .03f4d3) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7326>
test/lang/useOperator.ci:243:[.03f4d3, .03f4d8) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7331>
test/lang/useOperator.ci:244:[.03f4d8, .03f4dd) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7336>
test/lang/useOperator.ci:245:[.03f4dd, .03f4e2) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7341>
test/lang/useOperator.ci:246:[.03f4e2, .03f4e7) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7346>
test/lang/useOperator.ci:252:[.03f4e7, .03f4eb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7351>
test/lang/useOperator.ci:253:[.03f4eb, .03f4f0) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7355>
test/lang/useOperator.ci:254:[.03f4f0, .03f4f6) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7360>
test/lang/useOperator.ci:255:[.03f4f6, .03f4fb) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7366>
test/lang/useOperator.ci:256:[.03f4fb, .03f501) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7371>
test/lang/useOperator.ci:257:[.03f501, .03f506) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7377>
test/lang/useOperator.ci:258:[.03f506, .03f50c) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7382>
test/lang/useOperator.ci:260:[.03f50c, .03f515) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7388>
test/lang/useOperator.ci:261:[.03f515, .03f51e) exec(1), time(0 / 0.000 ms): <.main+7397>
test/lang/useOperator.ci:262:[.03f51e, .03f520) exec(1), time(0 / 0.000 ms): <.main+7406>
test/lang/useOperator.ci:263:[.03f520, .03f523) exec(1), time(2-2 / 0.002-0.002 ms): <.main+7408>
test/lang/useOperator.ci:265:[.03f523, .03f528) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7411>
test/lang/useOperator.ci:266:[.03f528, .03f52d) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7416>
test/lang/useOperator.ci:267:[.03f52d, .03f532) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7421>
test/lang/useOperator.ci:268:[.03f532, .03f537) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7426>
test/lang/useOperator.ci:269:[.03f537, .03f53c) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7431>
test/lang/useOperator.ci:275:[.03f53c, .03f540) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7436>
test/lang/useOperator.ci:276:[.03f540, .03f545) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7440>
test/lang/useOperator.ci:277:[.03f545, .03f54b) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7445>
test/lang/useOperator.ci:278:[.03f54b, .03f550) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7451>
test/lang/useOperator.ci:279:[.03f550, .03f556) exec(1), time(4-4 / 0.004-0.004 ms): <.main+7456>
test/lang/useOperator.ci:280:[.03f556, .03f55b) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7462>
test/lang/useOperator.ci:281:[.03f55b, .03f561) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7467>
test/lang/useOperator.ci:283:[.03f561, .03f566) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7473>
test/lang/useOperator.ci:284:[.03f566, .03f56a) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7478>
test/lang/useOperator.ci:299:[.03f56a, .03f56f) exec(1), time(3-3 / 0.003-0.003 ms): <.main+7482>
test/lang/useOperator.ci:300:[.03f56f, .03f575) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7487>
test/lang/statementIf.ci:4:[.03f575, .03f59c) exec(1), time(66-66 / 0.066-0.066 ms): <.main+7493>
test/lang/statementIf.ci:12:[.03f59c, .03f5c3) exec(1), time(56-56 / 0.056-0.056 ms): <.main+7532>
test/lang/statementIf.ci:22:[.03f5c3, .03f5ea) exec(1), time(56-56 / 0.056-0.056 ms): <.main+7571>
test/lang/statementIf.ci:26:[.03f5ea, .03f5eb) exec(1), time(1-1 / 0.001-0.001 ms): <.main+7610>
test/lang/statementIf.ci:29:[.03f5f3, .03f619) exec(1), time(64-64 / 0.064-0.064 ms): <.main+7619>
test/lang/statementIf.ci:28:[.03f5eb, .03f619) exec(1-1), time(0 / 0.000 ms): <.main+7611>
test/lang/statementIf.ci:33:[.03f621, .03f647) exec(0), time(0 / 0.000 ms): <.main+7665>
test/lang/statementIf.ci:32:[.03f619, .03f647) exec(1), time(5-5 / 0.005-0.005 ms): <.main+7657>
test/lang/statementIf.ci:37:[.03f64f, .03f675) exec(1), time(63-63 / 0.063-0.063 ms): <.main+7711>
test/lang/statementIf.ci:40:[.03f679, .03f69f) exec(0), time(0 / 0.000 ms): <.main+7753>
test/lang/statementIf.ci:36:[.03f647, .03f69f) exec(1), time(66-66 / 0.066-0.066 ms): <.main+7703>
test/lang/statementIf.ci:44:[.03f6a7, .03f6cd) exec(0), time(0 / 0.000 ms): <.main+7799>
test/lang/statementIf.ci:47:[.03f6d1, .03f6f7) exec(1), time(64-64 / 0.064-0.064 ms): <.main+7841>
test/lang/statementIf.ci:43:[.03f69f, .03f6f7) exec(1-1), time(0 / 0.000 ms): <.main+7791>
test/lang/statementIf.ci:51:[.03f6ff, .03f725) exec(1), time(72-72 / 0.072-0.072 ms): <.main+7887>
test/lang/statementIf.ci:54:[.03f735, .03f75b) exec(0), time(0 / 0.000 ms): <.main+7941>
test/lang/statementIf.ci:57:[.03f76b, .03f791) exec(0), time(0 / 0.000 ms): <.main+7995>
test/lang/statementIf.ci:60:[.03f7a1, .03f7c7) exec(0), time(0 / 0.000 ms): <.main+8049>
test/lang/statementIf.ci:63:[.03f7d7, .03f7fd) exec(0), time(0 / 0.000 ms): <.main+8103>
test/lang/statementIf.ci:66:[.03f80d, .03f833) exec(0), time(0 / 0.000 ms): <.main+8157>
test/lang/statementIf.ci:69:[.03f837, .03f85d) exec(0), time(0 / 0.000 ms): <.main+8199>
test/lang/statementIf.ci:65:[.03f801, .03f85d) exec(0), time(0 / 0.000 ms): <.main+8145>
test/lang/statementIf.ci:62:[.03f7cb, .03f85d) exec(0), time(0 / 0.000 ms): <.main+8091>
test/lang/statementIf.ci:59:[.03f795, .03f85d) exec(0), time(0 / 0.000 ms): <.main+8037>
test/lang/statementIf.ci:56:[.03f75f, .03f85d) exec(0), time(0 / 0.000 ms): <.main+7983>
test/lang/statementIf.ci:53:[.03f729, .03f85d) exec(0), time(0 / 0.000 ms): <.main+7929>
test/lang/statementIf.ci:50:[.03f6f7, .03f85d) exec(1), time(75-75 / 0.075-0.075 ms): <.main+7879>
test/lang/statementFor.ci:4:[.03f861, .03f884) exec(1), time(49-49 / 0.049-0.049 ms): <.main+8241>
test/lang/statementFor.ci:5:[.03f884, .03f888) exec(1), time(0 / 0.000 ms): <.main+8276>
::[.03f888, .03f88c) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8280>
test/lang/statementFor.ci:3:[.03f85d, .03f88c) exec(1-1), time(0 / 0.000 ms): <.main+8237>
test/lang/statementFor.ci:9:[.03f891, .03f8b3) exec(2), time(111-111 / 0.111-0.111 ms): <.main+8289>
test/lang/statementFor.ci:8:[.03f8b3, .03f8b7) exec(2), time(2-2 / 0.002-0.002 ms): <.main+8323>
test/lang/statementFor.ci:8:[.03f8b7, .03f8c3) exec(3), time(14-14 / 0.014-0.014 ms): <.main+8327>
test/lang/statementFor.ci:8:[.03f88c, .03f8c7) exec(1), time(7-7 / 0.007-0.007 ms): <.main+8284>
test/lang/statementFor.ci:12:[.03f8c7, .03f8c8) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8343>
test/lang/statementFor.ci:14:[.03f8cf, .03f8f1) exec(2), time(113-113 / 0.113-0.113 ms): <.main+8351>
test/lang/statementFor.ci:13:[.03f8f1, .03f8f5) exec(2), time(0 / 0.000 ms): <.main+8385>
test/lang/statementFor.ci:13:[.03f8f5, .03f901) exec(3), time(15-15 / 0.015-0.015 ms): <.main+8389>
test/lang/statementFor.ci:13:[.03f8c8, .03f901) exec(1-1), time(0 / 0.000 ms): <.main+8344>
test/lang/statementFor.ci:19:[.03f912, .03f916) exec(2), time(0 / 0.000 ms): <.main+8418>
test/lang/statementFor.ci:18:[.03f906, .03f916) exec(7-2), time(22-22 / 0.022-0.022 ms): <.main+8406>
test/lang/statementFor.ci:21:[.03f916, .03f938) exec(5), time(304-304 / 0.304-0.304 ms): <.main+8422>
test/lang/statementFor.ci:17:[.03f938, .03f93c) exec(7), time(5-5 / 0.005-0.005 ms): <.main+8456>
test/lang/statementFor.ci:17:[.03f93c, .03f948) exec(8), time(39-39 / 0.039-0.039 ms): <.main+8460>
test/lang/statementFor.ci:17:[.03f901, .03f94c) exec(1), time(7-7 / 0.007-0.007 ms): <.main+8401>
test/lang/statementFor.ci:26:[.03f95d, .03f961) exec(1), time(1-1 / 0.001-0.001 ms): <.main+8493>
test/lang/statementFor.ci:25:[.03f951, .03f961) exec(4-1), time(12-12 / 0.012-0.012 ms): <.main+8481>
test/lang/statementFor.ci:28:[.03f961, .03f983) exec(3), time(170-170 / 0.170-0.170 ms): <.main+8497>
test/lang/statementFor.ci:24:[.03f983, .03f987) exec(3), time(2-2 / 0.002-0.002 ms): <.main+8531>
test/lang/statementFor.ci:24:[.03f987, .03f993) exec(4), time(19-19 / 0.019-0.019 ms): <.main+8535>
test/lang/statementFor.ci:24:[.03f94c, .03f997) exec(1), time(2-2 / 0.002-0.002 ms): <.main+8476>

---------- Exitcode: 0, time: 31.550 ms
