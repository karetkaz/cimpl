
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:50: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:71: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:72: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:73: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:70: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:58: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:80: warn: empty statement `;`
lib/stdlib.ci:85: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:86: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:88: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:89: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:90: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:3: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:64: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:70: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:43: warn: no code will be generated for statement: 0
lib/stdlib.ci:43: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
test/lang/method.ci:58: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@005f68>, cast: static const inline)
.field file: function (size: 0, offs: <@006168>, cast: static const inline)
.field line: function (size: 0, offs: <@006368>, cast: static const inline)
.field name: function (size: 0, offs: <@006568>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:83: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal usages: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:83: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005f68>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006168>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006368>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006568>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:68: referenced as `void`
	test/lang/method.ci:62: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:30: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:19: referenced as `void`
	test/lang/method.ci:15: referenced as `void`
	test/lang/method.ci:11: referenced as `void`
	test/lang/method.ci:6: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:66: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:47: referenced as `bool`
	lib/stdlib.ci:45: referenced as `bool`
	lib/stdlib.ci:43: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:66: referenced as `char`
	lib/stdlib.ci:61: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:43: referenced as `char`
	lib/stdlib.ci:38: referenced as `char`
	lib/stdlib.ci:36: referenced as `char`
	lib/stdlib.ci:33: referenced as `char`
	lib/stdlib.ci:31: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:26: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:16: referenced as `char`
	lib/stdlib.ci:13: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:68: referenced as `int32`
	test/lang/method.ci:62: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:30: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:19: referenced as `int32`
	test/lang/method.ci:15: referenced as `int32`
	test/lang/method.ci:11: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:83: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0091a8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0094d8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0096d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0098d8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ad8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009cd8>, cast: static const inline)
.field hib: function (size: 0, offs: <@009ed8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a0d8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091a8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0094d8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098d8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ad8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009cd8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ed8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0d8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a400>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a728>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a400>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a728>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00a928>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ab28>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ad28>, cast: static const inline)
.field log: function (size: 0, offs: <@00af28>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b128>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b3c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b5c0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b858>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a928>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab28>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad28>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af28>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b128>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b3c0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5c0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b858>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00ba50>, cast: static const inline)
.field cos: function (size: 0, offs: <@00bc48>, cast: static const inline)
.field tan: function (size: 0, offs: <@00be40>, cast: static const inline)
.field log: function (size: 0, offs: <@00c038>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c230>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c4c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c6b8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c948>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba50>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc48>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be40>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c038>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c230>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c4c0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6b8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c948>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007880>, cast: static const inline)
.field fill: function (size: 0, offs: <@007bb8>, cast: static const inline)
.field copy: function (size: 0, offs: <@007ef0>, cast: static const inline)
.field move: function (size: 0, offs: <@008220>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007880>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bb8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007ef0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008220>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:58: referenced as `variant`
	lib/stdlib.ci:55: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:43: referenced as `variant`
	lib/stdlib.ci:36: referenced as `variant`
	lib/stdlib.ci:31: referenced as `variant`
	lib/stdlib.ci:26: referenced as `variant`
	lib/stdlib.ci:21: referenced as `variant`
	lib/stdlib.ci:16: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:6: referenced as `variant`
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:70: referenced as `null`
	test/lang/method.ci:64: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:78: referenced as `null`
	lib/stdlib.ci:61: referenced as `null`
	lib/stdlib.ci:58: referenced as `null`
	lib/stdlib.ci:40: referenced as `null`
	lib/stdlib.ci:38: referenced as `null`
	lib/stdlib.ci:33: referenced as `null`
	lib/stdlib.ci:28: referenced as `null`
	lib/stdlib.ci:23: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:13: referenced as `null`
	lib/stdlib.ci:8: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.usages:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.usages:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@001058>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@0010f8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0014b8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001558>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0017d8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001d78>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@0022f0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0024c0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002690>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002860>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002a30>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002d30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@003180>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@0035b0>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0039e0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f40>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044a0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0048d0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004d00>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005130>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005560>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005730>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0014b8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001558>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0017d8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001d78>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022f0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0024c0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002690>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002860>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a30>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002d30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003180>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0035b0>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0039e0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f40>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044a0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048d0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004d00>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005130>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005560>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005730>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005c20>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d00>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(5)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:75: referenced as `abort`
	lib/stdlib.ci:40: referenced as `abort`
	lib/stdlib.ci:38: referenced as `abort`
	lib/stdlib.ci:36: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:33: referenced as `error`
	lib/stdlib.ci:31: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:28: referenced as `warn`
	lib/stdlib.ci:26: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:23: referenced as `info`
	lib/stdlib.ci:21: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:18: referenced as `debug`
	lib/stdlib.ci:16: referenced as `debug`
	lib/stdlib.ci:13: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:8: referenced as `verbose`
	lib/stdlib.ci:6: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:28: referenced as `noTrace`
	lib/stdlib.ci:26: referenced as `noTrace`
	lib/stdlib.ci:23: referenced as `noTrace`
	lib/stdlib.ci:21: referenced as `noTrace`
	lib/stdlib.ci:13: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:8: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:75: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:38: referenced as `defTrace`
	lib/stdlib.ci:36: referenced as `defTrace`
	lib/stdlib.ci:33: referenced as `defTrace`
	lib/stdlib.ci:31: referenced as `defTrace`
	lib/stdlib.ci:18: referenced as `defTrace`
	lib/stdlib.ci:16: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0075e0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008250>
.name: 'System'
.field exit: function (size: 0, offs: <@0084c8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0086d0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008838>, cast: static const inline)
.field time: function (size: 0, offs: <@0089a0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008b08>, cast: static const inline)
.field millis: function (size: 0, offs: <@008c70>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008e70>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084c8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008838>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b08>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c70>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e70>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.usages:
	internal usages: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:6: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:8: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:13'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:69: referenced as `debug`
	test/lang/method.ci:63: referenced as `debug`
	lib/stdlib.ci:13: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:31: referenced as `trace`
	test/lang/method.ci:26: referenced as `trace`
	test/lang/method.ci:7: referenced as `trace`
	lib/stdlib.ci:16: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:18: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:21: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:23: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:26: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:28: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:31: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:33'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:33: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:43: referenced as `abort`
	lib/stdlib.ci:36: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
	lib/stdlib.ci:38: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:40: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:43: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:45: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:47: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00fbe0>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:50'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:70: referenced as `NotEquals`
	lib/stdlib.ci:50: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:52'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:71: referenced as `expected`
	lib/stdlib.ci:52: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:55'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:72: referenced as `returned`
	lib/stdlib.ci:55: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:58'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:58: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:73: referenced as `message`
	lib/stdlib.ci:61: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@04fc98>
.name: 'assertEq'
.file: 'lib/stdlib.ci:66'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@04fc98> - <@04fcf6>)
	lib/stdlib.ci:67: (10 bytes: <@04fc98> - <@04fca2>): if (bool(returned == expected))
	<assertEq @04fc98>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @04fc9a>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @04fc9c>    : 57                         ceq.i32
	<assertEq+5 @04fc9d>    : 06 05 00 00                jz <assertEq+10 @04fca2>
	lib/stdlib.ci:68: (1 byte: <@04fca1> - <@04fca2>): return;
	<assertEq+9 @04fca1>    : 03                         ret
	lib/stdlib.ci:70: (41 bytes: <@04fca2> - <@04fccb>): details: NotEquals := {...}
	<assertEq+10 @04fca2>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:71: (11 bytes: <@04fca6> - <@04fcb1>): void(details.expected := (expected));
	<assertEq+14 @04fca6>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @04fcab>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @04fcaf>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:72: (11 bytes: <@04fcb1> - <@04fcbc>): void(details.returned := (returned));
	<assertEq+25 @04fcb1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @04fcb6>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @04fcba>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:73: (3 bytes: <@04fcbc> - <@04fcbf>): void(details.message := (message));
	<assertEq+36 @04fcbc>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@04fcbf> - <@04fccb>): void(details.argument := (null))
	<assertEq+39 @04fcbf>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @04fcc4>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @04fcc9>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:75: (38 bytes: <@04fccb> - <@04fcf1>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @04fccb>   : 1f 78 c9 00 00             load.ref <@00c978> ;"lib/stdlib.ci"
	<assertEq+56 @04fcd0>   : 1c 4b 00 00 00             load.c32 75
	<assertEq+61 @04fcd5>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @04fcda>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @04fcdf>   : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<assertEq+76 @04fce4>   : 1f e0 fb 00 00             load.ref <@00fbe0> ;NotEquals
	<assertEq+81 @04fce9>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @04fced>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @04fcf1>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @04fcf5>   : 03                         ret
.usages:
	lib/stdlib.ci:78: referenced as `assertEq`
	lib/stdlib.ci:66: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:78'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:78: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:83'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:83: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@010e58>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@04fcf8>, cast: static const function)
.field floor: function (size: 24, offs: <@04fd50>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@04fd68>, cast: static const function)
.field abs: function (size: 18, offs: <@04fd80>, cast: static const function)
.field absMod: function (size: 27, offs: <@04fd98>, cast: static const function)
.field absMod: function (size: 27, offs: <@04fdb8>, cast: static const function)
.field min: function (size: 17, offs: <@04fdd8>, cast: static const function)
.field min: function (size: 17, offs: <@04fdf0>, cast: static const function)
.field max: function (size: 17, offs: <@04fe08>, cast: static const function)
.field max: function (size: 17, offs: <@04fe20>, cast: static const function)
.field clamp: function (size: 30, offs: <@04fe38>, cast: static const function)
.field clamp: function (size: 30, offs: <@04fe58>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@04fe78>, cast: static const function)
.field max: function (size: 72, offs: <@04fec0>, cast: static const function)
.field sum: function (size: 40, offs: <@04ff08>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@04ff30>, cast: static const function)
.field cmp: function (size: 57, offs: <@04ff60>, cast: static const function)
.field cmp: function (size: 57, offs: <@04ffa0>, cast: static const function)
.field sinCos: function (size: 335, offs: <@04ffe0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@050130>, cast: static const function)
.field sinh: function (size: 241, offs: <@0502a8>, cast: static const function)
.field cosh: function (size: 75, offs: <@0503a0>, cast: static const function)
.field asin: function (size: 166, offs: <@0503f0>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: float64(1.000000 / ln2)
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: float64(1.000000 / ln10)
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: float64((0) / 0.000000)
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: float64((1) / 0.000000)
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@04fcf8>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@04fcf8> - <@04fd4e>)
	lib/std/math.ci:23: (63 bytes: <@04fcf8> - <@04fd37>): if (bool(x < (1)))
	<modf @04fcf8>      : 11 02                      dup.x2 sp(2)
	<modf+2 @04fcfa>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @04fd03>   : 88                         clt.f64
	<modf+12 @04fd04>   : 06 33 00 00                jz <modf+63 @04fd37>
	lib/std/math.ci:24: (39 bytes: <@04fd08> - <@04fd2f>): if (bool(x < (0)))
	<modf+16 @04fd08>   : 11 02                      dup.x2 sp(2)
	<modf+18 @04fd0a>   : 1a                         load.z64
	<modf+19 @04fd0b>   : 88                         clt.f64
	<modf+20 @04fd0c>   : 06 23 00 00                jz <modf+55 @04fd2f>
	lib/std/math.ci:25: (17 bytes: <@04fd10> - <@04fd21>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @04fd10>   : 1a                         load.z64
	<modf+25 @04fd11>   : 11 04                      dup.x2 sp(4)
	<modf+27 @04fd13>   : 80                         neg.f64
	<modf+28 @04fd14>   : 10 05                      dup.x1 sp(5)
	<modf+30 @04fd16>   : 1f f8 fc 04 00             load.ref <@04fcf8> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @04fd1b>   : 02                         call
	<modf+36 @04fd1c>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @04fd20>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@04fd21> - <@04fd28>): float64(intPart := float64(-intPart));
	<modf+41 @04fd21>   : 10 03                      dup.x1 sp(3)
	<modf+43 @04fd23>   : 23                         load.i64
	<modf+44 @04fd24>   : 80                         neg.f64
	<modf+45 @04fd25>   : 10 05                      dup.x1 sp(5)
	<modf+47 @04fd27>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@04fd28> - <@04fd2b>): return float64(.result := result);
	<modf+48 @04fd28>   : 14 06                      set.x2 sp(6)
	<modf+50 @04fd2a>   : 03                         ret
	<modf+51 @04fd2b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@04fd2f> - <@04fd33>): float64(intPart := (0));
	<modf+55 @04fd2f>   : 1a                         load.z64
	<modf+56 @04fd30>   : 10 03                      dup.x1 sp(3)
	<modf+58 @04fd32>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@04fd33> - <@04fd37>): return float64(.result := x);
	<modf+59 @04fd33>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @04fd36>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@04fd37> - <@04fd43>): result: float64 := float64(x % (1))
	<modf+63 @04fd37>   : 11 02                      dup.x2 sp(2)
	<modf+65 @04fd39>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @04fd42>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@04fd43> - <@04fd4b>): float64(intPart := float64(x - result));
	<modf+75 @04fd43>   : 11 04                      dup.x2 sp(4)
	<modf+77 @04fd45>   : 11 02                      dup.x2 sp(2)
	<modf+79 @04fd47>   : 82                         sub.f64
	<modf+80 @04fd48>   : 10 05                      dup.x1 sp(5)
	<modf+82 @04fd4a>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@04fd4b> - <@04fd4e>): return float64(.result := result);
	<modf+83 @04fd4b>   : 14 06                      set.x2 sp(6)
	<modf+85 @04fd4d>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@04fd50>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@04fd50> - <@04fd68>)
	lib/std/math.ci:48: (1 byte: <@04fd50> - <@04fd51>): result: float64
	<floor @04fd50>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@04fd51> - <@04fd65>): modf(void(x, result));
	<floor+1 @04fd51>    : 11 05                      dup.x2 sp(5)
	<floor+3 @04fd53>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @04fd57>    : 1f f8 fc 04 00             load.ref <@04fcf8> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @04fd5c>   : 02                         call
	<floor+13 @04fd5d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @04fd61>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@04fd65> - <@04fd68>): return float64(.result := result);
	<floor+21 @04fd65>   : 14 05                      set.x2 sp(5)
	<floor+23 @04fd67>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04fd68>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@04fd68> - <@04fd7a>)
	lib/std/math.ci:78: (14 bytes: <@04fd68> - <@04fd76>): if (bool(x < (0)))
	<abs @04fd68>      : 10 01                      dup.x1 sp(1)
	<abs+2 @04fd6a>    : 19                         load.z32
	<abs+3 @04fd6b>    : 78                         clt.f32
	<abs+4 @04fd6c>    : 06 0a 00 00                jz <abs+14 @04fd76>
	lib/std/math.ci:79: (6 bytes: <@04fd70> - <@04fd76>): return float32(.result := float32(-x));
	<abs+8 @04fd70>    : 10 01                      dup.x1 sp(1)
	<abs+10 @04fd72>   : 70                         neg.f32
	<abs+11 @04fd73>   : 13 03                      set.x1 sp(3)
	<abs+13 @04fd75>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@04fd76> - <@04fd7a>): return float32(.result := x);
	<abs+14 @04fd76>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @04fd79>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04fd80>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@04fd80> - <@04fd92>)
	lib/std/math.ci:86: (14 bytes: <@04fd80> - <@04fd8e>): if (bool(x < (0)))
	<abs @04fd80>      : 11 01                      dup.x2 sp(1)
	<abs+2 @04fd82>    : 1a                         load.z64
	<abs+3 @04fd83>    : 88                         clt.f64
	<abs+4 @04fd84>    : 06 0a 00 00                jz <abs+14 @04fd8e>
	lib/std/math.ci:87: (6 bytes: <@04fd88> - <@04fd8e>): return float64(.result := float64(-x));
	<abs+8 @04fd88>    : 11 01                      dup.x2 sp(1)
	<abs+10 @04fd8a>   : 80                         neg.f64
	<abs+11 @04fd8b>   : 14 05                      set.x2 sp(5)
	<abs+13 @04fd8d>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@04fd8e> - <@04fd92>): return float64(.result := x);
	<abs+14 @04fd8e>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @04fd91>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04fd98>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@04fd98> - <@04fdb3>)
	lib/std/math.ci:94: (23 bytes: <@04fd98> - <@04fdaf>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @04fd98>      : 10 02                      dup.x1 sp(2)
	<absMod+2 @04fd9a>    : 10 02                      dup.x1 sp(2)
	<absMod+4 @04fd9c>    : 75                         mod.f32
	<absMod+5 @04fd9d>    : 10 00                      dup.x1 sp(0)
	<absMod+7 @04fd9f>    : 13 04                      set.x1 sp(4)
	<absMod+9 @04fda1>    : 19                         load.z32
	<absMod+10 @04fda2>   : 78                         clt.f32
	<absMod+11 @04fda3>   : 06 0c 00 00                jz <absMod+23 @04fdaf>
	lib/std/math.ci:95: (8 bytes: <@04fda7> - <@04fdaf>): return float32(.result := float32(val + mod));
	<absMod+15 @04fda7>   : 10 02                      dup.x1 sp(2)
	<absMod+17 @04fda9>   : 10 02                      dup.x1 sp(2)
	<absMod+19 @04fdab>   : 71                         add.f32
	<absMod+20 @04fdac>   : 13 04                      set.x1 sp(4)
	<absMod+22 @04fdae>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@04fdaf> - <@04fdb3>): return float32(.result := val);
	<absMod+23 @04fdaf>   : 16 03 02                   mov.x1 sp(3, 2)
	<absMod+26 @04fdb2>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04fdb8>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@04fdb8> - <@04fdd3>)
	lib/std/math.ci:102: (23 bytes: <@04fdb8> - <@04fdcf>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @04fdb8>      : 11 03                      dup.x2 sp(3)
	<absMod+2 @04fdba>    : 11 03                      dup.x2 sp(3)
	<absMod+4 @04fdbc>    : 85                         mod.f64
	<absMod+5 @04fdbd>    : 11 00                      dup.x2 sp(0)
	<absMod+7 @04fdbf>    : 14 07                      set.x2 sp(7)
	<absMod+9 @04fdc1>    : 1a                         load.z64
	<absMod+10 @04fdc2>   : 88                         clt.f64
	<absMod+11 @04fdc3>   : 06 0c 00 00                jz <absMod+23 @04fdcf>
	lib/std/math.ci:103: (8 bytes: <@04fdc7> - <@04fdcf>): return float64(.result := float64(val + mod));
	<absMod+15 @04fdc7>   : 11 03                      dup.x2 sp(3)
	<absMod+17 @04fdc9>   : 11 03                      dup.x2 sp(3)
	<absMod+19 @04fdcb>   : 81                         add.f64
	<absMod+20 @04fdcc>   : 14 07                      set.x2 sp(7)
	<absMod+22 @04fdce>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@04fdcf> - <@04fdd3>): return float64(.result := val);
	<absMod+23 @04fdcf>   : 17 05 03                   mov.x2 sp(5, 3)
	<absMod+26 @04fdd2>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fdd8>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04fdd8> - <@04fde9>)
	lib/std/math.ci:116: (13 bytes: <@04fdd8> - <@04fde5>): if (bool(a < b))
	<min @04fdd8>      : 10 02                      dup.x1 sp(2)
	<min+2 @04fdda>    : 10 02                      dup.x1 sp(2)
	<min+4 @04fddc>    : 78                         clt.f32
	<min+5 @04fddd>    : 06 08 00 00                jz <min+13 @04fde5>
	lib/std/math.ci:117: (4 bytes: <@04fde1> - <@04fde5>): return float32(.result := a);
	<min+9 @04fde1>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @04fde4>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@04fde5> - <@04fde9>): return float32(.result := b);
	<min+13 @04fde5>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @04fde8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fdf0>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04fdf0> - <@04fe01>)
	lib/std/math.ci:124: (13 bytes: <@04fdf0> - <@04fdfd>): if (bool(a < b))
	<min @04fdf0>      : 11 03                      dup.x2 sp(3)
	<min+2 @04fdf2>    : 11 03                      dup.x2 sp(3)
	<min+4 @04fdf4>    : 88                         clt.f64
	<min+5 @04fdf5>    : 06 08 00 00                jz <min+13 @04fdfd>
	lib/std/math.ci:125: (4 bytes: <@04fdf9> - <@04fdfd>): return float64(.result := a);
	<min+9 @04fdf9>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @04fdfc>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@04fdfd> - <@04fe01>): return float64(.result := b);
	<min+13 @04fdfd>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @04fe00>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe08>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04fe08> - <@04fe19>)
	lib/std/math.ci:138: (13 bytes: <@04fe08> - <@04fe15>): if (bool(a > b))
	<max @04fe08>      : 10 02                      dup.x1 sp(2)
	<max+2 @04fe0a>    : 10 02                      dup.x1 sp(2)
	<max+4 @04fe0c>    : 79                         cgt.f32
	<max+5 @04fe0d>    : 06 08 00 00                jz <max+13 @04fe15>
	lib/std/math.ci:139: (4 bytes: <@04fe11> - <@04fe15>): return float32(.result := a);
	<max+9 @04fe11>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @04fe14>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@04fe15> - <@04fe19>): return float32(.result := b);
	<max+13 @04fe15>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @04fe18>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe20>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04fe20> - <@04fe31>)
	lib/std/math.ci:146: (13 bytes: <@04fe20> - <@04fe2d>): if (bool(a > b))
	<max @04fe20>      : 11 03                      dup.x2 sp(3)
	<max+2 @04fe22>    : 11 03                      dup.x2 sp(3)
	<max+4 @04fe24>    : 89                         cgt.f64
	<max+5 @04fe25>    : 06 08 00 00                jz <max+13 @04fe2d>
	lib/std/math.ci:147: (4 bytes: <@04fe29> - <@04fe2d>): return float64(.result := a);
	<max+9 @04fe29>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @04fe2c>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@04fe2d> - <@04fe31>): return float64(.result := b);
	<max+13 @04fe2d>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @04fe30>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04fe38>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@04fe38> - <@04fe56>)
	lib/std/math.ci:160: (13 bytes: <@04fe38> - <@04fe45>): if (bool(t < a))
	<clamp @04fe38>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @04fe3a>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @04fe3c>    : 78                         clt.f32
	<clamp+5 @04fe3d>    : 06 08 00 00                jz <clamp+13 @04fe45>
	lib/std/math.ci:161: (4 bytes: <@04fe41> - <@04fe45>): return float32(.result := a);
	<clamp+9 @04fe41>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @04fe44>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@04fe45> - <@04fe52>): if (bool(t > b))
	<clamp+13 @04fe45>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @04fe47>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @04fe49>   : 79                         cgt.f32
	<clamp+18 @04fe4a>   : 06 08 00 00                jz <clamp+26 @04fe52>
	lib/std/math.ci:164: (4 bytes: <@04fe4e> - <@04fe52>): return float32(.result := b);
	<clamp+22 @04fe4e>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @04fe51>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@04fe52> - <@04fe56>): return float32(.result := t);
	<clamp+26 @04fe52>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @04fe55>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04fe58>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@04fe58> - <@04fe76>)
	lib/std/math.ci:171: (13 bytes: <@04fe58> - <@04fe65>): if (bool(t < a))
	<clamp @04fe58>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @04fe5a>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @04fe5c>    : 88                         clt.f64
	<clamp+5 @04fe5d>    : 06 08 00 00                jz <clamp+13 @04fe65>
	lib/std/math.ci:172: (4 bytes: <@04fe61> - <@04fe65>): return float64(.result := a);
	<clamp+9 @04fe61>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @04fe64>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@04fe65> - <@04fe72>): if (bool(t > b))
	<clamp+13 @04fe65>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @04fe67>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @04fe69>   : 89                         cgt.f64
	<clamp+18 @04fe6a>   : 06 08 00 00                jz <clamp+26 @04fe72>
	lib/std/math.ci:175: (4 bytes: <@04fe6e> - <@04fe72>): return float64(.result := b);
	<clamp+22 @04fe6e>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @04fe71>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@04fe72> - <@04fe76>): return float64(.result := t);
	<clamp+26 @04fe72>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @04fe75>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04fe78>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04fe78> - <@04fec0>)
	lib/std/math.ci:202: (13 bytes: <@04fe78> - <@04fe85>): if (bool(data.length == (0)))
	<min @04fe78>      : 10 02                      dup.x1 sp(2)
	<min+2 @04fe7a>    : 19                         load.z32
	<min+3 @04fe7b>    : 57                         ceq.i32
	<min+4 @04fe7c>    : 06 09 00 00                jz <min+13 @04fe85>
	lib/std/math.ci:203: (5 bytes: <@04fe80> - <@04fe85>): return float64(.result := nan);
	<min+8 @04fe80>    : 1b                         load.z128
	<min+9 @04fe81>    : 84                         div.f64
	<min+10 @04fe82>   : 14 05                      set.x2 sp(5)
	<min+12 @04fe84>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@04fe85> - <@04fe88>): result: float64 := data[0]
	<min+13 @04fe85>   : 10 01                      dup.x1 sp(1)
	<min+15 @04fe87>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@04fe88> - <@04febd>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @04fe88>   : 1c 01 00 00 00             load.c32 1
	<min+21 @04fe8d>   : 04 23 00 00                jmp <min+56 @04feb0>
	lib/std/math.ci:207: (27 bytes: <@04fe91> - <@04feac>): if (bool(result > data[i]))
	<min+25 @04fe91>   : 11 01                      dup.x2 sp(1)
	<min+27 @04fe93>   : 10 06                      dup.x1 sp(6)
	<min+29 @04fe95>   : 10 03                      dup.x1 sp(3)
	<min+31 @04fe97>   : 0d 08 00 00                mad.u32 8
	<min+35 @04fe9b>   : 23                         load.i64
	<min+36 @04fe9c>   : 89                         cgt.f64
	<min+37 @04fe9d>   : 06 0f 00 00                jz <min+52 @04feac>
	lib/std/math.ci:208: (11 bytes: <@04fea1> - <@04feac>): float64(result := data[i]);
	<min+41 @04fea1>   : 10 04                      dup.x1 sp(4)
	<min+43 @04fea3>   : 10 01                      dup.x1 sp(1)
	<min+45 @04fea5>   : 0d 08 00 00                mad.u32 8
	<min+49 @04fea9>   : 23                         load.i64
	<min+50 @04feaa>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:206: (4 bytes: <@04feac> - <@04feb0>): int32(i := int32(i + 1))
	<min+52 @04feac>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@04feb0> - <@04feb9>): bool(i < (data.length))
	<min+56 @04feb0>   : 10 00                      dup.x1 sp(0)
	<min+58 @04feb2>   : 10 06                      dup.x1 sp(6)
	<min+60 @04feb4>   : 58                         clt.i32
	<min+61 @04feb5>   : 05 dc ff ff                jnz <min+25 @04fe91>
	<min+65 @04feb9>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@04febd> - <@04fec0>): return float64(.result := result);
	<min+69 @04febd>   : 14 05                      set.x2 sp(5)
	<min+71 @04febf>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04fec0>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04fec0> - <@04ff08>)
	lib/std/math.ci:216: (13 bytes: <@04fec0> - <@04fecd>): if (bool(data.length == (0)))
	<max @04fec0>      : 10 02                      dup.x1 sp(2)
	<max+2 @04fec2>    : 19                         load.z32
	<max+3 @04fec3>    : 57                         ceq.i32
	<max+4 @04fec4>    : 06 09 00 00                jz <max+13 @04fecd>
	lib/std/math.ci:217: (5 bytes: <@04fec8> - <@04fecd>): return float64(.result := nan);
	<max+8 @04fec8>    : 1b                         load.z128
	<max+9 @04fec9>    : 84                         div.f64
	<max+10 @04feca>   : 14 05                      set.x2 sp(5)
	<max+12 @04fecc>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@04fecd> - <@04fed0>): result: float64 := data[0]
	<max+13 @04fecd>   : 10 01                      dup.x1 sp(1)
	<max+15 @04fecf>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@04fed0> - <@04ff05>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @04fed0>   : 1c 01 00 00 00             load.c32 1
	<max+21 @04fed5>   : 04 23 00 00                jmp <max+56 @04fef8>
	lib/std/math.ci:221: (27 bytes: <@04fed9> - <@04fef4>): if (bool(result < data[i]))
	<max+25 @04fed9>   : 11 01                      dup.x2 sp(1)
	<max+27 @04fedb>   : 10 06                      dup.x1 sp(6)
	<max+29 @04fedd>   : 10 03                      dup.x1 sp(3)
	<max+31 @04fedf>   : 0d 08 00 00                mad.u32 8
	<max+35 @04fee3>   : 23                         load.i64
	<max+36 @04fee4>   : 88                         clt.f64
	<max+37 @04fee5>   : 06 0f 00 00                jz <max+52 @04fef4>
	lib/std/math.ci:222: (11 bytes: <@04fee9> - <@04fef4>): float64(result := data[i]);
	<max+41 @04fee9>   : 10 04                      dup.x1 sp(4)
	<max+43 @04feeb>   : 10 01                      dup.x1 sp(1)
	<max+45 @04feed>   : 0d 08 00 00                mad.u32 8
	<max+49 @04fef1>   : 23                         load.i64
	<max+50 @04fef2>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:220: (4 bytes: <@04fef4> - <@04fef8>): int32(i := int32(i + 1))
	<max+52 @04fef4>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@04fef8> - <@04ff01>): bool(i < (data.length))
	<max+56 @04fef8>   : 10 00                      dup.x1 sp(0)
	<max+58 @04fefa>   : 10 06                      dup.x1 sp(6)
	<max+60 @04fefc>   : 58                         clt.i32
	<max+61 @04fefd>   : 05 dc ff ff                jnz <max+25 @04fed9>
	<max+65 @04ff01>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@04ff05> - <@04ff08>): return float64(.result := result);
	<max+69 @04ff05>   : 14 05                      set.x2 sp(5)
	<max+71 @04ff07>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@04ff08>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@04ff08> - <@04ff30>)
	lib/std/math.ci:230: (1 byte: <@04ff08> - <@04ff09>): result: float64 := 0
	<sum @04ff08>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@04ff09> - <@04ff2d>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @04ff09>    : 6a                         i64.2i32
	<sum+2 @04ff0a>    : 04 16 00 00                jmp <sum+24 @04ff20>
	lib/std/math.ci:232: (14 bytes: <@04ff0e> - <@04ff1c>): float64(result := float64(result + data[i]));
	<sum+6 @04ff0e>    : 11 01                      dup.x2 sp(1)
	<sum+8 @04ff10>    : 10 06                      dup.x1 sp(6)
	<sum+10 @04ff12>   : 10 03                      dup.x1 sp(3)
	<sum+12 @04ff14>   : 0d 08 00 00                mad.u32 8
	<sum+16 @04ff18>   : 23                         load.i64
	<sum+17 @04ff19>   : 81                         add.f64
	<sum+18 @04ff1a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:231: (4 bytes: <@04ff1c> - <@04ff20>): int32(i := int32(i + 1))
	<sum+20 @04ff1c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@04ff20> - <@04ff29>): bool(i < (data.length))
	<sum+24 @04ff20>   : 10 00                      dup.x1 sp(0)
	<sum+26 @04ff22>   : 10 06                      dup.x1 sp(6)
	<sum+28 @04ff24>   : 58                         clt.i32
	<sum+29 @04ff25>   : 05 e9 ff ff                jnz <sum+6 @04ff0e>
	<sum+33 @04ff29>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@04ff2d> - <@04ff30>): return float64(.result := result);
	<sum+37 @04ff2d>   : 14 05                      set.x2 sp(5)
	<sum+39 @04ff2f>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@04ff30>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@04ff30> - <@04ff5f>)
	lib/std/math.ci:257: (1 byte: <@04ff30> - <@04ff31>): result: float64 := 0
	<eval @04ff30>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@04ff31> - <@04ff5c>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @04ff31>    : 10 04                      dup.x1 sp(4)
	<eval+3 @04ff33>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @04ff37>    : 04 19 00 00                jmp <eval+32 @04ff50>
	lib/std/math.ci:259: (17 bytes: <@04ff3b> - <@04ff4c>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @04ff3b>   : 11 01                      dup.x2 sp(1)
	<eval+13 @04ff3d>   : 11 08                      dup.x2 sp(8)
	<eval+15 @04ff3f>   : 83                         mul.f64
	<eval+16 @04ff40>   : 10 06                      dup.x1 sp(6)
	<eval+18 @04ff42>   : 10 03                      dup.x1 sp(3)
	<eval+20 @04ff44>   : 0d 08 00 00                mad.u32 8
	<eval+24 @04ff48>   : 23                         load.i64
	<eval+25 @04ff49>   : 81                         add.f64
	<eval+26 @04ff4a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:258: (4 bytes: <@04ff4c> - <@04ff50>): int32(i := int32(i - 1))
	<eval+28 @04ff4c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@04ff50> - <@04ff58>): bool(i >= 0)
	<eval+32 @04ff50>   : 10 00                      dup.x1 sp(0)
	<eval+34 @04ff52>   : 19                         load.z32
	<eval+35 @04ff53>   : 58                         clt.i32
	<eval+36 @04ff54>   : 06 e7 ff ff                jz <eval+11 @04ff3b>
	<eval+40 @04ff58>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@04ff5c> - <@04ff5f>): return float64(.result := result);
	<eval+44 @04ff5c>   : 14 07                      set.x2 sp(7)
	<eval+46 @04ff5e>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@04ff60>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@04ff60> - <@04ff99>)
	lib/std/math.ci:266: (53 bytes: <@04ff60> - <@04ff95>): if (bool(a < b))
	<cmp @04ff60>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @04ff62>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @04ff64>    : 78                         clt.f32
	<cmp+5 @04ff65>    : 06 1c 00 00                jz <cmp+33 @04ff81>
	lib/std/math.ci:267: (20 bytes: <@04ff69> - <@04ff7d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @04ff69>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @04ff6b>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @04ff6d>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @04ff6f>   : 72                         sub.f32
	<cmp+16 @04ff70>   : 78                         clt.f32
	<cmp+17 @04ff71>   : 06 0c 00 00                jz <cmp+29 @04ff7d>
	lib/std/math.ci:268: (8 bytes: <@04ff75> - <@04ff7d>): return int32(.result := int32(-1));
	<cmp+21 @04ff75>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04ff7a>   : 13 05                      set.x1 sp(5)
	<cmp+28 @04ff7c>   : 03                         ret
	<cmp+29 @04ff7d>   : 04 18 00 00                jmp <cmp+53 @04ff95>
	lib/std/math.ci:272: (20 bytes: <@04ff81> - <@04ff95>): if (bool(eps < (float32(a - b))))
	<cmp+33 @04ff81>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @04ff83>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @04ff85>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @04ff87>   : 72                         sub.f32
	<cmp+40 @04ff88>   : 78                         clt.f32
	<cmp+41 @04ff89>   : 06 0c 00 00                jz <cmp+53 @04ff95>
	lib/std/math.ci:273: (8 bytes: <@04ff8d> - <@04ff95>): return int32(.result := int32(+1));
	<cmp+45 @04ff8d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @04ff92>   : 13 05                      set.x1 sp(5)
	<cmp+52 @04ff94>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@04ff95> - <@04ff99>): return int32(.result := 0);
	<cmp+53 @04ff95>   : 19                         load.z32
	<cmp+54 @04ff96>   : 13 05                      set.x1 sp(5)
	<cmp+56 @04ff98>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@04ffa0>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@04ffa0> - <@04ffd9>)
	lib/std/math.ci:281: (53 bytes: <@04ffa0> - <@04ffd5>): if (bool(a < b))
	<cmp @04ffa0>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @04ffa2>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @04ffa4>    : 88                         clt.f64
	<cmp+5 @04ffa5>    : 06 1c 00 00                jz <cmp+33 @04ffc1>
	lib/std/math.ci:282: (20 bytes: <@04ffa9> - <@04ffbd>): if (bool(eps < (float64(b - a))))
	<cmp+9 @04ffa9>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @04ffab>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @04ffad>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @04ffaf>   : 82                         sub.f64
	<cmp+16 @04ffb0>   : 88                         clt.f64
	<cmp+17 @04ffb1>   : 06 0c 00 00                jz <cmp+29 @04ffbd>
	lib/std/math.ci:283: (8 bytes: <@04ffb5> - <@04ffbd>): return int32(.result := int32(-1));
	<cmp+21 @04ffb5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04ffba>   : 13 08                      set.x1 sp(8)
	<cmp+28 @04ffbc>   : 03                         ret
	<cmp+29 @04ffbd>   : 04 18 00 00                jmp <cmp+53 @04ffd5>
	lib/std/math.ci:287: (20 bytes: <@04ffc1> - <@04ffd5>): if (bool(eps < (float64(a - b))))
	<cmp+33 @04ffc1>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @04ffc3>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @04ffc5>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @04ffc7>   : 82                         sub.f64
	<cmp+40 @04ffc8>   : 88                         clt.f64
	<cmp+41 @04ffc9>   : 06 0c 00 00                jz <cmp+53 @04ffd5>
	lib/std/math.ci:288: (8 bytes: <@04ffcd> - <@04ffd5>): return int32(.result := int32(+1));
	<cmp+45 @04ffcd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @04ffd2>   : 13 08                      set.x1 sp(8)
	<cmp+52 @04ffd4>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@04ffd5> - <@04ffd9>): return int32(.result := 0);
	<cmp+53 @04ffd5>   : 19                         load.z32
	<cmp+54 @04ffd6>   : 13 08                      set.x1 sp(8)
	<cmp+56 @04ffd8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@04ffe0>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@04ffe0> - <@05012f>)
	lib/std/math.ci:309: (2 bytes: <@04ffe0> - <@04ffe2>): x: float64 := arg
	<sinCos @04ffe0>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:310: (17 bytes: <@04ffe2> - <@04fff3>): if (bool(x < (0)))
	<sinCos+2 @04ffe2>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @04ffe4>    : 1a                         load.z64
	<sinCos+5 @04ffe5>    : 88                         clt.f64
	<sinCos+6 @04ffe6>    : 06 0d 00 00                jz <sinCos+19 @04fff3>
	lib/std/math.ci:311: (1 byte: <@04ffea> - <@04ffeb>): float64(x := float64(-x));
	<sinCos+10 @04ffea>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@04ffeb> - <@04fff3>): int32(quad := int32(quad + 2));
	<sinCos+11 @04ffeb>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @04ffed>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @04fff1>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:315: (1 byte: <@04fff3> - <@04fff4>): y: float64
	<sinCos+19 @04fff3>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@04fff4> - <@05000c>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @04fff4>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @04fff6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @04ffff>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @050008>   : 84                         div.f64
	<sinCos+41 @050009>   : 83                         mul.f64
	<sinCos+42 @05000a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:317: (124 bytes: <@05000c> - <@050088>): if (bool(x > (32764)))
	<sinCos+44 @05000c>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @05000e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @050017>   : 89                         cgt.f64
	<sinCos+56 @050018>   : 06 54 00 00                jz <sinCos+140 @05006c>
	lib/std/math.ci:318: (1 byte: <@05001c> - <@05001d>): e: float64
	<sinCos+60 @05001c>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@05001d> - <@05002f>): float64(y := modf(void(x, e)));
	<sinCos+61 @05001d>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @05001f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @050023>   : 1f f8 fc 04 00             load.ref <@04fcf8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @050028>   : 02                         call
	<sinCos+73 @050029>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @05002d>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:320: (4 bytes: <@05002f> - <@050033>): float64(e := float64(e + (quad)));
	<sinCos+79 @05002f>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @050031>   : 5d                         i32.2f64
	<sinCos+82 @050032>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@050033> - <@050034>): f: float64
	<sinCos+83 @050033>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@050034> - <@050052>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @050034>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @05003d>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @05003f>   : 83                         mul.f64
	<sinCos+96 @050040>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @050044>  : 1f f8 fc 04 00             load.ref <@04fcf8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @050049>  : 02                         call
	<sinCos+106 @05004a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @05004e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@050052> - <@050064>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @050052>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @050054>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @05005d>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @05005f>  : 83                         mul.f64
	<sinCos+128 @050060>  : 82                         sub.f64
	<sinCos+129 @050061>  : 8a                         f64.2i32
	<sinCos+130 @050062>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @050064>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @050068>  : 04 20 00 00                jmp <sinCos+168 @050088>
	lib/std/math.ci:327: (3 bytes: <@05006c> - <@05006f>): k: int32 := x
	<sinCos+140 @05006c>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @05006e>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@05006f> - <@050077>): float64(y := float64(x - (k)));
	<sinCos+143 @05006f>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @050071>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @050073>  : 5d                         i32.2f64
	<sinCos+148 @050074>  : 82                         sub.f64
	<sinCos+149 @050075>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:329: (7 bytes: <@050077> - <@05007e>): int32(quad := int32(quad + k));
	<sinCos+151 @050077>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @050079>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @05007b>  : 51                         add.i32
	<sinCos+156 @05007c>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:330: (6 bytes: <@05007e> - <@050084>): int32(quad := int32(quad & 3));
	<sinCos+158 @05007e>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @050080>  : 3f 02                      b32.and 0x003
	<sinCos+162 @050082>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @050084>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@050088> - <@05009e>): if (int32(quad & 1))
	<sinCos+168 @050088>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @05008a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @05008c>  : 06 12 00 00                jz <sinCos+190 @05009e>
	lib/std/math.ci:333: (14 bytes: <@050090> - <@05009e>): float64(y := float64((1) - y));
	<sinCos+176 @050090>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @050099>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @05009b>  : 82                         sub.f64
	<sinCos+188 @05009c>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:335: (13 bytes: <@05009e> - <@0500ab>): if (bool(quad > 1))
	<sinCos+190 @05009e>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @0500a0>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @0500a5>  : 59                         cgt.i32
	<sinCos+198 @0500a6>  : 06 05 00 00                jz <sinCos+203 @0500ab>
	lib/std/math.ci:336: (1 byte: <@0500aa> - <@0500ab>): float64(y := float64(-y));
	<sinCos+202 @0500aa>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@0500ab> - <@0500b0>): ysq: float64 := float64(y * y)
	<sinCos+203 @0500ab>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @0500ad>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @0500af>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@0500b0> - <@0500f0>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @0500b0>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @0500b9>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @0500bb>  : 83                         mul.f64
	<sinCos+220 @0500bc>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @0500c5>  : 81                         add.f64
	<sinCos+230 @0500c6>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @0500c8>  : 83                         mul.f64
	<sinCos+233 @0500c9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @0500d2>  : 81                         add.f64
	<sinCos+243 @0500d3>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @0500d5>  : 83                         mul.f64
	<sinCos+246 @0500d6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @0500df>  : 81                         add.f64
	<sinCos+256 @0500e0>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @0500e2>  : 83                         mul.f64
	<sinCos+259 @0500e3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @0500ec>  : 81                         add.f64
	<sinCos+269 @0500ed>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @0500ef>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@0500f0> - <@050123>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @0500f0>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @0500f2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @0500fb>  : 81                         add.f64
	<sinCos+284 @0500fc>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @0500fe>  : 83                         mul.f64
	<sinCos+287 @0500ff>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @050108>  : 81                         add.f64
	<sinCos+297 @050109>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @05010b>  : 83                         mul.f64
	<sinCos+300 @05010c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @050115>  : 81                         add.f64
	<sinCos+310 @050116>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @050118>  : 83                         mul.f64
	<sinCos+313 @050119>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @050122>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@050123> - <@05012f>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @050123>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @050125>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @050127>  : 84                         div.f64
	<sinCos+328 @050128>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @05012a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @05012e>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@050130>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@050130> - <@0502a3>)
	lib/std/math.ci:365: (1 byte: <@050130> - <@050131>): complement: bool := false
	<tan @050130>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@050131> - <@050132>): negate: bool := false
	<tan+1 @050131>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@050132> - <@050149>): if (bool(arg < (0)))
	<tan+2 @050132>    : 11 03                      dup.x2 sp(3)
	<tan+4 @050134>    : 1a                         load.z64
	<tan+5 @050135>    : 88                         clt.f64
	<tan+6 @050136>    : 06 13 00 00                jz <tan+25 @050149>
	lib/std/math.ci:369: (5 bytes: <@05013a> - <@05013f>): float64(arg := float64(-arg));
	<tan+10 @05013a>   : 11 03                      dup.x2 sp(3)
	<tan+12 @05013c>   : 80                         neg.f64
	<tan+13 @05013d>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:370: (10 bytes: <@05013f> - <@050149>): bool(negate := true);
	<tan+15 @05013f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @050144>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @050148>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@050149> - <@050161>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @050149>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @050152>   : 11 05                      dup.x2 sp(5)
	<tan+36 @050154>   : 83                         mul.f64
	<tan+37 @050155>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @05015e>   : 84                         div.f64
	<tan+47 @05015f>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:374: (1 byte: <@050161> - <@050162>): e: float64
	<tan+49 @050161>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@050162> - <@050172>): x: float64 := modf(void(arg, e))
	<tan+50 @050162>   : 11 07                      dup.x2 sp(7)
	<tan+52 @050164>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @050168>   : 1f f8 fc 04 00             load.ref <@04fcf8> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @05016d>   : 02                         call
	<tan+62 @05016e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@050172> - <@05017b>): i: int32 := int32(int32(e) % 4)
	<tan+66 @050172>   : 11 02                      dup.x2 sp(2)
	<tan+68 @050174>   : 8a                         f64.2i32
	<tan+69 @050175>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @05017a>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@05017b> - <@0501f5>): if (bool(i == 0))
	<tan+75 @05017b>   : 10 00                      dup.x1 sp(0)
	<tan+77 @05017d>   : 19                         load.z32
	<tan+78 @05017e>   : 57                         ceq.i32
	<tan+79 @05017f>   : 05 76 00 00                jnz <tan+197 @0501f5>
	lib/std/math.ci:379: (114 bytes: <@050183> - <@0501f5>): if (bool(i == 1))
	<tan+83 @050183>   : 10 00                      dup.x1 sp(0)
	<tan+85 @050185>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @05018a>   : 57                         ceq.i32
	<tan+91 @05018b>   : 06 20 00 00                jz <tan+123 @0501ab>
	lib/std/math.ci:380: (14 bytes: <@05018f> - <@05019d>): float64(x := float64((1) - x));
	<tan+95 @05018f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @050198>  : 11 03                      dup.x2 sp(3)
	<tan+106 @05019a>  : 82                         sub.f64
	<tan+107 @05019b>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:381: (10 bytes: <@05019d> - <@0501a7>): bool(complement := true);
	<tan+109 @05019d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @0501a2>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @0501a6>  : 25                         store.i8
	<tan+119 @0501a7>  : 04 4e 00 00                jmp <tan+197 @0501f5>
	lib/std/math.ci:383: (74 bytes: <@0501ab> - <@0501f5>): if (bool(i == 2))
	<tan+123 @0501ab>  : 10 00                      dup.x1 sp(0)
	<tan+125 @0501ad>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @0501b2>  : 57                         ceq.i32
	<tan+131 @0501b3>  : 06 1d 00 00                jz <tan+160 @0501d0>
	lib/std/math.ci:384: (11 bytes: <@0501b7> - <@0501c2>): bool(negate := bool(!negate));
	<tan+135 @0501b7>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @0501bb>  : 20                         load.i8
	<tan+140 @0501bc>  : 0b                         not.b32
	<tan+141 @0501bd>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @0501c1>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@0501c2> - <@0501cc>): bool(complement := true);
	<tan+146 @0501c2>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @0501c7>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @0501cb>  : 25                         store.i8
	<tan+156 @0501cc>  : 04 29 00 00                jmp <tan+197 @0501f5>
	lib/std/math.ci:387: (37 bytes: <@0501d0> - <@0501f5>): if (bool(i == 3))
	<tan+160 @0501d0>  : 10 00                      dup.x1 sp(0)
	<tan+162 @0501d2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @0501d7>  : 57                         ceq.i32
	<tan+168 @0501d8>  : 06 1d 00 00                jz <tan+197 @0501f5>
	lib/std/math.ci:388: (14 bytes: <@0501dc> - <@0501ea>): float64(x := float64((1) - x));
	<tan+172 @0501dc>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @0501e5>  : 11 03                      dup.x2 sp(3)
	<tan+183 @0501e7>  : 82                         sub.f64
	<tan+184 @0501e8>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:389: (11 bytes: <@0501ea> - <@0501f5>): bool(negate := bool(!negate));
	<tan+186 @0501ea>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @0501ee>  : 20                         load.i8
	<tan+191 @0501ef>  : 0b                         not.b32
	<tan+192 @0501f0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @0501f4>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@0501f5> - <@0501fa>): xsq: float64 := float64(x * x)
	<tan+197 @0501f5>  : 11 01                      dup.x2 sp(1)
	<tan+199 @0501f7>  : 11 03                      dup.x2 sp(3)
	<tan+201 @0501f9>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@0501fa> - <@05023a>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @0501fa>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @050203>  : 11 02                      dup.x2 sp(2)
	<tan+213 @050205>  : 83                         mul.f64
	<tan+214 @050206>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @05020f>  : 81                         add.f64
	<tan+224 @050210>  : 11 02                      dup.x2 sp(2)
	<tan+226 @050212>  : 83                         mul.f64
	<tan+227 @050213>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @05021c>  : 81                         add.f64
	<tan+237 @05021d>  : 11 02                      dup.x2 sp(2)
	<tan+239 @05021f>  : 83                         mul.f64
	<tan+240 @050220>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @050229>  : 81                         add.f64
	<tan+250 @05022a>  : 11 02                      dup.x2 sp(2)
	<tan+252 @05022c>  : 83                         mul.f64
	<tan+253 @05022d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @050236>  : 81                         add.f64
	<tan+263 @050237>  : 11 05                      dup.x2 sp(5)
	<tan+265 @050239>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@05023a> - <@050261>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @05023a>  : 11 02                      dup.x2 sp(2)
	<tan+268 @05023c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @050245>  : 81                         add.f64
	<tan+278 @050246>  : 11 04                      dup.x2 sp(4)
	<tan+280 @050248>  : 83                         mul.f64
	<tan+281 @050249>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @050252>  : 81                         add.f64
	<tan+291 @050253>  : 11 04                      dup.x2 sp(4)
	<tan+293 @050255>  : 83                         mul.f64
	<tan+294 @050256>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @05025f>  : 81                         add.f64
	<tan+304 @050260>  : 84                         div.f64
	lib/std/math.ci:396: (40 bytes: <@050261> - <@050289>): if (complement)
	<tan+305 @050261>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @050265>  : 20                         load.i8
	<tan+310 @050266>  : 06 23 00 00                jz <tan+345 @050289>
	lib/std/math.ci:397: (17 bytes: <@05026a> - <@05027b>): if (bool(result == (0)))
	<tan+314 @05026a>  : 11 00                      dup.x2 sp(0)
	<tan+316 @05026c>  : 1a                         load.z64
	<tan+317 @05026d>  : 87                         ceq.f64
	<tan+318 @05026e>  : 06 0d 00 00                jz <tan+331 @05027b>
	lib/std/math.ci:398: (9 bytes: <@050272> - <@05027b>): return float64(.result := nan);
	<tan+322 @050272>  : 1b                         load.z128
	<tan+323 @050273>  : 84                         div.f64
	<tan+324 @050274>  : 14 10                      set.x2 sp(16)
	<tan+326 @050276>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @05027a>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@05027b> - <@050289>): float64(result := float64((1) / result));
	<tan+331 @05027b>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @050284>  : 11 02                      dup.x2 sp(2)
	<tan+342 @050286>  : 84                         div.f64
	<tan+343 @050287>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:402: (19 bytes: <@050289> - <@05029c>): if (negate)
	<tan+345 @050289>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @05028d>  : 20                         load.i8
	<tan+350 @05028e>  : 06 0e 00 00                jz <tan+364 @05029c>
	lib/std/math.ci:403: (10 bytes: <@050292> - <@05029c>): return float64(.result := float64(-result));
	<tan+354 @050292>  : 11 00                      dup.x2 sp(0)
	<tan+356 @050294>  : 80                         neg.f64
	<tan+357 @050295>  : 14 10                      set.x2 sp(16)
	<tan+359 @050297>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @05029b>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@05029c> - <@0502a3>): return float64(.result := result);
	<tan+364 @05029c>  : 14 0e                      set.x2 sp(14)
	<tan+366 @05029e>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @0502a2>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@0502a8>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@0502a8> - <@050399>)
	lib/std/math.ci:421: (1 byte: <@0502a8> - <@0502a9>): negate: bool := false
	<sinh @0502a8>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@0502a9> - <@0502c0>): if (bool(x < (0)))
	<sinh+1 @0502a9>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @0502ab>    : 1a                         load.z64
	<sinh+4 @0502ac>    : 88                         clt.f64
	<sinh+5 @0502ad>    : 06 13 00 00                jz <sinh+24 @0502c0>
	lib/std/math.ci:423: (5 bytes: <@0502b1> - <@0502b6>): float64(x := float64(-x));
	<sinh+9 @0502b1>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @0502b3>   : 80                         neg.f64
	<sinh+12 @0502b4>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:424: (10 bytes: <@0502b6> - <@0502c0>): bool(negate := true);
	<sinh+14 @0502b6>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @0502bb>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @0502bf>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@0502c0> - <@0502e7>): if (bool(x > (21)))
	<sinh+24 @0502c0>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @0502c2>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @0502cb>   : 89                         cgt.f64
	<sinh+36 @0502cc>   : 06 1b 00 00                jz <sinh+63 @0502e7>
	lib/std/math.ci:428: (23 bytes: <@0502d0> - <@0502e7>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @0502d0>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @0502d2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @0502d6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @0502df>   : 84                         div.f64
	<sinh+56 @0502e0>   : 14 06                      set.x2 sp(6)
	<sinh+58 @0502e2>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @0502e6>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@0502e7> - <@0502e8>): result: float64
	<sinh+63 @0502e7>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@0502e8> - <@05037f>): if (bool(x > 0.500000))
	<sinh+64 @0502e8>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @0502ea>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @0502f3>   : 89                         cgt.f64
	<sinh+76 @0502f4>   : 06 22 00 00                jz <sinh+110 @050316>
	lib/std/math.ci:433: (26 bytes: <@0502f8> - <@050312>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @0502f8>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @0502fa>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @0502fe>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @050300>   : 80                         neg.f64
	<sinh+89 @050301>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @050305>   : 82                         sub.f64
	<sinh+94 @050306>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @05030f>  : 84                         div.f64
	<sinh+104 @050310>  : 14 02                      set.x2 sp(2)
	<sinh+106 @050312>  : 04 6d 00 00                jmp <sinh+215 @05037f>
	lib/std/math.ci:436: (5 bytes: <@050316> - <@05031b>): sq: float64 := float64(x * x)
	<sinh+110 @050316>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @050318>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @05031a>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@05031b> - <@050350>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @05031b>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @050324>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @050326>  : 83                         mul.f64
	<sinh+127 @050327>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @050330>  : 81                         add.f64
	<sinh+137 @050331>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @050333>  : 83                         mul.f64
	<sinh+140 @050334>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @05033d>  : 81                         add.f64
	<sinh+150 @05033e>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @050340>  : 83                         mul.f64
	<sinh+153 @050341>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @05034a>  : 81                         add.f64
	<sinh+163 @05034b>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @05034d>  : 83                         mul.f64
	<sinh+166 @05034e>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:438: (43 bytes: <@050350> - <@05037b>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @050350>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @050352>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @050354>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @05035d>  : 81                         add.f64
	<sinh+182 @05035e>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @050360>  : 83                         mul.f64
	<sinh+185 @050361>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @05036a>  : 81                         add.f64
	<sinh+195 @05036b>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @05036d>  : 83                         mul.f64
	<sinh+198 @05036e>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @050377>  : 81                         add.f64
	<sinh+208 @050378>  : 84                         div.f64
	<sinh+209 @050379>  : 14 04                      set.x2 sp(4)
	<sinh+211 @05037b>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@05037f> - <@050392>): if (negate)
	<sinh+215 @05037f>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @050383>  : 20                         load.i8
	<sinh+220 @050384>  : 06 0e 00 00                jz <sinh+234 @050392>
	lib/std/math.ci:442: (10 bytes: <@050388> - <@050392>): return float64(.result := float64(-result));
	<sinh+224 @050388>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @05038a>  : 80                         neg.f64
	<sinh+227 @05038b>  : 14 08                      set.x2 sp(8)
	<sinh+229 @05038d>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @050391>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@050392> - <@050399>): return float64(.result := result);
	<sinh+234 @050392>  : 14 06                      set.x2 sp(6)
	<sinh+236 @050394>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @050398>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@0503a0>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@0503a0> - <@0503eb>)
	lib/std/math.ci:449: (13 bytes: <@0503a0> - <@0503ad>): if (bool(x < (0)))
	<cosh @0503a0>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @0503a2>    : 1a                         load.z64
	<cosh+3 @0503a3>    : 88                         clt.f64
	<cosh+4 @0503a4>    : 06 09 00 00                jz <cosh+13 @0503ad>
	lib/std/math.ci:450: (5 bytes: <@0503a8> - <@0503ad>): float64(x := float64(-x));
	<cosh+8 @0503a8>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @0503aa>   : 80                         neg.f64
	<cosh+11 @0503ab>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:452: (35 bytes: <@0503ad> - <@0503d0>): if (bool(x > (21)))
	<cosh+13 @0503ad>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @0503af>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @0503b8>   : 89                         cgt.f64
	<cosh+25 @0503b9>   : 06 17 00 00                jz <cosh+48 @0503d0>
	lib/std/math.ci:453: (19 bytes: <@0503bd> - <@0503d0>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @0503bd>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @0503bf>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @0503c3>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @0503cc>   : 84                         div.f64
	<cosh+45 @0503cd>   : 14 05                      set.x2 sp(5)
	<cosh+47 @0503cf>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@0503d0> - <@0503eb>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @0503d0>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @0503d2>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @0503d6>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @0503d8>   : 80                         neg.f64
	<cosh+57 @0503d9>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @0503dd>   : 81                         add.f64
	<cosh+62 @0503de>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @0503e7>   : 84                         div.f64
	<cosh+72 @0503e8>   : 14 05                      set.x2 sp(5)
	<cosh+74 @0503ea>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@0503f0>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@0503f0> - <@050496>)
	lib/std/math.ci:464: (12 bytes: <@0503f0> - <@0503fc>): if (bool(x == (0)))
	<asin @0503f0>      : 11 01                      dup.x2 sp(1)
	<asin+2 @0503f2>    : 1a                         load.z64
	<asin+3 @0503f3>    : 87                         ceq.f64
	<asin+4 @0503f4>    : 06 08 00 00                jz <asin+12 @0503fc>
	lib/std/math.ci:466: (4 bytes: <@0503f8> - <@0503fc>): return float64(.result := x);
	<asin+8 @0503f8>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @0503fb>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@0503fc> - <@0503fd>): negate: bool := false
	<asin+12 @0503fc>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@0503fd> - <@050414>): if (bool(x < (0)))
	<asin+13 @0503fd>   : 11 02                      dup.x2 sp(2)
	<asin+15 @0503ff>   : 1a                         load.z64
	<asin+16 @050400>   : 88                         clt.f64
	<asin+17 @050401>   : 06 13 00 00                jz <asin+36 @050414>
	lib/std/math.ci:471: (10 bytes: <@050405> - <@05040f>): bool(negate := true);
	<asin+21 @050405>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @05040a>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @05040e>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@05040f> - <@050414>): float64(x := float64(-x));
	<asin+31 @05040f>   : 11 02                      dup.x2 sp(2)
	<asin+33 @050411>   : 80                         neg.f64
	<asin+34 @050412>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:475: (25 bytes: <@050414> - <@05042d>): if (bool(x > (1)))
	<asin+36 @050414>   : 11 02                      dup.x2 sp(2)
	<asin+38 @050416>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @05041f>   : 89                         cgt.f64
	<asin+48 @050420>   : 06 0d 00 00                jz <asin+61 @05042d>
	lib/std/math.ci:477: (9 bytes: <@050424> - <@05042d>): return float64(.result := nan);
	<asin+52 @050424>   : 1b                         load.z128
	<asin+53 @050425>   : 84                         div.f64
	<asin+54 @050426>   : 14 06                      set.x2 sp(6)
	<asin+56 @050428>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @05042c>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@05042d> - <@050440>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @05042d>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @050436>   : 11 04                      dup.x2 sp(4)
	<asin+72 @050438>   : 11 06                      dup.x2 sp(6)
	<asin+74 @05043a>   : 83                         mul.f64
	<asin+75 @05043b>   : 82                         sub.f64
	<asin+76 @05043c>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@050440> - <@05047c>): if (bool(x > 0.700000))
	<asin+80 @050440>   : 11 04                      dup.x2 sp(4)
	<asin+82 @050442>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @05044b>   : 89                         cgt.f64
	<asin+92 @05044c>   : 06 26 00 00                jz <asin+130 @050472>
	lib/std/math.ci:482: (30 bytes: <@050450> - <@05046e>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @050450>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @050459>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @050462>  : 84                         div.f64
	<asin+115 @050463>  : 11 02                      dup.x2 sp(2)
	<asin+117 @050465>  : 11 08                      dup.x2 sp(8)
	<asin+119 @050467>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @05046b>  : 82                         sub.f64
	<asin+124 @05046c>  : 14 02                      set.x2 sp(2)
	<asin+126 @05046e>  : 04 0e 00 00                jmp <asin+140 @05047c>
	lib/std/math.ci:485: (10 bytes: <@050472> - <@05047c>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @050472>  : 11 04                      dup.x2 sp(4)
	<asin+132 @050474>  : 11 02                      dup.x2 sp(2)
	<asin+134 @050476>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @05047a>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:488: (19 bytes: <@05047c> - <@05048f>): if (negate)
	<asin+140 @05047c>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @050480>  : 20                         load.i8
	<asin+145 @050481>  : 06 0e 00 00                jz <asin+159 @05048f>
	lib/std/math.ci:489: (10 bytes: <@050485> - <@05048f>): return float64(.result := float64(-result));
	<asin+149 @050485>  : 11 00                      dup.x2 sp(0)
	<asin+151 @050487>  : 80                         neg.f64
	<asin+152 @050488>  : 14 08                      set.x2 sp(8)
	<asin+154 @05048a>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @05048e>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@05048f> - <@050496>): return float64(.result := result);
	<asin+159 @05048f>  : 14 06                      set.x2 sp(6)
	<asin+161 @050491>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @050495>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@019b78>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050498>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@050498> - <@05049f>)
	lib/std/math.Complex.ci:25: (7 bytes: <@050498> - <@05049f>): return void(.result := {...});
	<Complex @050498>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@05049b> - <@05049e>): void(.result.im := (0))
	<Complex+3 @05049b>    : 1a                         load.z64
	<Complex+4 @05049c>    : 14 07                      set.x2 sp(7)
	<Complex+6 @05049e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@0504a0>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@0504a0> - <@0504a7>)
	lib/std/math.Complex.ci:32: (7 bytes: <@0504a0> - <@0504a7>): return void(.result := {...});
	<Complex @0504a0>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@0504a3> - <@0504a6>): void(.result.im := im);
	<Complex+3 @0504a3>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @0504a6>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@0504a8>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@0504a8> - <@050523>)
	lib/std/math.Complex.ci:87: (79 bytes: <@0504a8> - <@0504f7>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @0504a8>      : 1a                         load.z64
	<div+1 @0504a9>    : 11 03                      dup.x2 sp(3)
	<div+3 @0504ab>    : 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<div+8 @0504b0>    : 02                         call
	<div+9 @0504b1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @0504b5>   : 1a                         load.z64
	<div+14 @0504b6>   : 11 07                      dup.x2 sp(7)
	<div+16 @0504b8>   : 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<div+21 @0504bd>   : 02                         call
	<div+22 @0504be>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @0504c2>   : 88                         clt.f64
	<div+27 @0504c3>   : 05 34 00 00                jnz <div+79 @0504f7>
	lib/std/math.Complex.ci:88: (5 bytes: <@0504c7> - <@0504cc>): r: float64 := float64(b.im / b.re)
	<div+31 @0504c7>   : 11 03                      dup.x2 sp(3)
	<div+33 @0504c9>   : 11 03                      dup.x2 sp(3)
	<div+35 @0504cb>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@0504cc> - <@0504d4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @0504cc>   : 11 03                      dup.x2 sp(3)
	<div+38 @0504ce>   : 11 02                      dup.x2 sp(2)
	<div+40 @0504d0>   : 11 09                      dup.x2 sp(9)
	<div+42 @0504d2>   : 83                         mul.f64
	<div+43 @0504d3>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@0504d4> - <@0504f3>): return void(.result := {...});
	<div+44 @0504d4>   : 11 09                      dup.x2 sp(9)
	<div+46 @0504d6>   : 11 04                      dup.x2 sp(4)
	<div+48 @0504d8>   : 11 0f                      dup.x2 sp(15)
	<div+50 @0504da>   : 83                         mul.f64
	<div+51 @0504db>   : 81                         add.f64
	<div+52 @0504dc>   : 11 02                      dup.x2 sp(2)
	<div+54 @0504de>   : 84                         div.f64
	<div+55 @0504df>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@0504e1> - <@0504ee>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @0504e1>   : 11 0b                      dup.x2 sp(11)
	<div+59 @0504e3>   : 11 04                      dup.x2 sp(4)
	<div+61 @0504e5>   : 11 0d                      dup.x2 sp(13)
	<div+63 @0504e7>   : 83                         mul.f64
	<div+64 @0504e8>   : 82                         sub.f64
	<div+65 @0504e9>   : 11 02                      dup.x2 sp(2)
	<div+67 @0504eb>   : 84                         div.f64
	<div+68 @0504ec>   : 14 11                      set.x2 sp(17)
	<div+70 @0504ee>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @0504f2>   : 03                         ret
	<div+75 @0504f3>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@0504f7> - <@0504fc>): r: float64 := float64(b.re / b.im)
	<div+79 @0504f7>   : 11 01                      dup.x2 sp(1)
	<div+81 @0504f9>   : 11 05                      dup.x2 sp(5)
	<div+83 @0504fb>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@0504fc> - <@050504>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @0504fc>   : 11 05                      dup.x2 sp(5)
	<div+86 @0504fe>   : 11 02                      dup.x2 sp(2)
	<div+88 @050500>   : 11 07                      dup.x2 sp(7)
	<div+90 @050502>   : 83                         mul.f64
	<div+91 @050503>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@050504> - <@050523>): return void(.result := {...});
	<div+92 @050504>   : 11 09                      dup.x2 sp(9)
	<div+94 @050506>   : 11 04                      dup.x2 sp(4)
	<div+96 @050508>   : 83                         mul.f64
	<div+97 @050509>   : 11 0d                      dup.x2 sp(13)
	<div+99 @05050b>   : 81                         add.f64
	<div+100 @05050c>  : 11 02                      dup.x2 sp(2)
	<div+102 @05050e>  : 84                         div.f64
	<div+103 @05050f>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@050511> - <@05051e>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @050511>  : 11 0b                      dup.x2 sp(11)
	<div+107 @050513>  : 11 04                      dup.x2 sp(4)
	<div+109 @050515>  : 83                         mul.f64
	<div+110 @050516>  : 11 0b                      dup.x2 sp(11)
	<div+112 @050518>  : 82                         sub.f64
	<div+113 @050519>  : 11 02                      dup.x2 sp(2)
	<div+115 @05051b>  : 84                         div.f64
	<div+116 @05051c>  : 14 11                      set.x2 sp(17)
	<div+118 @05051e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @050522>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@050528>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@050528> - <@050547>)
	lib/std/math.Complex.ci:115: (11 bytes: <@050528> - <@050533>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @050528>      : 11 01                      dup.x2 sp(1)
	<inv+2 @05052a>    : 11 03                      dup.x2 sp(3)
	<inv+4 @05052c>    : 83                         mul.f64
	<inv+5 @05052d>    : 11 05                      dup.x2 sp(5)
	<inv+7 @05052f>    : 11 07                      dup.x2 sp(7)
	<inv+9 @050531>    : 83                         mul.f64
	<inv+10 @050532>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@050533> - <@050547>): return void(.result := {...});
	<inv+11 @050533>   : 11 03                      dup.x2 sp(3)
	<inv+13 @050535>   : 11 02                      dup.x2 sp(2)
	<inv+15 @050537>   : 84                         div.f64
	<inv+16 @050538>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@05053a> - <@050542>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @05053a>   : 11 05                      dup.x2 sp(5)
	<inv+20 @05053c>   : 80                         neg.f64
	<inv+21 @05053d>   : 11 02                      dup.x2 sp(2)
	<inv+23 @05053f>   : 84                         div.f64
	<inv+24 @050540>   : 14 0b                      set.x2 sp(11)
	<inv+26 @050542>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @050546>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@050548>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@050548> - <@0505ac>)
	lib/std/math.Complex.ci:133: (23 bytes: <@050548> - <@05055f>): r: float64 := abs(a)
	<pow @050548>      : 12 05                      dup.x4 sp(5)
	<pow+2 @05054a>    : 11 00                      dup.x2 sp(0)
	<pow+4 @05054c>    : 11 02                      dup.x2 sp(2)
	<pow+6 @05054e>    : 83                         mul.f64
	<pow+7 @05054f>    : 11 04                      dup.x2 sp(4)
	<pow+9 @050551>    : 11 06                      dup.x2 sp(6)
	<pow+11 @050553>   : 83                         mul.f64
	<pow+12 @050554>   : 81                         add.f64
	<pow+13 @050555>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @050559>   : 14 04                      set.x2 sp(4)
	<pow+19 @05055b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@05055f> - <@05056f>): t: float64 := arg(a)
	<pow+23 @05055f>   : 12 07                      dup.x4 sp(7)
	<pow+25 @050561>   : 11 00                      dup.x2 sp(0)
	<pow+27 @050563>   : 11 04                      dup.x2 sp(4)
	<pow+29 @050565>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @050569>   : 14 04                      set.x2 sp(4)
	<pow+35 @05056b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@05056f> - <@05057e>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @05056f>   : 11 05                      dup.x2 sp(5)
	<pow+41 @050571>   : 11 02                      dup.x2 sp(2)
	<pow+43 @050573>   : 83                         mul.f64
	<pow+44 @050574>   : 11 09                      dup.x2 sp(9)
	<pow+46 @050576>   : 11 06                      dup.x2 sp(6)
	<pow+48 @050578>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @05057c>   : 83                         mul.f64
	<pow+53 @05057d>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@05057e> - <@050591>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @05057e>   : 11 04                      dup.x2 sp(4)
	<pow+56 @050580>   : 11 09                      dup.x2 sp(9)
	<pow+58 @050582>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @050586>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @050588>   : 80                         neg.f64
	<pow+65 @050589>   : 11 06                      dup.x2 sp(6)
	<pow+67 @05058b>   : 83                         mul.f64
	<pow+68 @05058c>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @050590>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@050591> - <@0505ac>): return void(.result := {...});
	<pow+73 @050591>   : 11 00                      dup.x2 sp(0)
	<pow+75 @050593>   : 11 04                      dup.x2 sp(4)
	<pow+77 @050595>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @050599>   : 83                         mul.f64
	<pow+82 @05059a>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@05059c> - <@0505a7>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @05059c>   : 11 00                      dup.x2 sp(0)
	<pow+86 @05059e>   : 11 04                      dup.x2 sp(4)
	<pow+88 @0505a0>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @0505a4>   : 83                         mul.f64
	<pow+93 @0505a5>   : 14 15                      set.x2 sp(21)
	<pow+95 @0505a7>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @0505ab>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@0505b0>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@0505b0> - <@0505d6>)
	lib/std/string.ci:5: (16 bytes: <@0505b0> - <@0505c0>): if (bool((str) == null))
	<length @0505b0>      : 10 01                      dup.x1 sp(1)
	<length+2 @0505b2>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @0505b7>    : 57                         ceq.i32
	<length+8 @0505b8>    : 06 08 00 00                jz <length+16 @0505c0>
	lib/std/string.ci:6: (4 bytes: <@0505bc> - <@0505c0>): return int32(.result := 0);
	<length+12 @0505bc>   : 19                         load.z32
	<length+13 @0505bd>   : 13 03                      set.x1 sp(3)
	<length+15 @0505bf>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@0505c0> - <@0505c1>): result: int32 := 0
	<length+16 @0505c0>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@0505c1> - <@0505d3>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @0505c1>   : 04 08 00 00                jmp <length+25 @0505c9>
	lib/std/string.ci:9: (4 bytes: <@0505c5> - <@0505c9>): int32(result := int32(result + 1))
	<length+21 @0505c5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@0505c9> - <@0505d3>): str[result]
	<length+25 @0505c9>   : 10 02                      dup.x1 sp(2)
	<length+27 @0505cb>   : 10 01                      dup.x1 sp(1)
	<length+29 @0505cd>   : 51                         add.i32
	<length+30 @0505ce>   : 20                         load.i8
	<length+31 @0505cf>   : 05 f6 ff ff                jnz <length+21 @0505c5>
	lib/std/string.ci:11: (3 bytes: <@0505d3> - <@0505d6>): return int32(.result := result);
	<length+35 @0505d3>   : 13 03                      set.x1 sp(3)
	<length+37 @0505d5>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@0505d8>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@0505d8> - <@05060a>)
	lib/std/string.ci:16: (42 bytes: <@0505d8> - <@050602>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @0505d8>      : 19                         load.z32
	<indexOf+1 @0505d9>    : 04 1b 00 00                jmp <indexOf+28 @0505f4>
	lib/std/string.ci:17: (19 bytes: <@0505dd> - <@0505f0>): if (bool(str[i] == chr))
	<indexOf+5 @0505dd>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @0505df>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @0505e1>    : 51                         add.i32
	<indexOf+10 @0505e2>   : 20                         load.i8
	<indexOf+11 @0505e3>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @0505e7>   : 20                         load.i8
	<indexOf+16 @0505e8>   : 57                         ceq.i32
	<indexOf+17 @0505e9>   : 06 07 00 00                jz <indexOf+24 @0505f0>
	lib/std/string.ci:18: (3 bytes: <@0505ed> - <@0505f0>): return int32(.result := i);
	<indexOf+21 @0505ed>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @0505ef>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@0505f0> - <@0505f4>): int32(i := int32(i + 1))
	<indexOf+24 @0505f0>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@0505f4> - <@0505fe>): str[i]
	<indexOf+28 @0505f4>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @0505f6>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @0505f8>   : 51                         add.i32
	<indexOf+33 @0505f9>   : 20                         load.i8
	<indexOf+34 @0505fa>   : 05 e3 ff ff                jnz <indexOf+5 @0505dd>
	<indexOf+38 @0505fe>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@050602> - <@05060a>): return int32(.result := int32(-1));
	<indexOf+42 @050602>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @050607>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @050609>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050610>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@050610> - <@050642>)
	lib/std/string.ci:26: (5 bytes: <@050610> - <@050615>): result: int32 := int32(-1)
	<lastIndexOf @050610>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@050615> - <@05063f>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @050615>    : 19                         load.z32
	<lastIndexOf+6 @050616>    : 04 1b 00 00                jmp <lastIndexOf+33 @050631>
	lib/std/string.ci:28: (19 bytes: <@05061a> - <@05062d>): if (bool(str[i] == chr))
	<lastIndexOf+10 @05061a>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @05061c>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @05061e>   : 51                         add.i32
	<lastIndexOf+15 @05061f>   : 20                         load.i8
	<lastIndexOf+16 @050620>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @050624>   : 20                         load.i8
	<lastIndexOf+21 @050625>   : 57                         ceq.i32
	<lastIndexOf+22 @050626>   : 06 07 00 00                jz <lastIndexOf+29 @05062d>
	lib/std/string.ci:29: (3 bytes: <@05062a> - <@05062d>): int32(result := i);
	<lastIndexOf+26 @05062a>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@05062d> - <@050631>): int32(i := int32(i + 1))
	<lastIndexOf+29 @05062d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@050631> - <@05063b>): str[i]
	<lastIndexOf+33 @050631>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @050633>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @050635>   : 51                         add.i32
	<lastIndexOf+38 @050636>   : 20                         load.i8
	<lastIndexOf+39 @050637>   : 05 e3 ff ff                jnz <lastIndexOf+10 @05061a>
	<lastIndexOf+43 @05063b>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@05063f> - <@050642>): return int32(.result := result);
	<lastIndexOf+47 @05063f>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @050641>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@050648>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@050648> - <@050691>)
	lib/std/string.ci:37: (62 bytes: <@050648> - <@050686>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @050648>      : 19                         load.z32
	<startsWith+1 @050649>    : 04 2d 00 00                jmp <startsWith+46 @050676>
	lib/std/string.ci:38: (37 bytes: <@05064d> - <@050672>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @05064d>    : 19                         load.z32
	<startsWith+6 @05064e>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @050650>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @050652>   : 51                         add.i32
	<startsWith+11 @050653>   : 20                         load.i8
	<startsWith+12 @050654>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @050656>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @050658>   : 51                         add.i32
	<startsWith+17 @050659>   : 20                         load.i8
	<startsWith+18 @05065a>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @05065c>   : 02                         call
	<startsWith+21 @05065d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @050661>   : 19                         load.z32
	<startsWith+26 @050662>   : 57                         ceq.i32
	<startsWith+27 @050663>   : 05 0f 00 00                jnz <startsWith+42 @050672>
	lib/std/string.ci:39: (11 bytes: <@050667> - <@050672>): return bool(.result := false);
	<startsWith+31 @050667>   : 19                         load.z32
	<startsWith+32 @050668>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @05066c>   : 25                         store.i8
	<startsWith+37 @05066d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @050671>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@050672> - <@050676>): int32(i := int32(i + 1))
	<startsWith+42 @050672>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@050676> - <@050682>): bool((with[i]) != 0)
	<startsWith+46 @050676>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @050678>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @05067a>   : 51                         add.i32
	<startsWith+51 @05067b>   : 20                         load.i8
	<startsWith+52 @05067c>   : 19                         load.z32
	<startsWith+53 @05067d>   : 57                         ceq.i32
	<startsWith+54 @05067e>   : 06 cf ff ff                jz <startsWith+5 @05064d>
	<startsWith+58 @050682>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@050686> - <@050691>): return bool(.result := true);
	<startsWith+62 @050686>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @05068b>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @05068f>   : 25                         store.i8
	<startsWith+72 @050690>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@050698>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@050698> - <@050716>)
	lib/std/string.ci:47: (13 bytes: <@050698> - <@0506a5>): withLen: int32 := length(with)
	<endsWith @050698>      : 19                         load.z32
	<endsWith+1 @050699>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @05069b>    : 1f b0 05 05 00             load.ref <@0505b0> ;length(str: char[*]): int32
	<endsWith+8 @0506a0>    : 02                         call
	<endsWith+9 @0506a1>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@0506a5> - <@0506b2>): strLen: int32 := length(str)
	<endsWith+13 @0506a5>   : 19                         load.z32
	<endsWith+14 @0506a6>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @0506a8>   : 1f b0 05 05 00             load.ref <@0505b0> ;length(str: char[*]): int32
	<endsWith+21 @0506ad>   : 02                         call
	<endsWith+22 @0506ae>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@0506b2> - <@0506c6>): if (bool(strLen < withLen))
	<endsWith+26 @0506b2>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @0506b4>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @0506b6>   : 58                         clt.i32
	<endsWith+31 @0506b7>   : 06 0f 00 00                jz <endsWith+46 @0506c6>
	lib/std/string.ci:50: (11 bytes: <@0506bb> - <@0506c6>): return bool(.result := false);
	<endsWith+35 @0506bb>   : 19                         load.z32
	<endsWith+36 @0506bc>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @0506c0>   : 25                         store.i8
	<endsWith+41 @0506c1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @0506c5>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@0506c6> - <@050707>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @0506c6>   : 19                         load.z32
	<endsWith+47 @0506c7>   : 04 33 00 00                jmp <endsWith+98 @0506fa>
	lib/std/string.ci:53: (43 bytes: <@0506cb> - <@0506f6>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @0506cb>   : 19                         load.z32
	<endsWith+52 @0506cc>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @0506ce>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @0506d0>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @0506d2>   : 52                         sub.i32
	<endsWith+59 @0506d3>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @0506d5>   : 51                         add.i32
	<endsWith+62 @0506d6>   : 51                         add.i32
	<endsWith+63 @0506d7>   : 20                         load.i8
	<endsWith+64 @0506d8>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @0506da>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @0506dc>   : 51                         add.i32
	<endsWith+69 @0506dd>   : 20                         load.i8
	<endsWith+70 @0506de>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @0506e0>   : 02                         call
	<endsWith+73 @0506e1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @0506e5>   : 19                         load.z32
	<endsWith+78 @0506e6>   : 57                         ceq.i32
	<endsWith+79 @0506e7>   : 05 0f 00 00                jnz <endsWith+94 @0506f6>
	lib/std/string.ci:54: (11 bytes: <@0506eb> - <@0506f6>): return bool(.result := false);
	<endsWith+83 @0506eb>   : 19                         load.z32
	<endsWith+84 @0506ec>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @0506f0>   : 25                         store.i8
	<endsWith+89 @0506f1>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @0506f5>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@0506f6> - <@0506fa>): int32(i := int32(i + 1))
	<endsWith+94 @0506f6>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@0506fa> - <@050703>): bool(i < withLen)
	<endsWith+98 @0506fa>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @0506fc>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @0506fe>  : 58                         clt.i32
	<endsWith+103 @0506ff>  : 05 cc ff ff                jnz <endsWith+51 @0506cb>
	<endsWith+107 @050703>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@050707> - <@050716>): return bool(.result := true);
	<endsWith+111 @050707>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @05070c>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @050710>  : 25                         store.i8
	<endsWith+121 @050711>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @050715>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@050718>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@050718> - <@050757>)
	lib/std/string.ci:62: (1 byte: <@050718> - <@050719>): result: int32 := 0
	<compare @050718>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@050719> - <@050754>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @050719>    : 19                         load.z32
	<compare+2 @05071a>    : 04 2e 00 00                jmp <compare+48 @050748>
	lib/std/string.ci:64: (22 bytes: <@05071e> - <@050734>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @05071e>    : 19                         load.z32
	<compare+7 @05071f>    : 10 06                      dup.x1 sp(6)
	<compare+9 @050721>    : 10 02                      dup.x1 sp(2)
	<compare+11 @050723>   : 51                         add.i32
	<compare+12 @050724>   : 20                         load.i8
	<compare+13 @050725>   : 10 06                      dup.x1 sp(6)
	<compare+15 @050727>   : 10 03                      dup.x1 sp(3)
	<compare+17 @050729>   : 51                         add.i32
	<compare+18 @05072a>   : 20                         load.i8
	<compare+19 @05072b>   : 10 06                      dup.x1 sp(6)
	<compare+21 @05072d>   : 02                         call
	<compare+22 @05072e>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @050732>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:65: (16 bytes: <@050734> - <@050744>): if (bool((str[i]) == 0))
	<compare+28 @050734>   : 10 05                      dup.x1 sp(5)
	<compare+30 @050736>   : 10 01                      dup.x1 sp(1)
	<compare+32 @050738>   : 51                         add.i32
	<compare+33 @050739>   : 20                         load.i8
	<compare+34 @05073a>   : 19                         load.z32
	<compare+35 @05073b>   : 57                         ceq.i32
	<compare+36 @05073c>   : 06 08 00 00                jz <compare+44 @050744>
	lib/std/string.ci:66: (4 bytes: <@050740> - <@050744>): break;
	<compare+40 @050740>   : 04 10 00 00                jmp <compare+56 @050750>
	lib/std/string.ci:63: (4 bytes: <@050744> - <@050748>): int32(i := int32(i + 1))
	<compare+44 @050744>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@050748> - <@050750>): bool(result == 0)
	<compare+48 @050748>   : 10 01                      dup.x1 sp(1)
	<compare+50 @05074a>   : 19                         load.z32
	<compare+51 @05074b>   : 57                         ceq.i32
	<compare+52 @05074c>   : 05 d2 ff ff                jnz <compare+6 @05071e>
	<compare+56 @050750>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@050754> - <@050757>): return int32(.result := result);
	<compare+60 @050754>   : 13 05                      set.x1 sp(5)
	<compare+62 @050756>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@0507a0>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@0507a0> - <@0507c4>)
	lib/std/string.ci:84: (36 bytes: <@0507a0> - <@0507c4>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @0507a0>      : 19                         load.z32
	<ignCaseCmp+1 @0507a1>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @0507a5>    : 20                         load.i8
	<ignCaseCmp+6 @0507a6>    : 1f 58 07 05 00             load.ref <@050758> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @0507ab>   : 02                         call
	<ignCaseCmp+12 @0507ac>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @0507b0>   : 19                         load.z32
	<ignCaseCmp+17 @0507b1>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @0507b5>   : 20                         load.i8
	<ignCaseCmp+22 @0507b6>   : 1f 58 07 05 00             load.ref <@050758> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @0507bb>   : 02                         call
	<ignCaseCmp+28 @0507bc>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @0507c0>   : 52                         sub.i32
	<ignCaseCmp+33 @0507c1>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @0507c3>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@0507c8>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@0507c8> - <@0507d6>)
	lib/std/string.ci:89: (14 bytes: <@0507c8> - <@0507d6>): return char(.result := char(chr - with));
	<caseCmp @0507c8>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @0507cc>    : 20                         load.i8
	<caseCmp+5 @0507cd>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @0507d1>    : 20                         load.i8
	<caseCmp+10 @0507d2>   : 52                         sub.i32
	<caseCmp+11 @0507d3>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @0507d5>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0225a0>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@0507d8>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@0507d8> - <@05082c>)
	lib/std/string.ci:127: (56 bytes: <@0507d8> - <@050810>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @0507d8>      : 19                         load.z32
	<append+1 @0507d9>    : 04 29 00 00                jmp <append+42 @050802>
	lib/std/string.ci:128: (13 bytes: <@0507dd> - <@0507ea>): if (bool(pos >= (output.length)))
	<append+5 @0507dd>    : 10 03                      dup.x1 sp(3)
	<append+7 @0507df>    : 10 06                      dup.x1 sp(6)
	<append+9 @0507e1>    : 58                         clt.i32
	<append+10 @0507e2>   : 05 08 00 00                jnz <append+18 @0507ea>
	lib/std/string.ci:129: (4 bytes: <@0507e6> - <@0507ea>): break;
	<append+14 @0507e6>   : 04 26 00 00                jmp <append+52 @05080c>
	lib/std/string.ci:131: (12 bytes: <@0507ea> - <@0507f6>): char(output[pos] := value[i]);
	<append+18 @0507ea>   : 10 02                      dup.x1 sp(2)
	<append+20 @0507ec>   : 10 01                      dup.x1 sp(1)
	<append+22 @0507ee>   : 51                         add.i32
	<append+23 @0507ef>   : 20                         load.i8
	<append+24 @0507f0>   : 10 05                      dup.x1 sp(5)
	<append+26 @0507f2>   : 10 05                      dup.x1 sp(5)
	<append+28 @0507f4>   : 51                         add.i32
	<append+29 @0507f5>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@0507f6> - <@0507fe>): int32(pos := int32(pos + 1));
	<append+30 @0507f6>   : 10 03                      dup.x1 sp(3)
	<append+32 @0507f8>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @0507fc>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:127: (4 bytes: <@0507fe> - <@050802>): int32(i := int32(i + 1))
	<append+38 @0507fe>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@050802> - <@05080c>): value[i]
	<append+42 @050802>   : 10 02                      dup.x1 sp(2)
	<append+44 @050804>   : 10 01                      dup.x1 sp(1)
	<append+46 @050806>   : 51                         add.i32
	<append+47 @050807>   : 20                         load.i8
	<append+48 @050808>   : 05 d5 ff ff                jnz <append+5 @0507dd>
	<append+52 @05080c>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@050810> - <@050821>): if (bool(pos >= (output.length)))
	<append+56 @050810>   : 10 02                      dup.x1 sp(2)
	<append+58 @050812>   : 10 05                      dup.x1 sp(5)
	<append+60 @050814>   : 58                         clt.i32
	<append+61 @050815>   : 05 0c 00 00                jnz <append+73 @050821>
	lib/std/string.ci:136: (8 bytes: <@050819> - <@050821>): int32(pos := (uint32(output.length - (1))));
	<append+65 @050819>   : 10 04                      dup.x1 sp(4)
	<append+67 @05081b>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @05081f>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:138: (7 bytes: <@050821> - <@050828>): char(output[pos] := (0));
	<append+73 @050821>   : 19                         load.z32
	<append+74 @050822>   : 10 04                      dup.x1 sp(4)
	<append+76 @050824>   : 10 04                      dup.x1 sp(4)
	<append+78 @050826>   : 51                         add.i32
	<append+79 @050827>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@050828> - <@05082c>): return int32(.result := pos);
	<append+80 @050828>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @05082b>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@050840>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@050840> - <@050ad1>)
	lib/std/string.ci:147: (1 byte: <@050840> - <@050841>): len: int32 := 0
	<append @050840>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@050841> - <@050845>): digits: char[80]
	<append+1 @050841>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@050845> - <@050848>): radix: int32 := format.radix
	<append+5 @050845>    : 10 16                      dup.x1 sp(22)
	<append+7 @050847>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@050848> - <@05087e>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @050848>    : 10 00                      dup.x1 sp(0)
	<append+10 @05084a>   : 1c 01 00 00 00             load.c32 1
	<append+15 @05084f>   : 59                         cgt.i32
	<append+16 @050850>   : 06 08 00 00                jz <append+24 @050858>
	<append+20 @050854>   : 04 2a 00 00                jmp <append+62 @05087e>
	<append+24 @050858>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+29 @05085d>   : 1c 97 00 00 00             load.c32 151
	<append+34 @050862>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @050867>   : 1c 80 00 00 00             load.c32 128
	<append+44 @05086c>   : 1f fa f0 01 00             load.ref <@01f0fa> ;"radix is too small"
	<append+49 @050871>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @050876>   : 0a 18 00 00                load.sp(+24)
	<append+58 @05087a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@05087e> - <@0508b3>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @05087e>   : 10 00                      dup.x1 sp(0)
	<append+64 @050880>   : 2a 3c 08 05                load.m32 <@05083c> ;append.radixDigits+4
	<append+68 @050884>   : 58                         clt.i32
	<append+69 @050885>   : 06 08 00 00                jz <append+77 @05088d>
	<append+73 @050889>   : 04 2a 00 00                jmp <append+115 @0508b3>
	<append+77 @05088d>   : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+82 @050892>   : 1c 98 00 00 00             load.c32 152
	<append+87 @050897>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @05089c>   : 1c 80 00 00 00             load.c32 128
	<append+97 @0508a1>   : 1f 0d f1 01 00             load.ref <@01f10d> ;"radix is too big"
	<append+102 @0508a6>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @0508ab>  : 0a 18 00 00                load.sp(+24)
	<append+111 @0508af>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@0508b3> - <@0508e1>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @0508b3>  : 04 26 00 00                jmp <append+153 @0508d9>
	lib/std/string.ci:156: (27 bytes: <@0508b7> - <@0508d2>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @0508b7>  : 2a 38 08 05                load.m32 <@050838> ;append.radixDigits
	<append+123 @0508bb>  : 10 19                      dup.x1 sp(25)
	<append+125 @0508bd>  : 10 02                      dup.x1 sp(2)
	<append+127 @0508bf>  : 35                         mod.u32
	<append+128 @0508c0>  : 51                         add.i32
	<append+129 @0508c1>  : 20                         load.i8
	<append+130 @0508c2>  : 0a 08 00 00                load.sp(+8)
	<append+134 @0508c6>  : 10 17                      dup.x1 sp(23)
	<append+136 @0508c8>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @0508cc>  : 10 00                      dup.x1 sp(0)
	<append+142 @0508ce>  : 13 19                      set.x1 sp(25)
	<append+144 @0508d0>  : 51                         add.i32
	<append+145 @0508d1>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@0508d2> - <@0508d9>): uint32(value := uint32(value / (radix)))
	<append+146 @0508d2>  : 10 18                      dup.x1 sp(24)
	<append+148 @0508d4>  : 10 01                      dup.x1 sp(1)
	<append+150 @0508d6>  : 34                         div.u32
	<append+151 @0508d7>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:155: (8 bytes: <@0508d9> - <@0508e1>): bool(value > (0))
	<append+153 @0508d9>  : 10 18                      dup.x1 sp(24)
	<append+155 @0508db>  : 19                         load.z32
	<append+156 @0508dc>  : 39                         cgt.u32
	<append+157 @0508dd>  : 05 da ff ff                jnz <append+119 @0508b7>
	lib/std/string.ci:158: (29 bytes: <@0508e1> - <@0508fe>): if (bool(len == 0))
	<append+161 @0508e1>  : 10 15                      dup.x1 sp(21)
	<append+163 @0508e3>  : 19                         load.z32
	<append+164 @0508e4>  : 57                         ceq.i32
	<append+165 @0508e5>  : 06 19 00 00                jz <append+190 @0508fe>
	lib/std/string.ci:159: (21 bytes: <@0508e9> - <@0508fe>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @0508e9>  : 1c 30 00 00 00             load.c32 48
	<append+174 @0508ee>  : 0a 08 00 00                load.sp(+8)
	<append+178 @0508f2>  : 10 17                      dup.x1 sp(23)
	<append+180 @0508f4>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @0508f8>  : 10 00                      dup.x1 sp(0)
	<append+186 @0508fa>  : 13 19                      set.x1 sp(25)
	<append+188 @0508fc>  : 51                         add.i32
	<append+189 @0508fd>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@0508fe> - <@050908>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @0508fe>  : 10 17                      dup.x1 sp(23)
	<append+192 @050900>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @050904>  : 22                         load.i32
	<append+197 @050905>  : 10 16                      dup.x1 sp(22)
	<append+199 @050907>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@050908> - <@05090f>): padChr: char := format.padChr
	<append+200 @050908>  : 10 18                      dup.x1 sp(24)
	<append+202 @05090a>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @05090e>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@05090f> - <@050924>): if (bool(padChr == ''))
	<append+207 @05090f>  : 0a 00 00 00                load.sp(+0)
	<append+211 @050913>  : 20                         load.i8
	<append+212 @050914>  : 19                         load.z32
	<append+213 @050915>  : 57                         ceq.i32
	<append+214 @050916>  : 06 0e 00 00                jz <append+228 @050924>
	lib/std/string.ci:166: (10 bytes: <@05091a> - <@050924>): char(padChr := ' ');
	<append+218 @05091a>  : 1c 20 00 00 00             load.c32 32
	<append+223 @05091f>  : 0a 04 00 00                load.sp(+4)
	<append+227 @050923>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@050924> - <@0509f3>): if (bool((sign) != 0))
	<append+228 @050924>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @050928>  : 20                         load.i8
	<append+233 @050929>  : 19                         load.z32
	<append+234 @05092a>  : 57                         ceq.i32
	<append+235 @05092b>  : 05 c8 00 00                jnz <append+435 @0509f3>
	lib/std/string.ci:171: (8 bytes: <@05092f> - <@050937>): int32(maxLen := int32(maxLen - 1));
	<append+239 @05092f>  : 10 01                      dup.x1 sp(1)
	<append+241 @050931>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @050935>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (117 bytes: <@050937> - <@0509ac>): if (contains(void(whiteSpace, padChr)))
	<append+247 @050937>  : 19                         load.z32
	<append+248 @050938>  : 2a 30 08 05                load.m32 <@050830> ;append.whiteSpace
	<append+252 @05093c>  : 0a 08 00 00                load.sp(+8)
	<append+256 @050940>  : 20                         load.i8
	<append+257 @050941>  : 1f d8 05 05 00             load.ref <@0505d8> ;indexOf(str: char[*], chr: char): int32
	<append+262 @050946>  : 02                         call
	<append+263 @050947>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @05094b>  : 19                         load.z32
	<append+268 @05094c>  : 58                         clt.i32
	<append+269 @05094d>  : 05 5f 00 00                jnz <append+364 @0509ac>
	lib/std/string.ci:174: (91 bytes: <@050951> - <@0509ac>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @050951>  : 04 53 00 00                jmp <append+356 @0509a4>
	lib/std/string.ci:175: (52 bytes: <@050955> - <@050989>): assert(bool(pos < (output.length)));
	<append+277 @050955>  : 10 1c                      dup.x1 sp(28)
	<append+279 @050957>  : 10 1f                      dup.x1 sp(31)
	<append+281 @050959>  : 58                         clt.i32
	<append+282 @05095a>  : 06 08 00 00                jz <append+290 @050962>
	<append+286 @05095e>  : 04 2b 00 00                jmp <append+329 @050989>
	<append+290 @050962>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+295 @050967>  : 1c af 00 00 00             load.c32 175
	<append+300 @05096c>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @050971>  : 1c 80 00 00 00             load.c32 128
	<append+310 @050976>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+315 @05097b>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @050980>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @050985>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@050989> - <@050994>): char(output[pos] := padChr);
	<append+329 @050989>  : 0a 00 00 00                load.sp(+0)
	<append+333 @05098d>  : 20                         load.i8
	<append+334 @05098e>  : 10 1e                      dup.x1 sp(30)
	<append+336 @050990>  : 10 1e                      dup.x1 sp(30)
	<append+338 @050992>  : 51                         add.i32
	<append+339 @050993>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@050994> - <@05099c>): int32(pos := int32(pos + 1));
	<append+340 @050994>  : 10 1c                      dup.x1 sp(28)
	<append+342 @050996>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @05099a>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:174: (8 bytes: <@05099c> - <@0509a4>): int32(maxLen := int32(maxLen - 1))
	<append+348 @05099c>  : 10 01                      dup.x1 sp(1)
	<append+350 @05099e>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @0509a2>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:174: (8 bytes: <@0509a4> - <@0509ac>): bool(maxLen > 0)
	<append+356 @0509a4>  : 10 01                      dup.x1 sp(1)
	<append+358 @0509a6>  : 19                         load.z32
	<append+359 @0509a7>  : 59                         cgt.i32
	<append+360 @0509a8>  : 05 ad ff ff                jnz <append+277 @050955>
	lib/std/string.ci:180: (52 bytes: <@0509ac> - <@0509e0>): assert(bool(pos < (output.length)));
	<append+364 @0509ac>  : 10 1c                      dup.x1 sp(28)
	<append+366 @0509ae>  : 10 1f                      dup.x1 sp(31)
	<append+368 @0509b0>  : 58                         clt.i32
	<append+369 @0509b1>  : 06 08 00 00                jz <append+377 @0509b9>
	<append+373 @0509b5>  : 04 2b 00 00                jmp <append+416 @0509e0>
	<append+377 @0509b9>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+382 @0509be>  : 1c b4 00 00 00             load.c32 180
	<append+387 @0509c3>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @0509c8>  : 1c 80 00 00 00             load.c32 128
	<append+397 @0509cd>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+402 @0509d2>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @0509d7>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @0509dc>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@0509e0> - <@0509eb>): char(output[pos] := sign);
	<append+416 @0509e0>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @0509e4>  : 20                         load.i8
	<append+421 @0509e5>  : 10 1e                      dup.x1 sp(30)
	<append+423 @0509e7>  : 10 1e                      dup.x1 sp(30)
	<append+425 @0509e9>  : 51                         add.i32
	<append+426 @0509ea>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@0509eb> - <@0509f3>): int32(pos := int32(pos + 1));
	<append+427 @0509eb>  : 10 1c                      dup.x1 sp(28)
	<append+429 @0509ed>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @0509f1>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (91 bytes: <@0509f3> - <@050a4e>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @0509f3>  : 04 53 00 00                jmp <append+518 @050a46>
	lib/std/string.ci:187: (52 bytes: <@0509f7> - <@050a2b>): assert(bool(pos < (output.length)));
	<append+439 @0509f7>  : 10 1c                      dup.x1 sp(28)
	<append+441 @0509f9>  : 10 1f                      dup.x1 sp(31)
	<append+443 @0509fb>  : 58                         clt.i32
	<append+444 @0509fc>  : 06 08 00 00                jz <append+452 @050a04>
	<append+448 @050a00>  : 04 2b 00 00                jmp <append+491 @050a2b>
	<append+452 @050a04>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+457 @050a09>  : 1c bb 00 00 00             load.c32 187
	<append+462 @050a0e>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @050a13>  : 1c 80 00 00 00             load.c32 128
	<append+472 @050a18>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+477 @050a1d>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @050a22>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @050a27>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@050a2b> - <@050a36>): char(output[pos] := padChr);
	<append+491 @050a2b>  : 0a 00 00 00                load.sp(+0)
	<append+495 @050a2f>  : 20                         load.i8
	<append+496 @050a30>  : 10 1e                      dup.x1 sp(30)
	<append+498 @050a32>  : 10 1e                      dup.x1 sp(30)
	<append+500 @050a34>  : 51                         add.i32
	<append+501 @050a35>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@050a36> - <@050a3e>): int32(pos := int32(pos + 1));
	<append+502 @050a36>  : 10 1c                      dup.x1 sp(28)
	<append+504 @050a38>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @050a3c>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (8 bytes: <@050a3e> - <@050a46>): int32(maxLen := int32(maxLen - 1))
	<append+510 @050a3e>  : 10 01                      dup.x1 sp(1)
	<append+512 @050a40>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @050a44>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:186: (8 bytes: <@050a46> - <@050a4e>): bool(maxLen > 0)
	<append+518 @050a46>  : 10 01                      dup.x1 sp(1)
	<append+520 @050a48>  : 19                         load.z32
	<append+521 @050a49>  : 59                         cgt.i32
	<append+522 @050a4a>  : 05 ad ff ff                jnz <append+439 @0509f7>
	lib/std/string.ci:193: (99 bytes: <@050a4e> - <@050ab1>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @050a4e>  : 19                         load.z32
	<append+527 @050a4f>  : 04 55 00 00                jmp <append+612 @050aa4>
	lib/std/string.ci:194: (52 bytes: <@050a53> - <@050a87>): assert(bool(i < (output.length)));
	<append+531 @050a53>  : 10 00                      dup.x1 sp(0)
	<append+533 @050a55>  : 10 20                      dup.x1 sp(32)
	<append+535 @050a57>  : 58                         clt.i32
	<append+536 @050a58>  : 06 08 00 00                jz <append+544 @050a60>
	<append+540 @050a5c>  : 04 2b 00 00                jmp <append+583 @050a87>
	<append+544 @050a60>  : 1f 68 ed 01 00             load.ref <@01ed68> ;"lib/std/string.ci"
	<append+549 @050a65>  : 1c c2 00 00 00             load.c32 194
	<append+554 @050a6a>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @050a6f>  : 1c 80 00 00 00             load.c32 128
	<append+564 @050a74>  : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<append+569 @050a79>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @050a7e>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @050a83>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@050a87> - <@050a98>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @050a87>  : 0a 10 00 00                load.sp(+16)
	<append+587 @050a8b>  : 10 19                      dup.x1 sp(25)
	<append+589 @050a8d>  : 10 02                      dup.x1 sp(2)
	<append+591 @050a8f>  : 52                         sub.i32
	<append+592 @050a90>  : 51                         add.i32
	<append+593 @050a91>  : 20                         load.i8
	<append+594 @050a92>  : 10 1f                      dup.x1 sp(31)
	<append+596 @050a94>  : 10 1f                      dup.x1 sp(31)
	<append+598 @050a96>  : 51                         add.i32
	<append+599 @050a97>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@050a98> - <@050aa0>): int32(pos := int32(pos + 1));
	<append+600 @050a98>  : 10 1d                      dup.x1 sp(29)
	<append+602 @050a9a>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @050a9e>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:193: (4 bytes: <@050aa0> - <@050aa4>): int32(i := int32(i + 1))
	<append+608 @050aa0>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@050aa4> - <@050aad>): bool(i < len)
	<append+612 @050aa4>  : 10 00                      dup.x1 sp(0)
	<append+614 @050aa6>  : 10 19                      dup.x1 sp(25)
	<append+616 @050aa8>  : 58                         clt.i32
	<append+617 @050aa9>  : 05 aa ff ff                jnz <append+531 @050a53>
	<append+621 @050aad>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@050ab1> - <@050ac2>): if (bool(pos >= (output.length)))
	<append+625 @050ab1>  : 10 1c                      dup.x1 sp(28)
	<append+627 @050ab3>  : 10 1f                      dup.x1 sp(31)
	<append+629 @050ab5>  : 58                         clt.i32
	<append+630 @050ab6>  : 05 0c 00 00                jnz <append+642 @050ac2>
	lib/std/string.ci:200: (8 bytes: <@050aba> - <@050ac2>): int32(pos := (uint32(output.length - (1))));
	<append+634 @050aba>  : 10 1e                      dup.x1 sp(30)
	<append+636 @050abc>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @050ac0>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:202: (7 bytes: <@050ac2> - <@050ac9>): char(output[pos] := (0));
	<append+642 @050ac2>  : 19                         load.z32
	<append+643 @050ac3>  : 10 1e                      dup.x1 sp(30)
	<append+645 @050ac5>  : 10 1e                      dup.x1 sp(30)
	<append+647 @050ac7>  : 51                         add.i32
	<append+648 @050ac8>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@050ac9> - <@050ad1>): return int32(.result := pos);
	<append+649 @050ac9>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @050acc>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @050ad0>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@050ad8>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@050ad8> - <@050aef>)
	lib/std/string.ci:208: (23 bytes: <@050ad8> - <@050aef>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @050ad8>      : 19                         load.z32
	<append+1 @050ad9>    : 11 05                      dup.x2 sp(5)
	<append+3 @050adb>    : 10 06                      dup.x1 sp(6)
	<append+5 @050add>    : 19                         load.z32
	<append+6 @050ade>    : 10 07                      dup.x1 sp(7)
	<append+8 @050ae0>    : 10 07                      dup.x1 sp(7)
	<append+10 @050ae2>   : 1f 40 08 05 00             load.ref <@050840> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @050ae7>   : 02                         call
	<append+16 @050ae8>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @050aec>   : 13 07                      set.x1 sp(7)
	<append+22 @050aee>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@050af0>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@050af0> - <@050b21>)
	lib/std/string.ci:213: (1 byte: <@050af0> - <@050af1>): sign: int32 := 0
	<append @050af0>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@050af1> - <@050b05>): if (bool(value < 0))
	<append+1 @050af1>    : 10 03                      dup.x1 sp(3)
	<append+3 @050af3>    : 19                         load.z32
	<append+4 @050af4>    : 58                         clt.i32
	<append+5 @050af5>    : 06 10 00 00                jz <append+21 @050b05>
	lib/std/string.ci:215: (7 bytes: <@050af9> - <@050b00>): int32(sign := ('-'));
	<append+9 @050af9>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @050afe>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:216: (5 bytes: <@050b00> - <@050b05>): int32(value := int32(-value));
	<append+16 @050b00>   : 10 03                      dup.x1 sp(3)
	<append+18 @050b02>   : 50                         neg.i32
	<append+19 @050b03>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:218: (28 bytes: <@050b05> - <@050b21>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @050b05>   : 19                         load.z32
	<append+22 @050b06>   : 11 06                      dup.x2 sp(6)
	<append+24 @050b08>   : 10 07                      dup.x1 sp(7)
	<append+26 @050b0a>   : 10 04                      dup.x1 sp(4)
	<append+28 @050b0c>   : 10 08                      dup.x1 sp(8)
	<append+30 @050b0e>   : 10 08                      dup.x1 sp(8)
	<append+32 @050b10>   : 1f 40 08 05 00             load.ref <@050840> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @050b15>   : 02                         call
	<append+38 @050b16>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @050b1a>   : 13 08                      set.x1 sp(8)
	<append+44 @050b1c>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @050b20>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@050b38>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@050b38> - <@050b51>)
	lib/std/string.ci:224: (25 bytes: <@050b38> - <@050b51>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @050b38>      : 19                         load.z32
	<append+1 @050b39>    : 11 04                      dup.x2 sp(4)
	<append+3 @050b3b>    : 10 05                      dup.x1 sp(5)
	<append+5 @050b3d>    : 10 05                      dup.x1 sp(5)
	<append+7 @050b3f>    : 1f 28 0b 05 00             load.ref <@050b28> ;append.format
	<append+12 @050b44>   : 1f d8 0a 05 00             load.ref <@050ad8> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @050b49>   : 02                         call
	<append+18 @050b4a>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @050b4e>   : 13 06                      set.x1 sp(6)
	<append+24 @050b50>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024730>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050b58>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@050b58> - <@050b5f>)
	lib/vec/vec2d.ci:17: (7 bytes: <@050b58> - <@050b5f>): return void(.result := {...});
	<vec2d @050b58>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@050b5b> - <@050b5e>): void(.result.y := y);
	<vec2d+3 @050b5b>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @050b5e>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0256e8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@050b60>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@050b60> - <@050b6d>)
	lib/vec/vec4f.ci:29: (13 bytes: <@050b60> - <@050b6d>): return void(.result := {...});
	<vec4f @050b60>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@050b63> - <@050b66>): void(.result.y := y);
	<vec4f+3 @050b63>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@050b66> - <@050b69>): void(.result.z := z);
	<vec4f+6 @050b66>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@050b69> - <@050b6c>): void(.result.w := w);
	<vec4f+9 @050b69>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @050b6c>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with given x, y, z components, and w with 0'
.value: vec4f(void(void(void(x, y), z), 0.000000))
.usages:
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(len(v))))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@028ac8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@050b70>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@050b70> - <@050ba1>)
	lib/vec/mat4f.ci:31: (49 bytes: <@050b70> - <@050ba1>): return void(.result := {...});
	<mat4f @050b70>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes: <@050b73> - <@050b76>): void(.result.x.y := xy);
	<mat4f+3 @050b73>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes: <@050b76> - <@050b79>): void(.result.x.z := xz);
	<mat4f+6 @050b76>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes: <@050b79> - <@050b7c>): void(.result.x.w := xw);
	<mat4f+9 @050b79>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes: <@050b7c> - <@050b7f>): void(.result.y.x := yx);
	<mat4f+12 @050b7c>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes: <@050b7f> - <@050b82>): void(.result.y.y := yy);
	<mat4f+15 @050b7f>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes: <@050b82> - <@050b85>): void(.result.y.z := yz);
	<mat4f+18 @050b82>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes: <@050b85> - <@050b88>): void(.result.y.w := yw);
	<mat4f+21 @050b85>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes: <@050b88> - <@050b8b>): void(.result.z.x := zx);
	<mat4f+24 @050b88>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes: <@050b8b> - <@050b8e>): void(.result.z.y := zy);
	<mat4f+27 @050b8b>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes: <@050b8e> - <@050b91>): void(.result.z.z := zz);
	<mat4f+30 @050b8e>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes: <@050b91> - <@050b94>): void(.result.z.w := zw);
	<mat4f+33 @050b91>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes: <@050b94> - <@050b97>): void(.result.w.x := wx);
	<mat4f+36 @050b94>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes: <@050b97> - <@050b9a>): void(.result.w.y := wy);
	<mat4f+39 @050b97>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes: <@050b9a> - <@050b9d>): void(.result.w.z := wz);
	<mat4f+42 @050b9a>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes: <@050b9d> - <@050ba0>): void(.result.w.w := ww);
	<mat4f+45 @050b9d>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @050ba0>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@050ba8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@050ba8> - <@050bbd>)
	lib/vec/mat4f.ci:41: (21 bytes: <@050ba8> - <@050bbd>): return void(.result := {...});
	<mat4f @050ba8>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @050baa>    : 24                         load.i128
	<mat4f+3 @050bab>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes: <@050bad> - <@050bb2>): void(.result.y := y);
	<mat4f+5 @050bad>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @050baf>    : 24                         load.i128
	<mat4f+8 @050bb0>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes: <@050bb2> - <@050bb7>): void(.result.z := z);
	<mat4f+10 @050bb2>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @050bb4>   : 24                         load.i128
	<mat4f+13 @050bb5>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes: <@050bb7> - <@050bbc>): void(.result.w := w);
	<mat4f+15 @050bb7>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @050bb9>   : 24                         load.i128
	<mat4f+18 @050bba>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @050bbc>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@050bc0>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@050bc0> - <@050d61>)
	lib/vec/mat4f.ci:53: (144 bytes: <@050bc0> - <@050c50>): transposed: mat4f := {...}
	<mul @050bc0>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes: <@050bc4> - <@050bc9>): void(transposed.x.x := rhs.x.x);
	<mul+4 @050bc4>    : 10 11                      dup.x1 sp(17)
	<mul+6 @050bc6>    : 22                         load.i32
	<mul+7 @050bc7>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes: <@050bc9> - <@050bd2>): void(transposed.x.y := rhs.y.x);
	<mul+9 @050bc9>    : 10 11                      dup.x1 sp(17)
	<mul+11 @050bcb>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @050bcf>   : 22                         load.i32
	<mul+16 @050bd0>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes: <@050bd2> - <@050bdb>): void(transposed.x.z := rhs.z.x);
	<mul+18 @050bd2>   : 10 11                      dup.x1 sp(17)
	<mul+20 @050bd4>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @050bd8>   : 22                         load.i32
	<mul+25 @050bd9>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes: <@050bdb> - <@050be4>): void(transposed.x.w := rhs.w.x);
	<mul+27 @050bdb>   : 10 11                      dup.x1 sp(17)
	<mul+29 @050bdd>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @050be1>   : 22                         load.i32
	<mul+34 @050be2>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes: <@050be4> - <@050bed>): void(transposed.y.x := rhs.x.y);
	<mul+36 @050be4>   : 10 11                      dup.x1 sp(17)
	<mul+38 @050be6>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @050bea>   : 22                         load.i32
	<mul+43 @050beb>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes: <@050bed> - <@050bf6>): void(transposed.y.y := rhs.y.y);
	<mul+45 @050bed>   : 10 11                      dup.x1 sp(17)
	<mul+47 @050bef>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @050bf3>   : 22                         load.i32
	<mul+52 @050bf4>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes: <@050bf6> - <@050bff>): void(transposed.y.z := rhs.z.y);
	<mul+54 @050bf6>   : 10 11                      dup.x1 sp(17)
	<mul+56 @050bf8>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @050bfc>   : 22                         load.i32
	<mul+61 @050bfd>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes: <@050bff> - <@050c08>): void(transposed.y.w := rhs.w.y);
	<mul+63 @050bff>   : 10 11                      dup.x1 sp(17)
	<mul+65 @050c01>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @050c05>   : 22                         load.i32
	<mul+70 @050c06>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c08> - <@050c11>): void(transposed.z.x := rhs.x.z);
	<mul+72 @050c08>   : 10 11                      dup.x1 sp(17)
	<mul+74 @050c0a>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @050c0e>   : 22                         load.i32
	<mul+79 @050c0f>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c11> - <@050c1a>): void(transposed.z.y := rhs.y.z);
	<mul+81 @050c11>   : 10 11                      dup.x1 sp(17)
	<mul+83 @050c13>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @050c17>   : 22                         load.i32
	<mul+88 @050c18>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c1a> - <@050c23>): void(transposed.z.z := rhs.z.z);
	<mul+90 @050c1a>   : 10 11                      dup.x1 sp(17)
	<mul+92 @050c1c>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @050c20>   : 22                         load.i32
	<mul+97 @050c21>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c23> - <@050c2c>): void(transposed.z.w := rhs.w.z);
	<mul+99 @050c23>   : 10 11                      dup.x1 sp(17)
	<mul+101 @050c25>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @050c29>  : 22                         load.i32
	<mul+106 @050c2a>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes: <@050c2c> - <@050c35>): void(transposed.w.x := rhs.x.w);
	<mul+108 @050c2c>  : 10 11                      dup.x1 sp(17)
	<mul+110 @050c2e>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @050c32>  : 22                         load.i32
	<mul+115 @050c33>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes: <@050c35> - <@050c3e>): void(transposed.w.y := rhs.y.w);
	<mul+117 @050c35>  : 10 11                      dup.x1 sp(17)
	<mul+119 @050c37>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @050c3b>  : 22                         load.i32
	<mul+124 @050c3c>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes: <@050c3e> - <@050c47>): void(transposed.w.z := rhs.z.w);
	<mul+126 @050c3e>  : 10 11                      dup.x1 sp(17)
	<mul+128 @050c40>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @050c44>  : 22                         load.i32
	<mul+133 @050c45>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes: <@050c47> - <@050c50>): void(transposed.w.w := rhs.w.w);
	<mul+135 @050c47>  : 10 11                      dup.x1 sp(17)
	<mul+137 @050c49>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @050c4d>  : 22                         load.i32
	<mul+142 @050c4e>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes: <@050c50> - <@050d61>): return void(.result := {...});
	<mul+144 @050c50>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @050c54>  : 10 13                      dup.x1 sp(19)
	<mul+150 @050c56>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @050c5a>  : 10 04                      dup.x1 sp(4)
	<mul+156 @050c5c>  : 24                         load.i128
	<mul+157 @050c5d>  : 10 09                      dup.x1 sp(9)
	<mul+159 @050c5f>  : 24                         load.i128
	<mul+160 @050c60>  : 9b                         dp4.v4f
	<mul+161 @050c61>  : 10 05                      dup.x1 sp(5)
	<mul+163 @050c63>  : 24                         load.i128
	<mul+164 @050c64>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @050c66>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @050c6a>  : 24                         load.i128
	<mul+171 @050c6b>  : 9b                         dp4.v4f
	<mul+172 @050c6c>  : 10 06                      dup.x1 sp(6)
	<mul+174 @050c6e>  : 24                         load.i128
	<mul+175 @050c6f>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @050c71>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @050c75>  : 24                         load.i128
	<mul+182 @050c76>  : 9b                         dp4.v4f
	<mul+183 @050c77>  : 10 07                      dup.x1 sp(7)
	<mul+185 @050c79>  : 24                         load.i128
	<mul+186 @050c7a>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @050c7c>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @050c80>  : 24                         load.i128
	<mul+193 @050c81>  : 9b                         dp4.v4f
	<mul+194 @050c82>  : 1f 60 0b 05 00             load.ref <@050b60> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @050c87>  : 02                         call
	<mul+200 @050c88>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @050c8c>  : 15 02                      set.x4 sp(2)
	<mul+206 @050c8e>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes: <@050c90> - <@050cd4>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @050c90>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @050c94>  : 10 13                      dup.x1 sp(19)
	<mul+214 @050c96>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @050c9a>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @050c9e>  : 10 04                      dup.x1 sp(4)
	<mul+224 @050ca0>  : 24                         load.i128
	<mul+225 @050ca1>  : 10 09                      dup.x1 sp(9)
	<mul+227 @050ca3>  : 24                         load.i128
	<mul+228 @050ca4>  : 9b                         dp4.v4f
	<mul+229 @050ca5>  : 10 05                      dup.x1 sp(5)
	<mul+231 @050ca7>  : 24                         load.i128
	<mul+232 @050ca8>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @050caa>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @050cae>  : 24                         load.i128
	<mul+239 @050caf>  : 9b                         dp4.v4f
	<mul+240 @050cb0>  : 10 06                      dup.x1 sp(6)
	<mul+242 @050cb2>  : 24                         load.i128
	<mul+243 @050cb3>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @050cb5>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @050cb9>  : 24                         load.i128
	<mul+250 @050cba>  : 9b                         dp4.v4f
	<mul+251 @050cbb>  : 10 07                      dup.x1 sp(7)
	<mul+253 @050cbd>  : 24                         load.i128
	<mul+254 @050cbe>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @050cc0>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @050cc4>  : 24                         load.i128
	<mul+261 @050cc5>  : 9b                         dp4.v4f
	<mul+262 @050cc6>  : 1f 60 0b 05 00             load.ref <@050b60> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @050ccb>  : 02                         call
	<mul+268 @050ccc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @050cd0>  : 15 02                      set.x4 sp(2)
	<mul+274 @050cd2>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes: <@050cd4> - <@050d18>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @050cd4>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @050cd8>  : 10 13                      dup.x1 sp(19)
	<mul+282 @050cda>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @050cde>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @050ce2>  : 10 04                      dup.x1 sp(4)
	<mul+292 @050ce4>  : 24                         load.i128
	<mul+293 @050ce5>  : 10 09                      dup.x1 sp(9)
	<mul+295 @050ce7>  : 24                         load.i128
	<mul+296 @050ce8>  : 9b                         dp4.v4f
	<mul+297 @050ce9>  : 10 05                      dup.x1 sp(5)
	<mul+299 @050ceb>  : 24                         load.i128
	<mul+300 @050cec>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @050cee>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @050cf2>  : 24                         load.i128
	<mul+307 @050cf3>  : 9b                         dp4.v4f
	<mul+308 @050cf4>  : 10 06                      dup.x1 sp(6)
	<mul+310 @050cf6>  : 24                         load.i128
	<mul+311 @050cf7>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @050cf9>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @050cfd>  : 24                         load.i128
	<mul+318 @050cfe>  : 9b                         dp4.v4f
	<mul+319 @050cff>  : 10 07                      dup.x1 sp(7)
	<mul+321 @050d01>  : 24                         load.i128
	<mul+322 @050d02>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @050d04>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @050d08>  : 24                         load.i128
	<mul+329 @050d09>  : 9b                         dp4.v4f
	<mul+330 @050d0a>  : 1f 60 0b 05 00             load.ref <@050b60> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @050d0f>  : 02                         call
	<mul+336 @050d10>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @050d14>  : 15 02                      set.x4 sp(2)
	<mul+342 @050d16>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes: <@050d18> - <@050d5c>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @050d18>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @050d1c>  : 10 13                      dup.x1 sp(19)
	<mul+350 @050d1e>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @050d22>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @050d26>  : 10 04                      dup.x1 sp(4)
	<mul+360 @050d28>  : 24                         load.i128
	<mul+361 @050d29>  : 10 09                      dup.x1 sp(9)
	<mul+363 @050d2b>  : 24                         load.i128
	<mul+364 @050d2c>  : 9b                         dp4.v4f
	<mul+365 @050d2d>  : 10 05                      dup.x1 sp(5)
	<mul+367 @050d2f>  : 24                         load.i128
	<mul+368 @050d30>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @050d32>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @050d36>  : 24                         load.i128
	<mul+375 @050d37>  : 9b                         dp4.v4f
	<mul+376 @050d38>  : 10 06                      dup.x1 sp(6)
	<mul+378 @050d3a>  : 24                         load.i128
	<mul+379 @050d3b>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @050d3d>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @050d41>  : 24                         load.i128
	<mul+386 @050d42>  : 9b                         dp4.v4f
	<mul+387 @050d43>  : 10 07                      dup.x1 sp(7)
	<mul+389 @050d45>  : 24                         load.i128
	<mul+390 @050d46>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @050d48>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @050d4c>  : 24                         load.i128
	<mul+397 @050d4d>  : 9b                         dp4.v4f
	<mul+398 @050d4e>  : 1f 60 0b 05 00             load.ref <@050b60> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @050d53>  : 02                         call
	<mul+404 @050d54>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @050d58>  : 15 02                      set.x4 sp(2)
	<mul+410 @050d5a>  : 15 23                      set.x4 sp(35)
	<mul+412 @050d5c>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @050d60>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@030ff0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031120>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@050d68>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@050d70>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@050d70> - <@050d71>)
	<empty @050d70>      : 03                         ret
.usages:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@050d78>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@050d78> - <@050d80>)
	test/lang/function.ci:7: (8 bytes: <@050d78> - <@050d80>): return int32(.result := int32(x + y));
	<funAdd @050d78>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @050d7a>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @050d7c>    : 51                         add.i32
	<funAdd+5 @050d7d>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @050d7f>    : 03                         ret
.usages:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.usages:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.usages:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.usages:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@050d80>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@050d80> - <@050d88>)
	test/lang/function.ci:33: (8 bytes: <@050d80> - <@050d88>): return int32(.result := int32(x * y));
	<funMul @050d80>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @050d82>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @050d84>    : 53                         mul.i32
	<funMul+5 @050d85>    : 13 04                      set.x1 sp(4)
	<funMul+7 @050d87>    : 03                         ret
.usages:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@050d88>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@050d88> - <@050dbe>)
	test/lang/function.ci:38: (16 bytes: <@050d88> - <@050d98>): if (bool(n <= (1)))
	<fib @050d88>      : 10 01                      dup.x1 sp(1)
	<fib+2 @050d8a>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @050d8f>    : 39                         cgt.u32
	<fib+8 @050d90>    : 05 08 00 00                jnz <fib+16 @050d98>
	test/lang/function.ci:39: (4 bytes: <@050d94> - <@050d98>): return uint32(.result := n);
	<fib+12 @050d94>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @050d97>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@050d98> - <@050dbe>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @050d98>   : 19                         load.z32
	<fib+17 @050d99>   : 10 02                      dup.x1 sp(2)
	<fib+19 @050d9b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @050d9f>   : 1f 88 0d 05 00             load.ref <@050d88> ;fib(n: uint32): uint32
	<fib+28 @050da4>   : 02                         call
	<fib+29 @050da5>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @050da9>   : 19                         load.z32
	<fib+34 @050daa>   : 10 03                      dup.x1 sp(3)
	<fib+36 @050dac>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @050db0>   : 1f 88 0d 05 00             load.ref <@050d88> ;fib(n: uint32): uint32
	<fib+45 @050db5>   : 02                         call
	<fib+46 @050db6>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @050dba>   : 51                         add.i32
	<fib+51 @050dbb>   : 13 03                      set.x1 sp(3)
	<fib+53 @050dbd>   : 03                         ret
.usages:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.usages:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@036e10>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@036f40>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@050dc0>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@050dc0> - <@050dc1>)
	<noError @050dc0>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@050dc8>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@050dc8> - <@050de0>)
	test/stdc/tryExec.ci:15: (4 bytes: <@050dc8> - <@050dcc>): data: uint8[8192]
	<stackOverflow @050dc8>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@050dcc> - <@050ddb>): stackOverflow(ptr);
	<stackOverflow+4 @050dcc>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @050dd0>    : 22                         load.i32
	<stackOverflow+9 @050dd1>    : 1f c8 0d 05 00             load.ref <@050dc8> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @050dd6>   : 02                         call
	<stackOverflow+15 @050dd7>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @050ddb>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @050ddf>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050de0>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@050de0> - <@050dec>)
	test/stdc/tryExec.ci:20: (7 bytes: <@050de0> - <@050de7>): value: int32 := int32(3 / 0)
	<divisionByZero @050de0>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @050de5>    : 19                         load.z32
	<divisionByZero+6 @050de6>    : 54                         div.i32
	<divisionByZero+7 @050de7>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @050deb>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@050df0>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@050df0> - <@050e34>)
	test/stdc/tryExec.ci:29: (25 bytes: <@050df0> - <@050e09>): details: NotEquals := {...}
	<abortExecution @050df0>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@050df4> - <@050dfb>): void(details.message := ("assertion failed"));
	<abortExecution+4 @050df4>    : 1f 7b cc 00 00             load.ref <@00cc7b> ;"assertion failed"
	<abortExecution+9 @050df9>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@050dfb> - <@050e02>): void(details.expected := 97);
	<abortExecution+11 @050dfb>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @050e00>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@050e02> - <@050e09>): void(details.returned := 77);
	<abortExecution+18 @050e02>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @050e07>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@050e09> - <@050e2f>): abort(void("fatal error", details));
	<abortExecution+25 @050e09>   : 1f b0 ab 03 00             load.ref <@03abb0> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @050e0e>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @050e13>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @050e18>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @050e1d>   : 1f f9 ab 03 00             load.ref <@03abf9> ;"fatal error"
	<abortExecution+50 @050e22>   : 1f 10 b6 03 00             load.ref <@03b610> ;abortExecution.NotEquals
	<abortExecution+55 @050e27>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @050e2b>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @050e2f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @050e33>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@050e38>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@050e38> - <@050e45>)
	test/stdc/tryExec.ci:38: (5 bytes: <@050e38> - <@050e3d>): i32Ref: int32 := null
	<invalidMemoryAccess @050e38>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@050e3d> - <@050e40>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @050e3d>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @050e3f>    : 22                         load.i32
	<invalidMemoryAccess+8 @050e40>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @050e44>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@050e48>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@050e48> - <@050e4a>)
	test/stdc/tryExec.ci:43: (2 bytes: <@050e48> - <@050e4a>): emit(void(load.z32, ret));
	<invalidInstruction @050e48>      : 19                         load.z32
	<invalidInstruction+1 @050e49>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@050e50>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@050e50> - <@050e54>)
	test/lang/array.ci:103: (4 bytes: <@050e50> - <@050e54>): return uint32(.result := values.length);
	<lenSlice @050e50>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @050e53>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050e58>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050e58> - <@050e64>)
	test/lang/array.ci:104: (12 bytes: <@050e58> - <@050e64>): return int64(.result := values[idx]);
	<nthFixed @050e58>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @050e5a>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @050e5c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @050e60>    : 23                         load.i64
	<nthFixed+9 @050e61>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @050e63>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050e68>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050e68> - <@050e74>)
	test/lang/array.ci:105: (12 bytes: <@050e68> - <@050e74>): return int64(.result := values[idx]);
	<nthArray @050e68>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @050e6a>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @050e6c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @050e70>    : 23                         load.i64
	<nthArray+9 @050e71>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @050e73>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050e78>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050e78> - <@050e84>)
	test/lang/array.ci:106: (12 bytes: <@050e78> - <@050e84>): return int64(.result := values[idx]);
	<nthSlice @050e78>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @050e7a>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @050e7c>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @050e80>    : 23                         load.i64
	<nthSlice+9 @050e81>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @050e83>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03e358>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@03e3f0>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@050e88>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@050e90>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@050e98>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@050ea0>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@050ea8>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@050eb0>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03e3f0>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@050e88>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@050e90>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@050e98>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050ea0>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050ea8>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050eb0>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03ee30>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 39, offs: <@050eb8>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@050ee0>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@050ee8>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@050f10>, cast: static const function)
.usages:
	test/lang/method.ci:80: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:68: referenced as `RecordMethodTest`
	test/lang/method.ci:65: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:30: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:19: referenced as `RecordMethodTest`
	test/lang/method.ci:15: referenced as `RecordMethodTest`
	test/lang/method.ci:11: referenced as `RecordMethodTest`
	test/lang/method.ci:6: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050eb8>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@050eb8> - <@050edf>)
	test/lang/method.ci:7: (38 bytes: <@050eb8> - <@050ede>): trace(void("staticMethod", x));
	<staticMethod @050eb8>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<staticMethod+5 @050ebd>    : 1c 07 00 00 00             load.c32 7
	<staticMethod+10 @050ec2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @050ec7>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @050ecc>   : 1f 95 ed 03 00             load.ref <@03ed95> ;"staticMethod"
	<staticMethod+25 @050ed1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @050ed6>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @050eda>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @050ede>   : 03                         ret
.usages:
	test/lang/method.ci:79: referenced as `staticMethod`
	test/lang/method.ci:65: referenced as `staticMethod`
	test/lang/method.ci:58: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@050ee0>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:11'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.usages:
	test/lang/method.ci:19: referenced as `forwardMethod`
	test/lang/method.ci:11: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:15'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.usages:
	test/lang/method.ci:46: referenced as `abstractMethod`
	test/lang/method.ci:15: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:19'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.usages:
	test/lang/method.ci:19: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: virtualMethod
.usages:
	test/lang/method.ci:81: referenced as `virtualMethod`
	test/lang/method.ci:71: referenced as `virtualMethod`
	test/lang/method.ci:59: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050ee8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@050ee8> - <@050f0f>)
	test/lang/method.ci:26: (38 bytes: <@050ee8> - <@050f0e>): trace(void("virtualMethod", x));
	<virtualMethod @050ee8>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<virtualMethod+5 @050eed>    : 1c 1a 00 00 00             load.c32 26
	<virtualMethod+10 @050ef2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @050ef7>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @050efc>   : 1f d3 ed 03 00             load.ref <@03edd3> ;"virtualMethod"
	<virtualMethod+25 @050f01>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @050f06>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @050f0a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @050f0e>   : 03                         ret
.usages:
	test/lang/method.ci:80: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050f10>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:30'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@050f10> - <@050f37>)
	test/lang/method.ci:31: (38 bytes: <@050f10> - <@050f36>): trace(void("forwardMethod", x));
	<forwardMethod @050f10>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<forwardMethod+5 @050f15>    : 1c 1f 00 00 00             load.c32 31
	<forwardMethod+10 @050f1a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @050f1f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @050f24>   : 1f a7 ed 03 00             load.ref <@03eda7> ;"forwardMethod"
	<forwardMethod+25 @050f29>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @050f2e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @050f32>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @050f36>   : 03                         ret
.usages:
	test/lang/method.ci:30: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050f38>
.name: 'globalFunction'
.file: 'test/lang/method.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@050f38> - <@050f5f>)
	test/lang/method.ci:41: (38 bytes: <@050f38> - <@050f5e>): trace(void("globalFunction", x));
	<globalFunction @050f38>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<globalFunction+5 @050f3d>    : 1c 29 00 00 00             load.c32 41
	<globalFunction+10 @050f42>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @050f47>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @050f4c>   : 1f e1 ed 03 00             load.ref <@03ede1> ;"globalFunction"
	<globalFunction+25 @050f51>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @050f56>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @050f5a>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @050f5e>   : 03                         ret
.usages:
	test/lang/method.ci:46: referenced as `globalFunction`
	test/lang/method.ci:40: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:44'
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:80: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:76: referenced as `recordMethodTest`
	test/lang/method.ci:75: referenced as `recordMethodTest`
	test/lang/method.ci:59: referenced as `recordMethodTest`
	test/lang/method.ci:58: referenced as `recordMethodTest`
	test/lang/method.ci:44: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@050f60>
.name: 'staticMethod'
.file: 'test/lang/method.ci:62'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@050f60> - <@050fa2>)
	test/lang/method.ci:63: (35 bytes: <@050f60> - <@050f83>): debug("extension.staticMethod");
	<staticMethod @050f60>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<staticMethod+5 @050f65>    : 1c 3f 00 00 00             load.c32 63
	<staticMethod+10 @050f6a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @050f6f>   : 19                         load.z32
	<staticMethod+16 @050f70>   : 1f 01 ee 03 00             load.ref <@03ee01> ;"extension.staticMethod"
	<staticMethod+21 @050f75>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @050f7a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @050f7f>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:64: (30 bytes: <@050f83> - <@050fa1>): if (bool((this) != null))
	<staticMethod+35 @050f83>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @050f87>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @050f8c>   : 57                         ceq.i32
	<staticMethod+45 @050f8d>   : 05 14 00 00                jnz <staticMethod+65 @050fa1>
	test/lang/method.ci:65: (16 bytes: <@050f91> - <@050fa1>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @050f91>   : 12 02                      dup.x4 sp(2)
	<staticMethod+51 @050f93>   : 10 05                      dup.x1 sp(5)
	<staticMethod+53 @050f95>   : 13 04                      set.x1 sp(4)
	<staticMethod+55 @050f97>   : 1f b8 0e 05 00             load.ref <@050eb8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @050f9c>   : 02                         call
	<staticMethod+61 @050f9d>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @050fa1>   : 03                         ret
.usages:
	test/lang/method.ci:75: referenced as `staticMethod`
	test/lang/method.ci:62: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@050fa8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:68'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@050fa8> - <@050fe7>)
	test/lang/method.ci:69: (35 bytes: <@050fa8> - <@050fcb>): debug("extension.virtualMethod");
	<virtualMethod @050fa8>      : 1f 70 ed 03 00             load.ref <@03ed70> ;"test/lang/method.ci"
	<virtualMethod+5 @050fad>    : 1c 45 00 00 00             load.c32 69
	<virtualMethod+10 @050fb2>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @050fb7>   : 19                         load.z32
	<virtualMethod+16 @050fb8>   : 1f 18 ee 03 00             load.ref <@03ee18> ;"extension.virtualMethod"
	<virtualMethod+21 @050fbd>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @050fc2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @050fc7>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:70: (27 bytes: <@050fcb> - <@050fe6>): if (bool((this) != null))
	<virtualMethod+35 @050fcb>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @050fcf>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @050fd4>   : 57                         ceq.i32
	<virtualMethod+45 @050fd5>   : 05 11 00 00                jnz <virtualMethod+62 @050fe6>
	test/lang/method.ci:71: (13 bytes: <@050fd9> - <@050fe6>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @050fd9>   : 12 02                      dup.x4 sp(2)
	<virtualMethod+51 @050fdb>   : 10 05                      dup.x1 sp(5)
	<virtualMethod+53 @050fdd>   : 13 04                      set.x1 sp(4)
	<virtualMethod+55 @050fdf>   : 10 08                      dup.x1 sp(8)
	<virtualMethod+57 @050fe1>   : 02                         call
	<virtualMethod+58 @050fe2>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @050fe6>   : 03                         ret
.usages:
	test/lang/method.ci:76: referenced as `virtualMethod`
	test/lang/method.ci:68: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0405b0>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@040810>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@040a70>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@040c38>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1356>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1360>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1364>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1368>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1372>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@0410d8>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@041500>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@041928>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@041d50>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@042178>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0425a0>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1376>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1496>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1500>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1584>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1588>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1672>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1676>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1760>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1764>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1848>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1852>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1936>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1940>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2024>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2028>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2048>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2056>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2172>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2176>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2196>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2204>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2320>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2324>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2384>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2388>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2408>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2416>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2484>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2488>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2504>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2508>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2520>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2524>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2532>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2540>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2936>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2940>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2956>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2972>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2980>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2988>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2996>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3004>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3012>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3020>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3028>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3032>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3036>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3040>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3044>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3048>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3052>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3056>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3060>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3064>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3068>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3072>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 10884
.offset: <@050fe7>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@001058>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@0010f8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005c20>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006d00>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0075e0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008250>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00fbe0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@04fc98>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@010e58>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@019b78>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@050498>, cast: static const function)
.field Complex: function (size: 7, offs: <@0504a0>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@0504a8>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@050528>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@050548>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@0505b0>, cast: static const function)
.field indexOf: function (size: 50, offs: <@0505d8>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@050610>, cast: static const function)
.field startsWith: function (size: 73, offs: <@050648>, cast: static const function)
.field endsWith: function (size: 126, offs: <@050698>, cast: static const function)
.field compare: function (size: 63, offs: <@050718>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@0507a0>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@0507c8>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@0225a0>, cast: static const typename(val))
.field append: function (size: 84, offs: <@0507d8>, cast: static const function)
.field append: function (size: 657, offs: <@050840>, cast: static const function)
.field append: function (size: 23, offs: <@050ad8>, cast: static const function)
.field append: function (size: 49, offs: <@050af0>, cast: static const function)
.field append: function (size: 25, offs: <@050b38>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024730>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@050b58>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@0256e8>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@050b60>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@028ac8>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@050b70>, cast: static const function)
.field mat4f: function (size: 21, offs: <@050ba8>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@050bc0>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@030ff0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@031120>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@050d68>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@050d70>, cast: static const function)
.field funAdd: function (size: 8, offs: <@050d78>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@050d80>, cast: static const function)
.field fib: function (size: 54, offs: <@050d88>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@036e10>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@036f40>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@050dc0>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@050dc8>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@050de0>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@050df0>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@050e38>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@050e48>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@050e50>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@050e58>, cast: static const function)
.field nthArray: function (size: 12, offs: <@050e68>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@050e78>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@03e358>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03ee30>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@050f38>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field staticMethod: function (size: 66, offs: <@050f60>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@050fa8>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@0405b0>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@040810>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@040a70>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@040c38>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1356>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1360>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1364>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1368>, cast: variable(val))
.field blue: color (size: 4, offs: <+1372>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@0410d8>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@041500>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@041928>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@041d50>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@042178>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@0425a0>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1376>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1496>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1500>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1584>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1588>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1672>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1676>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1760>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1764>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1848>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1852>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1936>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1940>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2024>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2028>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2048>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2056>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2172>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2176>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2196>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2204>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2320>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2324>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2384>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2388>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2408>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2416>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2484>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2488>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2504>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2508>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2520>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2524>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2532>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2540>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2936>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2940>, cast: variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <+2956>, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <+2972>, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <+2980>, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <+2988>, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <+2996>, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <+3004>, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <+3012>, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <+3020>, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <+3028>, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <+3032>, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <+3036>, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <+3040>, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <+3044>, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <+3048>, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <+3052>, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <+3056>, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <+3060>, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <+3064>, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <+3068>, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <+3072>, cast: variable(f32))
.field .main: function (size: 10884, offs: <@050fe7>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (10884 bytes: <@050fe7> - <@053a6b>)
	lib/std/string.ci:144: (14 bytes: <@050fe7> - <@050ff5>): static const whiteSpace: char[] := " \t\n\r"
	<.main @050fe7>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @050fec>    : 1f b9 f0 01 00             load.ref <@01f0b9> ;" \t\n\r"
	<.main+10 @050ff1>   : 2d 30 08 05                store.m64 <@050830> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@050ff5> - <@051003>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @050ff5>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @050ffa>   : 1f ca f0 01 00             load.ref <@01f0ca> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @050fff>   : 2d 38 08 05                store.m64 <@050838> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@051003> - <@05101d>): static const format: FormatFlags := {...}
	<.main+28 @051003>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @051008>   : 2e 28 0b 05                store.m32 <@050b28> ;append.format
	:: (7 bytes: <@05100c> - <@051013>): void(format.padChr := (0))
	<.main+37 @05100c>   : 19                         load.z32
	<.main+38 @05100d>   : 1f 2c 0b 05 00             load.ref <@050b2c> ;append.format+4
	<.main+43 @051012>   : 25                         store.i8
	:: (5 bytes: <@051013> - <@051018>): void(format.padLen := 0)
	<.main+44 @051013>   : 19                         load.z32
	<.main+45 @051014>   : 2e 30 0b 05                store.m32 <@050b30> ;append.format+8
	:: (5 bytes: <@051018> - <@05101d>): void(format.precision := 0)
	<.main+49 @051018>   : 19                         load.z32
	<.main+50 @051019>   : 2e 34 0b 05                store.m32 <@050b34> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@05101d> - <@05102a>): static value: int64 := 42
	<.main+54 @05101d>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @051026>   : 2d 68 0d 05                store.m64 <@050d68> ;value
	test/lang/member.ci:35: (5 bytes: <@05102a> - <@05102f>): static global: int32
	<.main+67 @05102a>   : 19                         load.z32
	<.main+68 @05102b>   : 2e 88 0e 05                store.m32 <@050e88> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@05102f> - <@051038>): static globalInit: int32 := 1
	<.main+72 @05102f>   : 1c 01 00 00 00             load.c32 1
	<.main+77 @051034>   : 2e 90 0e 05                store.m32 <@050e90> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@051038> - <@051041>): static const globalConstant: int32 := 2
	<.main+81 @051038>   : 1c 02 00 00 00             load.c32 2
	<.main+86 @05103d>   : 2e 98 0e 05                store.m32 <@050e98> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@051041> - <@051053>): static globalRecInit: Inner := {...}
	<.main+90 @051041>   : 1c 04 00 00 00             load.c32 4
	<.main+95 @051046>   : 2e a8 0e 05                store.m32 <@050ea8> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@05104a> - <@051053>): void(globalRecInit.constant := 5);
	<.main+99 @05104a>   : 1c 05 00 00 00             load.c32 5
	<.main+104 @05104f>  : 2e ac 0e 05                store.m32 <@050eac> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@051053> - <@051065>): static const globalConstantRec: Inner := {...}
	<.main+108 @051053>  : 1c 06 00 00 00             load.c32 6
	<.main+113 @051058>  : 2e b0 0e 05                store.m32 <@050eb0> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@05105c> - <@051065>): void(globalConstantRec.constant := 7);
	<.main+117 @05105c>  : 1c 07 00 00 00             load.c32 7
	<.main+122 @051061>  : 2e b4 0e 05                store.m32 <@050eb4> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:11: (9 bytes: <@051065> - <@05106e>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+126 @051065>  : 1f 10 0f 05 00             load.ref <@050f10> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+131 @05106a>  : 2e e0 0e 05                store.m32 <@050ee0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/emit.ci:3: (1 byte: <@05106e> - <@05106f>): emitldz32: int32 := emit(load.z32)
	<.main+135 @05106e>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@05106f> - <@051070>): emitldz64: int64 := emit(load.z64)
	<.main+136 @05106f>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@051070> - <@051075>): emitA: int32 := 42
	<.main+137 @051070>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@051075> - <@05107a>): emitB: int32 := 96
	<.main+142 @051075>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@05107a> - <@05107f>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @05107a>  : 10 01                      dup.x1 sp(1)
	<.main+149 @05107c>  : 10 01                      dup.x1 sp(1)
	<.main+151 @05107e>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@05107f> - <@05108a>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @05107f>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @051084>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @051089>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@05108a> - <@05108f>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @05108a>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@05108f> - <@051095>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @05108f>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @051094>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@051095> - <@05109f>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @051095>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @05109e>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@05109f> - <@0510a8>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @05109f>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@0510a8> - <@0510b2>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @0510a8>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @0510ad>  : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@0510b2> - <@0510b7>): i3: int32 := 3
	<.main+203 @0510b2>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@0510b7> - <@0510bc>): i6: int32 := 6
	<.main+208 @0510b7>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@0510bc> - <@0510c1>): i2: int32 := 2
	<.main+213 @0510bc>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@0510c1> - <@0510c6>): i8: int32 := 8
	<.main+218 @0510c1>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@0510c6> - <@0510c7>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @0510c6>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@0510c7> - <@0510c8>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @0510c7>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@0510c8> - <@0510c9>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @0510c8>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@0510c9> - <@0510ce>): lastVal: int32 := last(void(3, 6))
	<.main+226 @0510c9>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@0510ce> - <@0510d0>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @0510ce>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@0510d0> - <@0510da>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @0510d0>  : 10 07                      dup.x1 sp(7)
	<.main+235 @0510d2>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @0510d6>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@0510da> - <@0510e3>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @0510da>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @0510df>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@0510e3> - <@0510e8>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @0510e3>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @0510e5>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @0510e7>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@0510e8> - <@0510f9>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @0510e8>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @0510ea>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @0510ee>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @0510f0>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @0510f4>  : 51                         add.i32
	<.main+270 @0510f5>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@0510f9> - <@051111>): any2Val: int32 := any(void(3, 6))
	<.main+274 @0510f9>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @0510fe>  : 10 00                      dup.x1 sp(0)
	<.main+281 @051100>  : 06 0a 00 00                jz <.main+291 @05110a>
	<.main+285 @051104>  : 10 00                      dup.x1 sp(0)
	<.main+287 @051106>  : 04 09 00 00                jmp <.main+296 @05110f>
	<.main+291 @05110a>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @05110f>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@051111> - <@051123>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @051111>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @051113>  : 10 00                      dup.x1 sp(0)
	<.main+302 @051115>  : 06 0a 00 00                jz <.main+312 @05111f>
	<.main+306 @051119>  : 10 00                      dup.x1 sp(0)
	<.main+308 @05111b>  : 04 06 00 00                jmp <.main+314 @051121>
	<.main+312 @05111f>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @051121>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@051123> - <@051141>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @051123>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @051125>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @051129>  : 10 00                      dup.x1 sp(0)
	<.main+324 @05112b>  : 06 0a 00 00                jz <.main+334 @051135>
	<.main+328 @05112f>  : 10 00                      dup.x1 sp(0)
	<.main+330 @051131>  : 04 0a 00 00                jmp <.main+340 @05113b>
	<.main+334 @051135>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @051137>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @05113b>  : 13 01                      set.x1 sp(1)
	<.main+342 @05113d>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@051141> - <@051162>): min2Val: int32 := min(void(3, 6))
	<.main+346 @051141>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @051146>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @05114b>  : 10 01                      dup.x1 sp(1)
	<.main+358 @05114d>  : 10 01                      dup.x1 sp(1)
	<.main+360 @05114f>  : 58                         clt.i32
	<.main+361 @051150>  : 06 0a 00 00                jz <.main+371 @05115a>
	<.main+365 @051154>  : 10 01                      dup.x1 sp(1)
	<.main+367 @051156>  : 04 06 00 00                jmp <.main+373 @05115c>
	<.main+371 @05115a>  : 10 00                      dup.x1 sp(0)
	<.main+373 @05115c>  : 13 02                      set.x1 sp(2)
	<.main+375 @05115e>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@051162> - <@05117d>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @051162>  : 10 10                      dup.x1 sp(16)
	<.main+381 @051164>  : 10 10                      dup.x1 sp(16)
	<.main+383 @051166>  : 10 01                      dup.x1 sp(1)
	<.main+385 @051168>  : 10 01                      dup.x1 sp(1)
	<.main+387 @05116a>  : 58                         clt.i32
	<.main+388 @05116b>  : 06 0a 00 00                jz <.main+398 @051175>
	<.main+392 @05116f>  : 10 01                      dup.x1 sp(1)
	<.main+394 @051171>  : 04 06 00 00                jmp <.main+400 @051177>
	<.main+398 @051175>  : 10 00                      dup.x1 sp(0)
	<.main+400 @051177>  : 13 02                      set.x1 sp(2)
	<.main+402 @051179>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@05117d> - <@0511a4>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @05117d>  : 10 11                      dup.x1 sp(17)
	<.main+408 @05117f>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @051183>  : 10 11                      dup.x1 sp(17)
	<.main+414 @051185>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @051189>  : 10 01                      dup.x1 sp(1)
	<.main+420 @05118b>  : 10 01                      dup.x1 sp(1)
	<.main+422 @05118d>  : 58                         clt.i32
	<.main+423 @05118e>  : 06 0a 00 00                jz <.main+433 @051198>
	<.main+427 @051192>  : 10 01                      dup.x1 sp(1)
	<.main+429 @051194>  : 04 06 00 00                jmp <.main+435 @05119a>
	<.main+433 @051198>  : 10 00                      dup.x1 sp(0)
	<.main+435 @05119a>  : 13 02                      set.x1 sp(2)
	<.main+437 @05119c>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @0511a0>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@0511a4> - <@0511c5>): max2Val: int32 := max(void(3, 6))
	<.main+445 @0511a4>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @0511a9>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @0511ae>  : 10 01                      dup.x1 sp(1)
	<.main+457 @0511b0>  : 10 01                      dup.x1 sp(1)
	<.main+459 @0511b2>  : 59                         cgt.i32
	<.main+460 @0511b3>  : 06 0a 00 00                jz <.main+470 @0511bd>
	<.main+464 @0511b7>  : 10 01                      dup.x1 sp(1)
	<.main+466 @0511b9>  : 04 06 00 00                jmp <.main+472 @0511bf>
	<.main+470 @0511bd>  : 10 00                      dup.x1 sp(0)
	<.main+472 @0511bf>  : 13 02                      set.x1 sp(2)
	<.main+474 @0511c1>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@0511c5> - <@0511e0>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @0511c5>  : 10 13                      dup.x1 sp(19)
	<.main+480 @0511c7>  : 10 13                      dup.x1 sp(19)
	<.main+482 @0511c9>  : 10 01                      dup.x1 sp(1)
	<.main+484 @0511cb>  : 10 01                      dup.x1 sp(1)
	<.main+486 @0511cd>  : 59                         cgt.i32
	<.main+487 @0511ce>  : 06 0a 00 00                jz <.main+497 @0511d8>
	<.main+491 @0511d2>  : 10 01                      dup.x1 sp(1)
	<.main+493 @0511d4>  : 04 06 00 00                jmp <.main+499 @0511da>
	<.main+497 @0511d8>  : 10 00                      dup.x1 sp(0)
	<.main+499 @0511da>  : 13 02                      set.x1 sp(2)
	<.main+501 @0511dc>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@0511e0> - <@051207>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @0511e0>  : 10 14                      dup.x1 sp(20)
	<.main+507 @0511e2>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @0511e6>  : 10 14                      dup.x1 sp(20)
	<.main+513 @0511e8>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @0511ec>  : 10 01                      dup.x1 sp(1)
	<.main+519 @0511ee>  : 10 01                      dup.x1 sp(1)
	<.main+521 @0511f0>  : 59                         cgt.i32
	<.main+522 @0511f1>  : 06 0a 00 00                jz <.main+532 @0511fb>
	<.main+526 @0511f5>  : 10 01                      dup.x1 sp(1)
	<.main+528 @0511f7>  : 04 06 00 00                jmp <.main+534 @0511fd>
	<.main+532 @0511fb>  : 10 00                      dup.x1 sp(0)
	<.main+534 @0511fd>  : 13 02                      set.x1 sp(2)
	<.main+536 @0511ff>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @051203>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@051207> - <@05121c>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @051207>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @05120c>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @051211>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @051216>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @05121a>  : 51                         add.i32
	<.main+564 @05121b>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@05121c> - <@05122d>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @05121c>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @051221>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @051225>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @051229>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@05122d> - <@051238>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @05122d>  : 10 17                      dup.x1 sp(23)
	<.main+584 @05122f>  : 10 17                      dup.x1 sp(23)
	<.main+586 @051231>  : 10 17                      dup.x1 sp(23)
	<.main+588 @051233>  : 10 17                      dup.x1 sp(23)
	<.main+590 @051235>  : 51                         add.i32
	<.main+591 @051236>  : 51                         add.i32
	<.main+592 @051237>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@051238> - <@051243>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @051238>  : 10 18                      dup.x1 sp(24)
	<.main+595 @05123a>  : 10 18                      dup.x1 sp(24)
	<.main+597 @05123c>  : 51                         add.i32
	<.main+598 @05123d>  : 10 17                      dup.x1 sp(23)
	<.main+600 @05123f>  : 51                         add.i32
	<.main+601 @051240>  : 10 16                      dup.x1 sp(22)
	<.main+603 @051242>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@051243> - <@051262>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @051243>  : 10 19                      dup.x1 sp(25)
	<.main+606 @051245>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @051249>  : 10 19                      dup.x1 sp(25)
	<.main+612 @05124b>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @05124f>  : 10 19                      dup.x1 sp(25)
	<.main+618 @051251>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @051255>  : 10 19                      dup.x1 sp(25)
	<.main+624 @051257>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @05125b>  : 51                         add.i32
	<.main+629 @05125c>  : 51                         add.i32
	<.main+630 @05125d>  : 51                         add.i32
	<.main+631 @05125e>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@051262> - <@051281>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @051262>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @051264>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @051268>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @05126a>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @05126e>  : 51                         add.i32
	<.main+648 @05126f>  : 10 19                      dup.x1 sp(25)
	<.main+650 @051271>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @051275>  : 51                         add.i32
	<.main+655 @051276>  : 10 18                      dup.x1 sp(24)
	<.main+657 @051278>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @05127c>  : 51                         add.i32
	<.main+662 @05127d>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@051281> - <@0512bf>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @051281>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @051286>  : 10 00                      dup.x1 sp(0)
	<.main+673 @051288>  : 06 0a 00 00                jz <.main+683 @051292>
	<.main+677 @05128c>  : 10 00                      dup.x1 sp(0)
	<.main+679 @05128e>  : 04 2f 00 00                jmp <.main+726 @0512bd>
	<.main+683 @051292>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @051297>  : 10 00                      dup.x1 sp(0)
	<.main+690 @051299>  : 06 0a 00 00                jz <.main+700 @0512a3>
	<.main+694 @05129d>  : 10 00                      dup.x1 sp(0)
	<.main+696 @05129f>  : 04 1c 00 00                jmp <.main+724 @0512bb>
	<.main+700 @0512a3>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @0512a8>  : 10 00                      dup.x1 sp(0)
	<.main+707 @0512aa>  : 06 0a 00 00                jz <.main+717 @0512b4>
	<.main+711 @0512ae>  : 10 00                      dup.x1 sp(0)
	<.main+713 @0512b0>  : 04 09 00 00                jmp <.main+722 @0512b9>
	<.main+717 @0512b4>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @0512b9>  : 13 01                      set.x1 sp(1)
	<.main+724 @0512bb>  : 13 01                      set.x1 sp(1)
	<.main+726 @0512bd>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@0512bf> - <@0512fd>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @0512bf>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @0512c4>  : 10 00                      dup.x1 sp(0)
	<.main+735 @0512c6>  : 06 0a 00 00                jz <.main+745 @0512d0>
	<.main+739 @0512ca>  : 10 00                      dup.x1 sp(0)
	<.main+741 @0512cc>  : 04 09 00 00                jmp <.main+750 @0512d5>
	<.main+745 @0512d0>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @0512d5>  : 13 01                      set.x1 sp(1)
	<.main+752 @0512d7>  : 10 00                      dup.x1 sp(0)
	<.main+754 @0512d9>  : 06 0a 00 00                jz <.main+764 @0512e3>
	<.main+758 @0512dd>  : 10 00                      dup.x1 sp(0)
	<.main+760 @0512df>  : 04 09 00 00                jmp <.main+769 @0512e8>
	<.main+764 @0512e3>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @0512e8>  : 13 01                      set.x1 sp(1)
	<.main+771 @0512ea>  : 10 00                      dup.x1 sp(0)
	<.main+773 @0512ec>  : 06 0a 00 00                jz <.main+783 @0512f6>
	<.main+777 @0512f0>  : 10 00                      dup.x1 sp(0)
	<.main+779 @0512f2>  : 04 09 00 00                jmp <.main+788 @0512fb>
	<.main+783 @0512f6>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @0512fb>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@0512fd> - <@05132f>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @0512fd>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @0512ff>  : 10 00                      dup.x1 sp(0)
	<.main+794 @051301>  : 06 0a 00 00                jz <.main+804 @05130b>
	<.main+798 @051305>  : 10 00                      dup.x1 sp(0)
	<.main+800 @051307>  : 04 26 00 00                jmp <.main+838 @05132d>
	<.main+804 @05130b>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @05130d>  : 10 00                      dup.x1 sp(0)
	<.main+808 @05130f>  : 06 0a 00 00                jz <.main+818 @051319>
	<.main+812 @051313>  : 10 00                      dup.x1 sp(0)
	<.main+814 @051315>  : 04 16 00 00                jmp <.main+836 @05132b>
	<.main+818 @051319>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @05131b>  : 10 00                      dup.x1 sp(0)
	<.main+822 @05131d>  : 06 0a 00 00                jz <.main+832 @051327>
	<.main+826 @051321>  : 10 00                      dup.x1 sp(0)
	<.main+828 @051323>  : 04 06 00 00                jmp <.main+834 @051329>
	<.main+832 @051327>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @051329>  : 13 01                      set.x1 sp(1)
	<.main+836 @05132b>  : 13 01                      set.x1 sp(1)
	<.main+838 @05132d>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@05132f> - <@051361>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @05132f>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @051331>  : 10 00                      dup.x1 sp(0)
	<.main+844 @051333>  : 06 0a 00 00                jz <.main+854 @05133d>
	<.main+848 @051337>  : 10 00                      dup.x1 sp(0)
	<.main+850 @051339>  : 04 06 00 00                jmp <.main+856 @05133f>
	<.main+854 @05133d>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @05133f>  : 13 01                      set.x1 sp(1)
	<.main+858 @051341>  : 10 00                      dup.x1 sp(0)
	<.main+860 @051343>  : 06 0a 00 00                jz <.main+870 @05134d>
	<.main+864 @051347>  : 10 00                      dup.x1 sp(0)
	<.main+866 @051349>  : 04 06 00 00                jmp <.main+872 @05134f>
	<.main+870 @05134d>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @05134f>  : 13 01                      set.x1 sp(1)
	<.main+874 @051351>  : 10 00                      dup.x1 sp(0)
	<.main+876 @051353>  : 06 0a 00 00                jz <.main+886 @05135d>
	<.main+880 @051357>  : 10 00                      dup.x1 sp(0)
	<.main+882 @051359>  : 04 06 00 00                jmp <.main+888 @05135f>
	<.main+886 @05135d>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @05135f>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@051361> - <@0513a7>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @051361>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @051363>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @051367>  : 10 00                      dup.x1 sp(0)
	<.main+898 @051369>  : 06 0a 00 00                jz <.main+908 @051373>
	<.main+902 @05136d>  : 10 00                      dup.x1 sp(0)
	<.main+904 @05136f>  : 04 32 00 00                jmp <.main+954 @0513a1>
	<.main+908 @051373>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @051375>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @051379>  : 10 00                      dup.x1 sp(0)
	<.main+916 @05137b>  : 06 0a 00 00                jz <.main+926 @051385>
	<.main+920 @05137f>  : 10 00                      dup.x1 sp(0)
	<.main+922 @051381>  : 04 1e 00 00                jmp <.main+952 @05139f>
	<.main+926 @051385>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @051387>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @05138b>  : 10 00                      dup.x1 sp(0)
	<.main+934 @05138d>  : 06 0a 00 00                jz <.main+944 @051397>
	<.main+938 @051391>  : 10 00                      dup.x1 sp(0)
	<.main+940 @051393>  : 04 0a 00 00                jmp <.main+950 @05139d>
	<.main+944 @051397>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @051399>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @05139d>  : 13 01                      set.x1 sp(1)
	<.main+952 @05139f>  : 13 01                      set.x1 sp(1)
	<.main+954 @0513a1>  : 13 01                      set.x1 sp(1)
	<.main+956 @0513a3>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@0513a7> - <@0513ed>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @0513a7>  : 10 20                      dup.x1 sp(32)
	<.main+962 @0513a9>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @0513ad>  : 10 00                      dup.x1 sp(0)
	<.main+968 @0513af>  : 06 0a 00 00                jz <.main+978 @0513b9>
	<.main+972 @0513b3>  : 10 00                      dup.x1 sp(0)
	<.main+974 @0513b5>  : 04 0a 00 00                jmp <.main+984 @0513bf>
	<.main+978 @0513b9>  : 10 20                      dup.x1 sp(32)
	<.main+980 @0513bb>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @0513bf>  : 13 01                      set.x1 sp(1)
	<.main+986 @0513c1>  : 10 00                      dup.x1 sp(0)
	<.main+988 @0513c3>  : 06 0a 00 00                jz <.main+998 @0513cd>
	<.main+992 @0513c7>  : 10 00                      dup.x1 sp(0)
	<.main+994 @0513c9>  : 04 0a 00 00                jmp <.main+1004 @0513d3>
	<.main+998 @0513cd>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @0513cf> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @0513d3> : 13 01                      set.x1 sp(1)
	<.main+1006 @0513d5> : 10 00                      dup.x1 sp(0)
	<.main+1008 @0513d7> : 06 0a 00 00                jz <.main+1018 @0513e1>
	<.main+1012 @0513db> : 10 00                      dup.x1 sp(0)
	<.main+1014 @0513dd> : 04 0a 00 00                jmp <.main+1024 @0513e7>
	<.main+1018 @0513e1> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @0513e3> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @0513e7> : 13 01                      set.x1 sp(1)
	<.main+1026 @0513e9> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@0513ed> - <@051446>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @0513ed> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @0513f2> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @0513f7> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @0513fc> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @051401> : 10 01                      dup.x1 sp(1)
	<.main+1052 @051403> : 10 01                      dup.x1 sp(1)
	<.main+1054 @051405> : 58                         clt.i32
	<.main+1055 @051406> : 06 0a 00 00                jz <.main+1065 @051410>
	<.main+1059 @05140a> : 10 01                      dup.x1 sp(1)
	<.main+1061 @05140c> : 04 06 00 00                jmp <.main+1067 @051412>
	<.main+1065 @051410> : 10 00                      dup.x1 sp(0)
	<.main+1067 @051412> : 13 02                      set.x1 sp(2)
	<.main+1069 @051414> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @051418> : 10 01                      dup.x1 sp(1)
	<.main+1075 @05141a> : 10 01                      dup.x1 sp(1)
	<.main+1077 @05141c> : 58                         clt.i32
	<.main+1078 @05141d> : 06 0a 00 00                jz <.main+1088 @051427>
	<.main+1082 @051421> : 10 01                      dup.x1 sp(1)
	<.main+1084 @051423> : 04 06 00 00                jmp <.main+1090 @051429>
	<.main+1088 @051427> : 10 00                      dup.x1 sp(0)
	<.main+1090 @051429> : 13 02                      set.x1 sp(2)
	<.main+1092 @05142b> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @05142f> : 10 01                      dup.x1 sp(1)
	<.main+1098 @051431> : 10 01                      dup.x1 sp(1)
	<.main+1100 @051433> : 58                         clt.i32
	<.main+1101 @051434> : 06 0a 00 00                jz <.main+1111 @05143e>
	<.main+1105 @051438> : 10 01                      dup.x1 sp(1)
	<.main+1107 @05143a> : 04 06 00 00                jmp <.main+1113 @051440>
	<.main+1111 @05143e> : 10 00                      dup.x1 sp(0)
	<.main+1113 @051440> : 13 02                      set.x1 sp(2)
	<.main+1115 @051442> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@051446> - <@05149f>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @051446> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @05144b> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @051450> : 10 01                      dup.x1 sp(1)
	<.main+1131 @051452> : 10 01                      dup.x1 sp(1)
	<.main+1133 @051454> : 58                         clt.i32
	<.main+1134 @051455> : 06 0a 00 00                jz <.main+1144 @05145f>
	<.main+1138 @051459> : 10 01                      dup.x1 sp(1)
	<.main+1140 @05145b> : 04 06 00 00                jmp <.main+1146 @051461>
	<.main+1144 @05145f> : 10 00                      dup.x1 sp(0)
	<.main+1146 @051461> : 13 02                      set.x1 sp(2)
	<.main+1148 @051463> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @051467> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @05146c> : 10 01                      dup.x1 sp(1)
	<.main+1159 @05146e> : 10 01                      dup.x1 sp(1)
	<.main+1161 @051470> : 58                         clt.i32
	<.main+1162 @051471> : 06 0a 00 00                jz <.main+1172 @05147b>
	<.main+1166 @051475> : 10 01                      dup.x1 sp(1)
	<.main+1168 @051477> : 04 06 00 00                jmp <.main+1174 @05147d>
	<.main+1172 @05147b> : 10 00                      dup.x1 sp(0)
	<.main+1174 @05147d> : 13 02                      set.x1 sp(2)
	<.main+1176 @05147f> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @051483> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @051488> : 10 01                      dup.x1 sp(1)
	<.main+1187 @05148a> : 10 01                      dup.x1 sp(1)
	<.main+1189 @05148c> : 58                         clt.i32
	<.main+1190 @05148d> : 06 0a 00 00                jz <.main+1200 @051497>
	<.main+1194 @051491> : 10 01                      dup.x1 sp(1)
	<.main+1196 @051493> : 04 06 00 00                jmp <.main+1202 @051499>
	<.main+1200 @051497> : 10 00                      dup.x1 sp(0)
	<.main+1202 @051499> : 13 02                      set.x1 sp(2)
	<.main+1204 @05149b> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@05149f> - <@0514ec>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @05149f> : 10 23                      dup.x1 sp(35)
	<.main+1210 @0514a1> : 10 23                      dup.x1 sp(35)
	<.main+1212 @0514a3> : 10 23                      dup.x1 sp(35)
	<.main+1214 @0514a5> : 10 23                      dup.x1 sp(35)
	<.main+1216 @0514a7> : 10 01                      dup.x1 sp(1)
	<.main+1218 @0514a9> : 10 01                      dup.x1 sp(1)
	<.main+1220 @0514ab> : 58                         clt.i32
	<.main+1221 @0514ac> : 06 0a 00 00                jz <.main+1231 @0514b6>
	<.main+1225 @0514b0> : 10 01                      dup.x1 sp(1)
	<.main+1227 @0514b2> : 04 06 00 00                jmp <.main+1233 @0514b8>
	<.main+1231 @0514b6> : 10 00                      dup.x1 sp(0)
	<.main+1233 @0514b8> : 13 02                      set.x1 sp(2)
	<.main+1235 @0514ba> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @0514be> : 10 01                      dup.x1 sp(1)
	<.main+1241 @0514c0> : 10 01                      dup.x1 sp(1)
	<.main+1243 @0514c2> : 58                         clt.i32
	<.main+1244 @0514c3> : 06 0a 00 00                jz <.main+1254 @0514cd>
	<.main+1248 @0514c7> : 10 01                      dup.x1 sp(1)
	<.main+1250 @0514c9> : 04 06 00 00                jmp <.main+1256 @0514cf>
	<.main+1254 @0514cd> : 10 00                      dup.x1 sp(0)
	<.main+1256 @0514cf> : 13 02                      set.x1 sp(2)
	<.main+1258 @0514d1> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @0514d5> : 10 01                      dup.x1 sp(1)
	<.main+1264 @0514d7> : 10 01                      dup.x1 sp(1)
	<.main+1266 @0514d9> : 58                         clt.i32
	<.main+1267 @0514da> : 06 0a 00 00                jz <.main+1277 @0514e4>
	<.main+1271 @0514de> : 10 01                      dup.x1 sp(1)
	<.main+1273 @0514e0> : 04 06 00 00                jmp <.main+1279 @0514e6>
	<.main+1277 @0514e4> : 10 00                      dup.x1 sp(0)
	<.main+1279 @0514e6> : 13 02                      set.x1 sp(2)
	<.main+1281 @0514e8> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@0514ec> - <@051539>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @0514ec> : 10 24                      dup.x1 sp(36)
	<.main+1287 @0514ee> : 10 24                      dup.x1 sp(36)
	<.main+1289 @0514f0> : 10 01                      dup.x1 sp(1)
	<.main+1291 @0514f2> : 10 01                      dup.x1 sp(1)
	<.main+1293 @0514f4> : 58                         clt.i32
	<.main+1294 @0514f5> : 06 0a 00 00                jz <.main+1304 @0514ff>
	<.main+1298 @0514f9> : 10 01                      dup.x1 sp(1)
	<.main+1300 @0514fb> : 04 06 00 00                jmp <.main+1306 @051501>
	<.main+1304 @0514ff> : 10 00                      dup.x1 sp(0)
	<.main+1306 @051501> : 13 02                      set.x1 sp(2)
	<.main+1308 @051503> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @051507> : 10 23                      dup.x1 sp(35)
	<.main+1314 @051509> : 10 01                      dup.x1 sp(1)
	<.main+1316 @05150b> : 10 01                      dup.x1 sp(1)
	<.main+1318 @05150d> : 58                         clt.i32
	<.main+1319 @05150e> : 06 0a 00 00                jz <.main+1329 @051518>
	<.main+1323 @051512> : 10 01                      dup.x1 sp(1)
	<.main+1325 @051514> : 04 06 00 00                jmp <.main+1331 @05151a>
	<.main+1329 @051518> : 10 00                      dup.x1 sp(0)
	<.main+1331 @05151a> : 13 02                      set.x1 sp(2)
	<.main+1333 @05151c> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @051520> : 10 22                      dup.x1 sp(34)
	<.main+1339 @051522> : 10 01                      dup.x1 sp(1)
	<.main+1341 @051524> : 10 01                      dup.x1 sp(1)
	<.main+1343 @051526> : 58                         clt.i32
	<.main+1344 @051527> : 06 0a 00 00                jz <.main+1354 @051531>
	<.main+1348 @05152b> : 10 01                      dup.x1 sp(1)
	<.main+1350 @05152d> : 04 06 00 00                jmp <.main+1356 @051533>
	<.main+1354 @051531> : 10 00                      dup.x1 sp(0)
	<.main+1356 @051533> : 13 02                      set.x1 sp(2)
	<.main+1358 @051535> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@051539> - <@05159a>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @051539> : 10 25                      dup.x1 sp(37)
	<.main+1364 @05153b> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @05153f> : 10 25                      dup.x1 sp(37)
	<.main+1370 @051541> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @051545> : 10 25                      dup.x1 sp(37)
	<.main+1376 @051547> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @05154b> : 10 25                      dup.x1 sp(37)
	<.main+1382 @05154d> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @051551> : 10 01                      dup.x1 sp(1)
	<.main+1388 @051553> : 10 01                      dup.x1 sp(1)
	<.main+1390 @051555> : 58                         clt.i32
	<.main+1391 @051556> : 06 0a 00 00                jz <.main+1401 @051560>
	<.main+1395 @05155a> : 10 01                      dup.x1 sp(1)
	<.main+1397 @05155c> : 04 06 00 00                jmp <.main+1403 @051562>
	<.main+1401 @051560> : 10 00                      dup.x1 sp(0)
	<.main+1403 @051562> : 13 02                      set.x1 sp(2)
	<.main+1405 @051564> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @051568> : 10 01                      dup.x1 sp(1)
	<.main+1411 @05156a> : 10 01                      dup.x1 sp(1)
	<.main+1413 @05156c> : 58                         clt.i32
	<.main+1414 @05156d> : 06 0a 00 00                jz <.main+1424 @051577>
	<.main+1418 @051571> : 10 01                      dup.x1 sp(1)
	<.main+1420 @051573> : 04 06 00 00                jmp <.main+1426 @051579>
	<.main+1424 @051577> : 10 00                      dup.x1 sp(0)
	<.main+1426 @051579> : 13 02                      set.x1 sp(2)
	<.main+1428 @05157b> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @05157f> : 10 01                      dup.x1 sp(1)
	<.main+1434 @051581> : 10 01                      dup.x1 sp(1)
	<.main+1436 @051583> : 58                         clt.i32
	<.main+1437 @051584> : 06 0a 00 00                jz <.main+1447 @05158e>
	<.main+1441 @051588> : 10 01                      dup.x1 sp(1)
	<.main+1443 @05158a> : 04 06 00 00                jmp <.main+1449 @051590>
	<.main+1447 @05158e> : 10 00                      dup.x1 sp(0)
	<.main+1449 @051590> : 13 02                      set.x1 sp(2)
	<.main+1451 @051592> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @051596> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@05159a> - <@0515fb>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @05159a> : 10 26                      dup.x1 sp(38)
	<.main+1461 @05159c> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @0515a0> : 10 26                      dup.x1 sp(38)
	<.main+1467 @0515a2> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @0515a6> : 10 01                      dup.x1 sp(1)
	<.main+1473 @0515a8> : 10 01                      dup.x1 sp(1)
	<.main+1475 @0515aa> : 58                         clt.i32
	<.main+1476 @0515ab> : 06 0a 00 00                jz <.main+1486 @0515b5>
	<.main+1480 @0515af> : 10 01                      dup.x1 sp(1)
	<.main+1482 @0515b1> : 04 06 00 00                jmp <.main+1488 @0515b7>
	<.main+1486 @0515b5> : 10 00                      dup.x1 sp(0)
	<.main+1488 @0515b7> : 13 02                      set.x1 sp(2)
	<.main+1490 @0515b9> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @0515bd> : 10 25                      dup.x1 sp(37)
	<.main+1496 @0515bf> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @0515c3> : 10 01                      dup.x1 sp(1)
	<.main+1502 @0515c5> : 10 01                      dup.x1 sp(1)
	<.main+1504 @0515c7> : 58                         clt.i32
	<.main+1505 @0515c8> : 06 0a 00 00                jz <.main+1515 @0515d2>
	<.main+1509 @0515cc> : 10 01                      dup.x1 sp(1)
	<.main+1511 @0515ce> : 04 06 00 00                jmp <.main+1517 @0515d4>
	<.main+1515 @0515d2> : 10 00                      dup.x1 sp(0)
	<.main+1517 @0515d4> : 13 02                      set.x1 sp(2)
	<.main+1519 @0515d6> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @0515da> : 10 24                      dup.x1 sp(36)
	<.main+1525 @0515dc> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @0515e0> : 10 01                      dup.x1 sp(1)
	<.main+1531 @0515e2> : 10 01                      dup.x1 sp(1)
	<.main+1533 @0515e4> : 58                         clt.i32
	<.main+1534 @0515e5> : 06 0a 00 00                jz <.main+1544 @0515ef>
	<.main+1538 @0515e9> : 10 01                      dup.x1 sp(1)
	<.main+1540 @0515eb> : 04 06 00 00                jmp <.main+1546 @0515f1>
	<.main+1544 @0515ef> : 10 00                      dup.x1 sp(0)
	<.main+1546 @0515f1> : 13 02                      set.x1 sp(2)
	<.main+1548 @0515f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @0515f7> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@0515fb> - <@051654>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @0515fb> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @051600> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @051605> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @05160a> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @05160f> : 10 01                      dup.x1 sp(1)
	<.main+1578 @051611> : 10 01                      dup.x1 sp(1)
	<.main+1580 @051613> : 59                         cgt.i32
	<.main+1581 @051614> : 06 0a 00 00                jz <.main+1591 @05161e>
	<.main+1585 @051618> : 10 01                      dup.x1 sp(1)
	<.main+1587 @05161a> : 04 06 00 00                jmp <.main+1593 @051620>
	<.main+1591 @05161e> : 10 00                      dup.x1 sp(0)
	<.main+1593 @051620> : 13 02                      set.x1 sp(2)
	<.main+1595 @051622> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @051626> : 10 01                      dup.x1 sp(1)
	<.main+1601 @051628> : 10 01                      dup.x1 sp(1)
	<.main+1603 @05162a> : 59                         cgt.i32
	<.main+1604 @05162b> : 06 0a 00 00                jz <.main+1614 @051635>
	<.main+1608 @05162f> : 10 01                      dup.x1 sp(1)
	<.main+1610 @051631> : 04 06 00 00                jmp <.main+1616 @051637>
	<.main+1614 @051635> : 10 00                      dup.x1 sp(0)
	<.main+1616 @051637> : 13 02                      set.x1 sp(2)
	<.main+1618 @051639> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @05163d> : 10 01                      dup.x1 sp(1)
	<.main+1624 @05163f> : 10 01                      dup.x1 sp(1)
	<.main+1626 @051641> : 59                         cgt.i32
	<.main+1627 @051642> : 06 0a 00 00                jz <.main+1637 @05164c>
	<.main+1631 @051646> : 10 01                      dup.x1 sp(1)
	<.main+1633 @051648> : 04 06 00 00                jmp <.main+1639 @05164e>
	<.main+1637 @05164c> : 10 00                      dup.x1 sp(0)
	<.main+1639 @05164e> : 13 02                      set.x1 sp(2)
	<.main+1641 @051650> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@051654> - <@0516ad>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @051654> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @051659> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @05165e> : 10 01                      dup.x1 sp(1)
	<.main+1657 @051660> : 10 01                      dup.x1 sp(1)
	<.main+1659 @051662> : 59                         cgt.i32
	<.main+1660 @051663> : 06 0a 00 00                jz <.main+1670 @05166d>
	<.main+1664 @051667> : 10 01                      dup.x1 sp(1)
	<.main+1666 @051669> : 04 06 00 00                jmp <.main+1672 @05166f>
	<.main+1670 @05166d> : 10 00                      dup.x1 sp(0)
	<.main+1672 @05166f> : 13 02                      set.x1 sp(2)
	<.main+1674 @051671> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @051675> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @05167a> : 10 01                      dup.x1 sp(1)
	<.main+1685 @05167c> : 10 01                      dup.x1 sp(1)
	<.main+1687 @05167e> : 59                         cgt.i32
	<.main+1688 @05167f> : 06 0a 00 00                jz <.main+1698 @051689>
	<.main+1692 @051683> : 10 01                      dup.x1 sp(1)
	<.main+1694 @051685> : 04 06 00 00                jmp <.main+1700 @05168b>
	<.main+1698 @051689> : 10 00                      dup.x1 sp(0)
	<.main+1700 @05168b> : 13 02                      set.x1 sp(2)
	<.main+1702 @05168d> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @051691> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @051696> : 10 01                      dup.x1 sp(1)
	<.main+1713 @051698> : 10 01                      dup.x1 sp(1)
	<.main+1715 @05169a> : 59                         cgt.i32
	<.main+1716 @05169b> : 06 0a 00 00                jz <.main+1726 @0516a5>
	<.main+1720 @05169f> : 10 01                      dup.x1 sp(1)
	<.main+1722 @0516a1> : 04 06 00 00                jmp <.main+1728 @0516a7>
	<.main+1726 @0516a5> : 10 00                      dup.x1 sp(0)
	<.main+1728 @0516a7> : 13 02                      set.x1 sp(2)
	<.main+1730 @0516a9> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@0516ad> - <@0516fa>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @0516ad> : 10 29                      dup.x1 sp(41)
	<.main+1736 @0516af> : 10 29                      dup.x1 sp(41)
	<.main+1738 @0516b1> : 10 29                      dup.x1 sp(41)
	<.main+1740 @0516b3> : 10 29                      dup.x1 sp(41)
	<.main+1742 @0516b5> : 10 01                      dup.x1 sp(1)
	<.main+1744 @0516b7> : 10 01                      dup.x1 sp(1)
	<.main+1746 @0516b9> : 59                         cgt.i32
	<.main+1747 @0516ba> : 06 0a 00 00                jz <.main+1757 @0516c4>
	<.main+1751 @0516be> : 10 01                      dup.x1 sp(1)
	<.main+1753 @0516c0> : 04 06 00 00                jmp <.main+1759 @0516c6>
	<.main+1757 @0516c4> : 10 00                      dup.x1 sp(0)
	<.main+1759 @0516c6> : 13 02                      set.x1 sp(2)
	<.main+1761 @0516c8> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @0516cc> : 10 01                      dup.x1 sp(1)
	<.main+1767 @0516ce> : 10 01                      dup.x1 sp(1)
	<.main+1769 @0516d0> : 59                         cgt.i32
	<.main+1770 @0516d1> : 06 0a 00 00                jz <.main+1780 @0516db>
	<.main+1774 @0516d5> : 10 01                      dup.x1 sp(1)
	<.main+1776 @0516d7> : 04 06 00 00                jmp <.main+1782 @0516dd>
	<.main+1780 @0516db> : 10 00                      dup.x1 sp(0)
	<.main+1782 @0516dd> : 13 02                      set.x1 sp(2)
	<.main+1784 @0516df> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @0516e3> : 10 01                      dup.x1 sp(1)
	<.main+1790 @0516e5> : 10 01                      dup.x1 sp(1)
	<.main+1792 @0516e7> : 59                         cgt.i32
	<.main+1793 @0516e8> : 06 0a 00 00                jz <.main+1803 @0516f2>
	<.main+1797 @0516ec> : 10 01                      dup.x1 sp(1)
	<.main+1799 @0516ee> : 04 06 00 00                jmp <.main+1805 @0516f4>
	<.main+1803 @0516f2> : 10 00                      dup.x1 sp(0)
	<.main+1805 @0516f4> : 13 02                      set.x1 sp(2)
	<.main+1807 @0516f6> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@0516fa> - <@051747>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @0516fa> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @0516fc> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @0516fe> : 10 01                      dup.x1 sp(1)
	<.main+1817 @051700> : 10 01                      dup.x1 sp(1)
	<.main+1819 @051702> : 59                         cgt.i32
	<.main+1820 @051703> : 06 0a 00 00                jz <.main+1830 @05170d>
	<.main+1824 @051707> : 10 01                      dup.x1 sp(1)
	<.main+1826 @051709> : 04 06 00 00                jmp <.main+1832 @05170f>
	<.main+1830 @05170d> : 10 00                      dup.x1 sp(0)
	<.main+1832 @05170f> : 13 02                      set.x1 sp(2)
	<.main+1834 @051711> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @051715> : 10 29                      dup.x1 sp(41)
	<.main+1840 @051717> : 10 01                      dup.x1 sp(1)
	<.main+1842 @051719> : 10 01                      dup.x1 sp(1)
	<.main+1844 @05171b> : 59                         cgt.i32
	<.main+1845 @05171c> : 06 0a 00 00                jz <.main+1855 @051726>
	<.main+1849 @051720> : 10 01                      dup.x1 sp(1)
	<.main+1851 @051722> : 04 06 00 00                jmp <.main+1857 @051728>
	<.main+1855 @051726> : 10 00                      dup.x1 sp(0)
	<.main+1857 @051728> : 13 02                      set.x1 sp(2)
	<.main+1859 @05172a> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @05172e> : 10 28                      dup.x1 sp(40)
	<.main+1865 @051730> : 10 01                      dup.x1 sp(1)
	<.main+1867 @051732> : 10 01                      dup.x1 sp(1)
	<.main+1869 @051734> : 59                         cgt.i32
	<.main+1870 @051735> : 06 0a 00 00                jz <.main+1880 @05173f>
	<.main+1874 @051739> : 10 01                      dup.x1 sp(1)
	<.main+1876 @05173b> : 04 06 00 00                jmp <.main+1882 @051741>
	<.main+1880 @05173f> : 10 00                      dup.x1 sp(0)
	<.main+1882 @051741> : 13 02                      set.x1 sp(2)
	<.main+1884 @051743> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@051747> - <@0517a8>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @051747> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @051749> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @05174d> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @05174f> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @051753> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @051755> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @051759> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @05175b> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @05175f> : 10 01                      dup.x1 sp(1)
	<.main+1914 @051761> : 10 01                      dup.x1 sp(1)
	<.main+1916 @051763> : 59                         cgt.i32
	<.main+1917 @051764> : 06 0a 00 00                jz <.main+1927 @05176e>
	<.main+1921 @051768> : 10 01                      dup.x1 sp(1)
	<.main+1923 @05176a> : 04 06 00 00                jmp <.main+1929 @051770>
	<.main+1927 @05176e> : 10 00                      dup.x1 sp(0)
	<.main+1929 @051770> : 13 02                      set.x1 sp(2)
	<.main+1931 @051772> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @051776> : 10 01                      dup.x1 sp(1)
	<.main+1937 @051778> : 10 01                      dup.x1 sp(1)
	<.main+1939 @05177a> : 59                         cgt.i32
	<.main+1940 @05177b> : 06 0a 00 00                jz <.main+1950 @051785>
	<.main+1944 @05177f> : 10 01                      dup.x1 sp(1)
	<.main+1946 @051781> : 04 06 00 00                jmp <.main+1952 @051787>
	<.main+1950 @051785> : 10 00                      dup.x1 sp(0)
	<.main+1952 @051787> : 13 02                      set.x1 sp(2)
	<.main+1954 @051789> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @05178d> : 10 01                      dup.x1 sp(1)
	<.main+1960 @05178f> : 10 01                      dup.x1 sp(1)
	<.main+1962 @051791> : 59                         cgt.i32
	<.main+1963 @051792> : 06 0a 00 00                jz <.main+1973 @05179c>
	<.main+1967 @051796> : 10 01                      dup.x1 sp(1)
	<.main+1969 @051798> : 04 06 00 00                jmp <.main+1975 @05179e>
	<.main+1973 @05179c> : 10 00                      dup.x1 sp(0)
	<.main+1975 @05179e> : 13 02                      set.x1 sp(2)
	<.main+1977 @0517a0> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @0517a4> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@0517a8> - <@051809>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @0517a8> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @0517aa> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @0517ae> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @0517b0> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @0517b4> : 10 01                      dup.x1 sp(1)
	<.main+1999 @0517b6> : 10 01                      dup.x1 sp(1)
	<.main+2001 @0517b8> : 59                         cgt.i32
	<.main+2002 @0517b9> : 06 0a 00 00                jz <.main+2012 @0517c3>
	<.main+2006 @0517bd> : 10 01                      dup.x1 sp(1)
	<.main+2008 @0517bf> : 04 06 00 00                jmp <.main+2014 @0517c5>
	<.main+2012 @0517c3> : 10 00                      dup.x1 sp(0)
	<.main+2014 @0517c5> : 13 02                      set.x1 sp(2)
	<.main+2016 @0517c7> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @0517cb> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @0517cd> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @0517d1> : 10 01                      dup.x1 sp(1)
	<.main+2028 @0517d3> : 10 01                      dup.x1 sp(1)
	<.main+2030 @0517d5> : 59                         cgt.i32
	<.main+2031 @0517d6> : 06 0a 00 00                jz <.main+2041 @0517e0>
	<.main+2035 @0517da> : 10 01                      dup.x1 sp(1)
	<.main+2037 @0517dc> : 04 06 00 00                jmp <.main+2043 @0517e2>
	<.main+2041 @0517e0> : 10 00                      dup.x1 sp(0)
	<.main+2043 @0517e2> : 13 02                      set.x1 sp(2)
	<.main+2045 @0517e4> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @0517e8> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @0517ea> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @0517ee> : 10 01                      dup.x1 sp(1)
	<.main+2057 @0517f0> : 10 01                      dup.x1 sp(1)
	<.main+2059 @0517f2> : 59                         cgt.i32
	<.main+2060 @0517f3> : 06 0a 00 00                jz <.main+2070 @0517fd>
	<.main+2064 @0517f7> : 10 01                      dup.x1 sp(1)
	<.main+2066 @0517f9> : 04 06 00 00                jmp <.main+2072 @0517ff>
	<.main+2070 @0517fd> : 10 00                      dup.x1 sp(0)
	<.main+2072 @0517ff> : 13 02                      set.x1 sp(2)
	<.main+2074 @051801> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @051805> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@051809> - <@05180e>): overload1: float32 := overload
	<.main+2082 @051809> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@05180e> - <@051813>): overload2: float32 := overload()
	<.main+2087 @05180e> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@051813> - <@051818>): overload3: float32 := overload(0)
	<.main+2092 @051813> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@051818> - <@05181d>): overload4: float32 := overload(0.000000)
	<.main+2097 @051818> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@05181d> - <@051822>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @05181d> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@051822> - <@05182b>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @051822> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@05182b> - <@051841>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @05182b> : 11 00                      dup.x2 sp(0)
	<.main+2118 @05182d> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @051836> : 83                         mul.f64
	<.main+2128 @051837> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @051840> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@051841> - <@051846>): valueRef: int64 := value
	<.main+2138 @051841> : 1f 68 0d 05 00             load.ref <@050d68> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@051846> - <@05184b>): valuePtr: pointer := value
	<.main+2143 @051846> : 1f 68 0d 05 00             load.ref <@050d68> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@05184b> - <@051855>): valueVar: variant := value
	<.main+2148 @05184b> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2153 @051850> : 1f 68 0d 05 00             load.ref <@050d68> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@051855> - <@051858>): fromRef: int64 := valueRef
	<.main+2158 @051855> : 10 03                      dup.x1 sp(3)
	<.main+2160 @051857> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@051858> - <@05185a>): fromPtr: int64 := valuePtr
	<.main+2161 @051858> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@05185a> - <@05185c>): fromVar: int64 := valueVar
	<.main+2163 @05185a> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@05185c> - <@051861>): nullRef: int64 := null
	<.main+2165 @05185c> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@051861> - <@051866>): nullPtr: pointer := null
	<.main+2170 @051861> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@051866> - <@051870>): nullVar: variant := null
	<.main+2175 @051866> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2180 @05186b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@051870> - <@051875>): nullTyp: typename := null
	<.main+2185 @051870> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@051875> - <@05187a>): nullFun: function := null
	<.main+2190 @051875> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@05187a> - <@05187f>): nullObj: object := null
	<.main+2195 @05187a> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@05187f> - <@051884>): typePtr: pointer := int64
	<.main+2200 @05187f> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@051884> - <@05188e>): typeVar: variant := int64
	<.main+2205 @051884> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @051889> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@05188e> - <@051893>): typeTyp: typename := int64
	<.main+2215 @05188e> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@051893> - <@051897>): local: int64 := value
	<.main+2220 @051893> : 2b 68 0d 05                load.m64 <@050d68> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@051897> - <@051899>): copyVal: int64 := local
	<.main+2224 @051897> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@051899> - <@05189b>): copyRef: int64 := valueRef
	<.main+2226 @051899> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@05189b> - <@05189d>): copyPtr: pointer := valuePtr
	<.main+2228 @05189b> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@05189d> - <@05189f>): copyVar: variant := valueVar
	<.main+2230 @05189d> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@05189f> - <@0518a1>): copyTyp: typename := typeTyp
	<.main+2232 @05189f> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@0518a1> - <@0518a6>): ptrVoid: pointer := void
	<.main+2234 @0518a1> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@0518a6> - <@0518ab>): ptrBool: pointer := bool
	<.main+2239 @0518a6> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@0518ab> - <@0518b0>): ptrChar: pointer := char
	<.main+2244 @0518ab> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@0518b0> - <@0518b5>): ptrInt8: pointer := int8
	<.main+2249 @0518b0> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@0518b5> - <@0518ba>): ptrInt16: pointer := int16
	<.main+2254 @0518b5> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@0518ba> - <@0518bf>): ptrInt32: pointer := int32
	<.main+2259 @0518ba> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@0518bf> - <@0518c4>): ptrInt64: pointer := int64
	<.main+2264 @0518bf> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@0518c4> - <@0518c9>): ptrUint8: pointer := uint8
	<.main+2269 @0518c4> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@0518c9> - <@0518ce>): ptrUint16: pointer := uint16
	<.main+2274 @0518c9> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@0518ce> - <@0518d3>): ptrUint32: pointer := uint32
	<.main+2279 @0518ce> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@0518d3> - <@0518d8>): ptrUint64: pointer := uint64
	<.main+2284 @0518d3> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@0518d8> - <@0518dd>): ptrFloat32: pointer := float32
	<.main+2289 @0518d8> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@0518dd> - <@0518e2>): ptrFloat64: pointer := float64
	<.main+2294 @0518dd> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@0518e2> - <@0518e7>): ptrTypename: pointer := typename
	<.main+2299 @0518e2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@0518e7> - <@0518ec>): ptrFunction: pointer := function
	<.main+2304 @0518e7> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@0518ec> - <@0518f1>): ptrPointer: pointer := pointer
	<.main+2309 @0518ec> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@0518f1> - <@0518f6>): ptrVariant: pointer := variant
	<.main+2314 @0518f1> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@0518f6> - <@0518fb>): ptrObject: pointer := object
	<.main+2319 @0518f6> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@0518fb> - <@051905>): varVoid: variant := void
	<.main+2324 @0518fb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @051900> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@051905> - <@05190f>): varBool: variant := bool
	<.main+2334 @051905> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @05190a> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@05190f> - <@051919>): varChar: variant := char
	<.main+2344 @05190f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @051914> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@051919> - <@051923>): varInt8: variant := int8
	<.main+2354 @051919> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @05191e> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@051923> - <@05192d>): varInt16: variant := int16
	<.main+2364 @051923> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @051928> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@05192d> - <@051937>): varInt32: variant := int32
	<.main+2374 @05192d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @051932> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@051937> - <@051941>): varInt64: variant := int64
	<.main+2384 @051937> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @05193c> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@051941> - <@05194b>): varUint8: variant := uint8
	<.main+2394 @051941> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @051946> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@05194b> - <@051955>): varUint16: variant := uint16
	<.main+2404 @05194b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @051950> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@051955> - <@05195f>): varUint32: variant := uint32
	<.main+2414 @051955> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @05195a> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@05195f> - <@051969>): varUint64: variant := uint64
	<.main+2424 @05195f> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @051964> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@051969> - <@051973>): varFloat32: variant := float32
	<.main+2434 @051969> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @05196e> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@051973> - <@05197d>): varFloat64: variant := float64
	<.main+2444 @051973> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @051978> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@05197d> - <@051987>): varTypename: variant := typename
	<.main+2454 @05197d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @051982> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@051987> - <@051991>): varFunction: variant := function
	<.main+2464 @051987> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @05198c> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@051991> - <@05199b>): varPointer: variant := pointer
	<.main+2474 @051991> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @051996> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@05199b> - <@0519a5>): varVariant: variant := variant
	<.main+2484 @05199b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @0519a0> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@0519a5> - <@0519af>): varObject: variant := object
	<.main+2494 @0519a5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @0519aa> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@0519af> - <@0519b4>): typVoid: typename := void
	<.main+2504 @0519af> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@0519b4> - <@0519b9>): typBool: typename := bool
	<.main+2509 @0519b4> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@0519b9> - <@0519be>): typChar: typename := char
	<.main+2514 @0519b9> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@0519be> - <@0519c3>): typInt8: typename := int8
	<.main+2519 @0519be> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@0519c3> - <@0519c8>): typInt16: typename := int16
	<.main+2524 @0519c3> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@0519c8> - <@0519cd>): typInt32: typename := int32
	<.main+2529 @0519c8> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@0519cd> - <@0519d2>): typInt64: typename := int64
	<.main+2534 @0519cd> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@0519d2> - <@0519d7>): typUint8: typename := uint8
	<.main+2539 @0519d2> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@0519d7> - <@0519dc>): typUint16: typename := uint16
	<.main+2544 @0519d7> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@0519dc> - <@0519e1>): typUint32: typename := uint32
	<.main+2549 @0519dc> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@0519e1> - <@0519e6>): typUint64: typename := uint64
	<.main+2554 @0519e1> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@0519e6> - <@0519eb>): typFloat32: typename := float32
	<.main+2559 @0519e6> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@0519eb> - <@0519f0>): typFloat64: typename := float64
	<.main+2564 @0519eb> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@0519f0> - <@0519f5>): typTypename: typename := typename
	<.main+2569 @0519f0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@0519f5> - <@0519fa>): typFunction: typename := function
	<.main+2574 @0519f5> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@0519fa> - <@0519ff>): typPointer: typename := pointer
	<.main+2579 @0519fa> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@0519ff> - <@051a04>): typVariant: typename := variant
	<.main+2584 @0519ff> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@051a04> - <@051a09>): typObject: typename := object
	<.main+2589 @051a04> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@051a09> - <@051a0e>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @051a09> : 1f 68 0d 05 00             load.ref <@050d68> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@051a0e> - <@051a18>): valueOfVar: variant := variant(value)
	<.main+2599 @051a0e> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2604 @051a13> : 1f 68 0d 05 00             load.ref <@050d68> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@051a18> - <@051a1d>): valueOfTyp: typename := typename(value)
	<.main+2609 @051a18> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@051a1d> - <@051a22>): typeOfValue: typename := typename(value)
	<.main+2614 @051a1d> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@051a22> - <@051a29>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @051a22> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2624 @051a27> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@051a29> - <@051a2b>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @051a29> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@051a2b> - <@051a40>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @051a2b> : 19                         load.z32
	<.main+2629 @051a2c> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @051a31> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @051a36> : 1f 78 0d 05 00             load.ref <@050d78> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @051a3b> : 02                         call
	<.main+2645 @051a3c> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@051a40> - <@051a45>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @051a40> : 1f 78 0d 05 00             load.ref <@050d78> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@051a45> - <@051a57>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @051a45> : 19                         load.z32
	<.main+2655 @051a46> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @051a4b> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @051a50> : 10 03                      dup.x1 sp(3)
	<.main+2667 @051a52> : 02                         call
	<.main+2668 @051a53> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@051a57> - <@051a5c>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @051a57> : 1f 80 0d 05 00             load.ref <@050d80> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@051a5c> - <@051a6e>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @051a5c> : 19                         load.z32
	<.main+2678 @051a5d> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @051a62> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @051a67> : 10 03                      dup.x1 sp(3)
	<.main+2690 @051a69> : 02                         call
	<.main+2691 @051a6a> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@051a6e> - <@051a70>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @051a6e> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@051a70> - <@051a82>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @051a70> : 19                         load.z32
	<.main+2698 @051a71> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @051a76> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @051a7b> : 10 03                      dup.x1 sp(3)
	<.main+2710 @051a7d> : 02                         call
	<.main+2711 @051a7e> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@051a82> - <@051a92>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @051a82> : 19                         load.z32
	<.main+2716 @051a83> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @051a88> : 1f 88 0d 05 00             load.ref <@050d88> ;fib(n: uint32): uint32
	<.main+2726 @051a8d> : 02                         call
	<.main+2727 @051a8e> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@051a92> - <@051a96>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @051a92> : 2a d0 00 00                load.m32 <@0000d0>
	test/lang/reflect.ci:4: (4 bytes: <@051a96> - <@051a9a>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @051a96> : 2a 70 01 00                load.m32 <@000170>
	test/lang/reflect.ci:5: (4 bytes: <@051a9a> - <@051a9e>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @051a9a> : 2a 10 02 00                load.m32 <@000210>
	test/lang/reflect.ci:6: (4 bytes: <@051a9e> - <@051aa2>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @051a9e> : 2a b0 02 00                load.m32 <@0002b0>
	test/lang/reflect.ci:7: (4 bytes: <@051aa2> - <@051aa6>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @051aa2> : 2a 50 03 00                load.m32 <@000350>
	test/lang/reflect.ci:8: (4 bytes: <@051aa6> - <@051aaa>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @051aa6> : 2a f0 03 00                load.m32 <@0003f0>
	test/lang/reflect.ci:9: (4 bytes: <@051aaa> - <@051aae>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @051aaa> : 2a 90 04 00                load.m32 <@000490>
	test/lang/reflect.ci:10: (4 bytes: <@051aae> - <@051ab2>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @051aae> : 2a 30 05 00                load.m32 <@000530>
	test/lang/reflect.ci:11: (4 bytes: <@051ab2> - <@051ab6>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @051ab2> : 2a d0 05 00                load.m32 <@0005d0>
	test/lang/reflect.ci:12: (4 bytes: <@051ab6> - <@051aba>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @051ab6> : 2a 70 06 00                load.m32 <@000670>
	test/lang/reflect.ci:13: (4 bytes: <@051aba> - <@051abe>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @051aba> : 2a 10 07 00                load.m32 <@000710>
	test/lang/reflect.ci:14: (4 bytes: <@051abe> - <@051ac2>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @051abe> : 2a b0 07 00                load.m32 <@0007b0>
	test/lang/reflect.ci:15: (4 bytes: <@051ac2> - <@051ac6>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @051ac2> : 2a 50 08 00                load.m32 <@000850>
	test/lang/reflect.ci:16: (4 bytes: <@051ac6> - <@051aca>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @051ac6> : 2a f0 08 00                load.m32 <@0008f0>
	test/lang/reflect.ci:17: (4 bytes: <@051aca> - <@051ace>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @051aca> : 2a 90 09 00                load.m32 <@000990>
	test/lang/reflect.ci:18: (4 bytes: <@051ace> - <@051ad2>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @051ace> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	test/lang/reflect.ci:19: (4 bytes: <@051ad2> - <@051ad6>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @051ad2> : 2a 30 0a 00                load.m32 <@000a30>
	test/lang/reflect.ci:20: (4 bytes: <@051ad6> - <@051ada>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @051ad6> : 2a d8 0a 00                load.m32 <@000ad8>
	test/lang/reflect.ci:30: (5 bytes: <@051ada> - <@051adf>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @051ada> : 1f 40 6f 03 00             load.ref <@036f40> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@051adf> - <@051ae5>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @051adf> : 10 00                      dup.x1 sp(0)
	<.main+2810 @051ae1> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@051ae5> - <@051aec>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @051ae5> : 10 01                      dup.x1 sp(1)
	<.main+2816 @051ae7> : 0c 28 00 00                inc.i32(+40)
	<.main+2820 @051aeb> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@051aec> - <@051af3>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @051aec> : 10 02                      dup.x1 sp(2)
	<.main+2823 @051aee> : 0c 20 00 00                inc.i32(+32)
	<.main+2827 @051af2> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@051af3> - <@051af9>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @051af3> : 10 03                      dup.x1 sp(3)
	<.main+2830 @051af5> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@051af9> - <@051aff>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @051af9> : 10 04                      dup.x1 sp(4)
	<.main+2836 @051afb> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@051aff> - <@051b05>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @051aff> : 10 05                      dup.x1 sp(5)
	<.main+2842 @051b01> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@051b05> - <@051b0b>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @051b05> : 10 00                      dup.x1 sp(0)
	<.main+2848 @051b07> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@051b0b> - <@051b12>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @051b0b> : 10 01                      dup.x1 sp(1)
	<.main+2854 @051b0d> : 0c 28 00 00                inc.i32(+40)
	<.main+2858 @051b11> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@051b12> - <@051b19>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @051b12> : 10 02                      dup.x1 sp(2)
	<.main+2861 @051b14> : 0c 20 00 00                inc.i32(+32)
	<.main+2865 @051b18> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@051b19> - <@051b1f>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @051b19> : 10 03                      dup.x1 sp(3)
	<.main+2868 @051b1b> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@051b1f> - <@051b25>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @051b1f> : 10 04                      dup.x1 sp(4)
	<.main+2874 @051b21> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@051b25> - <@051b2b>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @051b25> : 10 05                      dup.x1 sp(5)
	<.main+2880 @051b27> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@051b2b> - <@051b32>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @051b2b> : 10 00                      dup.x1 sp(0)
	<.main+2886 @051b2d> : 0c 28 00 00                inc.i32(+40)
	<.main+2890 @051b31> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@051b32> - <@051b39>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @051b32> : 10 01                      dup.x1 sp(1)
	<.main+2893 @051b34> : 0c 20 00 00                inc.i32(+32)
	<.main+2897 @051b38> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@051b39> - <@051b3f>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @051b39> : 10 02                      dup.x1 sp(2)
	<.main+2900 @051b3b> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@051b3f> - <@051b46>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @051b3f> : 10 00                      dup.x1 sp(0)
	<.main+2906 @051b41> : 0c 28 00 00                inc.i32(+40)
	<.main+2910 @051b45> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@051b46> - <@051b4d>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @051b46> : 10 01                      dup.x1 sp(1)
	<.main+2913 @051b48> : 0c 20 00 00                inc.i32(+32)
	<.main+2917 @051b4c> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@051b4d> - <@051b56>): pi64: float64 := 3.141593
	<.main+2918 @051b4d> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@051b56> - <@051b5f>): e64: float64 := 2.718282
	<.main+2927 @051b56> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@051b5f> - <@051b62>): pi32: float32 := pi64
	<.main+2936 @051b5f> : 11 02                      dup.x2 sp(2)
	<.main+2938 @051b61> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@051b62> - <@051b65>): e32: float32 := e64
	<.main+2939 @051b62> : 11 01                      dup.x2 sp(1)
	<.main+2941 @051b64> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@051b65> - <@051b6c>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @051b65> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @051b6a> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@051b6c> - <@051b73>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @051b6c> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @051b71> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@051b73> - <@051b7a>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @051b73> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @051b78> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@051b7a> - <@051b96>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @051b7a> : 10 02                      dup.x1 sp(2)
	<.main+2965 @051b7c> : 3f 48                      b32.shl 0x008
	<.main+2967 @051b7e> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @051b83> : 31                         and.b32
	<.main+2973 @051b84> : 10 02                      dup.x1 sp(2)
	<.main+2975 @051b86> : 3f 43                      b32.shl 0x003
	<.main+2977 @051b88> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @051b8d> : 31                         and.b32
	<.main+2983 @051b8e> : 32                         or.b32
	<.main+2984 @051b8f> : 10 01                      dup.x1 sp(1)
	<.main+2986 @051b91> : 3f c3                      b32.sar 0x003
	<.main+2988 @051b93> : 3f 05                      b32.and 0x01f
	<.main+2990 @051b95> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@051b96> - <@051bb0>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @051b96> : 10 03                      dup.x1 sp(3)
	<.main+2993 @051b98> : 3f 50                      b32.shl 0x010
	<.main+2995 @051b9a> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @051b9f> : 31                         and.b32
	<.main+3001 @051ba0> : 10 03                      dup.x1 sp(3)
	<.main+3003 @051ba2> : 3f 48                      b32.shl 0x008
	<.main+3005 @051ba4> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @051ba9> : 31                         and.b32
	<.main+3011 @051baa> : 32                         or.b32
	<.main+3012 @051bab> : 10 02                      dup.x1 sp(2)
	<.main+3014 @051bad> : 3f 08                      b32.and 0x0ff
	<.main+3016 @051baf> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@051bb0> - <@051bc0>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @051bb0> : 10 01                      dup.x1 sp(1)
	<.main+3019 @051bb2> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @051bb7> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @051bbc> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@051bc0> - <@051bd0>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @051bc0> : 10 02                      dup.x1 sp(2)
	<.main+3035 @051bc2> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @051bc7> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @051bcc> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@051bd0> - <@051bdc>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @051bd0> : 10 03                      dup.x1 sp(3)
	<.main+3051 @051bd2> : 19                         load.z32
	<.main+3052 @051bd3> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @051bd8> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@051bdc> - <@051bec>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @051bdc> : 10 04                      dup.x1 sp(4)
	<.main+3063 @051bde> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @051be3> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @051be8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@051bec> - <@051bfc>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @051bec> : 10 05                      dup.x1 sp(5)
	<.main+3079 @051bee> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @051bf3> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @051bf8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@051bfc> - <@051c08>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @051bfc> : 10 06                      dup.x1 sp(6)
	<.main+3095 @051bfe> : 19                         load.z32
	<.main+3096 @051bff> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @051c04> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@051c08> - <@051c18>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @051c08> : 10 06                      dup.x1 sp(6)
	<.main+3107 @051c0a> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @051c0f> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @051c14> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@051c18> - <@051c28>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @051c18> : 10 07                      dup.x1 sp(7)
	<.main+3123 @051c1a> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @051c1f> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @051c24> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@051c28> - <@051c34>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @051c28> : 10 08                      dup.x1 sp(8)
	<.main+3139 @051c2a> : 19                         load.z32
	<.main+3140 @051c2b> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @051c30> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@051c34> - <@051c44>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @051c34> : 10 09                      dup.x1 sp(9)
	<.main+3151 @051c36> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @051c3b> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @051c40> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@051c44> - <@051c54>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @051c44> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @051c46> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @051c4b> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @051c50> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@051c54> - <@051c60>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @051c54> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @051c56> : 19                         load.z32
	<.main+3184 @051c57> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @051c5c> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@051c60> - <@051c70>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @051c60> : 11 15                      dup.x2 sp(21)
	<.main+3195 @051c62> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @051c6b> : 84                         div.f64
	<.main+3205 @051c6c> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@051c70> - <@051c80>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @051c70> : 11 17                      dup.x2 sp(23)
	<.main+3211 @051c72> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @051c7b> : 84                         div.f64
	<.main+3221 @051c7c> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@051c80> - <@051c90>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @051c80> : 11 19                      dup.x2 sp(25)
	<.main+3227 @051c82> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @051c8b> : 84                         div.f64
	<.main+3237 @051c8c> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@051c90> - <@051c9c>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @051c90> : 11 19                      dup.x2 sp(25)
	<.main+3243 @051c92> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @051c94> : 83                         mul.f64
	<.main+3246 @051c95> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @051c97> : 83                         mul.f64
	<.main+3249 @051c98> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@051c9c> - <@051ca9>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @051c9c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @051ca5> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@051ca9> - <@051cbb>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @051ca9> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @051cab> : 11 21                      dup.x2 sp(33)
	<.main+3270 @051cad> : 83                         mul.f64
	<.main+3271 @051cae> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @051cb7> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@051cbb> - <@051cc4>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @051cbb> : 11 21                      dup.x2 sp(33)
	<.main+3286 @051cbd> : 11 23                      dup.x2 sp(35)
	<.main+3288 @051cbf> : 83                         mul.f64
	<.main+3289 @051cc0> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@051cc4> - <@051cd3>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @051cc4> : 11 23                      dup.x2 sp(35)
	<.main+3295 @051cc6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @051ccf> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@051cd3> - <@051cdf>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @051cd3> : 10 22                      dup.x1 sp(34)
	<.main+3310 @051cd5> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @051cda> : 74                         div.f32
	<.main+3316 @051cdb> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@051cdf> - <@051ceb>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @051cdf> : 10 23                      dup.x1 sp(35)
	<.main+3322 @051ce1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @051ce6> : 74                         div.f32
	<.main+3328 @051ce7> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@051ceb> - <@051cf7>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @051ceb> : 10 24                      dup.x1 sp(36)
	<.main+3334 @051ced> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @051cf2> : 74                         div.f32
	<.main+3340 @051cf3> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@051cf7> - <@051d03>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @051cf7> : 10 24                      dup.x1 sp(36)
	<.main+3346 @051cf9> : 10 25                      dup.x1 sp(37)
	<.main+3348 @051cfb> : 73                         mul.f32
	<.main+3349 @051cfc> : 10 25                      dup.x1 sp(37)
	<.main+3351 @051cfe> : 73                         mul.f32
	<.main+3352 @051cff> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@051d03> - <@051d0c>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @051d03> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @051d08> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@051d0c> - <@051d1a>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @051d0c> : 10 27                      dup.x1 sp(39)
	<.main+3367 @051d0e> : 10 28                      dup.x1 sp(40)
	<.main+3369 @051d10> : 73                         mul.f32
	<.main+3370 @051d11> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @051d16> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@051d1a> - <@051d23>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @051d1a> : 10 28                      dup.x1 sp(40)
	<.main+3381 @051d1c> : 10 29                      dup.x1 sp(41)
	<.main+3383 @051d1e> : 73                         mul.f32
	<.main+3384 @051d1f> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@051d23> - <@051d2e>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @051d23> : 10 29                      dup.x1 sp(41)
	<.main+3390 @051d25> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @051d2a> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@051d2e> - <@051d34>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @051d2e> : 10 25                      dup.x1 sp(37)
	<.main+3401 @051d30> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@051d34> - <@051d3a>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @051d34> : 10 26                      dup.x1 sp(38)
	<.main+3407 @051d36> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@051d3a> - <@051d40>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @051d3a> : 10 27                      dup.x1 sp(39)
	<.main+3413 @051d3c> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@051d40> - <@051d46>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @051d40> : 10 28                      dup.x1 sp(40)
	<.main+3419 @051d42> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@051d46> - <@051d4c>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @051d46> : 10 29                      dup.x1 sp(41)
	<.main+3425 @051d48> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@051d4c> - <@051d52>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @051d4c> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @051d4e> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@051d52> - <@051d5e>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @051d52> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @051d54> : 19                         load.z32
	<.main+3438 @051d55> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @051d5a> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@051d5e> - <@051d6a>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @051d5e> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @051d60> : 19                         load.z32
	<.main+3450 @051d61> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @051d66> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@051d6a> - <@051d78>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @051d6a> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @051d6c> : 5c                         i32.2i64
	<.main+3462 @051d6d> : 19                         load.z32
	<.main+3463 @051d6e> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @051d73> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @051d77> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@051d78> - <@051d86>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @051d78> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @051d7a> : 5c                         i32.2i64
	<.main+3476 @051d7b> : 19                         load.z32
	<.main+3477 @051d7c> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @051d81> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @051d85> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@051d86> - <@051d94>): p1: pointer := malloc(1024)
	<.main+3487 @051d86> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @051d8b> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @051d90> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@051d94> - <@051da2>): p2: pointer := malloc(80)
	<.main+3501 @051d94> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @051d99> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @051d9e> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@051da2> - <@051db0>): p3: pointer := malloc(160)
	<.main+3515 @051da2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @051da7> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @051dac> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@051db0> - <@051dbe>): p4: pointer := malloc(820)
	<.main+3529 @051db0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @051db5> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @051dba> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@051dbe> - <@051dce>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @051dbe> : 10 03                      dup.x1 sp(3)
	<.main+3545 @051dc0> : 19                         load.z32
	<.main+3546 @051dc1> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @051dc6> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @051dca> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@051dce> - <@051ddf>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @051dce> : 10 03                      dup.x1 sp(3)
	<.main+3561 @051dd0> : 10 02                      dup.x1 sp(2)
	<.main+3563 @051dd2> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @051dd7> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @051ddb> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@051ddf> - <@051dea>): free(p1);
	<.main+3576 @051ddf> : 10 03                      dup.x1 sp(3)
	<.main+3578 @051de1> : 19                         load.z32
	<.main+3579 @051de2> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @051de6> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@051dea> - <@051df5>): free(p2);
	<.main+3587 @051dea> : 10 02                      dup.x1 sp(2)
	<.main+3589 @051dec> : 19                         load.z32
	<.main+3590 @051ded> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @051df1> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@051df5> - <@051e00>): free(p3);
	<.main+3598 @051df5> : 10 01                      dup.x1 sp(1)
	<.main+3600 @051df7> : 19                         load.z32
	<.main+3601 @051df8> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @051dfc> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@051e00> - <@051e0b>): free(p4);
	<.main+3609 @051e00> : 10 00                      dup.x1 sp(0)
	<.main+3611 @051e02> : 19                         load.z32
	<.main+3612 @051e03> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @051e07> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@051e0b> - <@051e14>): val1: int64 := 42
	<.main+3620 @051e0b> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@051e14> - <@051e1d>): val2: int64 := 96
	<.main+3629 @051e14> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@051e1d> - <@051e3f>): debug(void("val1", val1));
	<.main+3638 @051e1d> : 1f f8 a1 03 00             load.ref <@03a1f8> ;"test/stdc/memory.ci"
	<.main+3643 @051e22> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @051e27> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @051e2c> : 19                         load.z32
	<.main+3654 @051e2d> : 1f 20 a2 03 00             load.ref <@03a220> ;"val1"
	<.main+3659 @051e32> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3664 @051e37> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @051e3b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@051e3f> - <@051e61>): debug(void("val2", val2));
	<.main+3672 @051e3f> : 1f f8 a1 03 00             load.ref <@03a1f8> ;"test/stdc/memory.ci"
	<.main+3677 @051e44> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @051e49> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @051e4e> : 19                         load.z32
	<.main+3688 @051e4f> : 1f 25 a2 03 00             load.ref <@03a225> ;"val2"
	<.main+3693 @051e54> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3698 @051e59> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @051e5d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@051e61> - <@051e75>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @051e61> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @051e65> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @051e69> : 2a 90 04 00                load.m32 <@000490>
	<.main+3718 @051e6d> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @051e71> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@051e75> - <@051e86>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @051e75> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @051e79> : 19                         load.z32
	<.main+3731 @051e7a> : 2a 90 04 00                load.m32 <@000490>
	<.main+3735 @051e7e> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @051e82> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@051e86> - <@051ea8>): debug(void("val1", val1));
	<.main+3743 @051e86> : 1f f8 a1 03 00             load.ref <@03a1f8> ;"test/stdc/memory.ci"
	<.main+3748 @051e8b> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @051e90> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @051e95> : 19                         load.z32
	<.main+3759 @051e96> : 1f 20 a2 03 00             load.ref <@03a220> ;"val1"
	<.main+3764 @051e9b> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3769 @051ea0> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @051ea4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@051ea8> - <@051eca>): debug(void("val2", val2));
	<.main+3777 @051ea8> : 1f f8 a1 03 00             load.ref <@03a1f8> ;"test/stdc/memory.ci"
	<.main+3782 @051ead> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @051eb2> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @051eb7> : 19                         load.z32
	<.main+3793 @051eb8> : 1f 25 a2 03 00             load.ref <@03a225> ;"val2"
	<.main+3798 @051ebd> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3803 @051ec2> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @051ec6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@051eca> - <@051ed8>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @051eca> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @051ecf> : 1f c0 0d 05 00             load.ref <@050dc0> ;noError(ptr: pointer): void
	<.main+3821 @051ed4> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@051ed8> - <@051ee6>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @051ed8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @051edd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @051ee2> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@051ee6> - <@051ef4>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @051ee6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @051eeb> : 1f c8 0d 05 00             load.ref <@050dc8> ;stackOverflow(ptr: pointer): void
	<.main+3849 @051ef0> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@051ef4> - <@051f02>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @051ef4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @051ef9> : 1f e0 0d 05 00             load.ref <@050de0> ;divisionByZero(args: pointer): void
	<.main+3863 @051efe> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@051f02> - <@051f10>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @051f02> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @051f07> : 1f 48 0e 05 00             load.ref <@050e48> ;invalidInstruction(args: pointer): void
	<.main+3877 @051f0c> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@051f10> - <@051f1e>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @051f10> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @051f15> : 1f 38 0e 05 00             load.ref <@050e38> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @051f1a> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@051f1e> - <@051f2c>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @051f1e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @051f23> : 1f f0 0d 05 00             load.ref <@050df0> ;abortExecution(args: pointer): void
	<.main+3905 @051f28> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@051f2c> - <@051f30>): arrFixedNoInit: int64[7]
	<.main+3909 @051f2c> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@051f30> - <@051f34>): arrArrayNoInit: int64[*]
	<.main+3913 @051f30> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@051f34> - <@051f38>): arrSliceNoInit: int64[]
	<.main+3917 @051f34> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@051f38> - <@051f65>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @051f38> : 19                         load.z32
	<.main+3922 @051f39> : 04 1c 00 00                jmp <.main+3950 @051f55>
	test/lang/array.ci:55: (20 bytes: <@051f3d> - <@051f51>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @051f3d> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @051f42> : 10 01                      dup.x1 sp(1)
	<.main+3933 @051f44> : 51                         add.i32
	<.main+3934 @051f45> : 5c                         i32.2i64
	<.main+3935 @051f46> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @051f4a> : 10 03                      dup.x1 sp(3)
	<.main+3941 @051f4c> : 0d 08 00 00                mad.u32 8
	<.main+3945 @051f50> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@051f51> - <@051f55>): int32(i := int32(i + 1))
	<.main+3946 @051f51> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@051f55> - <@051f61>): bool(i < arrFixedNoInit.length)
	<.main+3950 @051f55> : 10 00                      dup.x1 sp(0)
	<.main+3952 @051f57> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @051f5c> : 58                         clt.i32
	<.main+3958 @051f5d> : 05 e0 ff ff                jnz <.main+3926 @051f3d>
	<.main+3962 @051f61> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@051f65> - <@051f6a>): arrArrayInitNull: int64[*] := null
	<.main+3966 @051f65> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@051f6a> - <@051f70>): arrSliceInitNull: int64[] := null
	<.main+3971 @051f6a> : 19                         load.z32
	<.main+3972 @051f6b> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@051f70> - <@051f74>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @051f70> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@051f74> - <@051f7d>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @051f74> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @051f79> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@051f7d> - <@051f7f>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @051f7d> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@051f7f> - <@051f81>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @051f7f> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@051f81> - <@051f83>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @051f81> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@051f83> - <@051f87>): strFixed: char[7]
	<.main+3996 @051f83> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@051f87> - <@051f9d>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @051f87> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @051f8b> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	<.main+4009 @051f90> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @051f95> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @051f99> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@051f9d> - <@051fbf>): debug(void("string as variant", strFixed));
	<.main+4022 @051f9d> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4027 @051fa2> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @051fa7> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @051fac> : 19                         load.z32
	<.main+4038 @051fad> : 1f 4b c3 03 00             load.ref <@03c34b> ;"string as variant"
	<.main+4043 @051fb2> : 1f 58 d1 03 00             load.ref <@03d158>
	<.main+4048 @051fb7> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @051fbb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@051fbf> - <@051fe1>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @051fbf> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4061 @051fc4> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @051fc9> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @051fce> : 19                         load.z32
	<.main+4072 @051fcf> : 1f 5d c3 03 00             load.ref <@03c35d> ;"string to variant"
	<.main+4077 @051fd4> : 1f 58 d1 03 00             load.ref <@03d158>
	<.main+4082 @051fd9> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @051fdd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@051fe1> - <@051fe6>): strArray: char[*] := "string"
	<.main+4090 @051fe1> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/array.ci:87: (32 bytes: <@051fe6> - <@052006>): debug(void("string as variant", strArray));
	<.main+4095 @051fe6> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4100 @051feb> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @051ff0> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @051ff5> : 19                         load.z32
	<.main+4111 @051ff6> : 1f 4b c3 03 00             load.ref <@03c34b> ;"string as variant"
	<.main+4116 @051ffb> : 1f 20 d3 03 00             load.ref <@03d320>
	<.main+4121 @052000> : 10 06                      dup.x1 sp(6)
	<.main+4123 @052002> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@052006> - <@052026>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @052006> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4132 @05200b> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @052010> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @052015> : 19                         load.z32
	<.main+4143 @052016> : 1f 5d c3 03 00             load.ref <@03c35d> ;"string to variant"
	<.main+4148 @05201b> : 1f 20 d3 03 00             load.ref <@03d320>
	<.main+4153 @052020> : 10 06                      dup.x1 sp(6)
	<.main+4155 @052022> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@052026> - <@052030>): strSlice: char[] := "string"
	<.main+4159 @052026> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @05202b> : 1f 2c b2 02 00             load.ref <@02b22c> ;"string"
	test/lang/array.ci:91: (32 bytes: <@052030> - <@052050>): debug(void("string as variant", strSlice));
	<.main+4169 @052030> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4174 @052035> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @05203a> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @05203f> : 19                         load.z32
	<.main+4185 @052040> : 1f 4b c3 03 00             load.ref <@03c34b> ;"string as variant"
	<.main+4190 @052045> : 1f 50 d4 03 00             load.ref <@03d450>
	<.main+4195 @05204a> : 10 06                      dup.x1 sp(6)
	<.main+4197 @05204c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@052050> - <@052070>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @052050> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4206 @052055> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @05205a> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @05205f> : 19                         load.z32
	<.main+4217 @052060> : 1f 5d c3 03 00             load.ref <@03c35d> ;"string to variant"
	<.main+4222 @052065> : 1f 50 d4 03 00             load.ref <@03d450>
	<.main+4227 @05206a> : 10 06                      dup.x1 sp(6)
	<.main+4229 @05206c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@052070> - <@0520a3>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @052070> : 10 10                      dup.x1 sp(16)
	<.main+4235 @052072> : 19                         load.z32
	<.main+4236 @052073> : 38                         clt.u32
	<.main+4237 @052074> : 05 08 00 00                jnz <.main+4245 @05207c>
	<.main+4241 @052078> : 04 2b 00 00                jmp <.main+4284 @0520a3>
	<.main+4245 @05207c> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4250 @052081> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @052086> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @05208b> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @052090> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4270 @052095> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4275 @05209a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @05209f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@0520a3> - <@0520d6>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @0520a3> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @0520a5> : 19                         load.z32
	<.main+4287 @0520a6> : 57                         ceq.i32
	<.main+4288 @0520a7> : 06 08 00 00                jz <.main+4296 @0520af>
	<.main+4292 @0520ab> : 04 2b 00 00                jmp <.main+4335 @0520d6>
	<.main+4296 @0520af> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4301 @0520b4> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @0520b9> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @0520be> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @0520c3> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4321 @0520c8> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4326 @0520cd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @0520d2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@0520d6> - <@052111>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @0520d6> : 11 12                      dup.x2 sp(18)
	<.main+4337 @0520d8> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @0520e1> : 67                         ceq.i64
	<.main+4347 @0520e2> : 06 08 00 00                jz <.main+4355 @0520ea>
	<.main+4351 @0520e6> : 04 2b 00 00                jmp <.main+4394 @052111>
	<.main+4355 @0520ea> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4360 @0520ef> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @0520f4> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @0520f9> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @0520fe> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4380 @052103> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4385 @052108> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @05210d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@052111> - <@05212a>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @052111> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @052116> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @05211b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @052120> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @052125> : 02                         call
	<.main+4415 @052126> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@05212a> - <@052140>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @05212a> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @05212f> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @052131> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @052136> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @05213b> : 02                         call
	<.main+4437 @05213c> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@052140> - <@052156>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @052140> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @052145> : 10 08                      dup.x1 sp(8)
	<.main+4448 @052147> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @05214c> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @052151> : 02                         call
	<.main+4459 @052152> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@052156> - <@052176>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @052156> : 19                         load.z32
	<.main+4464 @052157> : 1a                         load.z64
	<.main+4465 @052158> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @05215d> : 1f 50 0e 05 00             load.ref <@050e50> ;lenSlice(values: int64[]): int32
	<.main+4475 @052162> : 02                         call
	<.main+4476 @052163> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @052167> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @05216c> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @052171> : 02                         call
	<.main+4491 @052172> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@052176> - <@052193>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @052176> : 19                         load.z32
	<.main+4496 @052177> : 19                         load.z32
	<.main+4497 @052178> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @05217a> : 1f 50 0e 05 00             load.ref <@050e50> ;lenSlice(values: int64[]): int32
	<.main+4504 @05217f> : 02                         call
	<.main+4505 @052180> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @052184> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @052189> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @05218e> : 02                         call
	<.main+4520 @05218f> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@052193> - <@0521bb>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @052193> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @052198> : 19                         load.z32
	<.main+4530 @052199> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @05219e> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @0521a2> : 1f 50 0e 05 00             load.ref <@050e50> ;lenSlice(values: int64[]): int32
	<.main+4544 @0521a7> : 02                         call
	<.main+4545 @0521a8> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @0521ac> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @0521b1> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @0521b6> : 02                         call
	<.main+4560 @0521b7> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@0521bb> - <@0521dc>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @0521bb> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @0521c0> : 19                         load.z32
	<.main+4570 @0521c1> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @0521c3> : 1f 50 0e 05 00             load.ref <@050e50> ;lenSlice(values: int64[]): int32
	<.main+4577 @0521c8> : 02                         call
	<.main+4578 @0521c9> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @0521cd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @0521d2> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @0521d7> : 02                         call
	<.main+4593 @0521d8> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@0521dc> - <@0521fd>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @0521dc> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @0521e1> : 19                         load.z32
	<.main+4603 @0521e2> : 11 08                      dup.x2 sp(8)
	<.main+4605 @0521e4> : 1f 50 0e 05 00             load.ref <@050e50> ;lenSlice(values: int64[]): int32
	<.main+4610 @0521e9> : 02                         call
	<.main+4611 @0521ea> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @0521ee> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @0521f3> : 1f 98 fc 04 00             load.ref <@04fc98> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @0521f8> : 02                         call
	<.main+4626 @0521f9> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@0521fd> - <@052524>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @0521fd> : 19                         load.z32
	<.main+4631 @0521fe> : 04 16 03 00                jmp <.main+5421 @052514>
	test/lang/array.ci:119: (9 bytes: <@052202> - <@05220b>): expected: int64 := int32(42 + i)
	<.main+4635 @052202> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @052207> : 10 01                      dup.x1 sp(1)
	<.main+4642 @052209> : 51                         add.i32
	<.main+4643 @05220a> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@05220b> - <@052248>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @05220b> : 11 00                      dup.x2 sp(0)
	<.main+4646 @05220d> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @052211> : 10 05                      dup.x1 sp(5)
	<.main+4652 @052213> : 0d 08 00 00                mad.u32 8
	<.main+4656 @052217> : 23                         load.i64
	<.main+4657 @052218> : 67                         ceq.i64
	<.main+4658 @052219> : 06 08 00 00                jz <.main+4666 @052221>
	<.main+4662 @05221d> : 04 2b 00 00                jmp <.main+4705 @052248>
	<.main+4666 @052221> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4671 @052226> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @05222b> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @052230> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @052235> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4691 @05223a> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4696 @05223f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @052244> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@052248> - <@052283>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @052248> : 11 00                      dup.x2 sp(0)
	<.main+4707 @05224a> : 10 10                      dup.x1 sp(16)
	<.main+4709 @05224c> : 10 05                      dup.x1 sp(5)
	<.main+4711 @05224e> : 0d 08 00 00                mad.u32 8
	<.main+4715 @052252> : 23                         load.i64
	<.main+4716 @052253> : 67                         ceq.i64
	<.main+4717 @052254> : 06 08 00 00                jz <.main+4725 @05225c>
	<.main+4721 @052258> : 04 2b 00 00                jmp <.main+4764 @052283>
	<.main+4725 @05225c> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4730 @052261> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @052266> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @05226b> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @052270> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4750 @052275> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4755 @05227a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @05227f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@052283> - <@0522be>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @052283> : 11 00                      dup.x2 sp(0)
	<.main+4766 @052285> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @052287> : 10 05                      dup.x1 sp(5)
	<.main+4770 @052289> : 0d 08 00 00                mad.u32 8
	<.main+4774 @05228d> : 23                         load.i64
	<.main+4775 @05228e> : 67                         ceq.i64
	<.main+4776 @05228f> : 06 08 00 00                jz <.main+4784 @052297>
	<.main+4780 @052293> : 04 2b 00 00                jmp <.main+4823 @0522be>
	<.main+4784 @052297> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4789 @05229c> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @0522a1> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @0522a6> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @0522ab> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4809 @0522b0> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4814 @0522b5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @0522ba> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@0522be> - <@052301>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @0522be> : 11 00                      dup.x2 sp(0)
	<.main+4825 @0522c0> : 1a                         load.z64
	<.main+4826 @0522c1> : 10 06                      dup.x1 sp(6)
	<.main+4828 @0522c3> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @0522c7> : 1f 58 0e 05 00             load.ref <@050e58> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @0522cc> : 02                         call
	<.main+4838 @0522cd> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @0522d1> : 67                         ceq.i64
	<.main+4843 @0522d2> : 06 08 00 00                jz <.main+4851 @0522da>
	<.main+4847 @0522d6> : 04 2b 00 00                jmp <.main+4890 @052301>
	<.main+4851 @0522da> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4856 @0522df> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @0522e4> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @0522e9> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @0522ee> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4876 @0522f3> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4881 @0522f8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @0522fd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@052301> - <@052342>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @052301> : 11 00                      dup.x2 sp(0)
	<.main+4892 @052303> : 1a                         load.z64
	<.main+4893 @052304> : 10 06                      dup.x1 sp(6)
	<.main+4895 @052306> : 10 13                      dup.x1 sp(19)
	<.main+4897 @052308> : 1f 58 0e 05 00             load.ref <@050e58> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @05230d> : 02                         call
	<.main+4903 @05230e> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @052312> : 67                         ceq.i64
	<.main+4908 @052313> : 06 08 00 00                jz <.main+4916 @05231b>
	<.main+4912 @052317> : 04 2b 00 00                jmp <.main+4955 @052342>
	<.main+4916 @05231b> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4921 @052320> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @052325> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @05232a> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @05232f> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+4941 @052334> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4946 @052339> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @05233e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@052342> - <@052383>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @052342> : 11 00                      dup.x2 sp(0)
	<.main+4957 @052344> : 1a                         load.z64
	<.main+4958 @052345> : 10 06                      dup.x1 sp(6)
	<.main+4960 @052347> : 10 11                      dup.x1 sp(17)
	<.main+4962 @052349> : 1f 58 0e 05 00             load.ref <@050e58> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @05234e> : 02                         call
	<.main+4968 @05234f> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @052353> : 67                         ceq.i64
	<.main+4973 @052354> : 06 08 00 00                jz <.main+4981 @05235c>
	<.main+4977 @052358> : 04 2b 00 00                jmp <.main+5020 @052383>
	<.main+4981 @05235c> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+4986 @052361> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @052366> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @05236b> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @052370> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5006 @052375> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5011 @05237a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @05237f> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@052383> - <@0523c6>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @052383> : 11 00                      dup.x2 sp(0)
	<.main+5022 @052385> : 1a                         load.z64
	<.main+5023 @052386> : 10 06                      dup.x1 sp(6)
	<.main+5025 @052388> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @05238c> : 1f 68 0e 05 00             load.ref <@050e68> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @052391> : 02                         call
	<.main+5035 @052392> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @052396> : 67                         ceq.i64
	<.main+5040 @052397> : 06 08 00 00                jz <.main+5048 @05239f>
	<.main+5044 @05239b> : 04 2b 00 00                jmp <.main+5087 @0523c6>
	<.main+5048 @05239f> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5053 @0523a4> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @0523a9> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @0523ae> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @0523b3> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5073 @0523b8> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5078 @0523bd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @0523c2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@0523c6> - <@052407>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @0523c6> : 11 00                      dup.x2 sp(0)
	<.main+5089 @0523c8> : 1a                         load.z64
	<.main+5090 @0523c9> : 10 06                      dup.x1 sp(6)
	<.main+5092 @0523cb> : 10 13                      dup.x1 sp(19)
	<.main+5094 @0523cd> : 1f 68 0e 05 00             load.ref <@050e68> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @0523d2> : 02                         call
	<.main+5100 @0523d3> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @0523d7> : 67                         ceq.i64
	<.main+5105 @0523d8> : 06 08 00 00                jz <.main+5113 @0523e0>
	<.main+5109 @0523dc> : 04 2b 00 00                jmp <.main+5152 @052407>
	<.main+5113 @0523e0> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5118 @0523e5> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @0523ea> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @0523ef> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @0523f4> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5138 @0523f9> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5143 @0523fe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @052403> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@052407> - <@052448>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @052407> : 11 00                      dup.x2 sp(0)
	<.main+5154 @052409> : 1a                         load.z64
	<.main+5155 @05240a> : 10 06                      dup.x1 sp(6)
	<.main+5157 @05240c> : 10 11                      dup.x1 sp(17)
	<.main+5159 @05240e> : 1f 68 0e 05 00             load.ref <@050e68> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @052413> : 02                         call
	<.main+5165 @052414> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @052418> : 67                         ceq.i64
	<.main+5170 @052419> : 06 08 00 00                jz <.main+5178 @052421>
	<.main+5174 @05241d> : 04 2b 00 00                jmp <.main+5217 @052448>
	<.main+5178 @052421> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5183 @052426> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @05242b> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @052430> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @052435> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5203 @05243a> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5208 @05243f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @052444> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@052448> - <@052490>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @052448> : 11 00                      dup.x2 sp(0)
	<.main+5219 @05244a> : 1a                         load.z64
	<.main+5220 @05244b> : 10 06                      dup.x1 sp(6)
	<.main+5222 @05244d> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @052452> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @052456> : 1f 78 0e 05 00             load.ref <@050e78> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @05245b> : 02                         call
	<.main+5237 @05245c> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @052460> : 67                         ceq.i64
	<.main+5242 @052461> : 06 08 00 00                jz <.main+5250 @052469>
	<.main+5246 @052465> : 04 2b 00 00                jmp <.main+5289 @052490>
	<.main+5250 @052469> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5255 @05246e> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @052473> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @052478> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @05247d> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5275 @052482> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5280 @052487> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @05248c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@052490> - <@0524d1>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @052490> : 11 00                      dup.x2 sp(0)
	<.main+5291 @052492> : 1a                         load.z64
	<.main+5292 @052493> : 10 06                      dup.x1 sp(6)
	<.main+5294 @052495> : 11 11                      dup.x2 sp(17)
	<.main+5296 @052497> : 1f 78 0e 05 00             load.ref <@050e78> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @05249c> : 02                         call
	<.main+5302 @05249d> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @0524a1> : 67                         ceq.i64
	<.main+5307 @0524a2> : 06 08 00 00                jz <.main+5315 @0524aa>
	<.main+5311 @0524a6> : 04 2b 00 00                jmp <.main+5354 @0524d1>
	<.main+5315 @0524aa> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5320 @0524af> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @0524b4> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @0524b9> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @0524be> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5340 @0524c3> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5345 @0524c8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @0524cd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@0524d1> - <@05250c>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @0524d1> : 11 00                      dup.x2 sp(0)
	<.main+5356 @0524d3> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @0524d5> : 10 05                      dup.x1 sp(5)
	<.main+5360 @0524d7> : 0d 08 00 00                mad.u32 8
	<.main+5364 @0524db> : 23                         load.i64
	<.main+5365 @0524dc> : 67                         ceq.i64
	<.main+5366 @0524dd> : 06 08 00 00                jz <.main+5374 @0524e5>
	<.main+5370 @0524e1> : 04 2b 00 00                jmp <.main+5413 @05250c>
	<.main+5374 @0524e5> : 1f 88 c2 03 00             load.ref <@03c288> ;"test/lang/array.ci"
	<.main+5379 @0524ea> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @0524ef> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @0524f4> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @0524f9> : 1f 59 cb 00 00             load.ref <@00cb59> ;"assertion failed!"
	<.main+5399 @0524fe> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5404 @052503> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @052508> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @05250c> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@052510> - <@052514>): int32(i := int32(i + 1))
	<.main+5417 @052510> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@052514> - <@052520>): bool(i < arrFixedNoInit.length)
	<.main+5421 @052514> : 10 00                      dup.x1 sp(0)
	<.main+5423 @052516> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @05251b> : 58                         clt.i32
	<.main+5429 @05251c> : 05 e6 fc ff                jnz <.main+4635 @052202>
	<.main+5433 @052520> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@052524> - <@052560>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @052524> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@052528> - <@05252f>): void(recordMemberTest.member := 10);
	<.main+5441 @052528> : 1c 0a 00 00 00             load.c32 10
	<.main+5446 @05252d> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@05252f> - <@052536>): void(recordMemberTest.constant := 11);
	<.main+5448 @05252f> : 1c 0b 00 00 00             load.c32 11
	<.main+5453 @052534> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@052536> - <@05253d>): void(recordMemberTest.memberInit := 12);
	<.main+5455 @052536> : 1c 0c 00 00 00             load.c32 12
	<.main+5460 @05253b> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@05253d> - <@052544>): void(recordMemberTest.constantInit := 13);
	<.main+5462 @05253d> : 1c 0d 00 00 00             load.c32 13
	<.main+5467 @052542> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@052544> - <@05254b>): void(recordMemberTest.memberRec.member := 14);
	<.main+5469 @052544> : 1c 0e 00 00 00             load.c32 14
	<.main+5474 @052549> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@05254b> - <@052552>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5476 @05254b> : 1c 0f 00 00 00             load.c32 15
	<.main+5481 @052550> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@052552> - <@052559>): void(recordMemberTest.constantRec.member := 16);
	<.main+5483 @052552> : 1c 10 00 00 00             load.c32 16
	<.main+5488 @052557> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@052559> - <@052560>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5490 @052559> : 1c 11 00 00 00             load.c32 17
	<.main+5495 @05255e> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:44: (24 bytes: <@052560> - <@052578>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @052560> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:46: (7 bytes: <@052564> - <@05256b>): void(recordMethodTest.abstractMethod := globalFunction);
	<.main+5501 @052564> : 1f 38 0f 05 00             load.ref <@050f38> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5506 @052569> : 13 01                      set.x1 sp(1)
	:: (6 bytes: <@05256b> - <@052571>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5508 @05256b> : 2a e0 0e 05                load.m32 <@050ee0> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5512 @05256f> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@052571> - <@052578>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5514 @052571> : 1f e8 0e 05 00             load.ref <@050ee8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5519 @052576> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:58: (19 bytes: <@052578> - <@05258b>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+5521 @052578> : 12 00                      dup.x4 sp(0)
	<.main+5523 @05257a> : 1c 01 00 00 00             load.c32 1
	<.main+5528 @05257f> : 13 04                      set.x1 sp(4)
	<.main+5530 @052581> : 1f b8 0e 05 00             load.ref <@050eb8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5535 @052586> : 02                         call
	<.main+5536 @052587> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:59: (16 bytes: <@05258b> - <@05259b>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+5540 @05258b> : 12 00                      dup.x4 sp(0)
	<.main+5542 @05258d> : 1c 01 00 00 00             load.c32 1
	<.main+5547 @052592> : 13 04                      set.x1 sp(4)
	<.main+5549 @052594> : 10 06                      dup.x1 sp(6)
	<.main+5551 @052596> : 02                         call
	<.main+5552 @052597> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:75: (17 bytes: <@05259b> - <@0525ac>): staticMethod(void(recordMethodTest, 2));
	<.main+5556 @05259b> : 12 00                      dup.x4 sp(0)
	<.main+5558 @05259d> : 1c 02 00 00 00             load.c32 2
	<.main+5563 @0525a2> : 1f 60 0f 05 00             load.ref <@050f60> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5568 @0525a7> : 02                         call
	<.main+5569 @0525a8> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:76: (17 bytes: <@0525ac> - <@0525bd>): virtualMethod(void(recordMethodTest, 2));
	<.main+5573 @0525ac> : 12 00                      dup.x4 sp(0)
	<.main+5575 @0525ae> : 1c 02 00 00 00             load.c32 2
	<.main+5580 @0525b3> : 1f a8 0f 05 00             load.ref <@050fa8> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5585 @0525b8> : 02                         call
	<.main+5586 @0525b9> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:79: (19 bytes: <@0525bd> - <@0525d0>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+5590 @0525bd> : 12 00                      dup.x4 sp(0)
	<.main+5592 @0525bf> : 1c 03 00 00 00             load.c32 3
	<.main+5597 @0525c4> : 13 04                      set.x1 sp(4)
	<.main+5599 @0525c6> : 1f b8 0e 05 00             load.ref <@050eb8> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5604 @0525cb> : 02                         call
	<.main+5605 @0525cc> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:80: (19 bytes: <@0525d0> - <@0525e3>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5609 @0525d0> : 12 00                      dup.x4 sp(0)
	<.main+5611 @0525d2> : 1c 03 00 00 00             load.c32 3
	<.main+5616 @0525d7> : 13 04                      set.x1 sp(4)
	<.main+5618 @0525d9> : 1f e8 0e 05 00             load.ref <@050ee8> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5623 @0525de> : 02                         call
	<.main+5624 @0525df> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:81: (16 bytes: <@0525e3> - <@0525f3>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5628 @0525e3> : 12 00                      dup.x4 sp(0)
	<.main+5630 @0525e5> : 1c 03 00 00 00             load.c32 3
	<.main+5635 @0525ea> : 13 04                      set.x1 sp(4)
	<.main+5637 @0525ec> : 10 06                      dup.x1 sp(6)
	<.main+5639 @0525ee> : 02                         call
	<.main+5640 @0525ef> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@0525f3> - <@052609>): black: rgbU8 := {...}
	<.main+5644 @0525f3> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@0525f7> - <@0525fd>): void(black.r := (0));
	<.main+5648 @0525f7> : 19                         load.z32
	<.main+5649 @0525f8> : 0a 06 00 00                load.sp(+6)
	<.main+5653 @0525fc> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@0525fd> - <@052603>): void(black.g := (0));
	<.main+5654 @0525fd> : 19                         load.z32
	<.main+5655 @0525fe> : 0a 05 00 00                load.sp(+5)
	<.main+5659 @052602> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@052603> - <@052609>): void(black.b := (0));
	<.main+5660 @052603> : 19                         load.z32
	<.main+5661 @052604> : 0a 04 00 00                load.sp(+4)
	<.main+5665 @052608> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@052609> - <@052623>): green: rgbU8 := {...}
	<.main+5666 @052609> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@05260d> - <@052613>): void(green.r := (0));
	<.main+5670 @05260d> : 19                         load.z32
	<.main+5671 @05260e> : 0a 06 00 00                load.sp(+6)
	<.main+5675 @052612> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@052613> - <@05261d>): void(green.g := (255));
	<.main+5676 @052613> : 1c ff 00 00 00             load.c32 255
	<.main+5681 @052618> : 0a 05 00 00                load.sp(+5)
	<.main+5685 @05261c> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@05261d> - <@052623>): void(green.b := (0));
	<.main+5686 @05261d> : 19                         load.z32
	<.main+5687 @05261e> : 0a 04 00 00                load.sp(+4)
	<.main+5691 @052622> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@052623> - <@052645>): white: rgbU8 := {...}
	<.main+5692 @052623> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@052627> - <@052631>): void(white.r := (255));
	<.main+5696 @052627> : 1c ff 00 00 00             load.c32 255
	<.main+5701 @05262c> : 0a 06 00 00                load.sp(+6)
	<.main+5705 @052630> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@052631> - <@05263b>): void(white.g := (255));
	<.main+5706 @052631> : 1c ff 00 00 00             load.c32 255
	<.main+5711 @052636> : 0a 05 00 00                load.sp(+5)
	<.main+5715 @05263a> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@05263b> - <@052645>): void(white.b := (255));
	<.main+5716 @05263b> : 1c ff 00 00 00             load.c32 255
	<.main+5721 @052640> : 0a 04 00 00                load.sp(+4)
	<.main+5725 @052644> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@052645> - <@052650>): cyan: color := {...}
	<.main+5726 @052645> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@052649> - <@052650>): void(cyan.col := (65535));
	<.main+5730 @052649> : 1c ff ff 00 00             load.c32 65535
	<.main+5735 @05264e> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@052650> - <@05266a>): blue: color := {...}
	<.main+5737 @052650> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@052654> - <@05265a>): void(blue.rgb.r := (0));
	<.main+5741 @052654> : 19                         load.z32
	<.main+5742 @052655> : 0a 06 00 00                load.sp(+6)
	<.main+5746 @052659> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@05265a> - <@052660>): void(blue.rgb.g := (0));
	<.main+5747 @05265a> : 19                         load.z32
	<.main+5748 @05265b> : 0a 05 00 00                load.sp(+5)
	<.main+5752 @05265f> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@052660> - <@05266a>): void(blue.rgb.b := (255));
	<.main+5753 @052660> : 1c ff 00 00 00             load.c32 255
	<.main+5758 @052665> : 0a 04 00 00                load.sp(+4)
	<.main+5762 @052669> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@05266a> - <@05266f>): shift: int32 := 2
	<.main+5763 @05266a> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@05266f> - <@052674>): boolA: bool := true
	<.main+5768 @05266f> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@052674> - <@052679>): boolB: bool := bool(!false)
	<.main+5773 @052674> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@052679> - <@052684>): boolAnd: bool := bool(boolA & boolB)
	<.main+5778 @052679> : 0a 04 00 00                load.sp(+4)
	<.main+5782 @05267d> : 20                         load.i8
	<.main+5783 @05267e> : 0a 04 00 00                load.sp(+4)
	<.main+5787 @052682> : 20                         load.i8
	<.main+5788 @052683> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@052684> - <@05268f>): boolIor: bool := bool(boolA | boolB)
	<.main+5789 @052684> : 0a 08 00 00                load.sp(+8)
	<.main+5793 @052688> : 20                         load.i8
	<.main+5794 @052689> : 0a 08 00 00                load.sp(+8)
	<.main+5798 @05268d> : 20                         load.i8
	<.main+5799 @05268e> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@05268f> - <@05269a>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5800 @05268f> : 0a 0c 00 00                load.sp(+12)
	<.main+5804 @052693> : 20                         load.i8
	<.main+5805 @052694> : 0a 0c 00 00                load.sp(+12)
	<.main+5809 @052698> : 20                         load.i8
	<.main+5810 @052699> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@05269a> - <@0526a0>): boolNot: bool := bool(!boolB)
	<.main+5811 @05269a> : 0a 0c 00 00                load.sp(+12)
	<.main+5815 @05269e> : 20                         load.i8
	<.main+5816 @05269f> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@0526a0> - <@0526ab>): boolCeq: bool := bool(boolA == boolB)
	<.main+5817 @0526a0> : 0a 14 00 00                load.sp(+20)
	<.main+5821 @0526a4> : 20                         load.i8
	<.main+5822 @0526a5> : 0a 14 00 00                load.sp(+20)
	<.main+5826 @0526a9> : 20                         load.i8
	<.main+5827 @0526aa> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@0526ab> - <@0526b7>): boolCne: bool := bool(boolA != boolB)
	<.main+5828 @0526ab> : 0a 18 00 00                load.sp(+24)
	<.main+5832 @0526af> : 20                         load.i8
	<.main+5833 @0526b0> : 0a 18 00 00                load.sp(+24)
	<.main+5837 @0526b4> : 20                         load.i8
	<.main+5838 @0526b5> : 57                         ceq.i32
	<.main+5839 @0526b6> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@0526b7> - <@0526c2>): boolClt: bool := bool(boolA < boolB)
	<.main+5840 @0526b7> : 0a 1c 00 00                load.sp(+28)
	<.main+5844 @0526bb> : 20                         load.i8
	<.main+5845 @0526bc> : 0a 1c 00 00                load.sp(+28)
	<.main+5849 @0526c0> : 20                         load.i8
	<.main+5850 @0526c1> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@0526c2> - <@0526ce>): boolCle: bool := bool(boolA <= boolB)
	<.main+5851 @0526c2> : 0a 20 00 00                load.sp(+32)
	<.main+5855 @0526c6> : 20                         load.i8
	<.main+5856 @0526c7> : 0a 20 00 00                load.sp(+32)
	<.main+5860 @0526cb> : 20                         load.i8
	<.main+5861 @0526cc> : 59                         cgt.i32
	<.main+5862 @0526cd> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@0526ce> - <@0526d9>): boolCgt: bool := bool(boolA > boolB)
	<.main+5863 @0526ce> : 0a 24 00 00                load.sp(+36)
	<.main+5867 @0526d2> : 20                         load.i8
	<.main+5868 @0526d3> : 0a 24 00 00                load.sp(+36)
	<.main+5872 @0526d7> : 20                         load.i8
	<.main+5873 @0526d8> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@0526d9> - <@0526e5>): boolCge: bool := bool(boolA >= boolB)
	<.main+5874 @0526d9> : 0a 28 00 00                load.sp(+40)
	<.main+5878 @0526dd> : 20                         load.i8
	<.main+5879 @0526de> : 0a 28 00 00                load.sp(+40)
	<.main+5883 @0526e2> : 20                         load.i8
	<.main+5884 @0526e3> : 58                         clt.i32
	<.main+5885 @0526e4> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@0526e5> - <@0526ea>): chrA: char := 'a'
	<.main+5886 @0526e5> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@0526ea> - <@0526ef>): chrB: char := 'b'
	<.main+5891 @0526ea> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@0526ef> - <@0526f4>): chrPls: char := char(+chrB)
	<.main+5896 @0526ef> : 0a 00 00 00                load.sp(+0)
	<.main+5900 @0526f3> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@0526f4> - <@0526fa>): chrNeg: char := char(-chrB)
	<.main+5901 @0526f4> : 0a 04 00 00                load.sp(+4)
	<.main+5905 @0526f8> : 20                         load.i8
	<.main+5906 @0526f9> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@0526fa> - <@052700>): chrCmt: char := char(~chrB)
	<.main+5907 @0526fa> : 0a 08 00 00                load.sp(+8)
	<.main+5911 @0526fe> : 20                         load.i8
	<.main+5912 @0526ff> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@052700> - <@05270b>): chrAdd: char := char(chrA + chrB)
	<.main+5913 @052700> : 0a 10 00 00                load.sp(+16)
	<.main+5917 @052704> : 20                         load.i8
	<.main+5918 @052705> : 0a 10 00 00                load.sp(+16)
	<.main+5922 @052709> : 20                         load.i8
	<.main+5923 @05270a> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@05270b> - <@052716>): chrSub: char := char(chrA - chrB)
	<.main+5924 @05270b> : 0a 14 00 00                load.sp(+20)
	<.main+5928 @05270f> : 20                         load.i8
	<.main+5929 @052710> : 0a 14 00 00                load.sp(+20)
	<.main+5933 @052714> : 20                         load.i8
	<.main+5934 @052715> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@052716> - <@052721>): chrMul: char := char(chrA * chrB)
	<.main+5935 @052716> : 0a 18 00 00                load.sp(+24)
	<.main+5939 @05271a> : 20                         load.i8
	<.main+5940 @05271b> : 0a 18 00 00                load.sp(+24)
	<.main+5944 @05271f> : 20                         load.i8
	<.main+5945 @052720> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@052721> - <@05272c>): chrDiv: char := char(chrA / chrB)
	<.main+5946 @052721> : 0a 1c 00 00                load.sp(+28)
	<.main+5950 @052725> : 20                         load.i8
	<.main+5951 @052726> : 0a 1c 00 00                load.sp(+28)
	<.main+5955 @05272a> : 20                         load.i8
	<.main+5956 @05272b> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@05272c> - <@052737>): chrMod: char := char(chrA % chrB)
	<.main+5957 @05272c> : 0a 20 00 00                load.sp(+32)
	<.main+5961 @052730> : 20                         load.i8
	<.main+5962 @052731> : 0a 20 00 00                load.sp(+32)
	<.main+5966 @052735> : 20                         load.i8
	<.main+5967 @052736> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@052737> - <@052742>): chrAnd: char := char(chrA & chrB)
	<.main+5968 @052737> : 0a 24 00 00                load.sp(+36)
	<.main+5972 @05273b> : 20                         load.i8
	<.main+5973 @05273c> : 0a 24 00 00                load.sp(+36)
	<.main+5977 @052740> : 20                         load.i8
	<.main+5978 @052741> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@052742> - <@05274d>): chrIor: char := char(chrA | chrB)
	<.main+5979 @052742> : 0a 28 00 00                load.sp(+40)
	<.main+5983 @052746> : 20                         load.i8
	<.main+5984 @052747> : 0a 28 00 00                load.sp(+40)
	<.main+5988 @05274b> : 20                         load.i8
	<.main+5989 @05274c> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@05274d> - <@052758>): chrXor: char := char(chrA ^ chrB)
	<.main+5990 @05274d> : 0a 2c 00 00                load.sp(+44)
	<.main+5994 @052751> : 20                         load.i8
	<.main+5995 @052752> : 0a 2c 00 00                load.sp(+44)
	<.main+5999 @052756> : 20                         load.i8
	<.main+6000 @052757> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@052758> - <@052760>): chrShl: char := int32((chrA) << shift)
	<.main+6001 @052758> : 0a 30 00 00                load.sp(+48)
	<.main+6005 @05275c> : 20                         load.i8
	<.main+6006 @05275d> : 10 1a                      dup.x1 sp(26)
	<.main+6008 @05275f> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@052760> - <@052768>): chrShr: char := int32((chrA) >> shift)
	<.main+6009 @052760> : 0a 34 00 00                load.sp(+52)
	<.main+6013 @052764> : 20                         load.i8
	<.main+6014 @052765> : 10 1b                      dup.x1 sp(27)
	<.main+6016 @052767> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@052768> - <@05276f>): chrNot: bool := bool(!(chrB))
	<.main+6017 @052768> : 0a 34 00 00                load.sp(+52)
	<.main+6021 @05276c> : 20                         load.i8
	<.main+6022 @05276d> : 5a                         i32.2bool
	<.main+6023 @05276e> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@05276f> - <@05277a>): chrCeq: bool := bool(chrA == chrB)
	<.main+6024 @05276f> : 0a 3c 00 00                load.sp(+60)
	<.main+6028 @052773> : 20                         load.i8
	<.main+6029 @052774> : 0a 3c 00 00                load.sp(+60)
	<.main+6033 @052778> : 20                         load.i8
	<.main+6034 @052779> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@05277a> - <@052786>): chrCne: bool := bool(chrA != chrB)
	<.main+6035 @05277a> : 0a 40 00 00                load.sp(+64)
	<.main+6039 @05277e> : 20                         load.i8
	<.main+6040 @05277f> : 0a 40 00 00                load.sp(+64)
	<.main+6044 @052783> : 20                         load.i8
	<.main+6045 @052784> : 57                         ceq.i32
	<.main+6046 @052785> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@052786> - <@052791>): chrClt: bool := bool(chrA < chrB)
	<.main+6047 @052786> : 0a 44 00 00                load.sp(+68)
	<.main+6051 @05278a> : 20                         load.i8
	<.main+6052 @05278b> : 0a 44 00 00                load.sp(+68)
	<.main+6056 @05278f> : 20                         load.i8
	<.main+6057 @052790> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@052791> - <@05279d>): chrCle: bool := bool(chrA <= chrB)
	<.main+6058 @052791> : 0a 48 00 00                load.sp(+72)
	<.main+6062 @052795> : 20                         load.i8
	<.main+6063 @052796> : 0a 48 00 00                load.sp(+72)
	<.main+6067 @05279a> : 20                         load.i8
	<.main+6068 @05279b> : 59                         cgt.i32
	<.main+6069 @05279c> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@05279d> - <@0527a8>): chrCgt: bool := bool(chrA > chrB)
	<.main+6070 @05279d> : 0a 4c 00 00                load.sp(+76)
	<.main+6074 @0527a1> : 20                         load.i8
	<.main+6075 @0527a2> : 0a 4c 00 00                load.sp(+76)
	<.main+6079 @0527a6> : 20                         load.i8
	<.main+6080 @0527a7> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@0527a8> - <@0527b4>): chrCge: bool := bool(chrA >= chrB)
	<.main+6081 @0527a8> : 0a 50 00 00                load.sp(+80)
	<.main+6085 @0527ac> : 20                         load.i8
	<.main+6086 @0527ad> : 0a 50 00 00                load.sp(+80)
	<.main+6090 @0527b1> : 20                         load.i8
	<.main+6091 @0527b2> : 58                         clt.i32
	<.main+6092 @0527b3> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@0527b4> - <@0527b9>): i8A: int8 := a
	<.main+6093 @0527b4> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@0527b9> - <@0527be>): i8B: int8 := b
	<.main+6098 @0527b9> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@0527be> - <@0527c3>): i8Pls: int8 := int8(+i8B)
	<.main+6103 @0527be> : 0a 00 00 00                load.sp(+0)
	<.main+6107 @0527c2> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@0527c3> - <@0527c9>): i8Neg: int8 := int8(-i8B)
	<.main+6108 @0527c3> : 0a 04 00 00                load.sp(+4)
	<.main+6112 @0527c7> : 20                         load.i8
	<.main+6113 @0527c8> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@0527c9> - <@0527cf>): i8Cmt: int8 := int8(~i8B)
	<.main+6114 @0527c9> : 0a 08 00 00                load.sp(+8)
	<.main+6118 @0527cd> : 20                         load.i8
	<.main+6119 @0527ce> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@0527cf> - <@0527da>): i8Add: int8 := int8(i8A + i8B)
	<.main+6120 @0527cf> : 0a 10 00 00                load.sp(+16)
	<.main+6124 @0527d3> : 20                         load.i8
	<.main+6125 @0527d4> : 0a 10 00 00                load.sp(+16)
	<.main+6129 @0527d8> : 20                         load.i8
	<.main+6130 @0527d9> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@0527da> - <@0527e5>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6131 @0527da> : 0a 14 00 00                load.sp(+20)
	<.main+6135 @0527de> : 20                         load.i8
	<.main+6136 @0527df> : 0a 14 00 00                load.sp(+20)
	<.main+6140 @0527e3> : 20                         load.i8
	<.main+6141 @0527e4> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@0527e5> - <@0527f0>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6142 @0527e5> : 0a 18 00 00                load.sp(+24)
	<.main+6146 @0527e9> : 20                         load.i8
	<.main+6147 @0527ea> : 0a 18 00 00                load.sp(+24)
	<.main+6151 @0527ee> : 20                         load.i8
	<.main+6152 @0527ef> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@0527f0> - <@0527fb>): i8Div: int8 := int8(i8A / i8B)
	<.main+6153 @0527f0> : 0a 1c 00 00                load.sp(+28)
	<.main+6157 @0527f4> : 20                         load.i8
	<.main+6158 @0527f5> : 0a 1c 00 00                load.sp(+28)
	<.main+6162 @0527f9> : 20                         load.i8
	<.main+6163 @0527fa> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@0527fb> - <@052806>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6164 @0527fb> : 0a 20 00 00                load.sp(+32)
	<.main+6168 @0527ff> : 20                         load.i8
	<.main+6169 @052800> : 0a 20 00 00                load.sp(+32)
	<.main+6173 @052804> : 20                         load.i8
	<.main+6174 @052805> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@052806> - <@052811>): i8And: int8 := int8(i8A & i8B)
	<.main+6175 @052806> : 0a 24 00 00                load.sp(+36)
	<.main+6179 @05280a> : 20                         load.i8
	<.main+6180 @05280b> : 0a 24 00 00                load.sp(+36)
	<.main+6184 @05280f> : 20                         load.i8
	<.main+6185 @052810> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@052811> - <@05281c>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6186 @052811> : 0a 28 00 00                load.sp(+40)
	<.main+6190 @052815> : 20                         load.i8
	<.main+6191 @052816> : 0a 28 00 00                load.sp(+40)
	<.main+6195 @05281a> : 20                         load.i8
	<.main+6196 @05281b> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@05281c> - <@052827>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6197 @05281c> : 0a 2c 00 00                load.sp(+44)
	<.main+6201 @052820> : 20                         load.i8
	<.main+6202 @052821> : 0a 2c 00 00                load.sp(+44)
	<.main+6206 @052825> : 20                         load.i8
	<.main+6207 @052826> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@052827> - <@05282f>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6208 @052827> : 0a 30 00 00                load.sp(+48)
	<.main+6212 @05282b> : 20                         load.i8
	<.main+6213 @05282c> : 10 30                      dup.x1 sp(48)
	<.main+6215 @05282e> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@05282f> - <@052837>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6216 @05282f> : 0a 34 00 00                load.sp(+52)
	<.main+6220 @052833> : 20                         load.i8
	<.main+6221 @052834> : 10 31                      dup.x1 sp(49)
	<.main+6223 @052836> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@052837> - <@05283e>): i8Not: bool := bool(!(i8B))
	<.main+6224 @052837> : 0a 34 00 00                load.sp(+52)
	<.main+6228 @05283b> : 20                         load.i8
	<.main+6229 @05283c> : 5a                         i32.2bool
	<.main+6230 @05283d> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@05283e> - <@052849>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6231 @05283e> : 0a 3c 00 00                load.sp(+60)
	<.main+6235 @052842> : 20                         load.i8
	<.main+6236 @052843> : 0a 3c 00 00                load.sp(+60)
	<.main+6240 @052847> : 20                         load.i8
	<.main+6241 @052848> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@052849> - <@052855>): i8Cne: bool := bool(i8A != i8B)
	<.main+6242 @052849> : 0a 40 00 00                load.sp(+64)
	<.main+6246 @05284d> : 20                         load.i8
	<.main+6247 @05284e> : 0a 40 00 00                load.sp(+64)
	<.main+6251 @052852> : 20                         load.i8
	<.main+6252 @052853> : 57                         ceq.i32
	<.main+6253 @052854> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@052855> - <@052860>): i8Clt: bool := bool(i8A < i8B)
	<.main+6254 @052855> : 0a 44 00 00                load.sp(+68)
	<.main+6258 @052859> : 20                         load.i8
	<.main+6259 @05285a> : 0a 44 00 00                load.sp(+68)
	<.main+6263 @05285e> : 20                         load.i8
	<.main+6264 @05285f> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@052860> - <@05286c>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6265 @052860> : 0a 48 00 00                load.sp(+72)
	<.main+6269 @052864> : 20                         load.i8
	<.main+6270 @052865> : 0a 48 00 00                load.sp(+72)
	<.main+6274 @052869> : 20                         load.i8
	<.main+6275 @05286a> : 59                         cgt.i32
	<.main+6276 @05286b> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@05286c> - <@052877>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6277 @05286c> : 0a 4c 00 00                load.sp(+76)
	<.main+6281 @052870> : 20                         load.i8
	<.main+6282 @052871> : 0a 4c 00 00                load.sp(+76)
	<.main+6286 @052875> : 20                         load.i8
	<.main+6287 @052876> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@052877> - <@052883>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6288 @052877> : 0a 50 00 00                load.sp(+80)
	<.main+6292 @05287b> : 20                         load.i8
	<.main+6293 @05287c> : 0a 50 00 00                load.sp(+80)
	<.main+6297 @052880> : 20                         load.i8
	<.main+6298 @052881> : 58                         clt.i32
	<.main+6299 @052882> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@052883> - <@052888>): u8A: uint8 := a
	<.main+6300 @052883> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@052888> - <@05288d>): u8B: uint8 := b
	<.main+6305 @052888> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@05288d> - <@052892>): u8Pls: uint8 := uint8(+u8B)
	<.main+6310 @05288d> : 0a 00 00 00                load.sp(+0)
	<.main+6314 @052891> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@052892> - <@052898>): u8Neg: uint8 := uint8(-u8B)
	<.main+6315 @052892> : 0a 04 00 00                load.sp(+4)
	<.main+6319 @052896> : 20                         load.i8
	<.main+6320 @052897> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@052898> - <@05289e>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6321 @052898> : 0a 08 00 00                load.sp(+8)
	<.main+6325 @05289c> : 20                         load.i8
	<.main+6326 @05289d> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@05289e> - <@0528a9>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6327 @05289e> : 0a 10 00 00                load.sp(+16)
	<.main+6331 @0528a2> : 20                         load.i8
	<.main+6332 @0528a3> : 0a 10 00 00                load.sp(+16)
	<.main+6336 @0528a7> : 20                         load.i8
	<.main+6337 @0528a8> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@0528a9> - <@0528b4>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6338 @0528a9> : 0a 14 00 00                load.sp(+20)
	<.main+6342 @0528ad> : 20                         load.i8
	<.main+6343 @0528ae> : 0a 14 00 00                load.sp(+20)
	<.main+6347 @0528b2> : 20                         load.i8
	<.main+6348 @0528b3> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@0528b4> - <@0528bf>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6349 @0528b4> : 0a 18 00 00                load.sp(+24)
	<.main+6353 @0528b8> : 20                         load.i8
	<.main+6354 @0528b9> : 0a 18 00 00                load.sp(+24)
	<.main+6358 @0528bd> : 20                         load.i8
	<.main+6359 @0528be> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@0528bf> - <@0528ca>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6360 @0528bf> : 0a 1c 00 00                load.sp(+28)
	<.main+6364 @0528c3> : 20                         load.i8
	<.main+6365 @0528c4> : 0a 1c 00 00                load.sp(+28)
	<.main+6369 @0528c8> : 20                         load.i8
	<.main+6370 @0528c9> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@0528ca> - <@0528d5>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6371 @0528ca> : 0a 20 00 00                load.sp(+32)
	<.main+6375 @0528ce> : 20                         load.i8
	<.main+6376 @0528cf> : 0a 20 00 00                load.sp(+32)
	<.main+6380 @0528d3> : 20                         load.i8
	<.main+6381 @0528d4> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@0528d5> - <@0528e0>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6382 @0528d5> : 0a 24 00 00                load.sp(+36)
	<.main+6386 @0528d9> : 20                         load.i8
	<.main+6387 @0528da> : 0a 24 00 00                load.sp(+36)
	<.main+6391 @0528de> : 20                         load.i8
	<.main+6392 @0528df> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@0528e0> - <@0528eb>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6393 @0528e0> : 0a 28 00 00                load.sp(+40)
	<.main+6397 @0528e4> : 20                         load.i8
	<.main+6398 @0528e5> : 0a 28 00 00                load.sp(+40)
	<.main+6402 @0528e9> : 20                         load.i8
	<.main+6403 @0528ea> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@0528eb> - <@0528f6>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6404 @0528eb> : 0a 2c 00 00                load.sp(+44)
	<.main+6408 @0528ef> : 20                         load.i8
	<.main+6409 @0528f0> : 0a 2c 00 00                load.sp(+44)
	<.main+6413 @0528f4> : 20                         load.i8
	<.main+6414 @0528f5> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@0528f6> - <@0528fe>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6415 @0528f6> : 0a 30 00 00                load.sp(+48)
	<.main+6419 @0528fa> : 20                         load.i8
	<.main+6420 @0528fb> : 10 46                      dup.x1 sp(70)
	<.main+6422 @0528fd> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@0528fe> - <@052906>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6423 @0528fe> : 0a 34 00 00                load.sp(+52)
	<.main+6427 @052902> : 20                         load.i8
	<.main+6428 @052903> : 10 47                      dup.x1 sp(71)
	<.main+6430 @052905> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@052906> - <@05290d>): u8Not: bool := bool(!(u8B))
	<.main+6431 @052906> : 0a 34 00 00                load.sp(+52)
	<.main+6435 @05290a> : 20                         load.i8
	<.main+6436 @05290b> : 5a                         i32.2bool
	<.main+6437 @05290c> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@05290d> - <@052918>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6438 @05290d> : 0a 3c 00 00                load.sp(+60)
	<.main+6442 @052911> : 20                         load.i8
	<.main+6443 @052912> : 0a 3c 00 00                load.sp(+60)
	<.main+6447 @052916> : 20                         load.i8
	<.main+6448 @052917> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@052918> - <@052924>): u8Cne: bool := bool(u8A != u8B)
	<.main+6449 @052918> : 0a 40 00 00                load.sp(+64)
	<.main+6453 @05291c> : 20                         load.i8
	<.main+6454 @05291d> : 0a 40 00 00                load.sp(+64)
	<.main+6458 @052921> : 20                         load.i8
	<.main+6459 @052922> : 57                         ceq.i32
	<.main+6460 @052923> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@052924> - <@05292f>): u8Clt: bool := bool(u8A < u8B)
	<.main+6461 @052924> : 0a 44 00 00                load.sp(+68)
	<.main+6465 @052928> : 20                         load.i8
	<.main+6466 @052929> : 0a 44 00 00                load.sp(+68)
	<.main+6470 @05292d> : 20                         load.i8
	<.main+6471 @05292e> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@05292f> - <@05293b>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6472 @05292f> : 0a 48 00 00                load.sp(+72)
	<.main+6476 @052933> : 20                         load.i8
	<.main+6477 @052934> : 0a 48 00 00                load.sp(+72)
	<.main+6481 @052938> : 20                         load.i8
	<.main+6482 @052939> : 39                         cgt.u32
	<.main+6483 @05293a> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@05293b> - <@052946>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6484 @05293b> : 0a 4c 00 00                load.sp(+76)
	<.main+6488 @05293f> : 20                         load.i8
	<.main+6489 @052940> : 0a 4c 00 00                load.sp(+76)
	<.main+6493 @052944> : 20                         load.i8
	<.main+6494 @052945> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@052946> - <@052952>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6495 @052946> : 0a 50 00 00                load.sp(+80)
	<.main+6499 @05294a> : 20                         load.i8
	<.main+6500 @05294b> : 0a 50 00 00                load.sp(+80)
	<.main+6504 @05294f> : 20                         load.i8
	<.main+6505 @052950> : 38                         clt.u32
	<.main+6506 @052951> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@052952> - <@052957>): i16A: int16 := a
	<.main+6507 @052952> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@052957> - <@05295c>): i16B: int16 := b
	<.main+6512 @052957> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@05295c> - <@052961>): i16Pls: int16 := int16(+i16B)
	<.main+6517 @05295c> : 0a 00 00 00                load.sp(+0)
	<.main+6521 @052960> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@052961> - <@052967>): i16Neg: int16 := int16(-i16B)
	<.main+6522 @052961> : 0a 04 00 00                load.sp(+4)
	<.main+6526 @052965> : 21                         load.i16
	<.main+6527 @052966> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@052967> - <@05296d>): i16Cmt: int16 := int16(~i16B)
	<.main+6528 @052967> : 0a 08 00 00                load.sp(+8)
	<.main+6532 @05296b> : 21                         load.i16
	<.main+6533 @05296c> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@05296d> - <@052978>): i16Add: int16 := int16(i16A + i16B)
	<.main+6534 @05296d> : 0a 10 00 00                load.sp(+16)
	<.main+6538 @052971> : 21                         load.i16
	<.main+6539 @052972> : 0a 10 00 00                load.sp(+16)
	<.main+6543 @052976> : 21                         load.i16
	<.main+6544 @052977> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@052978> - <@052983>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6545 @052978> : 0a 14 00 00                load.sp(+20)
	<.main+6549 @05297c> : 21                         load.i16
	<.main+6550 @05297d> : 0a 14 00 00                load.sp(+20)
	<.main+6554 @052981> : 21                         load.i16
	<.main+6555 @052982> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@052983> - <@05298e>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6556 @052983> : 0a 18 00 00                load.sp(+24)
	<.main+6560 @052987> : 21                         load.i16
	<.main+6561 @052988> : 0a 18 00 00                load.sp(+24)
	<.main+6565 @05298c> : 21                         load.i16
	<.main+6566 @05298d> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@05298e> - <@052999>): i16Div: int16 := int16(i16A / i16B)
	<.main+6567 @05298e> : 0a 1c 00 00                load.sp(+28)
	<.main+6571 @052992> : 21                         load.i16
	<.main+6572 @052993> : 0a 1c 00 00                load.sp(+28)
	<.main+6576 @052997> : 21                         load.i16
	<.main+6577 @052998> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@052999> - <@0529a4>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6578 @052999> : 0a 20 00 00                load.sp(+32)
	<.main+6582 @05299d> : 21                         load.i16
	<.main+6583 @05299e> : 0a 20 00 00                load.sp(+32)
	<.main+6587 @0529a2> : 21                         load.i16
	<.main+6588 @0529a3> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@0529a4> - <@0529af>): i16And: int16 := int16(i16A & i16B)
	<.main+6589 @0529a4> : 0a 24 00 00                load.sp(+36)
	<.main+6593 @0529a8> : 21                         load.i16
	<.main+6594 @0529a9> : 0a 24 00 00                load.sp(+36)
	<.main+6598 @0529ad> : 21                         load.i16
	<.main+6599 @0529ae> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@0529af> - <@0529ba>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6600 @0529af> : 0a 28 00 00                load.sp(+40)
	<.main+6604 @0529b3> : 21                         load.i16
	<.main+6605 @0529b4> : 0a 28 00 00                load.sp(+40)
	<.main+6609 @0529b8> : 21                         load.i16
	<.main+6610 @0529b9> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@0529ba> - <@0529c5>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6611 @0529ba> : 0a 2c 00 00                load.sp(+44)
	<.main+6615 @0529be> : 21                         load.i16
	<.main+6616 @0529bf> : 0a 2c 00 00                load.sp(+44)
	<.main+6620 @0529c3> : 21                         load.i16
	<.main+6621 @0529c4> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@0529c5> - <@0529cd>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6622 @0529c5> : 0a 30 00 00                load.sp(+48)
	<.main+6626 @0529c9> : 21                         load.i16
	<.main+6627 @0529ca> : 10 5c                      dup.x1 sp(92)
	<.main+6629 @0529cc> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@0529cd> - <@0529d5>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6630 @0529cd> : 0a 34 00 00                load.sp(+52)
	<.main+6634 @0529d1> : 21                         load.i16
	<.main+6635 @0529d2> : 10 5d                      dup.x1 sp(93)
	<.main+6637 @0529d4> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@0529d5> - <@0529dc>): i16Not: bool := bool(!(i16B))
	<.main+6638 @0529d5> : 0a 34 00 00                load.sp(+52)
	<.main+6642 @0529d9> : 21                         load.i16
	<.main+6643 @0529da> : 5a                         i32.2bool
	<.main+6644 @0529db> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@0529dc> - <@0529e7>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6645 @0529dc> : 0a 3c 00 00                load.sp(+60)
	<.main+6649 @0529e0> : 21                         load.i16
	<.main+6650 @0529e1> : 0a 3c 00 00                load.sp(+60)
	<.main+6654 @0529e5> : 21                         load.i16
	<.main+6655 @0529e6> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@0529e7> - <@0529f3>): i16Cne: bool := bool(i16A != i16B)
	<.main+6656 @0529e7> : 0a 40 00 00                load.sp(+64)
	<.main+6660 @0529eb> : 21                         load.i16
	<.main+6661 @0529ec> : 0a 40 00 00                load.sp(+64)
	<.main+6665 @0529f0> : 21                         load.i16
	<.main+6666 @0529f1> : 57                         ceq.i32
	<.main+6667 @0529f2> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@0529f3> - <@0529fe>): i16Clt: bool := bool(i16A < i16B)
	<.main+6668 @0529f3> : 0a 44 00 00                load.sp(+68)
	<.main+6672 @0529f7> : 21                         load.i16
	<.main+6673 @0529f8> : 0a 44 00 00                load.sp(+68)
	<.main+6677 @0529fc> : 21                         load.i16
	<.main+6678 @0529fd> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@0529fe> - <@052a0a>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6679 @0529fe> : 0a 48 00 00                load.sp(+72)
	<.main+6683 @052a02> : 21                         load.i16
	<.main+6684 @052a03> : 0a 48 00 00                load.sp(+72)
	<.main+6688 @052a07> : 21                         load.i16
	<.main+6689 @052a08> : 59                         cgt.i32
	<.main+6690 @052a09> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@052a0a> - <@052a15>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6691 @052a0a> : 0a 4c 00 00                load.sp(+76)
	<.main+6695 @052a0e> : 21                         load.i16
	<.main+6696 @052a0f> : 0a 4c 00 00                load.sp(+76)
	<.main+6700 @052a13> : 21                         load.i16
	<.main+6701 @052a14> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@052a15> - <@052a21>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6702 @052a15> : 0a 50 00 00                load.sp(+80)
	<.main+6706 @052a19> : 21                         load.i16
	<.main+6707 @052a1a> : 0a 50 00 00                load.sp(+80)
	<.main+6711 @052a1e> : 21                         load.i16
	<.main+6712 @052a1f> : 58                         clt.i32
	<.main+6713 @052a20> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@052a21> - <@052a26>): u16A: uint16 := a
	<.main+6714 @052a21> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@052a26> - <@052a2b>): u16B: uint16 := b
	<.main+6719 @052a26> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@052a2b> - <@052a30>): u16Pls: uint16 := uint16(+u16B)
	<.main+6724 @052a2b> : 0a 00 00 00                load.sp(+0)
	<.main+6728 @052a2f> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@052a30> - <@052a36>): u16Neg: uint16 := uint16(-u16B)
	<.main+6729 @052a30> : 0a 04 00 00                load.sp(+4)
	<.main+6733 @052a34> : 21                         load.i16
	<.main+6734 @052a35> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@052a36> - <@052a3c>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6735 @052a36> : 0a 08 00 00                load.sp(+8)
	<.main+6739 @052a3a> : 21                         load.i16
	<.main+6740 @052a3b> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@052a3c> - <@052a47>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6741 @052a3c> : 0a 10 00 00                load.sp(+16)
	<.main+6745 @052a40> : 21                         load.i16
	<.main+6746 @052a41> : 0a 10 00 00                load.sp(+16)
	<.main+6750 @052a45> : 21                         load.i16
	<.main+6751 @052a46> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@052a47> - <@052a52>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6752 @052a47> : 0a 14 00 00                load.sp(+20)
	<.main+6756 @052a4b> : 21                         load.i16
	<.main+6757 @052a4c> : 0a 14 00 00                load.sp(+20)
	<.main+6761 @052a50> : 21                         load.i16
	<.main+6762 @052a51> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@052a52> - <@052a5d>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6763 @052a52> : 0a 18 00 00                load.sp(+24)
	<.main+6767 @052a56> : 21                         load.i16
	<.main+6768 @052a57> : 0a 18 00 00                load.sp(+24)
	<.main+6772 @052a5b> : 21                         load.i16
	<.main+6773 @052a5c> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@052a5d> - <@052a68>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6774 @052a5d> : 0a 1c 00 00                load.sp(+28)
	<.main+6778 @052a61> : 21                         load.i16
	<.main+6779 @052a62> : 0a 1c 00 00                load.sp(+28)
	<.main+6783 @052a66> : 21                         load.i16
	<.main+6784 @052a67> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@052a68> - <@052a73>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6785 @052a68> : 0a 20 00 00                load.sp(+32)
	<.main+6789 @052a6c> : 21                         load.i16
	<.main+6790 @052a6d> : 0a 20 00 00                load.sp(+32)
	<.main+6794 @052a71> : 21                         load.i16
	<.main+6795 @052a72> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@052a73> - <@052a7e>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6796 @052a73> : 0a 24 00 00                load.sp(+36)
	<.main+6800 @052a77> : 21                         load.i16
	<.main+6801 @052a78> : 0a 24 00 00                load.sp(+36)
	<.main+6805 @052a7c> : 21                         load.i16
	<.main+6806 @052a7d> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@052a7e> - <@052a89>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6807 @052a7e> : 0a 28 00 00                load.sp(+40)
	<.main+6811 @052a82> : 21                         load.i16
	<.main+6812 @052a83> : 0a 28 00 00                load.sp(+40)
	<.main+6816 @052a87> : 21                         load.i16
	<.main+6817 @052a88> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@052a89> - <@052a94>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6818 @052a89> : 0a 2c 00 00                load.sp(+44)
	<.main+6822 @052a8d> : 21                         load.i16
	<.main+6823 @052a8e> : 0a 2c 00 00                load.sp(+44)
	<.main+6827 @052a92> : 21                         load.i16
	<.main+6828 @052a93> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@052a94> - <@052a9c>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6829 @052a94> : 0a 30 00 00                load.sp(+48)
	<.main+6833 @052a98> : 21                         load.i16
	<.main+6834 @052a99> : 10 72                      dup.x1 sp(114)
	<.main+6836 @052a9b> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@052a9c> - <@052aa4>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6837 @052a9c> : 0a 34 00 00                load.sp(+52)
	<.main+6841 @052aa0> : 21                         load.i16
	<.main+6842 @052aa1> : 10 73                      dup.x1 sp(115)
	<.main+6844 @052aa3> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@052aa4> - <@052aab>): u16Not: bool := bool(!(u16B))
	<.main+6845 @052aa4> : 0a 34 00 00                load.sp(+52)
	<.main+6849 @052aa8> : 21                         load.i16
	<.main+6850 @052aa9> : 5a                         i32.2bool
	<.main+6851 @052aaa> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@052aab> - <@052ab6>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6852 @052aab> : 0a 3c 00 00                load.sp(+60)
	<.main+6856 @052aaf> : 21                         load.i16
	<.main+6857 @052ab0> : 0a 3c 00 00                load.sp(+60)
	<.main+6861 @052ab4> : 21                         load.i16
	<.main+6862 @052ab5> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@052ab6> - <@052ac2>): u16Cne: bool := bool(u16A != u16B)
	<.main+6863 @052ab6> : 0a 40 00 00                load.sp(+64)
	<.main+6867 @052aba> : 21                         load.i16
	<.main+6868 @052abb> : 0a 40 00 00                load.sp(+64)
	<.main+6872 @052abf> : 21                         load.i16
	<.main+6873 @052ac0> : 57                         ceq.i32
	<.main+6874 @052ac1> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@052ac2> - <@052acd>): u16Clt: bool := bool(u16A < u16B)
	<.main+6875 @052ac2> : 0a 44 00 00                load.sp(+68)
	<.main+6879 @052ac6> : 21                         load.i16
	<.main+6880 @052ac7> : 0a 44 00 00                load.sp(+68)
	<.main+6884 @052acb> : 21                         load.i16
	<.main+6885 @052acc> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@052acd> - <@052ad9>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6886 @052acd> : 0a 48 00 00                load.sp(+72)
	<.main+6890 @052ad1> : 21                         load.i16
	<.main+6891 @052ad2> : 0a 48 00 00                load.sp(+72)
	<.main+6895 @052ad6> : 21                         load.i16
	<.main+6896 @052ad7> : 39                         cgt.u32
	<.main+6897 @052ad8> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@052ad9> - <@052ae4>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6898 @052ad9> : 0a 4c 00 00                load.sp(+76)
	<.main+6902 @052add> : 21                         load.i16
	<.main+6903 @052ade> : 0a 4c 00 00                load.sp(+76)
	<.main+6907 @052ae2> : 21                         load.i16
	<.main+6908 @052ae3> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@052ae4> - <@052af0>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6909 @052ae4> : 0a 50 00 00                load.sp(+80)
	<.main+6913 @052ae8> : 21                         load.i16
	<.main+6914 @052ae9> : 0a 50 00 00                load.sp(+80)
	<.main+6918 @052aed> : 21                         load.i16
	<.main+6919 @052aee> : 38                         clt.u32
	<.main+6920 @052aef> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@052af0> - <@052af5>): i32A: int32 := a
	<.main+6921 @052af0> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@052af5> - <@052afa>): i32B: int32 := b
	<.main+6926 @052af5> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@052afa> - <@052afc>): i32Pls: int32 := int32(+i32B)
	<.main+6931 @052afa> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@052afc> - <@052aff>): i32Neg: int32 := int32(-i32B)
	<.main+6933 @052afc> : 10 01                      dup.x1 sp(1)
	<.main+6935 @052afe> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@052aff> - <@052b02>): i32Cmt: int32 := int32(~i32B)
	<.main+6936 @052aff> : 10 02                      dup.x1 sp(2)
	<.main+6938 @052b01> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@052b02> - <@052b07>): i32Add: int32 := int32(i32A + i32B)
	<.main+6939 @052b02> : 10 04                      dup.x1 sp(4)
	<.main+6941 @052b04> : 10 04                      dup.x1 sp(4)
	<.main+6943 @052b06> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@052b07> - <@052b0c>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6944 @052b07> : 10 05                      dup.x1 sp(5)
	<.main+6946 @052b09> : 10 05                      dup.x1 sp(5)
	<.main+6948 @052b0b> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@052b0c> - <@052b11>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6949 @052b0c> : 10 06                      dup.x1 sp(6)
	<.main+6951 @052b0e> : 10 06                      dup.x1 sp(6)
	<.main+6953 @052b10> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@052b11> - <@052b16>): i32Div: int32 := int32(i32A / i32B)
	<.main+6954 @052b11> : 10 07                      dup.x1 sp(7)
	<.main+6956 @052b13> : 10 07                      dup.x1 sp(7)
	<.main+6958 @052b15> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@052b16> - <@052b1b>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6959 @052b16> : 10 08                      dup.x1 sp(8)
	<.main+6961 @052b18> : 10 08                      dup.x1 sp(8)
	<.main+6963 @052b1a> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@052b1b> - <@052b20>): i32And: int32 := int32(i32A & i32B)
	<.main+6964 @052b1b> : 10 09                      dup.x1 sp(9)
	<.main+6966 @052b1d> : 10 09                      dup.x1 sp(9)
	<.main+6968 @052b1f> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@052b20> - <@052b25>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6969 @052b20> : 10 0a                      dup.x1 sp(10)
	<.main+6971 @052b22> : 10 0a                      dup.x1 sp(10)
	<.main+6973 @052b24> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@052b25> - <@052b2a>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6974 @052b25> : 10 0b                      dup.x1 sp(11)
	<.main+6976 @052b27> : 10 0b                      dup.x1 sp(11)
	<.main+6978 @052b29> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@052b2a> - <@052b2f>): i32Shl: int32 := int32(i32A << shift)
	<.main+6979 @052b2a> : 10 0c                      dup.x1 sp(12)
	<.main+6981 @052b2c> : 10 88                      dup.x1 sp(136)
	<.main+6983 @052b2e> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@052b2f> - <@052b34>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6984 @052b2f> : 10 0d                      dup.x1 sp(13)
	<.main+6986 @052b31> : 10 89                      dup.x1 sp(137)
	<.main+6988 @052b33> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@052b34> - <@052b38>): i32Not: bool := bool(!(i32B))
	<.main+6989 @052b34> : 10 0d                      dup.x1 sp(13)
	<.main+6991 @052b36> : 5a                         i32.2bool
	<.main+6992 @052b37> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@052b38> - <@052b3d>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6993 @052b38> : 10 0f                      dup.x1 sp(15)
	<.main+6995 @052b3a> : 10 0f                      dup.x1 sp(15)
	<.main+6997 @052b3c> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@052b3d> - <@052b43>): i32Cne: bool := bool(i32A != i32B)
	<.main+6998 @052b3d> : 10 10                      dup.x1 sp(16)
	<.main+7000 @052b3f> : 10 10                      dup.x1 sp(16)
	<.main+7002 @052b41> : 57                         ceq.i32
	<.main+7003 @052b42> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@052b43> - <@052b48>): i32Clt: bool := bool(i32A < i32B)
	<.main+7004 @052b43> : 10 11                      dup.x1 sp(17)
	<.main+7006 @052b45> : 10 11                      dup.x1 sp(17)
	<.main+7008 @052b47> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@052b48> - <@052b4e>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7009 @052b48> : 10 12                      dup.x1 sp(18)
	<.main+7011 @052b4a> : 10 12                      dup.x1 sp(18)
	<.main+7013 @052b4c> : 59                         cgt.i32
	<.main+7014 @052b4d> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@052b4e> - <@052b53>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7015 @052b4e> : 10 13                      dup.x1 sp(19)
	<.main+7017 @052b50> : 10 13                      dup.x1 sp(19)
	<.main+7019 @052b52> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@052b53> - <@052b59>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7020 @052b53> : 10 14                      dup.x1 sp(20)
	<.main+7022 @052b55> : 10 14                      dup.x1 sp(20)
	<.main+7024 @052b57> : 58                         clt.i32
	<.main+7025 @052b58> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@052b59> - <@052b5e>): u32A: uint32 := a
	<.main+7026 @052b59> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@052b5e> - <@052b63>): u32B: uint32 := b
	<.main+7031 @052b5e> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@052b63> - <@052b65>): u32Pls: uint32 := uint32(+u32B)
	<.main+7036 @052b63> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@052b65> - <@052b68>): u32Neg: uint32 := uint32(-u32B)
	<.main+7038 @052b65> : 10 01                      dup.x1 sp(1)
	<.main+7040 @052b67> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@052b68> - <@052b6b>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7041 @052b68> : 10 02                      dup.x1 sp(2)
	<.main+7043 @052b6a> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@052b6b> - <@052b70>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7044 @052b6b> : 10 04                      dup.x1 sp(4)
	<.main+7046 @052b6d> : 10 04                      dup.x1 sp(4)
	<.main+7048 @052b6f> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@052b70> - <@052b75>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7049 @052b70> : 10 05                      dup.x1 sp(5)
	<.main+7051 @052b72> : 10 05                      dup.x1 sp(5)
	<.main+7053 @052b74> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@052b75> - <@052b7a>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7054 @052b75> : 10 06                      dup.x1 sp(6)
	<.main+7056 @052b77> : 10 06                      dup.x1 sp(6)
	<.main+7058 @052b79> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@052b7a> - <@052b7f>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7059 @052b7a> : 10 07                      dup.x1 sp(7)
	<.main+7061 @052b7c> : 10 07                      dup.x1 sp(7)
	<.main+7063 @052b7e> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@052b7f> - <@052b84>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7064 @052b7f> : 10 08                      dup.x1 sp(8)
	<.main+7066 @052b81> : 10 08                      dup.x1 sp(8)
	<.main+7068 @052b83> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@052b84> - <@052b89>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7069 @052b84> : 10 09                      dup.x1 sp(9)
	<.main+7071 @052b86> : 10 09                      dup.x1 sp(9)
	<.main+7073 @052b88> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@052b89> - <@052b8e>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7074 @052b89> : 10 0a                      dup.x1 sp(10)
	<.main+7076 @052b8b> : 10 0a                      dup.x1 sp(10)
	<.main+7078 @052b8d> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@052b8e> - <@052b93>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7079 @052b8e> : 10 0b                      dup.x1 sp(11)
	<.main+7081 @052b90> : 10 0b                      dup.x1 sp(11)
	<.main+7083 @052b92> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@052b93> - <@052b98>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7084 @052b93> : 10 0c                      dup.x1 sp(12)
	<.main+7086 @052b95> : 10 9e                      dup.x1 sp(158)
	<.main+7088 @052b97> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@052b98> - <@052b9d>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7089 @052b98> : 10 0d                      dup.x1 sp(13)
	<.main+7091 @052b9a> : 10 9f                      dup.x1 sp(159)
	<.main+7093 @052b9c> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@052b9d> - <@052ba1>): u32Not: bool := bool(!(u32B))
	<.main+7094 @052b9d> : 10 0d                      dup.x1 sp(13)
	<.main+7096 @052b9f> : 5a                         i32.2bool
	<.main+7097 @052ba0> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@052ba1> - <@052ba6>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7098 @052ba1> : 10 0f                      dup.x1 sp(15)
	<.main+7100 @052ba3> : 10 0f                      dup.x1 sp(15)
	<.main+7102 @052ba5> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@052ba6> - <@052bac>): u32Cne: bool := bool(u32A != u32B)
	<.main+7103 @052ba6> : 10 10                      dup.x1 sp(16)
	<.main+7105 @052ba8> : 10 10                      dup.x1 sp(16)
	<.main+7107 @052baa> : 57                         ceq.i32
	<.main+7108 @052bab> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@052bac> - <@052bb1>): u32Clt: bool := bool(u32A < u32B)
	<.main+7109 @052bac> : 10 11                      dup.x1 sp(17)
	<.main+7111 @052bae> : 10 11                      dup.x1 sp(17)
	<.main+7113 @052bb0> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@052bb1> - <@052bb7>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7114 @052bb1> : 10 12                      dup.x1 sp(18)
	<.main+7116 @052bb3> : 10 12                      dup.x1 sp(18)
	<.main+7118 @052bb5> : 39                         cgt.u32
	<.main+7119 @052bb6> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@052bb7> - <@052bbc>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7120 @052bb7> : 10 13                      dup.x1 sp(19)
	<.main+7122 @052bb9> : 10 13                      dup.x1 sp(19)
	<.main+7124 @052bbb> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@052bbc> - <@052bc2>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7125 @052bbc> : 10 14                      dup.x1 sp(20)
	<.main+7127 @052bbe> : 10 14                      dup.x1 sp(20)
	<.main+7129 @052bc0> : 38                         clt.u32
	<.main+7130 @052bc1> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@052bc2> - <@052bcb>): i64A: int64 := a
	<.main+7131 @052bc2> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@052bcb> - <@052bd4>): i64B: int64 := b
	<.main+7140 @052bcb> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@052bd4> - <@052bd6>): i64Pls: int64 := int64(+i64B)
	<.main+7149 @052bd4> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@052bd6> - <@052bd9>): i64Neg: int64 := int64(-i64B)
	<.main+7151 @052bd6> : 11 02                      dup.x2 sp(2)
	<.main+7153 @052bd8> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@052bd9> - <@052bdc>): i64Cmt: int64 := int64(~i64B)
	<.main+7154 @052bd9> : 11 04                      dup.x2 sp(4)
	<.main+7156 @052bdb> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@052bdc> - <@052be1>): i64Add: int64 := int64(i64A + i64B)
	<.main+7157 @052bdc> : 11 08                      dup.x2 sp(8)
	<.main+7159 @052bde> : 11 08                      dup.x2 sp(8)
	<.main+7161 @052be0> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@052be1> - <@052be6>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7162 @052be1> : 11 0a                      dup.x2 sp(10)
	<.main+7164 @052be3> : 11 0a                      dup.x2 sp(10)
	<.main+7166 @052be5> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@052be6> - <@052beb>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7167 @052be6> : 11 0c                      dup.x2 sp(12)
	<.main+7169 @052be8> : 11 0c                      dup.x2 sp(12)
	<.main+7171 @052bea> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@052beb> - <@052bf0>): i64Div: int64 := int64(i64A / i64B)
	<.main+7172 @052beb> : 11 0e                      dup.x2 sp(14)
	<.main+7174 @052bed> : 11 0e                      dup.x2 sp(14)
	<.main+7176 @052bef> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@052bf0> - <@052bf5>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7177 @052bf0> : 11 10                      dup.x2 sp(16)
	<.main+7179 @052bf2> : 11 10                      dup.x2 sp(16)
	<.main+7181 @052bf4> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@052bf5> - <@052bfa>): i64And: int64 := int64(i64A & i64B)
	<.main+7182 @052bf5> : 11 12                      dup.x2 sp(18)
	<.main+7184 @052bf7> : 11 12                      dup.x2 sp(18)
	<.main+7186 @052bf9> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@052bfa> - <@052bff>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7187 @052bfa> : 11 14                      dup.x2 sp(20)
	<.main+7189 @052bfc> : 11 14                      dup.x2 sp(20)
	<.main+7191 @052bfe> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@052bff> - <@052c04>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7192 @052bff> : 11 16                      dup.x2 sp(22)
	<.main+7194 @052c01> : 11 16                      dup.x2 sp(22)
	<.main+7196 @052c03> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@052c04> - <@052c09>): i64Shl: int64 := int64(i64A << shift)
	<.main+7197 @052c04> : 11 18                      dup.x2 sp(24)
	<.main+7199 @052c06> : 10 c2                      dup.x1 sp(194)
	<.main+7201 @052c08> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@052c09> - <@052c0e>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7202 @052c09> : 11 1a                      dup.x2 sp(26)
	<.main+7204 @052c0b> : 10 c4                      dup.x1 sp(196)
	<.main+7206 @052c0d> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@052c0e> - <@052c12>): i64Not: bool := bool(!(i64B))
	<.main+7207 @052c0e> : 11 1a                      dup.x2 sp(26)
	<.main+7209 @052c10> : 6c                         i64.2bool
	<.main+7210 @052c11> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@052c12> - <@052c17>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7211 @052c12> : 11 1d                      dup.x2 sp(29)
	<.main+7213 @052c14> : 11 1d                      dup.x2 sp(29)
	<.main+7215 @052c16> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@052c17> - <@052c1d>): i64Cne: bool := bool(i64A != i64B)
	<.main+7216 @052c17> : 11 1e                      dup.x2 sp(30)
	<.main+7218 @052c19> : 11 1e                      dup.x2 sp(30)
	<.main+7220 @052c1b> : 67                         ceq.i64
	<.main+7221 @052c1c> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@052c1d> - <@052c22>): i64Clt: bool := bool(i64A < i64B)
	<.main+7222 @052c1d> : 11 1f                      dup.x2 sp(31)
	<.main+7224 @052c1f> : 11 1f                      dup.x2 sp(31)
	<.main+7226 @052c21> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@052c22> - <@052c28>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7227 @052c22> : 11 20                      dup.x2 sp(32)
	<.main+7229 @052c24> : 11 20                      dup.x2 sp(32)
	<.main+7231 @052c26> : 69                         cgt.i64
	<.main+7232 @052c27> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@052c28> - <@052c2d>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7233 @052c28> : 11 21                      dup.x2 sp(33)
	<.main+7235 @052c2a> : 11 21                      dup.x2 sp(33)
	<.main+7237 @052c2c> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@052c2d> - <@052c33>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7238 @052c2d> : 11 22                      dup.x2 sp(34)
	<.main+7240 @052c2f> : 11 22                      dup.x2 sp(34)
	<.main+7242 @052c31> : 68                         clt.i64
	<.main+7243 @052c32> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@052c33> - <@052c3c>): u64A: uint64 := a
	<.main+7244 @052c33> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@052c3c> - <@052c45>): u64B: uint64 := b
	<.main+7253 @052c3c> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@052c45> - <@052c47>): u64Pls: uint64 := uint64(+u64B)
	<.main+7262 @052c45> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@052c47> - <@052c4a>): u64Neg: uint64 := uint64(-u64B)
	<.main+7264 @052c47> : 11 02                      dup.x2 sp(2)
	<.main+7266 @052c49> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@052c4a> - <@052c4d>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7267 @052c4a> : 11 04                      dup.x2 sp(4)
	<.main+7269 @052c4c> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@052c4d> - <@052c52>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7270 @052c4d> : 11 08                      dup.x2 sp(8)
	<.main+7272 @052c4f> : 11 08                      dup.x2 sp(8)
	<.main+7274 @052c51> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@052c52> - <@052c57>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7275 @052c52> : 11 0a                      dup.x2 sp(10)
	<.main+7277 @052c54> : 11 0a                      dup.x2 sp(10)
	<.main+7279 @052c56> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@052c57> - <@052c5c>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7280 @052c57> : 11 0c                      dup.x2 sp(12)
	<.main+7282 @052c59> : 11 0c                      dup.x2 sp(12)
	<.main+7284 @052c5b> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@052c5c> - <@052c61>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7285 @052c5c> : 11 0e                      dup.x2 sp(14)
	<.main+7287 @052c5e> : 11 0e                      dup.x2 sp(14)
	<.main+7289 @052c60> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@052c61> - <@052c66>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7290 @052c61> : 11 10                      dup.x2 sp(16)
	<.main+7292 @052c63> : 11 10                      dup.x2 sp(16)
	<.main+7294 @052c65> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@052c66> - <@052c6b>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7295 @052c66> : 11 12                      dup.x2 sp(18)
	<.main+7297 @052c68> : 11 12                      dup.x2 sp(18)
	<.main+7299 @052c6a> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@052c6b> - <@052c70>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7300 @052c6b> : 11 14                      dup.x2 sp(20)
	<.main+7302 @052c6d> : 11 14                      dup.x2 sp(20)
	<.main+7304 @052c6f> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@052c70> - <@052c75>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7305 @052c70> : 11 16                      dup.x2 sp(22)
	<.main+7307 @052c72> : 11 16                      dup.x2 sp(22)
	<.main+7309 @052c74> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@052c75> - <@052c7a>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7310 @052c75> : 11 18                      dup.x2 sp(24)
	<.main+7312 @052c77> : 10 e7                      dup.x1 sp(231)
	<.main+7314 @052c79> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@052c7a> - <@052c7f>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7315 @052c7a> : 11 1a                      dup.x2 sp(26)
	<.main+7317 @052c7c> : 10 e9                      dup.x1 sp(233)
	<.main+7319 @052c7e> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@052c7f> - <@052c83>): u64Not: bool := bool(!(u64B))
	<.main+7320 @052c7f> : 11 1a                      dup.x2 sp(26)
	<.main+7322 @052c81> : 6c                         i64.2bool
	<.main+7323 @052c82> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@052c83> - <@052c88>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7324 @052c83> : 11 1d                      dup.x2 sp(29)
	<.main+7326 @052c85> : 11 1d                      dup.x2 sp(29)
	<.main+7328 @052c87> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@052c88> - <@052c8e>): u64Cne: bool := bool(u64A != u64B)
	<.main+7329 @052c88> : 11 1e                      dup.x2 sp(30)
	<.main+7331 @052c8a> : 11 1e                      dup.x2 sp(30)
	<.main+7333 @052c8c> : 67                         ceq.i64
	<.main+7334 @052c8d> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@052c8e> - <@052c93>): u64Clt: bool := bool(u64A < u64B)
	<.main+7335 @052c8e> : 11 1f                      dup.x2 sp(31)
	<.main+7337 @052c90> : 11 1f                      dup.x2 sp(31)
	<.main+7339 @052c92> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@052c93> - <@052c99>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7340 @052c93> : 11 20                      dup.x2 sp(32)
	<.main+7342 @052c95> : 11 20                      dup.x2 sp(32)
	<.main+7344 @052c97> : 49                         cgt.u64
	<.main+7345 @052c98> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@052c99> - <@052c9e>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7346 @052c99> : 11 21                      dup.x2 sp(33)
	<.main+7348 @052c9b> : 11 21                      dup.x2 sp(33)
	<.main+7350 @052c9d> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@052c9e> - <@052ca4>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7351 @052c9e> : 11 22                      dup.x2 sp(34)
	<.main+7353 @052ca0> : 11 22                      dup.x2 sp(34)
	<.main+7355 @052ca2> : 48                         clt.u64
	<.main+7356 @052ca3> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@052ca4> - <@052ca9>): f32A: float32 := a
	<.main+7357 @052ca4> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@052ca9> - <@052cae>): f32B: float32 := b
	<.main+7362 @052ca9> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@052cae> - <@052cb0>): f32Pls: float32 := float32(+f32B)
	<.main+7367 @052cae> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@052cb0> - <@052cb3>): f32Neg: float32 := float32(-f32B)
	<.main+7369 @052cb0> : 10 01                      dup.x1 sp(1)
	<.main+7371 @052cb2> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@052cb3> - <@052cb8>): f32Add: float32 := float32(f32A + f32B)
	<.main+7372 @052cb3> : 10 03                      dup.x1 sp(3)
	<.main+7374 @052cb5> : 10 03                      dup.x1 sp(3)
	<.main+7376 @052cb7> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@052cb8> - <@052cbd>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7377 @052cb8> : 10 04                      dup.x1 sp(4)
	<.main+7379 @052cba> : 10 04                      dup.x1 sp(4)
	<.main+7381 @052cbc> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@052cbd> - <@052cc2>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7382 @052cbd> : 10 05                      dup.x1 sp(5)
	<.main+7384 @052cbf> : 10 05                      dup.x1 sp(5)
	<.main+7386 @052cc1> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@052cc2> - <@052cc7>): f32Div: float32 := float32(f32A / f32B)
	<.main+7387 @052cc2> : 10 06                      dup.x1 sp(6)
	<.main+7389 @052cc4> : 10 06                      dup.x1 sp(6)
	<.main+7391 @052cc6> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@052cc7> - <@052ccc>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7392 @052cc7> : 10 07                      dup.x1 sp(7)
	<.main+7394 @052cc9> : 10 07                      dup.x1 sp(7)
	<.main+7396 @052ccb> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@052ccc> - <@052cd0>): f32Not: bool := bool(!(f32B))
	<.main+7397 @052ccc> : 10 07                      dup.x1 sp(7)
	<.main+7399 @052cce> : 7b                         f32.2bool
	<.main+7400 @052ccf> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@052cd0> - <@052cd5>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7401 @052cd0> : 10 09                      dup.x1 sp(9)
	<.main+7403 @052cd2> : 10 09                      dup.x1 sp(9)
	<.main+7405 @052cd4> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@052cd5> - <@052cdb>): f32Cne: bool := bool(f32A != f32B)
	<.main+7406 @052cd5> : 10 0a                      dup.x1 sp(10)
	<.main+7408 @052cd7> : 10 0a                      dup.x1 sp(10)
	<.main+7410 @052cd9> : 77                         ceq.f32
	<.main+7411 @052cda> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@052cdb> - <@052ce0>): f32Clt: bool := bool(f32A < f32B)
	<.main+7412 @052cdb> : 10 0b                      dup.x1 sp(11)
	<.main+7414 @052cdd> : 10 0b                      dup.x1 sp(11)
	<.main+7416 @052cdf> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@052ce0> - <@052ce6>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7417 @052ce0> : 10 0c                      dup.x1 sp(12)
	<.main+7419 @052ce2> : 10 0c                      dup.x1 sp(12)
	<.main+7421 @052ce4> : 79                         cgt.f32
	<.main+7422 @052ce5> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@052ce6> - <@052ceb>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7423 @052ce6> : 10 0d                      dup.x1 sp(13)
	<.main+7425 @052ce8> : 10 0d                      dup.x1 sp(13)
	<.main+7427 @052cea> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@052ceb> - <@052cf1>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7428 @052ceb> : 10 0e                      dup.x1 sp(14)
	<.main+7430 @052ced> : 10 0e                      dup.x1 sp(14)
	<.main+7432 @052cef> : 78                         clt.f32
	<.main+7433 @052cf0> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@052cf1> - <@052cfa>): f64A: float64 := a
	<.main+7434 @052cf1> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@052cfa> - <@052d03>): f64B: float64 := b
	<.main+7443 @052cfa> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@052d03> - <@052d05>): f64Pls: float64 := float64(+f64B)
	<.main+7452 @052d03> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@052d05> - <@052d08>): f64Neg: float64 := float64(-f64B)
	<.main+7454 @052d05> : 11 02                      dup.x2 sp(2)
	<.main+7456 @052d07> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@052d08> - <@052d0d>): f64Add: float64 := float64(f64A + f64B)
	<.main+7457 @052d08> : 11 06                      dup.x2 sp(6)
	<.main+7459 @052d0a> : 11 06                      dup.x2 sp(6)
	<.main+7461 @052d0c> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@052d0d> - <@052d12>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7462 @052d0d> : 11 08                      dup.x2 sp(8)
	<.main+7464 @052d0f> : 11 08                      dup.x2 sp(8)
	<.main+7466 @052d11> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@052d12> - <@052d17>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7467 @052d12> : 11 0a                      dup.x2 sp(10)
	<.main+7469 @052d14> : 11 0a                      dup.x2 sp(10)
	<.main+7471 @052d16> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@052d17> - <@052d1c>): f64Div: float64 := float64(f64A / f64B)
	<.main+7472 @052d17> : 11 0c                      dup.x2 sp(12)
	<.main+7474 @052d19> : 11 0c                      dup.x2 sp(12)
	<.main+7476 @052d1b> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@052d1c> - <@052d21>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7477 @052d1c> : 11 0e                      dup.x2 sp(14)
	<.main+7479 @052d1e> : 11 0e                      dup.x2 sp(14)
	<.main+7481 @052d20> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@052d21> - <@052d25>): f64Not: bool := bool(!(f64B))
	<.main+7482 @052d21> : 11 0e                      dup.x2 sp(14)
	<.main+7484 @052d23> : 8d                         f64.2bool
	<.main+7485 @052d24> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@052d25> - <@052d2a>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7486 @052d25> : 11 11                      dup.x2 sp(17)
	<.main+7488 @052d27> : 11 11                      dup.x2 sp(17)
	<.main+7490 @052d29> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@052d2a> - <@052d30>): f64Cne: bool := bool(f64A != f64B)
	<.main+7491 @052d2a> : 11 12                      dup.x2 sp(18)
	<.main+7493 @052d2c> : 11 12                      dup.x2 sp(18)
	<.main+7495 @052d2e> : 87                         ceq.f64
	<.main+7496 @052d2f> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@052d30> - <@052d35>): f64Clt: bool := bool(f64A < f64B)
	<.main+7497 @052d30> : 11 13                      dup.x2 sp(19)
	<.main+7499 @052d32> : 11 13                      dup.x2 sp(19)
	<.main+7501 @052d34> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@052d35> - <@052d3b>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7502 @052d35> : 11 14                      dup.x2 sp(20)
	<.main+7504 @052d37> : 11 14                      dup.x2 sp(20)
	<.main+7506 @052d39> : 89                         cgt.f64
	<.main+7507 @052d3a> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@052d3b> - <@052d40>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7508 @052d3b> : 11 15                      dup.x2 sp(21)
	<.main+7510 @052d3d> : 11 15                      dup.x2 sp(21)
	<.main+7512 @052d3f> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@052d40> - <@052d46>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7513 @052d40> : 11 16                      dup.x2 sp(22)
	<.main+7515 @052d42> : 11 16                      dup.x2 sp(22)
	<.main+7517 @052d44> : 88                         clt.f64
	<.main+7518 @052d45> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@052d46> - <@052d4b>): ptrA: pointer := null
	<.main+7519 @052d46> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@052d4b> - <@052d4f>): ptrB: pointer := pointer(shift)
	<.main+7524 @052d4b> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@052d4f> - <@052d54>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7528 @052d4f> : 10 01                      dup.x1 sp(1)
	<.main+7530 @052d51> : 10 01                      dup.x1 sp(1)
	<.main+7532 @052d53> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@052d54> - <@052d5a>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7533 @052d54> : 10 02                      dup.x1 sp(2)
	<.main+7535 @052d56> : 10 02                      dup.x1 sp(2)
	<.main+7537 @052d58> : 57                         ceq.i32
	<.main+7538 @052d59> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@052d5a> - <@052d81>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7539 @052d5a> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7544 @052d5f> : 1c 04 00 00 00             load.c32 4
	<.main+7549 @052d64> : 1c 0e 00 00 00             load.c32 14
	<.main+7554 @052d69> : 1c 01 00 00 00             load.c32 1
	<.main+7559 @052d6e> : 1f 41 c4 04 00             load.ref <@04c441> ;"0 == 0"
	<.main+7564 @052d73> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7569 @052d78> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7574 @052d7d> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@052d81> - <@052da8>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7578 @052d81> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7583 @052d86> : 1c 0c 00 00 00             load.c32 12
	<.main+7588 @052d8b> : 1c 0e 00 00 00             load.c32 14
	<.main+7593 @052d90> : 1c 03 00 00 00             load.c32 3
	<.main+7598 @052d95> : 1f 41 c4 04 00             load.ref <@04c441> ;"0 == 0"
	<.main+7603 @052d9a> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7608 @052d9f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7613 @052da4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@052da8> - <@052dcf>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7617 @052da8> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7622 @052dad> : 1c 16 00 00 00             load.c32 22
	<.main+7627 @052db2> : 1c 0e 00 00 00             load.c32 14
	<.main+7632 @052db7> : 1c 06 00 00 00             load.c32 6
	<.main+7637 @052dbc> : 1f 41 c4 04 00             load.ref <@04c441> ;"0 == 0"
	<.main+7642 @052dc1> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7647 @052dc6> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7652 @052dcb> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@052dcf> - <@052dd0>): t: int32 := 0
	<.main+7656 @052dcf> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@052dd0> - <@052dfe>): if (bool(t == 0))
	<.main+7657 @052dd0> : 10 00                      dup.x1 sp(0)
	<.main+7659 @052dd2> : 19                         load.z32
	<.main+7660 @052dd3> : 57                         ceq.i32
	<.main+7661 @052dd4> : 06 2a 00 00                jz <.main+7703 @052dfe>
	test/lang/statementIf.ci:29: (38 bytes: <@052dd8> - <@052dfe>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7665 @052dd8> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7670 @052ddd> : 1c 1d 00 00 00             load.c32 29
	<.main+7675 @052de2> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @052de7> : 1c 07 00 00 00             load.c32 7
	<.main+7685 @052dec> : 1f 4f c4 04 00             load.ref <@04c44f> ;"t == 0"
	<.main+7690 @052df1> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7695 @052df6> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @052dfa> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@052dfe> - <@052e2c>): if (bool(t != 0))
	<.main+7703 @052dfe> : 10 00                      dup.x1 sp(0)
	<.main+7705 @052e00> : 19                         load.z32
	<.main+7706 @052e01> : 57                         ceq.i32
	<.main+7707 @052e02> : 05 2a 00 00                jnz <.main+7749 @052e2c>
	test/lang/statementIf.ci:33: (38 bytes: <@052e06> - <@052e2c>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7711 @052e06> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7716 @052e0b> : 1c 21 00 00 00             load.c32 33
	<.main+7721 @052e10> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @052e15> : 1c 08 00 00 00             load.c32 8
	<.main+7731 @052e1a> : 1f 56 c4 04 00             load.ref <@04c456> ;"t != 0"
	<.main+7736 @052e1f> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7741 @052e24> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @052e28> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@052e2c> - <@052e84>): if (bool(t == 0))
	<.main+7749 @052e2c> : 10 00                      dup.x1 sp(0)
	<.main+7751 @052e2e> : 19                         load.z32
	<.main+7752 @052e2f> : 57                         ceq.i32
	<.main+7753 @052e30> : 06 2e 00 00                jz <.main+7799 @052e5e>
	test/lang/statementIf.ci:37: (38 bytes: <@052e34> - <@052e5a>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7757 @052e34> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7762 @052e39> : 1c 25 00 00 00             load.c32 37
	<.main+7767 @052e3e> : 1c 0e 00 00 00             load.c32 14
	<.main+7772 @052e43> : 1c 09 00 00 00             load.c32 9
	<.main+7777 @052e48> : 1f 4f c4 04 00             load.ref <@04c44f> ;"t == 0"
	<.main+7782 @052e4d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7787 @052e52> : 0a 18 00 00                load.sp(+24)
	<.main+7791 @052e56> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7795 @052e5a> : 04 2a 00 00                jmp <.main+7837 @052e84>
	test/lang/statementIf.ci:40: (38 bytes: <@052e5e> - <@052e84>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7799 @052e5e> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7804 @052e63> : 1c 28 00 00 00             load.c32 40
	<.main+7809 @052e68> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @052e6d> : 1c 0a 00 00 00             load.c32 10
	<.main+7819 @052e72> : 1f 56 c4 04 00             load.ref <@04c456> ;"t != 0"
	<.main+7824 @052e77> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7829 @052e7c> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @052e80> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@052e84> - <@052edc>): if (bool(t != 0))
	<.main+7837 @052e84> : 10 00                      dup.x1 sp(0)
	<.main+7839 @052e86> : 19                         load.z32
	<.main+7840 @052e87> : 57                         ceq.i32
	<.main+7841 @052e88> : 05 2e 00 00                jnz <.main+7887 @052eb6>
	test/lang/statementIf.ci:44: (38 bytes: <@052e8c> - <@052eb2>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7845 @052e8c> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7850 @052e91> : 1c 2c 00 00 00             load.c32 44
	<.main+7855 @052e96> : 1c 0e 00 00 00             load.c32 14
	<.main+7860 @052e9b> : 1c 0b 00 00 00             load.c32 11
	<.main+7865 @052ea0> : 1f 56 c4 04 00             load.ref <@04c456> ;"t != 0"
	<.main+7870 @052ea5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7875 @052eaa> : 0a 18 00 00                load.sp(+24)
	<.main+7879 @052eae> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7883 @052eb2> : 04 2a 00 00                jmp <.main+7925 @052edc>
	test/lang/statementIf.ci:47: (38 bytes: <@052eb6> - <@052edc>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7887 @052eb6> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7892 @052ebb> : 1c 2f 00 00 00             load.c32 47
	<.main+7897 @052ec0> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @052ec5> : 1c 0c 00 00 00             load.c32 12
	<.main+7907 @052eca> : 1f 4f c4 04 00             load.ref <@04c44f> ;"t == 0"
	<.main+7912 @052ecf> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7917 @052ed4> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @052ed8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@052edc> - <@053042>): if (bool(t == 0))
	<.main+7925 @052edc> : 10 00                      dup.x1 sp(0)
	<.main+7927 @052ede> : 19                         load.z32
	<.main+7928 @052edf> : 57                         ceq.i32
	<.main+7929 @052ee0> : 06 2e 00 00                jz <.main+7975 @052f0e>
	test/lang/statementIf.ci:51: (38 bytes: <@052ee4> - <@052f0a>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7933 @052ee4> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7938 @052ee9> : 1c 33 00 00 00             load.c32 51
	<.main+7943 @052eee> : 1c 0e 00 00 00             load.c32 14
	<.main+7948 @052ef3> : 1c 09 00 00 00             load.c32 9
	<.main+7953 @052ef8> : 1f 4f c4 04 00             load.ref <@04c44f> ;"t == 0"
	<.main+7958 @052efd> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7963 @052f02> : 0a 18 00 00                load.sp(+24)
	<.main+7967 @052f06> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7971 @052f0a> : 04 38 01 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:53: (308 bytes: <@052f0e> - <@053042>): if (bool(t == 1))
	<.main+7975 @052f0e> : 10 00                      dup.x1 sp(0)
	<.main+7977 @052f10> : 1c 01 00 00 00             load.c32 1
	<.main+7982 @052f15> : 57                         ceq.i32
	<.main+7983 @052f16> : 06 2e 00 00                jz <.main+8029 @052f44>
	test/lang/statementIf.ci:54: (38 bytes: <@052f1a> - <@052f40>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7987 @052f1a> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+7992 @052f1f> : 1c 36 00 00 00             load.c32 54
	<.main+7997 @052f24> : 1c 0e 00 00 00             load.c32 14
	<.main+8002 @052f29> : 1c 0a 00 00 00             load.c32 10
	<.main+8007 @052f2e> : 1f 5d c4 04 00             load.ref <@04c45d> ;"t == 1"
	<.main+8012 @052f33> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8017 @052f38> : 0a 18 00 00                load.sp(+24)
	<.main+8021 @052f3c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8025 @052f40> : 04 02 01 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:56: (254 bytes: <@052f44> - <@053042>): if (bool(t == 2))
	<.main+8029 @052f44> : 10 00                      dup.x1 sp(0)
	<.main+8031 @052f46> : 1c 02 00 00 00             load.c32 2
	<.main+8036 @052f4b> : 57                         ceq.i32
	<.main+8037 @052f4c> : 06 2e 00 00                jz <.main+8083 @052f7a>
	test/lang/statementIf.ci:57: (38 bytes: <@052f50> - <@052f76>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8041 @052f50> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+8046 @052f55> : 1c 39 00 00 00             load.c32 57
	<.main+8051 @052f5a> : 1c 0e 00 00 00             load.c32 14
	<.main+8056 @052f5f> : 1c 0a 00 00 00             load.c32 10
	<.main+8061 @052f64> : 1f 64 c4 04 00             load.ref <@04c464> ;"t == 2"
	<.main+8066 @052f69> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8071 @052f6e> : 0a 18 00 00                load.sp(+24)
	<.main+8075 @052f72> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8079 @052f76> : 04 cc 00 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:59: (200 bytes: <@052f7a> - <@053042>): if (bool(t == 3))
	<.main+8083 @052f7a> : 10 00                      dup.x1 sp(0)
	<.main+8085 @052f7c> : 1c 03 00 00 00             load.c32 3
	<.main+8090 @052f81> : 57                         ceq.i32
	<.main+8091 @052f82> : 06 2e 00 00                jz <.main+8137 @052fb0>
	test/lang/statementIf.ci:60: (38 bytes: <@052f86> - <@052fac>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8095 @052f86> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+8100 @052f8b> : 1c 3c 00 00 00             load.c32 60
	<.main+8105 @052f90> : 1c 0e 00 00 00             load.c32 14
	<.main+8110 @052f95> : 1c 0a 00 00 00             load.c32 10
	<.main+8115 @052f9a> : 1f 6b c4 04 00             load.ref <@04c46b> ;"t == 3"
	<.main+8120 @052f9f> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8125 @052fa4> : 0a 18 00 00                load.sp(+24)
	<.main+8129 @052fa8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8133 @052fac> : 04 96 00 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:62: (146 bytes: <@052fb0> - <@053042>): if (bool(t == 4))
	<.main+8137 @052fb0> : 10 00                      dup.x1 sp(0)
	<.main+8139 @052fb2> : 1c 04 00 00 00             load.c32 4
	<.main+8144 @052fb7> : 57                         ceq.i32
	<.main+8145 @052fb8> : 06 2e 00 00                jz <.main+8191 @052fe6>
	test/lang/statementIf.ci:63: (38 bytes: <@052fbc> - <@052fe2>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8149 @052fbc> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+8154 @052fc1> : 1c 3f 00 00 00             load.c32 63
	<.main+8159 @052fc6> : 1c 0e 00 00 00             load.c32 14
	<.main+8164 @052fcb> : 1c 0a 00 00 00             load.c32 10
	<.main+8169 @052fd0> : 1f 72 c4 04 00             load.ref <@04c472> ;"t == 4"
	<.main+8174 @052fd5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8179 @052fda> : 0a 18 00 00                load.sp(+24)
	<.main+8183 @052fde> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8187 @052fe2> : 04 60 00 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:65: (92 bytes: <@052fe6> - <@053042>): if (bool(t == 5))
	<.main+8191 @052fe6> : 10 00                      dup.x1 sp(0)
	<.main+8193 @052fe8> : 1c 05 00 00 00             load.c32 5
	<.main+8198 @052fed> : 57                         ceq.i32
	<.main+8199 @052fee> : 06 2e 00 00                jz <.main+8245 @05301c>
	test/lang/statementIf.ci:66: (38 bytes: <@052ff2> - <@053018>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8203 @052ff2> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+8208 @052ff7> : 1c 42 00 00 00             load.c32 66
	<.main+8213 @052ffc> : 1c 0e 00 00 00             load.c32 14
	<.main+8218 @053001> : 1c 0a 00 00 00             load.c32 10
	<.main+8223 @053006> : 1f 79 c4 04 00             load.ref <@04c479> ;"t == 5"
	<.main+8228 @05300b> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8233 @053010> : 0a 18 00 00                load.sp(+24)
	<.main+8237 @053014> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8241 @053018> : 04 2a 00 00                jmp <.main+8283 @053042>
	test/lang/statementIf.ci:69: (38 bytes: <@05301c> - <@053042>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8245 @05301c> : 1f 28 c4 04 00             load.ref <@04c428> ;"test/lang/statementIf.ci"
	<.main+8250 @053021> : 1c 45 00 00 00             load.c32 69
	<.main+8255 @053026> : 1c 0e 00 00 00             load.c32 14
	<.main+8260 @05302b> : 1c 0a 00 00 00             load.c32 10
	<.main+8265 @053030> : 1f 80 c4 04 00             load.ref <@04c480> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8270 @053035> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8275 @05303a> : 0a 18 00 00                load.sp(+24)
	<.main+8279 @05303e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@053042> - <@053071>): for ( ; ; )
	<.main+8283 @053042> : 04 2b 00 00                jmp <.main+8326 @05306d>
	test/lang/statementFor.ci:4: (35 bytes: <@053046> - <@053069>): debug("for ( ; ; )");
	<.main+8287 @053046> : 1f 68 c5 04 00             load.ref <@04c568> ;"test/lang/statementFor.ci"
	<.main+8292 @05304b> : 1c 04 00 00 00             load.c32 4
	<.main+8297 @053050> : 1c 0e 00 00 00             load.c32 14
	<.main+8302 @053055> : 19                         load.z32
	<.main+8303 @053056> : 1f 82 c5 04 00             load.ref <@04c582> ;"for ( ; ; )"
	<.main+8308 @05305b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+8313 @053060> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8318 @053065> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@053069> - <@05306d>): break;
	<.main+8322 @053069> : 04 08 00 00                jmp <.main+8330 @053071>
	:: (4 bytes: <@05306d> - <@053071>)
	<.main+8326 @05306d> : 04 d9 ff ff                jmp <.main+8287 @053046>
	test/lang/statementFor.ci:8: (59 bytes: <@053071> - <@0530ac>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8330 @053071> : 19                         load.z32
	<.main+8331 @053072> : 04 2a 00 00                jmp <.main+8373 @05309c>
	test/lang/statementFor.ci:9: (34 bytes: <@053076> - <@053098>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8335 @053076> : 1f 68 c5 04 00             load.ref <@04c568> ;"test/lang/statementFor.ci"
	<.main+8340 @05307b> : 1c 09 00 00 00             load.c32 9
	<.main+8345 @053080> : 1c 0e 00 00 00             load.c32 14
	<.main+8350 @053085> : 19                         load.z32
	<.main+8351 @053086> : 1f 8e c5 04 00             load.ref <@04c58e> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8356 @05308b> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8361 @053090> : 0a 18 00 00                load.sp(+24)
	<.main+8365 @053094> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@053098> - <@05309c>): int32(i := int32(i + 1))
	<.main+8369 @053098> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@05309c> - <@0530a8>): bool(i < 2)
	<.main+8373 @05309c> : 10 00                      dup.x1 sp(0)
	<.main+8375 @05309e> : 1c 02 00 00 00             load.c32 2
	<.main+8380 @0530a3> : 58                         clt.i32
	<.main+8381 @0530a4> : 05 d2 ff ff                jnz <.main+8335 @053076>
	<.main+8385 @0530a8> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@0530ac> - <@0530ad>): forIdx: int32
	<.main+8389 @0530ac> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@0530ad> - <@0530e6>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8390 @0530ad> : 19                         load.z32
	<.main+8391 @0530ae> : 13 01                      set.x1 sp(1)
	<.main+8393 @0530b0> : 04 2a 00 00                jmp <.main+8435 @0530da>
	test/lang/statementFor.ci:14: (34 bytes: <@0530b4> - <@0530d6>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8397 @0530b4> : 1f 68 c5 04 00             load.ref <@04c568> ;"test/lang/statementFor.ci"
	<.main+8402 @0530b9> : 1c 0e 00 00 00             load.c32 14
	<.main+8407 @0530be> : 1c 0e 00 00 00             load.c32 14
	<.main+8412 @0530c3> : 19                         load.z32
	<.main+8413 @0530c4> : 1f b4 c5 04 00             load.ref <@04c5b4> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8418 @0530c9> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8423 @0530ce> : 0a 18 00 00                load.sp(+24)
	<.main+8427 @0530d2> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@0530d6> - <@0530da>): int32(forIdx := int32(forIdx + 1))
	<.main+8431 @0530d6> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@0530da> - <@0530e6>): bool(forIdx < 2)
	<.main+8435 @0530da> : 10 00                      dup.x1 sp(0)
	<.main+8437 @0530dc> : 1c 02 00 00 00             load.c32 2
	<.main+8442 @0530e1> : 58                         clt.i32
	<.main+8443 @0530e2> : 05 d2 ff ff                jnz <.main+8397 @0530b4>
	test/lang/statementFor.ci:17: (75 bytes: <@0530e6> - <@053131>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8447 @0530e6> : 19                         load.z32
	<.main+8448 @0530e7> : 04 3a 00 00                jmp <.main+8506 @053121>
	test/lang/statementFor.ci:18: (16 bytes: <@0530eb> - <@0530fb>): if (bool(i < 2))
	<.main+8452 @0530eb> : 10 00                      dup.x1 sp(0)
	<.main+8454 @0530ed> : 1c 02 00 00 00             load.c32 2
	<.main+8459 @0530f2> : 58                         clt.i32
	<.main+8460 @0530f3> : 06 08 00 00                jz <.main+8468 @0530fb>
	test/lang/statementFor.ci:19: (4 bytes: <@0530f7> - <@0530fb>): continue;
	<.main+8464 @0530f7> : 04 26 00 00                jmp <.main+8502 @05311d>
	test/lang/statementFor.ci:21: (34 bytes: <@0530fb> - <@05311d>): debug(void("for with continue", i));
	<.main+8468 @0530fb> : 1f 68 c5 04 00             load.ref <@04c568> ;"test/lang/statementFor.ci"
	<.main+8473 @053100> : 1c 15 00 00 00             load.c32 21
	<.main+8478 @053105> : 1c 0e 00 00 00             load.c32 14
	<.main+8483 @05310a> : 19                         load.z32
	<.main+8484 @05310b> : 1f de c5 04 00             load.ref <@04c5de> ;"for with continue"
	<.main+8489 @053110> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8494 @053115> : 0a 18 00 00                load.sp(+24)
	<.main+8498 @053119> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@05311d> - <@053121>): int32(i := int32(i + 1))
	<.main+8502 @05311d> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@053121> - <@05312d>): bool(i < 7)
	<.main+8506 @053121> : 10 00                      dup.x1 sp(0)
	<.main+8508 @053123> : 1c 07 00 00 00             load.c32 7
	<.main+8513 @053128> : 58                         clt.i32
	<.main+8514 @053129> : 05 c2 ff ff                jnz <.main+8452 @0530eb>
	<.main+8518 @05312d> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@053131> - <@05317c>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8522 @053131> : 19                         load.z32
	<.main+8523 @053132> : 04 3a 00 00                jmp <.main+8581 @05316c>
	test/lang/statementFor.ci:25: (16 bytes: <@053136> - <@053146>): if (bool(i > 2))
	<.main+8527 @053136> : 10 00                      dup.x1 sp(0)
	<.main+8529 @053138> : 1c 02 00 00 00             load.c32 2
	<.main+8534 @05313d> : 59                         cgt.i32
	<.main+8535 @05313e> : 06 08 00 00                jz <.main+8543 @053146>
	test/lang/statementFor.ci:26: (4 bytes: <@053142> - <@053146>): break;
	<.main+8539 @053142> : 04 36 00 00                jmp <.main+8593 @053178>
	test/lang/statementFor.ci:28: (34 bytes: <@053146> - <@053168>): debug(void("for with break", i));
	<.main+8543 @053146> : 1f 68 c5 04 00             load.ref <@04c568> ;"test/lang/statementFor.ci"
	<.main+8548 @05314b> : 1c 1c 00 00 00             load.c32 28
	<.main+8553 @053150> : 1c 0e 00 00 00             load.c32 14
	<.main+8558 @053155> : 19                         load.z32
	<.main+8559 @053156> : 1f f0 c5 04 00             load.ref <@04c5f0> ;"for with break"
	<.main+8564 @05315b> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8569 @053160> : 0a 18 00 00                load.sp(+24)
	<.main+8573 @053164> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@053168> - <@05316c>): int32(i := int32(i + 1))
	<.main+8577 @053168> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@05316c> - <@053178>): bool(i < 7)
	<.main+8581 @05316c> : 10 00                      dup.x1 sp(0)
	<.main+8583 @05316e> : 1c 07 00 00 00             load.c32 7
	<.main+8588 @053173> : 58                         clt.i32
	<.main+8589 @053174> : 05 c2 ff ff                jnz <.main+8527 @053136>
	<.main+8593 @053178> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@05317c> - <@053190>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8597 @05317c> : 1a                         load.z64
	<.main+8598 @05317d> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8607 @053186> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8612 @05318b> : 02                         call
	<.main+8613 @05318c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@053190> - <@0531a4>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8617 @053190> : 1a                         load.z64
	<.main+8618 @053191> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8627 @05319a> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8632 @05319f> : 02                         call
	<.main+8633 @0531a0> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@0531a4> - <@0531b8>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8637 @0531a4> : 1a                         load.z64
	<.main+8638 @0531a5> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8647 @0531ae> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8652 @0531b3> : 02                         call
	<.main+8653 @0531b4> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@0531b8> - <@0531cc>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8657 @0531b8> : 1a                         load.z64
	<.main+8658 @0531b9> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8667 @0531c2> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8672 @0531c7> : 02                         call
	<.main+8673 @0531c8> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@0531cc> - <@0531e0>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8677 @0531cc> : 1a                         load.z64
	<.main+8678 @0531cd> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8687 @0531d6> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8692 @0531db> : 02                         call
	<.main+8693 @0531dc> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@0531e0> - <@0531f4>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8697 @0531e0> : 1a                         load.z64
	<.main+8698 @0531e1> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8707 @0531ea> : 1f 50 fd 04 00             load.ref <@04fd50> ;Math.floor(x: float64): float64
	<.main+8712 @0531ef> : 02                         call
	<.main+8713 @0531f0> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (25 bytes: <@0531f4> - <@05320d>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8717 @0531f4> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8726 @0531fd> : 11 00                      dup.x2 sp(0)
	<.main+8728 @0531ff> : 1a                         load.z64
	<.main+8729 @053200> : 89                         cgt.f64
	<.main+8730 @053201> : 11 01                      dup.x2 sp(1)
	<.main+8732 @053203> : 1a                         load.z64
	<.main+8733 @053204> : 88                         clt.f64
	<.main+8734 @053205> : 52                         sub.i32
	<.main+8735 @053206> : 13 02                      set.x1 sp(2)
	<.main+8737 @053208> : 09 fc ff ff                inc.sp(-4)
	<.main+8741 @05320c> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (17 bytes: <@05320d> - <@05321e>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8742 @05320d> : 1a                         load.z64
	<.main+8743 @05320e> : 11 00                      dup.x2 sp(0)
	<.main+8745 @053210> : 1a                         load.z64
	<.main+8746 @053211> : 89                         cgt.f64
	<.main+8747 @053212> : 11 01                      dup.x2 sp(1)
	<.main+8749 @053214> : 1a                         load.z64
	<.main+8750 @053215> : 88                         clt.f64
	<.main+8751 @053216> : 52                         sub.i32
	<.main+8752 @053217> : 13 02                      set.x1 sp(2)
	<.main+8754 @053219> : 09 fc ff ff                inc.sp(-4)
	<.main+8758 @05321d> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (25 bytes: <@05321e> - <@053237>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8759 @05321e> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8768 @053227> : 11 00                      dup.x2 sp(0)
	<.main+8770 @053229> : 1a                         load.z64
	<.main+8771 @05322a> : 89                         cgt.f64
	<.main+8772 @05322b> : 11 01                      dup.x2 sp(1)
	<.main+8774 @05322d> : 1a                         load.z64
	<.main+8775 @05322e> : 88                         clt.f64
	<.main+8776 @05322f> : 52                         sub.i32
	<.main+8777 @053230> : 13 02                      set.x1 sp(2)
	<.main+8779 @053232> : 09 fc ff ff                inc.sp(-4)
	<.main+8783 @053236> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@053237> - <@053248>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8784 @053237> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8789 @05323c> : 10 00                      dup.x1 sp(0)
	<.main+8791 @05323e> : 19                         load.z32
	<.main+8792 @05323f> : 79                         cgt.f32
	<.main+8793 @053240> : 10 01                      dup.x1 sp(1)
	<.main+8795 @053242> : 19                         load.z32
	<.main+8796 @053243> : 78                         clt.f32
	<.main+8797 @053244> : 52                         sub.i32
	<.main+8798 @053245> : 13 01                      set.x1 sp(1)
	<.main+8800 @053247> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@053248> - <@053255>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8801 @053248> : 19                         load.z32
	<.main+8802 @053249> : 10 00                      dup.x1 sp(0)
	<.main+8804 @05324b> : 19                         load.z32
	<.main+8805 @05324c> : 79                         cgt.f32
	<.main+8806 @05324d> : 10 01                      dup.x1 sp(1)
	<.main+8808 @05324f> : 19                         load.z32
	<.main+8809 @053250> : 78                         clt.f32
	<.main+8810 @053251> : 52                         sub.i32
	<.main+8811 @053252> : 13 01                      set.x1 sp(1)
	<.main+8813 @053254> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@053255> - <@053266>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8814 @053255> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8819 @05325a> : 10 00                      dup.x1 sp(0)
	<.main+8821 @05325c> : 19                         load.z32
	<.main+8822 @05325d> : 79                         cgt.f32
	<.main+8823 @05325e> : 10 01                      dup.x1 sp(1)
	<.main+8825 @053260> : 19                         load.z32
	<.main+8826 @053261> : 78                         clt.f32
	<.main+8827 @053262> : 52                         sub.i32
	<.main+8828 @053263> : 13 01                      set.x1 sp(1)
	<.main+8830 @053265> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@053266> - <@05327a>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8831 @053266> : 1a                         load.z64
	<.main+8832 @053267> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8841 @053270> : 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<.main+8846 @053275> : 02                         call
	<.main+8847 @053276> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@05327a> - <@053285>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8851 @05327a> : 1b                         load.z128
	<.main+8852 @05327b> : 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<.main+8857 @053280> : 02                         call
	<.main+8858 @053281> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@053285> - <@053299>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8862 @053285> : 1a                         load.z64
	<.main+8863 @053286> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8872 @05328f> : 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<.main+8877 @053294> : 02                         call
	<.main+8878 @053295> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@053299> - <@0532aa>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8882 @053299> : 19                         load.z32
	<.main+8883 @05329a> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8888 @05329f> : 1f 68 fd 04 00             load.ref <@04fd68> ;Math.abs(x: float32): float32
	<.main+8893 @0532a4> : 02                         call
	<.main+8894 @0532a5> : 09 fc ff ff                inc.sp(-4)
	<.main+8898 @0532a9> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@0532aa> - <@0532b7>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8899 @0532aa> : 19                         load.z32
	<.main+8900 @0532ab> : 19                         load.z32
	<.main+8901 @0532ac> : 1f 68 fd 04 00             load.ref <@04fd68> ;Math.abs(x: float32): float32
	<.main+8906 @0532b1> : 02                         call
	<.main+8907 @0532b2> : 09 fc ff ff                inc.sp(-4)
	<.main+8911 @0532b6> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@0532b7> - <@0532c8>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8912 @0532b7> : 19                         load.z32
	<.main+8913 @0532b8> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8918 @0532bd> : 1f 68 fd 04 00             load.ref <@04fd68> ;Math.abs(x: float32): float32
	<.main+8923 @0532c2> : 02                         call
	<.main+8924 @0532c3> : 09 fc ff ff                inc.sp(-4)
	<.main+8928 @0532c7> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@0532c8> - <@0532de>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8929 @0532c8> : 19                         load.z32
	<.main+8930 @0532c9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8935 @0532ce> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8940 @0532d3> : 1f d8 fd 04 00             load.ref <@04fdd8> ;Math.min(a: float32, b: float32): float32
	<.main+8945 @0532d8> : 02                         call
	<.main+8946 @0532d9> : 09 f8 ff ff                inc.sp(-8)
	<.main+8950 @0532dd> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@0532de> - <@0532f4>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8951 @0532de> : 19                         load.z32
	<.main+8952 @0532df> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8957 @0532e4> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8962 @0532e9> : 1f 08 fe 04 00             load.ref <@04fe08> ;Math.max(a: float32, b: float32): float32
	<.main+8967 @0532ee> : 02                         call
	<.main+8968 @0532ef> : 09 f8 ff ff                inc.sp(-8)
	<.main+8972 @0532f3> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@0532f4> - <@053311>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8973 @0532f4> : 1a                         load.z64
	<.main+8974 @0532f5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8983 @0532fe> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8992 @053307> : 1f f0 fd 04 00             load.ref <@04fdf0> ;Math.min(a: float64, b: float64): float64
	<.main+8997 @05330c> : 02                         call
	<.main+8998 @05330d> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@053311> - <@05332e>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9002 @053311> : 1a                         load.z64
	<.main+9003 @053312> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9012 @05331b> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9021 @053324> : 1f 20 fe 04 00             load.ref <@04fe20> ;Math.max(a: float64, b: float64): float64
	<.main+9026 @053329> : 02                         call
	<.main+9027 @05332a> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@05332e> - <@053345>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9031 @05332e> : 19                         load.z32
	<.main+9032 @05332f> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9037 @053334> : 19                         load.z32
	<.main+9038 @053335> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9043 @05333a> : 1f 38 fe 04 00             load.ref <@04fe38> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9048 @05333f> : 02                         call
	<.main+9049 @053340> : 09 f4 ff ff                inc.sp(-12)
	<.main+9053 @053344> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@053345> - <@053363>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9054 @053345> : 1a                         load.z64
	<.main+9055 @053346> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9064 @05334f> : 1a                         load.z64
	<.main+9065 @053350> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9074 @053359> : 1f 58 fe 04 00             load.ref <@04fe58> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9079 @05335e> : 02                         call
	<.main+9080 @05335f> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@053363> - <@053378>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9084 @053363> : 19                         load.z32
	<.main+9085 @053364> : 10 00                      dup.x1 sp(0)
	<.main+9087 @053366> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9092 @05336b> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9097 @053370> : 10 03                      dup.x1 sp(3)
	<.main+9099 @053372> : 72                         sub.f32
	<.main+9100 @053373> : 73                         mul.f32
	<.main+9101 @053374> : 71                         add.f32
	<.main+9102 @053375> : 13 01                      set.x1 sp(1)
	<.main+9104 @053377> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@053378> - <@053394>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9105 @053378> : 1a                         load.z64
	<.main+9106 @053379> : 11 00                      dup.x2 sp(0)
	<.main+9108 @05337b> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9117 @053384> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9126 @05338d> : 11 06                      dup.x2 sp(6)
	<.main+9128 @05338f> : 82                         sub.f64
	<.main+9129 @053390> : 83                         mul.f64
	<.main+9130 @053391> : 81                         add.f64
	<.main+9131 @053392> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (60 bytes: <@053394> - <@0533d0>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9133 @053394> : 19                         load.z32
	<.main+9134 @053395> : 19                         load.z32
	<.main+9135 @053396> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9140 @05339b> : 10 02                      dup.x1 sp(2)
	<.main+9142 @05339d> : 72                         sub.f32
	<.main+9143 @05339e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9148 @0533a3> : 10 03                      dup.x1 sp(3)
	<.main+9150 @0533a5> : 72                         sub.f32
	<.main+9151 @0533a6> : 74                         div.f32
	<.main+9152 @0533a7> : 19                         load.z32
	<.main+9153 @0533a8> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9158 @0533ad> : 1f 38 fe 04 00             load.ref <@04fe38> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9163 @0533b2> : 02                         call
	<.main+9164 @0533b3> : 09 f4 ff ff                inc.sp(-12)
	<.main+9168 @0533b7> : 10 00                      dup.x1 sp(0)
	<.main+9170 @0533b9> : 10 01                      dup.x1 sp(1)
	<.main+9172 @0533bb> : 73                         mul.f32
	<.main+9173 @0533bc> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9178 @0533c1> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9183 @0533c6> : 10 03                      dup.x1 sp(3)
	<.main+9185 @0533c8> : 73                         mul.f32
	<.main+9186 @0533c9> : 72                         sub.f32
	<.main+9187 @0533ca> : 73                         mul.f32
	<.main+9188 @0533cb> : 13 01                      set.x1 sp(1)
	<.main+9190 @0533cd> : 13 01                      set.x1 sp(1)
	<.main+9192 @0533cf> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (78 bytes: <@0533d0> - <@05341e>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9193 @0533d0> : 1b                         load.z128
	<.main+9194 @0533d1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9203 @0533da> : 11 04                      dup.x2 sp(4)
	<.main+9205 @0533dc> : 82                         sub.f64
	<.main+9206 @0533dd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9215 @0533e6> : 11 06                      dup.x2 sp(6)
	<.main+9217 @0533e8> : 82                         sub.f64
	<.main+9218 @0533e9> : 84                         div.f64
	<.main+9219 @0533ea> : 1a                         load.z64
	<.main+9220 @0533eb> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9229 @0533f4> : 1f 58 fe 04 00             load.ref <@04fe58> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9234 @0533f9> : 02                         call
	<.main+9235 @0533fa> : 09 e8 ff ff                inc.sp(-24)
	<.main+9239 @0533fe> : 11 00                      dup.x2 sp(0)
	<.main+9241 @053400> : 11 02                      dup.x2 sp(2)
	<.main+9243 @053402> : 83                         mul.f64
	<.main+9244 @053403> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9253 @05340c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9262 @053415> : 11 06                      dup.x2 sp(6)
	<.main+9264 @053417> : 83                         mul.f64
	<.main+9265 @053418> : 82                         sub.f64
	<.main+9266 @053419> : 83                         mul.f64
	<.main+9267 @05341a> : 14 02                      set.x2 sp(2)
	<.main+9269 @05341c> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:38: (21 bytes: <@05341e> - <@053433>): testMathMin_nan: float64 := Math.min()
	<.main+9271 @05341e> : 19                         load.z32
	<.main+9272 @05341f> : 0a 04 00 00                load.sp(+4)
	<.main+9276 @053423> : 1a                         load.z64
	<.main+9277 @053424> : 11 02                      dup.x2 sp(2)
	<.main+9279 @053426> : 1f 78 fe 04 00             load.ref <@04fe78> ;Math.min(data: float64[]): float64
	<.main+9284 @05342b> : 02                         call
	<.main+9285 @05342c> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9288 @05342f> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:39: (106 bytes: <@053433> - <@05349d>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9292 @053433> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9301 @05343c> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9310 @053445> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9319 @05344e> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9328 @053457> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9337 @053460> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9346 @053469> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9355 @053472> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9364 @05347b> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9373 @053484> : 1c 09 00 00 00             load.c32 9
	<.main+9378 @053489> : 0a 04 00 00                load.sp(+4)
	<.main+9382 @05348d> : 1a                         load.z64
	<.main+9383 @05348e> : 11 02                      dup.x2 sp(2)
	<.main+9385 @053490> : 1f 78 fe 04 00             load.ref <@04fe78> ;Math.min(data: float64[]): float64
	<.main+9390 @053495> : 02                         call
	<.main+9391 @053496> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9394 @053499> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:40: (21 bytes: <@05349d> - <@0534b2>): testMathMax_nan: float64 := Math.max()
	<.main+9398 @05349d> : 19                         load.z32
	<.main+9399 @05349e> : 0a 04 00 00                load.sp(+4)
	<.main+9403 @0534a2> : 1a                         load.z64
	<.main+9404 @0534a3> : 11 02                      dup.x2 sp(2)
	<.main+9406 @0534a5> : 1f c0 fe 04 00             load.ref <@04fec0> ;Math.max(data: float64[]): float64
	<.main+9411 @0534aa> : 02                         call
	<.main+9412 @0534ab> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9415 @0534ae> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@0534b2> - <@05351c>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9419 @0534b2> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9428 @0534bb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9437 @0534c4> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9446 @0534cd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9455 @0534d6> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9464 @0534df> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9473 @0534e8> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9482 @0534f1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9491 @0534fa> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9500 @053503> : 1c 09 00 00 00             load.c32 9
	<.main+9505 @053508> : 0a 04 00 00                load.sp(+4)
	<.main+9509 @05350c> : 1a                         load.z64
	<.main+9510 @05350d> : 11 02                      dup.x2 sp(2)
	<.main+9512 @05350f> : 1f c0 fe 04 00             load.ref <@04fec0> ;Math.max(data: float64[]): float64
	<.main+9517 @053514> : 02                         call
	<.main+9518 @053515> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9521 @053518> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:43: (21 bytes: <@05351c> - <@053531>): testMathSum_0: float64 := Math.sum()
	<.main+9525 @05351c> : 19                         load.z32
	<.main+9526 @05351d> : 0a 04 00 00                load.sp(+4)
	<.main+9530 @053521> : 1a                         load.z64
	<.main+9531 @053522> : 11 02                      dup.x2 sp(2)
	<.main+9533 @053524> : 1f 08 ff 04 00             load.ref <@04ff08> ;Math.sum(data: float64[]): float64
	<.main+9538 @053529> : 02                         call
	<.main+9539 @05352a> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9542 @05352d> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:44: (34 bytes: <@053531> - <@053553>): testMathSum_1: float64 := Math.sum(1)
	<.main+9546 @053531> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9555 @05353a> : 1c 01 00 00 00             load.c32 1
	<.main+9560 @05353f> : 0a 04 00 00                load.sp(+4)
	<.main+9564 @053543> : 1a                         load.z64
	<.main+9565 @053544> : 11 02                      dup.x2 sp(2)
	<.main+9567 @053546> : 1f 08 ff 04 00             load.ref <@04ff08> ;Math.sum(data: float64[]): float64
	<.main+9572 @05354b> : 02                         call
	<.main+9573 @05354c> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9576 @05354f> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:45: (43 bytes: <@053553> - <@05357e>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9580 @053553> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9589 @05355c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9598 @053565> : 1c 02 00 00 00             load.c32 2
	<.main+9603 @05356a> : 0a 04 00 00                load.sp(+4)
	<.main+9607 @05356e> : 1a                         load.z64
	<.main+9608 @05356f> : 11 02                      dup.x2 sp(2)
	<.main+9610 @053571> : 1f 08 ff 04 00             load.ref <@04ff08> ;Math.sum(data: float64[]): float64
	<.main+9615 @053576> : 02                         call
	<.main+9616 @053577> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9619 @05357a> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:46: (115 bytes: <@05357e> - <@0535f1>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9623 @05357e> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9632 @053587> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9641 @053590> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9650 @053599> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9659 @0535a2> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9668 @0535ab> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9677 @0535b4> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9686 @0535bd> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9695 @0535c6> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9704 @0535cf> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9713 @0535d8> : 1c 0a 00 00 00             load.c32 10
	<.main+9718 @0535dd> : 0a 04 00 00                load.sp(+4)
	<.main+9722 @0535e1> : 1a                         load.z64
	<.main+9723 @0535e2> : 11 02                      dup.x2 sp(2)
	<.main+9725 @0535e4> : 1f 08 ff 04 00             load.ref <@04ff08> ;Math.sum(data: float64[]): float64
	<.main+9730 @0535e9> : 02                         call
	<.main+9731 @0535ea> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9734 @0535ed> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:48: (9 bytes: <@0535f1> - <@0535fa>): testMathEval_x: float64 := 10
	<.main+9738 @0535f1> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:49: (23 bytes: <@0535fa> - <@053611>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9747 @0535fa> : 19                         load.z32
	<.main+9748 @0535fb> : 0a 04 00 00                load.sp(+4)
	<.main+9752 @0535ff> : 1a                         load.z64
	<.main+9753 @053600> : 11 04                      dup.x2 sp(4)
	<.main+9755 @053602> : 11 04                      dup.x2 sp(4)
	<.main+9757 @053604> : 1f 30 ff 04 00             load.ref <@04ff30> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9762 @053609> : 02                         call
	<.main+9763 @05360a> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9766 @05360d> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:50: (9 bytes: <@053611> - <@05361a>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9770 @053611> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:51: (22 bytes: <@05361a> - <@053630>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9779 @05361a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9788 @053623> : 11 06                      dup.x2 sp(6)
	<.main+9790 @053625> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9799 @05362e> : 83                         mul.f64
	<.main+9800 @05362f> : 81                         add.f64
	test/stdc/test.math.ci:52: (39 bytes: <@053630> - <@053657>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9801 @053630> : 11 06                      dup.x2 sp(6)
	<.main+9803 @053632> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9812 @05363b> : 11 02                      dup.x2 sp(2)
	<.main+9814 @05363d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9823 @053646> : 11 06                      dup.x2 sp(6)
	<.main+9825 @053648> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9834 @053651> : 83                         mul.f64
	<.main+9835 @053652> : 81                         add.f64
	<.main+9836 @053653> : 83                         mul.f64
	<.main+9837 @053654> : 81                         add.f64
	<.main+9838 @053655> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:53: (56 bytes: <@053657> - <@05368f>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9840 @053657> : 11 08                      dup.x2 sp(8)
	<.main+9842 @053659> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9851 @053662> : 11 02                      dup.x2 sp(2)
	<.main+9853 @053664> : 11 04                      dup.x2 sp(4)
	<.main+9855 @053666> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9864 @05366f> : 11 02                      dup.x2 sp(2)
	<.main+9866 @053671> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9875 @05367a> : 11 06                      dup.x2 sp(6)
	<.main+9877 @05367c> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9886 @053685> : 83                         mul.f64
	<.main+9887 @053686> : 81                         add.f64
	<.main+9888 @053687> : 83                         mul.f64
	<.main+9889 @053688> : 81                         add.f64
	<.main+9890 @053689> : 14 02                      set.x2 sp(2)
	<.main+9892 @05368b> : 83                         mul.f64
	<.main+9893 @05368c> : 81                         add.f64
	<.main+9894 @05368d> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:54: (72 bytes: <@05368f> - <@0536d7>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9896 @05368f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9905 @053698> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9914 @0536a1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9923 @0536aa> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9932 @0536b3> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9941 @0536bc> : 1c 05 00 00 00             load.c32 5
	<.main+9946 @0536c1> : 0a 04 00 00                load.sp(+4)
	<.main+9950 @0536c5> : 1a                         load.z64
	<.main+9951 @0536c6> : 11 18                      dup.x2 sp(24)
	<.main+9953 @0536c8> : 11 04                      dup.x2 sp(4)
	<.main+9955 @0536ca> : 1f 30 ff 04 00             load.ref <@04ff30> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9960 @0536cf> : 02                         call
	<.main+9961 @0536d0> : 17 10 04                   mov.x2 sp(16, 4)
	<.main+9964 @0536d3> : 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:55: (81 bytes: <@0536d7> - <@053728>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9968 @0536d7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9977 @0536e0> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9986 @0536e9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9995 @0536f2> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10004 @0536fb>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10013 @053704>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10022 @05370d>: 1c 06 00 00 00             load.c32 6
	<.main+10027 @053712>: 0a 04 00 00                load.sp(+4)
	<.main+10031 @053716>: 1a                         load.z64
	<.main+10032 @053717>: 11 1c                      dup.x2 sp(28)
	<.main+10034 @053719>: 11 04                      dup.x2 sp(4)
	<.main+10036 @05371b>: 1f 30 ff 04 00             load.ref <@04ff30> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10041 @053720>: 02                         call
	<.main+10042 @053721>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10045 @053724>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:57: (31 bytes: <@053728> - <@053747>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10049 @053728>: 1a                         load.z64
	<.main+10050 @053729>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10059 @053732>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10068 @05373b>: 84                         div.f64
	<.main+10069 @05373c>: 19                         load.z32
	<.main+10070 @05373d>: 1f e0 ff 04 00             load.ref <@04ffe0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10075 @053742>: 02                         call
	<.main+10076 @053743>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:58: (45 bytes: <@053747> - <@053774>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10080 @053747>: 1b                         load.z128
	<.main+10081 @053748>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10090 @053751>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10099 @05375a>: 84                         div.f64
	<.main+10100 @05375b>: 1f 80 fd 04 00             load.ref <@04fd80> ;Math.abs(x: float64): float64
	<.main+10105 @053760>: 02                         call
	<.main+10106 @053761>: 09 f8 ff ff                inc.sp(-8)
	<.main+10110 @053765>: 1c 01 00 00 00             load.c32 1
	<.main+10115 @05376a>: 1f e0 ff 04 00             load.ref <@04ffe0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10120 @05376f>: 02                         call
	<.main+10121 @053770>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:59: (30 bytes: <@053774> - <@053792>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10125 @053774>: 1a                         load.z64
	<.main+10126 @053775>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10135 @05377e>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10144 @053787>: 84                         div.f64
	<.main+10145 @053788>: 1f 30 01 05 00             load.ref <@050130> ;Math.tan(arg: float64): float64
	<.main+10150 @05378d>: 02                         call
	<.main+10151 @05378e>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:60: (30 bytes: <@053792> - <@0537b0>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10155 @053792>: 1a                         load.z64
	<.main+10156 @053793>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10165 @05379c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10174 @0537a5>: 84                         div.f64
	<.main+10175 @0537a6>: 1f a8 02 05 00             load.ref <@0502a8> ;Math.sinh(x: float64): float64
	<.main+10180 @0537ab>: 02                         call
	<.main+10181 @0537ac>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:61: (30 bytes: <@0537b0> - <@0537ce>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10185 @0537b0>: 1a                         load.z64
	<.main+10186 @0537b1>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10195 @0537ba>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10204 @0537c3>: 84                         div.f64
	<.main+10205 @0537c4>: 1f a0 03 05 00             load.ref <@0503a0> ;Math.cosh(x: float64): float64
	<.main+10210 @0537c9>: 02                         call
	<.main+10211 @0537ca>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (20 bytes: <@0537ce> - <@0537e2>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10215 @0537ce>: 1a                         load.z64
	<.main+10216 @0537cf>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10225 @0537d8>: 1f f0 03 05 00             load.ref <@0503f0> ;Math.asin(x: float64): float64
	<.main+10230 @0537dd>: 02                         call
	<.main+10231 @0537de>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:64: (40 bytes: <@0537e2> - <@05380a>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10235 @0537e2>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10244 @0537eb>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10253 @0537f4>: 84                         div.f64
	<.main+10254 @0537f5>: 1a                         load.z64
	<.main+10255 @0537f6>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10264 @0537ff>: 1f f0 03 05 00             load.ref <@0503f0> ;Math.asin(x: float64): float64
	<.main+10269 @053804>: 02                         call
	<.main+10270 @053805>: 09 f8 ff ff                inc.sp(-8)
	<.main+10274 @053809>: 82                         sub.f64
	test/stdc/test.math.ci:67: (28 bytes: <@05380a> - <@053826>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10275 @05380a>: 19                         load.z32
	<.main+10276 @05380b>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10281 @053810>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10286 @053815>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10291 @05381a>: 1f 60 ff 04 00             load.ref <@04ff60> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10296 @05381f>: 02                         call
	<.main+10297 @053820>: 09 f4 ff ff                inc.sp(-12)
	<.main+10301 @053824>: 19                         load.z32
	<.main+10302 @053825>: 57                         ceq.i32
	test/stdc/test.math.ci:68: (40 bytes: <@053826> - <@05384e>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10303 @053826>: 19                         load.z32
	<.main+10304 @053827>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10313 @053830>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10322 @053839>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10331 @053842>: 1f a0 ff 04 00             load.ref <@04ffa0> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10336 @053847>: 02                         call
	<.main+10337 @053848>: 09 e8 ff ff                inc.sp(-24)
	<.main+10341 @05384c>: 19                         load.z32
	<.main+10342 @05384d>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (29 bytes: <@05384e> - <@05386b>): testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10343 @05384e>: 1a                         load.z64
	<.main+10344 @05384f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10353 @053858>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10362 @053861>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10367 @053866>: 02                         call
	<.main+10368 @053867>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:71: (20 bytes: <@05386b> - <@05387f>): testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+10372 @05386b>: 1b                         load.z128
	<.main+10373 @05386c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10382 @053875>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10387 @05387a>: 02                         call
	<.main+10388 @05387b>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:72: (29 bytes: <@05387f> - <@05389c>): testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+10392 @05387f>: 1a                         load.z64
	<.main+10393 @053880>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+10402 @053889>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10411 @053892>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10416 @053897>: 02                         call
	<.main+10417 @053898>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:74: (29 bytes: <@05389c> - <@0538b9>): testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+10421 @05389c>: 1a                         load.z64
	<.main+10422 @05389d>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+10431 @0538a6>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10440 @0538af>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10445 @0538b4>: 02                         call
	<.main+10446 @0538b5>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:75: (29 bytes: <@0538b9> - <@0538d6>): testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+10450 @0538b9>: 1a                         load.z64
	<.main+10451 @0538ba>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10460 @0538c3>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10469 @0538cc>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10474 @0538d1>: 02                         call
	<.main+10475 @0538d2>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:76: (29 bytes: <@0538d6> - <@0538f3>): testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+10479 @0538d6>: 1a                         load.z64
	<.main+10480 @0538d7>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+10489 @0538e0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10498 @0538e9>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10503 @0538ee>: 02                         call
	<.main+10504 @0538ef>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:77: (29 bytes: <@0538f3> - <@053910>): testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+10508 @0538f3>: 1a                         load.z64
	<.main+10509 @0538f4>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+10518 @0538fd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10527 @053906>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10532 @05390b>: 02                         call
	<.main+10533 @05390c>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:79: (29 bytes: <@053910> - <@05392d>): testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+10537 @053910>: 1a                         load.z64
	<.main+10538 @053911>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+10547 @05391a>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10556 @053923>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10561 @053928>: 02                         call
	<.main+10562 @053929>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:80: (29 bytes: <@05392d> - <@05394a>): testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+10566 @05392d>: 1a                         load.z64
	<.main+10567 @05392e>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10576 @053937>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10585 @053940>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10590 @053945>: 02                         call
	<.main+10591 @053946>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:81: (29 bytes: <@05394a> - <@053967>): testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+10595 @05394a>: 1a                         load.z64
	<.main+10596 @05394b>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+10605 @053954>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10614 @05395d>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10619 @053962>: 02                         call
	<.main+10620 @053963>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:82: (29 bytes: <@053967> - <@053984>): testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+10624 @053967>: 1a                         load.z64
	<.main+10625 @053968>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+10634 @053971>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10643 @05397a>: 1f b8 fd 04 00             load.ref <@04fdb8> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10648 @05397f>: 02                         call
	<.main+10649 @053980>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:84: (21 bytes: <@053984> - <@053999>): testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+10653 @053984>: 19                         load.z32
	<.main+10654 @053985>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10659 @05398a>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10664 @05398f>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10669 @053994>: 02                         call
	<.main+10670 @053995>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:85: (17 bytes: <@053999> - <@0539aa>): testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+10674 @053999>: 19                         load.z32
	<.main+10675 @05399a>: 19                         load.z32
	<.main+10676 @05399b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10681 @0539a0>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10686 @0539a5>: 02                         call
	<.main+10687 @0539a6>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:86: (21 bytes: <@0539aa> - <@0539bf>): testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+10691 @0539aa>: 19                         load.z32
	<.main+10692 @0539ab>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+10697 @0539b0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10702 @0539b5>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10707 @0539ba>: 02                         call
	<.main+10708 @0539bb>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:88: (21 bytes: <@0539bf> - <@0539d4>): testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+10712 @0539bf>: 19                         load.z32
	<.main+10713 @0539c0>: 7f 00 00 98 41             load.f32 19.000000
	<.main+10718 @0539c5>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10723 @0539ca>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10728 @0539cf>: 02                         call
	<.main+10729 @0539d0>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:89: (21 bytes: <@0539d4> - <@0539e9>): testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+10733 @0539d4>: 19                         load.z32
	<.main+10734 @0539d5>: 7f 00 00 10 41             load.f32 9.000000
	<.main+10739 @0539da>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10744 @0539df>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10749 @0539e4>: 02                         call
	<.main+10750 @0539e5>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:90: (21 bytes: <@0539e9> - <@0539fe>): testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+10754 @0539e9>: 19                         load.z32
	<.main+10755 @0539ea>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+10760 @0539ef>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10765 @0539f4>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10770 @0539f9>: 02                         call
	<.main+10771 @0539fa>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:91: (21 bytes: <@0539fe> - <@053a13>): testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+10775 @0539fe>: 19                         load.z32
	<.main+10776 @0539ff>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+10781 @053a04>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10786 @053a09>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10791 @053a0e>: 02                         call
	<.main+10792 @053a0f>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:93: (21 bytes: <@053a13> - <@053a28>): testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+10796 @053a13>: 19                         load.z32
	<.main+10797 @053a14>: 7f 00 00 90 41             load.f32 18.000000
	<.main+10802 @053a19>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10807 @053a1e>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10812 @053a23>: 02                         call
	<.main+10813 @053a24>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:94: (21 bytes: <@053a28> - <@053a3d>): testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+10817 @053a28>: 19                         load.z32
	<.main+10818 @053a29>: 7f 00 00 00 41             load.f32 8.000000
	<.main+10823 @053a2e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10828 @053a33>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10833 @053a38>: 02                         call
	<.main+10834 @053a39>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:95: (21 bytes: <@053a3d> - <@053a52>): testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+10838 @053a3d>: 19                         load.z32
	<.main+10839 @053a3e>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+10844 @053a43>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10849 @053a48>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10854 @053a4d>: 02                         call
	<.main+10855 @053a4e>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:96: (21 bytes: <@053a52> - <@053a67>): testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+10859 @053a52>: 19                         load.z32
	<.main+10860 @053a53>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+10865 @053a58>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10870 @053a5d>: 1f 98 fd 04 00             load.ref <@04fd98> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10875 @053a62>: 02                         call
	<.main+10876 @053a63>: 09 f8 ff ff                inc.sp(-8)
	<.main+10880 @053a67>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 238.56] > .main
[ 239.06]  > funAdd(x: int32, y: int32): int32
[ 239.07]  < return
[ 239.08]  > funAdd(x: int32, y: int32): int32
[ 239.11]  < return
[ 239.14]  > funMul(x: int32, y: int32): int32
[ 239.15]  < return
[ 239.16]  > funMul(x: int32, y: int32): int32
[ 239.17]  < return
[ 239.18]  > fib(n: uint32): uint32
[ 239.19]   > fib(n: uint32): uint32
[ 239.20]    > fib(n: uint32): uint32
[ 239.21]     > fib(n: uint32): uint32
[ 239.22]      > fib(n: uint32): uint32
[ 239.23]       > fib(n: uint32): uint32
[ 239.24]        > fib(n: uint32): uint32
[ 239.25]         > fib(n: uint32): uint32
[ 239.26]          > fib(n: uint32): uint32
[ 239.28]           > fib(n: uint32): uint32
[ 239.29]            > fib(n: uint32): uint32
[ 239.30]             > fib(n: uint32): uint32
[ 239.31]              > fib(n: uint32): uint32
[ 239.32]              < return
[ 239.32]              > fib(n: uint32): uint32
[ 239.33]              < return
[ 239.34]             < return
[ 239.35]             > fib(n: uint32): uint32
[ 239.36]             < return
[ 239.37]            < return
[ 239.37]            > fib(n: uint32): uint32
[ 239.38]             > fib(n: uint32): uint32
[ 239.39]             < return
[ 239.40]             > fib(n: uint32): uint32
[ 239.41]             < return
[ 239.42]            < return
[ 239.43]           < return
[ 239.43]           > fib(n: uint32): uint32
[ 239.44]            > fib(n: uint32): uint32
[ 239.46]             > fib(n: uint32): uint32
[ 239.47]             < return
[ 239.47]             > fib(n: uint32): uint32
[ 239.48]             < return
[ 239.49]            < return
[ 239.50]            > fib(n: uint32): uint32
[ 239.51]            < return
[ 239.51]           < return
[ 239.52]          < return
[ 239.53]          > fib(n: uint32): uint32
[ 239.54]           > fib(n: uint32): uint32
[ 239.55]            > fib(n: uint32): uint32
[ 239.56]             > fib(n: uint32): uint32
[ 239.57]             < return
[ 239.58]             > fib(n: uint32): uint32
[ 239.59]             < return
[ 239.60]            < return
[ 239.60]            > fib(n: uint32): uint32
[ 239.61]            < return
[ 239.62]           < return
[ 239.63]           > fib(n: uint32): uint32
[ 239.64]            > fib(n: uint32): uint32
[ 239.65]            < return
[ 239.66]            > fib(n: uint32): uint32
[ 239.67]            < return
[ 239.68]           < return
[ 239.68]          < return
[ 239.69]         < return
[ 239.70]         > fib(n: uint32): uint32
[ 239.71]          > fib(n: uint32): uint32
[ 239.72]           > fib(n: uint32): uint32
[ 239.73]            > fib(n: uint32): uint32
[ 239.74]             > fib(n: uint32): uint32
[ 239.75]             < return
[ 239.76]             > fib(n: uint32): uint32
[ 239.77]             < return
[ 239.78]            < return
[ 239.78]            > fib(n: uint32): uint32
[ 239.79]            < return
[ 239.80]           < return
[ 239.81]           > fib(n: uint32): uint32
[ 239.82]            > fib(n: uint32): uint32
[ 239.83]            < return
[ 239.84]            > fib(n: uint32): uint32
[ 239.85]            < return
[ 239.85]           < return
[ 239.86]          < return
[ 239.87]          > fib(n: uint32): uint32
[ 239.88]           > fib(n: uint32): uint32
[ 239.89]            > fib(n: uint32): uint32
[ 239.90]            < return
[ 239.91]            > fib(n: uint32): uint32
[ 239.92]            < return
[ 239.92]           < return
[ 239.93]           > fib(n: uint32): uint32
[ 239.94]           < return
[ 239.95]          < return
[ 239.96]         < return
[ 239.96]        < return
[ 239.97]        > fib(n: uint32): uint32
[ 239.98]         > fib(n: uint32): uint32
[ 239.99]          > fib(n: uint32): uint32
[ 240.00]           > fib(n: uint32): uint32
[ 240.01]            > fib(n: uint32): uint32
[ 240.03]             > fib(n: uint32): uint32
[ 240.03]             < return
[ 240.04]             > fib(n: uint32): uint32
[ 240.05]             < return
[ 240.06]            < return
[ 240.07]            > fib(n: uint32): uint32
[ 240.08]            < return
[ 240.08]           < return
[ 240.09]           > fib(n: uint32): uint32
[ 240.10]            > fib(n: uint32): uint32
[ 240.11]            < return
[ 240.12]            > fib(n: uint32): uint32
[ 240.13]            < return
[ 240.13]           < return
[ 240.14]          < return
[ 240.15]          > fib(n: uint32): uint32
[ 240.16]           > fib(n: uint32): uint32
[ 240.17]            > fib(n: uint32): uint32
[ 240.18]            < return
[ 240.19]            > fib(n: uint32): uint32
[ 240.20]            < return
[ 240.21]           < return
[ 240.21]           > fib(n: uint32): uint32
[ 240.22]           < return
[ 240.23]          < return
[ 240.24]         < return
[ 240.25]         > fib(n: uint32): uint32
[ 240.25]          > fib(n: uint32): uint32
[ 240.27]           > fib(n: uint32): uint32
[ 240.28]            > fib(n: uint32): uint32
[ 240.29]            < return
[ 240.29]            > fib(n: uint32): uint32
[ 240.30]            < return
[ 240.31]           < return
[ 240.32]           > fib(n: uint32): uint32
[ 240.33]           < return
[ 240.34]          < return
[ 240.34]          > fib(n: uint32): uint32
[ 240.35]           > fib(n: uint32): uint32
[ 240.36]           < return
[ 240.37]           > fib(n: uint32): uint32
[ 240.38]           < return
[ 240.39]          < return
[ 240.40]         < return
[ 240.40]        < return
[ 240.41]       < return
[ 240.42]       > fib(n: uint32): uint32
[ 240.43]        > fib(n: uint32): uint32
[ 240.44]         > fib(n: uint32): uint32
[ 240.45]          > fib(n: uint32): uint32
[ 240.46]           > fib(n: uint32): uint32
[ 240.47]            > fib(n: uint32): uint32
[ 240.48]             > fib(n: uint32): uint32
[ 240.49]             < return
[ 240.50]             > fib(n: uint32): uint32
[ 240.51]             < return
[ 240.52]            < return
[ 240.52]            > fib(n: uint32): uint32
[ 240.53]            < return
[ 240.54]           < return
[ 240.55]           > fib(n: uint32): uint32
[ 240.56]            > fib(n: uint32): uint32
[ 240.57]            < return
[ 240.58]            > fib(n: uint32): uint32
[ 240.59]            < return
[ 240.60]           < return
[ 240.60]          < return
[ 240.61]          > fib(n: uint32): uint32
[ 240.62]           > fib(n: uint32): uint32
[ 240.63]            > fib(n: uint32): uint32
[ 240.64]            < return
[ 240.65]            > fib(n: uint32): uint32
[ 240.66]            < return
[ 240.67]           < return
[ 240.67]           > fib(n: uint32): uint32
[ 240.68]           < return
[ 240.69]          < return
[ 240.70]         < return
[ 240.71]         > fib(n: uint32): uint32
[ 240.73]          > fib(n: uint32): uint32
[ 240.74]           > fib(n: uint32): uint32
[ 240.75]            > fib(n: uint32): uint32
[ 240.76]            < return
[ 240.77]            > fib(n: uint32): uint32
[ 240.78]            < return
[ 240.78]           < return
[ 240.79]           > fib(n: uint32): uint32
[ 240.82]           < return
[ 240.82]          < return
[ 240.85]          > fib(n: uint32): uint32
[ 240.88]           > fib(n: uint32): uint32
[ 240.89]           < return
[ 240.90]           > fib(n: uint32): uint32
[ 240.91]           < return
[ 240.93]          < return
[ 240.93]         < return
[ 240.95]        < return
[ 240.96]        > fib(n: uint32): uint32
[ 240.97]         > fib(n: uint32): uint32
[ 240.98]          > fib(n: uint32): uint32
[ 240.99]           > fib(n: uint32): uint32
[ 241.00]            > fib(n: uint32): uint32
[ 241.01]            < return
[ 241.02]            > fib(n: uint32): uint32
[ 241.03]            < return
[ 241.04]           < return
[ 241.05]           > fib(n: uint32): uint32
[ 241.06]           < return
[ 241.06]          < return
[ 241.07]          > fib(n: uint32): uint32
[ 241.08]           > fib(n: uint32): uint32
[ 241.09]           < return
[ 241.10]           > fib(n: uint32): uint32
[ 241.11]           < return
[ 241.12]          < return
[ 241.12]         < return
[ 241.13]         > fib(n: uint32): uint32
[ 241.14]          > fib(n: uint32): uint32
[ 241.15]           > fib(n: uint32): uint32
[ 241.17]           < return
[ 241.18]           > fib(n: uint32): uint32
[ 241.21]           < return
[ 241.23]          < return
[ 241.25]          > fib(n: uint32): uint32
[ 241.26]          < return
[ 241.27]         < return
[ 241.28]        < return
[ 241.28]       < return
[ 241.29]      < return
[ 241.30]      > fib(n: uint32): uint32
[ 241.33]       > fib(n: uint32): uint32
[ 241.34]        > fib(n: uint32): uint32
[ 241.35]         > fib(n: uint32): uint32
[ 241.38]          > fib(n: uint32): uint32
[ 241.39]           > fib(n: uint32): uint32
[ 241.40]            > fib(n: uint32): uint32
[ 241.41]             > fib(n: uint32): uint32
[ 241.42]             < return
[ 241.42]             > fib(n: uint32): uint32
[ 241.43]             < return
[ 241.44]            < return
[ 241.45]            > fib(n: uint32): uint32
[ 241.46]            < return
[ 241.46]           < return
[ 241.47]           > fib(n: uint32): uint32
[ 241.48]            > fib(n: uint32): uint32
[ 241.49]            < return
[ 241.50]            > fib(n: uint32): uint32
[ 241.51]            < return
[ 241.51]           < return
[ 241.52]          < return
[ 241.53]          > fib(n: uint32): uint32
[ 241.56]           > fib(n: uint32): uint32
[ 241.58]            > fib(n: uint32): uint32
[ 241.59]            < return
[ 241.60]            > fib(n: uint32): uint32
[ 241.61]            < return
[ 241.62]           < return
[ 241.62]           > fib(n: uint32): uint32
[ 241.63]           < return
[ 241.64]          < return
[ 241.65]         < return
[ 241.66]         > fib(n: uint32): uint32
[ 241.67]          > fib(n: uint32): uint32
[ 241.68]           > fib(n: uint32): uint32
[ 241.69]            > fib(n: uint32): uint32
[ 241.70]            < return
[ 241.71]            > fib(n: uint32): uint32
[ 241.72]            < return
[ 241.72]           < return
[ 241.73]           > fib(n: uint32): uint32
[ 241.74]           < return
[ 241.75]          < return
[ 241.75]          > fib(n: uint32): uint32
[ 241.76]           > fib(n: uint32): uint32
[ 241.79]           < return
[ 241.79]           > fib(n: uint32): uint32
[ 241.81]           < return
[ 241.81]          < return
[ 241.82]         < return
[ 241.83]        < return
[ 241.84]        > fib(n: uint32): uint32
[ 241.85]         > fib(n: uint32): uint32
[ 241.86]          > fib(n: uint32): uint32
[ 241.87]           > fib(n: uint32): uint32
[ 241.88]            > fib(n: uint32): uint32
[ 241.89]            < return
[ 241.90]            > fib(n: uint32): uint32
[ 241.91]            < return
[ 241.91]           < return
[ 241.92]           > fib(n: uint32): uint32
[ 241.95]           < return
[ 241.97]          < return
[ 241.98]          > fib(n: uint32): uint32
[ 241.99]           > fib(n: uint32): uint32
[ 242.00]           < return
[ 242.00]           > fib(n: uint32): uint32
[ 242.01]           < return
[ 242.02]          < return
[ 242.03]         < return
[ 242.03]         > fib(n: uint32): uint32
[ 242.05]          > fib(n: uint32): uint32
[ 242.06]           > fib(n: uint32): uint32
[ 242.07]           < return
[ 242.07]           > fib(n: uint32): uint32
[ 242.10]           < return
[ 242.10]          < return
[ 242.11]          > fib(n: uint32): uint32
[ 242.12]          < return
[ 242.13]         < return
[ 242.13]        < return
[ 242.14]       < return
[ 242.15]       > fib(n: uint32): uint32
[ 242.16]        > fib(n: uint32): uint32
[ 242.17]         > fib(n: uint32): uint32
[ 242.18]          > fib(n: uint32): uint32
[ 242.19]           > fib(n: uint32): uint32
[ 242.20]            > fib(n: uint32): uint32
[ 242.21]            < return
[ 242.22]            > fib(n: uint32): uint32
[ 242.23]            < return
[ 242.24]           < return
[ 242.24]           > fib(n: uint32): uint32
[ 242.27]           < return
[ 242.28]          < return
[ 242.28]          > fib(n: uint32): uint32
[ 242.29]           > fib(n: uint32): uint32
[ 242.32]           < return
[ 242.33]           > fib(n: uint32): uint32
[ 242.34]           < return
[ 242.34]          < return
[ 242.35]         < return
[ 242.36]         > fib(n: uint32): uint32
[ 242.37]          > fib(n: uint32): uint32
[ 242.38]           > fib(n: uint32): uint32
[ 242.39]           < return
[ 242.40]           > fib(n: uint32): uint32
[ 242.40]           < return
[ 242.41]          < return
[ 242.42]          > fib(n: uint32): uint32
[ 242.43]          < return
[ 242.44]         < return
[ 242.44]        < return
[ 242.45]        > fib(n: uint32): uint32
[ 242.46]         > fib(n: uint32): uint32
[ 242.47]          > fib(n: uint32): uint32
[ 242.48]           > fib(n: uint32): uint32
[ 242.49]           < return
[ 242.50]           > fib(n: uint32): uint32
[ 242.51]           < return
[ 242.51]          < return
[ 242.52]          > fib(n: uint32): uint32
[ 242.53]          < return
[ 242.54]         < return
[ 242.54]         > fib(n: uint32): uint32
[ 242.56]          > fib(n: uint32): uint32
[ 242.56]          < return
[ 242.57]          > fib(n: uint32): uint32
[ 242.58]          < return
[ 242.59]         < return
[ 242.59]        < return
[ 242.60]       < return
[ 242.61]      < return
[ 242.63]     < return
[ 242.64]     > fib(n: uint32): uint32
[ 242.65]      > fib(n: uint32): uint32
[ 242.66]       > fib(n: uint32): uint32
[ 242.69]        > fib(n: uint32): uint32
[ 242.70]         > fib(n: uint32): uint32
[ 242.71]          > fib(n: uint32): uint32
[ 242.72]           > fib(n: uint32): uint32
[ 242.73]            > fib(n: uint32): uint32
[ 242.74]             > fib(n: uint32): uint32
[ 242.75]             < return
[ 242.76]             > fib(n: uint32): uint32
[ 242.77]             < return
[ 242.77]            < return
[ 242.78]            > fib(n: uint32): uint32
[ 242.79]            < return
[ 242.80]           < return
[ 242.81]           > fib(n: uint32): uint32
[ 242.82]            > fib(n: uint32): uint32
[ 242.82]            < return
[ 242.83]            > fib(n: uint32): uint32
[ 242.84]            < return
[ 242.85]           < return
[ 242.86]          < return
[ 242.86]          > fib(n: uint32): uint32
[ 242.89]           > fib(n: uint32): uint32
[ 242.90]            > fib(n: uint32): uint32
[ 242.92]            < return
[ 242.92]            > fib(n: uint32): uint32
[ 242.93]            < return
[ 242.94]           < return
[ 242.95]           > fib(n: uint32): uint32
[ 242.96]           < return
[ 242.97]          < return
[ 242.97]         < return
[ 242.99]         > fib(n: uint32): uint32
[ 243.00]          > fib(n: uint32): uint32
[ 243.01]           > fib(n: uint32): uint32
[ 243.03]            > fib(n: uint32): uint32
[ 243.03]            < return
[ 243.04]            > fib(n: uint32): uint32
[ 243.05]            < return
[ 243.06]           < return
[ 243.07]           > fib(n: uint32): uint32
[ 243.08]           < return
[ 243.08]          < return
[ 243.09]          > fib(n: uint32): uint32
[ 243.10]           > fib(n: uint32): uint32
[ 243.12]           < return
[ 243.13]           > fib(n: uint32): uint32
[ 243.14]           < return
[ 243.15]          < return
[ 243.16]         < return
[ 243.16]        < return
[ 243.17]        > fib(n: uint32): uint32
[ 243.18]         > fib(n: uint32): uint32
[ 243.19]          > fib(n: uint32): uint32
[ 243.20]           > fib(n: uint32): uint32
[ 243.21]            > fib(n: uint32): uint32
[ 243.22]            < return
[ 243.23]            > fib(n: uint32): uint32
[ 243.24]            < return
[ 243.24]           < return
[ 243.25]           > fib(n: uint32): uint32
[ 243.28]           < return
[ 243.29]          < return
[ 243.31]          > fib(n: uint32): uint32
[ 243.32]           > fib(n: uint32): uint32
[ 243.33]           < return
[ 243.34]           > fib(n: uint32): uint32
[ 243.34]           < return
[ 243.35]          < return
[ 243.36]         < return
[ 243.37]         > fib(n: uint32): uint32
[ 243.39]          > fib(n: uint32): uint32
[ 243.40]           > fib(n: uint32): uint32
[ 243.41]           < return
[ 243.42]           > fib(n: uint32): uint32
[ 243.43]           < return
[ 243.43]          < return
[ 243.44]          > fib(n: uint32): uint32
[ 243.45]          < return
[ 243.46]         < return
[ 243.46]        < return
[ 243.47]       < return
[ 243.48]       > fib(n: uint32): uint32
[ 243.49]        > fib(n: uint32): uint32
[ 243.50]         > fib(n: uint32): uint32
[ 243.51]          > fib(n: uint32): uint32
[ 243.52]           > fib(n: uint32): uint32
[ 243.53]            > fib(n: uint32): uint32
[ 243.54]            < return
[ 243.57]            > fib(n: uint32): uint32
[ 243.59]            < return
[ 243.60]           < return
[ 243.61]           > fib(n: uint32): uint32
[ 243.64]           < return
[ 243.66]          < return
[ 243.67]          > fib(n: uint32): uint32
[ 243.68]           > fib(n: uint32): uint32
[ 243.69]           < return
[ 243.70]           > fib(n: uint32): uint32
[ 243.71]           < return
[ 243.72]          < return
[ 243.72]         < return
[ 243.73]         > fib(n: uint32): uint32
[ 243.74]          > fib(n: uint32): uint32
[ 243.77]           > fib(n: uint32): uint32
[ 243.78]           < return
[ 243.79]           > fib(n: uint32): uint32
[ 243.80]           < return
[ 243.81]          < return
[ 243.82]          > fib(n: uint32): uint32
[ 243.83]          < return
[ 243.84]         < return
[ 243.85]        < return
[ 243.86]        > fib(n: uint32): uint32
[ 243.88]         > fib(n: uint32): uint32
[ 243.89]          > fib(n: uint32): uint32
[ 243.91]           > fib(n: uint32): uint32
[ 243.92]           < return
[ 243.93]           > fib(n: uint32): uint32
[ 243.94]           < return
[ 243.97]          < return
[ 243.98]          > fib(n: uint32): uint32
[ 243.99]          < return
[ 244.00]         < return
[ 244.01]         > fib(n: uint32): uint32
[ 244.04]          > fib(n: uint32): uint32
[ 244.07]          < return
[ 244.08]          > fib(n: uint32): uint32
[ 244.09]          < return
[ 244.10]         < return
[ 244.11]        < return
[ 244.12]       < return
[ 244.13]      < return
[ 244.16]      > fib(n: uint32): uint32
[ 244.17]       > fib(n: uint32): uint32
[ 244.18]        > fib(n: uint32): uint32
[ 244.20]         > fib(n: uint32): uint32
[ 244.21]          > fib(n: uint32): uint32
[ 244.23]           > fib(n: uint32): uint32
[ 244.25]            > fib(n: uint32): uint32
[ 244.26]            < return
[ 244.27]            > fib(n: uint32): uint32
[ 244.28]            < return
[ 244.29]           < return
[ 244.30]           > fib(n: uint32): uint32
[ 244.31]           < return
[ 244.34]          < return
[ 244.35]          > fib(n: uint32): uint32
[ 244.37]           > fib(n: uint32): uint32
[ 244.38]           < return
[ 244.39]           > fib(n: uint32): uint32
[ 244.40]           < return
[ 244.41]          < return
[ 244.42]         < return
[ 244.43]         > fib(n: uint32): uint32
[ 244.46]          > fib(n: uint32): uint32
[ 244.48]           > fib(n: uint32): uint32
[ 244.49]           < return
[ 244.50]           > fib(n: uint32): uint32
[ 244.51]           < return
[ 244.52]          < return
[ 244.53]          > fib(n: uint32): uint32
[ 244.56]          < return
[ 244.57]         < return
[ 244.57]        < return
[ 244.58]        > fib(n: uint32): uint32
[ 244.60]         > fib(n: uint32): uint32
[ 244.61]          > fib(n: uint32): uint32
[ 244.63]           > fib(n: uint32): uint32
[ 244.64]           < return
[ 244.65]           > fib(n: uint32): uint32
[ 244.66]           < return
[ 244.67]          < return
[ 244.68]          > fib(n: uint32): uint32
[ 244.69]          < return
[ 244.70]         < return
[ 244.73]         > fib(n: uint32): uint32
[ 244.74]          > fib(n: uint32): uint32
[ 244.77]          < return
[ 244.78]          > fib(n: uint32): uint32
[ 244.82]          < return
[ 244.83]         < return
[ 244.84]        < return
[ 244.84]       < return
[ 244.85]       > fib(n: uint32): uint32
[ 244.86]        > fib(n: uint32): uint32
[ 244.87]         > fib(n: uint32): uint32
[ 244.90]          > fib(n: uint32): uint32
[ 244.91]           > fib(n: uint32): uint32
[ 244.92]           < return
[ 244.92]           > fib(n: uint32): uint32
[ 244.93]           < return
[ 244.94]          < return
[ 244.95]          > fib(n: uint32): uint32
[ 244.96]          < return
[ 244.96]         < return
[ 244.97]         > fib(n: uint32): uint32
[ 244.98]          > fib(n: uint32): uint32
[ 244.99]          < return
[ 245.00]          > fib(n: uint32): uint32
[ 245.01]          < return
[ 245.02]         < return
[ 245.02]        < return
[ 245.03]        > fib(n: uint32): uint32
[ 245.04]         > fib(n: uint32): uint32
[ 245.05]          > fib(n: uint32): uint32
[ 245.06]          < return
[ 245.07]          > fib(n: uint32): uint32
[ 245.10]          < return
[ 245.12]         < return
[ 245.12]         > fib(n: uint32): uint32
[ 245.13]         < return
[ 245.14]        < return
[ 245.15]       < return
[ 245.16]      < return
[ 245.19]     < return
[ 245.19]    < return
[ 245.20]    > fib(n: uint32): uint32
[ 245.23]     > fib(n: uint32): uint32
[ 245.24]      > fib(n: uint32): uint32
[ 245.25]       > fib(n: uint32): uint32
[ 245.26]        > fib(n: uint32): uint32
[ 245.28]         > fib(n: uint32): uint32
[ 245.30]          > fib(n: uint32): uint32
[ 245.31]           > fib(n: uint32): uint32
[ 245.32]            > fib(n: uint32): uint32
[ 245.33]             > fib(n: uint32): uint32
[ 245.34]             < return
[ 245.35]             > fib(n: uint32): uint32
[ 245.35]             < return
[ 245.36]            < return
[ 245.37]            > fib(n: uint32): uint32
[ 245.38]            < return
[ 245.39]           < return
[ 245.39]           > fib(n: uint32): uint32
[ 245.40]            > fib(n: uint32): uint32
[ 245.41]            < return
[ 245.42]            > fib(n: uint32): uint32
[ 245.43]            < return
[ 245.44]           < return
[ 245.44]          < return
[ 245.45]          > fib(n: uint32): uint32
[ 245.46]           > fib(n: uint32): uint32
[ 245.47]            > fib(n: uint32): uint32
[ 245.48]            < return
[ 245.49]            > fib(n: uint32): uint32
[ 245.50]            < return
[ 245.51]           < return
[ 245.51]           > fib(n: uint32): uint32
[ 245.52]           < return
[ 245.55]          < return
[ 245.56]         < return
[ 245.57]         > fib(n: uint32): uint32
[ 245.58]          > fib(n: uint32): uint32
[ 245.60]           > fib(n: uint32): uint32
[ 245.61]            > fib(n: uint32): uint32
[ 245.62]            < return
[ 245.63]            > fib(n: uint32): uint32
[ 245.64]            < return
[ 245.65]           < return
[ 245.65]           > fib(n: uint32): uint32
[ 245.66]           < return
[ 245.67]          < return
[ 245.68]          > fib(n: uint32): uint32
[ 245.69]           > fib(n: uint32): uint32
[ 245.70]           < return
[ 245.70]           > fib(n: uint32): uint32
[ 245.71]           < return
[ 245.72]          < return
[ 245.73]         < return
[ 245.73]        < return
[ 245.74]        > fib(n: uint32): uint32
[ 245.75]         > fib(n: uint32): uint32
[ 245.76]          > fib(n: uint32): uint32
[ 245.77]           > fib(n: uint32): uint32
[ 245.78]            > fib(n: uint32): uint32
[ 245.79]            < return
[ 245.82]            > fib(n: uint32): uint32
[ 245.83]            < return
[ 245.84]           < return
[ 245.84]           > fib(n: uint32): uint32
[ 245.85]           < return
[ 245.86]          < return
[ 245.87]          > fib(n: uint32): uint32
[ 245.88]           > fib(n: uint32): uint32
[ 245.89]           < return
[ 245.90]           > fib(n: uint32): uint32
[ 245.91]           < return
[ 245.91]          < return
[ 245.93]         < return
[ 245.94]         > fib(n: uint32): uint32
[ 245.95]          > fib(n: uint32): uint32
[ 245.96]           > fib(n: uint32): uint32
[ 245.97]           < return
[ 245.98]           > fib(n: uint32): uint32
[ 246.00]           < return
[ 246.02]          < return
[ 246.03]          > fib(n: uint32): uint32
[ 246.04]          < return
[ 246.05]         < return
[ 246.05]        < return
[ 246.06]       < return
[ 246.07]       > fib(n: uint32): uint32
[ 246.08]        > fib(n: uint32): uint32
[ 246.09]         > fib(n: uint32): uint32
[ 246.10]          > fib(n: uint32): uint32
[ 246.11]           > fib(n: uint32): uint32
[ 246.12]            > fib(n: uint32): uint32
[ 246.13]            < return
[ 246.14]            > fib(n: uint32): uint32
[ 246.15]            < return
[ 246.15]           < return
[ 246.16]           > fib(n: uint32): uint32
[ 246.17]           < return
[ 246.18]          < return
[ 246.19]          > fib(n: uint32): uint32
[ 246.20]           > fib(n: uint32): uint32
[ 246.22]           < return
[ 246.25]           > fib(n: uint32): uint32
[ 246.26]           < return
[ 246.26]          < return
[ 246.27]         < return
[ 246.28]         > fib(n: uint32): uint32
[ 246.29]          > fib(n: uint32): uint32
[ 246.30]           > fib(n: uint32): uint32
[ 246.31]           < return
[ 246.33]           > fib(n: uint32): uint32
[ 246.34]           < return
[ 246.35]          < return
[ 246.35]          > fib(n: uint32): uint32
[ 246.36]          < return
[ 246.37]         < return
[ 246.38]        < return
[ 246.38]        > fib(n: uint32): uint32
[ 246.39]         > fib(n: uint32): uint32
[ 246.40]          > fib(n: uint32): uint32
[ 246.41]           > fib(n: uint32): uint32
[ 246.42]           < return
[ 246.43]           > fib(n: uint32): uint32
[ 246.44]           < return
[ 246.45]          < return
[ 246.46]          > fib(n: uint32): uint32
[ 246.46]          < return
[ 246.47]         < return
[ 246.48]         > fib(n: uint32): uint32
[ 246.49]          > fib(n: uint32): uint32
[ 246.50]          < return
[ 246.51]          > fib(n: uint32): uint32
[ 246.51]          < return
[ 246.54]         < return
[ 246.55]        < return
[ 246.55]       < return
[ 246.56]      < return
[ 246.57]      > fib(n: uint32): uint32
[ 246.59]       > fib(n: uint32): uint32
[ 246.60]        > fib(n: uint32): uint32
[ 246.62]         > fib(n: uint32): uint32
[ 246.63]          > fib(n: uint32): uint32
[ 246.64]           > fib(n: uint32): uint32
[ 246.65]            > fib(n: uint32): uint32
[ 246.66]            < return
[ 246.66]            > fib(n: uint32): uint32
[ 246.67]            < return
[ 246.68]           < return
[ 246.69]           > fib(n: uint32): uint32
[ 246.70]           < return
[ 246.71]          < return
[ 246.71]          > fib(n: uint32): uint32
[ 246.72]           > fib(n: uint32): uint32
[ 246.73]           < return
[ 246.74]           > fib(n: uint32): uint32
[ 246.75]           < return
[ 246.76]          < return
[ 246.76]         < return
[ 246.77]         > fib(n: uint32): uint32
[ 246.78]          > fib(n: uint32): uint32
[ 246.79]           > fib(n: uint32): uint32
[ 246.80]           < return
[ 246.81]           > fib(n: uint32): uint32
[ 246.82]           < return
[ 246.83]          < return
[ 246.83]          > fib(n: uint32): uint32
[ 246.84]          < return
[ 246.85]         < return
[ 246.86]        < return
[ 246.86]        > fib(n: uint32): uint32
[ 246.87]         > fib(n: uint32): uint32
[ 246.90]          > fib(n: uint32): uint32
[ 246.91]           > fib(n: uint32): uint32
[ 246.92]           < return
[ 246.93]           > fib(n: uint32): uint32
[ 246.94]           < return
[ 246.96]          < return
[ 246.97]          > fib(n: uint32): uint32
[ 246.98]          < return
[ 246.99]         < return
[ 246.99]         > fib(n: uint32): uint32
[ 247.00]          > fib(n: uint32): uint32
[ 247.01]          < return
[ 247.02]          > fib(n: uint32): uint32
[ 247.03]          < return
[ 247.04]         < return
[ 247.04]        < return
[ 247.05]       < return
[ 247.06]       > fib(n: uint32): uint32
[ 247.07]        > fib(n: uint32): uint32
[ 247.08]         > fib(n: uint32): uint32
[ 247.09]          > fib(n: uint32): uint32
[ 247.10]           > fib(n: uint32): uint32
[ 247.11]           < return
[ 247.12]           > fib(n: uint32): uint32
[ 247.13]           < return
[ 247.14]          < return
[ 247.14]          > fib(n: uint32): uint32
[ 247.15]          < return
[ 247.18]         < return
[ 247.19]         > fib(n: uint32): uint32
[ 247.20]          > fib(n: uint32): uint32
[ 247.21]          < return
[ 247.21]          > fib(n: uint32): uint32
[ 247.22]          < return
[ 247.23]         < return
[ 247.24]        < return
[ 247.25]        > fib(n: uint32): uint32
[ 247.26]         > fib(n: uint32): uint32
[ 247.28]          > fib(n: uint32): uint32
[ 247.29]          < return
[ 247.30]          > fib(n: uint32): uint32
[ 247.31]          < return
[ 247.31]         < return
[ 247.32]         > fib(n: uint32): uint32
[ 247.33]         < return
[ 247.35]        < return
[ 247.37]       < return
[ 247.38]      < return
[ 247.39]     < return
[ 247.39]     > fib(n: uint32): uint32
[ 247.41]      > fib(n: uint32): uint32
[ 247.41]       > fib(n: uint32): uint32
[ 247.43]        > fib(n: uint32): uint32
[ 247.44]         > fib(n: uint32): uint32
[ 247.45]          > fib(n: uint32): uint32
[ 247.46]           > fib(n: uint32): uint32
[ 247.47]            > fib(n: uint32): uint32
[ 247.48]            < return
[ 247.49]            > fib(n: uint32): uint32
[ 247.49]            < return
[ 247.50]           < return
[ 247.51]           > fib(n: uint32): uint32
[ 247.52]           < return
[ 247.53]          < return
[ 247.56]          > fib(n: uint32): uint32
[ 247.58]           > fib(n: uint32): uint32
[ 247.61]           < return
[ 247.62]           > fib(n: uint32): uint32
[ 247.63]           < return
[ 247.65]          < return
[ 247.66]         < return
[ 247.67]         > fib(n: uint32): uint32
[ 247.68]          > fib(n: uint32): uint32
[ 247.69]           > fib(n: uint32): uint32
[ 247.70]           < return
[ 247.71]           > fib(n: uint32): uint32
[ 247.72]           < return
[ 247.74]          < return
[ 247.74]          > fib(n: uint32): uint32
[ 247.75]          < return
[ 247.76]         < return
[ 247.77]        < return
[ 247.78]        > fib(n: uint32): uint32
[ 247.78]         > fib(n: uint32): uint32
[ 247.80]          > fib(n: uint32): uint32
[ 247.81]           > fib(n: uint32): uint32
[ 247.81]           < return
[ 247.82]           > fib(n: uint32): uint32
[ 247.83]           < return
[ 247.84]          < return
[ 247.85]          > fib(n: uint32): uint32
[ 247.86]          < return
[ 247.87]         < return
[ 247.87]         > fib(n: uint32): uint32
[ 247.88]          > fib(n: uint32): uint32
[ 247.89]          < return
[ 247.90]          > fib(n: uint32): uint32
[ 247.93]          < return
[ 247.94]         < return
[ 247.94]        < return
[ 247.95]       < return
[ 247.96]       > fib(n: uint32): uint32
[ 247.98]        > fib(n: uint32): uint32
[ 247.99]         > fib(n: uint32): uint32
[ 248.00]          > fib(n: uint32): uint32
[ 248.01]           > fib(n: uint32): uint32
[ 248.02]           < return
[ 248.03]           > fib(n: uint32): uint32
[ 248.04]           < return
[ 248.05]          < return
[ 248.05]          > fib(n: uint32): uint32
[ 248.06]          < return
[ 248.07]         < return
[ 248.08]         > fib(n: uint32): uint32
[ 248.09]          > fib(n: uint32): uint32
[ 248.10]          < return
[ 248.10]          > fib(n: uint32): uint32
[ 248.11]          < return
[ 248.12]         < return
[ 248.13]        < return
[ 248.13]        > fib(n: uint32): uint32
[ 248.15]         > fib(n: uint32): uint32
[ 248.16]          > fib(n: uint32): uint32
[ 248.16]          < return
[ 248.17]          > fib(n: uint32): uint32
[ 248.18]          < return
[ 248.19]         < return
[ 248.20]         > fib(n: uint32): uint32
[ 248.21]         < return
[ 248.21]        < return
[ 248.22]       < return
[ 248.23]      < return
[ 248.23]      > fib(n: uint32): uint32
[ 248.24]       > fib(n: uint32): uint32
[ 248.25]        > fib(n: uint32): uint32
[ 248.26]         > fib(n: uint32): uint32
[ 248.29]          > fib(n: uint32): uint32
[ 248.31]           > fib(n: uint32): uint32
[ 248.31]           < return
[ 248.32]           > fib(n: uint32): uint32
[ 248.34]           < return
[ 248.35]          < return
[ 248.36]          > fib(n: uint32): uint32
[ 248.37]          < return
[ 248.38]         < return
[ 248.38]         > fib(n: uint32): uint32
[ 248.39]          > fib(n: uint32): uint32
[ 248.40]          < return
[ 248.41]          > fib(n: uint32): uint32
[ 248.42]          < return
[ 248.43]         < return
[ 248.43]        < return
[ 248.44]        > fib(n: uint32): uint32
[ 248.45]         > fib(n: uint32): uint32
[ 248.46]          > fib(n: uint32): uint32
[ 248.47]          < return
[ 248.48]          > fib(n: uint32): uint32
[ 248.49]          < return
[ 248.50]         < return
[ 248.50]         > fib(n: uint32): uint32
[ 248.51]         < return
[ 248.52]        < return
[ 248.54]       < return
[ 248.55]       > fib(n: uint32): uint32
[ 248.56]        > fib(n: uint32): uint32
[ 248.57]         > fib(n: uint32): uint32
[ 248.59]          > fib(n: uint32): uint32
[ 248.59]          < return
[ 248.62]          > fib(n: uint32): uint32
[ 248.62]          < return
[ 248.63]         < return
[ 248.64]         > fib(n: uint32): uint32
[ 248.65]         < return
[ 248.66]        < return
[ 248.66]        > fib(n: uint32): uint32
[ 248.68]         > fib(n: uint32): uint32
[ 248.69]         < return
[ 248.69]         > fib(n: uint32): uint32
[ 248.70]         < return
[ 248.71]        < return
[ 248.72]       < return
[ 248.72]      < return
[ 248.75]     < return
[ 248.75]    < return
[ 248.76]   < return
[ 248.77]   > fib(n: uint32): uint32
[ 248.78]    > fib(n: uint32): uint32
[ 248.79]     > fib(n: uint32): uint32
[ 248.80]      > fib(n: uint32): uint32
[ 248.81]       > fib(n: uint32): uint32
[ 248.82]        > fib(n: uint32): uint32
[ 248.83]         > fib(n: uint32): uint32
[ 248.84]          > fib(n: uint32): uint32
[ 248.85]           > fib(n: uint32): uint32
[ 248.86]            > fib(n: uint32): uint32
[ 248.89]             > fib(n: uint32): uint32
[ 248.92]             < return
[ 248.93]             > fib(n: uint32): uint32
[ 248.94]             < return
[ 248.94]            < return
[ 248.95]            > fib(n: uint32): uint32
[ 248.97]            < return
[ 249.00]           < return
[ 249.01]           > fib(n: uint32): uint32
[ 249.02]            > fib(n: uint32): uint32
[ 249.03]            < return
[ 249.03]            > fib(n: uint32): uint32
[ 249.04]            < return
[ 249.05]           < return
[ 249.06]          < return
[ 249.07]          > fib(n: uint32): uint32
[ 249.08]           > fib(n: uint32): uint32
[ 249.09]            > fib(n: uint32): uint32
[ 249.10]            < return
[ 249.11]            > fib(n: uint32): uint32
[ 249.12]            < return
[ 249.12]           < return
[ 249.13]           > fib(n: uint32): uint32
[ 249.14]           < return
[ 249.15]          < return
[ 249.16]         < return
[ 249.17]         > fib(n: uint32): uint32
[ 249.20]          > fib(n: uint32): uint32
[ 249.23]           > fib(n: uint32): uint32
[ 249.24]            > fib(n: uint32): uint32
[ 249.26]            < return
[ 249.27]            > fib(n: uint32): uint32
[ 249.28]            < return
[ 249.28]           < return
[ 249.29]           > fib(n: uint32): uint32
[ 249.30]           < return
[ 249.31]          < return
[ 249.33]          > fib(n: uint32): uint32
[ 249.34]           > fib(n: uint32): uint32
[ 249.35]           < return
[ 249.36]           > fib(n: uint32): uint32
[ 249.38]           < return
[ 249.39]          < return
[ 249.40]         < return
[ 249.40]        < return
[ 249.41]        > fib(n: uint32): uint32
[ 249.42]         > fib(n: uint32): uint32
[ 249.43]          > fib(n: uint32): uint32
[ 249.44]           > fib(n: uint32): uint32
[ 249.45]            > fib(n: uint32): uint32
[ 249.46]            < return
[ 249.47]            > fib(n: uint32): uint32
[ 249.48]            < return
[ 249.49]           < return
[ 249.49]           > fib(n: uint32): uint32
[ 249.50]           < return
[ 249.51]          < return
[ 249.52]          > fib(n: uint32): uint32
[ 249.53]           > fib(n: uint32): uint32
[ 249.54]           < return
[ 249.54]           > fib(n: uint32): uint32
[ 249.55]           < return
[ 249.56]          < return
[ 249.57]         < return
[ 249.57]         > fib(n: uint32): uint32
[ 249.59]          > fib(n: uint32): uint32
[ 249.60]           > fib(n: uint32): uint32
[ 249.60]           < return
[ 249.61]           > fib(n: uint32): uint32
[ 249.62]           < return
[ 249.63]          < return
[ 249.64]          > fib(n: uint32): uint32
[ 249.65]          < return
[ 249.65]         < return
[ 249.66]        < return
[ 249.67]       < return
[ 249.67]       > fib(n: uint32): uint32
[ 249.70]        > fib(n: uint32): uint32
[ 249.73]         > fib(n: uint32): uint32
[ 249.74]          > fib(n: uint32): uint32
[ 249.75]           > fib(n: uint32): uint32
[ 249.76]            > fib(n: uint32): uint32
[ 249.77]            < return
[ 249.78]            > fib(n: uint32): uint32
[ 249.79]            < return
[ 249.80]           < return
[ 249.82]           > fib(n: uint32): uint32
[ 249.82]           < return
[ 249.83]          < return
[ 249.84]          > fib(n: uint32): uint32
[ 249.85]           > fib(n: uint32): uint32
[ 249.86]           < return
[ 249.87]           > fib(n: uint32): uint32
[ 249.88]           < return
[ 249.88]          < return
[ 249.89]         < return
[ 249.90]         > fib(n: uint32): uint32
[ 249.91]          > fib(n: uint32): uint32
[ 249.92]           > fib(n: uint32): uint32
[ 249.93]           < return
[ 249.94]           > fib(n: uint32): uint32
[ 249.95]           < return
[ 249.95]          < return
[ 249.98]          > fib(n: uint32): uint32
[ 250.00]          < return
[ 250.01]         < return
[ 250.02]        < return
[ 250.02]        > fib(n: uint32): uint32
[ 250.03]         > fib(n: uint32): uint32
[ 250.04]          > fib(n: uint32): uint32
[ 250.06]           > fib(n: uint32): uint32
[ 250.07]           < return
[ 250.07]           > fib(n: uint32): uint32
[ 250.08]           < return
[ 250.09]          < return
[ 250.10]          > fib(n: uint32): uint32
[ 250.11]          < return
[ 250.11]         < return
[ 250.12]         > fib(n: uint32): uint32
[ 250.13]          > fib(n: uint32): uint32
[ 250.14]          < return
[ 250.15]          > fib(n: uint32): uint32
[ 250.16]          < return
[ 250.17]         < return
[ 250.17]        < return
[ 250.19]       < return
[ 250.20]      < return
[ 250.21]      > fib(n: uint32): uint32
[ 250.22]       > fib(n: uint32): uint32
[ 250.23]        > fib(n: uint32): uint32
[ 250.24]         > fib(n: uint32): uint32
[ 250.25]          > fib(n: uint32): uint32
[ 250.26]           > fib(n: uint32): uint32
[ 250.27]            > fib(n: uint32): uint32
[ 250.28]            < return
[ 250.29]            > fib(n: uint32): uint32
[ 250.30]            < return
[ 250.31]           < return
[ 250.31]           > fib(n: uint32): uint32
[ 250.32]           < return
[ 250.33]          < return
[ 250.34]          > fib(n: uint32): uint32
[ 250.37]           > fib(n: uint32): uint32
[ 250.38]           < return
[ 250.38]           > fib(n: uint32): uint32
[ 250.40]           < return
[ 250.41]          < return
[ 250.42]         < return
[ 250.43]         > fib(n: uint32): uint32
[ 250.44]          > fib(n: uint32): uint32
[ 250.45]           > fib(n: uint32): uint32
[ 250.46]           < return
[ 250.47]           > fib(n: uint32): uint32
[ 250.48]           < return
[ 250.48]          < return
[ 250.49]          > fib(n: uint32): uint32
[ 250.50]          < return
[ 250.51]         < return
[ 250.51]        < return
[ 250.52]        > fib(n: uint32): uint32
[ 250.53]         > fib(n: uint32): uint32
[ 250.54]          > fib(n: uint32): uint32
[ 250.55]           > fib(n: uint32): uint32
[ 250.56]           < return
[ 250.57]           > fib(n: uint32): uint32
[ 250.58]           < return
[ 250.59]          < return
[ 250.59]          > fib(n: uint32): uint32
[ 250.60]          < return
[ 250.61]         < return
[ 250.62]         > fib(n: uint32): uint32
[ 250.63]          > fib(n: uint32): uint32
[ 250.64]          < return
[ 250.66]          > fib(n: uint32): uint32
[ 250.67]          < return
[ 250.68]         < return
[ 250.69]        < return
[ 250.69]       < return
[ 250.72]       > fib(n: uint32): uint32
[ 250.72]        > fib(n: uint32): uint32
[ 250.74]         > fib(n: uint32): uint32
[ 250.75]          > fib(n: uint32): uint32
[ 250.76]           > fib(n: uint32): uint32
[ 250.77]           < return
[ 250.77]           > fib(n: uint32): uint32
[ 250.78]           < return
[ 250.79]          < return
[ 250.80]          > fib(n: uint32): uint32
[ 250.81]          < return
[ 250.81]         < return
[ 250.82]         > fib(n: uint32): uint32
[ 250.83]          > fib(n: uint32): uint32
[ 250.84]          < return
[ 250.85]          > fib(n: uint32): uint32
[ 250.86]          < return
[ 250.87]         < return
[ 250.87]        < return
[ 250.88]        > fib(n: uint32): uint32
[ 250.89]         > fib(n: uint32): uint32
[ 250.90]          > fib(n: uint32): uint32
[ 250.91]          < return
[ 250.92]          > fib(n: uint32): uint32
[ 250.93]          < return
[ 250.93]         < return
[ 250.94]         > fib(n: uint32): uint32
[ 250.95]         < return
[ 250.96]        < return
[ 250.96]       < return
[ 250.97]      < return
[ 250.98]     < return
[ 250.98]     > fib(n: uint32): uint32
[ 250.99]      > fib(n: uint32): uint32
[ 251.00]       > fib(n: uint32): uint32
[ 251.03]        > fib(n: uint32): uint32
[ 251.04]         > fib(n: uint32): uint32
[ 251.06]          > fib(n: uint32): uint32
[ 251.08]           > fib(n: uint32): uint32
[ 251.09]            > fib(n: uint32): uint32
[ 251.10]            < return
[ 251.11]            > fib(n: uint32): uint32
[ 251.12]            < return
[ 251.12]           < return
[ 251.13]           > fib(n: uint32): uint32
[ 251.14]           < return
[ 251.15]          < return
[ 251.15]          > fib(n: uint32): uint32
[ 251.16]           > fib(n: uint32): uint32
[ 251.17]           < return
[ 251.18]           > fib(n: uint32): uint32
[ 251.19]           < return
[ 251.20]          < return
[ 251.20]         < return
[ 251.21]         > fib(n: uint32): uint32
[ 251.22]          > fib(n: uint32): uint32
[ 251.23]           > fib(n: uint32): uint32
[ 251.24]           < return
[ 251.25]           > fib(n: uint32): uint32
[ 251.26]           < return
[ 251.28]          < return
[ 251.29]          > fib(n: uint32): uint32
[ 251.30]          < return
[ 251.31]         < return
[ 251.32]        < return
[ 251.33]        > fib(n: uint32): uint32
[ 251.34]         > fib(n: uint32): uint32
[ 251.35]          > fib(n: uint32): uint32
[ 251.36]           > fib(n: uint32): uint32
[ 251.37]           < return
[ 251.38]           > fib(n: uint32): uint32
[ 251.40]           < return
[ 251.41]          < return
[ 251.41]          > fib(n: uint32): uint32
[ 251.42]          < return
[ 251.43]         < return
[ 251.44]         > fib(n: uint32): uint32
[ 251.46]          > fib(n: uint32): uint32
[ 251.49]          < return
[ 251.49]          > fib(n: uint32): uint32
[ 251.50]          < return
[ 251.51]         < return
[ 251.52]        < return
[ 251.52]       < return
[ 251.53]       > fib(n: uint32): uint32
[ 251.54]        > fib(n: uint32): uint32
[ 251.55]         > fib(n: uint32): uint32
[ 251.56]          > fib(n: uint32): uint32
[ 251.57]           > fib(n: uint32): uint32
[ 251.58]           < return
[ 251.59]           > fib(n: uint32): uint32
[ 251.60]           < return
[ 251.61]          < return
[ 251.61]          > fib(n: uint32): uint32
[ 251.62]          < return
[ 251.63]         < return
[ 251.64]         > fib(n: uint32): uint32
[ 251.65]          > fib(n: uint32): uint32
[ 251.66]          < return
[ 251.68]          > fib(n: uint32): uint32
[ 251.69]          < return
[ 251.70]         < return
[ 251.71]        < return
[ 251.72]        > fib(n: uint32): uint32
[ 251.74]         > fib(n: uint32): uint32
[ 251.75]          > fib(n: uint32): uint32
[ 251.76]          < return
[ 251.77]          > fib(n: uint32): uint32
[ 251.78]          < return
[ 251.78]         < return
[ 251.79]         > fib(n: uint32): uint32
[ 251.80]         < return
[ 251.81]        < return
[ 251.81]       < return
[ 251.84]      < return
[ 251.85]      > fib(n: uint32): uint32
[ 251.87]       > fib(n: uint32): uint32
[ 251.88]        > fib(n: uint32): uint32
[ 251.89]         > fib(n: uint32): uint32
[ 251.91]          > fib(n: uint32): uint32
[ 251.92]           > fib(n: uint32): uint32
[ 251.93]           < return
[ 251.94]           > fib(n: uint32): uint32
[ 251.98]           < return
[ 251.99]          < return
[ 252.00]          > fib(n: uint32): uint32
[ 252.02]          < return
[ 252.03]         < return
[ 252.03]         > fib(n: uint32): uint32
[ 252.04]          > fib(n: uint32): uint32
[ 252.07]          < return
[ 252.08]          > fib(n: uint32): uint32
[ 252.09]          < return
[ 252.10]         < return
[ 252.10]        < return
[ 252.11]        > fib(n: uint32): uint32
[ 252.14]         > fib(n: uint32): uint32
[ 252.15]          > fib(n: uint32): uint32
[ 252.16]          < return
[ 252.16]          > fib(n: uint32): uint32
[ 252.17]          < return
[ 252.18]         < return
[ 252.19]         > fib(n: uint32): uint32
[ 252.20]         < return
[ 252.20]        < return
[ 252.21]       < return
[ 252.22]       > fib(n: uint32): uint32
[ 252.23]        > fib(n: uint32): uint32
[ 252.24]         > fib(n: uint32): uint32
[ 252.25]          > fib(n: uint32): uint32
[ 252.26]          < return
[ 252.26]          > fib(n: uint32): uint32
[ 252.28]          < return
[ 252.28]         < return
[ 252.29]         > fib(n: uint32): uint32
[ 252.30]         < return
[ 252.31]        < return
[ 252.31]        > fib(n: uint32): uint32
[ 252.32]         > fib(n: uint32): uint32
[ 252.33]         < return
[ 252.34]         > fib(n: uint32): uint32
[ 252.35]         < return
[ 252.36]        < return
[ 252.36]       < return
[ 252.37]      < return
[ 252.38]     < return
[ 252.38]    < return
[ 252.39]    > fib(n: uint32): uint32
[ 252.40]     > fib(n: uint32): uint32
[ 252.41]      > fib(n: uint32): uint32
[ 252.44]       > fib(n: uint32): uint32
[ 252.47]        > fib(n: uint32): uint32
[ 252.48]         > fib(n: uint32): uint32
[ 252.49]          > fib(n: uint32): uint32
[ 252.50]           > fib(n: uint32): uint32
[ 252.51]            > fib(n: uint32): uint32
[ 252.52]            < return
[ 252.53]            > fib(n: uint32): uint32
[ 252.55]            < return
[ 252.56]           < return
[ 252.57]           > fib(n: uint32): uint32
[ 252.57]           < return
[ 252.58]          < return
[ 252.59]          > fib(n: uint32): uint32
[ 252.60]           > fib(n: uint32): uint32
[ 252.61]           < return
[ 252.62]           > fib(n: uint32): uint32
[ 252.63]           < return
[ 252.63]          < return
[ 252.64]         < return
[ 252.65]         > fib(n: uint32): uint32
[ 252.66]          > fib(n: uint32): uint32
[ 252.67]           > fib(n: uint32): uint32
[ 252.68]           < return
[ 252.69]           > fib(n: uint32): uint32
[ 252.72]           < return
[ 252.72]          < return
[ 252.73]          > fib(n: uint32): uint32
[ 252.74]          < return
[ 252.75]         < return
[ 252.75]        < return
[ 252.76]        > fib(n: uint32): uint32
[ 252.79]         > fib(n: uint32): uint32
[ 252.80]          > fib(n: uint32): uint32
[ 252.81]           > fib(n: uint32): uint32
[ 252.82]           < return
[ 252.84]           > fib(n: uint32): uint32
[ 252.85]           < return
[ 252.86]          < return
[ 252.87]          > fib(n: uint32): uint32
[ 252.88]          < return
[ 252.89]         < return
[ 252.91]         > fib(n: uint32): uint32
[ 252.92]          > fib(n: uint32): uint32
[ 252.93]          < return
[ 252.95]          > fib(n: uint32): uint32
[ 252.96]          < return
[ 252.97]         < return
[ 252.97]        < return
[ 252.98]       < return
[ 252.99]       > fib(n: uint32): uint32
[ 253.00]        > fib(n: uint32): uint32
[ 253.01]         > fib(n: uint32): uint32
[ 253.02]          > fib(n: uint32): uint32
[ 253.03]           > fib(n: uint32): uint32
[ 253.04]           < return
[ 253.05]           > fib(n: uint32): uint32
[ 253.06]           < return
[ 253.06]          < return
[ 253.07]          > fib(n: uint32): uint32
[ 253.08]          < return
[ 253.09]         < return
[ 253.09]         > fib(n: uint32): uint32
[ 253.10]          > fib(n: uint32): uint32
[ 253.13]          < return
[ 253.13]          > fib(n: uint32): uint32
[ 253.14]          < return
[ 253.15]         < return
[ 253.16]        < return
[ 253.17]        > fib(n: uint32): uint32
[ 253.20]         > fib(n: uint32): uint32
[ 253.23]          > fib(n: uint32): uint32
[ 253.24]          < return
[ 253.25]          > fib(n: uint32): uint32
[ 253.27]          < return
[ 253.28]         < return
[ 253.28]         > fib(n: uint32): uint32
[ 253.29]         < return
[ 253.30]        < return
[ 253.31]       < return
[ 253.31]      < return
[ 253.32]      > fib(n: uint32): uint32
[ 253.33]       > fib(n: uint32): uint32
[ 253.34]        > fib(n: uint32): uint32
[ 253.35]         > fib(n: uint32): uint32
[ 253.36]          > fib(n: uint32): uint32
[ 253.37]           > fib(n: uint32): uint32
[ 253.38]           < return
[ 253.39]           > fib(n: uint32): uint32
[ 253.40]           < return
[ 253.41]          < return
[ 253.41]          > fib(n: uint32): uint32
[ 253.42]          < return
[ 253.43]         < return
[ 253.44]         > fib(n: uint32): uint32
[ 253.45]          > fib(n: uint32): uint32
[ 253.46]          < return
[ 253.46]          > fib(n: uint32): uint32
[ 253.49]          < return
[ 253.50]         < return
[ 253.50]        < return
[ 253.51]        > fib(n: uint32): uint32
[ 253.53]         > fib(n: uint32): uint32
[ 253.54]          > fib(n: uint32): uint32
[ 253.55]          < return
[ 253.56]          > fib(n: uint32): uint32
[ 253.57]          < return
[ 253.58]         < return
[ 253.59]         > fib(n: uint32): uint32
[ 253.59]         < return
[ 253.60]        < return
[ 253.61]       < return
[ 253.62]       > fib(n: uint32): uint32
[ 253.63]        > fib(n: uint32): uint32
[ 253.64]         > fib(n: uint32): uint32
[ 253.65]          > fib(n: uint32): uint32
[ 253.66]          < return
[ 253.66]          > fib(n: uint32): uint32
[ 253.67]          < return
[ 253.68]         < return
[ 253.69]         > fib(n: uint32): uint32
[ 253.70]         < return
[ 253.70]        < return
[ 253.71]        > fib(n: uint32): uint32
[ 253.72]         > fib(n: uint32): uint32
[ 253.74]         < return
[ 253.74]         > fib(n: uint32): uint32
[ 253.75]         < return
[ 253.76]        < return
[ 253.77]       < return
[ 253.77]      < return
[ 253.78]     < return
[ 253.79]     > fib(n: uint32): uint32
[ 253.80]      > fib(n: uint32): uint32
[ 253.81]       > fib(n: uint32): uint32
[ 253.82]        > fib(n: uint32): uint32
[ 253.83]         > fib(n: uint32): uint32
[ 253.86]          > fib(n: uint32): uint32
[ 253.87]           > fib(n: uint32): uint32
[ 253.88]           < return
[ 253.89]           > fib(n: uint32): uint32
[ 253.91]           < return
[ 253.92]          < return
[ 253.93]          > fib(n: uint32): uint32
[ 253.93]          < return
[ 253.94]         < return
[ 253.95]         > fib(n: uint32): uint32
[ 253.96]          > fib(n: uint32): uint32
[ 253.97]          < return
[ 253.97]          > fib(n: uint32): uint32
[ 253.98]          < return
[ 253.99]         < return
[ 254.00]        < return
[ 254.01]        > fib(n: uint32): uint32
[ 254.02]         > fib(n: uint32): uint32
[ 254.03]          > fib(n: uint32): uint32
[ 254.04]          < return
[ 254.04]          > fib(n: uint32): uint32
[ 254.05]          < return
[ 254.06]         < return
[ 254.07]         > fib(n: uint32): uint32
[ 254.08]         < return
[ 254.08]        < return
[ 254.09]       < return
[ 254.12]       > fib(n: uint32): uint32
[ 254.13]        > fib(n: uint32): uint32
[ 254.14]         > fib(n: uint32): uint32
[ 254.15]          > fib(n: uint32): uint32
[ 254.16]          < return
[ 254.17]          > fib(n: uint32): uint32
[ 254.18]          < return
[ 254.18]         < return
[ 254.19]         > fib(n: uint32): uint32
[ 254.21]         < return
[ 254.22]        < return
[ 254.23]        > fib(n: uint32): uint32
[ 254.24]         > fib(n: uint32): uint32
[ 254.25]         < return
[ 254.26]         > fib(n: uint32): uint32
[ 254.27]         < return
[ 254.29]        < return
[ 254.29]       < return
[ 254.31]      < return
[ 254.32]      > fib(n: uint32): uint32
[ 254.33]       > fib(n: uint32): uint32
[ 254.34]        > fib(n: uint32): uint32
[ 254.35]         > fib(n: uint32): uint32
[ 254.37]          > fib(n: uint32): uint32
[ 254.37]          < return
[ 254.38]          > fib(n: uint32): uint32
[ 254.39]          < return
[ 254.40]         < return
[ 254.41]         > fib(n: uint32): uint32
[ 254.41]         < return
[ 254.42]        < return
[ 254.43]        > fib(n: uint32): uint32
[ 254.44]         > fib(n: uint32): uint32
[ 254.45]         < return
[ 254.46]         > fib(n: uint32): uint32
[ 254.47]         < return
[ 254.47]        < return
[ 254.48]       < return
[ 254.50]       > fib(n: uint32): uint32
[ 254.51]        > fib(n: uint32): uint32
[ 254.52]         > fib(n: uint32): uint32
[ 254.53]         < return
[ 254.55]         > fib(n: uint32): uint32
[ 254.56]         < return
[ 254.57]        < return
[ 254.58]        > fib(n: uint32): uint32
[ 254.59]        < return
[ 254.59]       < return
[ 254.60]      < return
[ 254.61]     < return
[ 254.61]    < return
[ 254.62]   < return
[ 254.63]  < return
[ 254.66]  > typename.name(type: typename): .cstr
[ 254.68]  < return
[ 254.69]  > typename.file(type: typename): .cstr
[ 254.70]  < return
[ 254.71]  > typename.line(type: typename): int32
[ 254.72]  < return
[ 254.72]  > typename.base(type: typename): typename
[ 254.73]  < return
[ 254.74]  > typename.name(type: typename): .cstr
[ 254.75]  < return
[ 254.76]  > typename.file(type: typename): .cstr
[ 254.77]  < return
[ 254.77]  > typename.line(type: typename): int32
[ 254.78]  < return
[ 254.80]  > typename.base(type: typename): typename
[ 254.81]  < return
[ 254.82]  > typename.base(type: typename): typename
[ 254.85]  < return
[ 254.89]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.90]  < return
[ 254.90]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.91]  < return
[ 254.92]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 254.93]  < return
[ 254.94]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.95]  < return
[ 254.96]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.96]  < return
[ 254.97]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 254.98]  < return
[ 254.99]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 255.00]  < return
[ 255.00]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 255.01]  < return
[ 255.02]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 255.03]  < return
[ 255.04]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 255.04]  < return
[ 255.05]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 255.06]  < return
[ 255.07]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 255.08]  < return
[ 255.09]  > float64.sin(x: float64): float64
[ 255.11]  < return
[ 255.12]  > float64.cos(x: float64): float64
[ 255.13]  < return
[ 255.14]  > float64.tan(x: float64): float64
[ 255.17]  < return
[ 255.18]  > float64.log(x: float64): float64
[ 255.19]  < return
[ 255.20]  > float64.exp(x: float64): float64
[ 255.22]  < return
[ 255.25]  > float64.pow(x: float64, y: float64): float64
[ 255.26]  < return
[ 255.27]  > float64.sqrt(x: float64): float64
[ 255.27]  < return
[ 255.28]  > float64.atan2(x: float64, y: float64): float64
[ 255.29]  < return
[ 255.31]  > float32.sin(x: float32): float32
[ 255.32]  < return
[ 255.33]  > float32.cos(x: float32): float32
[ 255.34]  < return
[ 255.35]  > float32.tan(x: float32): float32
[ 255.35]  < return
[ 255.37]  > float32.log(x: float32): float32
[ 255.37]  < return
[ 255.38]  > float32.exp(x: float32): float32
[ 255.39]  < return
[ 255.40]  > float32.pow(x: float32, y: float32): float32
[ 255.41]  < return
[ 255.41]  > float32.sqrt(x: float32): float32
[ 255.42]  < return
[ 255.43]  > float32.atan2(x: float32, y: float32): float32
[ 255.46]  < return
[ 255.47]  > uint32.pop(value: int32): int32
[ 255.47]  < return
[ 255.48]  > uint32.swap(value: int32): int32
[ 255.49]  < return
[ 255.50]  > uint32.bsr(value: int32): int32
[ 255.50]  < return
[ 255.51]  > uint32.bsf(value: int32): int32
[ 255.52]  < return
[ 255.53]  > uint32.hib(value: int32): int32
[ 255.54]  < return
[ 255.54]  > uint32.lob(value: int32): int32
[ 255.55]  < return
[ 255.57]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 255.58]  < return
[ 255.59]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 255.60]  < return
[ 255.61]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 255.62]  < return
[ 255.63]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 255.63]  < return
[ 255.64]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.66]  < return
[ 255.67]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.68]  < return
[ 255.69]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.70]  < return
[ 255.71]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.72]  < return
[ 255.72]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 255.73]  < return
[ 255.74]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 255.75]  < return
[ 255.76]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.77]  < return
[ 255.78]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.78]  < return
[ 255.79]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.80]  < return
[ 255.81]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 255.82]  < return
[ 255.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 255.87]  < return
[ 255.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 255.90]  < return
[ 255.91]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 255.92]  < return
[ 255.93]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 255.93]  < return
[ 255.94]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 255.97]  < return
[ 255.98]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 256.01]  < return
[ 256.02]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.03]   > noError(ptr: pointer): void
[ 256.04]   < return
[ 256.05]   > halt(): void
[ 256.06]   < return
[ 256.06]  < return
[ 256.07]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.08]  < return
[ 256.09]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 256.10]   > stackOverflow(ptr: pointer): void
[ 256.11]    > stackOverflow(ptr: pointer): void
[ 256.12]     > stackOverflow(ptr: pointer): void
[ 256.14]      > stackOverflow(ptr: pointer): void
[ 256.15]       > stackOverflow(ptr: pointer): void
[ 256.16]        > stackOverflow(ptr: pointer): void
[ 256.18]         > stackOverflow(ptr: pointer): void
[ 256.19]          > stackOverflow(ptr: pointer): void
[ 256.20]           > stackOverflow(ptr: pointer): void
[ 256.21]            > stackOverflow(ptr: pointer): void
[ 256.22]             > stackOverflow(ptr: pointer): void
[ 256.23]              > stackOverflow(ptr: pointer): void
[ 256.24]               > stackOverflow(ptr: pointer): void
[ 256.25]                > stackOverflow(ptr: pointer): void
[ 256.26]                 > stackOverflow(ptr: pointer): void
[ 256.26]                  > stackOverflow(ptr: pointer): void
[ 256.27]                   > stackOverflow(ptr: pointer): void
[ 256.28]                    > stackOverflow(ptr: pointer): void
[ 256.29]                     > stackOverflow(ptr: pointer): void
[ 256.30]                      > stackOverflow(ptr: pointer): void
[ 256.31]                       > stackOverflow(ptr: pointer): void
[ 256.32]                        > stackOverflow(ptr: pointer): void
[ 256.33]                         > stackOverflow(ptr: pointer): void
[ 256.34]                          > stackOverflow(ptr: pointer): void
[ 256.35]                           > stackOverflow(ptr: pointer): void
[ 256.36]                            > stackOverflow(ptr: pointer): void
[ 256.37]                             > stackOverflow(ptr: pointer): void
[ 256.38]                              > stackOverflow(ptr: pointer): void
[ 256.39]                               > stackOverflow(ptr: pointer): void
[ 256.40]                                > stackOverflow(ptr: pointer): void
[ 256.40]                                 > stackOverflow(ptr: pointer): void
[ 256.42]                                  > stackOverflow(ptr: pointer): void
[ 256.42]                                   > stackOverflow(ptr: pointer): void
[ 256.43]                                    > stackOverflow(ptr: pointer): void
[ 256.44]                                     > stackOverflow(ptr: pointer): void
[ 256.45]                                      > stackOverflow(ptr: pointer): void
[ 256.46]                                       > stackOverflow(ptr: pointer): void
[ 256.47]                                        > stackOverflow(ptr: pointer): void
[ 256.48]                                         > stackOverflow(ptr: pointer): void
[ 256.50]                                          > stackOverflow(ptr: pointer): void
[ 256.51]                                           > stackOverflow(ptr: pointer): void
[ 256.52]                                            > stackOverflow(ptr: pointer): void
[ 256.55]                                             > stackOverflow(ptr: pointer): void
[ 256.56]                                              > stackOverflow(ptr: pointer): void
[ 256.56]                                               > stackOverflow(ptr: pointer): void
[ 256.57]                                                > stackOverflow(ptr: pointer): void
[ 256.58]                                                 > stackOverflow(ptr: pointer): void
[ 256.59]                                                  > stackOverflow(ptr: pointer): void
[ 256.60]                                                   > stackOverflow(ptr: pointer): void
[ 256.61]                                                    > stackOverflow(ptr: pointer): void
[ 256.62]                                                     > stackOverflow(ptr: pointer): void
[ 256.63]                                                      > stackOverflow(ptr: pointer): void
[ 256.64]                                                       > stackOverflow(ptr: pointer): void
[ 256.65]                                                        > stackOverflow(ptr: pointer): void
[ 256.66]                                                         > stackOverflow(ptr: pointer): void
[ 256.67]                                                          > stackOverflow(ptr: pointer): void
[ 256.68]                                                           > stackOverflow(ptr: pointer): void
[ 256.69]                                                            > stackOverflow(ptr: pointer): void
[ 256.70]                                                             > stackOverflow(ptr: pointer): void
[ 256.71]                                                              > stackOverflow(ptr: pointer): void
[ 256.72]                                                               > stackOverflow(ptr: pointer): void
[ 256.73]                                                                > stackOverflow(ptr: pointer): void
[ 256.75]                                                                 > stackOverflow(ptr: pointer): void
[ 256.76]                                                                  > stackOverflow(ptr: pointer): void
[ 256.77]                                                                  < return
[ 256.78]                                                                 < return
[ 256.79]                                                                < return
[ 256.79]                                                               < return
[ 256.80]                                                              < return
[ 256.82]                                                             < return
[ 256.82]                                                            < return
[ 256.83]                                                           < return
[ 256.84]                                                          < return
[ 256.84]                                                         < return
[ 256.85]                                                        < return
[ 256.86]                                                       < return
[ 256.86]                                                      < return
[ 256.87]                                                     < return
[ 256.88]                                                    < return
[ 256.88]                                                   < return
[ 256.89]                                                  < return
[ 256.89]                                                 < return
[ 256.90]                                                < return
[ 256.91]                                               < return
[ 256.91]                                              < return
[ 256.92]                                             < return
[ 256.93]                                            < return
[ 256.93]                                           < return
[ 256.94]                                          < return
[ 256.96]                                         < return
[ 256.96]                                        < return
[ 256.97]                                       < return
[ 256.98]                                      < return
[ 256.98]                                     < return
[ 257.01]                                    < return
[ 257.01]                                   < return
[ 257.02]                                  < return
[ 257.03]                                 < return
[ 257.03]                                < return
[ 257.04]                               < return
[ 257.06]                              < return
[ 257.07]                             < return
[ 257.07]                            < return
[ 257.08]                           < return
[ 257.09]                          < return
[ 257.09]                         < return
[ 257.10]                        < return
[ 257.11]                       < return
[ 257.11]                      < return
[ 257.12]                     < return
[ 257.12]                    < return
[ 257.13]                   < return
[ 257.15]                  < return
[ 257.15]                 < return
[ 257.17]                < return
[ 257.18]               < return
[ 257.20]              < return
[ 257.21]             < return
[ 257.23]            < return
[ 257.23]           < return
[ 257.24]          < return
[ 257.26]         < return
[ 257.26]        < return
[ 257.27]       < return
[ 257.28]      < return
[ 257.28]     < return
[ 257.29]    < return
[ 257.30]   < return
[ 257.30]  < return
[ 257.31]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 257.32]   > divisionByZero(args: pointer): void
[ 257.33]   < return
[ 257.33]  < return
[ 257.34]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 257.35]   > invalidInstruction(args: pointer): void
[ 257.36]   < return
[ 257.37]  < return
[ 257.37]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 257.38]   > invalidMemoryAccess(args: pointer): void
[ 257.39]   < return
[ 257.40]  < return
[ 257.40]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 257.41]   > abortExecution(args: pointer): void
[ 257.43]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 257.54]    < return
[ 257.54]   < return
[ 257.55]  < return
[ 257.66]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 257.67]  < return
[ 257.68]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 257.74]  < return
[ 257.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 257.81]  < return
[ 257.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 257.87]  < return
[ 257.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 257.92]  < return
[ 257.93]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 257.95]  < return
[ 257.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 257.98]  < return
[ 258.00]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.01]  < return
[ 258.02]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.03]  < return
[ 258.04]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.05]  < return
[ 258.06]  > lenSlice(values: int64[]): int32
[ 258.07]  < return
[ 258.08]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.09]  < return
[ 258.12]  > lenSlice(values: int64[]): int32
[ 258.13]  < return
[ 258.13]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.14]  < return
[ 258.15]  > lenSlice(values: int64[]): int32
[ 258.17]  < return
[ 258.17]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.18]  < return
[ 258.20]  > lenSlice(values: int64[]): int32
[ 258.20]  < return
[ 258.23]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.24]  < return
[ 258.25]  > lenSlice(values: int64[]): int32
[ 258.26]  < return
[ 258.26]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 258.27]  < return
[ 258.34]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.35]  < return
[ 258.37]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.38]  < return
[ 258.39]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.40]  < return
[ 258.41]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.43]  < return
[ 258.44]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.45]  < return
[ 258.46]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.47]  < return
[ 258.49]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.51]  < return
[ 258.53]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.54]  < return
[ 258.60]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.61]  < return
[ 258.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.63]  < return
[ 258.65]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.66]  < return
[ 258.67]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.68]  < return
[ 258.70]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.71]  < return
[ 258.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.73]  < return
[ 258.75]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.76]  < return
[ 258.77]  > nthSlice(idx: int32, values: int64[]): int64
[ 258.78]  < return
[ 258.86]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.87]  < return
[ 258.88]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.89]  < return
[ 258.92]  > nthFixed(idx: int32, values: int64[7]): int64
[ 258.93]  < return
[ 258.94]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.95]  < return
[ 258.97]  > nthArray(idx: int32, values: int64[*]): int64
[ 258.98]  < return
[ 258.99]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.00]  < return
[ 259.02]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.03]  < return
[ 259.04]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.05]  < return
[ 259.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.11]  < return
[ 259.12]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.14]  < return
[ 259.15]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.16]  < return
[ 259.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.21]  < return
[ 259.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.24]  < return
[ 259.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.26]  < return
[ 259.29]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.30]  < return
[ 259.31]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.32]  < return
[ 259.37]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.38]  < return
[ 259.40]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.41]  < return
[ 259.42]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.43]  < return
[ 259.47]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.48]  < return
[ 259.50]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.51]  < return
[ 259.52]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.53]  < return
[ 259.55]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.56]  < return
[ 259.57]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.58]  < return
[ 259.63]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.64]  < return
[ 259.66]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.67]  < return
[ 259.69]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.71]  < return
[ 259.72]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.73]  < return
[ 259.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.75]  < return
[ 259.77]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.78]  < return
[ 259.79]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.82]  < return
[ 259.83]  > nthSlice(idx: int32, values: int64[]): int64
[ 259.86]  < return
[ 259.91]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.92]  < return
[ 259.93]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.94]  < return
[ 259.95]  > nthFixed(idx: int32, values: int64[7]): int64
[ 259.96]  < return
[ 259.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 259.99]  < return
[ 260.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 260.01]  < return
[ 260.03]  > nthArray(idx: int32, values: int64[*]): int64
[ 260.04]  < return
[ 260.05]  > nthSlice(idx: int32, values: int64[]): int64
[ 260.06]  < return
[ 260.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 260.09]  < return
[ 260.16]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 260.18]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(1)
	test/lang/method.ci:58: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 260.25]   < return
[ 260.26]  < return
[ 260.27]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 260.29]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(1)
	test/lang/method.ci:59: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 260.35]   < return
[ 260.36]  < return
[ 260.37]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 260.38]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:63: debug: extension.staticMethod
[ 260.40]   < return
[ 260.41]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 260.42]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(2)
	test/lang/method.ci:65: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:75: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 260.56]    < return
[ 260.57]   < return
[ 260.57]  < return
[ 260.59]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 260.60]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:69: debug: extension.virtualMethod
[ 260.61]   < return
[ 260.62]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 260.63]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(2)
	test/lang/method.ci:71: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:76: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 260.76]    < return
[ 260.77]   < return
[ 260.77]  < return
[ 260.79]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 260.80]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(3)
	test/lang/method.ci:79: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 260.88]   < return
[ 260.89]  < return
[ 260.92]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 260.93]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:80: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 260.99]   < return
[ 261.00]  < return
[ 261.01]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 261.02]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:81: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 261.12]   < return
[ 261.13]  < return
[ 262.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 262.30]  < return
[ 262.31]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 262.33]  < return
[ 262.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 262.37]  < return
[ 262.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 262.43]  < return
[ 262.46]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 262.49]  < return
[ 262.51]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 262.53]  < return
[ 262.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 262.57]  < return
[ 262.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 262.61]  < return
[ 262.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 262.65]  < return
[ 262.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 262.70]  < return
[ 262.75]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 262.77]  < return
[ 262.79]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 262.81]  < return
[ 262.87]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 262.89]  < return
[ 262.91]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 262.93]  < return
[ 262.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 262.98]  < return
[ 263.01]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 263.03]  < return
[ 263.06]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 263.10]  < return
[ 263.13]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 263.15]  < return
[ 263.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 263.20]  < return
[ 263.22]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 263.24]  < return
[ 263.27]  > Math.floor(x: float64): float64
[ 263.27]   > Math.modf(x: float64, intPart: float64): float64
[ 263.28]   < return
[ 263.29]  < return
[ 263.31]  > Math.floor(x: float64): float64
[ 263.32]   > Math.modf(x: float64, intPart: float64): float64
[ 263.33]   < return
[ 263.34]  < return
[ 263.35]  > Math.floor(x: float64): float64
[ 263.36]   > Math.modf(x: float64, intPart: float64): float64
[ 263.38]   < return
[ 263.38]  < return
[ 263.40]  > Math.floor(x: float64): float64
[ 263.40]   > Math.modf(x: float64, intPart: float64): float64
[ 263.41]    > Math.modf(x: float64, intPart: float64): float64
[ 263.42]    < return
[ 263.43]   < return
[ 263.43]  < return
[ 263.44]  > Math.floor(x: float64): float64
[ 263.45]   > Math.modf(x: float64, intPart: float64): float64
[ 263.46]    > Math.modf(x: float64, intPart: float64): float64
[ 263.47]    < return
[ 263.47]   < return
[ 263.48]  < return
[ 263.49]  > Math.floor(x: float64): float64
[ 263.50]   > Math.modf(x: float64, intPart: float64): float64
[ 263.50]    > Math.modf(x: float64, intPart: float64): float64
[ 263.53]    < return
[ 263.53]   < return
[ 263.54]  < return
[ 263.62]  > Math.abs(x: float64): float64
[ 263.62]  < return
[ 263.64]  > Math.abs(x: float64): float64
[ 263.66]  < return
[ 263.67]  > Math.abs(x: float64): float64
[ 263.68]  < return
[ 263.70]  > Math.abs(x: float32): float32
[ 263.71]  < return
[ 263.72]  > Math.abs(x: float32): float32
[ 263.73]  < return
[ 263.74]  > Math.abs(x: float32): float32
[ 263.75]  < return
[ 263.76]  > Math.min(a: float32, b: float32): float32
[ 263.77]  < return
[ 263.78]  > Math.max(a: float32, b: float32): float32
[ 263.79]  < return
[ 263.81]  > Math.min(a: float64, b: float64): float64
[ 263.81]  < return
[ 263.83]  > Math.max(a: float64, b: float64): float64
[ 263.83]  < return
[ 263.85]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 263.86]  < return
[ 263.87]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 263.88]  < return
[ 263.92]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 263.93]  < return
[ 263.99]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 264.00]  < return
[ 264.02]  > Math.min(data: float64[]): float64
[ 264.03]  < return
[ 264.06]  > Math.min(data: float64[]): float64
[ 264.11]  < return
[ 264.12]  > Math.max(data: float64[]): float64
[ 264.13]  < return
[ 264.16]  > Math.max(data: float64[]): float64
[ 264.20]  < return
[ 264.21]  > Math.sum(data: float64[]): float64
[ 264.22]  < return
[ 264.24]  > Math.sum(data: float64[]): float64
[ 264.25]  < return
[ 264.27]  > Math.sum(data: float64[]): float64
[ 264.29]  < return
[ 264.33]  > Math.sum(data: float64[]): float64
[ 264.38]  < return
[ 264.40]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 264.43]  < return
[ 264.48]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 264.51]  < return
[ 264.54]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 264.57]  < return
[ 264.60]  > Math.sinCos(arg: float64, quad: int32): float64
[ 264.64]  < return
[ 264.65]  > Math.abs(x: float64): float64
[ 264.66]  < return
[ 264.67]  > Math.sinCos(arg: float64, quad: int32): float64
[ 264.70]  < return
[ 264.71]  > Math.tan(arg: float64): float64
[ 264.72]   > Math.modf(x: float64, intPart: float64): float64
[ 264.75]   < return
[ 264.78]  < return
[ 264.80]  > Math.sinh(x: float64): float64
[ 264.81]   > float64.exp(x: float64): float64
[ 264.82]   < return
[ 264.82]   > float64.exp(x: float64): float64
[ 264.83]   < return
[ 264.84]  < return
[ 264.86]  > Math.cosh(x: float64): float64
[ 264.86]   > float64.exp(x: float64): float64
[ 264.87]   < return
[ 264.88]   > float64.exp(x: float64): float64
[ 264.88]   < return
[ 264.89]  < return
[ 264.90]  > Math.asin(x: float64): float64
[ 264.91]   > float64.sqrt(x: float64): float64
[ 264.92]   < return
[ 264.93]   > float64.atan2(x: float64, y: float64): float64
[ 264.94]   < return
[ 264.96]  < return
[ 264.97]  > Math.asin(x: float64): float64
[ 264.99]   > float64.sqrt(x: float64): float64
[ 264.99]   < return
[ 265.00]   > float64.atan2(x: float64, y: float64): float64
[ 265.01]   < return
[ 265.01]  < return
[ 265.03]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 265.04]  < return
[ 265.06]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 265.08]  < return
[ 265.10]  > Math.absMod(val: float64, mod: float64): float64
[ 265.11]  < return
[ 265.12]  > Math.absMod(val: float64, mod: float64): float64
[ 265.12]  < return
[ 265.14]  > Math.absMod(val: float64, mod: float64): float64
[ 265.14]  < return
[ 265.16]  > Math.absMod(val: float64, mod: float64): float64
[ 265.19]  < return
[ 265.20]  > Math.absMod(val: float64, mod: float64): float64
[ 265.21]  < return
[ 265.24]  > Math.absMod(val: float64, mod: float64): float64
[ 265.25]  < return
[ 265.26]  > Math.absMod(val: float64, mod: float64): float64
[ 265.27]  < return
[ 265.29]  > Math.absMod(val: float64, mod: float64): float64
[ 265.31]  < return
[ 265.34]  > Math.absMod(val: float64, mod: float64): float64
[ 265.36]  < return
[ 265.38]  > Math.absMod(val: float64, mod: float64): float64
[ 265.38]  < return
[ 265.40]  > Math.absMod(val: float64, mod: float64): float64
[ 265.40]  < return
[ 265.42]  > Math.absMod(val: float32, mod: float32): float32
[ 265.42]  < return
[ 265.44]  > Math.absMod(val: float32, mod: float32): float32
[ 265.44]  < return
[ 265.46]  > Math.absMod(val: float32, mod: float32): float32
[ 265.46]  < return
[ 265.48]  > Math.absMod(val: float32, mod: float32): float32
[ 265.49]  < return
[ 265.50]  > Math.absMod(val: float32, mod: float32): float32
[ 265.51]  < return
[ 265.52]  > Math.absMod(val: float32, mod: float32): float32
[ 265.53]  < return
[ 265.54]  > Math.absMod(val: float32, mod: float32): float32
[ 265.55]  < return
[ 265.56]  > Math.absMod(val: float32, mod: float32): float32
[ 265.57]  < return
[ 265.58]  > Math.absMod(val: float32, mod: float32): float32
[ 265.59]  < return
[ 265.60]  > Math.absMod(val: float32, mod: float32): float32
[ 265.61]  < return
[ 265.62]  > Math.absMod(val: float32, mod: float32): float32
[ 265.63]  < return
[ 265.64]  > halt(): void
[ 265.65]  < return
[ 265.65] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:50: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:66: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(225088)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(224784)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:11: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:25: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:30: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:40: globalFunction: function(<globalFunction>)
test/lang/method.ci:44: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:62: staticMethod: function(<staticMethod>)
test/lang/method.ci:68: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 342635(334.6 Kb)
memory[heap] @053a6b; size: 1229971(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 326808(319.1 Kb)
memory[code] @000000; size: 15489(15.1 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @053a88; size: 1229920(1.2 Mb)

---------- Profile functions: 79/113, coverage: 69.91%
::[.005c20, .005c20): exec(2), time(0.013 ms): halt(): void
::[.005f68, .005f68): exec(3), time(0.037 ms): typename.base(type: typename): typename
::[.006168, .006168): exec(2), time(0.016 ms): typename.file(type: typename): .cstr
::[.006368, .006368): exec(2), time(0.016 ms): typename.line(type: typename): int32
::[.006568, .006568): exec(2), time(0.024 ms): typename.name(type: typename): .cstr
::[.006d00, .006d00): exec(40), time(1.579 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0075e0, .0075e0): exec(7), time(1.476 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007880, .007880): exec(8), time(0.076 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007bb8, .007bb8): exec(2), time(0.016 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007ef0, .007ef0): exec(2), time(0.017 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008220, .008220): exec(1), time(0.008 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0084c8, .0084c8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0086d0, .0086d0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008838, .008838): exec(0), time(0.000 ms): System.rand(): int32
::[.0089a0, .0089a0): exec(0), time(0.000 ms): System.time(): int32
::[.008b08, .008b08): exec(0), time(0.000 ms): System.clock(): int32
::[.008c70, .008c70): exec(0), time(0.000 ms): System.millis(): int64
::[.008e70, .008e70): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0091a8, .0091a8): exec(7), time(0.052 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0094d8, .0094d8): exec(7), time(0.056 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0096d8, .0096d8): exec(1), time(0.008 ms): uint32.pop(value: int32): int32
::[.0098d8, .0098d8): exec(1), time(0.008 ms): uint32.swap(value: int32): int32
::[.009ad8, .009ad8): exec(1), time(0.008 ms): uint32.bsr(value: int32): int32
::[.009cd8, .009cd8): exec(1), time(0.007 ms): uint32.bsf(value: int32): int32
::[.009ed8, .009ed8): exec(1), time(0.008 ms): uint32.hib(value: int32): int32
::[.00a0d8, .00a0d8): exec(1), time(0.008 ms): uint32.lob(value: int32): int32
::[.00a400, .00a400): exec(1), time(0.008 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a728, .00a728): exec(1), time(0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00a928, .00a928): exec(1), time(0.008 ms): float32.sin(x: float32): float32
::[.00ab28, .00ab28): exec(1), time(0.008 ms): float32.cos(x: float32): float32
::[.00ad28, .00ad28): exec(1), time(0.008 ms): float32.tan(x: float32): float32
::[.00af28, .00af28): exec(1), time(0.008 ms): float32.log(x: float32): float32
::[.00b128, .00b128): exec(1), time(0.007 ms): float32.exp(x: float32): float32
::[.00b3c0, .00b3c0): exec(1), time(0.007 ms): float32.pow(x: float32, y: float32): float32
::[.00b5c0, .00b5c0): exec(1), time(0.008 ms): float32.sqrt(x: float32): float32
::[.00b858, .00b858): exec(1), time(0.028 ms): float32.atan2(x: float32, y: float32): float32
::[.00ba50, .00ba50): exec(1), time(0.023 ms): float64.sin(x: float64): float64
::[.00bc48, .00bc48): exec(1), time(0.013 ms): float64.cos(x: float64): float64
::[.00be40, .00be40): exec(1), time(0.027 ms): float64.tan(x: float64): float64
::[.00c038, .00c038): exec(1), time(0.011 ms): float64.log(x: float64): float64
::[.00c230, .00c230): exec(5), time(0.051 ms): float64.exp(x: float64): float64
::[.00c4c0, .00c4c0): exec(1), time(0.010 ms): float64.pow(x: float64, y: float64): float64
::[.00c6b8, .00c6b8): exec(3), time(0.022 ms): float64.sqrt(x: float64): float64
::[.00c948, .00c948): exec(3), time(0.024 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:66:[.04fc98, .04fcf6): exec(8), time(0.074 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.04fcf8, .04fd4e): exec(10), time(0.141 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.04fd50, .04fd68): exec(6), time(0.202-0.119 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.04fd68, .04fd7a): exec(3), time(0.023 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.04fd80, .04fd92): exec(4), time(0.044 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.04fd98, .04fdb3): exec(11), time(0.089 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.04fdb8, .04fdd3): exec(11), time(0.142 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.04fdd8, .04fde9): exec(1), time(0.007 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.04fdf0, .04fe01): exec(1), time(0.008 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.04fe08, .04fe19): exec(1), time(0.008 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.04fe20, .04fe31): exec(1), time(0.008 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.04fe38, .04fe56): exec(2), time(0.018 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.04fe58, .04fe76): exec(2), time(0.019 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.04fe78, .04fec0): exec(2), time(0.062 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.04fec0, .04ff08): exec(2), time(0.049 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.04ff08, .04ff30): exec(4), time(0.102 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.04ff30, .04ff5f): exec(3), time(0.085 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.04ff60, .04ff99): exec(1), time(0.011 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.04ffa0, .04ffd9): exec(1), time(0.024 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.04ffe0, .05012f): exec(2), time(0.069 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.050130, .0502a3): exec(1), time(0.073-0.022 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.0502a8, .050399): exec(1), time(0.043-0.017 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.0503a0, .0503eb): exec(1), time(0.035-0.013 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.0503f0, .050496): exec(2), time(0.099-0.029 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.050498, .05049f): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.0504a0, .0504a7): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.0504a8, .050523): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.050528, .050547): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.050548, .0505ac): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.0505b0, .0505d6): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.0505d8, .05060a): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.050610, .050642): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.050648, .050691): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.050698, .050716): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.050718, .050757): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.050758, .05079f): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.0507a0, .0507c4): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.0507c8, .0507d6): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.0507d8, .05082c): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.050840, .050ad1): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.050ad8, .050aef): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.050af0, .050b21): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.050b38, .050b51): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.050b58, .050b5f): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.050b60, .050b6d): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:27:[.050b70, .050ba1): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:40:[.050ba8, .050bbd): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:52:[.050bc0, .050d61): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:3:[.050d70, .050d71): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:6:[.050d78, .050d80): exec(2), time(0.042 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.050d80, .050d88): exec(2), time(0.019 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.050d88, .050dbe): exec(753), time(15.452 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.050dc0, .050dc1): exec(1), time(0.010 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.050dc8, .050de0): exec(64-64), time(1.199 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.050de0, .050dec): exec(1-1), time(0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.050df0, .050e34): exec(1-1), time(0.131-0.109 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.050e38, .050e45): exec(1-1), time(0.010 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.050e48, .050e4a): exec(1-1), time(0.009 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.050e50, .050e54): exec(5), time(0.047 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.050e58, .050e64): exec(21), time(0.240 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.050e68, .050e74): exec(21), time(0.260 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.050e78, .050e84): exec(14), time(0.201 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.050eb8, .050edf): exec(3), time(0.361-0.307 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:25:[.050ee8, .050f0f): exec(4), time(0.432-0.360 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:30:[.050f10, .050f37): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.050f38, .050f5f): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:62:[.050f60, .050fa2): exec(1), time(0.203-0.173 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:68:[.050fa8, .050fe7): exec(1), time(0.189-0.159 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.050fe7, .053a6b): exec(1), time(27.093-21.285 ms): .main

---------- Profile statements: 886/1136, coverage: 77.99%
lib/stdlib.ci:68:[.04fca1, .04fca2) exec(8), time(0.041-0.041 ms): <assertEq+9>
lib/stdlib.ci:67:[.04fc98, .04fca2) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:71:[.04fca6, .04fcb1) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:72:[.04fcb1, .04fcbc) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:73:[.04fcbc, .04fcbf) exec(0), time(0.000 ms): <assertEq+36>
::[.04fcbf, .04fccb) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:70:[.04fca2, .04fccb) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:75:[.04fccb, .04fcf1) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.04fd10, .04fd21) exec(3), time(0.055-0.055 ms): <modf+24>
lib/std/math.ci:26:[.04fd21, .04fd28) exec(3), time(0.002-0.002 ms): <modf+41>
lib/std/math.ci:27:[.04fd28, .04fd2b) exec(3), time(0.015-0.015 ms): <modf+48>
lib/std/math.ci:24:[.04fd08, .04fd2f) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.04fd2f, .04fd33) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.04fd33, .04fd37) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.04fcf8, .04fd37) exec(10-3), time(0.003-0.003 ms): <modf+0>
lib/std/math.ci:32:[.04fd37, .04fd43) exec(7), time(0.003-0.003 ms): <modf+63>
lib/std/math.ci:33:[.04fd43, .04fd4b) exec(7), time(0.003-0.003 ms): <modf+75>
lib/std/math.ci:34:[.04fd4b, .04fd4e) exec(7), time(0.048-0.048 ms): <modf+83>
lib/std/math.ci:48:[.04fd50, .04fd51) exec(6), time(0.004-0.004 ms): <floor+0>
lib/std/math.ci:49:[.04fd51, .04fd65) exec(6), time(0.153-0.153 ms): <floor+1>
lib/std/math.ci:50:[.04fd65, .04fd68) exec(6), time(0.030-0.030 ms): <floor+21>
lib/std/math.ci:79:[.04fd70, .04fd76) exec(1), time(0.005-0.005 ms): <abs+8>
lib/std/math.ci:78:[.04fd68, .04fd76) exec(3-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:81:[.04fd76, .04fd7a) exec(2), time(0.010-0.010 ms): <abs+14>
lib/std/math.ci:87:[.04fd88, .04fd8e) exec(1), time(0.005-0.005 ms): <abs+8>
lib/std/math.ci:86:[.04fd80, .04fd8e) exec(4-1), time(0.002-0.002 ms): <abs+0>
lib/std/math.ci:89:[.04fd8e, .04fd92) exec(3), time(0.016-0.016 ms): <abs+14>
lib/std/math.ci:95:[.04fda7, .04fdaf) exec(4), time(0.022-0.022 ms): <absMod+15>
lib/std/math.ci:94:[.04fd98, .04fdaf) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:97:[.04fdaf, .04fdb3) exec(7), time(0.036-0.036 ms): <absMod+23>
lib/std/math.ci:103:[.04fdc7, .04fdcf) exec(4), time(0.021-0.021 ms): <absMod+15>
lib/std/math.ci:102:[.04fdb8, .04fdcf) exec(11-4), time(0.006-0.006 ms): <absMod+0>
lib/std/math.ci:105:[.04fdcf, .04fdd3) exec(7), time(0.051-0.051 ms): <absMod+23>
lib/std/math.ci:117:[.04fde1, .04fde5) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:116:[.04fdd8, .04fde5) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.04fde5, .04fde9) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.04fdf9, .04fdfd) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:124:[.04fdf0, .04fdfd) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.04fdfd, .04fe01) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.04fe11, .04fe15) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.04fe08, .04fe15) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.04fe15, .04fe19) exec(1), time(0.005-0.005 ms): <max+13>
lib/std/math.ci:147:[.04fe29, .04fe2d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.04fe20, .04fe2d) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.04fe2d, .04fe31) exec(1), time(0.005-0.005 ms): <max+13>
lib/std/math.ci:161:[.04fe41, .04fe45) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.04fe38, .04fe45) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:164:[.04fe4e, .04fe52) exec(1), time(0.005-0.005 ms): <clamp+22>
lib/std/math.ci:163:[.04fe45, .04fe52) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:166:[.04fe52, .04fe56) exec(1), time(0.005-0.005 ms): <clamp+26>
lib/std/math.ci:172:[.04fe61, .04fe65) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.04fe58, .04fe65) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:175:[.04fe6e, .04fe72) exec(1), time(0.006-0.006 ms): <clamp+22>
lib/std/math.ci:174:[.04fe65, .04fe72) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:177:[.04fe72, .04fe76) exec(1), time(0.005-0.005 ms): <clamp+26>
lib/std/math.ci:203:[.04fe80, .04fe85) exec(1), time(0.006-0.006 ms): <min+8>
lib/std/math.ci:202:[.04fe78, .04fe85) exec(2-1), time(0.000 ms): <min+0>
lib/std/math.ci:205:[.04fe85, .04fe88) exec(1), time(0.000 ms): <min+13>
lib/std/math.ci:208:[.04fea1, .04feac) exec(2), time(0.002-0.002 ms): <min+41>
lib/std/math.ci:207:[.04fe91, .04feac) exec(8-2), time(0.005-0.005 ms): <min+25>
lib/std/math.ci:206:[.04feac, .04feb0) exec(8), time(0.001-0.001 ms): <min+52>
lib/std/math.ci:206:[.04feb0, .04feb9) exec(9), time(0.006-0.006 ms): <min+56>
lib/std/math.ci:206:[.04fe88, .04febd) exec(1), time(0.001-0.001 ms): <min+16>
lib/std/math.ci:211:[.04febd, .04fec0) exec(1), time(0.006-0.006 ms): <min+69>
lib/std/math.ci:217:[.04fec8, .04fecd) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:216:[.04fec0, .04fecd) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.04fecd, .04fed0) exec(1), time(0.000 ms): <max+13>
lib/std/math.ci:222:[.04fee9, .04fef4) exec(2), time(0.002-0.002 ms): <max+41>
lib/std/math.ci:221:[.04fed9, .04fef4) exec(8-2), time(0.006-0.006 ms): <max+25>
lib/std/math.ci:220:[.04fef4, .04fef8) exec(8), time(0.003-0.003 ms): <max+52>
lib/std/math.ci:220:[.04fef8, .04ff01) exec(9), time(0.008-0.008 ms): <max+56>
lib/std/math.ci:220:[.04fed0, .04ff05) exec(1), time(0.001-0.001 ms): <max+16>
lib/std/math.ci:225:[.04ff05, .04ff08) exec(1), time(0.005-0.005 ms): <max+69>
lib/std/math.ci:230:[.04ff08, .04ff09) exec(4), time(0.002-0.002 ms): <sum+0>
lib/std/math.ci:232:[.04ff0e, .04ff1c) exec(13), time(0.011-0.011 ms): <sum+6>
lib/std/math.ci:231:[.04ff1c, .04ff20) exec(13), time(0.004-0.004 ms): <sum+20>
lib/std/math.ci:231:[.04ff20, .04ff29) exec(17), time(0.011-0.011 ms): <sum+24>
lib/std/math.ci:231:[.04ff09, .04ff2d) exec(4), time(0.005-0.005 ms): <sum+1>
lib/std/math.ci:234:[.04ff2d, .04ff30) exec(4), time(0.021-0.021 ms): <sum+37>
lib/std/math.ci:257:[.04ff30, .04ff31) exec(3), time(0.002-0.002 ms): <eval+0>
lib/std/math.ci:259:[.04ff3b, .04ff4c) exec(11), time(0.010-0.010 ms): <eval+11>
lib/std/math.ci:258:[.04ff4c, .04ff50) exec(11), time(0.005-0.005 ms): <eval+28>
lib/std/math.ci:258:[.04ff50, .04ff58) exec(14), time(0.007-0.007 ms): <eval+32>
lib/std/math.ci:258:[.04ff31, .04ff5c) exec(3), time(0.004-0.004 ms): <eval+1>
lib/std/math.ci:261:[.04ff5c, .04ff5f) exec(3), time(0.018-0.018 ms): <eval+44>
lib/std/math.ci:268:[.04ff75, .04ff7d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.04ff69, .04ff7d) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.04ff8d, .04ff95) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.04ff81, .04ff95) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.04ff60, .04ff95) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:276:[.04ff95, .04ff99) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:283:[.04ffb5, .04ffbd) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.04ffa9, .04ffbd) exec(1), time(0.014-0.014 ms): <cmp+9>
lib/std/math.ci:288:[.04ffcd, .04ffd5) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.04ffc1, .04ffd5) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.04ffa0, .04ffd5) exec(1), time(0.015-0.015 ms): <cmp+0>
lib/std/math.ci:291:[.04ffd5, .04ffd9) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:309:[.04ffe0, .04ffe2) exec(2), time(0.002-0.002 ms): <sinCos+0>
lib/std/math.ci:311:[.04ffea, .04ffeb) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.04ffeb, .04fff3) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.04ffe2, .04fff3) exec(2), time(0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:315:[.04fff3, .04fff4) exec(2), time(0.002-0.002 ms): <sinCos+19>
lib/std/math.ci:316:[.04fff4, .05000c) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:318:[.05001c, .05001d) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.05001d, .05002f) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.05002f, .050033) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.050033, .050034) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.050034, .050052) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.050052, .050064) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.05006c, .05006f) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:328:[.05006f, .050077) exec(2), time(0.001-0.001 ms): <sinCos+143>
lib/std/math.ci:329:[.050077, .05007e) exec(2), time(0.001-0.001 ms): <sinCos+151>
lib/std/math.ci:330:[.05007e, .050084) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:317:[.05000c, .050088) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:333:[.050090, .05009e) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:332:[.050088, .05009e) exec(2-1), time(0.001-0.001 ms): <sinCos+168>
lib/std/math.ci:336:[.0500aa, .0500ab) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:335:[.05009e, .0500ab) exec(2-1), time(0.000 ms): <sinCos+190>
lib/std/math.ci:339:[.0500ab, .0500b0) exec(2), time(0.001-0.001 ms): <sinCos+203>
lib/std/math.ci:340:[.0500b0, .0500f0) exec(2), time(0.005-0.005 ms): <sinCos+208>
lib/std/math.ci:341:[.0500f0, .050123) exec(2), time(0.003-0.003 ms): <sinCos+272>
lib/std/math.ci:342:[.050123, .05012f) exec(2), time(0.012-0.012 ms): <sinCos+323>
lib/std/math.ci:365:[.050130, .050131) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.050131, .050132) exec(1), time(0.001-0.001 ms): <tan+1>
lib/std/math.ci:369:[.05013a, .05013f) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.05013f, .050149) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.050132, .050149) exec(1), time(0.001-0.001 ms): <tan+2>
lib/std/math.ci:372:[.050149, .050161) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.050161, .050162) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:375:[.050162, .050172) exec(1), time(0.042-0.042 ms): <tan+50>
lib/std/math.ci:376:[.050172, .05017b) exec(1), time(0.000 ms): <tan+66>
lib/std/math.ci:380:[.05018f, .05019d) exec(1), time(0.000 ms): <tan+95>
lib/std/math.ci:381:[.05019d, .0501a7) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.0501b7, .0501c2) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.0501c2, .0501cc) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.0501dc, .0501ea) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.0501ea, .0501f5) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.0501d0, .0501f5) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.0501ab, .0501f5) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.050183, .0501f5) exec(1), time(0.001-0.001 ms): <tan+83>
lib/std/math.ci:378:[.05017b, .0501f5) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.0501f5, .0501fa) exec(1), time(0.000 ms): <tan+197>
lib/std/math.ci:393:[.0501fa, .05023a) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.05023a, .050261) exec(1), time(0.002-0.002 ms): <tan+266>
lib/std/math.ci:398:[.050272, .05027b) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.05026a, .05027b) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.05027b, .050289) exec(1), time(0.000 ms): <tan+331>
lib/std/math.ci:396:[.050261, .050289) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.050292, .05029c) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:402:[.050289, .05029c) exec(1), time(0.000 ms): <tan+345>
lib/std/math.ci:405:[.05029c, .0502a3) exec(1), time(0.005-0.005 ms): <tan+364>
lib/std/math.ci:421:[.0502a8, .0502a9) exec(1), time(0.001-0.001 ms): <sinh+0>
lib/std/math.ci:423:[.0502b1, .0502b6) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.0502b6, .0502c0) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.0502a9, .0502c0) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.0502d0, .0502e7) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.0502c0, .0502e7) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:431:[.0502e7, .0502e8) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:433:[.0502f8, .050312) exec(1), time(0.027-0.027 ms): <sinh+80>
lib/std/math.ci:436:[.050316, .05031b) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.05031b, .050350) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.050350, .05037b) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.0502e8, .05037f) exec(1), time(0.028-0.028 ms): <sinh+64>
lib/std/math.ci:442:[.050388, .050392) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.05037f, .050392) exec(1), time(0.000 ms): <sinh+215>
lib/std/math.ci:444:[.050392, .050399) exec(1), time(0.005-0.005 ms): <sinh+234>
lib/std/math.ci:450:[.0503a8, .0503ad) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.0503a0, .0503ad) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:453:[.0503bd, .0503d0) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.0503ad, .0503d0) exec(1), time(0.000 ms): <cosh+13>
lib/std/math.ci:455:[.0503d0, .0503eb) exec(1), time(0.029-0.029 ms): <cosh+48>
lib/std/math.ci:466:[.0503f8, .0503fc) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.0503f0, .0503fc) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:469:[.0503fc, .0503fd) exec(2), time(0.000 ms): <asin+12>
lib/std/math.ci:471:[.050405, .05040f) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.05040f, .050414) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.0503fd, .050414) exec(2), time(0.000 ms): <asin+13>
lib/std/math.ci:477:[.050424, .05042d) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.050414, .05042d) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.05042d, .050440) exec(2), time(0.026-0.026 ms): <asin+61>
lib/std/math.ci:482:[.050450, .05046e) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:485:[.050472, .05047c) exec(2), time(0.040-0.040 ms): <asin+130>
lib/std/math.ci:481:[.050440, .05047c) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:489:[.050485, .05048f) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:488:[.05047c, .05048f) exec(2), time(0.000 ms): <asin+140>
lib/std/math.ci:491:[.05048f, .050496) exec(2), time(0.012-0.012 ms): <asin+159>
::[.05049b, .05049e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.050498, .05049f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.0504a3, .0504a6) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.0504a0, .0504a7) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.0504c7, .0504cc) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.0504cc, .0504d4) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.0504e1, .0504ee) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.0504d4, .0504f3) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.0504a8, .0504f7) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.0504f7, .0504fc) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.0504fc, .050504) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.050511, .05051e) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.050504, .050523) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.050528, .050533) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.05053a, .050542) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.050533, .050547) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.050548, .05055f) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.05055f, .05056f) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.05056f, .05057e) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.05057e, .050591) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.05059c, .0505a7) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.050591, .0505ac) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.0505bc, .0505c0) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.0505b0, .0505c0) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.0505c0, .0505c1) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.0505c5, .0505c9) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.0505c9, .0505d3) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.0505c1, .0505d3) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.0505d3, .0505d6) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.0505ed, .0505f0) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.0505dd, .0505f0) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.0505f0, .0505f4) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.0505f4, .0505fe) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.0505d8, .050602) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.050602, .05060a) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.050610, .050615) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.05062a, .05062d) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.05061a, .05062d) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.05062d, .050631) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.050631, .05063b) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.050615, .05063f) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.05063f, .050642) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.050667, .050672) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.05064d, .050672) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.050672, .050676) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.050676, .050682) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.050648, .050686) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.050686, .050691) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.050698, .0506a5) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.0506a5, .0506b2) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.0506bb, .0506c6) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.0506b2, .0506c6) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.0506eb, .0506f6) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.0506cb, .0506f6) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.0506f6, .0506fa) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.0506fa, .050703) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.0506c6, .050707) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.050707, .050716) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.050718, .050719) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.05071e, .050734) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.050740, .050744) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.050734, .050744) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.050744, .050748) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.050748, .050750) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.050719, .050754) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.050754, .050757) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.050767, .050772) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.050758, .050772) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.050781, .05078c) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.050772, .05078c) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.05078c, .05079f) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.0507a0, .0507c4) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.0507c8, .0507d6) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.0507e6, .0507ea) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.0507dd, .0507ea) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.0507ea, .0507f6) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.0507f6, .0507fe) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.0507fe, .050802) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.050802, .05080c) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.0507d8, .050810) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.050819, .050821) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.050810, .050821) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.050821, .050828) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.050828, .05082c) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.050840, .050841) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.050841, .050845) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.050845, .050848) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.050848, .05087e) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.05087e, .0508b3) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.0508b7, .0508d2) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.0508d2, .0508d9) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.0508d9, .0508e1) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.0508b3, .0508e1) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.0508e9, .0508fe) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.0508e1, .0508fe) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.0508fe, .050908) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.050908, .05090f) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.05091a, .050924) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.05090f, .050924) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.05092f, .050937) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.050955, .050989) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.050989, .050994) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.050994, .05099c) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.05099c, .0509a4) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.0509a4, .0509ac) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.050951, .0509ac) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.050937, .0509ac) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.0509ac, .0509e0) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.0509e0, .0509eb) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.0509eb, .0509f3) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.050924, .0509f3) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.0509f7, .050a2b) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.050a2b, .050a36) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.050a36, .050a3e) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.050a3e, .050a46) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.050a46, .050a4e) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.0509f3, .050a4e) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.050a53, .050a87) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.050a87, .050a98) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.050a98, .050aa0) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.050aa0, .050aa4) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.050aa4, .050aad) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.050a4e, .050ab1) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.050aba, .050ac2) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.050ab1, .050ac2) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.050ac2, .050ac9) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.050ac9, .050ad1) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.050ad8, .050aef) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.050af0, .050af1) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.050af9, .050b00) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.050b00, .050b05) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.050af1, .050b05) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.050b05, .050b21) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.050b38, .050b51) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.050b5b, .050b5e) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.050b58, .050b5f) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.050b63, .050b66) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.050b66, .050b69) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.050b69, .050b6c) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.050b60, .050b6d) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:32:[.050b73, .050b76) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:32:[.050b76, .050b79) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:32:[.050b79, .050b7c) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:33:[.050b7c, .050b7f) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:33:[.050b7f, .050b82) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:33:[.050b82, .050b85) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:33:[.050b85, .050b88) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:34:[.050b88, .050b8b) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:34:[.050b8b, .050b8e) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:34:[.050b8e, .050b91) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:34:[.050b91, .050b94) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:35:[.050b94, .050b97) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:35:[.050b97, .050b9a) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:35:[.050b9a, .050b9d) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:35:[.050b9d, .050ba0) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:31:[.050b70, .050ba1) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:41:[.050bad, .050bb2) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:41:[.050bb2, .050bb7) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:41:[.050bb7, .050bbc) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:41:[.050ba8, .050bbd) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:54:[.050bc4, .050bc9) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:54:[.050bc9, .050bd2) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:54:[.050bd2, .050bdb) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:54:[.050bdb, .050be4) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:55:[.050be4, .050bed) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:55:[.050bed, .050bf6) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:55:[.050bf6, .050bff) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:55:[.050bff, .050c08) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:56:[.050c08, .050c11) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:56:[.050c11, .050c1a) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:56:[.050c1a, .050c23) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:56:[.050c23, .050c2c) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:57:[.050c2c, .050c35) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:57:[.050c35, .050c3e) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:57:[.050c3e, .050c47) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:57:[.050c47, .050c50) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:53:[.050bc0, .050c50) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:61:[.050c90, .050cd4) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:62:[.050cd4, .050d18) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:63:[.050d18, .050d5c) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:59:[.050c50, .050d61) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:7:[.050d78, .050d80) exec(2), time(0.029-0.029 ms): <funAdd+0>
test/lang/function.ci:33:[.050d80, .050d88) exec(2), time(0.014-0.014 ms): <funMul+0>
test/lang/function.ci:39:[.050d94, .050d98) exec(377), time(2.613-2.613 ms): <fib+12>
test/lang/function.ci:38:[.050d88, .050d98) exec(753-377), time(0.692-0.692 ms): <fib+0>
test/lang/function.ci:41:[.050d98, .050dbe) exec(376-375), time(15.448-15.448 ms): <fib+16>
test/stdc/tryExec.ci:15:[.050dc8, .050dcc) exec(64-1), time(0.030-0.030 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.050dcc, .050ddb) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.050de0, .050de7) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.050df4, .050dfb) exec(1), time(0.000 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.050dfb, .050e02) exec(1), time(0.001-0.001 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.050e02, .050e09) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.050df0, .050e09) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.050e09, .050e2f) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.050e38, .050e3d) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.050e3d, .050e40) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.050e48, .050e4a) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.050e50, .050e54) exec(5), time(0.032-0.032 ms): <lenSlice+0>
test/lang/array.ci:104:[.050e58, .050e64) exec(21), time(0.174-0.174 ms): <nthFixed+0>
test/lang/array.ci:105:[.050e68, .050e74) exec(21), time(0.165-0.165 ms): <nthArray+0>
test/lang/array.ci:106:[.050e78, .050e84) exec(14), time(0.110-0.110 ms): <nthSlice+0>
test/lang/method.ci:7:[.050eb8, .050ede) exec(3), time(0.334-0.334 ms): <staticMethod+0>
test/lang/method.ci:26:[.050ee8, .050f0e) exec(4), time(0.398-0.398 ms): <virtualMethod+0>
test/lang/method.ci:31:[.050f10, .050f36) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.050f38, .050f5e) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:63:[.050f60, .050f83) exec(1), time(0.023-0.023 ms): <staticMethod+0>
test/lang/method.ci:65:[.050f91, .050fa1) exec(1), time(0.168-0.168 ms): <staticMethod+49>
test/lang/method.ci:64:[.050f83, .050fa1) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:69:[.050fa8, .050fcb) exec(1), time(0.022-0.022 ms): <virtualMethod+0>
test/lang/method.ci:71:[.050fd9, .050fe6) exec(1), time(0.154-0.154 ms): <virtualMethod+49>
test/lang/method.ci:70:[.050fcb, .050fe6) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.050fe7, .050ff5) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.050ff5, .051003) exec(1), time(0.001-0.001 ms): <.main+14>
::[.05100c, .051013) exec(1), time(0.001-0.001 ms): <.main+37>
::[.051013, .051018) exec(1), time(0.001-0.001 ms): <.main+44>
::[.051018, .05101d) exec(1), time(0.000 ms): <.main+49>
lib/std/string.ci:223:[.051003, .05101d) exec(1-1), time(0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.05101d, .05102a) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.05102a, .05102f) exec(1), time(0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.05102f, .051038) exec(1), time(0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.051038, .051041) exec(1), time(0.000 ms): <.main+81>
test/lang/member.ci:47:[.05104a, .051053) exec(1), time(0.000 ms): <.main+99>
test/lang/member.ci:47:[.051041, .051053) exec(1-1), time(0.000 ms): <.main+90>
test/lang/member.ci:50:[.05105c, .051065) exec(1), time(0.000 ms): <.main+117>
test/lang/member.ci:50:[.051053, .051065) exec(1-1), time(0.000 ms): <.main+108>
test/lang/method.ci:11:[.051065, .05106e) exec(1), time(0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.05106e, .05106f) exec(1), time(0.000 ms): <.main+135>
test/lang/emit.ci:4:[.05106f, .051070) exec(1), time(0.001-0.001 ms): <.main+136>
test/lang/emit.ci:6:[.051070, .051075) exec(1), time(0.000 ms): <.main+137>
test/lang/emit.ci:7:[.051075, .05107a) exec(1), time(0.000 ms): <.main+142>
test/lang/emit.ci:9:[.05107a, .05107f) exec(1), time(0.001-0.001 ms): <.main+147>
test/lang/emit.ci:10:[.05107f, .05108a) exec(1), time(0.002-0.002 ms): <.main+152>
test/lang/emit.ci:17:[.05108a, .05108f) exec(1), time(0.000 ms): <.main+163>
test/lang/emit.ci:18:[.05108f, .051095) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.051095, .05109f) exec(1), time(0.001-0.001 ms): <.main+174>
test/lang/emit.ci:20:[.05109f, .0510a8) exec(1), time(0.001-0.001 ms): <.main+184>
test/lang/emit.ci:23:[.0510a8, .0510b2) exec(1), time(0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.0510b2, .0510b7) exec(1), time(0.001-0.001 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.0510b7, .0510bc) exec(1), time(0.000 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.0510bc, .0510c1) exec(1), time(0.000 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.0510c1, .0510c6) exec(1), time(0.001-0.001 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.0510c6, .0510c7) exec(1), time(0.001-0.001 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.0510c7, .0510c8) exec(1), time(0.000 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.0510c8, .0510c9) exec(1), time(0.000 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.0510c9, .0510ce) exec(1), time(0.001-0.001 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.0510ce, .0510d0) exec(1), time(0.001-0.001 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.0510d0, .0510da) exec(1), time(0.001-0.001 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.0510da, .0510e3) exec(1), time(0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.0510e3, .0510e8) exec(1), time(0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.0510e8, .0510f9) exec(1), time(0.003-0.003 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.0510f9, .051111) exec(1), time(0.002-0.002 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.051111, .051123) exec(1), time(0.003-0.003 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.051123, .051141) exec(1), time(0.003-0.003 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.051141, .051162) exec(1), time(0.005-0.005 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.051162, .05117d) exec(1), time(0.004-0.004 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.05117d, .0511a4) exec(1), time(0.006-0.006 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.0511a4, .0511c5) exec(1), time(0.004-0.004 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.0511c5, .0511e0) exec(1), time(0.004-0.004 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.0511e0, .051207) exec(1), time(0.006-0.006 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.051207, .05121c) exec(1), time(0.003-0.003 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.05121c, .05122d) exec(1), time(0.002-0.002 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.05122d, .051238) exec(1), time(0.003-0.003 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.051238, .051243) exec(1), time(0.003-0.003 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.051243, .051262) exec(1), time(0.006-0.006 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.051262, .051281) exec(1), time(0.006-0.006 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.051281, .0512bf) exec(1), time(0.003-0.003 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.0512bf, .0512fd) exec(1), time(0.007-0.007 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.0512fd, .05132f) exec(1), time(0.003-0.003 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.05132f, .051361) exec(1), time(0.007-0.007 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.051361, .0513a7) exec(1), time(0.004-0.004 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.0513a7, .0513ed) exec(1), time(0.008-0.008 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.0513ed, .051446) exec(1), time(0.013-0.013 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.051446, .05149f) exec(1), time(0.012-0.012 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.05149f, .0514ec) exec(1), time(0.013-0.013 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.0514ec, .051539) exec(1), time(0.013-0.013 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.051539, .05159a) exec(1), time(0.015-0.015 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.05159a, .0515fb) exec(1), time(0.016-0.016 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.0515fb, .051654) exec(1), time(0.013-0.013 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.051654, .0516ad) exec(1), time(0.013-0.013 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.0516ad, .0516fa) exec(1), time(0.012-0.012 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.0516fa, .051747) exec(1), time(0.013-0.013 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.051747, .0517a8) exec(1), time(0.014-0.014 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.0517a8, .051809) exec(1), time(0.016-0.016 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.051809, .05180e) exec(1), time(0.000 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.05180e, .051813) exec(1), time(0.000 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.051813, .051818) exec(1), time(0.001-0.001 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.051818, .05181d) exec(1), time(0.000 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.05181d, .051822) exec(1), time(0.000 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.051822, .05182b) exec(1), time(0.001-0.001 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.05182b, .051841) exec(1), time(0.002-0.002 ms): <.main+2116>
test/lang/initByRef.ci:8:[.051841, .051846) exec(1), time(0.001-0.001 ms): <.main+2138>
test/lang/initByRef.ci:9:[.051846, .05184b) exec(1), time(0.001-0.001 ms): <.main+2143>
test/lang/initByRef.ci:10:[.05184b, .051855) exec(1), time(0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.051855, .051858) exec(1), time(0.001-0.001 ms): <.main+2158>
test/lang/initByRef.ci:13:[.051858, .05185a) exec(1), time(0.000 ms): <.main+2161>
test/lang/initByRef.ci:14:[.05185a, .05185c) exec(1), time(0.000 ms): <.main+2163>
test/lang/initByRef.ci:16:[.05185c, .051861) exec(1), time(0.001-0.001 ms): <.main+2165>
test/lang/initByRef.ci:17:[.051861, .051866) exec(1), time(0.000 ms): <.main+2170>
test/lang/initByRef.ci:18:[.051866, .051870) exec(1), time(0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.051870, .051875) exec(1), time(0.000 ms): <.main+2185>
test/lang/initByRef.ci:20:[.051875, .05187a) exec(1), time(0.001-0.001 ms): <.main+2190>
test/lang/initByRef.ci:21:[.05187a, .05187f) exec(1), time(0.001-0.001 ms): <.main+2195>
test/lang/initByRef.ci:23:[.05187f, .051884) exec(1), time(0.000 ms): <.main+2200>
test/lang/initByRef.ci:24:[.051884, .05188e) exec(1), time(0.001-0.001 ms): <.main+2205>
test/lang/initByRef.ci:25:[.05188e, .051893) exec(1), time(0.000 ms): <.main+2215>
test/lang/initByRef.ci:27:[.051893, .051897) exec(1), time(0.001-0.001 ms): <.main+2220>
test/lang/initByRef.ci:28:[.051897, .051899) exec(1), time(0.000 ms): <.main+2224>
test/lang/initByRef.ci:29:[.051899, .05189b) exec(1), time(0.000 ms): <.main+2226>
test/lang/initByRef.ci:30:[.05189b, .05189d) exec(1), time(0.001-0.001 ms): <.main+2228>
test/lang/initByRef.ci:31:[.05189d, .05189f) exec(1), time(0.000 ms): <.main+2230>
test/lang/initByRef.ci:32:[.05189f, .0518a1) exec(1), time(0.000 ms): <.main+2232>
test/lang/initByRef.ci:35:[.0518a1, .0518a6) exec(1), time(0.001-0.001 ms): <.main+2234>
test/lang/initByRef.ci:36:[.0518a6, .0518ab) exec(1), time(0.000 ms): <.main+2239>
test/lang/initByRef.ci:37:[.0518ab, .0518b0) exec(1), time(0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.0518b0, .0518b5) exec(1), time(0.001-0.001 ms): <.main+2249>
test/lang/initByRef.ci:39:[.0518b5, .0518ba) exec(1), time(0.000 ms): <.main+2254>
test/lang/initByRef.ci:40:[.0518ba, .0518bf) exec(1), time(0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.0518bf, .0518c4) exec(1), time(0.001-0.001 ms): <.main+2264>
test/lang/initByRef.ci:42:[.0518c4, .0518c9) exec(1), time(0.000 ms): <.main+2269>
test/lang/initByRef.ci:43:[.0518c9, .0518ce) exec(1), time(0.000 ms): <.main+2274>
test/lang/initByRef.ci:44:[.0518ce, .0518d3) exec(1), time(0.001-0.001 ms): <.main+2279>
test/lang/initByRef.ci:45:[.0518d3, .0518d8) exec(1), time(0.000 ms): <.main+2284>
test/lang/initByRef.ci:46:[.0518d8, .0518dd) exec(1), time(0.000 ms): <.main+2289>
test/lang/initByRef.ci:47:[.0518dd, .0518e2) exec(1), time(0.001-0.001 ms): <.main+2294>
test/lang/initByRef.ci:48:[.0518e2, .0518e7) exec(1), time(0.000 ms): <.main+2299>
test/lang/initByRef.ci:49:[.0518e7, .0518ec) exec(1), time(0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.0518ec, .0518f1) exec(1), time(0.001-0.001 ms): <.main+2309>
test/lang/initByRef.ci:51:[.0518f1, .0518f6) exec(1), time(0.000 ms): <.main+2314>
test/lang/initByRef.ci:52:[.0518f6, .0518fb) exec(1), time(0.000 ms): <.main+2319>
test/lang/initByRef.ci:55:[.0518fb, .051905) exec(1), time(0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.051905, .05190f) exec(1), time(0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.05190f, .051919) exec(1), time(0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.051919, .051923) exec(1), time(0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.051923, .05192d) exec(1), time(0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.05192d, .051937) exec(1), time(0.001-0.001 ms): <.main+2374>
test/lang/initByRef.ci:61:[.051937, .051941) exec(1), time(0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.051941, .05194b) exec(1), time(0.001-0.001 ms): <.main+2394>
test/lang/initByRef.ci:63:[.05194b, .051955) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/initByRef.ci:64:[.051955, .05195f) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.05195f, .051969) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.051969, .051973) exec(1), time(0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.051973, .05197d) exec(1), time(0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.05197d, .051987) exec(1), time(0.001-0.001 ms): <.main+2454>
test/lang/initByRef.ci:69:[.051987, .051991) exec(1), time(0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.051991, .05199b) exec(1), time(0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.05199b, .0519a5) exec(1), time(0.001-0.001 ms): <.main+2484>
test/lang/initByRef.ci:72:[.0519a5, .0519af) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.0519af, .0519b4) exec(1), time(0.000 ms): <.main+2504>
test/lang/initByRef.ci:76:[.0519b4, .0519b9) exec(1), time(0.000 ms): <.main+2509>
test/lang/initByRef.ci:77:[.0519b9, .0519be) exec(1), time(0.001-0.001 ms): <.main+2514>
test/lang/initByRef.ci:78:[.0519be, .0519c3) exec(1), time(0.000 ms): <.main+2519>
test/lang/initByRef.ci:79:[.0519c3, .0519c8) exec(1), time(0.000 ms): <.main+2524>
test/lang/initByRef.ci:80:[.0519c8, .0519cd) exec(1), time(0.001-0.001 ms): <.main+2529>
test/lang/initByRef.ci:81:[.0519cd, .0519d2) exec(1), time(0.000 ms): <.main+2534>
test/lang/initByRef.ci:82:[.0519d2, .0519d7) exec(1), time(0.001-0.001 ms): <.main+2539>
test/lang/initByRef.ci:83:[.0519d7, .0519dc) exec(1), time(0.000 ms): <.main+2544>
test/lang/initByRef.ci:84:[.0519dc, .0519e1) exec(1), time(0.000 ms): <.main+2549>
test/lang/initByRef.ci:85:[.0519e1, .0519e6) exec(1), time(0.001-0.001 ms): <.main+2554>
test/lang/initByRef.ci:86:[.0519e6, .0519eb) exec(1), time(0.000 ms): <.main+2559>
test/lang/initByRef.ci:87:[.0519eb, .0519f0) exec(1), time(0.000 ms): <.main+2564>
test/lang/initByRef.ci:88:[.0519f0, .0519f5) exec(1), time(0.001-0.001 ms): <.main+2569>
test/lang/initByRef.ci:89:[.0519f5, .0519fa) exec(1), time(0.000 ms): <.main+2574>
test/lang/initByRef.ci:90:[.0519fa, .0519ff) exec(1), time(0.001-0.001 ms): <.main+2579>
test/lang/initByRef.ci:91:[.0519ff, .051a04) exec(1), time(0.000 ms): <.main+2584>
test/lang/initByRef.ci:92:[.051a04, .051a09) exec(1), time(0.000 ms): <.main+2589>
test/lang/initByRef.ci:95:[.051a09, .051a0e) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:96:[.051a0e, .051a18) exec(1), time(0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.051a18, .051a1d) exec(1), time(0.000 ms): <.main+2609>
test/lang/initByRef.ci:99:[.051a1d, .051a22) exec(1), time(0.001-0.001 ms): <.main+2614>
test/lang/initByRef.ci:105:[.051a22, .051a29) exec(1), time(0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.051a29, .051a2b) exec(1), time(0.000 ms): <.main+2626>
test/lang/function.ci:11:[.051a2b, .051a40) exec(1), time(0.024-0.024 ms): <.main+2628>
test/lang/function.ci:14:[.051a40, .051a45) exec(1), time(0.000 ms): <.main+2649>
test/lang/function.ci:17:[.051a45, .051a57) exec(1), time(0.052-0.052 ms): <.main+2654>
test/lang/function.ci:20:[.051a57, .051a5c) exec(1), time(0.001-0.001 ms): <.main+2672>
test/lang/function.ci:23:[.051a5c, .051a6e) exec(1), time(0.018-0.018 ms): <.main+2677>
test/lang/function.ci:26:[.051a6e, .051a70) exec(1), time(0.000 ms): <.main+2695>
test/lang/function.ci:29:[.051a70, .051a82) exec(1), time(0.019-0.019 ms): <.main+2697>
test/lang/function.ci:45:[.051a82, .051a92) exec(1), time(15.461-15.461 ms): <.main+2715>
test/lang/reflect.ci:3:[.051a92, .051a96) exec(1), time(0.000 ms): <.main+2731>
test/lang/reflect.ci:4:[.051a96, .051a9a) exec(1), time(0.000 ms): <.main+2735>
test/lang/reflect.ci:5:[.051a9a, .051a9e) exec(1), time(0.001-0.001 ms): <.main+2739>
test/lang/reflect.ci:6:[.051a9e, .051aa2) exec(1), time(0.000 ms): <.main+2743>
test/lang/reflect.ci:7:[.051aa2, .051aa6) exec(1), time(0.000 ms): <.main+2747>
test/lang/reflect.ci:8:[.051aa6, .051aaa) exec(1), time(0.001-0.001 ms): <.main+2751>
test/lang/reflect.ci:9:[.051aaa, .051aae) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:10:[.051aae, .051ab2) exec(1), time(0.000 ms): <.main+2759>
test/lang/reflect.ci:11:[.051ab2, .051ab6) exec(1), time(0.000 ms): <.main+2763>
test/lang/reflect.ci:12:[.051ab6, .051aba) exec(1), time(0.001-0.001 ms): <.main+2767>
test/lang/reflect.ci:13:[.051aba, .051abe) exec(1), time(0.000 ms): <.main+2771>
test/lang/reflect.ci:14:[.051abe, .051ac2) exec(1), time(0.000 ms): <.main+2775>
test/lang/reflect.ci:15:[.051ac2, .051ac6) exec(1), time(0.001-0.001 ms): <.main+2779>
test/lang/reflect.ci:16:[.051ac6, .051aca) exec(1), time(0.000 ms): <.main+2783>
test/lang/reflect.ci:17:[.051aca, .051ace) exec(1), time(0.000 ms): <.main+2787>
test/lang/reflect.ci:18:[.051ace, .051ad2) exec(1), time(0.001-0.001 ms): <.main+2791>
test/lang/reflect.ci:19:[.051ad2, .051ad6) exec(1), time(0.001-0.001 ms): <.main+2795>
test/lang/reflect.ci:20:[.051ad6, .051ada) exec(1), time(0.000 ms): <.main+2799>
test/lang/reflect.ci:30:[.051ada, .051adf) exec(1), time(0.000 ms): <.main+2803>
test/lang/reflect.ci:31:[.051adf, .051ae5) exec(1), time(0.023-0.023 ms): <.main+2808>
test/lang/reflect.ci:32:[.051ae5, .051aec) exec(1), time(0.002-0.002 ms): <.main+2814>
test/lang/reflect.ci:33:[.051aec, .051af3) exec(1), time(0.001-0.001 ms): <.main+2821>
test/lang/reflect.ci:34:[.051af3, .051af9) exec(1), time(0.015-0.015 ms): <.main+2828>
test/lang/reflect.ci:35:[.051af9, .051aff) exec(1), time(0.015-0.015 ms): <.main+2834>
test/lang/reflect.ci:37:[.051aff, .051b05) exec(1), time(0.014-0.014 ms): <.main+2840>
test/lang/reflect.ci:38:[.051b05, .051b0b) exec(1), time(0.015-0.015 ms): <.main+2846>
test/lang/reflect.ci:39:[.051b0b, .051b12) exec(1), time(0.002-0.002 ms): <.main+2852>
test/lang/reflect.ci:40:[.051b12, .051b19) exec(1), time(0.001-0.001 ms): <.main+2859>
test/lang/reflect.ci:41:[.051b19, .051b1f) exec(1), time(0.015-0.015 ms): <.main+2866>
test/lang/reflect.ci:42:[.051b1f, .051b25) exec(1), time(0.028-0.028 ms): <.main+2872>
test/lang/reflect.ci:44:[.051b25, .051b2b) exec(1), time(0.015-0.015 ms): <.main+2878>
test/lang/reflect.ci:45:[.051b2b, .051b32) exec(1), time(0.002-0.002 ms): <.main+2884>
test/lang/reflect.ci:46:[.051b32, .051b39) exec(1), time(0.002-0.002 ms): <.main+2891>
test/lang/reflect.ci:48:[.051b39, .051b3f) exec(1), time(0.027-0.027 ms): <.main+2898>
test/lang/reflect.ci:49:[.051b3f, .051b46) exec(1), time(0.002-0.002 ms): <.main+2904>
test/lang/reflect.ci:50:[.051b46, .051b4d) exec(1), time(0.001-0.001 ms): <.main+2911>
test/stdc/number.ci:3:[.051b4d, .051b56) exec(1), time(0.001-0.001 ms): <.main+2918>
test/stdc/number.ci:4:[.051b56, .051b5f) exec(1), time(0.000 ms): <.main+2927>
test/stdc/number.ci:6:[.051b5f, .051b62) exec(1), time(0.001-0.001 ms): <.main+2936>
test/stdc/number.ci:7:[.051b62, .051b65) exec(1), time(0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.051b65, .051b6c) exec(1), time(0.001-0.001 ms): <.main+2942>
test/stdc/number.ci:15:[.051b6c, .051b73) exec(1), time(0.001-0.001 ms): <.main+2949>
test/stdc/number.ci:16:[.051b73, .051b7a) exec(1), time(0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.051b7a, .051b96) exec(1), time(0.007-0.007 ms): <.main+2963>
test/stdc/number.ci:19:[.051b96, .051bb0) exec(1), time(0.006-0.006 ms): <.main+2991>
test/stdc/number.ci:21:[.051bb0, .051bc0) exec(1), time(0.016-0.016 ms): <.main+3017>
test/stdc/number.ci:22:[.051bc0, .051bd0) exec(1), time(0.016-0.016 ms): <.main+3033>
test/stdc/number.ci:23:[.051bd0, .051bdc) exec(1), time(0.015-0.015 ms): <.main+3049>
test/stdc/number.ci:25:[.051bdc, .051bec) exec(1), time(0.019-0.019 ms): <.main+3061>
test/stdc/number.ci:26:[.051bec, .051bfc) exec(1), time(0.015-0.015 ms): <.main+3077>
test/stdc/number.ci:27:[.051bfc, .051c08) exec(1), time(0.015-0.015 ms): <.main+3093>
test/stdc/number.ci:29:[.051c08, .051c18) exec(1), time(0.016-0.016 ms): <.main+3105>
test/stdc/number.ci:30:[.051c18, .051c28) exec(1), time(0.015-0.015 ms): <.main+3121>
test/stdc/number.ci:31:[.051c28, .051c34) exec(1), time(0.014-0.014 ms): <.main+3137>
test/stdc/number.ci:33:[.051c34, .051c44) exec(1), time(0.015-0.015 ms): <.main+3149>
test/stdc/number.ci:34:[.051c44, .051c54) exec(1), time(0.015-0.015 ms): <.main+3165>
test/stdc/number.ci:35:[.051c54, .051c60) exec(1), time(0.015-0.015 ms): <.main+3181>
test/stdc/number.ci:37:[.051c60, .051c70) exec(1), time(0.032-0.032 ms): <.main+3193>
test/stdc/number.ci:38:[.051c70, .051c80) exec(1), time(0.021-0.021 ms): <.main+3209>
test/stdc/number.ci:39:[.051c80, .051c90) exec(1), time(0.035-0.035 ms): <.main+3225>
test/stdc/number.ci:40:[.051c90, .051c9c) exec(1), time(0.020-0.020 ms): <.main+3241>
test/stdc/number.ci:41:[.051c9c, .051ca9) exec(1), time(0.028-0.028 ms): <.main+3253>
test/stdc/number.ci:42:[.051ca9, .051cbb) exec(1), time(0.038-0.038 ms): <.main+3266>
test/stdc/number.ci:43:[.051cbb, .051cc4) exec(1), time(0.016-0.016 ms): <.main+3284>
test/stdc/number.ci:44:[.051cc4, .051cd3) exec(1), time(0.016-0.016 ms): <.main+3293>
test/stdc/number.ci:46:[.051cd3, .051cdf) exec(1), time(0.028-0.028 ms): <.main+3308>
test/stdc/number.ci:47:[.051cdf, .051ceb) exec(1), time(0.016-0.016 ms): <.main+3320>
test/stdc/number.ci:48:[.051ceb, .051cf7) exec(1), time(0.016-0.016 ms): <.main+3332>
test/stdc/number.ci:49:[.051cf7, .051d03) exec(1), time(0.017-0.017 ms): <.main+3344>
test/stdc/number.ci:50:[.051d03, .051d0c) exec(1), time(0.014-0.014 ms): <.main+3356>
test/stdc/number.ci:51:[.051d0c, .051d1a) exec(1), time(0.016-0.016 ms): <.main+3365>
test/stdc/number.ci:52:[.051d1a, .051d23) exec(1), time(0.016-0.016 ms): <.main+3379>
test/stdc/number.ci:53:[.051d23, .051d2e) exec(1), time(0.036-0.036 ms): <.main+3388>
test/stdc/number.ci:55:[.051d2e, .051d34) exec(1), time(0.015-0.015 ms): <.main+3399>
test/stdc/number.ci:56:[.051d34, .051d3a) exec(1), time(0.014-0.014 ms): <.main+3405>
test/stdc/number.ci:57:[.051d3a, .051d40) exec(1), time(0.015-0.015 ms): <.main+3411>
test/stdc/number.ci:58:[.051d40, .051d46) exec(1), time(0.014-0.014 ms): <.main+3417>
test/stdc/number.ci:59:[.051d46, .051d4c) exec(1), time(0.014-0.014 ms): <.main+3423>
test/stdc/number.ci:60:[.051d4c, .051d52) exec(1), time(0.028-0.028 ms): <.main+3429>
test/stdc/number.ci:62:[.051d52, .051d5e) exec(1), time(0.016-0.016 ms): <.main+3435>
test/stdc/number.ci:63:[.051d5e, .051d6a) exec(1), time(0.016-0.016 ms): <.main+3447>
test/stdc/number.ci:65:[.051d6a, .051d78) exec(1), time(0.018-0.018 ms): <.main+3459>
test/stdc/number.ci:66:[.051d78, .051d86) exec(1), time(0.017-0.017 ms): <.main+3473>
test/stdc/memory.ci:7:[.051d86, .051d94) exec(1), time(0.028-0.028 ms): <.main+3487>
test/stdc/memory.ci:8:[.051d94, .051da2) exec(1), time(0.018-0.018 ms): <.main+3501>
test/stdc/memory.ci:9:[.051da2, .051db0) exec(1), time(0.015-0.015 ms): <.main+3515>
test/stdc/memory.ci:10:[.051db0, .051dbe) exec(1), time(0.015-0.015 ms): <.main+3529>
test/stdc/memory.ci:13:[.051dbe, .051dce) exec(1), time(0.016-0.016 ms): <.main+3543>
test/stdc/memory.ci:14:[.051dce, .051ddf) exec(1), time(0.017-0.017 ms): <.main+3559>
test/stdc/memory.ci:17:[.051ddf, .051dea) exec(1), time(0.015-0.015 ms): <.main+3576>
test/stdc/memory.ci:18:[.051dea, .051df5) exec(1), time(0.015-0.015 ms): <.main+3587>
test/stdc/memory.ci:19:[.051df5, .051e00) exec(1), time(0.016-0.016 ms): <.main+3598>
test/stdc/memory.ci:20:[.051e00, .051e0b) exec(1), time(0.029-0.029 ms): <.main+3609>
test/stdc/memory.ci:23:[.051e0b, .051e14) exec(1), time(0.000 ms): <.main+3620>
test/stdc/memory.ci:24:[.051e14, .051e1d) exec(1), time(0.001-0.001 ms): <.main+3629>
test/stdc/memory.ci:26:[.051e1d, .051e3f) exec(1), time(0.032-0.032 ms): <.main+3638>
test/stdc/memory.ci:27:[.051e3f, .051e61) exec(1), time(0.030-0.030 ms): <.main+3672>
test/stdc/memory.ci:29:[.051e61, .051e75) exec(1), time(0.018-0.018 ms): <.main+3706>
test/stdc/memory.ci:30:[.051e75, .051e86) exec(1), time(0.016-0.016 ms): <.main+3726>
test/stdc/memory.ci:32:[.051e86, .051ea8) exec(1), time(0.033-0.033 ms): <.main+3743>
test/stdc/memory.ci:33:[.051ea8, .051eca) exec(1), time(0.044-0.044 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.051eca, .051ed8) exec(1), time(0.047-0.047 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.051ed8, .051ee6) exec(1), time(0.018-0.018 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.051ee6, .051ef4) exec(1), time(1.220-1.220 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.051ef4, .051f02) exec(1), time(0.031-0.031 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.051f02, .051f10) exec(1), time(0.030-0.030 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.051f10, .051f1e) exec(1), time(0.030-0.030 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.051f1e, .051f2c) exec(1), time(0.152-0.152 ms): <.main+3895>
test/lang/array.ci:49:[.051f2c, .051f30) exec(1), time(0.001-0.001 ms): <.main+3909>
test/lang/array.ci:50:[.051f30, .051f34) exec(1), time(0.000 ms): <.main+3913>
test/lang/array.ci:51:[.051f34, .051f38) exec(1), time(0.001-0.001 ms): <.main+3917>
test/lang/array.ci:55:[.051f3d, .051f51) exec(7), time(0.035-0.035 ms): <.main+3926>
test/lang/array.ci:54:[.051f51, .051f55) exec(7), time(0.003-0.003 ms): <.main+3946>
test/lang/array.ci:54:[.051f55, .051f61) exec(8), time(0.019-0.019 ms): <.main+3950>
test/lang/array.ci:54:[.051f38, .051f65) exec(1), time(0.003-0.003 ms): <.main+3921>
test/lang/array.ci:59:[.051f65, .051f6a) exec(1), time(0.001-0.001 ms): <.main+3966>
test/lang/array.ci:60:[.051f6a, .051f70) exec(1), time(0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.051f70, .051f74) exec(1), time(0.000 ms): <.main+3977>
test/lang/array.ci:64:[.051f74, .051f7d) exec(1), time(0.001-0.001 ms): <.main+3981>
test/lang/array.ci:67:[.051f7d, .051f7f) exec(1), time(0.000 ms): <.main+3990>
test/lang/array.ci:68:[.051f7f, .051f81) exec(1), time(0.001-0.001 ms): <.main+3992>
test/lang/array.ci:71:[.051f81, .051f83) exec(1), time(0.000 ms): <.main+3994>
test/lang/array.ci:81:[.051f83, .051f87) exec(1), time(0.000 ms): <.main+3996>
test/lang/array.ci:82:[.051f87, .051f9d) exec(1), time(0.019-0.019 ms): <.main+4000>
test/lang/array.ci:83:[.051f9d, .051fbf) exec(1), time(0.072-0.072 ms): <.main+4022>
test/lang/array.ci:84:[.051fbf, .051fe1) exec(1), time(0.072-0.072 ms): <.main+4056>
test/lang/array.ci:86:[.051fe1, .051fe6) exec(1), time(0.001-0.001 ms): <.main+4090>
test/lang/array.ci:87:[.051fe6, .052006) exec(1), time(0.048-0.048 ms): <.main+4095>
test/lang/array.ci:88:[.052006, .052026) exec(1), time(0.048-0.048 ms): <.main+4127>
test/lang/array.ci:90:[.052026, .052030) exec(1), time(0.001-0.001 ms): <.main+4159>
test/lang/array.ci:91:[.052030, .052050) exec(1), time(0.032-0.032 ms): <.main+4169>
test/lang/array.ci:92:[.052050, .052070) exec(1), time(0.032-0.032 ms): <.main+4201>
test/lang/array.ci:98:[.052070, .0520a3) exec(1), time(0.003-0.003 ms): <.main+4233>
test/lang/array.ci:99:[.0520a3, .0520d6) exec(1), time(0.003-0.003 ms): <.main+4284>
test/lang/array.ci:101:[.0520d6, .052111) exec(1), time(0.003-0.003 ms): <.main+4335>
test/lang/array.ci:108:[.052111, .05212a) exec(1), time(0.019-0.019 ms): <.main+4394>
test/lang/array.ci:109:[.05212a, .052140) exec(1), time(0.018-0.018 ms): <.main+4419>
test/lang/array.ci:110:[.052140, .052156) exec(1), time(0.017-0.017 ms): <.main+4441>
test/lang/array.ci:112:[.052156, .052176) exec(1), time(0.036-0.036 ms): <.main+4463>
test/lang/array.ci:113:[.052176, .052193) exec(1), time(0.055-0.055 ms): <.main+4495>
test/lang/array.ci:114:[.052193, .0521bb) exec(1), time(0.040-0.040 ms): <.main+4524>
test/lang/array.ci:115:[.0521bb, .0521dc) exec(1), time(0.050-0.050 ms): <.main+4564>
test/lang/array.ci:116:[.0521dc, .0521fd) exec(1), time(0.037-0.037 ms): <.main+4597>
test/lang/array.ci:119:[.052202, .05220b) exec(7), time(0.030-0.030 ms): <.main+4635>
test/lang/array.ci:120:[.05220b, .052248) exec(7), time(0.038-0.038 ms): <.main+4644>
test/lang/array.ci:121:[.052248, .052283) exec(7), time(0.037-0.037 ms): <.main+4705>
test/lang/array.ci:122:[.052283, .0522be) exec(7), time(0.035-0.035 ms): <.main+4764>
test/lang/array.ci:124:[.0522be, .052301) exec(7), time(0.169-0.169 ms): <.main+4823>
test/lang/array.ci:125:[.052301, .052342) exec(7), time(0.188-0.188 ms): <.main+4890>
test/lang/array.ci:126:[.052342, .052383) exec(7), time(0.191-0.191 ms): <.main+4955>
test/lang/array.ci:128:[.052383, .0523c6) exec(7), time(0.192-0.192 ms): <.main+5020>
test/lang/array.ci:129:[.0523c6, .052407) exec(7), time(0.164-0.164 ms): <.main+5087>
test/lang/array.ci:130:[.052407, .052448) exec(7), time(0.162-0.162 ms): <.main+5152>
test/lang/array.ci:132:[.052448, .052490) exec(7), time(0.213-0.213 ms): <.main+5217>
test/lang/array.ci:134:[.052490, .0524d1) exec(7), time(0.192-0.192 ms): <.main+5289>
test/lang/array.ci:136:[.0524d1, .05250c) exec(7), time(0.062-0.062 ms): <.main+5354>
test/lang/array.ci:118:[.052510, .052514) exec(7), time(0.001-0.001 ms): <.main+5417>
test/lang/array.ci:118:[.052514, .052520) exec(8), time(0.023-0.023 ms): <.main+5421>
test/lang/array.ci:118:[.0521fd, .052524) exec(1), time(0.003-0.003 ms): <.main+4630>
test/lang/member.ci:54:[.052528, .05252f) exec(1), time(0.002-0.002 ms): <.main+5441>
test/lang/member.ci:55:[.05252f, .052536) exec(1), time(0.001-0.001 ms): <.main+5448>
test/lang/member.ci:56:[.052536, .05253d) exec(1), time(0.001-0.001 ms): <.main+5455>
test/lang/member.ci:57:[.05253d, .052544) exec(1), time(0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.052544, .05254b) exec(1), time(0.001-0.001 ms): <.main+5469>
test/lang/member.ci:61:[.05254b, .052552) exec(1), time(0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.052552, .052559) exec(1), time(0.002-0.002 ms): <.main+5483>
test/lang/member.ci:66:[.052559, .052560) exec(1), time(0.001-0.001 ms): <.main+5490>
test/lang/member.ci:53:[.052524, .052560) exec(1-1), time(0.000 ms): <.main+5437>
test/lang/method.ci:46:[.052564, .05256b) exec(1), time(0.001-0.001 ms): <.main+5501>
::[.05256b, .052571) exec(1), time(0.001-0.001 ms): <.main+5508>
::[.052571, .052578) exec(1), time(0.001-0.001 ms): <.main+5514>
test/lang/method.ci:44:[.052560, .052578) exec(1-1), time(0.000 ms): <.main+5497>
test/lang/method.ci:58:[.052578, .05258b) exec(1), time(0.108-0.108 ms): <.main+5521>
test/lang/method.ci:59:[.05258b, .05259b) exec(1), time(0.098-0.098 ms): <.main+5540>
test/lang/method.ci:75:[.05259b, .0525ac) exec(1), time(0.212-0.212 ms): <.main+5556>
test/lang/method.ci:76:[.0525ac, .0525bd) exec(1), time(0.198-0.198 ms): <.main+5573>
test/lang/method.ci:79:[.0525bd, .0525d0) exec(1), time(0.116-0.116 ms): <.main+5590>
test/lang/method.ci:80:[.0525d0, .0525e3) exec(1), time(0.109-0.109 ms): <.main+5609>
test/lang/method.ci:81:[.0525e3, .0525f3) exec(1), time(0.126-0.126 ms): <.main+5628>
test/lang/recUnion.ci:26:[.0525f7, .0525fd) exec(1), time(0.001-0.001 ms): <.main+5648>
test/lang/recUnion.ci:26:[.0525fd, .052603) exec(1), time(0.001-0.001 ms): <.main+5654>
test/lang/recUnion.ci:26:[.052603, .052609) exec(1), time(0.002-0.002 ms): <.main+5660>
test/lang/recUnion.ci:26:[.0525f3, .052609) exec(1-1), time(0.000 ms): <.main+5644>
test/lang/recUnion.ci:27:[.05260d, .052613) exec(1), time(0.002-0.002 ms): <.main+5670>
test/lang/recUnion.ci:27:[.052613, .05261d) exec(1), time(0.002-0.002 ms): <.main+5676>
test/lang/recUnion.ci:27:[.05261d, .052623) exec(1), time(0.002-0.002 ms): <.main+5686>
test/lang/recUnion.ci:27:[.052609, .052623) exec(1-1), time(0.000 ms): <.main+5666>
test/lang/recUnion.ci:28:[.052627, .052631) exec(1), time(0.002-0.002 ms): <.main+5696>
test/lang/recUnion.ci:28:[.052631, .05263b) exec(1), time(0.002-0.002 ms): <.main+5706>
test/lang/recUnion.ci:28:[.05263b, .052645) exec(1), time(0.002-0.002 ms): <.main+5716>
test/lang/recUnion.ci:28:[.052623, .052645) exec(1-1), time(0.000 ms): <.main+5692>
test/lang/recUnion.ci:30:[.052649, .052650) exec(1), time(0.001-0.001 ms): <.main+5730>
test/lang/recUnion.ci:30:[.052645, .052650) exec(1-1), time(0.000 ms): <.main+5726>
test/lang/recUnion.ci:31:[.052654, .05265a) exec(1), time(0.003-0.003 ms): <.main+5741>
test/lang/recUnion.ci:31:[.05265a, .052660) exec(1), time(0.015-0.015 ms): <.main+5747>
test/lang/recUnion.ci:31:[.052660, .05266a) exec(1), time(0.002-0.002 ms): <.main+5753>
test/lang/recUnion.ci:31:[.052650, .05266a) exec(1-1), time(0.000 ms): <.main+5737>
test/lang/useOperator.ci:5:[.05266a, .05266f) exec(1), time(0.000 ms): <.main+5763>
test/lang/useOperator.ci:7:[.05266f, .052674) exec(1), time(0.001-0.001 ms): <.main+5768>
test/lang/useOperator.ci:8:[.052674, .052679) exec(1), time(0.000 ms): <.main+5773>
test/lang/useOperator.ci:17:[.052679, .052684) exec(1), time(0.004-0.004 ms): <.main+5778>
test/lang/useOperator.ci:18:[.052684, .05268f) exec(1), time(0.004-0.004 ms): <.main+5789>
test/lang/useOperator.ci:19:[.05268f, .05269a) exec(1), time(0.003-0.003 ms): <.main+5800>
test/lang/useOperator.ci:22:[.05269a, .0526a0) exec(1), time(0.002-0.002 ms): <.main+5811>
test/lang/useOperator.ci:23:[.0526a0, .0526ab) exec(1), time(0.003-0.003 ms): <.main+5817>
test/lang/useOperator.ci:24:[.0526ab, .0526b7) exec(1), time(0.004-0.004 ms): <.main+5828>
test/lang/useOperator.ci:25:[.0526b7, .0526c2) exec(1), time(0.004-0.004 ms): <.main+5840>
test/lang/useOperator.ci:26:[.0526c2, .0526ce) exec(1), time(0.004-0.004 ms): <.main+5851>
test/lang/useOperator.ci:27:[.0526ce, .0526d9) exec(1), time(0.004-0.004 ms): <.main+5863>
test/lang/useOperator.ci:28:[.0526d9, .0526e5) exec(1), time(0.005-0.005 ms): <.main+5874>
test/lang/useOperator.ci:30:[.0526e5, .0526ea) exec(1), time(0.000 ms): <.main+5886>
test/lang/useOperator.ci:31:[.0526ea, .0526ef) exec(1), time(0.001-0.001 ms): <.main+5891>
test/lang/useOperator.ci:32:[.0526ef, .0526f4) exec(1), time(0.001-0.001 ms): <.main+5896>
test/lang/useOperator.ci:33:[.0526f4, .0526fa) exec(1), time(0.002-0.002 ms): <.main+5901>
test/lang/useOperator.ci:34:[.0526fa, .052700) exec(1), time(0.002-0.002 ms): <.main+5907>
test/lang/useOperator.ci:35:[.052700, .05270b) exec(1), time(0.004-0.004 ms): <.main+5913>
test/lang/useOperator.ci:36:[.05270b, .052716) exec(1), time(0.003-0.003 ms): <.main+5924>
test/lang/useOperator.ci:37:[.052716, .052721) exec(1), time(0.003-0.003 ms): <.main+5935>
test/lang/useOperator.ci:38:[.052721, .05272c) exec(1), time(0.004-0.004 ms): <.main+5946>
test/lang/useOperator.ci:39:[.05272c, .052737) exec(1), time(0.004-0.004 ms): <.main+5957>
test/lang/useOperator.ci:40:[.052737, .052742) exec(1), time(0.003-0.003 ms): <.main+5968>
test/lang/useOperator.ci:41:[.052742, .05274d) exec(1), time(0.003-0.003 ms): <.main+5979>
test/lang/useOperator.ci:42:[.05274d, .052758) exec(1), time(0.004-0.004 ms): <.main+5990>
test/lang/useOperator.ci:43:[.052758, .052760) exec(1), time(0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:44:[.052760, .052768) exec(1), time(0.003-0.003 ms): <.main+6009>
test/lang/useOperator.ci:45:[.052768, .05276f) exec(1), time(0.003-0.003 ms): <.main+6017>
test/lang/useOperator.ci:46:[.05276f, .05277a) exec(1), time(0.003-0.003 ms): <.main+6024>
test/lang/useOperator.ci:47:[.05277a, .052786) exec(1), time(0.004-0.004 ms): <.main+6035>
test/lang/useOperator.ci:48:[.052786, .052791) exec(1), time(0.004-0.004 ms): <.main+6047>
test/lang/useOperator.ci:49:[.052791, .05279d) exec(1), time(0.004-0.004 ms): <.main+6058>
test/lang/useOperator.ci:50:[.05279d, .0527a8) exec(1), time(0.003-0.003 ms): <.main+6070>
test/lang/useOperator.ci:51:[.0527a8, .0527b4) exec(1), time(0.004-0.004 ms): <.main+6081>
test/lang/useOperator.ci:53:[.0527b4, .0527b9) exec(1), time(0.001-0.001 ms): <.main+6093>
test/lang/useOperator.ci:54:[.0527b9, .0527be) exec(1), time(0.000 ms): <.main+6098>
test/lang/useOperator.ci:55:[.0527be, .0527c3) exec(1), time(0.002-0.002 ms): <.main+6103>
test/lang/useOperator.ci:56:[.0527c3, .0527c9) exec(1), time(0.002-0.002 ms): <.main+6108>
test/lang/useOperator.ci:57:[.0527c9, .0527cf) exec(1), time(0.002-0.002 ms): <.main+6114>
test/lang/useOperator.ci:58:[.0527cf, .0527da) exec(1), time(0.004-0.004 ms): <.main+6120>
test/lang/useOperator.ci:59:[.0527da, .0527e5) exec(1), time(0.004-0.004 ms): <.main+6131>
test/lang/useOperator.ci:60:[.0527e5, .0527f0) exec(1), time(0.004-0.004 ms): <.main+6142>
test/lang/useOperator.ci:61:[.0527f0, .0527fb) exec(1), time(0.003-0.003 ms): <.main+6153>
test/lang/useOperator.ci:62:[.0527fb, .052806) exec(1), time(0.003-0.003 ms): <.main+6164>
test/lang/useOperator.ci:63:[.052806, .052811) exec(1), time(0.004-0.004 ms): <.main+6175>
test/lang/useOperator.ci:64:[.052811, .05281c) exec(1), time(0.018-0.018 ms): <.main+6186>
test/lang/useOperator.ci:65:[.05281c, .052827) exec(1), time(0.004-0.004 ms): <.main+6197>
test/lang/useOperator.ci:66:[.052827, .05282f) exec(1), time(0.003-0.003 ms): <.main+6208>
test/lang/useOperator.ci:67:[.05282f, .052837) exec(1), time(0.002-0.002 ms): <.main+6216>
test/lang/useOperator.ci:68:[.052837, .05283e) exec(1), time(0.003-0.003 ms): <.main+6224>
test/lang/useOperator.ci:69:[.05283e, .052849) exec(1), time(0.003-0.003 ms): <.main+6231>
test/lang/useOperator.ci:70:[.052849, .052855) exec(1), time(0.017-0.017 ms): <.main+6242>
test/lang/useOperator.ci:71:[.052855, .052860) exec(1), time(0.003-0.003 ms): <.main+6254>
test/lang/useOperator.ci:72:[.052860, .05286c) exec(1), time(0.004-0.004 ms): <.main+6265>
test/lang/useOperator.ci:73:[.05286c, .052877) exec(1), time(0.004-0.004 ms): <.main+6277>
test/lang/useOperator.ci:74:[.052877, .052883) exec(1), time(0.004-0.004 ms): <.main+6288>
test/lang/useOperator.ci:76:[.052883, .052888) exec(1), time(0.000 ms): <.main+6300>
test/lang/useOperator.ci:77:[.052888, .05288d) exec(1), time(0.001-0.001 ms): <.main+6305>
test/lang/useOperator.ci:78:[.05288d, .052892) exec(1), time(0.001-0.001 ms): <.main+6310>
test/lang/useOperator.ci:79:[.052892, .052898) exec(1), time(0.002-0.002 ms): <.main+6315>
test/lang/useOperator.ci:80:[.052898, .05289e) exec(1), time(0.002-0.002 ms): <.main+6321>
test/lang/useOperator.ci:81:[.05289e, .0528a9) exec(1), time(0.003-0.003 ms): <.main+6327>
test/lang/useOperator.ci:82:[.0528a9, .0528b4) exec(1), time(0.004-0.004 ms): <.main+6338>
test/lang/useOperator.ci:83:[.0528b4, .0528bf) exec(1), time(0.004-0.004 ms): <.main+6349>
test/lang/useOperator.ci:84:[.0528bf, .0528ca) exec(1), time(0.004-0.004 ms): <.main+6360>
test/lang/useOperator.ci:85:[.0528ca, .0528d5) exec(1), time(0.004-0.004 ms): <.main+6371>
test/lang/useOperator.ci:86:[.0528d5, .0528e0) exec(1), time(0.003-0.003 ms): <.main+6382>
test/lang/useOperator.ci:87:[.0528e0, .0528eb) exec(1), time(0.003-0.003 ms): <.main+6393>
test/lang/useOperator.ci:88:[.0528eb, .0528f6) exec(1), time(0.003-0.003 ms): <.main+6404>
test/lang/useOperator.ci:89:[.0528f6, .0528fe) exec(1), time(0.003-0.003 ms): <.main+6415>
test/lang/useOperator.ci:90:[.0528fe, .052906) exec(1), time(0.002-0.002 ms): <.main+6423>
test/lang/useOperator.ci:91:[.052906, .05290d) exec(1), time(0.002-0.002 ms): <.main+6431>
test/lang/useOperator.ci:92:[.05290d, .052918) exec(1), time(0.003-0.003 ms): <.main+6438>
test/lang/useOperator.ci:93:[.052918, .052924) exec(1), time(0.004-0.004 ms): <.main+6449>
test/lang/useOperator.ci:94:[.052924, .05292f) exec(1), time(0.004-0.004 ms): <.main+6461>
test/lang/useOperator.ci:95:[.05292f, .05293b) exec(1), time(0.005-0.005 ms): <.main+6472>
test/lang/useOperator.ci:96:[.05293b, .052946) exec(1), time(0.004-0.004 ms): <.main+6484>
test/lang/useOperator.ci:97:[.052946, .052952) exec(1), time(0.005-0.005 ms): <.main+6495>
test/lang/useOperator.ci:99:[.052952, .052957) exec(1), time(0.000 ms): <.main+6507>
test/lang/useOperator.ci:100:[.052957, .05295c) exec(1), time(0.001-0.001 ms): <.main+6512>
test/lang/useOperator.ci:101:[.05295c, .052961) exec(1), time(0.001-0.001 ms): <.main+6517>
test/lang/useOperator.ci:102:[.052961, .052967) exec(1), time(0.003-0.003 ms): <.main+6522>
test/lang/useOperator.ci:103:[.052967, .05296d) exec(1), time(0.002-0.002 ms): <.main+6528>
test/lang/useOperator.ci:104:[.05296d, .052978) exec(1), time(0.004-0.004 ms): <.main+6534>
test/lang/useOperator.ci:105:[.052978, .052983) exec(1), time(0.003-0.003 ms): <.main+6545>
test/lang/useOperator.ci:106:[.052983, .05298e) exec(1), time(0.003-0.003 ms): <.main+6556>
test/lang/useOperator.ci:107:[.05298e, .052999) exec(1), time(0.004-0.004 ms): <.main+6567>
test/lang/useOperator.ci:108:[.052999, .0529a4) exec(1), time(0.004-0.004 ms): <.main+6578>
test/lang/useOperator.ci:109:[.0529a4, .0529af) exec(1), time(0.004-0.004 ms): <.main+6589>
test/lang/useOperator.ci:110:[.0529af, .0529ba) exec(1), time(0.004-0.004 ms): <.main+6600>
test/lang/useOperator.ci:111:[.0529ba, .0529c5) exec(1), time(0.003-0.003 ms): <.main+6611>
test/lang/useOperator.ci:112:[.0529c5, .0529cd) exec(1), time(0.002-0.002 ms): <.main+6622>
test/lang/useOperator.ci:113:[.0529cd, .0529d5) exec(1), time(0.003-0.003 ms): <.main+6630>
test/lang/useOperator.ci:114:[.0529d5, .0529dc) exec(1), time(0.003-0.003 ms): <.main+6638>
test/lang/useOperator.ci:115:[.0529dc, .0529e7) exec(1), time(0.003-0.003 ms): <.main+6645>
test/lang/useOperator.ci:116:[.0529e7, .0529f3) exec(1), time(0.004-0.004 ms): <.main+6656>
test/lang/useOperator.ci:117:[.0529f3, .0529fe) exec(1), time(0.004-0.004 ms): <.main+6668>
test/lang/useOperator.ci:118:[.0529fe, .052a0a) exec(1), time(0.005-0.005 ms): <.main+6679>
test/lang/useOperator.ci:119:[.052a0a, .052a15) exec(1), time(0.003-0.003 ms): <.main+6691>
test/lang/useOperator.ci:120:[.052a15, .052a21) exec(1), time(0.004-0.004 ms): <.main+6702>
test/lang/useOperator.ci:122:[.052a21, .052a26) exec(1), time(0.001-0.001 ms): <.main+6714>
test/lang/useOperator.ci:123:[.052a26, .052a2b) exec(1), time(0.000 ms): <.main+6719>
test/lang/useOperator.ci:124:[.052a2b, .052a30) exec(1), time(0.002-0.002 ms): <.main+6724>
test/lang/useOperator.ci:125:[.052a30, .052a36) exec(1), time(0.002-0.002 ms): <.main+6729>
test/lang/useOperator.ci:126:[.052a36, .052a3c) exec(1), time(0.002-0.002 ms): <.main+6735>
test/lang/useOperator.ci:127:[.052a3c, .052a47) exec(1), time(0.004-0.004 ms): <.main+6741>
test/lang/useOperator.ci:128:[.052a47, .052a52) exec(1), time(0.004-0.004 ms): <.main+6752>
test/lang/useOperator.ci:129:[.052a52, .052a5d) exec(1), time(0.004-0.004 ms): <.main+6763>
test/lang/useOperator.ci:130:[.052a5d, .052a68) exec(1), time(0.004-0.004 ms): <.main+6774>
test/lang/useOperator.ci:131:[.052a68, .052a73) exec(1), time(0.003-0.003 ms): <.main+6785>
test/lang/useOperator.ci:132:[.052a73, .052a7e) exec(1), time(0.003-0.003 ms): <.main+6796>
test/lang/useOperator.ci:133:[.052a7e, .052a89) exec(1), time(0.004-0.004 ms): <.main+6807>
test/lang/useOperator.ci:134:[.052a89, .052a94) exec(1), time(0.004-0.004 ms): <.main+6818>
test/lang/useOperator.ci:135:[.052a94, .052a9c) exec(1), time(0.003-0.003 ms): <.main+6829>
test/lang/useOperator.ci:136:[.052a9c, .052aa4) exec(1), time(0.003-0.003 ms): <.main+6837>
test/lang/useOperator.ci:137:[.052aa4, .052aab) exec(1), time(0.003-0.003 ms): <.main+6845>
test/lang/useOperator.ci:138:[.052aab, .052ab6) exec(1), time(0.004-0.004 ms): <.main+6852>
test/lang/useOperator.ci:139:[.052ab6, .052ac2) exec(1), time(0.005-0.005 ms): <.main+6863>
test/lang/useOperator.ci:140:[.052ac2, .052acd) exec(1), time(0.003-0.003 ms): <.main+6875>
test/lang/useOperator.ci:141:[.052acd, .052ad9) exec(1), time(0.004-0.004 ms): <.main+6886>
test/lang/useOperator.ci:142:[.052ad9, .052ae4) exec(1), time(0.018-0.018 ms): <.main+6898>
test/lang/useOperator.ci:143:[.052ae4, .052af0) exec(1), time(0.005-0.005 ms): <.main+6909>
test/lang/useOperator.ci:145:[.052af0, .052af5) exec(1), time(0.000 ms): <.main+6921>
test/lang/useOperator.ci:146:[.052af5, .052afa) exec(1), time(0.000 ms): <.main+6926>
test/lang/useOperator.ci:147:[.052afa, .052afc) exec(1), time(0.000 ms): <.main+6931>
test/lang/useOperator.ci:148:[.052afc, .052aff) exec(1), time(0.002-0.002 ms): <.main+6933>
test/lang/useOperator.ci:149:[.052aff, .052b02) exec(1), time(0.001-0.001 ms): <.main+6936>
test/lang/useOperator.ci:150:[.052b02, .052b07) exec(1), time(0.003-0.003 ms): <.main+6939>
test/lang/useOperator.ci:151:[.052b07, .052b0c) exec(1), time(0.002-0.002 ms): <.main+6944>
test/lang/useOperator.ci:152:[.052b0c, .052b11) exec(1), time(0.002-0.002 ms): <.main+6949>
test/lang/useOperator.ci:153:[.052b11, .052b16) exec(1), time(0.002-0.002 ms): <.main+6954>
test/lang/useOperator.ci:154:[.052b16, .052b1b) exec(1), time(0.002-0.002 ms): <.main+6959>
test/lang/useOperator.ci:155:[.052b1b, .052b20) exec(1), time(0.003-0.003 ms): <.main+6964>
test/lang/useOperator.ci:156:[.052b20, .052b25) exec(1), time(0.002-0.002 ms): <.main+6969>
test/lang/useOperator.ci:157:[.052b25, .052b2a) exec(1), time(0.002-0.002 ms): <.main+6974>
test/lang/useOperator.ci:158:[.052b2a, .052b2f) exec(1), time(0.002-0.002 ms): <.main+6979>
test/lang/useOperator.ci:159:[.052b2f, .052b34) exec(1), time(0.002-0.002 ms): <.main+6984>
test/lang/useOperator.ci:160:[.052b34, .052b38) exec(1), time(0.002-0.002 ms): <.main+6989>
test/lang/useOperator.ci:161:[.052b38, .052b3d) exec(1), time(0.002-0.002 ms): <.main+6993>
test/lang/useOperator.ci:162:[.052b3d, .052b43) exec(1), time(0.003-0.003 ms): <.main+6998>
test/lang/useOperator.ci:163:[.052b43, .052b48) exec(1), time(0.002-0.002 ms): <.main+7004>
test/lang/useOperator.ci:164:[.052b48, .052b4e) exec(1), time(0.003-0.003 ms): <.main+7009>
test/lang/useOperator.ci:165:[.052b4e, .052b53) exec(1), time(0.002-0.002 ms): <.main+7015>
test/lang/useOperator.ci:166:[.052b53, .052b59) exec(1), time(0.003-0.003 ms): <.main+7020>
test/lang/useOperator.ci:168:[.052b59, .052b5e) exec(1), time(0.000 ms): <.main+7026>
test/lang/useOperator.ci:169:[.052b5e, .052b63) exec(1), time(0.000 ms): <.main+7031>
test/lang/useOperator.ci:170:[.052b63, .052b65) exec(1), time(0.001-0.001 ms): <.main+7036>
test/lang/useOperator.ci:171:[.052b65, .052b68) exec(1), time(0.014-0.014 ms): <.main+7038>
test/lang/useOperator.ci:172:[.052b68, .052b6b) exec(1), time(0.002-0.002 ms): <.main+7041>
test/lang/useOperator.ci:173:[.052b6b, .052b70) exec(1), time(0.002-0.002 ms): <.main+7044>
test/lang/useOperator.ci:174:[.052b70, .052b75) exec(1), time(0.002-0.002 ms): <.main+7049>
test/lang/useOperator.ci:175:[.052b75, .052b7a) exec(1), time(0.002-0.002 ms): <.main+7054>
test/lang/useOperator.ci:176:[.052b7a, .052b7f) exec(1), time(0.002-0.002 ms): <.main+7059>
test/lang/useOperator.ci:177:[.052b7f, .052b84) exec(1), time(0.002-0.002 ms): <.main+7064>
test/lang/useOperator.ci:178:[.052b84, .052b89) exec(1), time(0.002-0.002 ms): <.main+7069>
test/lang/useOperator.ci:179:[.052b89, .052b8e) exec(1), time(0.003-0.003 ms): <.main+7074>
test/lang/useOperator.ci:180:[.052b8e, .052b93) exec(1), time(0.002-0.002 ms): <.main+7079>
test/lang/useOperator.ci:181:[.052b93, .052b98) exec(1), time(0.002-0.002 ms): <.main+7084>
test/lang/useOperator.ci:182:[.052b98, .052b9d) exec(1), time(0.002-0.002 ms): <.main+7089>
test/lang/useOperator.ci:183:[.052b9d, .052ba1) exec(1), time(0.002-0.002 ms): <.main+7094>
test/lang/useOperator.ci:184:[.052ba1, .052ba6) exec(1), time(0.002-0.002 ms): <.main+7098>
test/lang/useOperator.ci:185:[.052ba6, .052bac) exec(1), time(0.003-0.003 ms): <.main+7103>
test/lang/useOperator.ci:186:[.052bac, .052bb1) exec(1), time(0.002-0.002 ms): <.main+7109>
test/lang/useOperator.ci:187:[.052bb1, .052bb7) exec(1), time(0.003-0.003 ms): <.main+7114>
test/lang/useOperator.ci:188:[.052bb7, .052bbc) exec(1), time(0.002-0.002 ms): <.main+7120>
test/lang/useOperator.ci:189:[.052bbc, .052bc2) exec(1), time(0.003-0.003 ms): <.main+7125>
test/lang/useOperator.ci:191:[.052bc2, .052bcb) exec(1), time(0.001-0.001 ms): <.main+7131>
test/lang/useOperator.ci:192:[.052bcb, .052bd4) exec(1), time(0.000 ms): <.main+7140>
test/lang/useOperator.ci:193:[.052bd4, .052bd6) exec(1), time(0.000 ms): <.main+7149>
test/lang/useOperator.ci:194:[.052bd6, .052bd9) exec(1), time(0.002-0.002 ms): <.main+7151>
test/lang/useOperator.ci:195:[.052bd9, .052bdc) exec(1), time(0.001-0.001 ms): <.main+7154>
test/lang/useOperator.ci:196:[.052bdc, .052be1) exec(1), time(0.002-0.002 ms): <.main+7157>
test/lang/useOperator.ci:197:[.052be1, .052be6) exec(1), time(0.002-0.002 ms): <.main+7162>
test/lang/useOperator.ci:198:[.052be6, .052beb) exec(1), time(0.003-0.003 ms): <.main+7167>
test/lang/useOperator.ci:199:[.052beb, .052bf0) exec(1), time(0.002-0.002 ms): <.main+7172>
test/lang/useOperator.ci:200:[.052bf0, .052bf5) exec(1), time(0.002-0.002 ms): <.main+7177>
test/lang/useOperator.ci:201:[.052bf5, .052bfa) exec(1), time(0.003-0.003 ms): <.main+7182>
test/lang/useOperator.ci:202:[.052bfa, .052bff) exec(1), time(0.002-0.002 ms): <.main+7187>
test/lang/useOperator.ci:203:[.052bff, .052c04) exec(1), time(0.002-0.002 ms): <.main+7192>
test/lang/useOperator.ci:204:[.052c04, .052c09) exec(1), time(0.002-0.002 ms): <.main+7197>
test/lang/useOperator.ci:205:[.052c09, .052c0e) exec(1), time(0.002-0.002 ms): <.main+7202>
test/lang/useOperator.ci:206:[.052c0e, .052c12) exec(1), time(0.002-0.002 ms): <.main+7207>
test/lang/useOperator.ci:207:[.052c12, .052c17) exec(1), time(0.002-0.002 ms): <.main+7211>
test/lang/useOperator.ci:208:[.052c17, .052c1d) exec(1), time(0.003-0.003 ms): <.main+7216>
test/lang/useOperator.ci:209:[.052c1d, .052c22) exec(1), time(0.002-0.002 ms): <.main+7222>
test/lang/useOperator.ci:210:[.052c22, .052c28) exec(1), time(0.003-0.003 ms): <.main+7227>
test/lang/useOperator.ci:211:[.052c28, .052c2d) exec(1), time(0.002-0.002 ms): <.main+7233>
test/lang/useOperator.ci:212:[.052c2d, .052c33) exec(1), time(0.003-0.003 ms): <.main+7238>
test/lang/useOperator.ci:214:[.052c33, .052c3c) exec(1), time(0.001-0.001 ms): <.main+7244>
test/lang/useOperator.ci:215:[.052c3c, .052c45) exec(1), time(0.001-0.001 ms): <.main+7253>
test/lang/useOperator.ci:216:[.052c45, .052c47) exec(1), time(0.000 ms): <.main+7262>
test/lang/useOperator.ci:217:[.052c47, .052c4a) exec(1), time(0.002-0.002 ms): <.main+7264>
test/lang/useOperator.ci:218:[.052c4a, .052c4d) exec(1), time(0.001-0.001 ms): <.main+7267>
test/lang/useOperator.ci:219:[.052c4d, .052c52) exec(1), time(0.002-0.002 ms): <.main+7270>
test/lang/useOperator.ci:220:[.052c52, .052c57) exec(1), time(0.002-0.002 ms): <.main+7275>
test/lang/useOperator.ci:221:[.052c57, .052c5c) exec(1), time(0.002-0.002 ms): <.main+7280>
test/lang/useOperator.ci:222:[.052c5c, .052c61) exec(1), time(0.002-0.002 ms): <.main+7285>
test/lang/useOperator.ci:223:[.052c61, .052c66) exec(1), time(0.002-0.002 ms): <.main+7290>
test/lang/useOperator.ci:224:[.052c66, .052c6b) exec(1), time(0.003-0.003 ms): <.main+7295>
test/lang/useOperator.ci:225:[.052c6b, .052c70) exec(1), time(0.002-0.002 ms): <.main+7300>
test/lang/useOperator.ci:226:[.052c70, .052c75) exec(1), time(0.003-0.003 ms): <.main+7305>
test/lang/useOperator.ci:227:[.052c75, .052c7a) exec(1), time(0.002-0.002 ms): <.main+7310>
test/lang/useOperator.ci:228:[.052c7a, .052c7f) exec(1), time(0.003-0.003 ms): <.main+7315>
test/lang/useOperator.ci:229:[.052c7f, .052c83) exec(1), time(0.002-0.002 ms): <.main+7320>
test/lang/useOperator.ci:230:[.052c83, .052c88) exec(1), time(0.002-0.002 ms): <.main+7324>
test/lang/useOperator.ci:231:[.052c88, .052c8e) exec(1), time(0.003-0.003 ms): <.main+7329>
test/lang/useOperator.ci:232:[.052c8e, .052c93) exec(1), time(0.003-0.003 ms): <.main+7335>
test/lang/useOperator.ci:233:[.052c93, .052c99) exec(1), time(0.016-0.016 ms): <.main+7340>
test/lang/useOperator.ci:234:[.052c99, .052c9e) exec(1), time(0.002-0.002 ms): <.main+7346>
test/lang/useOperator.ci:235:[.052c9e, .052ca4) exec(1), time(0.003-0.003 ms): <.main+7351>
test/lang/useOperator.ci:237:[.052ca4, .052ca9) exec(1), time(0.000 ms): <.main+7357>
test/lang/useOperator.ci:238:[.052ca9, .052cae) exec(1), time(0.001-0.001 ms): <.main+7362>
test/lang/useOperator.ci:239:[.052cae, .052cb0) exec(1), time(0.000 ms): <.main+7367>
test/lang/useOperator.ci:240:[.052cb0, .052cb3) exec(1), time(0.001-0.001 ms): <.main+7369>
test/lang/useOperator.ci:242:[.052cb3, .052cb8) exec(1), time(0.002-0.002 ms): <.main+7372>
test/lang/useOperator.ci:243:[.052cb8, .052cbd) exec(1), time(0.003-0.003 ms): <.main+7377>
test/lang/useOperator.ci:244:[.052cbd, .052cc2) exec(1), time(0.002-0.002 ms): <.main+7382>
test/lang/useOperator.ci:245:[.052cc2, .052cc7) exec(1), time(0.002-0.002 ms): <.main+7387>
test/lang/useOperator.ci:246:[.052cc7, .052ccc) exec(1), time(0.003-0.003 ms): <.main+7392>
test/lang/useOperator.ci:252:[.052ccc, .052cd0) exec(1), time(0.002-0.002 ms): <.main+7397>
test/lang/useOperator.ci:253:[.052cd0, .052cd5) exec(1), time(0.002-0.002 ms): <.main+7401>
test/lang/useOperator.ci:254:[.052cd5, .052cdb) exec(1), time(0.004-0.004 ms): <.main+7406>
test/lang/useOperator.ci:255:[.052cdb, .052ce0) exec(1), time(0.002-0.002 ms): <.main+7412>
test/lang/useOperator.ci:256:[.052ce0, .052ce6) exec(1), time(0.003-0.003 ms): <.main+7417>
test/lang/useOperator.ci:257:[.052ce6, .052ceb) exec(1), time(0.002-0.002 ms): <.main+7423>
test/lang/useOperator.ci:258:[.052ceb, .052cf1) exec(1), time(0.003-0.003 ms): <.main+7428>
test/lang/useOperator.ci:260:[.052cf1, .052cfa) exec(1), time(0.001-0.001 ms): <.main+7434>
test/lang/useOperator.ci:261:[.052cfa, .052d03) exec(1), time(0.001-0.001 ms): <.main+7443>
test/lang/useOperator.ci:262:[.052d03, .052d05) exec(1), time(0.000 ms): <.main+7452>
test/lang/useOperator.ci:263:[.052d05, .052d08) exec(1), time(0.001-0.001 ms): <.main+7454>
test/lang/useOperator.ci:265:[.052d08, .052d0d) exec(1), time(0.003-0.003 ms): <.main+7457>
test/lang/useOperator.ci:266:[.052d0d, .052d12) exec(1), time(0.003-0.003 ms): <.main+7462>
test/lang/useOperator.ci:267:[.052d12, .052d17) exec(1), time(0.002-0.002 ms): <.main+7467>
test/lang/useOperator.ci:268:[.052d17, .052d1c) exec(1), time(0.002-0.002 ms): <.main+7472>
test/lang/useOperator.ci:269:[.052d1c, .052d21) exec(1), time(0.003-0.003 ms): <.main+7477>
test/lang/useOperator.ci:275:[.052d21, .052d25) exec(1), time(0.003-0.003 ms): <.main+7482>
test/lang/useOperator.ci:276:[.052d25, .052d2a) exec(1), time(0.003-0.003 ms): <.main+7486>
test/lang/useOperator.ci:277:[.052d2a, .052d30) exec(1), time(0.003-0.003 ms): <.main+7491>
test/lang/useOperator.ci:278:[.052d30, .052d35) exec(1), time(0.002-0.002 ms): <.main+7497>
test/lang/useOperator.ci:279:[.052d35, .052d3b) exec(1), time(0.003-0.003 ms): <.main+7502>
test/lang/useOperator.ci:280:[.052d3b, .052d40) exec(1), time(0.002-0.002 ms): <.main+7508>
test/lang/useOperator.ci:281:[.052d40, .052d46) exec(1), time(0.003-0.003 ms): <.main+7513>
test/lang/useOperator.ci:283:[.052d46, .052d4b) exec(1), time(0.001-0.001 ms): <.main+7519>
test/lang/useOperator.ci:284:[.052d4b, .052d4f) exec(1), time(0.000 ms): <.main+7524>
test/lang/useOperator.ci:299:[.052d4f, .052d54) exec(1), time(0.002-0.002 ms): <.main+7528>
test/lang/useOperator.ci:300:[.052d54, .052d5a) exec(1), time(0.004-0.004 ms): <.main+7533>
test/lang/statementIf.ci:4:[.052d5a, .052d81) exec(1), time(0.046-0.046 ms): <.main+7539>
test/lang/statementIf.ci:12:[.052d81, .052da8) exec(1), time(0.032-0.032 ms): <.main+7578>
test/lang/statementIf.ci:22:[.052da8, .052dcf) exec(1), time(0.032-0.032 ms): <.main+7617>
test/lang/statementIf.ci:26:[.052dcf, .052dd0) exec(1), time(0.001-0.001 ms): <.main+7656>
test/lang/statementIf.ci:29:[.052dd8, .052dfe) exec(1), time(0.052-0.052 ms): <.main+7665>
test/lang/statementIf.ci:28:[.052dd0, .052dfe) exec(1-1), time(0.000 ms): <.main+7657>
test/lang/statementIf.ci:33:[.052e06, .052e2c) exec(0), time(0.000 ms): <.main+7711>
test/lang/statementIf.ci:32:[.052dfe, .052e2c) exec(1), time(0.004-0.004 ms): <.main+7703>
test/lang/statementIf.ci:37:[.052e34, .052e5a) exec(1), time(0.037-0.037 ms): <.main+7757>
test/lang/statementIf.ci:40:[.052e5e, .052e84) exec(0), time(0.000 ms): <.main+7799>
test/lang/statementIf.ci:36:[.052e2c, .052e84) exec(1), time(0.038-0.038 ms): <.main+7749>
test/lang/statementIf.ci:44:[.052e8c, .052eb2) exec(0), time(0.000 ms): <.main+7845>
test/lang/statementIf.ci:47:[.052eb6, .052edc) exec(1), time(0.037-0.037 ms): <.main+7887>
test/lang/statementIf.ci:43:[.052e84, .052edc) exec(1-1), time(0.000 ms): <.main+7837>
test/lang/statementIf.ci:51:[.052ee4, .052f0a) exec(1), time(0.036-0.036 ms): <.main+7933>
test/lang/statementIf.ci:54:[.052f1a, .052f40) exec(0), time(0.000 ms): <.main+7987>
test/lang/statementIf.ci:57:[.052f50, .052f76) exec(0), time(0.000 ms): <.main+8041>
test/lang/statementIf.ci:60:[.052f86, .052fac) exec(0), time(0.000 ms): <.main+8095>
test/lang/statementIf.ci:63:[.052fbc, .052fe2) exec(0), time(0.000 ms): <.main+8149>
test/lang/statementIf.ci:66:[.052ff2, .053018) exec(0), time(0.000 ms): <.main+8203>
test/lang/statementIf.ci:69:[.05301c, .053042) exec(0), time(0.000 ms): <.main+8245>
test/lang/statementIf.ci:65:[.052fe6, .053042) exec(0), time(0.000 ms): <.main+8191>
test/lang/statementIf.ci:62:[.052fb0, .053042) exec(0), time(0.000 ms): <.main+8137>
test/lang/statementIf.ci:59:[.052f7a, .053042) exec(0), time(0.000 ms): <.main+8083>
test/lang/statementIf.ci:56:[.052f44, .053042) exec(0), time(0.000 ms): <.main+8029>
test/lang/statementIf.ci:53:[.052f0e, .053042) exec(0), time(0.000 ms): <.main+7975>
test/lang/statementIf.ci:50:[.052edc, .053042) exec(1), time(0.038-0.038 ms): <.main+7925>
test/lang/statementFor.ci:4:[.053046, .053069) exec(1), time(0.028-0.028 ms): <.main+8287>
test/lang/statementFor.ci:5:[.053069, .05306d) exec(1), time(0.000 ms): <.main+8322>
::[.05306d, .053071) exec(1), time(0.000 ms): <.main+8326>
test/lang/statementFor.ci:3:[.053042, .053071) exec(1-1), time(0.000 ms): <.main+8283>
test/lang/statementFor.ci:9:[.053076, .053098) exec(2), time(0.078-0.078 ms): <.main+8335>
test/lang/statementFor.ci:8:[.053098, .05309c) exec(2), time(0.000 ms): <.main+8369>
test/lang/statementFor.ci:8:[.05309c, .0530a8) exec(3), time(0.009-0.009 ms): <.main+8373>
test/lang/statementFor.ci:8:[.053071, .0530ac) exec(1), time(0.005-0.005 ms): <.main+8330>
test/lang/statementFor.ci:12:[.0530ac, .0530ad) exec(1), time(0.000 ms): <.main+8389>
test/lang/statementFor.ci:14:[.0530b4, .0530d6) exec(2), time(0.078-0.078 ms): <.main+8397>
test/lang/statementFor.ci:13:[.0530d6, .0530da) exec(2), time(0.001-0.001 ms): <.main+8431>
test/lang/statementFor.ci:13:[.0530da, .0530e6) exec(3), time(0.010-0.010 ms): <.main+8435>
test/lang/statementFor.ci:13:[.0530ad, .0530e6) exec(1-1), time(0.000 ms): <.main+8390>
test/lang/statementFor.ci:19:[.0530f7, .0530fb) exec(2), time(0.001-0.001 ms): <.main+8464>
test/lang/statementFor.ci:18:[.0530eb, .0530fb) exec(7-2), time(0.031-0.031 ms): <.main+8452>
test/lang/statementFor.ci:21:[.0530fb, .05311d) exec(5), time(0.179-0.179 ms): <.main+8468>
test/lang/statementFor.ci:17:[.05311d, .053121) exec(7), time(0.002-0.002 ms): <.main+8502>
test/lang/statementFor.ci:17:[.053121, .05312d) exec(8), time(0.028-0.028 ms): <.main+8506>
test/lang/statementFor.ci:17:[.0530e6, .053131) exec(1), time(0.005-0.005 ms): <.main+8447>
test/lang/statementFor.ci:26:[.053142, .053146) exec(1), time(0.000 ms): <.main+8539>
test/lang/statementFor.ci:25:[.053136, .053146) exec(4-1), time(0.009-0.009 ms): <.main+8527>
test/lang/statementFor.ci:28:[.053146, .053168) exec(3), time(0.096-0.096 ms): <.main+8543>
test/lang/statementFor.ci:24:[.053168, .05316c) exec(3), time(0.002-0.002 ms): <.main+8577>
test/lang/statementFor.ci:24:[.05316c, .053178) exec(4), time(0.014-0.014 ms): <.main+8581>
test/lang/statementFor.ci:24:[.053131, .05317c) exec(1), time(0.002-0.002 ms): <.main+8522>
test/stdc/test.math.ci:3:[.05317c, .053190) exec(1), time(0.046-0.046 ms): <.main+8597>
test/stdc/test.math.ci:4:[.053190, .0531a4) exec(1), time(0.033-0.033 ms): <.main+8617>
test/stdc/test.math.ci:5:[.0531a4, .0531b8) exec(1), time(0.046-0.046 ms): <.main+8637>
test/stdc/test.math.ci:6:[.0531b8, .0531cc) exec(1), time(0.047-0.047 ms): <.main+8657>
test/stdc/test.math.ci:7:[.0531cc, .0531e0) exec(1), time(0.046-0.046 ms): <.main+8677>
test/stdc/test.math.ci:8:[.0531e0, .0531f4) exec(1), time(0.058-0.058 ms): <.main+8697>
test/stdc/test.math.ci:10:[.0531f4, .05320d) exec(1), time(0.010-0.010 ms): <.main+8717>
test/stdc/test.math.ci:11:[.05320d, .05321e) exec(1), time(0.010-0.010 ms): <.main+8742>
test/stdc/test.math.ci:12:[.05321e, .053237) exec(1), time(0.010-0.010 ms): <.main+8759>
test/stdc/test.math.ci:13:[.053237, .053248) exec(1), time(0.009-0.009 ms): <.main+8784>
test/stdc/test.math.ci:14:[.053248, .053255) exec(1), time(0.009-0.009 ms): <.main+8801>
test/stdc/test.math.ci:15:[.053255, .053266) exec(1), time(0.009-0.009 ms): <.main+8814>
test/stdc/test.math.ci:17:[.053266, .05327a) exec(1), time(0.019-0.019 ms): <.main+8831>
test/stdc/test.math.ci:18:[.05327a, .053285) exec(1), time(0.031-0.031 ms): <.main+8851>
test/stdc/test.math.ci:19:[.053285, .053299) exec(1), time(0.018-0.018 ms): <.main+8862>
test/stdc/test.math.ci:20:[.053299, .0532aa) exec(1), time(0.032-0.032 ms): <.main+8882>
test/stdc/test.math.ci:21:[.0532aa, .0532b7) exec(1), time(0.019-0.019 ms): <.main+8899>
test/stdc/test.math.ci:22:[.0532b7, .0532c8) exec(1), time(0.019-0.019 ms): <.main+8912>
test/stdc/test.math.ci:24:[.0532c8, .0532de) exec(1), time(0.020-0.020 ms): <.main+8929>
test/stdc/test.math.ci:25:[.0532de, .0532f4) exec(1), time(0.020-0.020 ms): <.main+8951>
test/stdc/test.math.ci:26:[.0532f4, .053311) exec(1), time(0.019-0.019 ms): <.main+8973>
test/stdc/test.math.ci:27:[.053311, .05332e) exec(1), time(0.019-0.019 ms): <.main+9002>
test/stdc/test.math.ci:29:[.05332e, .053345) exec(1), time(0.021-0.021 ms): <.main+9031>
test/stdc/test.math.ci:30:[.053345, .053363) exec(1), time(0.020-0.020 ms): <.main+9054>
test/stdc/test.math.ci:32:[.053363, .053378) exec(1), time(0.009-0.009 ms): <.main+9084>
test/stdc/test.math.ci:33:[.053378, .053394) exec(1), time(0.008-0.008 ms): <.main+9105>
test/stdc/test.math.ci:35:[.053394, .0533d0) exec(1), time(0.068-0.068 ms): <.main+9133>
test/stdc/test.math.ci:36:[.0533d0, .05341e) exec(1), time(0.039-0.039 ms): <.main+9193>
test/stdc/test.math.ci:38:[.05341e, .053433) exec(1), time(0.024-0.024 ms): <.main+9271>
test/stdc/test.math.ci:39:[.053433, .05349d) exec(1), time(0.074-0.074 ms): <.main+9292>
test/stdc/test.math.ci:40:[.05349d, .0534b2) exec(1), time(0.023-0.023 ms): <.main+9398>
test/stdc/test.math.ci:41:[.0534b2, .05351c) exec(1), time(0.062-0.062 ms): <.main+9419>
test/stdc/test.math.ci:43:[.05351c, .053531) exec(1), time(0.025-0.025 ms): <.main+9525>
test/stdc/test.math.ci:44:[.053531, .053553) exec(1), time(0.029-0.029 ms): <.main+9546>
test/stdc/test.math.ci:45:[.053553, .05357e) exec(1), time(0.033-0.033 ms): <.main+9580>
test/stdc/test.math.ci:46:[.05357e, .0535f1) exec(1), time(0.095-0.095 ms): <.main+9623>
test/stdc/test.math.ci:48:[.0535f1, .0535fa) exec(1), time(0.001-0.001 ms): <.main+9738>
test/stdc/test.math.ci:49:[.0535fa, .053611) exec(1), time(0.040-0.040 ms): <.main+9747>
test/stdc/test.math.ci:50:[.053611, .05361a) exec(1), time(0.000 ms): <.main+9770>
test/stdc/test.math.ci:51:[.05361a, .053630) exec(1), time(0.005-0.005 ms): <.main+9779>
test/stdc/test.math.ci:52:[.053630, .053657) exec(1), time(0.010-0.010 ms): <.main+9801>
test/stdc/test.math.ci:53:[.053657, .05368f) exec(1), time(0.015-0.015 ms): <.main+9840>
test/stdc/test.math.ci:54:[.05368f, .0536d7) exec(1), time(0.050-0.050 ms): <.main+9896>
test/stdc/test.math.ci:55:[.0536d7, .053728) exec(1), time(0.052-0.052 ms): <.main+9968>
test/stdc/test.math.ci:57:[.053728, .053747) exec(1), time(0.056-0.056 ms): <.main+10049>
test/stdc/test.math.ci:58:[.053747, .053774) exec(1), time(0.058-0.058 ms): <.main+10080>
test/stdc/test.math.ci:59:[.053774, .053792) exec(1), time(0.084-0.084 ms): <.main+10125>
test/stdc/test.math.ci:60:[.053792, .0537b0) exec(1), time(0.055-0.055 ms): <.main+10155>
test/stdc/test.math.ci:61:[.0537b0, .0537ce) exec(1), time(0.046-0.046 ms): <.main+10185>
test/stdc/test.math.ci:63:[.0537ce, .0537e2) exec(1), time(0.067-0.067 ms): <.main+10215>
test/stdc/test.math.ci:64:[.0537e2, .05380a) exec(1), time(0.058-0.058 ms): <.main+10235>
test/stdc/test.math.ci:67:[.05380a, .053826) exec(1), time(0.027-0.027 ms): <.main+10275>
test/stdc/test.math.ci:68:[.053826, .05384e) exec(1), time(0.038-0.038 ms): <.main+10303>
test/stdc/test.math.ci:70:[.05384e, .05386b) exec(1), time(0.019-0.019 ms): <.main+10343>
test/stdc/test.math.ci:71:[.05386b, .05387f) exec(1), time(0.018-0.018 ms): <.main+10372>
test/stdc/test.math.ci:72:[.05387f, .05389c) exec(1), time(0.019-0.019 ms): <.main+10392>
test/stdc/test.math.ci:74:[.05389c, .0538b9) exec(1), time(0.046-0.046 ms): <.main+10421>
test/stdc/test.math.ci:75:[.0538b9, .0538d6) exec(1), time(0.033-0.033 ms): <.main+10450>
test/stdc/test.math.ci:76:[.0538d6, .0538f3) exec(1), time(0.019-0.019 ms): <.main+10479>
test/stdc/test.math.ci:77:[.0538f3, .053910) exec(1), time(0.019-0.019 ms): <.main+10508>
test/stdc/test.math.ci:79:[.053910, .05392d) exec(1), time(0.047-0.047 ms): <.main+10537>
test/stdc/test.math.ci:80:[.05392d, .05394a) exec(1), time(0.047-0.047 ms): <.main+10566>
test/stdc/test.math.ci:81:[.05394a, .053967) exec(1), time(0.019-0.019 ms): <.main+10595>
test/stdc/test.math.ci:82:[.053967, .053984) exec(1), time(0.019-0.019 ms): <.main+10624>
test/stdc/test.math.ci:84:[.053984, .053999) exec(1), time(0.019-0.019 ms): <.main+10653>
test/stdc/test.math.ci:85:[.053999, .0539aa) exec(1), time(0.018-0.018 ms): <.main+10674>
test/stdc/test.math.ci:86:[.0539aa, .0539bf) exec(1), time(0.021-0.021 ms): <.main+10691>
test/stdc/test.math.ci:88:[.0539bf, .0539d4) exec(1), time(0.020-0.020 ms): <.main+10712>
test/stdc/test.math.ci:89:[.0539d4, .0539e9) exec(1), time(0.019-0.019 ms): <.main+10733>
test/stdc/test.math.ci:90:[.0539e9, .0539fe) exec(1), time(0.018-0.018 ms): <.main+10754>
test/stdc/test.math.ci:91:[.0539fe, .053a13) exec(1), time(0.019-0.019 ms): <.main+10775>
test/stdc/test.math.ci:93:[.053a13, .053a28) exec(1), time(0.019-0.019 ms): <.main+10796>
test/stdc/test.math.ci:94:[.053a28, .053a3d) exec(1), time(0.019-0.019 ms): <.main+10817>
test/stdc/test.math.ci:95:[.053a3d, .053a52) exec(1), time(0.019-0.019 ms): <.main+10838>
test/stdc/test.math.ci:96:[.053a52, .053a67) exec(1), time(0.019-0.019 ms): <.main+10859>

---------- Exitcode: 0, time: 27.101 ms
