
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:50: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:71: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:72: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:73: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:70: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:58: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:80: warn: empty statement `;`
lib/stdlib.ci:85: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:86: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:88: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:89: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:90: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:41: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:3: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:44: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:64: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:70: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:43: warn: no code will be generated for statement: 0
lib/stdlib.ci:43: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
lib/stdlib.ci:47: warn: no code will be generated for statement: 0
test/lang/method.ci:58: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@005f68>, cast: static const inline)
.field file: function (size: 0, offs: <@006168>, cast: static const inline)
.field line: function (size: 0, offs: <@006368>, cast: static const inline)
.field name: function (size: 0, offs: <@006568>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:83: referenced as `typename`
	lib/stdlib.ci:3: referenced as `typename`
	internal usages: 7
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:83: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005f68>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(1)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006168>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006368>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006568>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:68: referenced as `void`
	test/lang/method.ci:62: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:30: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:19: referenced as `void`
	test/lang/method.ci:15: referenced as `void`
	test/lang/method.ci:11: referenced as `void`
	test/lang/method.ci:6: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:3: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:66: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:47: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:45: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	lib/stdlib.ci:43: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:47: referenced as `bool`
	lib/stdlib.ci:45: referenced as `bool`
	lib/stdlib.ci:43: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:66: referenced as `char`
	lib/stdlib.ci:61: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:43: referenced as `char`
	lib/stdlib.ci:38: referenced as `char`
	lib/stdlib.ci:36: referenced as `char`
	lib/stdlib.ci:33: referenced as `char`
	lib/stdlib.ci:31: referenced as `char`
	lib/stdlib.ci:28: referenced as `char`
	lib/stdlib.ci:26: referenced as `char`
	lib/stdlib.ci:23: referenced as `char`
	lib/stdlib.ci:21: referenced as `char`
	lib/stdlib.ci:18: referenced as `char`
	lib/stdlib.ci:16: referenced as `char`
	lib/stdlib.ci:13: referenced as `char`
	lib/stdlib.ci:11: referenced as `char`
	lib/stdlib.ci:8: referenced as `char`
	lib/stdlib.ci:6: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:68: referenced as `int32`
	test/lang/method.ci:62: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:30: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:19: referenced as `int32`
	test/lang/method.ci:15: referenced as `int32`
	test/lang/method.ci:11: referenced as `int32`
	test/lang/method.ci:6: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:32: referenced as `int32`
	test/lang/function.ci:29: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:26: referenced as `int32`
	test/lang/function.ci:23: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:20: referenced as `int32`
	test/lang/function.ci:17: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:14: referenced as `int32`
	test/lang/function.ci:11: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/function.ci:6: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:83: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:78: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	lib/stdlib.ci:66: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0091a8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0094d8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0096d8>, cast: static const inline)
.field swap: function (size: 0, offs: <@0098d8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ad8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009cd8>, cast: static const inline)
.field hib: function (size: 0, offs: <@009ed8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a0d8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:45: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/function.ci:37: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091a8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(18)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0094d8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(19)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096d8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098d8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ad8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009cd8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ed8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0d8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a400>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a728>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a400>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a728>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00a928>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ab28>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ad28>, cast: static const inline)
.field log: function (size: 0, offs: <@00af28>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b128>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b3c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b5c0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00b858>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a928>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab28>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad28>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af28>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b128>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b3c0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5c0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b858>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00ba50>, cast: static const inline)
.field cos: function (size: 0, offs: <@00bc48>, cast: static const inline)
.field tan: function (size: 0, offs: <@00be40>, cast: static const inline)
.field log: function (size: 0, offs: <@00c038>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c230>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c4c0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c6b8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c948>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba50>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(36)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc48>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(37)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be40>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c038>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c230>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c4c0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6b8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c948>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007880>, cast: static const inline)
.field fill: function (size: 0, offs: <@007bb8>, cast: static const inline)
.field copy: function (size: 0, offs: <@007ef0>, cast: static const inline)
.field move: function (size: 0, offs: <@008220>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 12
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007880>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(7)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007bb8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(8)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007ef0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008220>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:58: referenced as `variant`
	lib/stdlib.ci:55: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:43: referenced as `variant`
	lib/stdlib.ci:36: referenced as `variant`
	lib/stdlib.ci:31: referenced as `variant`
	lib/stdlib.ci:26: referenced as `variant`
	lib/stdlib.ci:21: referenced as `variant`
	lib/stdlib.ci:16: referenced as `variant`
	lib/stdlib.ci:11: referenced as `variant`
	lib/stdlib.ci:6: referenced as `variant`
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:3: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:70: referenced as `null`
	test/lang/method.ci:64: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:78: referenced as `null`
	lib/stdlib.ci:61: referenced as `null`
	lib/stdlib.ci:58: referenced as `null`
	lib/stdlib.ci:40: referenced as `null`
	lib/stdlib.ci:38: referenced as `null`
	lib/stdlib.ci:33: referenced as `null`
	lib/stdlib.ci:28: referenced as `null`
	lib/stdlib.ci:23: referenced as `null`
	lib/stdlib.ci:18: referenced as `null`
	lib/stdlib.ci:13: referenced as `null`
	lib/stdlib.ci:8: referenced as `null`
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.value: uint8
.usages:
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.value: float32
.usages:
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.value: float64
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@001058>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@0010f8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@0014b8>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001558>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0017d8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001d78>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@002110>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@0022f0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0024c0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002690>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002860>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002a30>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002d30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@003180>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@0035b0>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0039e0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f40>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044a0>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0048d0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004d00>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005130>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005560>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005730>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0014b8>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001558>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0017d8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001d78>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002110>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0022f0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0024c0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002690>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002860>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a30>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002d30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003180>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0035b0>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0039e0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f40>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044a0>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0048d0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004d00>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005130>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005560>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005730>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005c20>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006d00>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(5)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:75: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:38: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:36: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:33: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:31: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:28: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:26: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:23: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:21: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:18: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:16: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:13: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:11: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:8: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:6: referenced as `raise`
	lib/stdlib.ci:3: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:75: referenced as `abort`
	lib/stdlib.ci:40: referenced as `abort`
	lib/stdlib.ci:38: referenced as `abort`
	lib/stdlib.ci:36: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:33: referenced as `error`
	lib/stdlib.ci:31: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:28: referenced as `warn`
	lib/stdlib.ci:26: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:23: referenced as `info`
	lib/stdlib.ci:21: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:18: referenced as `debug`
	lib/stdlib.ci:16: referenced as `debug`
	lib/stdlib.ci:13: referenced as `debug`
	lib/stdlib.ci:11: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:8: referenced as `verbose`
	lib/stdlib.ci:6: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:28: referenced as `noTrace`
	lib/stdlib.ci:26: referenced as `noTrace`
	lib/stdlib.ci:23: referenced as `noTrace`
	lib/stdlib.ci:21: referenced as `noTrace`
	lib/stdlib.ci:13: referenced as `noTrace`
	lib/stdlib.ci:11: referenced as `noTrace`
	lib/stdlib.ci:8: referenced as `noTrace`
	lib/stdlib.ci:6: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:75: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:38: referenced as `defTrace`
	lib/stdlib.ci:36: referenced as `defTrace`
	lib/stdlib.ci:33: referenced as `defTrace`
	lib/stdlib.ci:31: referenced as `defTrace`
	lib/stdlib.ci:18: referenced as `defTrace`
	lib/stdlib.ci:16: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0075e0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008250>
.name: 'System'
.field exit: function (size: 0, offs: <@0084c8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0086d0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008838>, cast: static const inline)
.field time: function (size: 0, offs: <@0089a0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008b08>, cast: static const inline)
.field millis: function (size: 0, offs: <@008c70>, cast: static const inline)
.field sleep: function (size: 0, offs: <@008e70>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084c8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(11)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(12)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008838>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(13)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0089a0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(14)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008b08>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008c70>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e70>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(17)
.usages:
	internal usages: 1
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:6: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'verbose'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:8: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:11: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'debug'
.file: 'lib/stdlib.ci:13'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:69: referenced as `debug`
	test/lang/method.ci:63: referenced as `debug`
	lib/stdlib.ci:13: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:31: referenced as `trace`
	test/lang/method.ci:26: referenced as `trace`
	test/lang/method.ci:7: referenced as `trace`
	lib/stdlib.ci:16: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'trace'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:18: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:21: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'info'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:23: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:26: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'warn'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:28: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:31: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'error'
.file: 'lib/stdlib.ci:33'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:33: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: ' report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:43: referenced as `abort`
	lib/stdlib.ci:36: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: ' report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
	lib/stdlib.ci:38: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abort'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: ' report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:40: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: ' report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:43: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: ' report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:45: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assert'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: ' report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:47: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@00fbf0>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:50'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:70: referenced as `NotEquals`
	lib/stdlib.ci:50: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:52'
.owner: NotEquals
.doc: ' Value of the expected result'
.usages:
	lib/stdlib.ci:71: referenced as `expected`
	lib/stdlib.ci:52: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:55'
.owner: NotEquals
.doc: ' Value of the actual result'
.usages:
	lib/stdlib.ci:72: referenced as `returned`
	lib/stdlib.ci:55: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:58'
.owner: NotEquals
.doc: ' Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:58: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: ' Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:73: referenced as `message`
	lib/stdlib.ci:61: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@04fd10>
.name: 'assertEq'
.file: 'lib/stdlib.ci:66'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: ' abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@04fd10> - <@04fd6e>)
	lib/stdlib.ci:67: (10 bytes: <@04fd10> - <@04fd1a>): if (bool(returned == expected))
	<assertEq @04fd10>      : 10 02                      dup.x1 sp(2)
	<assertEq+2 @04fd12>    : 10 04                      dup.x1 sp(4)
	<assertEq+4 @04fd14>    : 57                         ceq.i32
	<assertEq+5 @04fd15>    : 06 05 00 00                jz <assertEq+10 @04fd1a>
	lib/stdlib.ci:68: (1 byte: <@04fd19> - <@04fd1a>): return;
	<assertEq+9 @04fd19>    : 03                         ret
	lib/stdlib.ci:70: (41 bytes: <@04fd1a> - <@04fd43>): details: NotEquals := {...}
	<assertEq+10 @04fd1a>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:71: (11 bytes: <@04fd1e> - <@04fd29>): void(details.expected := (expected));
	<assertEq+14 @04fd1e>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @04fd23>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @04fd27>   : 14 02                      set.x2 sp(2)
	lib/stdlib.ci:72: (11 bytes: <@04fd29> - <@04fd34>): void(details.returned := (returned));
	<assertEq+25 @04fd29>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @04fd2e>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @04fd32>   : 14 04                      set.x2 sp(4)
	lib/stdlib.ci:73: (3 bytes: <@04fd34> - <@04fd37>): void(details.message := (message));
	<assertEq+36 @04fd34>   : 16 06 09                   mov.x1 sp(6, 9)
	:: (12 bytes: <@04fd37> - <@04fd43>): void(details.argument := (null))
	<assertEq+39 @04fd37>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @04fd3c>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @04fd41>   : 14 06                      set.x2 sp(6)
	lib/stdlib.ci:75: (38 bytes: <@04fd43> - <@04fd69>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @04fd43>   : 1f 78 c9 00 00             load.ref <@00c978> ;"lib/stdlib.ci"
	<assertEq+56 @04fd48>   : 1c 4b 00 00 00             load.c32 75
	<assertEq+61 @04fd4d>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @04fd52>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @04fd57>   : 1f 88 cc 00 00             load.ref <@00cc88> ;"assertion failed"
	<assertEq+76 @04fd5c>   : 1f f0 fb 00 00             load.ref <@00fbf0> ;NotEquals
	<assertEq+81 @04fd61>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @04fd65>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @04fd69>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @04fd6d>   : 03                         ret
.usages:
	lib/stdlib.ci:78: referenced as `assertEq`
	lib/stdlib.ci:66: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'assertEq'
.file: 'lib/stdlib.ci:78'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: ' abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:78: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sizeof'
.file: 'lib/stdlib.ci:83'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: ' Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:83: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@010e98>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@04fd70>, cast: static const function)
.field floor: function (size: 24, offs: <@04fdc8>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@04fde0>, cast: static const function)
.field abs: function (size: 18, offs: <@04fdf8>, cast: static const function)
.field absMod: function (size: 27, offs: <@04fe10>, cast: static const function)
.field absMod: function (size: 27, offs: <@04fe30>, cast: static const function)
.field min: function (size: 17, offs: <@04fe50>, cast: static const function)
.field min: function (size: 17, offs: <@04fe68>, cast: static const function)
.field max: function (size: 17, offs: <@04fe80>, cast: static const function)
.field max: function (size: 17, offs: <@04fe98>, cast: static const function)
.field clamp: function (size: 30, offs: <@04feb0>, cast: static const function)
.field clamp: function (size: 30, offs: <@04fed0>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 72, offs: <@04fef0>, cast: static const function)
.field max: function (size: 72, offs: <@04ff38>, cast: static const function)
.field sum: function (size: 40, offs: <@04ff80>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@04ffa8>, cast: static const function)
.field cmp: function (size: 57, offs: <@04ffd8>, cast: static const function)
.field cmp: function (size: 57, offs: <@050018>, cast: static const function)
.field sinCos: function (size: 335, offs: <@050058>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 371, offs: <@0501a8>, cast: static const function)
.field sinh: function (size: 241, offs: <@050320>, cast: static const function)
.field cosh: function (size: 75, offs: <@050418>, cast: static const function)
.field asin: function (size: 166, offs: <@050468>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: ' Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: float64(1.000000 / ln2)
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: float64(1.000000 / ln10)
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: float64((0) / 0.000000)
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: float64((1) / 0.000000)
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@04fd70>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: ' Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@04fd70> - <@04fdc6>)
	lib/std/math.ci:23: (63 bytes: <@04fd70> - <@04fdaf>): if (bool(x < (1)))
	<modf @04fd70>      : 11 02                      dup.x2 sp(2)
	<modf+2 @04fd72>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @04fd7b>   : 88                         clt.f64
	<modf+12 @04fd7c>   : 06 33 00 00                jz <modf+63 @04fdaf>
	lib/std/math.ci:24: (39 bytes: <@04fd80> - <@04fda7>): if (bool(x < (0)))
	<modf+16 @04fd80>   : 11 02                      dup.x2 sp(2)
	<modf+18 @04fd82>   : 1a                         load.z64
	<modf+19 @04fd83>   : 88                         clt.f64
	<modf+20 @04fd84>   : 06 23 00 00                jz <modf+55 @04fda7>
	lib/std/math.ci:25: (17 bytes: <@04fd88> - <@04fd99>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @04fd88>   : 1a                         load.z64
	<modf+25 @04fd89>   : 11 04                      dup.x2 sp(4)
	<modf+27 @04fd8b>   : 80                         neg.f64
	<modf+28 @04fd8c>   : 10 05                      dup.x1 sp(5)
	<modf+30 @04fd8e>   : 1f 70 fd 04 00             load.ref <@04fd70> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @04fd93>   : 02                         call
	<modf+36 @04fd94>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @04fd98>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@04fd99> - <@04fda0>): float64(intPart := float64(-intPart));
	<modf+41 @04fd99>   : 10 03                      dup.x1 sp(3)
	<modf+43 @04fd9b>   : 23                         load.i64
	<modf+44 @04fd9c>   : 80                         neg.f64
	<modf+45 @04fd9d>   : 10 05                      dup.x1 sp(5)
	<modf+47 @04fd9f>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@04fda0> - <@04fda3>): return float64(.result := result);
	<modf+48 @04fda0>   : 14 06                      set.x2 sp(6)
	<modf+50 @04fda2>   : 03                         ret
	<modf+51 @04fda3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@04fda7> - <@04fdab>): float64(intPart := (0));
	<modf+55 @04fda7>   : 1a                         load.z64
	<modf+56 @04fda8>   : 10 03                      dup.x1 sp(3)
	<modf+58 @04fdaa>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@04fdab> - <@04fdaf>): return float64(.result := x);
	<modf+59 @04fdab>   : 17 04 02                   mov.x2 sp(4, 2)
	<modf+62 @04fdae>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@04fdaf> - <@04fdbb>): result: float64 := float64(x % (1))
	<modf+63 @04fdaf>   : 11 02                      dup.x2 sp(2)
	<modf+65 @04fdb1>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @04fdba>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@04fdbb> - <@04fdc3>): float64(intPart := float64(x - result));
	<modf+75 @04fdbb>   : 11 04                      dup.x2 sp(4)
	<modf+77 @04fdbd>   : 11 02                      dup.x2 sp(2)
	<modf+79 @04fdbf>   : 82                         sub.f64
	<modf+80 @04fdc0>   : 10 05                      dup.x1 sp(5)
	<modf+82 @04fdc2>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@04fdc3> - <@04fdc6>): return float64(.result := result);
	<modf+83 @04fdc3>   : 14 06                      set.x2 sp(6)
	<modf+85 @04fdc5>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@04fdc8>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@04fdc8> - <@04fde0>)
	lib/std/math.ci:48: (1 byte: <@04fdc8> - <@04fdc9>): result: float64
	<floor @04fdc8>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@04fdc9> - <@04fddd>): modf(void(x, result));
	<floor+1 @04fdc9>    : 11 05                      dup.x2 sp(5)
	<floor+3 @04fdcb>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @04fdcf>    : 1f 70 fd 04 00             load.ref <@04fd70> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @04fdd4>   : 02                         call
	<floor+13 @04fdd5>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @04fdd9>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@04fddd> - <@04fde0>): return float64(.result := result);
	<floor+21 @04fddd>   : 14 05                      set.x2 sp(5)
	<floor+23 @04fddf>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: ' Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: ' Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04fde0>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: ' Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@04fde0> - <@04fdf2>)
	lib/std/math.ci:78: (14 bytes: <@04fde0> - <@04fdee>): if (bool(x < (0)))
	<abs @04fde0>      : 10 01                      dup.x1 sp(1)
	<abs+2 @04fde2>    : 19                         load.z32
	<abs+3 @04fde3>    : 78                         clt.f32
	<abs+4 @04fde4>    : 06 0a 00 00                jz <abs+14 @04fdee>
	lib/std/math.ci:79: (6 bytes: <@04fde8> - <@04fdee>): return float32(.result := float32(-x));
	<abs+8 @04fde8>    : 10 01                      dup.x1 sp(1)
	<abs+10 @04fdea>   : 70                         neg.f32
	<abs+11 @04fdeb>   : 13 03                      set.x1 sp(3)
	<abs+13 @04fded>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@04fdee> - <@04fdf2>): return float32(.result := x);
	<abs+14 @04fdee>   : 16 02 01                   mov.x1 sp(2, 1)
	<abs+17 @04fdf1>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@04fdf8>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@04fdf8> - <@04fe0a>)
	lib/std/math.ci:86: (14 bytes: <@04fdf8> - <@04fe06>): if (bool(x < (0)))
	<abs @04fdf8>      : 11 01                      dup.x2 sp(1)
	<abs+2 @04fdfa>    : 1a                         load.z64
	<abs+3 @04fdfb>    : 88                         clt.f64
	<abs+4 @04fdfc>    : 06 0a 00 00                jz <abs+14 @04fe06>
	lib/std/math.ci:87: (6 bytes: <@04fe00> - <@04fe06>): return float64(.result := float64(-x));
	<abs+8 @04fe00>    : 11 01                      dup.x2 sp(1)
	<abs+10 @04fe02>   : 80                         neg.f64
	<abs+11 @04fe03>   : 14 05                      set.x2 sp(5)
	<abs+13 @04fe05>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@04fe06> - <@04fe0a>): return float64(.result := x);
	<abs+14 @04fe06>   : 17 03 01                   mov.x2 sp(3, 1)
	<abs+17 @04fe09>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04fe10>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: ' Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@04fe10> - <@04fe2b>)
	lib/std/math.ci:94: (23 bytes: <@04fe10> - <@04fe27>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @04fe10>      : 10 02                      dup.x1 sp(2)
	<absMod+2 @04fe12>    : 10 02                      dup.x1 sp(2)
	<absMod+4 @04fe14>    : 75                         mod.f32
	<absMod+5 @04fe15>    : 10 00                      dup.x1 sp(0)
	<absMod+7 @04fe17>    : 13 04                      set.x1 sp(4)
	<absMod+9 @04fe19>    : 19                         load.z32
	<absMod+10 @04fe1a>   : 78                         clt.f32
	<absMod+11 @04fe1b>   : 06 0c 00 00                jz <absMod+23 @04fe27>
	lib/std/math.ci:95: (8 bytes: <@04fe1f> - <@04fe27>): return float32(.result := float32(val + mod));
	<absMod+15 @04fe1f>   : 10 02                      dup.x1 sp(2)
	<absMod+17 @04fe21>   : 10 02                      dup.x1 sp(2)
	<absMod+19 @04fe23>   : 71                         add.f32
	<absMod+20 @04fe24>   : 13 04                      set.x1 sp(4)
	<absMod+22 @04fe26>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@04fe27> - <@04fe2b>): return float32(.result := val);
	<absMod+23 @04fe27>   : 16 03 02                   mov.x1 sp(3, 2)
	<absMod+26 @04fe2a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@04fe30>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: ' Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@04fe30> - <@04fe4b>)
	lib/std/math.ci:102: (23 bytes: <@04fe30> - <@04fe47>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @04fe30>      : 11 03                      dup.x2 sp(3)
	<absMod+2 @04fe32>    : 11 03                      dup.x2 sp(3)
	<absMod+4 @04fe34>    : 85                         mod.f64
	<absMod+5 @04fe35>    : 11 00                      dup.x2 sp(0)
	<absMod+7 @04fe37>    : 14 07                      set.x2 sp(7)
	<absMod+9 @04fe39>    : 1a                         load.z64
	<absMod+10 @04fe3a>   : 88                         clt.f64
	<absMod+11 @04fe3b>   : 06 0c 00 00                jz <absMod+23 @04fe47>
	lib/std/math.ci:103: (8 bytes: <@04fe3f> - <@04fe47>): return float64(.result := float64(val + mod));
	<absMod+15 @04fe3f>   : 11 03                      dup.x2 sp(3)
	<absMod+17 @04fe41>   : 11 03                      dup.x2 sp(3)
	<absMod+19 @04fe43>   : 81                         add.f64
	<absMod+20 @04fe44>   : 14 07                      set.x2 sp(7)
	<absMod+22 @04fe46>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@04fe47> - <@04fe4b>): return float64(.result := val);
	<absMod+23 @04fe47>   : 17 05 03                   mov.x2 sp(5, 3)
	<absMod+26 @04fe4a>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe50>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: ' Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04fe50> - <@04fe61>)
	lib/std/math.ci:116: (13 bytes: <@04fe50> - <@04fe5d>): if (bool(a < b))
	<min @04fe50>      : 10 02                      dup.x1 sp(2)
	<min+2 @04fe52>    : 10 02                      dup.x1 sp(2)
	<min+4 @04fe54>    : 78                         clt.f32
	<min+5 @04fe55>    : 06 08 00 00                jz <min+13 @04fe5d>
	lib/std/math.ci:117: (4 bytes: <@04fe59> - <@04fe5d>): return float32(.result := a);
	<min+9 @04fe59>    : 16 03 02                   mov.x1 sp(3, 2)
	<min+12 @04fe5c>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@04fe5d> - <@04fe61>): return float32(.result := b);
	<min+13 @04fe5d>   : 16 03 01                   mov.x1 sp(3, 1)
	<min+16 @04fe60>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe68>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: ' Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04fe68> - <@04fe79>)
	lib/std/math.ci:124: (13 bytes: <@04fe68> - <@04fe75>): if (bool(a < b))
	<min @04fe68>      : 11 03                      dup.x2 sp(3)
	<min+2 @04fe6a>    : 11 03                      dup.x2 sp(3)
	<min+4 @04fe6c>    : 88                         clt.f64
	<min+5 @04fe6d>    : 06 08 00 00                jz <min+13 @04fe75>
	lib/std/math.ci:125: (4 bytes: <@04fe71> - <@04fe75>): return float64(.result := a);
	<min+9 @04fe71>    : 17 05 03                   mov.x2 sp(5, 3)
	<min+12 @04fe74>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@04fe75> - <@04fe79>): return float64(.result := b);
	<min+13 @04fe75>   : 17 05 01                   mov.x2 sp(5, 1)
	<min+16 @04fe78>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe80>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: ' Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@04fe80> - <@04fe91>)
	lib/std/math.ci:138: (13 bytes: <@04fe80> - <@04fe8d>): if (bool(a > b))
	<max @04fe80>      : 10 02                      dup.x1 sp(2)
	<max+2 @04fe82>    : 10 02                      dup.x1 sp(2)
	<max+4 @04fe84>    : 79                         cgt.f32
	<max+5 @04fe85>    : 06 08 00 00                jz <max+13 @04fe8d>
	lib/std/math.ci:139: (4 bytes: <@04fe89> - <@04fe8d>): return float32(.result := a);
	<max+9 @04fe89>    : 16 03 02                   mov.x1 sp(3, 2)
	<max+12 @04fe8c>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@04fe8d> - <@04fe91>): return float32(.result := b);
	<max+13 @04fe8d>   : 16 03 01                   mov.x1 sp(3, 1)
	<max+16 @04fe90>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@04fe98>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: ' Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@04fe98> - <@04fea9>)
	lib/std/math.ci:146: (13 bytes: <@04fe98> - <@04fea5>): if (bool(a > b))
	<max @04fe98>      : 11 03                      dup.x2 sp(3)
	<max+2 @04fe9a>    : 11 03                      dup.x2 sp(3)
	<max+4 @04fe9c>    : 89                         cgt.f64
	<max+5 @04fe9d>    : 06 08 00 00                jz <max+13 @04fea5>
	lib/std/math.ci:147: (4 bytes: <@04fea1> - <@04fea5>): return float64(.result := a);
	<max+9 @04fea1>    : 17 05 03                   mov.x2 sp(5, 3)
	<max+12 @04fea4>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@04fea5> - <@04fea9>): return float64(.result := b);
	<max+13 @04fea5>   : 17 05 01                   mov.x2 sp(5, 1)
	<max+16 @04fea8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04feb0>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: ' Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@04feb0> - <@04fece>)
	lib/std/math.ci:160: (13 bytes: <@04feb0> - <@04febd>): if (bool(t < a))
	<clamp @04feb0>      : 10 03                      dup.x1 sp(3)
	<clamp+2 @04feb2>    : 10 03                      dup.x1 sp(3)
	<clamp+4 @04feb4>    : 78                         clt.f32
	<clamp+5 @04feb5>    : 06 08 00 00                jz <clamp+13 @04febd>
	lib/std/math.ci:161: (4 bytes: <@04feb9> - <@04febd>): return float32(.result := a);
	<clamp+9 @04feb9>    : 16 04 02                   mov.x1 sp(4, 2)
	<clamp+12 @04febc>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@04febd> - <@04feca>): if (bool(t > b))
	<clamp+13 @04febd>   : 10 03                      dup.x1 sp(3)
	<clamp+15 @04febf>   : 10 02                      dup.x1 sp(2)
	<clamp+17 @04fec1>   : 79                         cgt.f32
	<clamp+18 @04fec2>   : 06 08 00 00                jz <clamp+26 @04feca>
	lib/std/math.ci:164: (4 bytes: <@04fec6> - <@04feca>): return float32(.result := b);
	<clamp+22 @04fec6>   : 16 04 01                   mov.x1 sp(4, 1)
	<clamp+25 @04fec9>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@04feca> - <@04fece>): return float32(.result := t);
	<clamp+26 @04feca>   : 16 04 03                   mov.x1 sp(4, 3)
	<clamp+29 @04fecd>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@04fed0>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: ' Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@04fed0> - <@04feee>)
	lib/std/math.ci:171: (13 bytes: <@04fed0> - <@04fedd>): if (bool(t < a))
	<clamp @04fed0>      : 11 05                      dup.x2 sp(5)
	<clamp+2 @04fed2>    : 11 05                      dup.x2 sp(5)
	<clamp+4 @04fed4>    : 88                         clt.f64
	<clamp+5 @04fed5>    : 06 08 00 00                jz <clamp+13 @04fedd>
	lib/std/math.ci:172: (4 bytes: <@04fed9> - <@04fedd>): return float64(.result := a);
	<clamp+9 @04fed9>    : 17 07 03                   mov.x2 sp(7, 3)
	<clamp+12 @04fedc>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@04fedd> - <@04feea>): if (bool(t > b))
	<clamp+13 @04fedd>   : 11 05                      dup.x2 sp(5)
	<clamp+15 @04fedf>   : 11 03                      dup.x2 sp(3)
	<clamp+17 @04fee1>   : 89                         cgt.f64
	<clamp+18 @04fee2>   : 06 08 00 00                jz <clamp+26 @04feea>
	lib/std/math.ci:175: (4 bytes: <@04fee6> - <@04feea>): return float64(.result := b);
	<clamp+22 @04fee6>   : 17 07 01                   mov.x2 sp(7, 1)
	<clamp+25 @04fee9>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@04feea> - <@04feee>): return float64(.result := t);
	<clamp+26 @04feea>   : 17 07 05                   mov.x2 sp(7, 5)
	<clamp+29 @04feed>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: ' Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: ' Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: ' Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: ' Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04fef0>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: ' Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04fef0> - <@04ff38>)
	lib/std/math.ci:202: (13 bytes: <@04fef0> - <@04fefd>): if (bool(data.length == (0)))
	<min @04fef0>      : 10 02                      dup.x1 sp(2)
	<min+2 @04fef2>    : 19                         load.z32
	<min+3 @04fef3>    : 57                         ceq.i32
	<min+4 @04fef4>    : 06 09 00 00                jz <min+13 @04fefd>
	lib/std/math.ci:203: (5 bytes: <@04fef8> - <@04fefd>): return float64(.result := nan);
	<min+8 @04fef8>    : 1b                         load.z128
	<min+9 @04fef9>    : 84                         div.f64
	<min+10 @04fefa>   : 14 05                      set.x2 sp(5)
	<min+12 @04fefc>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@04fefd> - <@04ff00>): result: float64 := data[0]
	<min+13 @04fefd>   : 10 01                      dup.x1 sp(1)
	<min+15 @04feff>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@04ff00> - <@04ff35>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+16 @04ff00>   : 1c 01 00 00 00             load.c32 1
	<min+21 @04ff05>   : 04 23 00 00                jmp <min+56 @04ff28>
	lib/std/math.ci:207: (27 bytes: <@04ff09> - <@04ff24>): if (bool(result > data[i]))
	<min+25 @04ff09>   : 11 01                      dup.x2 sp(1)
	<min+27 @04ff0b>   : 10 06                      dup.x1 sp(6)
	<min+29 @04ff0d>   : 10 03                      dup.x1 sp(3)
	<min+31 @04ff0f>   : 0d 08 00 00                mad.u32 8
	<min+35 @04ff13>   : 23                         load.i64
	<min+36 @04ff14>   : 89                         cgt.f64
	<min+37 @04ff15>   : 06 0f 00 00                jz <min+52 @04ff24>
	lib/std/math.ci:208: (11 bytes: <@04ff19> - <@04ff24>): float64(result := data[i]);
	<min+41 @04ff19>   : 10 04                      dup.x1 sp(4)
	<min+43 @04ff1b>   : 10 01                      dup.x1 sp(1)
	<min+45 @04ff1d>   : 0d 08 00 00                mad.u32 8
	<min+49 @04ff21>   : 23                         load.i64
	<min+50 @04ff22>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:206: (4 bytes: <@04ff24> - <@04ff28>): int32(i := int32(i + 1))
	<min+52 @04ff24>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@04ff28> - <@04ff31>): bool(i < (data.length))
	<min+56 @04ff28>   : 10 00                      dup.x1 sp(0)
	<min+58 @04ff2a>   : 10 06                      dup.x1 sp(6)
	<min+60 @04ff2c>   : 58                         clt.i32
	<min+61 @04ff2d>   : 05 dc ff ff                jnz <min+25 @04ff09>
	<min+65 @04ff31>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@04ff35> - <@04ff38>): return float64(.result := result);
	<min+69 @04ff35>   : 14 05                      set.x2 sp(5)
	<min+71 @04ff37>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 72
.offset: <@04ff38>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: ' Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (72 bytes: <@04ff38> - <@04ff80>)
	lib/std/math.ci:216: (13 bytes: <@04ff38> - <@04ff45>): if (bool(data.length == (0)))
	<max @04ff38>      : 10 02                      dup.x1 sp(2)
	<max+2 @04ff3a>    : 19                         load.z32
	<max+3 @04ff3b>    : 57                         ceq.i32
	<max+4 @04ff3c>    : 06 09 00 00                jz <max+13 @04ff45>
	lib/std/math.ci:217: (5 bytes: <@04ff40> - <@04ff45>): return float64(.result := nan);
	<max+8 @04ff40>    : 1b                         load.z128
	<max+9 @04ff41>    : 84                         div.f64
	<max+10 @04ff42>   : 14 05                      set.x2 sp(5)
	<max+12 @04ff44>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@04ff45> - <@04ff48>): result: float64 := data[0]
	<max+13 @04ff45>   : 10 01                      dup.x1 sp(1)
	<max+15 @04ff47>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@04ff48> - <@04ff7d>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+16 @04ff48>   : 1c 01 00 00 00             load.c32 1
	<max+21 @04ff4d>   : 04 23 00 00                jmp <max+56 @04ff70>
	lib/std/math.ci:221: (27 bytes: <@04ff51> - <@04ff6c>): if (bool(result < data[i]))
	<max+25 @04ff51>   : 11 01                      dup.x2 sp(1)
	<max+27 @04ff53>   : 10 06                      dup.x1 sp(6)
	<max+29 @04ff55>   : 10 03                      dup.x1 sp(3)
	<max+31 @04ff57>   : 0d 08 00 00                mad.u32 8
	<max+35 @04ff5b>   : 23                         load.i64
	<max+36 @04ff5c>   : 88                         clt.f64
	<max+37 @04ff5d>   : 06 0f 00 00                jz <max+52 @04ff6c>
	lib/std/math.ci:222: (11 bytes: <@04ff61> - <@04ff6c>): float64(result := data[i]);
	<max+41 @04ff61>   : 10 04                      dup.x1 sp(4)
	<max+43 @04ff63>   : 10 01                      dup.x1 sp(1)
	<max+45 @04ff65>   : 0d 08 00 00                mad.u32 8
	<max+49 @04ff69>   : 23                         load.i64
	<max+50 @04ff6a>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:220: (4 bytes: <@04ff6c> - <@04ff70>): int32(i := int32(i + 1))
	<max+52 @04ff6c>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@04ff70> - <@04ff79>): bool(i < (data.length))
	<max+56 @04ff70>   : 10 00                      dup.x1 sp(0)
	<max+58 @04ff72>   : 10 06                      dup.x1 sp(6)
	<max+60 @04ff74>   : 58                         clt.i32
	<max+61 @04ff75>   : 05 dc ff ff                jnz <max+25 @04ff51>
	<max+65 @04ff79>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@04ff7d> - <@04ff80>): return float64(.result := result);
	<max+69 @04ff7d>   : 14 05                      set.x2 sp(5)
	<max+71 @04ff7f>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@04ff80>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: ' Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@04ff80> - <@04ffa8>)
	lib/std/math.ci:230: (1 byte: <@04ff80> - <@04ff81>): result: float64 := 0
	<sum @04ff80>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@04ff81> - <@04ffa5>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @04ff81>    : 6a                         i64.2i32
	<sum+2 @04ff82>    : 04 16 00 00                jmp <sum+24 @04ff98>
	lib/std/math.ci:232: (14 bytes: <@04ff86> - <@04ff94>): float64(result := float64(result + data[i]));
	<sum+6 @04ff86>    : 11 01                      dup.x2 sp(1)
	<sum+8 @04ff88>    : 10 06                      dup.x1 sp(6)
	<sum+10 @04ff8a>   : 10 03                      dup.x1 sp(3)
	<sum+12 @04ff8c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @04ff90>   : 23                         load.i64
	<sum+17 @04ff91>   : 81                         add.f64
	<sum+18 @04ff92>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:231: (4 bytes: <@04ff94> - <@04ff98>): int32(i := int32(i + 1))
	<sum+20 @04ff94>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@04ff98> - <@04ffa1>): bool(i < (data.length))
	<sum+24 @04ff98>   : 10 00                      dup.x1 sp(0)
	<sum+26 @04ff9a>   : 10 06                      dup.x1 sp(6)
	<sum+28 @04ff9c>   : 58                         clt.i32
	<sum+29 @04ff9d>   : 05 e9 ff ff                jnz <sum+6 @04ff86>
	<sum+33 @04ffa1>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@04ffa5> - <@04ffa8>): return float64(.result := result);
	<sum+37 @04ffa5>   : 14 05                      set.x2 sp(5)
	<sum+39 @04ffa7>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: ' Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: ' Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: ' Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: ' Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@04ffa8>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: ' Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@04ffa8> - <@04ffd7>)
	lib/std/math.ci:257: (1 byte: <@04ffa8> - <@04ffa9>): result: float64 := 0
	<eval @04ffa8>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@04ffa9> - <@04ffd4>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @04ffa9>    : 10 04                      dup.x1 sp(4)
	<eval+3 @04ffab>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @04ffaf>    : 04 19 00 00                jmp <eval+32 @04ffc8>
	lib/std/math.ci:259: (17 bytes: <@04ffb3> - <@04ffc4>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @04ffb3>   : 11 01                      dup.x2 sp(1)
	<eval+13 @04ffb5>   : 11 08                      dup.x2 sp(8)
	<eval+15 @04ffb7>   : 83                         mul.f64
	<eval+16 @04ffb8>   : 10 06                      dup.x1 sp(6)
	<eval+18 @04ffba>   : 10 03                      dup.x1 sp(3)
	<eval+20 @04ffbc>   : 0d 08 00 00                mad.u32 8
	<eval+24 @04ffc0>   : 23                         load.i64
	<eval+25 @04ffc1>   : 81                         add.f64
	<eval+26 @04ffc2>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:258: (4 bytes: <@04ffc4> - <@04ffc8>): int32(i := int32(i - 1))
	<eval+28 @04ffc4>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@04ffc8> - <@04ffd0>): bool(i >= 0)
	<eval+32 @04ffc8>   : 10 00                      dup.x1 sp(0)
	<eval+34 @04ffca>   : 19                         load.z32
	<eval+35 @04ffcb>   : 58                         clt.i32
	<eval+36 @04ffcc>   : 06 e7 ff ff                jz <eval+11 @04ffb3>
	<eval+40 @04ffd0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@04ffd4> - <@04ffd7>): return float64(.result := result);
	<eval+44 @04ffd4>   : 14 07                      set.x2 sp(7)
	<eval+46 @04ffd6>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@04ffd8>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: ' Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@04ffd8> - <@050011>)
	lib/std/math.ci:266: (53 bytes: <@04ffd8> - <@05000d>): if (bool(a < b))
	<cmp @04ffd8>      : 10 03                      dup.x1 sp(3)
	<cmp+2 @04ffda>    : 10 03                      dup.x1 sp(3)
	<cmp+4 @04ffdc>    : 78                         clt.f32
	<cmp+5 @04ffdd>    : 06 1c 00 00                jz <cmp+33 @04fff9>
	lib/std/math.ci:267: (20 bytes: <@04ffe1> - <@04fff5>): if (bool(eps < (float32(b - a))))
	<cmp+9 @04ffe1>    : 10 01                      dup.x1 sp(1)
	<cmp+11 @04ffe3>   : 10 03                      dup.x1 sp(3)
	<cmp+13 @04ffe5>   : 10 05                      dup.x1 sp(5)
	<cmp+15 @04ffe7>   : 72                         sub.f32
	<cmp+16 @04ffe8>   : 78                         clt.f32
	<cmp+17 @04ffe9>   : 06 0c 00 00                jz <cmp+29 @04fff5>
	lib/std/math.ci:268: (8 bytes: <@04ffed> - <@04fff5>): return int32(.result := int32(-1));
	<cmp+21 @04ffed>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @04fff2>   : 13 05                      set.x1 sp(5)
	<cmp+28 @04fff4>   : 03                         ret
	<cmp+29 @04fff5>   : 04 18 00 00                jmp <cmp+53 @05000d>
	lib/std/math.ci:272: (20 bytes: <@04fff9> - <@05000d>): if (bool(eps < (float32(a - b))))
	<cmp+33 @04fff9>   : 10 01                      dup.x1 sp(1)
	<cmp+35 @04fffb>   : 10 04                      dup.x1 sp(4)
	<cmp+37 @04fffd>   : 10 04                      dup.x1 sp(4)
	<cmp+39 @04ffff>   : 72                         sub.f32
	<cmp+40 @050000>   : 78                         clt.f32
	<cmp+41 @050001>   : 06 0c 00 00                jz <cmp+53 @05000d>
	lib/std/math.ci:273: (8 bytes: <@050005> - <@05000d>): return int32(.result := int32(+1));
	<cmp+45 @050005>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05000a>   : 13 05                      set.x1 sp(5)
	<cmp+52 @05000c>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@05000d> - <@050011>): return int32(.result := 0);
	<cmp+53 @05000d>   : 19                         load.z32
	<cmp+54 @05000e>   : 13 05                      set.x1 sp(5)
	<cmp+56 @050010>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@050018>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: ' Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@050018> - <@050051>)
	lib/std/math.ci:281: (53 bytes: <@050018> - <@05004d>): if (bool(a < b))
	<cmp @050018>      : 11 05                      dup.x2 sp(5)
	<cmp+2 @05001a>    : 11 05                      dup.x2 sp(5)
	<cmp+4 @05001c>    : 88                         clt.f64
	<cmp+5 @05001d>    : 06 1c 00 00                jz <cmp+33 @050039>
	lib/std/math.ci:282: (20 bytes: <@050021> - <@050035>): if (bool(eps < (float64(b - a))))
	<cmp+9 @050021>    : 11 01                      dup.x2 sp(1)
	<cmp+11 @050023>   : 11 05                      dup.x2 sp(5)
	<cmp+13 @050025>   : 11 09                      dup.x2 sp(9)
	<cmp+15 @050027>   : 82                         sub.f64
	<cmp+16 @050028>   : 88                         clt.f64
	<cmp+17 @050029>   : 06 0c 00 00                jz <cmp+29 @050035>
	lib/std/math.ci:283: (8 bytes: <@05002d> - <@050035>): return int32(.result := int32(-1));
	<cmp+21 @05002d>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @050032>   : 13 08                      set.x1 sp(8)
	<cmp+28 @050034>   : 03                         ret
	<cmp+29 @050035>   : 04 18 00 00                jmp <cmp+53 @05004d>
	lib/std/math.ci:287: (20 bytes: <@050039> - <@05004d>): if (bool(eps < (float64(a - b))))
	<cmp+33 @050039>   : 11 01                      dup.x2 sp(1)
	<cmp+35 @05003b>   : 11 07                      dup.x2 sp(7)
	<cmp+37 @05003d>   : 11 07                      dup.x2 sp(7)
	<cmp+39 @05003f>   : 82                         sub.f64
	<cmp+40 @050040>   : 88                         clt.f64
	<cmp+41 @050041>   : 06 0c 00 00                jz <cmp+53 @05004d>
	lib/std/math.ci:288: (8 bytes: <@050045> - <@05004d>): return int32(.result := int32(+1));
	<cmp+45 @050045>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05004a>   : 13 08                      set.x1 sp(8)
	<cmp+52 @05004c>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@05004d> - <@050051>): return int32(.result := 0);
	<cmp+53 @05004d>   : 19                         load.z32
	<cmp+54 @05004e>   : 13 08                      set.x1 sp(8)
	<cmp+56 @050050>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@050058>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@050058> - <@0501a7>)
	lib/std/math.ci:309: (2 bytes: <@050058> - <@05005a>): x: float64 := arg
	<sinCos @050058>      : 11 02                      dup.x2 sp(2)
	lib/std/math.ci:310: (17 bytes: <@05005a> - <@05006b>): if (bool(x < (0)))
	<sinCos+2 @05005a>    : 11 00                      dup.x2 sp(0)
	<sinCos+4 @05005c>    : 1a                         load.z64
	<sinCos+5 @05005d>    : 88                         clt.f64
	<sinCos+6 @05005e>    : 06 0d 00 00                jz <sinCos+19 @05006b>
	lib/std/math.ci:311: (1 byte: <@050062> - <@050063>): float64(x := float64(-x));
	<sinCos+10 @050062>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@050063> - <@05006b>): int32(quad := int32(quad + 2));
	<sinCos+11 @050063>   : 10 03                      dup.x1 sp(3)
	<sinCos+13 @050065>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @050069>   : 13 04                      set.x1 sp(4)
	lib/std/math.ci:315: (1 byte: <@05006b> - <@05006c>): y: float64
	<sinCos+19 @05006b>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@05006c> - <@050084>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @05006c>   : 11 02                      dup.x2 sp(2)
	<sinCos+22 @05006e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @050077>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @050080>   : 84                         div.f64
	<sinCos+41 @050081>   : 83                         mul.f64
	<sinCos+42 @050082>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:317: (124 bytes: <@050084> - <@050100>): if (bool(x > (32764)))
	<sinCos+44 @050084>   : 11 02                      dup.x2 sp(2)
	<sinCos+46 @050086>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05008f>   : 89                         cgt.f64
	<sinCos+56 @050090>   : 06 54 00 00                jz <sinCos+140 @0500e4>
	lib/std/math.ci:318: (1 byte: <@050094> - <@050095>): e: float64
	<sinCos+60 @050094>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@050095> - <@0500a7>): float64(y := modf(void(x, e)));
	<sinCos+61 @050095>   : 11 06                      dup.x2 sp(6)
	<sinCos+63 @050097>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05009b>   : 1f 70 fd 04 00             load.ref <@04fd70> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @0500a0>   : 02                         call
	<sinCos+73 @0500a1>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @0500a5>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:320: (4 bytes: <@0500a7> - <@0500ab>): float64(e := float64(e + (quad)));
	<sinCos+79 @0500a7>   : 10 07                      dup.x1 sp(7)
	<sinCos+81 @0500a9>   : 5d                         i32.2f64
	<sinCos+82 @0500aa>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@0500ab> - <@0500ac>): f: float64
	<sinCos+83 @0500ab>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@0500ac> - <@0500ca>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @0500ac>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @0500b5>   : 11 06                      dup.x2 sp(6)
	<sinCos+95 @0500b7>   : 83                         mul.f64
	<sinCos+96 @0500b8>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @0500bc>  : 1f 70 fd 04 00             load.ref <@04fd70> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @0500c1>  : 02                         call
	<sinCos+106 @0500c2>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @0500c6>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@0500ca> - <@0500dc>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @0500ca>  : 11 02                      dup.x2 sp(2)
	<sinCos+116 @0500cc>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @0500d5>  : 11 04                      dup.x2 sp(4)
	<sinCos+127 @0500d7>  : 83                         mul.f64
	<sinCos+128 @0500d8>  : 82                         sub.f64
	<sinCos+129 @0500d9>  : 8a                         f64.2i32
	<sinCos+130 @0500da>  : 13 0a                      set.x1 sp(10)
	<sinCos+132 @0500dc>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @0500e0>  : 04 20 00 00                jmp <sinCos+168 @050100>
	lib/std/math.ci:327: (3 bytes: <@0500e4> - <@0500e7>): k: int32 := x
	<sinCos+140 @0500e4>  : 11 02                      dup.x2 sp(2)
	<sinCos+142 @0500e6>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@0500e7> - <@0500ef>): float64(y := float64(x - (k)));
	<sinCos+143 @0500e7>  : 11 03                      dup.x2 sp(3)
	<sinCos+145 @0500e9>  : 10 02                      dup.x1 sp(2)
	<sinCos+147 @0500eb>  : 5d                         i32.2f64
	<sinCos+148 @0500ec>  : 82                         sub.f64
	<sinCos+149 @0500ed>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:329: (7 bytes: <@0500ef> - <@0500f6>): int32(quad := int32(quad + k));
	<sinCos+151 @0500ef>  : 10 06                      dup.x1 sp(6)
	<sinCos+153 @0500f1>  : 10 01                      dup.x1 sp(1)
	<sinCos+155 @0500f3>  : 51                         add.i32
	<sinCos+156 @0500f4>  : 13 07                      set.x1 sp(7)
	lib/std/math.ci:330: (6 bytes: <@0500f6> - <@0500fc>): int32(quad := int32(quad & 3));
	<sinCos+158 @0500f6>  : 10 06                      dup.x1 sp(6)
	<sinCos+160 @0500f8>  : 3f 02                      b32.and 0x003
	<sinCos+162 @0500fa>  : 13 07                      set.x1 sp(7)
	<sinCos+164 @0500fc>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@050100> - <@050116>): if (int32(quad & 1))
	<sinCos+168 @050100>  : 10 05                      dup.x1 sp(5)
	<sinCos+170 @050102>  : 3f 01                      b32.and 0x001
	<sinCos+172 @050104>  : 06 12 00 00                jz <sinCos+190 @050116>
	lib/std/math.ci:333: (14 bytes: <@050108> - <@050116>): float64(y := float64((1) - y));
	<sinCos+176 @050108>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @050111>  : 11 02                      dup.x2 sp(2)
	<sinCos+187 @050113>  : 82                         sub.f64
	<sinCos+188 @050114>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:335: (13 bytes: <@050116> - <@050123>): if (bool(quad > 1))
	<sinCos+190 @050116>  : 10 05                      dup.x1 sp(5)
	<sinCos+192 @050118>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05011d>  : 59                         cgt.i32
	<sinCos+198 @05011e>  : 06 05 00 00                jz <sinCos+203 @050123>
	lib/std/math.ci:336: (1 byte: <@050122> - <@050123>): float64(y := float64(-y));
	<sinCos+202 @050122>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@050123> - <@050128>): ysq: float64 := float64(y * y)
	<sinCos+203 @050123>  : 11 00                      dup.x2 sp(0)
	<sinCos+205 @050125>  : 11 02                      dup.x2 sp(2)
	<sinCos+207 @050127>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@050128> - <@050168>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @050128>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @050131>  : 11 02                      dup.x2 sp(2)
	<sinCos+219 @050133>  : 83                         mul.f64
	<sinCos+220 @050134>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05013d>  : 81                         add.f64
	<sinCos+230 @05013e>  : 11 02                      dup.x2 sp(2)
	<sinCos+232 @050140>  : 83                         mul.f64
	<sinCos+233 @050141>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05014a>  : 81                         add.f64
	<sinCos+243 @05014b>  : 11 02                      dup.x2 sp(2)
	<sinCos+245 @05014d>  : 83                         mul.f64
	<sinCos+246 @05014e>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @050157>  : 81                         add.f64
	<sinCos+256 @050158>  : 11 02                      dup.x2 sp(2)
	<sinCos+258 @05015a>  : 83                         mul.f64
	<sinCos+259 @05015b>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @050164>  : 81                         add.f64
	<sinCos+269 @050165>  : 11 04                      dup.x2 sp(4)
	<sinCos+271 @050167>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@050168> - <@05019b>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @050168>  : 11 02                      dup.x2 sp(2)
	<sinCos+274 @05016a>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @050173>  : 81                         add.f64
	<sinCos+284 @050174>  : 11 04                      dup.x2 sp(4)
	<sinCos+286 @050176>  : 83                         mul.f64
	<sinCos+287 @050177>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @050180>  : 81                         add.f64
	<sinCos+297 @050181>  : 11 04                      dup.x2 sp(4)
	<sinCos+299 @050183>  : 83                         mul.f64
	<sinCos+300 @050184>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05018d>  : 81                         add.f64
	<sinCos+310 @05018e>  : 11 04                      dup.x2 sp(4)
	<sinCos+312 @050190>  : 83                         mul.f64
	<sinCos+313 @050191>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05019a>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@05019b> - <@0501a7>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @05019b>  : 11 02                      dup.x2 sp(2)
	<sinCos+325 @05019d>  : 11 02                      dup.x2 sp(2)
	<sinCos+327 @05019f>  : 84                         div.f64
	<sinCos+328 @0501a0>  : 14 10                      set.x2 sp(16)
	<sinCos+330 @0501a2>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @0501a6>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 371
.offset: <@0501a8>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (371 bytes: <@0501a8> - <@05031b>)
	lib/std/math.ci:365: (1 byte: <@0501a8> - <@0501a9>): complement: bool := false
	<tan @0501a8>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@0501a9> - <@0501aa>): negate: bool := false
	<tan+1 @0501a9>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@0501aa> - <@0501c1>): if (bool(arg < (0)))
	<tan+2 @0501aa>    : 11 03                      dup.x2 sp(3)
	<tan+4 @0501ac>    : 1a                         load.z64
	<tan+5 @0501ad>    : 88                         clt.f64
	<tan+6 @0501ae>    : 06 13 00 00                jz <tan+25 @0501c1>
	lib/std/math.ci:369: (5 bytes: <@0501b2> - <@0501b7>): float64(arg := float64(-arg));
	<tan+10 @0501b2>   : 11 03                      dup.x2 sp(3)
	<tan+12 @0501b4>   : 80                         neg.f64
	<tan+13 @0501b5>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:370: (10 bytes: <@0501b7> - <@0501c1>): bool(negate := true);
	<tan+15 @0501b7>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @0501bc>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @0501c0>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@0501c1> - <@0501d9>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @0501c1>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @0501ca>   : 11 05                      dup.x2 sp(5)
	<tan+36 @0501cc>   : 83                         mul.f64
	<tan+37 @0501cd>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @0501d6>   : 84                         div.f64
	<tan+47 @0501d7>   : 14 05                      set.x2 sp(5)
	lib/std/math.ci:374: (1 byte: <@0501d9> - <@0501da>): e: float64
	<tan+49 @0501d9>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@0501da> - <@0501ea>): x: float64 := modf(void(arg, e))
	<tan+50 @0501da>   : 11 07                      dup.x2 sp(7)
	<tan+52 @0501dc>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @0501e0>   : 1f 70 fd 04 00             load.ref <@04fd70> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @0501e5>   : 02                         call
	<tan+62 @0501e6>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@0501ea> - <@0501f3>): i: int32 := int32(int32(e) % 4)
	<tan+66 @0501ea>   : 11 02                      dup.x2 sp(2)
	<tan+68 @0501ec>   : 8a                         f64.2i32
	<tan+69 @0501ed>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @0501f2>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@0501f3> - <@05026d>): if (bool(i == 0))
	<tan+75 @0501f3>   : 10 00                      dup.x1 sp(0)
	<tan+77 @0501f5>   : 19                         load.z32
	<tan+78 @0501f6>   : 57                         ceq.i32
	<tan+79 @0501f7>   : 05 76 00 00                jnz <tan+197 @05026d>
	lib/std/math.ci:379: (114 bytes: <@0501fb> - <@05026d>): if (bool(i == 1))
	<tan+83 @0501fb>   : 10 00                      dup.x1 sp(0)
	<tan+85 @0501fd>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @050202>   : 57                         ceq.i32
	<tan+91 @050203>   : 06 20 00 00                jz <tan+123 @050223>
	lib/std/math.ci:380: (14 bytes: <@050207> - <@050215>): float64(x := float64((1) - x));
	<tan+95 @050207>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @050210>  : 11 03                      dup.x2 sp(3)
	<tan+106 @050212>  : 82                         sub.f64
	<tan+107 @050213>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:381: (10 bytes: <@050215> - <@05021f>): bool(complement := true);
	<tan+109 @050215>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05021a>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05021e>  : 25                         store.i8
	<tan+119 @05021f>  : 04 4e 00 00                jmp <tan+197 @05026d>
	lib/std/math.ci:383: (74 bytes: <@050223> - <@05026d>): if (bool(i == 2))
	<tan+123 @050223>  : 10 00                      dup.x1 sp(0)
	<tan+125 @050225>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05022a>  : 57                         ceq.i32
	<tan+131 @05022b>  : 06 1d 00 00                jz <tan+160 @050248>
	lib/std/math.ci:384: (11 bytes: <@05022f> - <@05023a>): bool(negate := bool(!negate));
	<tan+135 @05022f>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @050233>  : 20                         load.i8
	<tan+140 @050234>  : 0b                         not.b32
	<tan+141 @050235>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @050239>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@05023a> - <@050244>): bool(complement := true);
	<tan+146 @05023a>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05023f>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @050243>  : 25                         store.i8
	<tan+156 @050244>  : 04 29 00 00                jmp <tan+197 @05026d>
	lib/std/math.ci:387: (37 bytes: <@050248> - <@05026d>): if (bool(i == 3))
	<tan+160 @050248>  : 10 00                      dup.x1 sp(0)
	<tan+162 @05024a>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05024f>  : 57                         ceq.i32
	<tan+168 @050250>  : 06 1d 00 00                jz <tan+197 @05026d>
	lib/std/math.ci:388: (14 bytes: <@050254> - <@050262>): float64(x := float64((1) - x));
	<tan+172 @050254>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05025d>  : 11 03                      dup.x2 sp(3)
	<tan+183 @05025f>  : 82                         sub.f64
	<tan+184 @050260>  : 14 03                      set.x2 sp(3)
	lib/std/math.ci:389: (11 bytes: <@050262> - <@05026d>): bool(negate := bool(!negate));
	<tan+186 @050262>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @050266>  : 20                         load.i8
	<tan+191 @050267>  : 0b                         not.b32
	<tan+192 @050268>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05026c>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@05026d> - <@050272>): xsq: float64 := float64(x * x)
	<tan+197 @05026d>  : 11 01                      dup.x2 sp(1)
	<tan+199 @05026f>  : 11 03                      dup.x2 sp(3)
	<tan+201 @050271>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@050272> - <@0502b2>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @050272>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05027b>  : 11 02                      dup.x2 sp(2)
	<tan+213 @05027d>  : 83                         mul.f64
	<tan+214 @05027e>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @050287>  : 81                         add.f64
	<tan+224 @050288>  : 11 02                      dup.x2 sp(2)
	<tan+226 @05028a>  : 83                         mul.f64
	<tan+227 @05028b>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @050294>  : 81                         add.f64
	<tan+237 @050295>  : 11 02                      dup.x2 sp(2)
	<tan+239 @050297>  : 83                         mul.f64
	<tan+240 @050298>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @0502a1>  : 81                         add.f64
	<tan+250 @0502a2>  : 11 02                      dup.x2 sp(2)
	<tan+252 @0502a4>  : 83                         mul.f64
	<tan+253 @0502a5>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @0502ae>  : 81                         add.f64
	<tan+263 @0502af>  : 11 05                      dup.x2 sp(5)
	<tan+265 @0502b1>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@0502b2> - <@0502d9>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @0502b2>  : 11 02                      dup.x2 sp(2)
	<tan+268 @0502b4>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @0502bd>  : 81                         add.f64
	<tan+278 @0502be>  : 11 04                      dup.x2 sp(4)
	<tan+280 @0502c0>  : 83                         mul.f64
	<tan+281 @0502c1>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @0502ca>  : 81                         add.f64
	<tan+291 @0502cb>  : 11 04                      dup.x2 sp(4)
	<tan+293 @0502cd>  : 83                         mul.f64
	<tan+294 @0502ce>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @0502d7>  : 81                         add.f64
	<tan+304 @0502d8>  : 84                         div.f64
	lib/std/math.ci:396: (40 bytes: <@0502d9> - <@050301>): if (complement)
	<tan+305 @0502d9>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @0502dd>  : 20                         load.i8
	<tan+310 @0502de>  : 06 23 00 00                jz <tan+345 @050301>
	lib/std/math.ci:397: (17 bytes: <@0502e2> - <@0502f3>): if (bool(result == (0)))
	<tan+314 @0502e2>  : 11 00                      dup.x2 sp(0)
	<tan+316 @0502e4>  : 1a                         load.z64
	<tan+317 @0502e5>  : 87                         ceq.f64
	<tan+318 @0502e6>  : 06 0d 00 00                jz <tan+331 @0502f3>
	lib/std/math.ci:398: (9 bytes: <@0502ea> - <@0502f3>): return float64(.result := nan);
	<tan+322 @0502ea>  : 1b                         load.z128
	<tan+323 @0502eb>  : 84                         div.f64
	<tan+324 @0502ec>  : 14 10                      set.x2 sp(16)
	<tan+326 @0502ee>  : 09 d4 ff ff                inc.sp(-44)
	<tan+330 @0502f2>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@0502f3> - <@050301>): float64(result := float64((1) / result));
	<tan+331 @0502f3>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+340 @0502fc>  : 11 02                      dup.x2 sp(2)
	<tan+342 @0502fe>  : 84                         div.f64
	<tan+343 @0502ff>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:402: (19 bytes: <@050301> - <@050314>): if (negate)
	<tan+345 @050301>  : 0a 24 00 00                load.sp(+36)
	<tan+349 @050305>  : 20                         load.i8
	<tan+350 @050306>  : 06 0e 00 00                jz <tan+364 @050314>
	lib/std/math.ci:403: (10 bytes: <@05030a> - <@050314>): return float64(.result := float64(-result));
	<tan+354 @05030a>  : 11 00                      dup.x2 sp(0)
	<tan+356 @05030c>  : 80                         neg.f64
	<tan+357 @05030d>  : 14 10                      set.x2 sp(16)
	<tan+359 @05030f>  : 09 d4 ff ff                inc.sp(-44)
	<tan+363 @050313>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@050314> - <@05031b>): return float64(.result := result);
	<tan+364 @050314>  : 14 0e                      set.x2 sp(14)
	<tan+366 @050316>  : 09 dc ff ff                inc.sp(-36)
	<tan+370 @05031a>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@050320>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@050320> - <@050411>)
	lib/std/math.ci:421: (1 byte: <@050320> - <@050321>): negate: bool := false
	<sinh @050320>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@050321> - <@050338>): if (bool(x < (0)))
	<sinh+1 @050321>    : 11 02                      dup.x2 sp(2)
	<sinh+3 @050323>    : 1a                         load.z64
	<sinh+4 @050324>    : 88                         clt.f64
	<sinh+5 @050325>    : 06 13 00 00                jz <sinh+24 @050338>
	lib/std/math.ci:423: (5 bytes: <@050329> - <@05032e>): float64(x := float64(-x));
	<sinh+9 @050329>    : 11 02                      dup.x2 sp(2)
	<sinh+11 @05032b>   : 80                         neg.f64
	<sinh+12 @05032c>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:424: (10 bytes: <@05032e> - <@050338>): bool(negate := true);
	<sinh+14 @05032e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @050333>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @050337>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@050338> - <@05035f>): if (bool(x > (21)))
	<sinh+24 @050338>   : 11 02                      dup.x2 sp(2)
	<sinh+26 @05033a>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @050343>   : 89                         cgt.f64
	<sinh+36 @050344>   : 06 1b 00 00                jz <sinh+63 @05035f>
	lib/std/math.ci:428: (23 bytes: <@050348> - <@05035f>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @050348>   : 11 02                      dup.x2 sp(2)
	<sinh+42 @05034a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+46 @05034e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @050357>   : 84                         div.f64
	<sinh+56 @050358>   : 14 06                      set.x2 sp(6)
	<sinh+58 @05035a>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @05035e>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@05035f> - <@050360>): result: float64
	<sinh+63 @05035f>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@050360> - <@0503f7>): if (bool(x > 0.500000))
	<sinh+64 @050360>   : 11 04                      dup.x2 sp(4)
	<sinh+66 @050362>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @05036b>   : 89                         cgt.f64
	<sinh+76 @05036c>   : 06 22 00 00                jz <sinh+110 @05038e>
	lib/std/math.ci:433: (26 bytes: <@050370> - <@05038a>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @050370>   : 11 04                      dup.x2 sp(4)
	<sinh+82 @050372>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+86 @050376>   : 11 06                      dup.x2 sp(6)
	<sinh+88 @050378>   : 80                         neg.f64
	<sinh+89 @050379>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<sinh+93 @05037d>   : 82                         sub.f64
	<sinh+94 @05037e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @050387>  : 84                         div.f64
	<sinh+104 @050388>  : 14 02                      set.x2 sp(2)
	<sinh+106 @05038a>  : 04 6d 00 00                jmp <sinh+215 @0503f7>
	lib/std/math.ci:436: (5 bytes: <@05038e> - <@050393>): sq: float64 := float64(x * x)
	<sinh+110 @05038e>  : 11 04                      dup.x2 sp(4)
	<sinh+112 @050390>  : 11 06                      dup.x2 sp(6)
	<sinh+114 @050392>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@050393> - <@0503c8>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @050393>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05039c>  : 11 02                      dup.x2 sp(2)
	<sinh+126 @05039e>  : 83                         mul.f64
	<sinh+127 @05039f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @0503a8>  : 81                         add.f64
	<sinh+137 @0503a9>  : 11 02                      dup.x2 sp(2)
	<sinh+139 @0503ab>  : 83                         mul.f64
	<sinh+140 @0503ac>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @0503b5>  : 81                         add.f64
	<sinh+150 @0503b6>  : 11 02                      dup.x2 sp(2)
	<sinh+152 @0503b8>  : 83                         mul.f64
	<sinh+153 @0503b9>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @0503c2>  : 81                         add.f64
	<sinh+163 @0503c3>  : 11 08                      dup.x2 sp(8)
	<sinh+165 @0503c5>  : 83                         mul.f64
	<sinh+166 @0503c6>  : 14 04                      set.x2 sp(4)
	lib/std/math.ci:438: (43 bytes: <@0503c8> - <@0503f3>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @0503c8>  : 11 02                      dup.x2 sp(2)
	<sinh+170 @0503ca>  : 11 02                      dup.x2 sp(2)
	<sinh+172 @0503cc>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @0503d5>  : 81                         add.f64
	<sinh+182 @0503d6>  : 11 04                      dup.x2 sp(4)
	<sinh+184 @0503d8>  : 83                         mul.f64
	<sinh+185 @0503d9>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @0503e2>  : 81                         add.f64
	<sinh+195 @0503e3>  : 11 04                      dup.x2 sp(4)
	<sinh+197 @0503e5>  : 83                         mul.f64
	<sinh+198 @0503e6>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @0503ef>  : 81                         add.f64
	<sinh+208 @0503f0>  : 84                         div.f64
	<sinh+209 @0503f1>  : 14 04                      set.x2 sp(4)
	<sinh+211 @0503f3>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@0503f7> - <@05040a>): if (negate)
	<sinh+215 @0503f7>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @0503fb>  : 20                         load.i8
	<sinh+220 @0503fc>  : 06 0e 00 00                jz <sinh+234 @05040a>
	lib/std/math.ci:442: (10 bytes: <@050400> - <@05040a>): return float64(.result := float64(-result));
	<sinh+224 @050400>  : 11 00                      dup.x2 sp(0)
	<sinh+226 @050402>  : 80                         neg.f64
	<sinh+227 @050403>  : 14 08                      set.x2 sp(8)
	<sinh+229 @050405>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @050409>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@05040a> - <@050411>): return float64(.result := result);
	<sinh+234 @05040a>  : 14 06                      set.x2 sp(6)
	<sinh+236 @05040c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @050410>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@050418>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@050418> - <@050463>)
	lib/std/math.ci:449: (13 bytes: <@050418> - <@050425>): if (bool(x < (0)))
	<cosh @050418>      : 11 01                      dup.x2 sp(1)
	<cosh+2 @05041a>    : 1a                         load.z64
	<cosh+3 @05041b>    : 88                         clt.f64
	<cosh+4 @05041c>    : 06 09 00 00                jz <cosh+13 @050425>
	lib/std/math.ci:450: (5 bytes: <@050420> - <@050425>): float64(x := float64(-x));
	<cosh+8 @050420>    : 11 01                      dup.x2 sp(1)
	<cosh+10 @050422>   : 80                         neg.f64
	<cosh+11 @050423>   : 14 03                      set.x2 sp(3)
	lib/std/math.ci:452: (35 bytes: <@050425> - <@050448>): if (bool(x > (21)))
	<cosh+13 @050425>   : 11 01                      dup.x2 sp(1)
	<cosh+15 @050427>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @050430>   : 89                         cgt.f64
	<cosh+25 @050431>   : 06 17 00 00                jz <cosh+48 @050448>
	lib/std/math.ci:453: (19 bytes: <@050435> - <@050448>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @050435>   : 11 01                      dup.x2 sp(1)
	<cosh+31 @050437>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+35 @05043b>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @050444>   : 84                         div.f64
	<cosh+45 @050445>   : 14 05                      set.x2 sp(5)
	<cosh+47 @050447>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@050448> - <@050463>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @050448>   : 11 01                      dup.x2 sp(1)
	<cosh+50 @05044a>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+54 @05044e>   : 11 03                      dup.x2 sp(3)
	<cosh+56 @050450>   : 80                         neg.f64
	<cosh+57 @050451>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<cosh+61 @050455>   : 81                         add.f64
	<cosh+62 @050456>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @05045f>   : 84                         div.f64
	<cosh+72 @050460>   : 14 05                      set.x2 sp(5)
	<cosh+74 @050462>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 166
.offset: <@050468>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: ' Returns the arc sine of the input
	 *  Special cases are:
	 *    Asin(0) = 0
	 *    Asin(x) = NaN if x < -1 or x > 1
	 '
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (166 bytes: <@050468> - <@05050e>)
	lib/std/math.ci:464: (12 bytes: <@050468> - <@050474>): if (bool(x == (0)))
	<asin @050468>      : 11 01                      dup.x2 sp(1)
	<asin+2 @05046a>    : 1a                         load.z64
	<asin+3 @05046b>    : 87                         ceq.f64
	<asin+4 @05046c>    : 06 08 00 00                jz <asin+12 @050474>
	lib/std/math.ci:466: (4 bytes: <@050470> - <@050474>): return float64(.result := x);
	<asin+8 @050470>    : 17 03 01                   mov.x2 sp(3, 1)
	<asin+11 @050473>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@050474> - <@050475>): negate: bool := false
	<asin+12 @050474>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@050475> - <@05048c>): if (bool(x < (0)))
	<asin+13 @050475>   : 11 02                      dup.x2 sp(2)
	<asin+15 @050477>   : 1a                         load.z64
	<asin+16 @050478>   : 88                         clt.f64
	<asin+17 @050479>   : 06 13 00 00                jz <asin+36 @05048c>
	lib/std/math.ci:471: (10 bytes: <@05047d> - <@050487>): bool(negate := true);
	<asin+21 @05047d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @050482>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @050486>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@050487> - <@05048c>): float64(x := float64(-x));
	<asin+31 @050487>   : 11 02                      dup.x2 sp(2)
	<asin+33 @050489>   : 80                         neg.f64
	<asin+34 @05048a>   : 14 04                      set.x2 sp(4)
	lib/std/math.ci:475: (25 bytes: <@05048c> - <@0504a5>): if (bool(x > (1)))
	<asin+36 @05048c>   : 11 02                      dup.x2 sp(2)
	<asin+38 @05048e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @050497>   : 89                         cgt.f64
	<asin+48 @050498>   : 06 0d 00 00                jz <asin+61 @0504a5>
	lib/std/math.ci:477: (9 bytes: <@05049c> - <@0504a5>): return float64(.result := nan);
	<asin+52 @05049c>   : 1b                         load.z128
	<asin+53 @05049d>   : 84                         div.f64
	<asin+54 @05049e>   : 14 06                      set.x2 sp(6)
	<asin+56 @0504a0>   : 09 fc ff ff                inc.sp(-4)
	<asin+60 @0504a4>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@0504a5> - <@0504b8>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+61 @0504a5>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+70 @0504ae>   : 11 04                      dup.x2 sp(4)
	<asin+72 @0504b0>   : 11 06                      dup.x2 sp(6)
	<asin+74 @0504b2>   : 83                         mul.f64
	<asin+75 @0504b3>   : 82                         sub.f64
	<asin+76 @0504b4>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@0504b8> - <@0504f4>): if (bool(x > 0.700000))
	<asin+80 @0504b8>   : 11 04                      dup.x2 sp(4)
	<asin+82 @0504ba>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+91 @0504c3>   : 89                         cgt.f64
	<asin+92 @0504c4>   : 06 26 00 00                jz <asin+130 @0504ea>
	lib/std/math.ci:482: (30 bytes: <@0504c8> - <@0504e6>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+96 @0504c8>   : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+105 @0504d1>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+114 @0504da>  : 84                         div.f64
	<asin+115 @0504db>  : 11 02                      dup.x2 sp(2)
	<asin+117 @0504dd>  : 11 08                      dup.x2 sp(8)
	<asin+119 @0504df>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+123 @0504e3>  : 82                         sub.f64
	<asin+124 @0504e4>  : 14 02                      set.x2 sp(2)
	<asin+126 @0504e6>  : 04 0e 00 00                jmp <asin+140 @0504f4>
	lib/std/math.ci:485: (10 bytes: <@0504ea> - <@0504f4>): float64(result := float64.atan2(void(x, result)));
	<asin+130 @0504ea>  : 11 04                      dup.x2 sp(4)
	<asin+132 @0504ec>  : 11 02                      dup.x2 sp(2)
	<asin+134 @0504ee>  : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+138 @0504f2>  : 14 02                      set.x2 sp(2)
	lib/std/math.ci:488: (19 bytes: <@0504f4> - <@050507>): if (negate)
	<asin+140 @0504f4>  : 0a 08 00 00                load.sp(+8)
	<asin+144 @0504f8>  : 20                         load.i8
	<asin+145 @0504f9>  : 06 0e 00 00                jz <asin+159 @050507>
	lib/std/math.ci:489: (10 bytes: <@0504fd> - <@050507>): return float64(.result := float64(-result));
	<asin+149 @0504fd>  : 11 00                      dup.x2 sp(0)
	<asin+151 @0504ff>  : 80                         neg.f64
	<asin+152 @050500>  : 14 08                      set.x2 sp(8)
	<asin+154 @050502>  : 09 f4 ff ff                inc.sp(-12)
	<asin+158 @050506>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@050507> - <@05050e>): return float64(.result := result);
	<asin+159 @050507>  : 14 06                      set.x2 sp(6)
	<asin+161 @050509>  : 09 fc ff ff                inc.sp(-4)
	<asin+165 @05050d>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Returns the arc cosine of the input
	 *  Special case is:
	 *    Acos(x) = NaN if x < -1 or x > 1
	 '
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: ' Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@019bb8>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: ' Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: ' The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: ' The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050510>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@050510> - <@050517>)
	lib/std/math.Complex.ci:25: (7 bytes: <@050510> - <@050517>): return void(.result := {...});
	<Complex @050510>      : 17 03 01                   mov.x2 sp(3, 1)
	:: (3 bytes: <@050513> - <@050516>): void(.result.im := (0))
	<Complex+3 @050513>    : 1a                         load.z64
	<Complex+4 @050514>    : 14 07                      set.x2 sp(7)
	<Complex+6 @050516>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050518>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@050518> - <@05051f>)
	lib/std/math.Complex.ci:32: (7 bytes: <@050518> - <@05051f>): return void(.result := {...});
	<Complex @050518>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@05051b> - <@05051e>): void(.result.im := im);
	<Complex+3 @05051b>    : 17 07 01                   mov.x2 sp(7, 1)
	<Complex+6 @05051e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@050520>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@050520> - <@05059b>)
	lib/std/math.Complex.ci:87: (79 bytes: <@050520> - <@05056f>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @050520>      : 1a                         load.z64
	<div+1 @050521>    : 11 03                      dup.x2 sp(3)
	<div+3 @050523>    : 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<div+8 @050528>    : 02                         call
	<div+9 @050529>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @05052d>   : 1a                         load.z64
	<div+14 @05052e>   : 11 07                      dup.x2 sp(7)
	<div+16 @050530>   : 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<div+21 @050535>   : 02                         call
	<div+22 @050536>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @05053a>   : 88                         clt.f64
	<div+27 @05053b>   : 05 34 00 00                jnz <div+79 @05056f>
	lib/std/math.Complex.ci:88: (5 bytes: <@05053f> - <@050544>): r: float64 := float64(b.im / b.re)
	<div+31 @05053f>   : 11 03                      dup.x2 sp(3)
	<div+33 @050541>   : 11 03                      dup.x2 sp(3)
	<div+35 @050543>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@050544> - <@05054c>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @050544>   : 11 03                      dup.x2 sp(3)
	<div+38 @050546>   : 11 02                      dup.x2 sp(2)
	<div+40 @050548>   : 11 09                      dup.x2 sp(9)
	<div+42 @05054a>   : 83                         mul.f64
	<div+43 @05054b>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@05054c> - <@05056b>): return void(.result := {...});
	<div+44 @05054c>   : 11 09                      dup.x2 sp(9)
	<div+46 @05054e>   : 11 04                      dup.x2 sp(4)
	<div+48 @050550>   : 11 0f                      dup.x2 sp(15)
	<div+50 @050552>   : 83                         mul.f64
	<div+51 @050553>   : 81                         add.f64
	<div+52 @050554>   : 11 02                      dup.x2 sp(2)
	<div+54 @050556>   : 84                         div.f64
	<div+55 @050557>   : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@050559> - <@050566>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @050559>   : 11 0b                      dup.x2 sp(11)
	<div+59 @05055b>   : 11 04                      dup.x2 sp(4)
	<div+61 @05055d>   : 11 0d                      dup.x2 sp(13)
	<div+63 @05055f>   : 83                         mul.f64
	<div+64 @050560>   : 82                         sub.f64
	<div+65 @050561>   : 11 02                      dup.x2 sp(2)
	<div+67 @050563>   : 84                         div.f64
	<div+68 @050564>   : 14 11                      set.x2 sp(17)
	<div+70 @050566>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @05056a>   : 03                         ret
	<div+75 @05056b>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@05056f> - <@050574>): r: float64 := float64(b.re / b.im)
	<div+79 @05056f>   : 11 01                      dup.x2 sp(1)
	<div+81 @050571>   : 11 05                      dup.x2 sp(5)
	<div+83 @050573>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@050574> - <@05057c>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @050574>   : 11 05                      dup.x2 sp(5)
	<div+86 @050576>   : 11 02                      dup.x2 sp(2)
	<div+88 @050578>   : 11 07                      dup.x2 sp(7)
	<div+90 @05057a>   : 83                         mul.f64
	<div+91 @05057b>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@05057c> - <@05059b>): return void(.result := {...});
	<div+92 @05057c>   : 11 09                      dup.x2 sp(9)
	<div+94 @05057e>   : 11 04                      dup.x2 sp(4)
	<div+96 @050580>   : 83                         mul.f64
	<div+97 @050581>   : 11 0d                      dup.x2 sp(13)
	<div+99 @050583>   : 81                         add.f64
	<div+100 @050584>  : 11 02                      dup.x2 sp(2)
	<div+102 @050586>  : 84                         div.f64
	<div+103 @050587>  : 14 0f                      set.x2 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@050589> - <@050596>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @050589>  : 11 0b                      dup.x2 sp(11)
	<div+107 @05058b>  : 11 04                      dup.x2 sp(4)
	<div+109 @05058d>  : 83                         mul.f64
	<div+110 @05058e>  : 11 0b                      dup.x2 sp(11)
	<div+112 @050590>  : 82                         sub.f64
	<div+113 @050591>  : 11 02                      dup.x2 sp(2)
	<div+115 @050593>  : 84                         div.f64
	<div+116 @050594>  : 14 11                      set.x2 sp(17)
	<div+118 @050596>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @05059a>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@0505a0>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: ' Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@0505a0> - <@0505bf>)
	lib/std/math.Complex.ci:115: (11 bytes: <@0505a0> - <@0505ab>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @0505a0>      : 11 01                      dup.x2 sp(1)
	<inv+2 @0505a2>    : 11 03                      dup.x2 sp(3)
	<inv+4 @0505a4>    : 83                         mul.f64
	<inv+5 @0505a5>    : 11 05                      dup.x2 sp(5)
	<inv+7 @0505a7>    : 11 07                      dup.x2 sp(7)
	<inv+9 @0505a9>    : 83                         mul.f64
	<inv+10 @0505aa>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@0505ab> - <@0505bf>): return void(.result := {...});
	<inv+11 @0505ab>   : 11 03                      dup.x2 sp(3)
	<inv+13 @0505ad>   : 11 02                      dup.x2 sp(2)
	<inv+15 @0505af>   : 84                         div.f64
	<inv+16 @0505b0>   : 14 09                      set.x2 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@0505b2> - <@0505ba>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @0505b2>   : 11 05                      dup.x2 sp(5)
	<inv+20 @0505b4>   : 80                         neg.f64
	<inv+21 @0505b5>   : 11 02                      dup.x2 sp(2)
	<inv+23 @0505b7>   : 84                         div.f64
	<inv+24 @0505b8>   : 14 0b                      set.x2 sp(11)
	<inv+26 @0505ba>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @0505be>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@0505c0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@0505c0> - <@050624>)
	lib/std/math.Complex.ci:133: (23 bytes: <@0505c0> - <@0505d7>): r: float64 := abs(a)
	<pow @0505c0>      : 12 05                      dup.x4 sp(5)
	<pow+2 @0505c2>    : 11 00                      dup.x2 sp(0)
	<pow+4 @0505c4>    : 11 02                      dup.x2 sp(2)
	<pow+6 @0505c6>    : 83                         mul.f64
	<pow+7 @0505c7>    : 11 04                      dup.x2 sp(4)
	<pow+9 @0505c9>    : 11 06                      dup.x2 sp(6)
	<pow+11 @0505cb>   : 83                         mul.f64
	<pow+12 @0505cc>   : 81                         add.f64
	<pow+13 @0505cd>   : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	<pow+17 @0505d1>   : 14 04                      set.x2 sp(4)
	<pow+19 @0505d3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@0505d7> - <@0505e7>): t: float64 := arg(a)
	<pow+23 @0505d7>   : 12 07                      dup.x4 sp(7)
	<pow+25 @0505d9>   : 11 00                      dup.x2 sp(0)
	<pow+27 @0505db>   : 11 04                      dup.x2 sp(4)
	<pow+29 @0505dd>   : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @0505e1>   : 14 04                      set.x2 sp(4)
	<pow+35 @0505e3>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@0505e7> - <@0505f6>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @0505e7>   : 11 05                      dup.x2 sp(5)
	<pow+41 @0505e9>   : 11 02                      dup.x2 sp(2)
	<pow+43 @0505eb>   : 83                         mul.f64
	<pow+44 @0505ec>   : 11 09                      dup.x2 sp(9)
	<pow+46 @0505ee>   : 11 06                      dup.x2 sp(6)
	<pow+48 @0505f0>   : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	<pow+52 @0505f4>   : 83                         mul.f64
	<pow+53 @0505f5>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@0505f6> - <@050609>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @0505f6>   : 11 04                      dup.x2 sp(4)
	<pow+56 @0505f8>   : 11 09                      dup.x2 sp(9)
	<pow+58 @0505fa>   : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @0505fe>   : 11 0b                      dup.x2 sp(11)
	<pow+64 @050600>   : 80                         neg.f64
	<pow+65 @050601>   : 11 06                      dup.x2 sp(6)
	<pow+67 @050603>   : 83                         mul.f64
	<pow+68 @050604>   : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	<pow+72 @050608>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@050609> - <@050624>): return void(.result := {...});
	<pow+73 @050609>   : 11 00                      dup.x2 sp(0)
	<pow+75 @05060b>   : 11 04                      dup.x2 sp(4)
	<pow+77 @05060d>   : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	<pow+81 @050611>   : 83                         mul.f64
	<pow+82 @050612>   : 14 13                      set.x2 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@050614> - <@05061f>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @050614>   : 11 00                      dup.x2 sp(0)
	<pow+86 @050616>   : 11 04                      dup.x2 sp(4)
	<pow+88 @050618>   : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	<pow+92 @05061c>   : 83                         mul.f64
	<pow+93 @05061d>   : 14 15                      set.x2 sp(21)
	<pow+95 @05061f>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @050623>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@050628>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: ' Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@050628> - <@05064e>)
	lib/std/string.ci:5: (16 bytes: <@050628> - <@050638>): if (bool((str) == null))
	<length @050628>      : 10 01                      dup.x1 sp(1)
	<length+2 @05062a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @05062f>    : 57                         ceq.i32
	<length+8 @050630>    : 06 08 00 00                jz <length+16 @050638>
	lib/std/string.ci:6: (4 bytes: <@050634> - <@050638>): return int32(.result := 0);
	<length+12 @050634>   : 19                         load.z32
	<length+13 @050635>   : 13 03                      set.x1 sp(3)
	<length+15 @050637>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@050638> - <@050639>): result: int32 := 0
	<length+16 @050638>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@050639> - <@05064b>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @050639>   : 04 08 00 00                jmp <length+25 @050641>
	lib/std/string.ci:9: (4 bytes: <@05063d> - <@050641>): int32(result := int32(result + 1))
	<length+21 @05063d>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@050641> - <@05064b>): str[result]
	<length+25 @050641>   : 10 02                      dup.x1 sp(2)
	<length+27 @050643>   : 10 01                      dup.x1 sp(1)
	<length+29 @050645>   : 51                         add.i32
	<length+30 @050646>   : 20                         load.i8
	<length+31 @050647>   : 05 f6 ff ff                jnz <length+21 @05063d>
	lib/std/string.ci:11: (3 bytes: <@05064b> - <@05064e>): return int32(.result := result);
	<length+35 @05064b>   : 13 03                      set.x1 sp(3)
	<length+37 @05064d>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050650>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@050650> - <@050682>)
	lib/std/string.ci:16: (42 bytes: <@050650> - <@05067a>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @050650>      : 19                         load.z32
	<indexOf+1 @050651>    : 04 1b 00 00                jmp <indexOf+28 @05066c>
	lib/std/string.ci:17: (19 bytes: <@050655> - <@050668>): if (bool(str[i] == chr))
	<indexOf+5 @050655>    : 10 03                      dup.x1 sp(3)
	<indexOf+7 @050657>    : 10 01                      dup.x1 sp(1)
	<indexOf+9 @050659>    : 51                         add.i32
	<indexOf+10 @05065a>   : 20                         load.i8
	<indexOf+11 @05065b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @05065f>   : 20                         load.i8
	<indexOf+16 @050660>   : 57                         ceq.i32
	<indexOf+17 @050661>   : 06 07 00 00                jz <indexOf+24 @050668>
	lib/std/string.ci:18: (3 bytes: <@050665> - <@050668>): return int32(.result := i);
	<indexOf+21 @050665>   : 13 04                      set.x1 sp(4)
	<indexOf+23 @050667>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@050668> - <@05066c>): int32(i := int32(i + 1))
	<indexOf+24 @050668>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@05066c> - <@050676>): str[i]
	<indexOf+28 @05066c>   : 10 03                      dup.x1 sp(3)
	<indexOf+30 @05066e>   : 10 01                      dup.x1 sp(1)
	<indexOf+32 @050670>   : 51                         add.i32
	<indexOf+33 @050671>   : 20                         load.i8
	<indexOf+34 @050672>   : 05 e3 ff ff                jnz <indexOf+5 @050655>
	<indexOf+38 @050676>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@05067a> - <@050682>): return int32(.result := int32(-1));
	<indexOf+42 @05067a>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @05067f>   : 13 04                      set.x1 sp(4)
	<indexOf+49 @050681>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@050688>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@050688> - <@0506ba>)
	lib/std/string.ci:26: (5 bytes: <@050688> - <@05068d>): result: int32 := int32(-1)
	<lastIndexOf @050688>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@05068d> - <@0506b7>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @05068d>    : 19                         load.z32
	<lastIndexOf+6 @05068e>    : 04 1b 00 00                jmp <lastIndexOf+33 @0506a9>
	lib/std/string.ci:28: (19 bytes: <@050692> - <@0506a5>): if (bool(str[i] == chr))
	<lastIndexOf+10 @050692>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+12 @050694>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+14 @050696>   : 51                         add.i32
	<lastIndexOf+15 @050697>   : 20                         load.i8
	<lastIndexOf+16 @050698>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @05069c>   : 20                         load.i8
	<lastIndexOf+21 @05069d>   : 57                         ceq.i32
	<lastIndexOf+22 @05069e>   : 06 07 00 00                jz <lastIndexOf+29 @0506a5>
	lib/std/string.ci:29: (3 bytes: <@0506a2> - <@0506a5>): int32(result := i);
	<lastIndexOf+26 @0506a2>   : 16 01 00                   mov.x1 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@0506a5> - <@0506a9>): int32(i := int32(i + 1))
	<lastIndexOf+29 @0506a5>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@0506a9> - <@0506b3>): str[i]
	<lastIndexOf+33 @0506a9>   : 10 04                      dup.x1 sp(4)
	<lastIndexOf+35 @0506ab>   : 10 01                      dup.x1 sp(1)
	<lastIndexOf+37 @0506ad>   : 51                         add.i32
	<lastIndexOf+38 @0506ae>   : 20                         load.i8
	<lastIndexOf+39 @0506af>   : 05 e3 ff ff                jnz <lastIndexOf+10 @050692>
	<lastIndexOf+43 @0506b3>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@0506b7> - <@0506ba>): return int32(.result := result);
	<lastIndexOf+47 @0506b7>   : 13 04                      set.x1 sp(4)
	<lastIndexOf+49 @0506b9>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@0506c0>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: ' Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@0506c0> - <@050709>)
	lib/std/string.ci:37: (62 bytes: <@0506c0> - <@0506fe>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @0506c0>      : 19                         load.z32
	<startsWith+1 @0506c1>    : 04 2d 00 00                jmp <startsWith+46 @0506ee>
	lib/std/string.ci:38: (37 bytes: <@0506c5> - <@0506ea>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @0506c5>    : 19                         load.z32
	<startsWith+6 @0506c6>    : 10 05                      dup.x1 sp(5)
	<startsWith+8 @0506c8>    : 10 02                      dup.x1 sp(2)
	<startsWith+10 @0506ca>   : 51                         add.i32
	<startsWith+11 @0506cb>   : 20                         load.i8
	<startsWith+12 @0506cc>   : 10 05                      dup.x1 sp(5)
	<startsWith+14 @0506ce>   : 10 03                      dup.x1 sp(3)
	<startsWith+16 @0506d0>   : 51                         add.i32
	<startsWith+17 @0506d1>   : 20                         load.i8
	<startsWith+18 @0506d2>   : 10 05                      dup.x1 sp(5)
	<startsWith+20 @0506d4>   : 02                         call
	<startsWith+21 @0506d5>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @0506d9>   : 19                         load.z32
	<startsWith+26 @0506da>   : 57                         ceq.i32
	<startsWith+27 @0506db>   : 05 0f 00 00                jnz <startsWith+42 @0506ea>
	lib/std/string.ci:39: (11 bytes: <@0506df> - <@0506ea>): return bool(.result := false);
	<startsWith+31 @0506df>   : 19                         load.z32
	<startsWith+32 @0506e0>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @0506e4>   : 25                         store.i8
	<startsWith+37 @0506e5>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @0506e9>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@0506ea> - <@0506ee>): int32(i := int32(i + 1))
	<startsWith+42 @0506ea>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@0506ee> - <@0506fa>): bool((with[i]) != 0)
	<startsWith+46 @0506ee>   : 10 03                      dup.x1 sp(3)
	<startsWith+48 @0506f0>   : 10 01                      dup.x1 sp(1)
	<startsWith+50 @0506f2>   : 51                         add.i32
	<startsWith+51 @0506f3>   : 20                         load.i8
	<startsWith+52 @0506f4>   : 19                         load.z32
	<startsWith+53 @0506f5>   : 57                         ceq.i32
	<startsWith+54 @0506f6>   : 06 cf ff ff                jz <startsWith+5 @0506c5>
	<startsWith+58 @0506fa>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@0506fe> - <@050709>): return bool(.result := true);
	<startsWith+62 @0506fe>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @050703>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @050707>   : 25                         store.i8
	<startsWith+72 @050708>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@050710>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: ' Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@050710> - <@05078e>)
	lib/std/string.ci:47: (13 bytes: <@050710> - <@05071d>): withLen: int32 := length(with)
	<endsWith @050710>      : 19                         load.z32
	<endsWith+1 @050711>    : 10 03                      dup.x1 sp(3)
	<endsWith+3 @050713>    : 1f 28 06 05 00             load.ref <@050628> ;length(str: char[*]): int32
	<endsWith+8 @050718>    : 02                         call
	<endsWith+9 @050719>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@05071d> - <@05072a>): strLen: int32 := length(str)
	<endsWith+13 @05071d>   : 19                         load.z32
	<endsWith+14 @05071e>   : 10 05                      dup.x1 sp(5)
	<endsWith+16 @050720>   : 1f 28 06 05 00             load.ref <@050628> ;length(str: char[*]): int32
	<endsWith+21 @050725>   : 02                         call
	<endsWith+22 @050726>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@05072a> - <@05073e>): if (bool(strLen < withLen))
	<endsWith+26 @05072a>   : 10 00                      dup.x1 sp(0)
	<endsWith+28 @05072c>   : 10 02                      dup.x1 sp(2)
	<endsWith+30 @05072e>   : 58                         clt.i32
	<endsWith+31 @05072f>   : 06 0f 00 00                jz <endsWith+46 @05073e>
	lib/std/string.ci:50: (11 bytes: <@050733> - <@05073e>): return bool(.result := false);
	<endsWith+35 @050733>   : 19                         load.z32
	<endsWith+36 @050734>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @050738>   : 25                         store.i8
	<endsWith+41 @050739>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @05073d>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@05073e> - <@05077f>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @05073e>   : 19                         load.z32
	<endsWith+47 @05073f>   : 04 33 00 00                jmp <endsWith+98 @050772>
	lib/std/string.ci:53: (43 bytes: <@050743> - <@05076e>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @050743>   : 19                         load.z32
	<endsWith+52 @050744>   : 10 07                      dup.x1 sp(7)
	<endsWith+54 @050746>   : 10 03                      dup.x1 sp(3)
	<endsWith+56 @050748>   : 10 05                      dup.x1 sp(5)
	<endsWith+58 @05074a>   : 52                         sub.i32
	<endsWith+59 @05074b>   : 10 03                      dup.x1 sp(3)
	<endsWith+61 @05074d>   : 51                         add.i32
	<endsWith+62 @05074e>   : 51                         add.i32
	<endsWith+63 @05074f>   : 20                         load.i8
	<endsWith+64 @050750>   : 10 07                      dup.x1 sp(7)
	<endsWith+66 @050752>   : 10 03                      dup.x1 sp(3)
	<endsWith+68 @050754>   : 51                         add.i32
	<endsWith+69 @050755>   : 20                         load.i8
	<endsWith+70 @050756>   : 10 07                      dup.x1 sp(7)
	<endsWith+72 @050758>   : 02                         call
	<endsWith+73 @050759>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @05075d>   : 19                         load.z32
	<endsWith+78 @05075e>   : 57                         ceq.i32
	<endsWith+79 @05075f>   : 05 0f 00 00                jnz <endsWith+94 @05076e>
	lib/std/string.ci:54: (11 bytes: <@050763> - <@05076e>): return bool(.result := false);
	<endsWith+83 @050763>   : 19                         load.z32
	<endsWith+84 @050764>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @050768>   : 25                         store.i8
	<endsWith+89 @050769>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @05076d>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@05076e> - <@050772>): int32(i := int32(i + 1))
	<endsWith+94 @05076e>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@050772> - <@05077b>): bool(i < withLen)
	<endsWith+98 @050772>   : 10 00                      dup.x1 sp(0)
	<endsWith+100 @050774>  : 10 03                      dup.x1 sp(3)
	<endsWith+102 @050776>  : 58                         clt.i32
	<endsWith+103 @050777>  : 05 cc ff ff                jnz <endsWith+51 @050743>
	<endsWith+107 @05077b>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@05077f> - <@05078e>): return bool(.result := true);
	<endsWith+111 @05077f>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @050784>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @050788>  : 25                         store.i8
	<endsWith+121 @050789>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @05078d>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@050790>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: ' Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@050790> - <@0507cf>)
	lib/std/string.ci:62: (1 byte: <@050790> - <@050791>): result: int32 := 0
	<compare @050790>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@050791> - <@0507cc>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @050791>    : 19                         load.z32
	<compare+2 @050792>    : 04 2e 00 00                jmp <compare+48 @0507c0>
	lib/std/string.ci:64: (22 bytes: <@050796> - <@0507ac>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @050796>    : 19                         load.z32
	<compare+7 @050797>    : 10 06                      dup.x1 sp(6)
	<compare+9 @050799>    : 10 02                      dup.x1 sp(2)
	<compare+11 @05079b>   : 51                         add.i32
	<compare+12 @05079c>   : 20                         load.i8
	<compare+13 @05079d>   : 10 06                      dup.x1 sp(6)
	<compare+15 @05079f>   : 10 03                      dup.x1 sp(3)
	<compare+17 @0507a1>   : 51                         add.i32
	<compare+18 @0507a2>   : 20                         load.i8
	<compare+19 @0507a3>   : 10 06                      dup.x1 sp(6)
	<compare+21 @0507a5>   : 02                         call
	<compare+22 @0507a6>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @0507aa>   : 13 02                      set.x1 sp(2)
	lib/std/string.ci:65: (16 bytes: <@0507ac> - <@0507bc>): if (bool((str[i]) == 0))
	<compare+28 @0507ac>   : 10 05                      dup.x1 sp(5)
	<compare+30 @0507ae>   : 10 01                      dup.x1 sp(1)
	<compare+32 @0507b0>   : 51                         add.i32
	<compare+33 @0507b1>   : 20                         load.i8
	<compare+34 @0507b2>   : 19                         load.z32
	<compare+35 @0507b3>   : 57                         ceq.i32
	<compare+36 @0507b4>   : 06 08 00 00                jz <compare+44 @0507bc>
	lib/std/string.ci:66: (4 bytes: <@0507b8> - <@0507bc>): break;
	<compare+40 @0507b8>   : 04 10 00 00                jmp <compare+56 @0507c8>
	lib/std/string.ci:63: (4 bytes: <@0507bc> - <@0507c0>): int32(i := int32(i + 1))
	<compare+44 @0507bc>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@0507c0> - <@0507c8>): bool(result == 0)
	<compare+48 @0507c0>   : 10 01                      dup.x1 sp(1)
	<compare+50 @0507c2>   : 19                         load.z32
	<compare+51 @0507c3>   : 57                         ceq.i32
	<compare+52 @0507c4>   : 05 d2 ff ff                jnz <compare+6 @050796>
	<compare+56 @0507c8>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@0507cc> - <@0507cf>): return int32(.result := result);
	<compare+60 @0507cc>   : 13 05                      set.x1 sp(5)
	<compare+62 @0507ce>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@050818>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@050818> - <@05083c>)
	lib/std/string.ci:84: (36 bytes: <@050818> - <@05083c>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @050818>      : 19                         load.z32
	<ignCaseCmp+1 @050819>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @05081d>    : 20                         load.i8
	<ignCaseCmp+6 @05081e>    : 1f d0 07 05 00             load.ref <@0507d0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @050823>   : 02                         call
	<ignCaseCmp+12 @050824>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @050828>   : 19                         load.z32
	<ignCaseCmp+17 @050829>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @05082d>   : 20                         load.i8
	<ignCaseCmp+22 @05082e>   : 1f d0 07 05 00             load.ref <@0507d0> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @050833>   : 02                         call
	<ignCaseCmp+28 @050834>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @050838>   : 52                         sub.i32
	<ignCaseCmp+33 @050839>   : 13 04                      set.x1 sp(4)
	<ignCaseCmp+35 @05083b>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@050840>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: ' default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@050840> - <@05084e>)
	lib/std/string.ci:89: (14 bytes: <@050840> - <@05084e>): return char(.result := char(chr - with));
	<caseCmp @050840>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @050844>    : 20                         load.i8
	<caseCmp+5 @050845>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @050849>    : 20                         load.i8
	<caseCmp+10 @05084a>   : 52                         sub.i32
	<caseCmp+11 @05084b>   : 13 04                      set.x1 sp(4)
	<caseCmp+13 @05084d>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: ' Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0225f8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: ' Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: ' radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: ' padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: ' padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: ' precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@050850>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: ' Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@050850> - <@0508a4>)
	lib/std/string.ci:127: (56 bytes: <@050850> - <@050888>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @050850>      : 19                         load.z32
	<append+1 @050851>    : 04 29 00 00                jmp <append+42 @05087a>
	lib/std/string.ci:128: (13 bytes: <@050855> - <@050862>): if (bool(pos >= (output.length)))
	<append+5 @050855>    : 10 03                      dup.x1 sp(3)
	<append+7 @050857>    : 10 06                      dup.x1 sp(6)
	<append+9 @050859>    : 58                         clt.i32
	<append+10 @05085a>   : 05 08 00 00                jnz <append+18 @050862>
	lib/std/string.ci:129: (4 bytes: <@05085e> - <@050862>): break;
	<append+14 @05085e>   : 04 26 00 00                jmp <append+52 @050884>
	lib/std/string.ci:131: (12 bytes: <@050862> - <@05086e>): char(output[pos] := value[i]);
	<append+18 @050862>   : 10 02                      dup.x1 sp(2)
	<append+20 @050864>   : 10 01                      dup.x1 sp(1)
	<append+22 @050866>   : 51                         add.i32
	<append+23 @050867>   : 20                         load.i8
	<append+24 @050868>   : 10 05                      dup.x1 sp(5)
	<append+26 @05086a>   : 10 05                      dup.x1 sp(5)
	<append+28 @05086c>   : 51                         add.i32
	<append+29 @05086d>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@05086e> - <@050876>): int32(pos := int32(pos + 1));
	<append+30 @05086e>   : 10 03                      dup.x1 sp(3)
	<append+32 @050870>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @050874>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:127: (4 bytes: <@050876> - <@05087a>): int32(i := int32(i + 1))
	<append+38 @050876>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@05087a> - <@050884>): value[i]
	<append+42 @05087a>   : 10 02                      dup.x1 sp(2)
	<append+44 @05087c>   : 10 01                      dup.x1 sp(1)
	<append+46 @05087e>   : 51                         add.i32
	<append+47 @05087f>   : 20                         load.i8
	<append+48 @050880>   : 05 d5 ff ff                jnz <append+5 @050855>
	<append+52 @050884>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@050888> - <@050899>): if (bool(pos >= (output.length)))
	<append+56 @050888>   : 10 02                      dup.x1 sp(2)
	<append+58 @05088a>   : 10 05                      dup.x1 sp(5)
	<append+60 @05088c>   : 58                         clt.i32
	<append+61 @05088d>   : 05 0c 00 00                jnz <append+73 @050899>
	lib/std/string.ci:136: (8 bytes: <@050891> - <@050899>): int32(pos := (uint32(output.length - (1))));
	<append+65 @050891>   : 10 04                      dup.x1 sp(4)
	<append+67 @050893>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @050897>   : 13 03                      set.x1 sp(3)
	lib/std/string.ci:138: (7 bytes: <@050899> - <@0508a0>): char(output[pos] := (0));
	<append+73 @050899>   : 19                         load.z32
	<append+74 @05089a>   : 10 04                      dup.x1 sp(4)
	<append+76 @05089c>   : 10 04                      dup.x1 sp(4)
	<append+78 @05089e>   : 51                         add.i32
	<append+79 @05089f>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@0508a0> - <@0508a4>): return int32(.result := pos);
	<append+80 @0508a0>   : 16 05 02                   mov.x1 sp(5, 2)
	<append+83 @0508a3>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@0508b8>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@0508b8> - <@050b49>)
	lib/std/string.ci:147: (1 byte: <@0508b8> - <@0508b9>): len: int32 := 0
	<append @0508b8>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@0508b9> - <@0508bd>): digits: char[80]
	<append+1 @0508b9>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@0508bd> - <@0508c0>): radix: int32 := format.radix
	<append+5 @0508bd>    : 10 16                      dup.x1 sp(22)
	<append+7 @0508bf>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@0508c0> - <@0508f6>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @0508c0>    : 10 00                      dup.x1 sp(0)
	<append+10 @0508c2>   : 1c 01 00 00 00             load.c32 1
	<append+15 @0508c7>   : 59                         cgt.i32
	<append+16 @0508c8>   : 06 08 00 00                jz <append+24 @0508d0>
	<append+20 @0508cc>   : 04 2a 00 00                jmp <append+62 @0508f6>
	<append+24 @0508d0>   : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+29 @0508d5>   : 1c 97 00 00 00             load.c32 151
	<append+34 @0508da>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @0508df>   : 1c 80 00 00 00             load.c32 128
	<append+44 @0508e4>   : 1f 53 f1 01 00             load.ref <@01f153> ;"radix is too small"
	<append+49 @0508e9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @0508ee>   : 0a 18 00 00                load.sp(+24)
	<append+58 @0508f2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@0508f6> - <@05092b>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @0508f6>   : 10 00                      dup.x1 sp(0)
	<append+64 @0508f8>   : 2a b4 08 05                load.m32 <@0508b4> ;append.radixDigits+4
	<append+68 @0508fc>   : 58                         clt.i32
	<append+69 @0508fd>   : 06 08 00 00                jz <append+77 @050905>
	<append+73 @050901>   : 04 2a 00 00                jmp <append+115 @05092b>
	<append+77 @050905>   : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+82 @05090a>   : 1c 98 00 00 00             load.c32 152
	<append+87 @05090f>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @050914>   : 1c 80 00 00 00             load.c32 128
	<append+97 @050919>   : 1f 66 f1 01 00             load.ref <@01f166> ;"radix is too big"
	<append+102 @05091e>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @050923>  : 0a 18 00 00                load.sp(+24)
	<append+111 @050927>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@05092b> - <@050959>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @05092b>  : 04 26 00 00                jmp <append+153 @050951>
	lib/std/string.ci:156: (27 bytes: <@05092f> - <@05094a>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @05092f>  : 2a b0 08 05                load.m32 <@0508b0> ;append.radixDigits
	<append+123 @050933>  : 10 19                      dup.x1 sp(25)
	<append+125 @050935>  : 10 02                      dup.x1 sp(2)
	<append+127 @050937>  : 35                         mod.u32
	<append+128 @050938>  : 51                         add.i32
	<append+129 @050939>  : 20                         load.i8
	<append+130 @05093a>  : 0a 08 00 00                load.sp(+8)
	<append+134 @05093e>  : 10 17                      dup.x1 sp(23)
	<append+136 @050940>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @050944>  : 10 00                      dup.x1 sp(0)
	<append+142 @050946>  : 13 19                      set.x1 sp(25)
	<append+144 @050948>  : 51                         add.i32
	<append+145 @050949>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@05094a> - <@050951>): uint32(value := uint32(value / (radix)))
	<append+146 @05094a>  : 10 18                      dup.x1 sp(24)
	<append+148 @05094c>  : 10 01                      dup.x1 sp(1)
	<append+150 @05094e>  : 34                         div.u32
	<append+151 @05094f>  : 13 19                      set.x1 sp(25)
	lib/std/string.ci:155: (8 bytes: <@050951> - <@050959>): bool(value > (0))
	<append+153 @050951>  : 10 18                      dup.x1 sp(24)
	<append+155 @050953>  : 19                         load.z32
	<append+156 @050954>  : 39                         cgt.u32
	<append+157 @050955>  : 05 da ff ff                jnz <append+119 @05092f>
	lib/std/string.ci:158: (29 bytes: <@050959> - <@050976>): if (bool(len == 0))
	<append+161 @050959>  : 10 15                      dup.x1 sp(21)
	<append+163 @05095b>  : 19                         load.z32
	<append+164 @05095c>  : 57                         ceq.i32
	<append+165 @05095d>  : 06 19 00 00                jz <append+190 @050976>
	lib/std/string.ci:159: (21 bytes: <@050961> - <@050976>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @050961>  : 1c 30 00 00 00             load.c32 48
	<append+174 @050966>  : 0a 08 00 00                load.sp(+8)
	<append+178 @05096a>  : 10 17                      dup.x1 sp(23)
	<append+180 @05096c>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @050970>  : 10 00                      dup.x1 sp(0)
	<append+186 @050972>  : 13 19                      set.x1 sp(25)
	<append+188 @050974>  : 51                         add.i32
	<append+189 @050975>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@050976> - <@050980>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @050976>  : 10 17                      dup.x1 sp(23)
	<append+192 @050978>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @05097c>  : 22                         load.i32
	<append+197 @05097d>  : 10 16                      dup.x1 sp(22)
	<append+199 @05097f>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@050980> - <@050987>): padChr: char := format.padChr
	<append+200 @050980>  : 10 18                      dup.x1 sp(24)
	<append+202 @050982>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @050986>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@050987> - <@05099c>): if (bool(padChr == ''))
	<append+207 @050987>  : 0a 00 00 00                load.sp(+0)
	<append+211 @05098b>  : 20                         load.i8
	<append+212 @05098c>  : 19                         load.z32
	<append+213 @05098d>  : 57                         ceq.i32
	<append+214 @05098e>  : 06 0e 00 00                jz <append+228 @05099c>
	lib/std/string.ci:166: (10 bytes: <@050992> - <@05099c>): char(padChr := ' ');
	<append+218 @050992>  : 1c 20 00 00 00             load.c32 32
	<append+223 @050997>  : 0a 04 00 00                load.sp(+4)
	<append+227 @05099b>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@05099c> - <@050a6b>): if (bool((sign) != 0))
	<append+228 @05099c>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @0509a0>  : 20                         load.i8
	<append+233 @0509a1>  : 19                         load.z32
	<append+234 @0509a2>  : 57                         ceq.i32
	<append+235 @0509a3>  : 05 c8 00 00                jnz <append+435 @050a6b>
	lib/std/string.ci:171: (8 bytes: <@0509a7> - <@0509af>): int32(maxLen := int32(maxLen - 1));
	<append+239 @0509a7>  : 10 01                      dup.x1 sp(1)
	<append+241 @0509a9>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @0509ad>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:172: (117 bytes: <@0509af> - <@050a24>): if (contains(void(whiteSpace, padChr)))
	<append+247 @0509af>  : 19                         load.z32
	<append+248 @0509b0>  : 2a a8 08 05                load.m32 <@0508a8> ;append.whiteSpace
	<append+252 @0509b4>  : 0a 08 00 00                load.sp(+8)
	<append+256 @0509b8>  : 20                         load.i8
	<append+257 @0509b9>  : 1f 50 06 05 00             load.ref <@050650> ;indexOf(str: char[*], chr: char): int32
	<append+262 @0509be>  : 02                         call
	<append+263 @0509bf>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @0509c3>  : 19                         load.z32
	<append+268 @0509c4>  : 58                         clt.i32
	<append+269 @0509c5>  : 05 5f 00 00                jnz <append+364 @050a24>
	lib/std/string.ci:174: (91 bytes: <@0509c9> - <@050a24>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @0509c9>  : 04 53 00 00                jmp <append+356 @050a1c>
	lib/std/string.ci:175: (52 bytes: <@0509cd> - <@050a01>): assert(bool(pos < (output.length)));
	<append+277 @0509cd>  : 10 1c                      dup.x1 sp(28)
	<append+279 @0509cf>  : 10 1f                      dup.x1 sp(31)
	<append+281 @0509d1>  : 58                         clt.i32
	<append+282 @0509d2>  : 06 08 00 00                jz <append+290 @0509da>
	<append+286 @0509d6>  : 04 2b 00 00                jmp <append+329 @050a01>
	<append+290 @0509da>  : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+295 @0509df>  : 1c af 00 00 00             load.c32 175
	<append+300 @0509e4>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @0509e9>  : 1c 80 00 00 00             load.c32 128
	<append+310 @0509ee>  : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<append+315 @0509f3>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @0509f8>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @0509fd>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@050a01> - <@050a0c>): char(output[pos] := padChr);
	<append+329 @050a01>  : 0a 00 00 00                load.sp(+0)
	<append+333 @050a05>  : 20                         load.i8
	<append+334 @050a06>  : 10 1e                      dup.x1 sp(30)
	<append+336 @050a08>  : 10 1e                      dup.x1 sp(30)
	<append+338 @050a0a>  : 51                         add.i32
	<append+339 @050a0b>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@050a0c> - <@050a14>): int32(pos := int32(pos + 1));
	<append+340 @050a0c>  : 10 1c                      dup.x1 sp(28)
	<append+342 @050a0e>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @050a12>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:174: (8 bytes: <@050a14> - <@050a1c>): int32(maxLen := int32(maxLen - 1))
	<append+348 @050a14>  : 10 01                      dup.x1 sp(1)
	<append+350 @050a16>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @050a1a>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:174: (8 bytes: <@050a1c> - <@050a24>): bool(maxLen > 0)
	<append+356 @050a1c>  : 10 01                      dup.x1 sp(1)
	<append+358 @050a1e>  : 19                         load.z32
	<append+359 @050a1f>  : 59                         cgt.i32
	<append+360 @050a20>  : 05 ad ff ff                jnz <append+277 @0509cd>
	lib/std/string.ci:180: (52 bytes: <@050a24> - <@050a58>): assert(bool(pos < (output.length)));
	<append+364 @050a24>  : 10 1c                      dup.x1 sp(28)
	<append+366 @050a26>  : 10 1f                      dup.x1 sp(31)
	<append+368 @050a28>  : 58                         clt.i32
	<append+369 @050a29>  : 06 08 00 00                jz <append+377 @050a31>
	<append+373 @050a2d>  : 04 2b 00 00                jmp <append+416 @050a58>
	<append+377 @050a31>  : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+382 @050a36>  : 1c b4 00 00 00             load.c32 180
	<append+387 @050a3b>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @050a40>  : 1c 80 00 00 00             load.c32 128
	<append+397 @050a45>  : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<append+402 @050a4a>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @050a4f>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @050a54>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@050a58> - <@050a63>): char(output[pos] := sign);
	<append+416 @050a58>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @050a5c>  : 20                         load.i8
	<append+421 @050a5d>  : 10 1e                      dup.x1 sp(30)
	<append+423 @050a5f>  : 10 1e                      dup.x1 sp(30)
	<append+425 @050a61>  : 51                         add.i32
	<append+426 @050a62>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@050a63> - <@050a6b>): int32(pos := int32(pos + 1));
	<append+427 @050a63>  : 10 1c                      dup.x1 sp(28)
	<append+429 @050a65>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @050a69>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (91 bytes: <@050a6b> - <@050ac6>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @050a6b>  : 04 53 00 00                jmp <append+518 @050abe>
	lib/std/string.ci:187: (52 bytes: <@050a6f> - <@050aa3>): assert(bool(pos < (output.length)));
	<append+439 @050a6f>  : 10 1c                      dup.x1 sp(28)
	<append+441 @050a71>  : 10 1f                      dup.x1 sp(31)
	<append+443 @050a73>  : 58                         clt.i32
	<append+444 @050a74>  : 06 08 00 00                jz <append+452 @050a7c>
	<append+448 @050a78>  : 04 2b 00 00                jmp <append+491 @050aa3>
	<append+452 @050a7c>  : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+457 @050a81>  : 1c bb 00 00 00             load.c32 187
	<append+462 @050a86>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @050a8b>  : 1c 80 00 00 00             load.c32 128
	<append+472 @050a90>  : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<append+477 @050a95>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @050a9a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @050a9f>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@050aa3> - <@050aae>): char(output[pos] := padChr);
	<append+491 @050aa3>  : 0a 00 00 00                load.sp(+0)
	<append+495 @050aa7>  : 20                         load.i8
	<append+496 @050aa8>  : 10 1e                      dup.x1 sp(30)
	<append+498 @050aaa>  : 10 1e                      dup.x1 sp(30)
	<append+500 @050aac>  : 51                         add.i32
	<append+501 @050aad>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@050aae> - <@050ab6>): int32(pos := int32(pos + 1));
	<append+502 @050aae>  : 10 1c                      dup.x1 sp(28)
	<append+504 @050ab0>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @050ab4>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:186: (8 bytes: <@050ab6> - <@050abe>): int32(maxLen := int32(maxLen - 1))
	<append+510 @050ab6>  : 10 01                      dup.x1 sp(1)
	<append+512 @050ab8>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @050abc>  : 13 02                      set.x1 sp(2)
	lib/std/string.ci:186: (8 bytes: <@050abe> - <@050ac6>): bool(maxLen > 0)
	<append+518 @050abe>  : 10 01                      dup.x1 sp(1)
	<append+520 @050ac0>  : 19                         load.z32
	<append+521 @050ac1>  : 59                         cgt.i32
	<append+522 @050ac2>  : 05 ad ff ff                jnz <append+439 @050a6f>
	lib/std/string.ci:193: (99 bytes: <@050ac6> - <@050b29>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @050ac6>  : 19                         load.z32
	<append+527 @050ac7>  : 04 55 00 00                jmp <append+612 @050b1c>
	lib/std/string.ci:194: (52 bytes: <@050acb> - <@050aff>): assert(bool(i < (output.length)));
	<append+531 @050acb>  : 10 00                      dup.x1 sp(0)
	<append+533 @050acd>  : 10 20                      dup.x1 sp(32)
	<append+535 @050acf>  : 58                         clt.i32
	<append+536 @050ad0>  : 06 08 00 00                jz <append+544 @050ad8>
	<append+540 @050ad4>  : 04 2b 00 00                jmp <append+583 @050aff>
	<append+544 @050ad8>  : 1f a8 ed 01 00             load.ref <@01eda8> ;"lib/std/string.ci"
	<append+549 @050add>  : 1c c2 00 00 00             load.c32 194
	<append+554 @050ae2>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @050ae7>  : 1c 80 00 00 00             load.c32 128
	<append+564 @050aec>  : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<append+569 @050af1>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @050af6>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @050afb>  : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@050aff> - <@050b10>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @050aff>  : 0a 10 00 00                load.sp(+16)
	<append+587 @050b03>  : 10 19                      dup.x1 sp(25)
	<append+589 @050b05>  : 10 02                      dup.x1 sp(2)
	<append+591 @050b07>  : 52                         sub.i32
	<append+592 @050b08>  : 51                         add.i32
	<append+593 @050b09>  : 20                         load.i8
	<append+594 @050b0a>  : 10 1f                      dup.x1 sp(31)
	<append+596 @050b0c>  : 10 1f                      dup.x1 sp(31)
	<append+598 @050b0e>  : 51                         add.i32
	<append+599 @050b0f>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@050b10> - <@050b18>): int32(pos := int32(pos + 1));
	<append+600 @050b10>  : 10 1d                      dup.x1 sp(29)
	<append+602 @050b12>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @050b16>  : 13 1e                      set.x1 sp(30)
	lib/std/string.ci:193: (4 bytes: <@050b18> - <@050b1c>): int32(i := int32(i + 1))
	<append+608 @050b18>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@050b1c> - <@050b25>): bool(i < len)
	<append+612 @050b1c>  : 10 00                      dup.x1 sp(0)
	<append+614 @050b1e>  : 10 19                      dup.x1 sp(25)
	<append+616 @050b20>  : 58                         clt.i32
	<append+617 @050b21>  : 05 aa ff ff                jnz <append+531 @050acb>
	<append+621 @050b25>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@050b29> - <@050b3a>): if (bool(pos >= (output.length)))
	<append+625 @050b29>  : 10 1c                      dup.x1 sp(28)
	<append+627 @050b2b>  : 10 1f                      dup.x1 sp(31)
	<append+629 @050b2d>  : 58                         clt.i32
	<append+630 @050b2e>  : 05 0c 00 00                jnz <append+642 @050b3a>
	lib/std/string.ci:200: (8 bytes: <@050b32> - <@050b3a>): int32(pos := (uint32(output.length - (1))));
	<append+634 @050b32>  : 10 1e                      dup.x1 sp(30)
	<append+636 @050b34>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @050b38>  : 13 1d                      set.x1 sp(29)
	lib/std/string.ci:202: (7 bytes: <@050b3a> - <@050b41>): char(output[pos] := (0));
	<append+642 @050b3a>  : 19                         load.z32
	<append+643 @050b3b>  : 10 1e                      dup.x1 sp(30)
	<append+645 @050b3d>  : 10 1e                      dup.x1 sp(30)
	<append+647 @050b3f>  : 51                         add.i32
	<append+648 @050b40>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@050b41> - <@050b49>): return int32(.result := pos);
	<append+649 @050b41>  : 16 1f 1c                   mov.x1 sp(31, 28)
	<append+652 @050b44>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @050b48>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@050b50>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: ' Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@050b50> - <@050b67>)
	lib/std/string.ci:208: (23 bytes: <@050b50> - <@050b67>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @050b50>      : 19                         load.z32
	<append+1 @050b51>    : 11 05                      dup.x2 sp(5)
	<append+3 @050b53>    : 10 06                      dup.x1 sp(6)
	<append+5 @050b55>    : 19                         load.z32
	<append+6 @050b56>    : 10 07                      dup.x1 sp(7)
	<append+8 @050b58>    : 10 07                      dup.x1 sp(7)
	<append+10 @050b5a>   : 1f b8 08 05 00             load.ref <@0508b8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @050b5f>   : 02                         call
	<append+16 @050b60>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @050b64>   : 13 07                      set.x1 sp(7)
	<append+22 @050b66>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@050b68>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: ' Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@050b68> - <@050b99>)
	lib/std/string.ci:213: (1 byte: <@050b68> - <@050b69>): sign: int32 := 0
	<append @050b68>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@050b69> - <@050b7d>): if (bool(value < 0))
	<append+1 @050b69>    : 10 03                      dup.x1 sp(3)
	<append+3 @050b6b>    : 19                         load.z32
	<append+4 @050b6c>    : 58                         clt.i32
	<append+5 @050b6d>    : 06 10 00 00                jz <append+21 @050b7d>
	lib/std/string.ci:215: (7 bytes: <@050b71> - <@050b78>): int32(sign := ('-'));
	<append+9 @050b71>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @050b76>   : 13 01                      set.x1 sp(1)
	lib/std/string.ci:216: (5 bytes: <@050b78> - <@050b7d>): int32(value := int32(-value));
	<append+16 @050b78>   : 10 03                      dup.x1 sp(3)
	<append+18 @050b7a>   : 50                         neg.i32
	<append+19 @050b7b>   : 13 04                      set.x1 sp(4)
	lib/std/string.ci:218: (28 bytes: <@050b7d> - <@050b99>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @050b7d>   : 19                         load.z32
	<append+22 @050b7e>   : 11 06                      dup.x2 sp(6)
	<append+24 @050b80>   : 10 07                      dup.x1 sp(7)
	<append+26 @050b82>   : 10 04                      dup.x1 sp(4)
	<append+28 @050b84>   : 10 08                      dup.x1 sp(8)
	<append+30 @050b86>   : 10 08                      dup.x1 sp(8)
	<append+32 @050b88>   : 1f b8 08 05 00             load.ref <@0508b8> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @050b8d>   : 02                         call
	<append+38 @050b8e>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @050b92>   : 13 08                      set.x1 sp(8)
	<append+44 @050b94>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @050b98>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@050bb0>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: ' Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@050bb0> - <@050bc9>)
	lib/std/string.ci:224: (25 bytes: <@050bb0> - <@050bc9>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @050bb0>      : 19                         load.z32
	<append+1 @050bb1>    : 11 04                      dup.x2 sp(4)
	<append+3 @050bb3>    : 10 05                      dup.x1 sp(5)
	<append+5 @050bb5>    : 10 05                      dup.x1 sp(5)
	<append+7 @050bb7>    : 1f a0 0b 05 00             load.ref <@050ba0> ;append.format
	<append+12 @050bbc>   : 1f 50 0b 05 00             load.ref <@050b50> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @050bc1>   : 02                         call
	<append+18 @050bc2>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @050bc6>   : 13 06                      set.x1 sp(6)
	<append+24 @050bc8>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024790>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: ' A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: ' Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: ' X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: ' Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: ' X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: ' Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050bd0>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: ' Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@050bd0> - <@050bd7>)
	lib/vec/vec2d.ci:17: (7 bytes: <@050bd0> - <@050bd7>): return void(.result := {...});
	<vec2d @050bd0>      : 17 05 03                   mov.x2 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@050bd3> - <@050bd6>): void(.result.y := y);
	<vec2d+3 @050bd3>    : 17 07 01                   mov.x2 sp(7, 1)
	<vec2d+6 @050bd6>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: ' Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@025758>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: ' A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: ' Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: ' X component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: ' Y component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: ' Z component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: ' W component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: ' X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: ' Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: ' Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: ' W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@050bd8>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: ' Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@050bd8> - <@050be5>)
	lib/vec/vec4f.ci:29: (13 bytes: <@050bd8> - <@050be5>): return void(.result := {...});
	<vec4f @050bd8>      : 16 05 04                   mov.x1 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@050bdb> - <@050bde>): void(.result.y := y);
	<vec4f+3 @050bdb>    : 16 06 03                   mov.x1 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@050bde> - <@050be1>): void(.result.z := z);
	<vec4f+6 @050bde>    : 16 07 02                   mov.x1 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@050be1> - <@050be4>): void(.result.w := w);
	<vec4f+9 @050be1>    : 16 08 01                   mov.x1 sp(8, 1)
	<vec4f+12 @050be4>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: ' Initialize with given x, y, z components, and w with 0'
.value: vec4f(void(void(void(x, y), z), 0.000000))
.usages:
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: ' Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: ' Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: ' Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Homogeneous dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: ' Dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: ' Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: ' Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: ' Normalize the vector(xyz)'
.value: div(void(v, vec4f(len(v))))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: ' Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@028b40>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.doc: ' A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: ' Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: ' Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: ' Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@050be8>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: ' Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@050be8> - <@050c19>)
	lib/vec/mat4f.ci:31: (49 bytes: <@050be8> - <@050c19>): return void(.result := {...});
	<mat4f @050be8>      : 16 11 10                   mov.x1 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes: <@050beb> - <@050bee>): void(.result.x.y := xy);
	<mat4f+3 @050beb>    : 16 12 0f                   mov.x1 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes: <@050bee> - <@050bf1>): void(.result.x.z := xz);
	<mat4f+6 @050bee>    : 16 13 0e                   mov.x1 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes: <@050bf1> - <@050bf4>): void(.result.x.w := xw);
	<mat4f+9 @050bf1>    : 16 14 0d                   mov.x1 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes: <@050bf4> - <@050bf7>): void(.result.y.x := yx);
	<mat4f+12 @050bf4>   : 16 15 0c                   mov.x1 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes: <@050bf7> - <@050bfa>): void(.result.y.y := yy);
	<mat4f+15 @050bf7>   : 16 16 0b                   mov.x1 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes: <@050bfa> - <@050bfd>): void(.result.y.z := yz);
	<mat4f+18 @050bfa>   : 16 17 0a                   mov.x1 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes: <@050bfd> - <@050c00>): void(.result.y.w := yw);
	<mat4f+21 @050bfd>   : 16 18 09                   mov.x1 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes: <@050c00> - <@050c03>): void(.result.z.x := zx);
	<mat4f+24 @050c00>   : 16 19 08                   mov.x1 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes: <@050c03> - <@050c06>): void(.result.z.y := zy);
	<mat4f+27 @050c03>   : 16 1a 07                   mov.x1 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes: <@050c06> - <@050c09>): void(.result.z.z := zz);
	<mat4f+30 @050c06>   : 16 1b 06                   mov.x1 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes: <@050c09> - <@050c0c>): void(.result.z.w := zw);
	<mat4f+33 @050c09>   : 16 1c 05                   mov.x1 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes: <@050c0c> - <@050c0f>): void(.result.w.x := wx);
	<mat4f+36 @050c0c>   : 16 1d 04                   mov.x1 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes: <@050c0f> - <@050c12>): void(.result.w.y := wy);
	<mat4f+39 @050c0f>   : 16 1e 03                   mov.x1 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes: <@050c12> - <@050c15>): void(.result.w.z := wz);
	<mat4f+42 @050c12>   : 16 1f 02                   mov.x1 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes: <@050c15> - <@050c18>): void(.result.w.w := ww);
	<mat4f+45 @050c15>   : 16 20 01                   mov.x1 sp(32, 1)
	<mat4f+48 @050c18>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@050c20>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: ' Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@050c20> - <@050c35>)
	lib/vec/mat4f.ci:41: (21 bytes: <@050c20> - <@050c35>): return void(.result := {...});
	<mat4f @050c20>      : 10 04                      dup.x1 sp(4)
	<mat4f+2 @050c22>    : 24                         load.i128
	<mat4f+3 @050c23>    : 15 09                      set.x4 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes: <@050c25> - <@050c2a>): void(.result.y := y);
	<mat4f+5 @050c25>    : 10 03                      dup.x1 sp(3)
	<mat4f+7 @050c27>    : 24                         load.i128
	<mat4f+8 @050c28>    : 15 0d                      set.x4 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes: <@050c2a> - <@050c2f>): void(.result.z := z);
	<mat4f+10 @050c2a>   : 10 02                      dup.x1 sp(2)
	<mat4f+12 @050c2c>   : 24                         load.i128
	<mat4f+13 @050c2d>   : 15 11                      set.x4 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes: <@050c2f> - <@050c34>): void(.result.w := w);
	<mat4f+15 @050c2f>   : 10 01                      dup.x1 sp(1)
	<mat4f+17 @050c31>   : 24                         load.i128
	<mat4f+18 @050c32>   : 15 15                      set.x4 sp(21)
	<mat4f+20 @050c34>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: ' Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: ' Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: ' Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@050c38>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: ' Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@050c38> - <@050dd9>)
	lib/vec/mat4f.ci:53: (144 bytes: <@050c38> - <@050cc8>): transposed: mat4f := {...}
	<mul @050c38>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes: <@050c3c> - <@050c41>): void(transposed.x.x := rhs.x.x);
	<mul+4 @050c3c>    : 10 11                      dup.x1 sp(17)
	<mul+6 @050c3e>    : 22                         load.i32
	<mul+7 @050c3f>    : 13 01                      set.x1 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes: <@050c41> - <@050c4a>): void(transposed.x.y := rhs.y.x);
	<mul+9 @050c41>    : 10 11                      dup.x1 sp(17)
	<mul+11 @050c43>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @050c47>   : 22                         load.i32
	<mul+16 @050c48>   : 13 02                      set.x1 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes: <@050c4a> - <@050c53>): void(transposed.x.z := rhs.z.x);
	<mul+18 @050c4a>   : 10 11                      dup.x1 sp(17)
	<mul+20 @050c4c>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @050c50>   : 22                         load.i32
	<mul+25 @050c51>   : 13 03                      set.x1 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes: <@050c53> - <@050c5c>): void(transposed.x.w := rhs.w.x);
	<mul+27 @050c53>   : 10 11                      dup.x1 sp(17)
	<mul+29 @050c55>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @050c59>   : 22                         load.i32
	<mul+34 @050c5a>   : 13 04                      set.x1 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes: <@050c5c> - <@050c65>): void(transposed.y.x := rhs.x.y);
	<mul+36 @050c5c>   : 10 11                      dup.x1 sp(17)
	<mul+38 @050c5e>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @050c62>   : 22                         load.i32
	<mul+43 @050c63>   : 13 05                      set.x1 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes: <@050c65> - <@050c6e>): void(transposed.y.y := rhs.y.y);
	<mul+45 @050c65>   : 10 11                      dup.x1 sp(17)
	<mul+47 @050c67>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @050c6b>   : 22                         load.i32
	<mul+52 @050c6c>   : 13 06                      set.x1 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes: <@050c6e> - <@050c77>): void(transposed.y.z := rhs.z.y);
	<mul+54 @050c6e>   : 10 11                      dup.x1 sp(17)
	<mul+56 @050c70>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @050c74>   : 22                         load.i32
	<mul+61 @050c75>   : 13 07                      set.x1 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes: <@050c77> - <@050c80>): void(transposed.y.w := rhs.w.y);
	<mul+63 @050c77>   : 10 11                      dup.x1 sp(17)
	<mul+65 @050c79>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @050c7d>   : 22                         load.i32
	<mul+70 @050c7e>   : 13 08                      set.x1 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c80> - <@050c89>): void(transposed.z.x := rhs.x.z);
	<mul+72 @050c80>   : 10 11                      dup.x1 sp(17)
	<mul+74 @050c82>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @050c86>   : 22                         load.i32
	<mul+79 @050c87>   : 13 09                      set.x1 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c89> - <@050c92>): void(transposed.z.y := rhs.y.z);
	<mul+81 @050c89>   : 10 11                      dup.x1 sp(17)
	<mul+83 @050c8b>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @050c8f>   : 22                         load.i32
	<mul+88 @050c90>   : 13 0a                      set.x1 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c92> - <@050c9b>): void(transposed.z.z := rhs.z.z);
	<mul+90 @050c92>   : 10 11                      dup.x1 sp(17)
	<mul+92 @050c94>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @050c98>   : 22                         load.i32
	<mul+97 @050c99>   : 13 0b                      set.x1 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes: <@050c9b> - <@050ca4>): void(transposed.z.w := rhs.w.z);
	<mul+99 @050c9b>   : 10 11                      dup.x1 sp(17)
	<mul+101 @050c9d>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @050ca1>  : 22                         load.i32
	<mul+106 @050ca2>  : 13 0c                      set.x1 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes: <@050ca4> - <@050cad>): void(transposed.w.x := rhs.x.w);
	<mul+108 @050ca4>  : 10 11                      dup.x1 sp(17)
	<mul+110 @050ca6>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @050caa>  : 22                         load.i32
	<mul+115 @050cab>  : 13 0d                      set.x1 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes: <@050cad> - <@050cb6>): void(transposed.w.y := rhs.y.w);
	<mul+117 @050cad>  : 10 11                      dup.x1 sp(17)
	<mul+119 @050caf>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @050cb3>  : 22                         load.i32
	<mul+124 @050cb4>  : 13 0e                      set.x1 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes: <@050cb6> - <@050cbf>): void(transposed.w.z := rhs.z.w);
	<mul+126 @050cb6>  : 10 11                      dup.x1 sp(17)
	<mul+128 @050cb8>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @050cbc>  : 22                         load.i32
	<mul+133 @050cbd>  : 13 0f                      set.x1 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes: <@050cbf> - <@050cc8>): void(transposed.w.w := rhs.w.w);
	<mul+135 @050cbf>  : 10 11                      dup.x1 sp(17)
	<mul+137 @050cc1>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @050cc5>  : 22                         load.i32
	<mul+142 @050cc6>  : 13 10                      set.x1 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes: <@050cc8> - <@050dd9>): return void(.result := {...});
	<mul+144 @050cc8>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @050ccc>  : 10 13                      dup.x1 sp(19)
	<mul+150 @050cce>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @050cd2>  : 10 04                      dup.x1 sp(4)
	<mul+156 @050cd4>  : 24                         load.i128
	<mul+157 @050cd5>  : 10 09                      dup.x1 sp(9)
	<mul+159 @050cd7>  : 24                         load.i128
	<mul+160 @050cd8>  : 9b                         dp4.v4f
	<mul+161 @050cd9>  : 10 05                      dup.x1 sp(5)
	<mul+163 @050cdb>  : 24                         load.i128
	<mul+164 @050cdc>  : 10 0a                      dup.x1 sp(10)
	<mul+166 @050cde>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @050ce2>  : 24                         load.i128
	<mul+171 @050ce3>  : 9b                         dp4.v4f
	<mul+172 @050ce4>  : 10 06                      dup.x1 sp(6)
	<mul+174 @050ce6>  : 24                         load.i128
	<mul+175 @050ce7>  : 10 0b                      dup.x1 sp(11)
	<mul+177 @050ce9>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @050ced>  : 24                         load.i128
	<mul+182 @050cee>  : 9b                         dp4.v4f
	<mul+183 @050cef>  : 10 07                      dup.x1 sp(7)
	<mul+185 @050cf1>  : 24                         load.i128
	<mul+186 @050cf2>  : 10 0c                      dup.x1 sp(12)
	<mul+188 @050cf4>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @050cf8>  : 24                         load.i128
	<mul+193 @050cf9>  : 9b                         dp4.v4f
	<mul+194 @050cfa>  : 1f d8 0b 05 00             load.ref <@050bd8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @050cff>  : 02                         call
	<mul+200 @050d00>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @050d04>  : 15 02                      set.x4 sp(2)
	<mul+206 @050d06>  : 15 17                      set.x4 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes: <@050d08> - <@050d4c>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @050d08>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @050d0c>  : 10 13                      dup.x1 sp(19)
	<mul+214 @050d0e>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @050d12>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @050d16>  : 10 04                      dup.x1 sp(4)
	<mul+224 @050d18>  : 24                         load.i128
	<mul+225 @050d19>  : 10 09                      dup.x1 sp(9)
	<mul+227 @050d1b>  : 24                         load.i128
	<mul+228 @050d1c>  : 9b                         dp4.v4f
	<mul+229 @050d1d>  : 10 05                      dup.x1 sp(5)
	<mul+231 @050d1f>  : 24                         load.i128
	<mul+232 @050d20>  : 10 0a                      dup.x1 sp(10)
	<mul+234 @050d22>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @050d26>  : 24                         load.i128
	<mul+239 @050d27>  : 9b                         dp4.v4f
	<mul+240 @050d28>  : 10 06                      dup.x1 sp(6)
	<mul+242 @050d2a>  : 24                         load.i128
	<mul+243 @050d2b>  : 10 0b                      dup.x1 sp(11)
	<mul+245 @050d2d>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @050d31>  : 24                         load.i128
	<mul+250 @050d32>  : 9b                         dp4.v4f
	<mul+251 @050d33>  : 10 07                      dup.x1 sp(7)
	<mul+253 @050d35>  : 24                         load.i128
	<mul+254 @050d36>  : 10 0c                      dup.x1 sp(12)
	<mul+256 @050d38>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @050d3c>  : 24                         load.i128
	<mul+261 @050d3d>  : 9b                         dp4.v4f
	<mul+262 @050d3e>  : 1f d8 0b 05 00             load.ref <@050bd8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @050d43>  : 02                         call
	<mul+268 @050d44>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @050d48>  : 15 02                      set.x4 sp(2)
	<mul+274 @050d4a>  : 15 1b                      set.x4 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes: <@050d4c> - <@050d90>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @050d4c>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @050d50>  : 10 13                      dup.x1 sp(19)
	<mul+282 @050d52>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @050d56>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @050d5a>  : 10 04                      dup.x1 sp(4)
	<mul+292 @050d5c>  : 24                         load.i128
	<mul+293 @050d5d>  : 10 09                      dup.x1 sp(9)
	<mul+295 @050d5f>  : 24                         load.i128
	<mul+296 @050d60>  : 9b                         dp4.v4f
	<mul+297 @050d61>  : 10 05                      dup.x1 sp(5)
	<mul+299 @050d63>  : 24                         load.i128
	<mul+300 @050d64>  : 10 0a                      dup.x1 sp(10)
	<mul+302 @050d66>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @050d6a>  : 24                         load.i128
	<mul+307 @050d6b>  : 9b                         dp4.v4f
	<mul+308 @050d6c>  : 10 06                      dup.x1 sp(6)
	<mul+310 @050d6e>  : 24                         load.i128
	<mul+311 @050d6f>  : 10 0b                      dup.x1 sp(11)
	<mul+313 @050d71>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @050d75>  : 24                         load.i128
	<mul+318 @050d76>  : 9b                         dp4.v4f
	<mul+319 @050d77>  : 10 07                      dup.x1 sp(7)
	<mul+321 @050d79>  : 24                         load.i128
	<mul+322 @050d7a>  : 10 0c                      dup.x1 sp(12)
	<mul+324 @050d7c>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @050d80>  : 24                         load.i128
	<mul+329 @050d81>  : 9b                         dp4.v4f
	<mul+330 @050d82>  : 1f d8 0b 05 00             load.ref <@050bd8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @050d87>  : 02                         call
	<mul+336 @050d88>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @050d8c>  : 15 02                      set.x4 sp(2)
	<mul+342 @050d8e>  : 15 1f                      set.x4 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes: <@050d90> - <@050dd4>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @050d90>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @050d94>  : 10 13                      dup.x1 sp(19)
	<mul+350 @050d96>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @050d9a>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @050d9e>  : 10 04                      dup.x1 sp(4)
	<mul+360 @050da0>  : 24                         load.i128
	<mul+361 @050da1>  : 10 09                      dup.x1 sp(9)
	<mul+363 @050da3>  : 24                         load.i128
	<mul+364 @050da4>  : 9b                         dp4.v4f
	<mul+365 @050da5>  : 10 05                      dup.x1 sp(5)
	<mul+367 @050da7>  : 24                         load.i128
	<mul+368 @050da8>  : 10 0a                      dup.x1 sp(10)
	<mul+370 @050daa>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @050dae>  : 24                         load.i128
	<mul+375 @050daf>  : 9b                         dp4.v4f
	<mul+376 @050db0>  : 10 06                      dup.x1 sp(6)
	<mul+378 @050db2>  : 24                         load.i128
	<mul+379 @050db3>  : 10 0b                      dup.x1 sp(11)
	<mul+381 @050db5>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @050db9>  : 24                         load.i128
	<mul+386 @050dba>  : 9b                         dp4.v4f
	<mul+387 @050dbb>  : 10 07                      dup.x1 sp(7)
	<mul+389 @050dbd>  : 24                         load.i128
	<mul+390 @050dbe>  : 10 0c                      dup.x1 sp(12)
	<mul+392 @050dc0>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @050dc4>  : 24                         load.i128
	<mul+397 @050dc5>  : 9b                         dp4.v4f
	<mul+398 @050dc6>  : 1f d8 0b 05 00             load.ref <@050bd8> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @050dcb>  : 02                         call
	<mul+404 @050dcc>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @050dd0>  : 15 02                      set.x4 sp(2)
	<mul+410 @050dd2>  : 15 23                      set.x4 sp(35)
	<mul+412 @050dd4>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @050dd8>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+12>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+16>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+20>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+24>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+28>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+32>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+40>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+44>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+52>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+60>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+64>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+68>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+72>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+76>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+80>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+84>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+88>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+92>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+96>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+100>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+104>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+108>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+112>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+116>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+120>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+124>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+128>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+132>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+136>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+140>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+144>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+148>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+152>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+156>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+160>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+164>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+168>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+172>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+176>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+180>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+184>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+188>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+192>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+196>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+200>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+204>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+208>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+212>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+216>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+220>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+224>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+228>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+232>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+236>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+240>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+244>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+248>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+252>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+256>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+260>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+264>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031068>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031198>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.offset: <+272>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <+280>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@050de0>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+284>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+288>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+296>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+304>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+308>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+312>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+316>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+320>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+328>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+332>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+336>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.offset: <+340>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+344>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+352>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+356>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+364>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+372>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.offset: <+376>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+380>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+388>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+392>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+396>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+400>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+404>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+408>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+412>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+416>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+420>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+424>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+428>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+432>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+436>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+440>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+444>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+448>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+452>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+456>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+460>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+464>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+472>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+480>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+488>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+496>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+504>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+512>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+520>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+528>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+536>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+544>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+552>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+560>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+568>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+576>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+584>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+592>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+600>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+608>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+612>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+616>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+620>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+624>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+628>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+632>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+636>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+640>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+644>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+648>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+652>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+656>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+660>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+664>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+668>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+672>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+676>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+680>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+684>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+692>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+696>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+700>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.offset: <+708>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+712>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@050de8>
.name: 'empty'
.file: 'test/lang/function.ci:3'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.value: {
}
.instructions: (1 byte: <@050de8> - <@050de9>)
	<empty @050de8>      : 03                         ret
.usages:
	test/lang/function.ci:3: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@050df0>
.name: 'funAdd'
.file: 'test/lang/function.ci:6'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@050df0> - <@050df8>)
	test/lang/function.ci:7: (8 bytes: <@050df0> - <@050df8>): return int32(.result := int32(x + y));
	<funAdd @050df0>      : 10 02                      dup.x1 sp(2)
	<funAdd+2 @050df2>    : 10 02                      dup.x1 sp(2)
	<funAdd+4 @050df4>    : 51                         add.i32
	<funAdd+5 @050df5>    : 13 04                      set.x1 sp(4)
	<funAdd+7 @050df7>    : 03                         ret
.usages:
	test/lang/function.ci:14: referenced as `funAdd`
	test/lang/function.ci:11: referenced as `funAdd`
	test/lang/function.ci:6: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+716>
.name: 'funAddResult'
.file: 'test/lang/function.ci:11'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:11: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+720>
.name: 'funAddRef'
.file: 'test/lang/function.ci:14'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funAdd
.usages:
	test/lang/function.ci:17: referenced as `funAddRef`
	test/lang/function.ci:14: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+724>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:17'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:17: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+728>
.name: 'funMul'
.file: 'test/lang/function.ci:20'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.usages:
	test/lang/function.ci:26: referenced as `funMul`
	test/lang/function.ci:23: referenced as `funMul`
	test/lang/function.ci:20: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+732>
.name: 'funMulResult'
.file: 'test/lang/function.ci:23'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:23: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+736>
.name: 'funMulRef'
.file: 'test/lang/function.ci:26'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: funMul
.usages:
	test/lang/function.ci:29: referenced as `funMulRef`
	test/lang/function.ci:26: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+740>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:29'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:29: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@050df8>
.name: 'funMul'
.file: 'test/lang/function.ci:32'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@050df8> - <@050e00>)
	test/lang/function.ci:33: (8 bytes: <@050df8> - <@050e00>): return int32(.result := int32(x * y));
	<funMul @050df8>      : 10 02                      dup.x1 sp(2)
	<funMul+2 @050dfa>    : 10 02                      dup.x1 sp(2)
	<funMul+4 @050dfc>    : 53                         mul.i32
	<funMul+5 @050dfd>    : 13 04                      set.x1 sp(4)
	<funMul+7 @050dff>    : 03                         ret
.usages:
	test/lang/function.ci:32: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@050e00>
.name: 'fib'
.file: 'test/lang/function.ci:37'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@050e00> - <@050e36>)
	test/lang/function.ci:38: (16 bytes: <@050e00> - <@050e10>): if (bool(n <= (1)))
	<fib @050e00>      : 10 01                      dup.x1 sp(1)
	<fib+2 @050e02>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @050e07>    : 39                         cgt.u32
	<fib+8 @050e08>    : 05 08 00 00                jnz <fib+16 @050e10>
	test/lang/function.ci:39: (4 bytes: <@050e0c> - <@050e10>): return uint32(.result := n);
	<fib+12 @050e0c>   : 16 02 01                   mov.x1 sp(2, 1)
	<fib+15 @050e0f>   : 03                         ret
	test/lang/function.ci:41: (38 bytes: <@050e10> - <@050e36>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @050e10>   : 19                         load.z32
	<fib+17 @050e11>   : 10 02                      dup.x1 sp(2)
	<fib+19 @050e13>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @050e17>   : 1f 00 0e 05 00             load.ref <@050e00> ;fib(n: uint32): uint32
	<fib+28 @050e1c>   : 02                         call
	<fib+29 @050e1d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @050e21>   : 19                         load.z32
	<fib+34 @050e22>   : 10 03                      dup.x1 sp(3)
	<fib+36 @050e24>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @050e28>   : 1f 00 0e 05 00             load.ref <@050e00> ;fib(n: uint32): uint32
	<fib+45 @050e2d>   : 02                         call
	<fib+46 @050e2e>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @050e32>   : 51                         add.i32
	<fib+51 @050e33>   : 13 03                      set.x1 sp(3)
	<fib+53 @050e35>   : 03                         ret
.usages:
	test/lang/function.ci:45: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:41: referenced as `fib`
	test/lang/function.ci:37: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+744>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:45'
.value: fib(13)
.usages:
	test/lang/function.ci:45: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+748>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+752>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+756>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+760>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+764>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+768>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+772>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+776>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+780>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+784>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+788>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+792>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+796>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+800>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+804>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+808>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+812>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+816>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@036e88>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@036fb8>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+820>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+824>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+828>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+832>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+836>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+840>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+844>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+848>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+852>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+856>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+860>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+864>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+868>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+872>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+876>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.offset: <+880>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+884>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+888>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+896>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+904>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+908>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+912>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: ' pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: ' pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+916>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+920>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+924>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+928>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+932>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+936>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+940>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+944>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+948>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+952>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+956>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+960>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+964>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+968>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+972>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+976>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+980>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+988>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+996>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1004>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1012>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1020>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1028>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1036>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+1044>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1048>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1052>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1056>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1060>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1064>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1068>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1072>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+1076>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1080>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1084>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1088>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1092>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1096>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1100>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1104>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1108>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1112>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1116>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.offset: <+0>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1120>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1124>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1128>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+1132>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1140>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+1148>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@050e38>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@050e38> - <@050e39>)
	<noError @050e38>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@050e40>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@050e40> - <@050e58>)
	test/stdc/tryExec.ci:15: (4 bytes: <@050e40> - <@050e44>): data: uint8[8192]
	<stackOverflow @050e40>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@050e44> - <@050e53>): stackOverflow(ptr);
	<stackOverflow+4 @050e44>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @050e48>    : 22                         load.i32
	<stackOverflow+9 @050e49>    : 1f 40 0e 05 00             load.ref <@050e40> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @050e4e>   : 02                         call
	<stackOverflow+15 @050e4f>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @050e53>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @050e57>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050e58>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@050e58> - <@050e64>)
	test/stdc/tryExec.ci:20: (7 bytes: <@050e58> - <@050e5f>): value: int32 := int32(3 / 0)
	<divisionByZero @050e58>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @050e5d>    : 19                         load.z32
	<divisionByZero+6 @050e5e>    : 54                         div.i32
	<divisionByZero+7 @050e5f>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @050e63>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@050e68>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@050e68> - <@050eac>)
	test/stdc/tryExec.ci:29: (25 bytes: <@050e68> - <@050e81>): details: NotEquals := {...}
	<abortExecution @050e68>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@050e6c> - <@050e73>): void(details.message := ("assertion failed"));
	<abortExecution+4 @050e6c>    : 1f 88 cc 00 00             load.ref <@00cc88> ;"assertion failed"
	<abortExecution+9 @050e71>    : 13 01                      set.x1 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@050e73> - <@050e7a>): void(details.expected := 97);
	<abortExecution+11 @050e73>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @050e78>   : 13 02                      set.x1 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@050e7a> - <@050e81>): void(details.returned := 77);
	<abortExecution+18 @050e7a>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @050e7f>   : 13 03                      set.x1 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@050e81> - <@050ea7>): abort(void("fatal error", details));
	<abortExecution+25 @050e81>   : 1f 28 ac 03 00             load.ref <@03ac28> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @050e86>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @050e8b>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @050e90>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @050e95>   : 1f 71 ac 03 00             load.ref <@03ac71> ;"fatal error"
	<abortExecution+50 @050e9a>   : 1f 88 b6 03 00             load.ref <@03b688> ;abortExecution.NotEquals
	<abortExecution+55 @050e9f>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @050ea3>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @050ea7>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @050eab>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@050eb0>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@050eb0> - <@050ebd>)
	test/stdc/tryExec.ci:38: (5 bytes: <@050eb0> - <@050eb5>): i32Ref: int32 := null
	<invalidMemoryAccess @050eb0>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@050eb5> - <@050eb8>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @050eb5>    : 10 00                      dup.x1 sp(0)
	<invalidMemoryAccess+7 @050eb7>    : 22                         load.i32
	<invalidMemoryAccess+8 @050eb8>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @050ebc>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@050ec0>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@050ec0> - <@050ec2>)
	test/stdc/tryExec.ci:43: (2 bytes: <@050ec0> - <@050ec2>): emit(void(load.z32, ret));
	<invalidInstruction @050ec0>      : 19                         load.z32
	<invalidInstruction+1 @050ec1>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1152>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1156>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1160>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1164>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1168>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1172>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1176>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.offset: <+1232>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1236>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1244>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1248>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1256>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1260>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1268>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1272>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.offset: <+1280>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.offset: <+1284>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.offset: <+1292>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.offset: <+1296>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.offset: <+1304>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@050ec8>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@050ec8> - <@050ecc>)
	test/lang/array.ci:103: (4 bytes: <@050ec8> - <@050ecc>): return uint32(.result := values.length);
	<lenSlice @050ec8>      : 16 03 02                   mov.x1 sp(3, 2)
	<lenSlice+3 @050ecb>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050ed0>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050ed0> - <@050edc>)
	test/lang/array.ci:104: (12 bytes: <@050ed0> - <@050edc>): return int64(.result := values[idx]);
	<nthFixed @050ed0>      : 10 01                      dup.x1 sp(1)
	<nthFixed+2 @050ed2>    : 10 03                      dup.x1 sp(3)
	<nthFixed+4 @050ed4>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @050ed8>    : 23                         load.i64
	<nthFixed+9 @050ed9>    : 14 05                      set.x2 sp(5)
	<nthFixed+11 @050edb>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050ee0>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050ee0> - <@050eec>)
	test/lang/array.ci:105: (12 bytes: <@050ee0> - <@050eec>): return int64(.result := values[idx]);
	<nthArray @050ee0>      : 10 01                      dup.x1 sp(1)
	<nthArray+2 @050ee2>    : 10 03                      dup.x1 sp(3)
	<nthArray+4 @050ee4>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @050ee8>    : 23                         load.i64
	<nthArray+9 @050ee9>    : 14 05                      set.x2 sp(5)
	<nthArray+11 @050eeb>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@050ef0>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@050ef0> - <@050efc>)
	test/lang/array.ci:106: (12 bytes: <@050ef0> - <@050efc>): return int64(.result := values[idx]);
	<nthSlice @050ef0>      : 10 01                      dup.x1 sp(1)
	<nthSlice+2 @050ef2>    : 10 04                      dup.x1 sp(4)
	<nthSlice+4 @050ef4>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @050ef8>    : 23                         load.i64
	<nthSlice+9 @050ef9>    : 14 06                      set.x2 sp(6)
	<nthSlice+11 @050efb>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03e3d0>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@03e468>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@050f00>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@050f08>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@050f10>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@050f18>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@050f20>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@050f28>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03e468>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@050f00>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@050f08>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@050f10>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050f18>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050f20>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@050f28>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <+1336>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03eea8>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:3'
.field staticMethod: function (size: 39, offs: <@050f30>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@050f58>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@050f60>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@050f88>, cast: static const function)
.usages:
	test/lang/method.ci:80: referenced as `RecordMethodTest`
	test/lang/method.ci:79: referenced as `RecordMethodTest`
	test/lang/method.ci:68: referenced as `RecordMethodTest`
	test/lang/method.ci:65: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:44: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:30: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:19: referenced as `RecordMethodTest`
	test/lang/method.ci:15: referenced as `RecordMethodTest`
	test/lang/method.ci:11: referenced as `RecordMethodTest`
	test/lang/method.ci:6: referenced as `RecordMethodTest`
	test/lang/method.ci:3: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050f30>
.name: 'staticMethod'
.file: 'test/lang/method.ci:6'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@050f30> - <@050f57>)
	test/lang/method.ci:7: (38 bytes: <@050f30> - <@050f56>): trace(void("staticMethod", x));
	<staticMethod @050f30>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<staticMethod+5 @050f35>    : 1c 07 00 00 00             load.c32 7
	<staticMethod+10 @050f3a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @050f3f>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @050f44>   : 1f 0d ee 03 00             load.ref <@03ee0d> ;"staticMethod"
	<staticMethod+25 @050f49>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @050f4e>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @050f52>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @050f56>   : 03                         ret
.usages:
	test/lang/method.ci:79: referenced as `staticMethod`
	test/lang/method.ci:65: referenced as `staticMethod`
	test/lang/method.ci:58: referenced as `staticMethod`
	test/lang/method.ci:6: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@050f58>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:11'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.usages:
	test/lang/method.ci:19: referenced as `forwardMethod`
	test/lang/method.ci:11: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:15'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.usages:
	test/lang/method.ci:46: referenced as `abstractMethod`
	test/lang/method.ci:15: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:19'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: forwardMethod
.usages:
	test/lang/method.ci:19: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: virtualMethod
.usages:
	test/lang/method.ci:81: referenced as `virtualMethod`
	test/lang/method.ci:71: referenced as `virtualMethod`
	test/lang/method.ci:59: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050f60>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@050f60> - <@050f87>)
	test/lang/method.ci:26: (38 bytes: <@050f60> - <@050f86>): trace(void("virtualMethod", x));
	<virtualMethod @050f60>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<virtualMethod+5 @050f65>    : 1c 1a 00 00 00             load.c32 26
	<virtualMethod+10 @050f6a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @050f6f>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @050f74>   : 1f 4b ee 03 00             load.ref <@03ee4b> ;"virtualMethod"
	<virtualMethod+25 @050f79>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @050f7e>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @050f82>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @050f86>   : 03                         ret
.usages:
	test/lang/method.ci:80: referenced as `virtualMethod`
	test/lang/method.ci:25: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050f88>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:30'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@050f88> - <@050faf>)
	test/lang/method.ci:31: (38 bytes: <@050f88> - <@050fae>): trace(void("forwardMethod", x));
	<forwardMethod @050f88>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<forwardMethod+5 @050f8d>    : 1c 1f 00 00 00             load.c32 31
	<forwardMethod+10 @050f92>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @050f97>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @050f9c>   : 1f 1f ee 03 00             load.ref <@03ee1f> ;"forwardMethod"
	<forwardMethod+25 @050fa1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @050fa6>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @050faa>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @050fae>   : 03                         ret
.usages:
	test/lang/method.ci:30: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@050fb0>
.name: 'globalFunction'
.file: 'test/lang/method.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@050fb0> - <@050fd7>)
	test/lang/method.ci:41: (38 bytes: <@050fb0> - <@050fd6>): trace(void("globalFunction", x));
	<globalFunction @050fb0>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<globalFunction+5 @050fb5>    : 1c 29 00 00 00             load.c32 41
	<globalFunction+10 @050fba>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @050fbf>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @050fc4>   : 1f 59 ee 03 00             load.ref <@03ee59> ;"globalFunction"
	<globalFunction+25 @050fc9>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @050fce>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @050fd2>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @050fd6>   : 03                         ret
.usages:
	test/lang/method.ci:46: referenced as `globalFunction`
	test/lang/method.ci:40: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <+1352>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:44'
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:81: referenced as `recordMethodTest`
	test/lang/method.ci:80: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:76: referenced as `recordMethodTest`
	test/lang/method.ci:75: referenced as `recordMethodTest`
	test/lang/method.ci:59: referenced as `recordMethodTest`
	test/lang/method.ci:58: referenced as `recordMethodTest`
	test/lang/method.ci:44: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@050fd8>
.name: 'staticMethod'
.file: 'test/lang/method.ci:62'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@050fd8> - <@05101a>)
	test/lang/method.ci:63: (35 bytes: <@050fd8> - <@050ffb>): debug("extension.staticMethod");
	<staticMethod @050fd8>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<staticMethod+5 @050fdd>    : 1c 3f 00 00 00             load.c32 63
	<staticMethod+10 @050fe2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @050fe7>   : 19                         load.z32
	<staticMethod+16 @050fe8>   : 1f 79 ee 03 00             load.ref <@03ee79> ;"extension.staticMethod"
	<staticMethod+21 @050fed>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @050ff2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @050ff7>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:64: (30 bytes: <@050ffb> - <@051019>): if (bool((this) != null))
	<staticMethod+35 @050ffb>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @050fff>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @051004>   : 57                         ceq.i32
	<staticMethod+45 @051005>   : 05 14 00 00                jnz <staticMethod+65 @051019>
	test/lang/method.ci:65: (16 bytes: <@051009> - <@051019>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @051009>   : 12 02                      dup.x4 sp(2)
	<staticMethod+51 @05100b>   : 10 05                      dup.x1 sp(5)
	<staticMethod+53 @05100d>   : 13 04                      set.x1 sp(4)
	<staticMethod+55 @05100f>   : 1f 30 0f 05 00             load.ref <@050f30> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @051014>   : 02                         call
	<staticMethod+61 @051015>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @051019>   : 03                         ret
.usages:
	test/lang/method.ci:75: referenced as `staticMethod`
	test/lang/method.ci:62: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@051020>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:68'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@051020> - <@05105f>)
	test/lang/method.ci:69: (35 bytes: <@051020> - <@051043>): debug("extension.virtualMethod");
	<virtualMethod @051020>      : 1f e8 ed 03 00             load.ref <@03ede8> ;"test/lang/method.ci"
	<virtualMethod+5 @051025>    : 1c 45 00 00 00             load.c32 69
	<virtualMethod+10 @05102a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @05102f>   : 19                         load.z32
	<virtualMethod+16 @051030>   : 1f 90 ee 03 00             load.ref <@03ee90> ;"extension.virtualMethod"
	<virtualMethod+21 @051035>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @05103a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @05103f>   : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:70: (27 bytes: <@051043> - <@05105e>): if (bool((this) != null))
	<virtualMethod+35 @051043>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @051047>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @05104c>   : 57                         ceq.i32
	<virtualMethod+45 @05104d>   : 05 11 00 00                jnz <virtualMethod+62 @05105e>
	test/lang/method.ci:71: (13 bytes: <@051051> - <@05105e>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @051051>   : 12 02                      dup.x4 sp(2)
	<virtualMethod+51 @051053>   : 10 05                      dup.x1 sp(5)
	<virtualMethod+53 @051055>   : 13 04                      set.x1 sp(4)
	<virtualMethod+55 @051057>   : 10 08                      dup.x1 sp(8)
	<virtualMethod+57 @051059>   : 02                         call
	<virtualMethod+58 @05105a>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @05105e>   : 03                         ret
.usages:
	test/lang/method.ci:76: referenced as `virtualMethod`
	test/lang/method.ci:68: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@040628>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@040888>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@040ae8>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@040cb0>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1356>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1360>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+1364>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1368>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.offset: <+1372>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@041150>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@041578>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0419a0>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@041dc8>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@0421f0>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@042618>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.offset: <+0>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1376>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1380>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1384>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1392>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1396>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1400>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1404>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1408>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1412>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1416>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1420>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1424>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1428>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1432>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1436>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1440>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1444>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1448>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1452>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1456>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1460>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1464>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1468>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1472>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1476>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1480>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.offset: <+1484>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1488>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1492>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1496>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1500>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1504>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1508>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1512>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1516>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1520>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1524>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1528>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1532>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1536>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1540>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1544>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1548>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1552>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1556>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1560>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1564>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1568>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.offset: <+1572>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1576>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1580>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1584>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1588>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1592>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1596>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1600>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1604>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1608>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1612>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1616>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1620>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1624>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1628>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1632>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1636>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1640>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1644>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1648>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1652>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1656>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1660>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1664>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1668>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1672>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1676>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1680>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1684>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1688>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1692>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1696>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1700>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1704>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1708>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1712>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1716>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1720>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1724>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1728>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1732>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1736>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1740>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1744>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.offset: <+1748>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1752>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1756>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1760>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1764>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1768>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1772>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1776>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1780>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1784>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1788>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1792>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1796>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1800>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1804>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1808>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1812>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1816>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1820>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1824>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1828>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1832>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+1836>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1840>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1844>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1848>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1852>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1856>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1860>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1864>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1868>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1872>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1876>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1880>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1884>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1888>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1892>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1896>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1900>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1904>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1908>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1912>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1916>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1920>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+1924>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1928>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1932>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1936>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1940>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1944>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1948>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+1952>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1956>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1960>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1964>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1968>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1972>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1976>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1980>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1984>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1988>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1992>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+1996>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2000>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2004>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2008>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+2012>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2016>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2020>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2024>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2028>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2032>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2036>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2040>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2048>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2056>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2064>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2072>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2080>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2088>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2096>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2104>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2112>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2120>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2128>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2136>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2144>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2152>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+2160>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2164>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2168>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2172>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2176>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2180>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2184>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2188>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2196>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2204>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2212>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2220>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2228>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2236>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2244>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2252>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2260>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2268>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2276>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2284>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2292>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2300>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2308>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2312>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2316>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2320>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2324>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2328>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2332>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2336>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2340>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2344>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2348>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2352>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2356>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2360>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2364>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2368>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+2372>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2376>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2380>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2384>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2388>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2392>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2396>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2400>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2408>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2416>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2424>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2432>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2440>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2448>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2456>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2464>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2472>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2476>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2480>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2484>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2488>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2492>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2496>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2500>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2504>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.offset: <+2508>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2512>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2516>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2520>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+2524>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2532>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2540>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2548>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2556>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2564>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2572>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2580>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2588>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2596>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2604>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2612>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2620>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2628>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2636>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2644>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2652>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2660>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2668>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2676>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2684>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2692>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2700>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2708>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2716>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2724>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2732>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2740>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2748>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2756>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2764>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2772>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2780>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2788>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2796>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2804>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2812>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2820>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2828>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2836>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2844>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2852>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2860>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2868>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2876>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2884>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2892>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2900>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2908>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2916>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2924>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2932>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2936>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.offset: <+2940>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2948>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2956>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2964>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2972>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2980>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2988>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+2996>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3004>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3012>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3020>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+3028>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3032>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3036>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3040>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3044>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3048>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3052>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3056>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3060>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3064>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3068>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+3072>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 10884
.offset: <@05105f>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field true: bool (size: 0, offs: <@000000>, cast: static const inline)
.field false: bool (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field byte: typename (size: 0, offs: <@000000>, cast: static const inline)
.field float: typename (size: 0, offs: <@000000>, cast: static const inline)
.field double: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@001058>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@0010f8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005c20>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006d00>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0075e0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008250>, cast: static const typename(void))
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field verbose: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field debug: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field trace: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field info: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field warn: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field error: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field abort: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field assert: function (size: 0, offs: <+0>, cast: inline)
.field NotEquals: typename (size: 32, offs: <@00fbf0>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@04fd10>, cast: static const function)
.field assertEq: function (size: 0, offs: <+0>, cast: inline)
.field sizeof: function (size: 0, offs: <+0>, cast: inline)
.field Math: typename (size: 0, offs: <@010e98>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@019bb8>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@050510>, cast: static const function)
.field Complex: function (size: 7, offs: <@050518>, cast: static const function)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 123, offs: <@050520>, cast: static const function)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field abs: function (size: 0, offs: <+0>, cast: inline)
.field arg: function (size: 0, offs: <+0>, cast: inline)
.field inv: function (size: 31, offs: <@0505a0>, cast: static const function)
.field conj: function (size: 0, offs: <+0>, cast: inline)
.field exp: function (size: 0, offs: <+0>, cast: inline)
.field log: function (size: 0, offs: <+0>, cast: inline)
.field pow: function (size: 100, offs: <@0505c0>, cast: static const function)
.field pow: function (size: 0, offs: <+0>, cast: inline)
.field sin: function (size: 0, offs: <+0>, cast: inline)
.field cos: function (size: 0, offs: <+0>, cast: inline)
.field tan: function (size: 0, offs: <+0>, cast: inline)
.field cot: function (size: 0, offs: <+0>, cast: inline)
.field sinh: function (size: 0, offs: <+0>, cast: inline)
.field cosh: function (size: 0, offs: <+0>, cast: inline)
.field tanh: function (size: 0, offs: <+0>, cast: inline)
.field coth: function (size: 0, offs: <+0>, cast: inline)
.field sec: function (size: 0, offs: <+0>, cast: inline)
.field csc: function (size: 0, offs: <+0>, cast: inline)
.field sech: function (size: 0, offs: <+0>, cast: inline)
.field csch: function (size: 0, offs: <+0>, cast: inline)
.field toCartesian: function (size: 0, offs: <+0>, cast: inline)
.field toPolar: function (size: 0, offs: <+0>, cast: inline)
.field length: function (size: 38, offs: <@050628>, cast: static const function)
.field indexOf: function (size: 50, offs: <@050650>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@050688>, cast: static const function)
.field startsWith: function (size: 73, offs: <@0506c0>, cast: static const function)
.field endsWith: function (size: 126, offs: <@050710>, cast: static const function)
.field compare: function (size: 63, offs: <@050790>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@050818>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@050840>, cast: static const function)
.field startsWith: function (size: 0, offs: <+0>, cast: inline)
.field endsWith: function (size: 0, offs: <+0>, cast: inline)
.field compare: function (size: 0, offs: <+0>, cast: inline)
.field contains: function (size: 0, offs: <+0>, cast: inline)
.field FormatFlags: typename (size: 16, offs: <@0225f8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@050850>, cast: static const function)
.field append: function (size: 657, offs: <@0508b8>, cast: static const function)
.field append: function (size: 23, offs: <@050b50>, cast: static const function)
.field append: function (size: 49, offs: <@050b68>, cast: static const function)
.field append: function (size: 25, offs: <@050bb0>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024790>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@050bd0>, cast: static const function)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field dot: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: typename (size: 16, offs: <@025758>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@050bd8>, cast: static const function)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field vec4f: function (size: 0, offs: <+0>, cast: inline)
.field neg: function (size: 0, offs: <+0>, cast: inline)
.field add: function (size: 0, offs: <+0>, cast: inline)
.field sub: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 0, offs: <+0>, cast: inline)
.field div: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field cross: function (size: 0, offs: <+0>, cast: inline)
.field len: function (size: 0, offs: <+0>, cast: inline)
.field normalize: function (size: 0, offs: <+0>, cast: inline)
.field eval: function (size: 0, offs: <+0>, cast: inline)
.field mat4f: typename (size: 64, offs: <@028b40>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@050be8>, cast: static const function)
.field mat4f: function (size: 21, offs: <@050c20>, cast: static const function)
.field dp3: function (size: 0, offs: <+0>, cast: inline)
.field dph: function (size: 0, offs: <+0>, cast: inline)
.field dp4: function (size: 0, offs: <+0>, cast: inline)
.field mul: function (size: 417, offs: <@050c38>, cast: static const function)
.field integer: typename (size: 0, offs: <+0>, cast: inline)
.field emitldz32: int32 (size: 4, offs: <+4>, cast: variable(i32))
.field emitldz64: int64 (size: 8, offs: <+12>, cast: variable(i64))
.field emitA: int32 (size: 4, offs: <+16>, cast: variable(i32))
.field emitB: int32 (size: 4, offs: <+20>, cast: variable(i32))
.field emitAddI32: int32 (size: 4, offs: <+24>, cast: variable(i32))
.field emitDivI32: int32 (size: 4, offs: <+28>, cast: variable(i32))
.field floatAsInt32: function (size: 0, offs: <+0>, cast: inline)
.field floatAsInt64: function (size: 0, offs: <+0>, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <+32>, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <+40>, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <+44>, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <+52>, cast: variable(i64))
.field emitSlice: char[] (size: 8, offs: <+60>, cast: variable(arr))
.field zero: function (size: 0, offs: <+0>, cast: inline)
.field last: function (size: 0, offs: <+0>, cast: inline)
.field sum: function (size: 0, offs: <+0>, cast: inline)
.field any: function (size: 0, offs: <+0>, cast: inline)
.field min: function (size: 0, offs: <+0>, cast: inline)
.field max: function (size: 0, offs: <+0>, cast: inline)
.field i3: int32 (size: 4, offs: <+64>, cast: variable(i32))
.field i6: int32 (size: 4, offs: <+68>, cast: variable(i32))
.field i2: int32 (size: 4, offs: <+72>, cast: variable(i32))
.field i8: int32 (size: 4, offs: <+76>, cast: variable(i32))
.field zeroVal: int32 (size: 4, offs: <+80>, cast: variable(i32))
.field zeroVar: int32 (size: 4, offs: <+84>, cast: variable(i32))
.field zeroXpr: int32 (size: 4, offs: <+88>, cast: variable(i32))
.field lastVal: int32 (size: 4, offs: <+92>, cast: variable(i32))
.field lastVar: int32 (size: 4, offs: <+96>, cast: variable(i32))
.field lastXpr: int32 (size: 4, offs: <+100>, cast: variable(i32))
.field sum2Val: int32 (size: 4, offs: <+104>, cast: variable(i32))
.field sum2Var: int32 (size: 4, offs: <+108>, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <+112>, cast: variable(i32))
.field any2Val: int32 (size: 4, offs: <+116>, cast: variable(i32))
.field any2Var: int32 (size: 4, offs: <+120>, cast: variable(i32))
.field any2Xpr: int32 (size: 4, offs: <+124>, cast: variable(i32))
.field min2Val: int32 (size: 4, offs: <+128>, cast: variable(i32))
.field min2Var: int32 (size: 4, offs: <+132>, cast: variable(i32))
.field min2Xpr: int32 (size: 4, offs: <+136>, cast: variable(i32))
.field max2Val: int32 (size: 4, offs: <+140>, cast: variable(i32))
.field max2Var: int32 (size: 4, offs: <+144>, cast: variable(i32))
.field max2Xpr: int32 (size: 4, offs: <+148>, cast: variable(i32))
.field sumLr: function (size: 0, offs: <+0>, cast: inline)
.field sumRl: function (size: 0, offs: <+0>, cast: inline)
.field sumRlVal: int32 (size: 4, offs: <+152>, cast: variable(i32))
.field sumLrVal: int32 (size: 4, offs: <+156>, cast: variable(i32))
.field sumRlVar: int32 (size: 4, offs: <+160>, cast: variable(i32))
.field sumLrVar: int32 (size: 4, offs: <+164>, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <+168>, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <+172>, cast: variable(i32))
.field anyLr: function (size: 0, offs: <+0>, cast: inline)
.field anyRl: function (size: 0, offs: <+0>, cast: inline)
.field anyRlVal: int32 (size: 4, offs: <+176>, cast: variable(i32))
.field anyLrVal: int32 (size: 4, offs: <+180>, cast: variable(i32))
.field anyRlVar: int32 (size: 4, offs: <+184>, cast: variable(i32))
.field anyLrVar: int32 (size: 4, offs: <+188>, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <+192>, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <+196>, cast: variable(i32))
.field minLr: function (size: 0, offs: <+0>, cast: inline)
.field minRl: function (size: 0, offs: <+0>, cast: inline)
.field minRlVal: int32 (size: 4, offs: <+200>, cast: variable(i32))
.field minLrVal: int32 (size: 4, offs: <+204>, cast: variable(i32))
.field minRlVar: int32 (size: 4, offs: <+208>, cast: variable(i32))
.field minLrVar: int32 (size: 4, offs: <+212>, cast: variable(i32))
.field minRlXpr: int32 (size: 4, offs: <+216>, cast: variable(i32))
.field minLrXpr: int32 (size: 4, offs: <+220>, cast: variable(i32))
.field maxLr: function (size: 0, offs: <+0>, cast: inline)
.field maxRl: function (size: 0, offs: <+0>, cast: inline)
.field maxRlVal: int32 (size: 4, offs: <+224>, cast: variable(i32))
.field maxLrVal: int32 (size: 4, offs: <+228>, cast: variable(i32))
.field maxRlVar: int32 (size: 4, offs: <+232>, cast: variable(i32))
.field maxLrVar: int32 (size: 4, offs: <+236>, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <+240>, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <+244>, cast: variable(i32))
.field overload: typename (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload: function (size: 0, offs: <+0>, cast: inline)
.field overload1: float32 (size: 4, offs: <+248>, cast: variable(f32))
.field overload2: float32 (size: 4, offs: <+252>, cast: variable(f32))
.field overload3: float32 (size: 4, offs: <+256>, cast: variable(f32))
.field overload4: float32 (size: 4, offs: <+260>, cast: variable(f32))
.field overload5: float32 (size: 4, offs: <+264>, cast: variable(f32))
.field Celsius: typename (size: 8, offs: <@031068>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@031198>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field Celsius: function (size: 0, offs: <+0>, cast: inline)
.field Fahrenheit: function (size: 0, offs: <+0>, cast: inline)
.field boilC: Celsius (size: 8, offs: <+272>, cast: variable(val))
.field boilF: Fahrenheit (size: 8, offs: <+280>, cast: variable(val))
.field value: int64 (size: 8, offs: <@050de0>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <+284>, cast: variable(ref))
.field valuePtr: pointer (size: 4, offs: <+288>, cast: variable(ref))
.field valueVar: variant (size: 8, offs: <+296>, cast: variable(var))
.field fromRef: int64 (size: 8, offs: <+304>, cast: variable(i64))
.field fromPtr: int64 (size: 4, offs: <+308>, cast: variable(ref))
.field fromVar: int64 (size: 4, offs: <+312>, cast: variable(ref))
.field nullRef: int64 (size: 4, offs: <+316>, cast: variable(ref))
.field nullPtr: pointer (size: 4, offs: <+320>, cast: variable(ref))
.field nullVar: variant (size: 8, offs: <+328>, cast: variable(var))
.field nullTyp: typename (size: 4, offs: <+332>, cast: variable(ref))
.field nullFun: function (size: 4, offs: <+336>, cast: variable(ref))
.field nullObj: object (size: 4, offs: <+340>, cast: variable(ref))
.field typePtr: pointer (size: 4, offs: <+344>, cast: variable(ref))
.field typeVar: variant (size: 8, offs: <+352>, cast: variable(var))
.field typeTyp: typename (size: 4, offs: <+356>, cast: variable(ref))
.field local: int64 (size: 8, offs: <+364>, cast: variable(i64))
.field copyVal: int64 (size: 8, offs: <+372>, cast: variable(i64))
.field copyRef: int64 (size: 4, offs: <+376>, cast: variable(ref))
.field copyPtr: pointer (size: 4, offs: <+380>, cast: variable(ref))
.field copyVar: variant (size: 8, offs: <+388>, cast: variable(var))
.field copyTyp: typename (size: 4, offs: <+392>, cast: variable(ref))
.field ptrVoid: pointer (size: 4, offs: <+396>, cast: variable(ref))
.field ptrBool: pointer (size: 4, offs: <+400>, cast: variable(ref))
.field ptrChar: pointer (size: 4, offs: <+404>, cast: variable(ref))
.field ptrInt8: pointer (size: 4, offs: <+408>, cast: variable(ref))
.field ptrInt16: pointer (size: 4, offs: <+412>, cast: variable(ref))
.field ptrInt32: pointer (size: 4, offs: <+416>, cast: variable(ref))
.field ptrInt64: pointer (size: 4, offs: <+420>, cast: variable(ref))
.field ptrUint8: pointer (size: 4, offs: <+424>, cast: variable(ref))
.field ptrUint16: pointer (size: 4, offs: <+428>, cast: variable(ref))
.field ptrUint32: pointer (size: 4, offs: <+432>, cast: variable(ref))
.field ptrUint64: pointer (size: 4, offs: <+436>, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <+440>, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <+444>, cast: variable(ref))
.field ptrTypename: pointer (size: 4, offs: <+448>, cast: variable(ref))
.field ptrFunction: pointer (size: 4, offs: <+452>, cast: variable(ref))
.field ptrPointer: pointer (size: 4, offs: <+456>, cast: variable(ref))
.field ptrVariant: pointer (size: 4, offs: <+460>, cast: variable(ref))
.field ptrObject: pointer (size: 4, offs: <+464>, cast: variable(ref))
.field varVoid: variant (size: 8, offs: <+472>, cast: variable(var))
.field varBool: variant (size: 8, offs: <+480>, cast: variable(var))
.field varChar: variant (size: 8, offs: <+488>, cast: variable(var))
.field varInt8: variant (size: 8, offs: <+496>, cast: variable(var))
.field varInt16: variant (size: 8, offs: <+504>, cast: variable(var))
.field varInt32: variant (size: 8, offs: <+512>, cast: variable(var))
.field varInt64: variant (size: 8, offs: <+520>, cast: variable(var))
.field varUint8: variant (size: 8, offs: <+528>, cast: variable(var))
.field varUint16: variant (size: 8, offs: <+536>, cast: variable(var))
.field varUint32: variant (size: 8, offs: <+544>, cast: variable(var))
.field varUint64: variant (size: 8, offs: <+552>, cast: variable(var))
.field varFloat32: variant (size: 8, offs: <+560>, cast: variable(var))
.field varFloat64: variant (size: 8, offs: <+568>, cast: variable(var))
.field varTypename: variant (size: 8, offs: <+576>, cast: variable(var))
.field varFunction: variant (size: 8, offs: <+584>, cast: variable(var))
.field varPointer: variant (size: 8, offs: <+592>, cast: variable(var))
.field varVariant: variant (size: 8, offs: <+600>, cast: variable(var))
.field varObject: variant (size: 8, offs: <+608>, cast: variable(var))
.field typVoid: typename (size: 4, offs: <+612>, cast: variable(ref))
.field typBool: typename (size: 4, offs: <+616>, cast: variable(ref))
.field typChar: typename (size: 4, offs: <+620>, cast: variable(ref))
.field typInt8: typename (size: 4, offs: <+624>, cast: variable(ref))
.field typInt16: typename (size: 4, offs: <+628>, cast: variable(ref))
.field typInt32: typename (size: 4, offs: <+632>, cast: variable(ref))
.field typInt64: typename (size: 4, offs: <+636>, cast: variable(ref))
.field typUint8: typename (size: 4, offs: <+640>, cast: variable(ref))
.field typUint16: typename (size: 4, offs: <+644>, cast: variable(ref))
.field typUint32: typename (size: 4, offs: <+648>, cast: variable(ref))
.field typUint64: typename (size: 4, offs: <+652>, cast: variable(ref))
.field typFloat32: typename (size: 4, offs: <+656>, cast: variable(ref))
.field typFloat64: typename (size: 4, offs: <+660>, cast: variable(ref))
.field typTypename: typename (size: 4, offs: <+664>, cast: variable(ref))
.field typFunction: typename (size: 4, offs: <+668>, cast: variable(ref))
.field typPointer: typename (size: 4, offs: <+672>, cast: variable(ref))
.field typVariant: typename (size: 4, offs: <+676>, cast: variable(ref))
.field typObject: typename (size: 4, offs: <+680>, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <+684>, cast: variable(ref))
.field valueOfVar: variant (size: 8, offs: <+692>, cast: variable(var))
.field valueOfTyp: typename (size: 4, offs: <+696>, cast: variable(ref))
.field typeOfValue: typename (size: 4, offs: <+700>, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <+708>, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <+712>, cast: variable(ref))
.field empty: function (size: 1, offs: <@050de8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@050df0>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <+716>, cast: variable(i32))
.field funAddRef: function (size: 4, offs: <+720>, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <+724>, cast: variable(i32))
.field funMul: function (size: 4, offs: <+728>, cast: variable(ref))
.field funMulResult: int32 (size: 4, offs: <+732>, cast: variable(i32))
.field funMulRef: function (size: 4, offs: <+736>, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <+740>, cast: variable(i32))
.field funMul: function (size: 8, offs: <@050df8>, cast: static const function)
.field fib: function (size: 54, offs: <@050e00>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <+744>, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <+748>, cast: variable(i32))
.field sizeofBool: int32 (size: 4, offs: <+752>, cast: variable(i32))
.field sizeofChar: int32 (size: 4, offs: <+756>, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <+760>, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <+764>, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <+768>, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <+772>, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <+776>, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <+780>, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <+784>, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <+788>, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <+792>, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <+796>, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <+800>, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <+804>, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <+808>, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <+812>, cast: variable(i32))
.field sizeofObject: int32 (size: 4, offs: <+816>, cast: variable(i32))
.field RecordSizeof: object (size: 12, offs: <@036e88>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@036fb8>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <+820>, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <+824>, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <+828>, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <+832>, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <+836>, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <+840>, cast: variable(i32))
.field typeofBase: typename (size: 4, offs: <+844>, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <+848>, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <+852>, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <+856>, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <+860>, cast: variable(ref))
.field lineOfBase: int32 (size: 4, offs: <+864>, cast: variable(i32))
.field typeofBase1: typename (size: 4, offs: <+868>, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <+872>, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <+876>, cast: variable(i32))
.field typeofBase2: typename (size: 4, offs: <+880>, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <+884>, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <+888>, cast: variable(i32))
.field pi64: float64 (size: 8, offs: <+896>, cast: variable(f64))
.field e64: float64 (size: 8, offs: <+904>, cast: variable(f64))
.field pi32: float32 (size: 4, offs: <+908>, cast: variable(f32))
.field e32: float32 (size: 4, offs: <+912>, cast: variable(f32))
.field rgb888: function (size: 0, offs: <+0>, cast: inline)
.field rgb565: function (size: 0, offs: <+0>, cast: inline)
.field r_comp: int32 (size: 4, offs: <+916>, cast: variable(i32))
.field g_comp: int32 (size: 4, offs: <+920>, cast: variable(i32))
.field b_comp: int32 (size: 4, offs: <+924>, cast: variable(i32))
.field r5g6b5: int32 (size: 4, offs: <+928>, cast: variable(i32))
.field r8g8b8: int32 (size: 4, offs: <+932>, cast: variable(i32))
.field zxtR5: int32 (size: 4, offs: <+936>, cast: variable(i32))
.field zxtG6: int32 (size: 4, offs: <+940>, cast: variable(i32))
.field zxtB5: int32 (size: 4, offs: <+944>, cast: variable(i32))
.field sxtR5: int32 (size: 4, offs: <+948>, cast: variable(i32))
.field sxtG6: int32 (size: 4, offs: <+952>, cast: variable(i32))
.field sxtB5: int32 (size: 4, offs: <+956>, cast: variable(i32))
.field zxtR8: int32 (size: 4, offs: <+960>, cast: variable(i32))
.field zxtG8: int32 (size: 4, offs: <+964>, cast: variable(i32))
.field zxtB8: int32 (size: 4, offs: <+968>, cast: variable(i32))
.field sxtR8: int32 (size: 4, offs: <+972>, cast: variable(i32))
.field sxtG8: int32 (size: 4, offs: <+976>, cast: variable(i32))
.field sxtB8: int32 (size: 4, offs: <+980>, cast: variable(i32))
.field testSin_f64: float64 (size: 8, offs: <+988>, cast: variable(f64))
.field testCos_f64: float64 (size: 8, offs: <+996>, cast: variable(f64))
.field testTan_f64: float64 (size: 8, offs: <+1004>, cast: variable(f64))
.field testLog_f64: float64 (size: 8, offs: <+1012>, cast: variable(f64))
.field testExp_f64: float64 (size: 8, offs: <+1020>, cast: variable(f64))
.field testPow_f64: float64 (size: 8, offs: <+1028>, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <+1036>, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <+1044>, cast: variable(f64))
.field testSin_f32: float32 (size: 4, offs: <+1048>, cast: variable(f32))
.field testCos_f32: float32 (size: 4, offs: <+1052>, cast: variable(f32))
.field testTan_f32: float32 (size: 4, offs: <+1056>, cast: variable(f32))
.field testLog_f32: float32 (size: 4, offs: <+1060>, cast: variable(f32))
.field testExp_f32: float32 (size: 4, offs: <+1064>, cast: variable(f32))
.field testPow_f32: float32 (size: 4, offs: <+1068>, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <+1072>, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <+1076>, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <+1080>, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <+1084>, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <+1088>, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <+1092>, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <+1096>, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <+1100>, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <+1104>, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <+1108>, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <+1112>, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <+1116>, cast: variable(i32))
.field realloc: function (size: 0, offs: <+0>, cast: inline)
.field malloc: function (size: 0, offs: <+0>, cast: inline)
.field free: function (size: 0, offs: <+0>, cast: inline)
.field p1: pointer (size: 4, offs: <+1120>, cast: variable(ref))
.field p2: pointer (size: 4, offs: <+1124>, cast: variable(ref))
.field p3: pointer (size: 4, offs: <+1128>, cast: variable(ref))
.field p4: pointer (size: 4, offs: <+1132>, cast: variable(ref))
.field val1: int64 (size: 8, offs: <+1140>, cast: variable(i64))
.field val2: int64 (size: 8, offs: <+1148>, cast: variable(i64))
.field noError: function (size: 1, offs: <@050e38>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@050e40>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@050e58>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@050e68>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@050eb0>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@050ec0>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <+1152>, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <+1156>, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <+1160>, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <+1164>, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <+1168>, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <+1172>, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <+1176>, cast: variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <+1232>, cast: variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <+1236>, cast: variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <+1244>, cast: variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <+1248>, cast: variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <+1256>, cast: variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <+1260>, cast: variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <+1268>, cast: variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <+1272>, cast: variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <+1280>, cast: variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <+1284>, cast: variable(ref))
.field strFixed: char[7] (size: 7, offs: <+1292>, cast: variable(val))
.field strArray: char[*] (size: 4, offs: <+1296>, cast: variable(ref))
.field strSlice: char[] (size: 8, offs: <+1304>, cast: variable(arr))
.field lenSlice: function (size: 4, offs: <@050ec8>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@050ed0>, cast: static const function)
.field nthArray: function (size: 12, offs: <@050ee0>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@050ef0>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@03e3d0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <+1336>, cast: variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03eea8>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@050fb0>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <+1352>, cast: variable(val))
.field staticMethod: function (size: 66, offs: <@050fd8>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@051020>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@040628>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@040888>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@040ae8>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@040cb0>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <+1356>, cast: variable(val))
.field green: rgbU8 (size: 3, offs: <+1360>, cast: variable(val))
.field white: rgbU8 (size: 3, offs: <+1364>, cast: variable(val))
.field cyan: color (size: 4, offs: <+1368>, cast: variable(val))
.field blue: color (size: 4, offs: <+1372>, cast: variable(val))
.field record_pack0: typename (size: 8, offs: <@041150>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@041578>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0419a0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@041dc8>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@0421f0>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@042618>, cast: static const typename(val))
.field a: typename (size: 0, offs: <+0>, cast: inline)
.field b: typename (size: 0, offs: <+0>, cast: inline)
.field shift: int32 (size: 4, offs: <+1376>, cast: variable(i32))
.field boolA: bool (size: 1, offs: <+1380>, cast: variable(bool))
.field boolB: bool (size: 1, offs: <+1384>, cast: variable(bool))
.field boolAnd: bool (size: 1, offs: <+1388>, cast: variable(bool))
.field boolIor: bool (size: 1, offs: <+1392>, cast: variable(bool))
.field boolXor: bool (size: 1, offs: <+1396>, cast: variable(bool))
.field boolNot: bool (size: 1, offs: <+1400>, cast: variable(bool))
.field boolCeq: bool (size: 1, offs: <+1404>, cast: variable(bool))
.field boolCne: bool (size: 1, offs: <+1408>, cast: variable(bool))
.field boolClt: bool (size: 1, offs: <+1412>, cast: variable(bool))
.field boolCle: bool (size: 1, offs: <+1416>, cast: variable(bool))
.field boolCgt: bool (size: 1, offs: <+1420>, cast: variable(bool))
.field boolCge: bool (size: 1, offs: <+1424>, cast: variable(bool))
.field chrA: char (size: 1, offs: <+1428>, cast: variable(i32))
.field chrB: char (size: 1, offs: <+1432>, cast: variable(i32))
.field chrPls: char (size: 1, offs: <+1436>, cast: variable(i32))
.field chrNeg: char (size: 1, offs: <+1440>, cast: variable(i32))
.field chrCmt: char (size: 1, offs: <+1444>, cast: variable(i32))
.field chrAdd: char (size: 1, offs: <+1448>, cast: variable(i32))
.field chrSub: char (size: 1, offs: <+1452>, cast: variable(i32))
.field chrMul: char (size: 1, offs: <+1456>, cast: variable(i32))
.field chrDiv: char (size: 1, offs: <+1460>, cast: variable(i32))
.field chrMod: char (size: 1, offs: <+1464>, cast: variable(i32))
.field chrAnd: char (size: 1, offs: <+1468>, cast: variable(i32))
.field chrIor: char (size: 1, offs: <+1472>, cast: variable(i32))
.field chrXor: char (size: 1, offs: <+1476>, cast: variable(i32))
.field chrShl: char (size: 1, offs: <+1480>, cast: variable(i32))
.field chrShr: char (size: 1, offs: <+1484>, cast: variable(i32))
.field chrNot: bool (size: 1, offs: <+1488>, cast: variable(bool))
.field chrCeq: bool (size: 1, offs: <+1492>, cast: variable(bool))
.field chrCne: bool (size: 1, offs: <+1496>, cast: variable(bool))
.field chrClt: bool (size: 1, offs: <+1500>, cast: variable(bool))
.field chrCle: bool (size: 1, offs: <+1504>, cast: variable(bool))
.field chrCgt: bool (size: 1, offs: <+1508>, cast: variable(bool))
.field chrCge: bool (size: 1, offs: <+1512>, cast: variable(bool))
.field i8A: int8 (size: 1, offs: <+1516>, cast: variable(i32))
.field i8B: int8 (size: 1, offs: <+1520>, cast: variable(i32))
.field i8Pls: int8 (size: 1, offs: <+1524>, cast: variable(i32))
.field i8Neg: int8 (size: 1, offs: <+1528>, cast: variable(i32))
.field i8Cmt: int8 (size: 1, offs: <+1532>, cast: variable(i32))
.field i8Add: int8 (size: 1, offs: <+1536>, cast: variable(i32))
.field i8Sub: int8 (size: 1, offs: <+1540>, cast: variable(i32))
.field i8Mul: int8 (size: 1, offs: <+1544>, cast: variable(i32))
.field i8Div: int8 (size: 1, offs: <+1548>, cast: variable(i32))
.field i8Mod: int8 (size: 1, offs: <+1552>, cast: variable(i32))
.field i8And: int8 (size: 1, offs: <+1556>, cast: variable(i32))
.field i8Ior: int8 (size: 1, offs: <+1560>, cast: variable(i32))
.field i8Xor: int8 (size: 1, offs: <+1564>, cast: variable(i32))
.field i8Shl: int8 (size: 1, offs: <+1568>, cast: variable(i32))
.field i8Shr: int8 (size: 1, offs: <+1572>, cast: variable(i32))
.field i8Not: bool (size: 1, offs: <+1576>, cast: variable(bool))
.field i8Ceq: bool (size: 1, offs: <+1580>, cast: variable(bool))
.field i8Cne: bool (size: 1, offs: <+1584>, cast: variable(bool))
.field i8Clt: bool (size: 1, offs: <+1588>, cast: variable(bool))
.field i8Cle: bool (size: 1, offs: <+1592>, cast: variable(bool))
.field i8Cgt: bool (size: 1, offs: <+1596>, cast: variable(bool))
.field i8Cge: bool (size: 1, offs: <+1600>, cast: variable(bool))
.field u8A: uint8 (size: 1, offs: <+1604>, cast: variable(u32))
.field u8B: uint8 (size: 1, offs: <+1608>, cast: variable(u32))
.field u8Pls: uint8 (size: 1, offs: <+1612>, cast: variable(u32))
.field u8Neg: uint8 (size: 1, offs: <+1616>, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <+1620>, cast: variable(u32))
.field u8Add: uint8 (size: 1, offs: <+1624>, cast: variable(u32))
.field u8Sub: uint8 (size: 1, offs: <+1628>, cast: variable(u32))
.field u8Mul: uint8 (size: 1, offs: <+1632>, cast: variable(u32))
.field u8Div: uint8 (size: 1, offs: <+1636>, cast: variable(u32))
.field u8Mod: uint8 (size: 1, offs: <+1640>, cast: variable(u32))
.field u8And: uint8 (size: 1, offs: <+1644>, cast: variable(u32))
.field u8Ior: uint8 (size: 1, offs: <+1648>, cast: variable(u32))
.field u8Xor: uint8 (size: 1, offs: <+1652>, cast: variable(u32))
.field u8Shl: uint8 (size: 1, offs: <+1656>, cast: variable(u32))
.field u8Shr: uint8 (size: 1, offs: <+1660>, cast: variable(u32))
.field u8Not: bool (size: 1, offs: <+1664>, cast: variable(bool))
.field u8Ceq: bool (size: 1, offs: <+1668>, cast: variable(bool))
.field u8Cne: bool (size: 1, offs: <+1672>, cast: variable(bool))
.field u8Clt: bool (size: 1, offs: <+1676>, cast: variable(bool))
.field u8Cle: bool (size: 1, offs: <+1680>, cast: variable(bool))
.field u8Cgt: bool (size: 1, offs: <+1684>, cast: variable(bool))
.field u8Cge: bool (size: 1, offs: <+1688>, cast: variable(bool))
.field i16A: int16 (size: 2, offs: <+1692>, cast: variable(i32))
.field i16B: int16 (size: 2, offs: <+1696>, cast: variable(i32))
.field i16Pls: int16 (size: 2, offs: <+1700>, cast: variable(i32))
.field i16Neg: int16 (size: 2, offs: <+1704>, cast: variable(i32))
.field i16Cmt: int16 (size: 2, offs: <+1708>, cast: variable(i32))
.field i16Add: int16 (size: 2, offs: <+1712>, cast: variable(i32))
.field i16Sub: int16 (size: 2, offs: <+1716>, cast: variable(i32))
.field i16Mul: int16 (size: 2, offs: <+1720>, cast: variable(i32))
.field i16Div: int16 (size: 2, offs: <+1724>, cast: variable(i32))
.field i16Mod: int16 (size: 2, offs: <+1728>, cast: variable(i32))
.field i16And: int16 (size: 2, offs: <+1732>, cast: variable(i32))
.field i16Ior: int16 (size: 2, offs: <+1736>, cast: variable(i32))
.field i16Xor: int16 (size: 2, offs: <+1740>, cast: variable(i32))
.field i16Shl: int16 (size: 2, offs: <+1744>, cast: variable(i32))
.field i16Shr: int16 (size: 2, offs: <+1748>, cast: variable(i32))
.field i16Not: bool (size: 1, offs: <+1752>, cast: variable(bool))
.field i16Ceq: bool (size: 1, offs: <+1756>, cast: variable(bool))
.field i16Cne: bool (size: 1, offs: <+1760>, cast: variable(bool))
.field i16Clt: bool (size: 1, offs: <+1764>, cast: variable(bool))
.field i16Cle: bool (size: 1, offs: <+1768>, cast: variable(bool))
.field i16Cgt: bool (size: 1, offs: <+1772>, cast: variable(bool))
.field i16Cge: bool (size: 1, offs: <+1776>, cast: variable(bool))
.field u16A: uint16 (size: 2, offs: <+1780>, cast: variable(u32))
.field u16B: uint16 (size: 2, offs: <+1784>, cast: variable(u32))
.field u16Pls: uint16 (size: 2, offs: <+1788>, cast: variable(u32))
.field u16Neg: uint16 (size: 2, offs: <+1792>, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <+1796>, cast: variable(u32))
.field u16Add: uint16 (size: 2, offs: <+1800>, cast: variable(u32))
.field u16Sub: uint16 (size: 2, offs: <+1804>, cast: variable(u32))
.field u16Mul: uint16 (size: 2, offs: <+1808>, cast: variable(u32))
.field u16Div: uint16 (size: 2, offs: <+1812>, cast: variable(u32))
.field u16Mod: uint16 (size: 2, offs: <+1816>, cast: variable(u32))
.field u16And: uint16 (size: 2, offs: <+1820>, cast: variable(u32))
.field u16Ior: uint16 (size: 2, offs: <+1824>, cast: variable(u32))
.field u16Xor: uint16 (size: 2, offs: <+1828>, cast: variable(u32))
.field u16Shl: uint16 (size: 2, offs: <+1832>, cast: variable(u32))
.field u16Shr: uint16 (size: 2, offs: <+1836>, cast: variable(u32))
.field u16Not: bool (size: 1, offs: <+1840>, cast: variable(bool))
.field u16Ceq: bool (size: 1, offs: <+1844>, cast: variable(bool))
.field u16Cne: bool (size: 1, offs: <+1848>, cast: variable(bool))
.field u16Clt: bool (size: 1, offs: <+1852>, cast: variable(bool))
.field u16Cle: bool (size: 1, offs: <+1856>, cast: variable(bool))
.field u16Cgt: bool (size: 1, offs: <+1860>, cast: variable(bool))
.field u16Cge: bool (size: 1, offs: <+1864>, cast: variable(bool))
.field i32A: int32 (size: 4, offs: <+1868>, cast: variable(i32))
.field i32B: int32 (size: 4, offs: <+1872>, cast: variable(i32))
.field i32Pls: int32 (size: 4, offs: <+1876>, cast: variable(i32))
.field i32Neg: int32 (size: 4, offs: <+1880>, cast: variable(i32))
.field i32Cmt: int32 (size: 4, offs: <+1884>, cast: variable(i32))
.field i32Add: int32 (size: 4, offs: <+1888>, cast: variable(i32))
.field i32Sub: int32 (size: 4, offs: <+1892>, cast: variable(i32))
.field i32Mul: int32 (size: 4, offs: <+1896>, cast: variable(i32))
.field i32Div: int32 (size: 4, offs: <+1900>, cast: variable(i32))
.field i32Mod: int32 (size: 4, offs: <+1904>, cast: variable(i32))
.field i32And: int32 (size: 4, offs: <+1908>, cast: variable(i32))
.field i32Ior: int32 (size: 4, offs: <+1912>, cast: variable(i32))
.field i32Xor: int32 (size: 4, offs: <+1916>, cast: variable(i32))
.field i32Shl: int32 (size: 4, offs: <+1920>, cast: variable(i32))
.field i32Shr: int32 (size: 4, offs: <+1924>, cast: variable(i32))
.field i32Not: bool (size: 1, offs: <+1928>, cast: variable(bool))
.field i32Ceq: bool (size: 1, offs: <+1932>, cast: variable(bool))
.field i32Cne: bool (size: 1, offs: <+1936>, cast: variable(bool))
.field i32Clt: bool (size: 1, offs: <+1940>, cast: variable(bool))
.field i32Cle: bool (size: 1, offs: <+1944>, cast: variable(bool))
.field i32Cgt: bool (size: 1, offs: <+1948>, cast: variable(bool))
.field i32Cge: bool (size: 1, offs: <+1952>, cast: variable(bool))
.field u32A: uint32 (size: 4, offs: <+1956>, cast: variable(u32))
.field u32B: uint32 (size: 4, offs: <+1960>, cast: variable(u32))
.field u32Pls: uint32 (size: 4, offs: <+1964>, cast: variable(u32))
.field u32Neg: uint32 (size: 4, offs: <+1968>, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <+1972>, cast: variable(u32))
.field u32Add: uint32 (size: 4, offs: <+1976>, cast: variable(u32))
.field u32Sub: uint32 (size: 4, offs: <+1980>, cast: variable(u32))
.field u32Mul: uint32 (size: 4, offs: <+1984>, cast: variable(u32))
.field u32Div: uint32 (size: 4, offs: <+1988>, cast: variable(u32))
.field u32Mod: uint32 (size: 4, offs: <+1992>, cast: variable(u32))
.field u32And: uint32 (size: 4, offs: <+1996>, cast: variable(u32))
.field u32Ior: uint32 (size: 4, offs: <+2000>, cast: variable(u32))
.field u32Xor: uint32 (size: 4, offs: <+2004>, cast: variable(u32))
.field u32Shl: uint32 (size: 4, offs: <+2008>, cast: variable(u32))
.field u32Shr: uint32 (size: 4, offs: <+2012>, cast: variable(u32))
.field u32Not: bool (size: 1, offs: <+2016>, cast: variable(bool))
.field u32Ceq: bool (size: 1, offs: <+2020>, cast: variable(bool))
.field u32Cne: bool (size: 1, offs: <+2024>, cast: variable(bool))
.field u32Clt: bool (size: 1, offs: <+2028>, cast: variable(bool))
.field u32Cle: bool (size: 1, offs: <+2032>, cast: variable(bool))
.field u32Cgt: bool (size: 1, offs: <+2036>, cast: variable(bool))
.field u32Cge: bool (size: 1, offs: <+2040>, cast: variable(bool))
.field i64A: int64 (size: 8, offs: <+2048>, cast: variable(i64))
.field i64B: int64 (size: 8, offs: <+2056>, cast: variable(i64))
.field i64Pls: int64 (size: 8, offs: <+2064>, cast: variable(i64))
.field i64Neg: int64 (size: 8, offs: <+2072>, cast: variable(i64))
.field i64Cmt: int64 (size: 8, offs: <+2080>, cast: variable(i64))
.field i64Add: int64 (size: 8, offs: <+2088>, cast: variable(i64))
.field i64Sub: int64 (size: 8, offs: <+2096>, cast: variable(i64))
.field i64Mul: int64 (size: 8, offs: <+2104>, cast: variable(i64))
.field i64Div: int64 (size: 8, offs: <+2112>, cast: variable(i64))
.field i64Mod: int64 (size: 8, offs: <+2120>, cast: variable(i64))
.field i64And: int64 (size: 8, offs: <+2128>, cast: variable(i64))
.field i64Ior: int64 (size: 8, offs: <+2136>, cast: variable(i64))
.field i64Xor: int64 (size: 8, offs: <+2144>, cast: variable(i64))
.field i64Shl: int64 (size: 8, offs: <+2152>, cast: variable(i64))
.field i64Shr: int64 (size: 8, offs: <+2160>, cast: variable(i64))
.field i64Not: bool (size: 1, offs: <+2164>, cast: variable(bool))
.field i64Ceq: bool (size: 1, offs: <+2168>, cast: variable(bool))
.field i64Cne: bool (size: 1, offs: <+2172>, cast: variable(bool))
.field i64Clt: bool (size: 1, offs: <+2176>, cast: variable(bool))
.field i64Cle: bool (size: 1, offs: <+2180>, cast: variable(bool))
.field i64Cgt: bool (size: 1, offs: <+2184>, cast: variable(bool))
.field i64Cge: bool (size: 1, offs: <+2188>, cast: variable(bool))
.field u64A: uint64 (size: 8, offs: <+2196>, cast: variable(u64))
.field u64B: uint64 (size: 8, offs: <+2204>, cast: variable(u64))
.field u64Pls: uint64 (size: 8, offs: <+2212>, cast: variable(u64))
.field u64Neg: uint64 (size: 8, offs: <+2220>, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <+2228>, cast: variable(u64))
.field u64Add: uint64 (size: 8, offs: <+2236>, cast: variable(u64))
.field u64Sub: uint64 (size: 8, offs: <+2244>, cast: variable(u64))
.field u64Mul: uint64 (size: 8, offs: <+2252>, cast: variable(u64))
.field u64Div: uint64 (size: 8, offs: <+2260>, cast: variable(u64))
.field u64Mod: uint64 (size: 8, offs: <+2268>, cast: variable(u64))
.field u64And: uint64 (size: 8, offs: <+2276>, cast: variable(u64))
.field u64Ior: uint64 (size: 8, offs: <+2284>, cast: variable(u64))
.field u64Xor: uint64 (size: 8, offs: <+2292>, cast: variable(u64))
.field u64Shl: uint64 (size: 8, offs: <+2300>, cast: variable(u64))
.field u64Shr: uint64 (size: 8, offs: <+2308>, cast: variable(u64))
.field u64Not: bool (size: 1, offs: <+2312>, cast: variable(bool))
.field u64Ceq: bool (size: 1, offs: <+2316>, cast: variable(bool))
.field u64Cne: bool (size: 1, offs: <+2320>, cast: variable(bool))
.field u64Clt: bool (size: 1, offs: <+2324>, cast: variable(bool))
.field u64Cle: bool (size: 1, offs: <+2328>, cast: variable(bool))
.field u64Cgt: bool (size: 1, offs: <+2332>, cast: variable(bool))
.field u64Cge: bool (size: 1, offs: <+2336>, cast: variable(bool))
.field f32A: float32 (size: 4, offs: <+2340>, cast: variable(f32))
.field f32B: float32 (size: 4, offs: <+2344>, cast: variable(f32))
.field f32Pls: float32 (size: 4, offs: <+2348>, cast: variable(f32))
.field f32Neg: float32 (size: 4, offs: <+2352>, cast: variable(f32))
.field f32Add: float32 (size: 4, offs: <+2356>, cast: variable(f32))
.field f32Sub: float32 (size: 4, offs: <+2360>, cast: variable(f32))
.field f32Mul: float32 (size: 4, offs: <+2364>, cast: variable(f32))
.field f32Div: float32 (size: 4, offs: <+2368>, cast: variable(f32))
.field f32Mod: float32 (size: 4, offs: <+2372>, cast: variable(f32))
.field f32Not: bool (size: 1, offs: <+2376>, cast: variable(bool))
.field f32Ceq: bool (size: 1, offs: <+2380>, cast: variable(bool))
.field f32Cne: bool (size: 1, offs: <+2384>, cast: variable(bool))
.field f32Clt: bool (size: 1, offs: <+2388>, cast: variable(bool))
.field f32Cle: bool (size: 1, offs: <+2392>, cast: variable(bool))
.field f32Cgt: bool (size: 1, offs: <+2396>, cast: variable(bool))
.field f32Cge: bool (size: 1, offs: <+2400>, cast: variable(bool))
.field f64A: float64 (size: 8, offs: <+2408>, cast: variable(f64))
.field f64B: float64 (size: 8, offs: <+2416>, cast: variable(f64))
.field f64Pls: float64 (size: 8, offs: <+2424>, cast: variable(f64))
.field f64Neg: float64 (size: 8, offs: <+2432>, cast: variable(f64))
.field f64Add: float64 (size: 8, offs: <+2440>, cast: variable(f64))
.field f64Sub: float64 (size: 8, offs: <+2448>, cast: variable(f64))
.field f64Mul: float64 (size: 8, offs: <+2456>, cast: variable(f64))
.field f64Div: float64 (size: 8, offs: <+2464>, cast: variable(f64))
.field f64Mod: float64 (size: 8, offs: <+2472>, cast: variable(f64))
.field f64Not: bool (size: 1, offs: <+2476>, cast: variable(bool))
.field f64Ceq: bool (size: 1, offs: <+2480>, cast: variable(bool))
.field f64Cne: bool (size: 1, offs: <+2484>, cast: variable(bool))
.field f64Clt: bool (size: 1, offs: <+2488>, cast: variable(bool))
.field f64Cle: bool (size: 1, offs: <+2492>, cast: variable(bool))
.field f64Cgt: bool (size: 1, offs: <+2496>, cast: variable(bool))
.field f64Cge: bool (size: 1, offs: <+2500>, cast: variable(bool))
.field ptrA: pointer (size: 4, offs: <+2504>, cast: variable(ref))
.field ptrB: pointer (size: 4, offs: <+2508>, cast: variable(ref))
.field ptrCeq: bool (size: 1, offs: <+2512>, cast: variable(bool))
.field ptrCne: bool (size: 1, offs: <+2516>, cast: variable(bool))
.field t: int32 (size: 4, offs: <+2520>, cast: variable(i32))
.field forIdx: int32 (size: 4, offs: <+2524>, cast: variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <+2532>, cast: variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <+2540>, cast: variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <+2548>, cast: variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <+2556>, cast: variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <+2564>, cast: variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <+2572>, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <+2580>, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <+2588>, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <+2596>, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <+2604>, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <+2612>, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <+2620>, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <+2628>, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <+2636>, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <+2644>, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <+2652>, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <+2660>, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <+2668>, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <+2676>, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <+2684>, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <+2692>, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <+2700>, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <+2708>, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <+2716>, cast: variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <+2724>, cast: variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <+2732>, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <+2740>, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <+2748>, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <+2756>, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <+2764>, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <+2772>, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <+2780>, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <+2788>, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <+2796>, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <+2804>, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <+2812>, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <+2820>, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <+2828>, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <+2836>, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <+2844>, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <+2852>, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <+2860>, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <+2868>, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <+2876>, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <+2884>, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <+2892>, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <+2900>, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <+2908>, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <+2916>, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <+2924>, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <+2932>, cast: variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <+2936>, cast: variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <+2940>, cast: variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <+2948>, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <+2956>, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <+2964>, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <+2972>, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <+2980>, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <+2988>, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <+2996>, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <+3004>, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <+3012>, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <+3020>, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <+3028>, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <+3032>, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <+3036>, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <+3040>, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <+3044>, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <+3048>, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <+3052>, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <+3056>, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <+3060>, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <+3064>, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <+3068>, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <+3072>, cast: variable(f32))
.field .main: function (size: 10884, offs: <@05105f>, cast: static function)
.value: {
	{
		static if (bool(typename(raise) == function)) {
			verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := float64(1.000000 / ln2);
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := float64(1.000000 / ln10);
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := float64((0) / 0.000000);
			static const inf: float64 := float64((1) / 0.000000);
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(void(int32(3), pointer("string")));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := int32(a + b);
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(void(3, 6));
		zeroVar: int32 := zero(void(i3, i6));
		zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		lastVal: int32 := last(void(3, 6));
		lastVar: int32 := last(void(i3, i6));
		lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sum2Val: int32 := sum(void(3, 6));
		sum2Var: int32 := sum(void(i3, i6));
		sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		any2Val: int32 := any(void(3, 6));
		any2Var: int32 := any(void(i3, i6));
		any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		min2Val: int32 := min(void(3, 6));
		min2Var: int32 := min(void(i3, i6));
		min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		max2Val: int32 := max(void(3, 6));
		max2Var: int32 := max(void(i3, i6));
		max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		funAddResult: int32 := funAdd(void(2, 7));
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(void(2, 8));
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(void(2, 6));
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		r_comp: int32 := int32(14 << 3);
		g_comp: int32 := int32(63 << 2);
		b_comp: int32 := int32(31 << 3);
		r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		testExp_f64: float64 := float64.exp(1.000000);
		testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		testExp_f32: float32 := float32.exp(1.000000);
		testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		testPopulation_u32: int32 := uint32.pop(r5g6b5);
		testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		testHighBit_u32: int32 := uint32.hib(r5g6b5);
		testLowBit_u32: int32 := uint32.lob(r5g6b5);
		testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		malloc(size: int32): pointer := pointer.alloc(void(null, size));
		free(data: pointer): pointer := pointer.alloc(void(data, 0));
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		tryExecErr0: int32 := tryExec(void(null, noError));
		tryExecErr1: int32 := tryExec(void(null, null));
		tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		cyan: color := {
			void(cyan.col := (65535));
		};
		blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := bool(!false);
		boolAnd: bool := bool(boolA & boolB);
		boolIor: bool := bool(boolA | boolB);
		boolXor: bool := bool(boolA ^ boolB);
		boolNot: bool := bool(!boolB);
		boolCeq: bool := bool(boolA == boolB);
		boolCne: bool := bool(boolA != boolB);
		boolClt: bool := bool(boolA < boolB);
		boolCle: bool := bool(boolA <= boolB);
		boolCgt: bool := bool(boolA > boolB);
		boolCge: bool := bool(boolA >= boolB);
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := char(+chrB);
		chrNeg: char := char(-chrB);
		chrCmt: char := char(~chrB);
		chrAdd: char := char(chrA + chrB);
		chrSub: char := char(chrA - chrB);
		chrMul: char := char(chrA * chrB);
		chrDiv: char := char(chrA / chrB);
		chrMod: char := char(chrA % chrB);
		chrAnd: char := char(chrA & chrB);
		chrIor: char := char(chrA | chrB);
		chrXor: char := char(chrA ^ chrB);
		chrShl: char := int32((chrA) << shift);
		chrShr: char := int32((chrA) >> shift);
		chrNot: bool := bool(!(chrB));
		chrCeq: bool := bool(chrA == chrB);
		chrCne: bool := bool(chrA != chrB);
		chrClt: bool := bool(chrA < chrB);
		chrCle: bool := bool(chrA <= chrB);
		chrCgt: bool := bool(chrA > chrB);
		chrCge: bool := bool(chrA >= chrB);
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := int8(+i8B);
		i8Neg: int8 := int8(-i8B);
		i8Cmt: int8 := int8(~i8B);
		i8Add: int8 := int8(i8A + i8B);
		i8Sub: int8 := int8(i8A - i8B);
		i8Mul: int8 := int8(i8A * i8B);
		i8Div: int8 := int8(i8A / i8B);
		i8Mod: int8 := int8(i8A % i8B);
		i8And: int8 := int8(i8A & i8B);
		i8Ior: int8 := int8(i8A | i8B);
		i8Xor: int8 := int8(i8A ^ i8B);
		i8Shl: int8 := int32((i8A) << shift);
		i8Shr: int8 := int32((i8A) >> shift);
		i8Not: bool := bool(!(i8B));
		i8Ceq: bool := bool(i8A == i8B);
		i8Cne: bool := bool(i8A != i8B);
		i8Clt: bool := bool(i8A < i8B);
		i8Cle: bool := bool(i8A <= i8B);
		i8Cgt: bool := bool(i8A > i8B);
		i8Cge: bool := bool(i8A >= i8B);
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := uint8(+u8B);
		u8Neg: uint8 := uint8(-u8B);
		u8Cmt: uint8 := uint8(~u8B);
		u8Add: uint8 := uint8(u8A + u8B);
		u8Sub: uint8 := uint8(u8A - u8B);
		u8Mul: uint8 := uint8(u8A * u8B);
		u8Div: uint8 := uint8(u8A / u8B);
		u8Mod: uint8 := uint8(u8A % u8B);
		u8And: uint8 := uint8(u8A & u8B);
		u8Ior: uint8 := uint8(u8A | u8B);
		u8Xor: uint8 := uint8(u8A ^ u8B);
		u8Shl: uint8 := int32((u8A) << shift);
		u8Shr: uint8 := int32((u8A) >> shift);
		u8Not: bool := bool(!(u8B));
		u8Ceq: bool := bool(u8A == u8B);
		u8Cne: bool := bool(u8A != u8B);
		u8Clt: bool := bool(u8A < u8B);
		u8Cle: bool := bool(u8A <= u8B);
		u8Cgt: bool := bool(u8A > u8B);
		u8Cge: bool := bool(u8A >= u8B);
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := int16(+i16B);
		i16Neg: int16 := int16(-i16B);
		i16Cmt: int16 := int16(~i16B);
		i16Add: int16 := int16(i16A + i16B);
		i16Sub: int16 := int16(i16A - i16B);
		i16Mul: int16 := int16(i16A * i16B);
		i16Div: int16 := int16(i16A / i16B);
		i16Mod: int16 := int16(i16A % i16B);
		i16And: int16 := int16(i16A & i16B);
		i16Ior: int16 := int16(i16A | i16B);
		i16Xor: int16 := int16(i16A ^ i16B);
		i16Shl: int16 := int32((i16A) << shift);
		i16Shr: int16 := int32((i16A) >> shift);
		i16Not: bool := bool(!(i16B));
		i16Ceq: bool := bool(i16A == i16B);
		i16Cne: bool := bool(i16A != i16B);
		i16Clt: bool := bool(i16A < i16B);
		i16Cle: bool := bool(i16A <= i16B);
		i16Cgt: bool := bool(i16A > i16B);
		i16Cge: bool := bool(i16A >= i16B);
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := uint16(+u16B);
		u16Neg: uint16 := uint16(-u16B);
		u16Cmt: uint16 := uint16(~u16B);
		u16Add: uint16 := uint16(u16A + u16B);
		u16Sub: uint16 := uint16(u16A - u16B);
		u16Mul: uint16 := uint16(u16A * u16B);
		u16Div: uint16 := uint16(u16A / u16B);
		u16Mod: uint16 := uint16(u16A % u16B);
		u16And: uint16 := uint16(u16A & u16B);
		u16Ior: uint16 := uint16(u16A | u16B);
		u16Xor: uint16 := uint16(u16A ^ u16B);
		u16Shl: uint16 := int32((u16A) << shift);
		u16Shr: uint16 := int32((u16A) >> shift);
		u16Not: bool := bool(!(u16B));
		u16Ceq: bool := bool(u16A == u16B);
		u16Cne: bool := bool(u16A != u16B);
		u16Clt: bool := bool(u16A < u16B);
		u16Cle: bool := bool(u16A <= u16B);
		u16Cgt: bool := bool(u16A > u16B);
		u16Cge: bool := bool(u16A >= u16B);
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := int32(+i32B);
		i32Neg: int32 := int32(-i32B);
		i32Cmt: int32 := int32(~i32B);
		i32Add: int32 := int32(i32A + i32B);
		i32Sub: int32 := int32(i32A - i32B);
		i32Mul: int32 := int32(i32A * i32B);
		i32Div: int32 := int32(i32A / i32B);
		i32Mod: int32 := int32(i32A % i32B);
		i32And: int32 := int32(i32A & i32B);
		i32Ior: int32 := int32(i32A | i32B);
		i32Xor: int32 := int32(i32A ^ i32B);
		i32Shl: int32 := int32(i32A << shift);
		i32Shr: int32 := int32(i32A >> shift);
		i32Not: bool := bool(!(i32B));
		i32Ceq: bool := bool(i32A == i32B);
		i32Cne: bool := bool(i32A != i32B);
		i32Clt: bool := bool(i32A < i32B);
		i32Cle: bool := bool(i32A <= i32B);
		i32Cgt: bool := bool(i32A > i32B);
		i32Cge: bool := bool(i32A >= i32B);
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := uint32(+u32B);
		u32Neg: uint32 := uint32(-u32B);
		u32Cmt: uint32 := uint32(~u32B);
		u32Add: uint32 := uint32(u32A + u32B);
		u32Sub: uint32 := uint32(u32A - u32B);
		u32Mul: uint32 := uint32(u32A * u32B);
		u32Div: uint32 := uint32(u32A / u32B);
		u32Mod: uint32 := uint32(u32A % u32B);
		u32And: uint32 := uint32(u32A & u32B);
		u32Ior: uint32 := uint32(u32A | u32B);
		u32Xor: uint32 := uint32(u32A ^ u32B);
		u32Shl: uint32 := uint32(u32A << shift);
		u32Shr: uint32 := uint32(u32A >> shift);
		u32Not: bool := bool(!(u32B));
		u32Ceq: bool := bool(u32A == u32B);
		u32Cne: bool := bool(u32A != u32B);
		u32Clt: bool := bool(u32A < u32B);
		u32Cle: bool := bool(u32A <= u32B);
		u32Cgt: bool := bool(u32A > u32B);
		u32Cge: bool := bool(u32A >= u32B);
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := int64(+i64B);
		i64Neg: int64 := int64(-i64B);
		i64Cmt: int64 := int64(~i64B);
		i64Add: int64 := int64(i64A + i64B);
		i64Sub: int64 := int64(i64A - i64B);
		i64Mul: int64 := int64(i64A * i64B);
		i64Div: int64 := int64(i64A / i64B);
		i64Mod: int64 := int64(i64A % i64B);
		i64And: int64 := int64(i64A & i64B);
		i64Ior: int64 := int64(i64A | i64B);
		i64Xor: int64 := int64(i64A ^ i64B);
		i64Shl: int64 := int64(i64A << shift);
		i64Shr: int64 := int64(i64A >> shift);
		i64Not: bool := bool(!(i64B));
		i64Ceq: bool := bool(i64A == i64B);
		i64Cne: bool := bool(i64A != i64B);
		i64Clt: bool := bool(i64A < i64B);
		i64Cle: bool := bool(i64A <= i64B);
		i64Cgt: bool := bool(i64A > i64B);
		i64Cge: bool := bool(i64A >= i64B);
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := uint64(+u64B);
		u64Neg: uint64 := uint64(-u64B);
		u64Cmt: uint64 := uint64(~u64B);
		u64Add: uint64 := uint64(u64A + u64B);
		u64Sub: uint64 := uint64(u64A - u64B);
		u64Mul: uint64 := uint64(u64A * u64B);
		u64Div: uint64 := uint64(u64A / u64B);
		u64Mod: uint64 := uint64(u64A % u64B);
		u64And: uint64 := uint64(u64A & u64B);
		u64Ior: uint64 := uint64(u64A | u64B);
		u64Xor: uint64 := uint64(u64A ^ u64B);
		u64Shl: uint64 := uint64(u64A << shift);
		u64Shr: uint64 := uint64(u64A >> shift);
		u64Not: bool := bool(!(u64B));
		u64Ceq: bool := bool(u64A == u64B);
		u64Cne: bool := bool(u64A != u64B);
		u64Clt: bool := bool(u64A < u64B);
		u64Cle: bool := bool(u64A <= u64B);
		u64Cgt: bool := bool(u64A > u64B);
		u64Cge: bool := bool(u64A >= u64B);
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := float32(+f32B);
		f32Neg: float32 := float32(-f32B);
		f32Add: float32 := float32(f32A + f32B);
		f32Sub: float32 := float32(f32A - f32B);
		f32Mul: float32 := float32(f32A * f32B);
		f32Div: float32 := float32(f32A / f32B);
		f32Mod: float32 := float32(f32A % f32B);
		f32Not: bool := bool(!(f32B));
		f32Ceq: bool := bool(f32A == f32B);
		f32Cne: bool := bool(f32A != f32B);
		f32Clt: bool := bool(f32A < f32B);
		f32Cle: bool := bool(f32A <= f32B);
		f32Cgt: bool := bool(f32A > f32B);
		f32Cge: bool := bool(f32A >= f32B);
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := float64(+f64B);
		f64Neg: float64 := float64(-f64B);
		f64Add: float64 := float64(f64A + f64B);
		f64Sub: float64 := float64(f64A - f64B);
		f64Mul: float64 := float64(f64A * f64B);
		f64Div: float64 := float64(f64A / f64B);
		f64Mod: float64 := float64(f64A % f64B);
		f64Not: bool := bool(!(f64B));
		f64Ceq: bool := bool(f64A == f64B);
		f64Cne: bool := bool(f64A != f64B);
		f64Clt: bool := bool(f64A < f64B);
		f64Cle: bool := bool(f64A <= f64B);
		f64Cgt: bool := bool(f64A > f64B);
		f64Cge: bool := bool(f64A >= f64B);
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := bool(ptrA == ptrB);
		ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		testMathFloor_1: float64 := Math.floor(3.200000);
		testMathFloor_2: float64 := Math.floor(3.500000);
		testMathFloor_3: float64 := Math.floor(3.600000);
		testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(void(1, 2));
		testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (10884 bytes: <@05105f> - <@053ae3>)
	lib/std/string.ci:144: (14 bytes: <@05105f> - <@05106d>): static const whiteSpace: char[] := " \t\n\r"
	<.main @05105f>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @051064>    : 1f 12 f1 01 00             load.ref <@01f112> ;" \t\n\r"
	<.main+10 @051069>   : 2d a8 08 05                store.m64 <@0508a8> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@05106d> - <@05107b>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @05106d>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @051072>   : 1f 23 f1 01 00             load.ref <@01f123> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @051077>   : 2d b0 08 05                store.m64 <@0508b0> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@05107b> - <@051095>): static const format: FormatFlags := {...}
	<.main+28 @05107b>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @051080>   : 2e a0 0b 05                store.m32 <@050ba0> ;append.format
	:: (7 bytes: <@051084> - <@05108b>): void(format.padChr := (0))
	<.main+37 @051084>   : 19                         load.z32
	<.main+38 @051085>   : 1f a4 0b 05 00             load.ref <@050ba4> ;append.format+4
	<.main+43 @05108a>   : 25                         store.i8
	:: (5 bytes: <@05108b> - <@051090>): void(format.padLen := 0)
	<.main+44 @05108b>   : 19                         load.z32
	<.main+45 @05108c>   : 2e a8 0b 05                store.m32 <@050ba8> ;append.format+8
	:: (5 bytes: <@051090> - <@051095>): void(format.precision := 0)
	<.main+49 @051090>   : 19                         load.z32
	<.main+50 @051091>   : 2e ac 0b 05                store.m32 <@050bac> ;append.format+12
	test/lang/initByRef.ci:7: (13 bytes: <@051095> - <@0510a2>): static value: int64 := 42
	<.main+54 @051095>   : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+63 @05109e>   : 2d e0 0d 05                store.m64 <@050de0> ;value
	test/lang/member.ci:35: (5 bytes: <@0510a2> - <@0510a7>): static global: int32
	<.main+67 @0510a2>   : 19                         load.z32
	<.main+68 @0510a3>   : 2e 00 0f 05                store.m32 <@050f00> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@0510a7> - <@0510b0>): static globalInit: int32 := 1
	<.main+72 @0510a7>   : 1c 01 00 00 00             load.c32 1
	<.main+77 @0510ac>   : 2e 08 0f 05                store.m32 <@050f08> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@0510b0> - <@0510b9>): static const globalConstant: int32 := 2
	<.main+81 @0510b0>   : 1c 02 00 00 00             load.c32 2
	<.main+86 @0510b5>   : 2e 10 0f 05                store.m32 <@050f10> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@0510b9> - <@0510cb>): static globalRecInit: Inner := {...}
	<.main+90 @0510b9>   : 1c 04 00 00 00             load.c32 4
	<.main+95 @0510be>   : 2e 20 0f 05                store.m32 <@050f20> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@0510c2> - <@0510cb>): void(globalRecInit.constant := 5);
	<.main+99 @0510c2>   : 1c 05 00 00 00             load.c32 5
	<.main+104 @0510c7>  : 2e 24 0f 05                store.m32 <@050f24> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@0510cb> - <@0510dd>): static const globalConstantRec: Inner := {...}
	<.main+108 @0510cb>  : 1c 06 00 00 00             load.c32 6
	<.main+113 @0510d0>  : 2e 28 0f 05                store.m32 <@050f28> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@0510d4> - <@0510dd>): void(globalConstantRec.constant := 7);
	<.main+117 @0510d4>  : 1c 07 00 00 00             load.c32 7
	<.main+122 @0510d9>  : 2e 2c 0f 05                store.m32 <@050f2c> ;RecordMemberTest.globalConstantRec+4
	test/lang/method.ci:11: (9 bytes: <@0510dd> - <@0510e6>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+126 @0510dd>  : 1f 88 0f 05 00             load.ref <@050f88> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+131 @0510e2>  : 2e 58 0f 05                store.m32 <@050f58> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/emit.ci:3: (1 byte: <@0510e6> - <@0510e7>): emitldz32: int32 := emit(load.z32)
	<.main+135 @0510e6>  : 19                         load.z32
	test/lang/emit.ci:4: (1 byte: <@0510e7> - <@0510e8>): emitldz64: int64 := emit(load.z64)
	<.main+136 @0510e7>  : 1a                         load.z64
	test/lang/emit.ci:6: (5 bytes: <@0510e8> - <@0510ed>): emitA: int32 := 42
	<.main+137 @0510e8>  : 1c 2a 00 00 00             load.c32 42
	test/lang/emit.ci:7: (5 bytes: <@0510ed> - <@0510f2>): emitB: int32 := 96
	<.main+142 @0510ed>  : 1c 60 00 00 00             load.c32 96
	test/lang/emit.ci:9: (5 bytes: <@0510f2> - <@0510f7>): emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+147 @0510f2>  : 10 01                      dup.x1 sp(1)
	<.main+149 @0510f4>  : 10 01                      dup.x1 sp(1)
	<.main+151 @0510f6>  : 51                         add.i32
	test/lang/emit.ci:10: (11 bytes: <@0510f7> - <@051102>): emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+152 @0510f7>  : 1c 0a 00 00 00             load.c32 10
	<.main+157 @0510fc>  : 1c 05 00 00 00             load.c32 5
	<.main+162 @051101>  : 54                         div.i32
	test/lang/emit.ci:17: (5 bytes: <@051102> - <@051107>): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+163 @051102>  : 7f 00 00 fa 43             load.f32 500.000000
	test/lang/emit.ci:18: (6 bytes: <@051107> - <@05110d>): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+168 @051107>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+173 @05110c>  : 5c                         i32.2i64
	test/lang/emit.ci:19: (10 bytes: <@05110d> - <@051117>): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+174 @05110d>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+183 @051116>  : 6a                         i64.2i32
	test/lang/emit.ci:20: (9 bytes: <@051117> - <@051120>): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+184 @051117>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	test/lang/emit.ci:23: (10 bytes: <@051120> - <@05112a>): emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+193 @051120>  : 1c 03 00 00 00             load.c32 3
	<.main+198 @051125>  : 1f a4 b2 02 00             load.ref <@02b2a4> ;"string"
	test/lang/inlineMacros.ci:10: (5 bytes: <@05112a> - <@05112f>): i3: int32 := 3
	<.main+203 @05112a>  : 1c 03 00 00 00             load.c32 3
	test/lang/inlineMacros.ci:11: (5 bytes: <@05112f> - <@051134>): i6: int32 := 6
	<.main+208 @05112f>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:12: (5 bytes: <@051134> - <@051139>): i2: int32 := 2
	<.main+213 @051134>  : 1c 02 00 00 00             load.c32 2
	test/lang/inlineMacros.ci:13: (5 bytes: <@051139> - <@05113e>): i8: int32 := 8
	<.main+218 @051139>  : 1c 08 00 00 00             load.c32 8
	test/lang/inlineMacros.ci:15: (1 byte: <@05113e> - <@05113f>): zeroVal: int32 := zero(void(3, 6))
	<.main+223 @05113e>  : 19                         load.z32
	test/lang/inlineMacros.ci:16: (1 byte: <@05113f> - <@051140>): zeroVar: int32 := zero(void(i3, i6))
	<.main+224 @05113f>  : 19                         load.z32
	test/lang/inlineMacros.ci:17: (1 byte: <@051140> - <@051141>): zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+225 @051140>  : 19                         load.z32
	test/lang/inlineMacros.ci:19: (5 bytes: <@051141> - <@051146>): lastVal: int32 := last(void(3, 6))
	<.main+226 @051141>  : 1c 06 00 00 00             load.c32 6
	test/lang/inlineMacros.ci:20: (2 bytes: <@051146> - <@051148>): lastVar: int32 := last(void(i3, i6))
	<.main+231 @051146>  : 10 06                      dup.x1 sp(6)
	test/lang/inlineMacros.ci:21: (10 bytes: <@051148> - <@051152>): lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+233 @051148>  : 10 07                      dup.x1 sp(7)
	<.main+235 @05114a>  : 0c 01 00 00                inc.i32(+1)
	<.main+239 @05114e>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:23: (9 bytes: <@051152> - <@05115b>): sum2Val: int32 := sum(void(3, 6))
	<.main+243 @051152>  : 1c 03 00 00 00             load.c32 3
	<.main+248 @051157>  : 0c 06 00 00                inc.i32(+6)
	test/lang/inlineMacros.ci:24: (5 bytes: <@05115b> - <@051160>): sum2Var: int32 := sum(void(i3, i6))
	<.main+252 @05115b>  : 10 0a                      dup.x1 sp(10)
	<.main+254 @05115d>  : 10 0a                      dup.x1 sp(10)
	<.main+256 @05115f>  : 51                         add.i32
	test/lang/inlineMacros.ci:25: (17 bytes: <@051160> - <@051171>): sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+257 @051160>  : 10 0b                      dup.x1 sp(11)
	<.main+259 @051162>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @051166>  : 10 0b                      dup.x1 sp(11)
	<.main+265 @051168>  : 0c 01 00 00                inc.i32(+1)
	<.main+269 @05116c>  : 51                         add.i32
	<.main+270 @05116d>  : 0c fe ff ff                inc.i32(-2)
	test/lang/inlineMacros.ci:27: (24 bytes: <@051171> - <@051189>): any2Val: int32 := any(void(3, 6))
	<.main+274 @051171>  : 1c 03 00 00 00             load.c32 3
	<.main+279 @051176>  : 10 00                      dup.x1 sp(0)
	<.main+281 @051178>  : 06 0a 00 00                jz <.main+291 @051182>
	<.main+285 @05117c>  : 10 00                      dup.x1 sp(0)
	<.main+287 @05117e>  : 04 09 00 00                jmp <.main+296 @051187>
	<.main+291 @051182>  : 1c 06 00 00 00             load.c32 6
	<.main+296 @051187>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:28: (18 bytes: <@051189> - <@05119b>): any2Var: int32 := any(void(i3, i6))
	<.main+298 @051189>  : 10 0d                      dup.x1 sp(13)
	<.main+300 @05118b>  : 10 00                      dup.x1 sp(0)
	<.main+302 @05118d>  : 06 0a 00 00                jz <.main+312 @051197>
	<.main+306 @051191>  : 10 00                      dup.x1 sp(0)
	<.main+308 @051193>  : 04 06 00 00                jmp <.main+314 @051199>
	<.main+312 @051197>  : 10 0d                      dup.x1 sp(13)
	<.main+314 @051199>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:29: (30 bytes: <@05119b> - <@0511b9>): any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+316 @05119b>  : 10 0e                      dup.x1 sp(14)
	<.main+318 @05119d>  : 0c 01 00 00                inc.i32(+1)
	<.main+322 @0511a1>  : 10 00                      dup.x1 sp(0)
	<.main+324 @0511a3>  : 06 0a 00 00                jz <.main+334 @0511ad>
	<.main+328 @0511a7>  : 10 00                      dup.x1 sp(0)
	<.main+330 @0511a9>  : 04 0a 00 00                jmp <.main+340 @0511b3>
	<.main+334 @0511ad>  : 10 0e                      dup.x1 sp(14)
	<.main+336 @0511af>  : 0c 01 00 00                inc.i32(+1)
	<.main+340 @0511b3>  : 13 01                      set.x1 sp(1)
	<.main+342 @0511b5>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:31: (33 bytes: <@0511b9> - <@0511da>): min2Val: int32 := min(void(3, 6))
	<.main+346 @0511b9>  : 1c 03 00 00 00             load.c32 3
	<.main+351 @0511be>  : 1c 06 00 00 00             load.c32 6
	<.main+356 @0511c3>  : 10 01                      dup.x1 sp(1)
	<.main+358 @0511c5>  : 10 01                      dup.x1 sp(1)
	<.main+360 @0511c7>  : 58                         clt.i32
	<.main+361 @0511c8>  : 06 0a 00 00                jz <.main+371 @0511d2>
	<.main+365 @0511cc>  : 10 01                      dup.x1 sp(1)
	<.main+367 @0511ce>  : 04 06 00 00                jmp <.main+373 @0511d4>
	<.main+371 @0511d2>  : 10 00                      dup.x1 sp(0)
	<.main+373 @0511d4>  : 13 02                      set.x1 sp(2)
	<.main+375 @0511d6>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:32: (27 bytes: <@0511da> - <@0511f5>): min2Var: int32 := min(void(i3, i6))
	<.main+379 @0511da>  : 10 10                      dup.x1 sp(16)
	<.main+381 @0511dc>  : 10 10                      dup.x1 sp(16)
	<.main+383 @0511de>  : 10 01                      dup.x1 sp(1)
	<.main+385 @0511e0>  : 10 01                      dup.x1 sp(1)
	<.main+387 @0511e2>  : 58                         clt.i32
	<.main+388 @0511e3>  : 06 0a 00 00                jz <.main+398 @0511ed>
	<.main+392 @0511e7>  : 10 01                      dup.x1 sp(1)
	<.main+394 @0511e9>  : 04 06 00 00                jmp <.main+400 @0511ef>
	<.main+398 @0511ed>  : 10 00                      dup.x1 sp(0)
	<.main+400 @0511ef>  : 13 02                      set.x1 sp(2)
	<.main+402 @0511f1>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:33: (39 bytes: <@0511f5> - <@05121c>): min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+406 @0511f5>  : 10 11                      dup.x1 sp(17)
	<.main+408 @0511f7>  : 0c 01 00 00                inc.i32(+1)
	<.main+412 @0511fb>  : 10 11                      dup.x1 sp(17)
	<.main+414 @0511fd>  : 0c 01 00 00                inc.i32(+1)
	<.main+418 @051201>  : 10 01                      dup.x1 sp(1)
	<.main+420 @051203>  : 10 01                      dup.x1 sp(1)
	<.main+422 @051205>  : 58                         clt.i32
	<.main+423 @051206>  : 06 0a 00 00                jz <.main+433 @051210>
	<.main+427 @05120a>  : 10 01                      dup.x1 sp(1)
	<.main+429 @05120c>  : 04 06 00 00                jmp <.main+435 @051212>
	<.main+433 @051210>  : 10 00                      dup.x1 sp(0)
	<.main+435 @051212>  : 13 02                      set.x1 sp(2)
	<.main+437 @051214>  : 09 fc ff ff                inc.sp(-4)
	<.main+441 @051218>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:35: (33 bytes: <@05121c> - <@05123d>): max2Val: int32 := max(void(3, 6))
	<.main+445 @05121c>  : 1c 03 00 00 00             load.c32 3
	<.main+450 @051221>  : 1c 06 00 00 00             load.c32 6
	<.main+455 @051226>  : 10 01                      dup.x1 sp(1)
	<.main+457 @051228>  : 10 01                      dup.x1 sp(1)
	<.main+459 @05122a>  : 59                         cgt.i32
	<.main+460 @05122b>  : 06 0a 00 00                jz <.main+470 @051235>
	<.main+464 @05122f>  : 10 01                      dup.x1 sp(1)
	<.main+466 @051231>  : 04 06 00 00                jmp <.main+472 @051237>
	<.main+470 @051235>  : 10 00                      dup.x1 sp(0)
	<.main+472 @051237>  : 13 02                      set.x1 sp(2)
	<.main+474 @051239>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:36: (27 bytes: <@05123d> - <@051258>): max2Var: int32 := max(void(i3, i6))
	<.main+478 @05123d>  : 10 13                      dup.x1 sp(19)
	<.main+480 @05123f>  : 10 13                      dup.x1 sp(19)
	<.main+482 @051241>  : 10 01                      dup.x1 sp(1)
	<.main+484 @051243>  : 10 01                      dup.x1 sp(1)
	<.main+486 @051245>  : 59                         cgt.i32
	<.main+487 @051246>  : 06 0a 00 00                jz <.main+497 @051250>
	<.main+491 @05124a>  : 10 01                      dup.x1 sp(1)
	<.main+493 @05124c>  : 04 06 00 00                jmp <.main+499 @051252>
	<.main+497 @051250>  : 10 00                      dup.x1 sp(0)
	<.main+499 @051252>  : 13 02                      set.x1 sp(2)
	<.main+501 @051254>  : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:37: (39 bytes: <@051258> - <@05127f>): max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+505 @051258>  : 10 14                      dup.x1 sp(20)
	<.main+507 @05125a>  : 0c 01 00 00                inc.i32(+1)
	<.main+511 @05125e>  : 10 14                      dup.x1 sp(20)
	<.main+513 @051260>  : 0c 01 00 00                inc.i32(+1)
	<.main+517 @051264>  : 10 01                      dup.x1 sp(1)
	<.main+519 @051266>  : 10 01                      dup.x1 sp(1)
	<.main+521 @051268>  : 59                         cgt.i32
	<.main+522 @051269>  : 06 0a 00 00                jz <.main+532 @051273>
	<.main+526 @05126d>  : 10 01                      dup.x1 sp(1)
	<.main+528 @05126f>  : 04 06 00 00                jmp <.main+534 @051275>
	<.main+532 @051273>  : 10 00                      dup.x1 sp(0)
	<.main+534 @051275>  : 13 02                      set.x1 sp(2)
	<.main+536 @051277>  : 09 fc ff ff                inc.sp(-4)
	<.main+540 @05127b>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:41: (21 bytes: <@05127f> - <@051294>): sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+544 @05127f>  : 1c 03 00 00 00             load.c32 3
	<.main+549 @051284>  : 1c 06 00 00 00             load.c32 6
	<.main+554 @051289>  : 1c 02 00 00 00             load.c32 2
	<.main+559 @05128e>  : 0c 08 00 00                inc.i32(+8)
	<.main+563 @051292>  : 51                         add.i32
	<.main+564 @051293>  : 51                         add.i32
	test/lang/inlineMacros.ci:42: (17 bytes: <@051294> - <@0512a5>): sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+565 @051294>  : 1c 03 00 00 00             load.c32 3
	<.main+570 @051299>  : 0c 06 00 00                inc.i32(+6)
	<.main+574 @05129d>  : 0c 02 00 00                inc.i32(+2)
	<.main+578 @0512a1>  : 0c 08 00 00                inc.i32(+8)
	test/lang/inlineMacros.ci:43: (11 bytes: <@0512a5> - <@0512b0>): sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+582 @0512a5>  : 10 17                      dup.x1 sp(23)
	<.main+584 @0512a7>  : 10 17                      dup.x1 sp(23)
	<.main+586 @0512a9>  : 10 17                      dup.x1 sp(23)
	<.main+588 @0512ab>  : 10 17                      dup.x1 sp(23)
	<.main+590 @0512ad>  : 51                         add.i32
	<.main+591 @0512ae>  : 51                         add.i32
	<.main+592 @0512af>  : 51                         add.i32
	test/lang/inlineMacros.ci:44: (11 bytes: <@0512b0> - <@0512bb>): sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+593 @0512b0>  : 10 18                      dup.x1 sp(24)
	<.main+595 @0512b2>  : 10 18                      dup.x1 sp(24)
	<.main+597 @0512b4>  : 51                         add.i32
	<.main+598 @0512b5>  : 10 17                      dup.x1 sp(23)
	<.main+600 @0512b7>  : 51                         add.i32
	<.main+601 @0512b8>  : 10 16                      dup.x1 sp(22)
	<.main+603 @0512ba>  : 51                         add.i32
	test/lang/inlineMacros.ci:45: (31 bytes: <@0512bb> - <@0512da>): sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+604 @0512bb>  : 10 19                      dup.x1 sp(25)
	<.main+606 @0512bd>  : 0c 01 00 00                inc.i32(+1)
	<.main+610 @0512c1>  : 10 19                      dup.x1 sp(25)
	<.main+612 @0512c3>  : 0c 01 00 00                inc.i32(+1)
	<.main+616 @0512c7>  : 10 19                      dup.x1 sp(25)
	<.main+618 @0512c9>  : 0c 01 00 00                inc.i32(+1)
	<.main+622 @0512cd>  : 10 19                      dup.x1 sp(25)
	<.main+624 @0512cf>  : 0c 01 00 00                inc.i32(+1)
	<.main+628 @0512d3>  : 51                         add.i32
	<.main+629 @0512d4>  : 51                         add.i32
	<.main+630 @0512d5>  : 51                         add.i32
	<.main+631 @0512d6>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:46: (31 bytes: <@0512da> - <@0512f9>): sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+635 @0512da>  : 10 1a                      dup.x1 sp(26)
	<.main+637 @0512dc>  : 0c 01 00 00                inc.i32(+1)
	<.main+641 @0512e0>  : 10 1a                      dup.x1 sp(26)
	<.main+643 @0512e2>  : 0c 01 00 00                inc.i32(+1)
	<.main+647 @0512e6>  : 51                         add.i32
	<.main+648 @0512e7>  : 10 19                      dup.x1 sp(25)
	<.main+650 @0512e9>  : 0c 01 00 00                inc.i32(+1)
	<.main+654 @0512ed>  : 51                         add.i32
	<.main+655 @0512ee>  : 10 18                      dup.x1 sp(24)
	<.main+657 @0512f0>  : 0c 01 00 00                inc.i32(+1)
	<.main+661 @0512f4>  : 51                         add.i32
	<.main+662 @0512f5>  : 0c fc ff ff                inc.i32(-4)
	test/lang/inlineMacros.ci:50: (62 bytes: <@0512f9> - <@051337>): anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+666 @0512f9>  : 1c 03 00 00 00             load.c32 3
	<.main+671 @0512fe>  : 10 00                      dup.x1 sp(0)
	<.main+673 @051300>  : 06 0a 00 00                jz <.main+683 @05130a>
	<.main+677 @051304>  : 10 00                      dup.x1 sp(0)
	<.main+679 @051306>  : 04 2f 00 00                jmp <.main+726 @051335>
	<.main+683 @05130a>  : 1c 06 00 00 00             load.c32 6
	<.main+688 @05130f>  : 10 00                      dup.x1 sp(0)
	<.main+690 @051311>  : 06 0a 00 00                jz <.main+700 @05131b>
	<.main+694 @051315>  : 10 00                      dup.x1 sp(0)
	<.main+696 @051317>  : 04 1c 00 00                jmp <.main+724 @051333>
	<.main+700 @05131b>  : 1c 02 00 00 00             load.c32 2
	<.main+705 @051320>  : 10 00                      dup.x1 sp(0)
	<.main+707 @051322>  : 06 0a 00 00                jz <.main+717 @05132c>
	<.main+711 @051326>  : 10 00                      dup.x1 sp(0)
	<.main+713 @051328>  : 04 09 00 00                jmp <.main+722 @051331>
	<.main+717 @05132c>  : 1c 08 00 00 00             load.c32 8
	<.main+722 @051331>  : 13 01                      set.x1 sp(1)
	<.main+724 @051333>  : 13 01                      set.x1 sp(1)
	<.main+726 @051335>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:51: (62 bytes: <@051337> - <@051375>): anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+728 @051337>  : 1c 03 00 00 00             load.c32 3
	<.main+733 @05133c>  : 10 00                      dup.x1 sp(0)
	<.main+735 @05133e>  : 06 0a 00 00                jz <.main+745 @051348>
	<.main+739 @051342>  : 10 00                      dup.x1 sp(0)
	<.main+741 @051344>  : 04 09 00 00                jmp <.main+750 @05134d>
	<.main+745 @051348>  : 1c 06 00 00 00             load.c32 6
	<.main+750 @05134d>  : 13 01                      set.x1 sp(1)
	<.main+752 @05134f>  : 10 00                      dup.x1 sp(0)
	<.main+754 @051351>  : 06 0a 00 00                jz <.main+764 @05135b>
	<.main+758 @051355>  : 10 00                      dup.x1 sp(0)
	<.main+760 @051357>  : 04 09 00 00                jmp <.main+769 @051360>
	<.main+764 @05135b>  : 1c 02 00 00 00             load.c32 2
	<.main+769 @051360>  : 13 01                      set.x1 sp(1)
	<.main+771 @051362>  : 10 00                      dup.x1 sp(0)
	<.main+773 @051364>  : 06 0a 00 00                jz <.main+783 @05136e>
	<.main+777 @051368>  : 10 00                      dup.x1 sp(0)
	<.main+779 @05136a>  : 04 09 00 00                jmp <.main+788 @051373>
	<.main+783 @05136e>  : 1c 08 00 00 00             load.c32 8
	<.main+788 @051373>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:52: (50 bytes: <@051375> - <@0513a7>): anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+790 @051375>  : 10 1d                      dup.x1 sp(29)
	<.main+792 @051377>  : 10 00                      dup.x1 sp(0)
	<.main+794 @051379>  : 06 0a 00 00                jz <.main+804 @051383>
	<.main+798 @05137d>  : 10 00                      dup.x1 sp(0)
	<.main+800 @05137f>  : 04 26 00 00                jmp <.main+838 @0513a5>
	<.main+804 @051383>  : 10 1d                      dup.x1 sp(29)
	<.main+806 @051385>  : 10 00                      dup.x1 sp(0)
	<.main+808 @051387>  : 06 0a 00 00                jz <.main+818 @051391>
	<.main+812 @05138b>  : 10 00                      dup.x1 sp(0)
	<.main+814 @05138d>  : 04 16 00 00                jmp <.main+836 @0513a3>
	<.main+818 @051391>  : 10 1d                      dup.x1 sp(29)
	<.main+820 @051393>  : 10 00                      dup.x1 sp(0)
	<.main+822 @051395>  : 06 0a 00 00                jz <.main+832 @05139f>
	<.main+826 @051399>  : 10 00                      dup.x1 sp(0)
	<.main+828 @05139b>  : 04 06 00 00                jmp <.main+834 @0513a1>
	<.main+832 @05139f>  : 10 1d                      dup.x1 sp(29)
	<.main+834 @0513a1>  : 13 01                      set.x1 sp(1)
	<.main+836 @0513a3>  : 13 01                      set.x1 sp(1)
	<.main+838 @0513a5>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:53: (50 bytes: <@0513a7> - <@0513d9>): anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+840 @0513a7>  : 10 1e                      dup.x1 sp(30)
	<.main+842 @0513a9>  : 10 00                      dup.x1 sp(0)
	<.main+844 @0513ab>  : 06 0a 00 00                jz <.main+854 @0513b5>
	<.main+848 @0513af>  : 10 00                      dup.x1 sp(0)
	<.main+850 @0513b1>  : 04 06 00 00                jmp <.main+856 @0513b7>
	<.main+854 @0513b5>  : 10 1e                      dup.x1 sp(30)
	<.main+856 @0513b7>  : 13 01                      set.x1 sp(1)
	<.main+858 @0513b9>  : 10 00                      dup.x1 sp(0)
	<.main+860 @0513bb>  : 06 0a 00 00                jz <.main+870 @0513c5>
	<.main+864 @0513bf>  : 10 00                      dup.x1 sp(0)
	<.main+866 @0513c1>  : 04 06 00 00                jmp <.main+872 @0513c7>
	<.main+870 @0513c5>  : 10 1d                      dup.x1 sp(29)
	<.main+872 @0513c7>  : 13 01                      set.x1 sp(1)
	<.main+874 @0513c9>  : 10 00                      dup.x1 sp(0)
	<.main+876 @0513cb>  : 06 0a 00 00                jz <.main+886 @0513d5>
	<.main+880 @0513cf>  : 10 00                      dup.x1 sp(0)
	<.main+882 @0513d1>  : 04 06 00 00                jmp <.main+888 @0513d7>
	<.main+886 @0513d5>  : 10 1c                      dup.x1 sp(28)
	<.main+888 @0513d7>  : 13 01                      set.x1 sp(1)
	test/lang/inlineMacros.ci:54: (70 bytes: <@0513d9> - <@05141f>): anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+890 @0513d9>  : 10 1f                      dup.x1 sp(31)
	<.main+892 @0513db>  : 0c 01 00 00                inc.i32(+1)
	<.main+896 @0513df>  : 10 00                      dup.x1 sp(0)
	<.main+898 @0513e1>  : 06 0a 00 00                jz <.main+908 @0513eb>
	<.main+902 @0513e5>  : 10 00                      dup.x1 sp(0)
	<.main+904 @0513e7>  : 04 32 00 00                jmp <.main+954 @051419>
	<.main+908 @0513eb>  : 10 1f                      dup.x1 sp(31)
	<.main+910 @0513ed>  : 0c 01 00 00                inc.i32(+1)
	<.main+914 @0513f1>  : 10 00                      dup.x1 sp(0)
	<.main+916 @0513f3>  : 06 0a 00 00                jz <.main+926 @0513fd>
	<.main+920 @0513f7>  : 10 00                      dup.x1 sp(0)
	<.main+922 @0513f9>  : 04 1e 00 00                jmp <.main+952 @051417>
	<.main+926 @0513fd>  : 10 1f                      dup.x1 sp(31)
	<.main+928 @0513ff>  : 0c 01 00 00                inc.i32(+1)
	<.main+932 @051403>  : 10 00                      dup.x1 sp(0)
	<.main+934 @051405>  : 06 0a 00 00                jz <.main+944 @05140f>
	<.main+938 @051409>  : 10 00                      dup.x1 sp(0)
	<.main+940 @05140b>  : 04 0a 00 00                jmp <.main+950 @051415>
	<.main+944 @05140f>  : 10 1f                      dup.x1 sp(31)
	<.main+946 @051411>  : 0c 01 00 00                inc.i32(+1)
	<.main+950 @051415>  : 13 01                      set.x1 sp(1)
	<.main+952 @051417>  : 13 01                      set.x1 sp(1)
	<.main+954 @051419>  : 13 01                      set.x1 sp(1)
	<.main+956 @05141b>  : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:55: (70 bytes: <@05141f> - <@051465>): anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+960 @05141f>  : 10 20                      dup.x1 sp(32)
	<.main+962 @051421>  : 0c 01 00 00                inc.i32(+1)
	<.main+966 @051425>  : 10 00                      dup.x1 sp(0)
	<.main+968 @051427>  : 06 0a 00 00                jz <.main+978 @051431>
	<.main+972 @05142b>  : 10 00                      dup.x1 sp(0)
	<.main+974 @05142d>  : 04 0a 00 00                jmp <.main+984 @051437>
	<.main+978 @051431>  : 10 20                      dup.x1 sp(32)
	<.main+980 @051433>  : 0c 01 00 00                inc.i32(+1)
	<.main+984 @051437>  : 13 01                      set.x1 sp(1)
	<.main+986 @051439>  : 10 00                      dup.x1 sp(0)
	<.main+988 @05143b>  : 06 0a 00 00                jz <.main+998 @051445>
	<.main+992 @05143f>  : 10 00                      dup.x1 sp(0)
	<.main+994 @051441>  : 04 0a 00 00                jmp <.main+1004 @05144b>
	<.main+998 @051445>  : 10 1f                      dup.x1 sp(31)
	<.main+1000 @051447> : 0c 01 00 00                inc.i32(+1)
	<.main+1004 @05144b> : 13 01                      set.x1 sp(1)
	<.main+1006 @05144d> : 10 00                      dup.x1 sp(0)
	<.main+1008 @05144f> : 06 0a 00 00                jz <.main+1018 @051459>
	<.main+1012 @051453> : 10 00                      dup.x1 sp(0)
	<.main+1014 @051455> : 04 0a 00 00                jmp <.main+1024 @05145f>
	<.main+1018 @051459> : 10 1e                      dup.x1 sp(30)
	<.main+1020 @05145b> : 0c 01 00 00                inc.i32(+1)
	<.main+1024 @05145f> : 13 01                      set.x1 sp(1)
	<.main+1026 @051461> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:59: (89 bytes: <@051465> - <@0514be>): minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1030 @051465> : 1c 03 00 00 00             load.c32 3
	<.main+1035 @05146a> : 1c 06 00 00 00             load.c32 6
	<.main+1040 @05146f> : 1c 02 00 00 00             load.c32 2
	<.main+1045 @051474> : 1c 08 00 00 00             load.c32 8
	<.main+1050 @051479> : 10 01                      dup.x1 sp(1)
	<.main+1052 @05147b> : 10 01                      dup.x1 sp(1)
	<.main+1054 @05147d> : 58                         clt.i32
	<.main+1055 @05147e> : 06 0a 00 00                jz <.main+1065 @051488>
	<.main+1059 @051482> : 10 01                      dup.x1 sp(1)
	<.main+1061 @051484> : 04 06 00 00                jmp <.main+1067 @05148a>
	<.main+1065 @051488> : 10 00                      dup.x1 sp(0)
	<.main+1067 @05148a> : 13 02                      set.x1 sp(2)
	<.main+1069 @05148c> : 09 fc ff ff                inc.sp(-4)
	<.main+1073 @051490> : 10 01                      dup.x1 sp(1)
	<.main+1075 @051492> : 10 01                      dup.x1 sp(1)
	<.main+1077 @051494> : 58                         clt.i32
	<.main+1078 @051495> : 06 0a 00 00                jz <.main+1088 @05149f>
	<.main+1082 @051499> : 10 01                      dup.x1 sp(1)
	<.main+1084 @05149b> : 04 06 00 00                jmp <.main+1090 @0514a1>
	<.main+1088 @05149f> : 10 00                      dup.x1 sp(0)
	<.main+1090 @0514a1> : 13 02                      set.x1 sp(2)
	<.main+1092 @0514a3> : 09 fc ff ff                inc.sp(-4)
	<.main+1096 @0514a7> : 10 01                      dup.x1 sp(1)
	<.main+1098 @0514a9> : 10 01                      dup.x1 sp(1)
	<.main+1100 @0514ab> : 58                         clt.i32
	<.main+1101 @0514ac> : 06 0a 00 00                jz <.main+1111 @0514b6>
	<.main+1105 @0514b0> : 10 01                      dup.x1 sp(1)
	<.main+1107 @0514b2> : 04 06 00 00                jmp <.main+1113 @0514b8>
	<.main+1111 @0514b6> : 10 00                      dup.x1 sp(0)
	<.main+1113 @0514b8> : 13 02                      set.x1 sp(2)
	<.main+1115 @0514ba> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:60: (89 bytes: <@0514be> - <@051517>): minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1119 @0514be> : 1c 03 00 00 00             load.c32 3
	<.main+1124 @0514c3> : 1c 06 00 00 00             load.c32 6
	<.main+1129 @0514c8> : 10 01                      dup.x1 sp(1)
	<.main+1131 @0514ca> : 10 01                      dup.x1 sp(1)
	<.main+1133 @0514cc> : 58                         clt.i32
	<.main+1134 @0514cd> : 06 0a 00 00                jz <.main+1144 @0514d7>
	<.main+1138 @0514d1> : 10 01                      dup.x1 sp(1)
	<.main+1140 @0514d3> : 04 06 00 00                jmp <.main+1146 @0514d9>
	<.main+1144 @0514d7> : 10 00                      dup.x1 sp(0)
	<.main+1146 @0514d9> : 13 02                      set.x1 sp(2)
	<.main+1148 @0514db> : 09 fc ff ff                inc.sp(-4)
	<.main+1152 @0514df> : 1c 02 00 00 00             load.c32 2
	<.main+1157 @0514e4> : 10 01                      dup.x1 sp(1)
	<.main+1159 @0514e6> : 10 01                      dup.x1 sp(1)
	<.main+1161 @0514e8> : 58                         clt.i32
	<.main+1162 @0514e9> : 06 0a 00 00                jz <.main+1172 @0514f3>
	<.main+1166 @0514ed> : 10 01                      dup.x1 sp(1)
	<.main+1168 @0514ef> : 04 06 00 00                jmp <.main+1174 @0514f5>
	<.main+1172 @0514f3> : 10 00                      dup.x1 sp(0)
	<.main+1174 @0514f5> : 13 02                      set.x1 sp(2)
	<.main+1176 @0514f7> : 09 fc ff ff                inc.sp(-4)
	<.main+1180 @0514fb> : 1c 08 00 00 00             load.c32 8
	<.main+1185 @051500> : 10 01                      dup.x1 sp(1)
	<.main+1187 @051502> : 10 01                      dup.x1 sp(1)
	<.main+1189 @051504> : 58                         clt.i32
	<.main+1190 @051505> : 06 0a 00 00                jz <.main+1200 @05150f>
	<.main+1194 @051509> : 10 01                      dup.x1 sp(1)
	<.main+1196 @05150b> : 04 06 00 00                jmp <.main+1202 @051511>
	<.main+1200 @05150f> : 10 00                      dup.x1 sp(0)
	<.main+1202 @051511> : 13 02                      set.x1 sp(2)
	<.main+1204 @051513> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:61: (77 bytes: <@051517> - <@051564>): minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1208 @051517> : 10 23                      dup.x1 sp(35)
	<.main+1210 @051519> : 10 23                      dup.x1 sp(35)
	<.main+1212 @05151b> : 10 23                      dup.x1 sp(35)
	<.main+1214 @05151d> : 10 23                      dup.x1 sp(35)
	<.main+1216 @05151f> : 10 01                      dup.x1 sp(1)
	<.main+1218 @051521> : 10 01                      dup.x1 sp(1)
	<.main+1220 @051523> : 58                         clt.i32
	<.main+1221 @051524> : 06 0a 00 00                jz <.main+1231 @05152e>
	<.main+1225 @051528> : 10 01                      dup.x1 sp(1)
	<.main+1227 @05152a> : 04 06 00 00                jmp <.main+1233 @051530>
	<.main+1231 @05152e> : 10 00                      dup.x1 sp(0)
	<.main+1233 @051530> : 13 02                      set.x1 sp(2)
	<.main+1235 @051532> : 09 fc ff ff                inc.sp(-4)
	<.main+1239 @051536> : 10 01                      dup.x1 sp(1)
	<.main+1241 @051538> : 10 01                      dup.x1 sp(1)
	<.main+1243 @05153a> : 58                         clt.i32
	<.main+1244 @05153b> : 06 0a 00 00                jz <.main+1254 @051545>
	<.main+1248 @05153f> : 10 01                      dup.x1 sp(1)
	<.main+1250 @051541> : 04 06 00 00                jmp <.main+1256 @051547>
	<.main+1254 @051545> : 10 00                      dup.x1 sp(0)
	<.main+1256 @051547> : 13 02                      set.x1 sp(2)
	<.main+1258 @051549> : 09 fc ff ff                inc.sp(-4)
	<.main+1262 @05154d> : 10 01                      dup.x1 sp(1)
	<.main+1264 @05154f> : 10 01                      dup.x1 sp(1)
	<.main+1266 @051551> : 58                         clt.i32
	<.main+1267 @051552> : 06 0a 00 00                jz <.main+1277 @05155c>
	<.main+1271 @051556> : 10 01                      dup.x1 sp(1)
	<.main+1273 @051558> : 04 06 00 00                jmp <.main+1279 @05155e>
	<.main+1277 @05155c> : 10 00                      dup.x1 sp(0)
	<.main+1279 @05155e> : 13 02                      set.x1 sp(2)
	<.main+1281 @051560> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:62: (77 bytes: <@051564> - <@0515b1>): minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1285 @051564> : 10 24                      dup.x1 sp(36)
	<.main+1287 @051566> : 10 24                      dup.x1 sp(36)
	<.main+1289 @051568> : 10 01                      dup.x1 sp(1)
	<.main+1291 @05156a> : 10 01                      dup.x1 sp(1)
	<.main+1293 @05156c> : 58                         clt.i32
	<.main+1294 @05156d> : 06 0a 00 00                jz <.main+1304 @051577>
	<.main+1298 @051571> : 10 01                      dup.x1 sp(1)
	<.main+1300 @051573> : 04 06 00 00                jmp <.main+1306 @051579>
	<.main+1304 @051577> : 10 00                      dup.x1 sp(0)
	<.main+1306 @051579> : 13 02                      set.x1 sp(2)
	<.main+1308 @05157b> : 09 fc ff ff                inc.sp(-4)
	<.main+1312 @05157f> : 10 23                      dup.x1 sp(35)
	<.main+1314 @051581> : 10 01                      dup.x1 sp(1)
	<.main+1316 @051583> : 10 01                      dup.x1 sp(1)
	<.main+1318 @051585> : 58                         clt.i32
	<.main+1319 @051586> : 06 0a 00 00                jz <.main+1329 @051590>
	<.main+1323 @05158a> : 10 01                      dup.x1 sp(1)
	<.main+1325 @05158c> : 04 06 00 00                jmp <.main+1331 @051592>
	<.main+1329 @051590> : 10 00                      dup.x1 sp(0)
	<.main+1331 @051592> : 13 02                      set.x1 sp(2)
	<.main+1333 @051594> : 09 fc ff ff                inc.sp(-4)
	<.main+1337 @051598> : 10 22                      dup.x1 sp(34)
	<.main+1339 @05159a> : 10 01                      dup.x1 sp(1)
	<.main+1341 @05159c> : 10 01                      dup.x1 sp(1)
	<.main+1343 @05159e> : 58                         clt.i32
	<.main+1344 @05159f> : 06 0a 00 00                jz <.main+1354 @0515a9>
	<.main+1348 @0515a3> : 10 01                      dup.x1 sp(1)
	<.main+1350 @0515a5> : 04 06 00 00                jmp <.main+1356 @0515ab>
	<.main+1354 @0515a9> : 10 00                      dup.x1 sp(0)
	<.main+1356 @0515ab> : 13 02                      set.x1 sp(2)
	<.main+1358 @0515ad> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:63: (97 bytes: <@0515b1> - <@051612>): minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1362 @0515b1> : 10 25                      dup.x1 sp(37)
	<.main+1364 @0515b3> : 0c 01 00 00                inc.i32(+1)
	<.main+1368 @0515b7> : 10 25                      dup.x1 sp(37)
	<.main+1370 @0515b9> : 0c 01 00 00                inc.i32(+1)
	<.main+1374 @0515bd> : 10 25                      dup.x1 sp(37)
	<.main+1376 @0515bf> : 0c 01 00 00                inc.i32(+1)
	<.main+1380 @0515c3> : 10 25                      dup.x1 sp(37)
	<.main+1382 @0515c5> : 0c 01 00 00                inc.i32(+1)
	<.main+1386 @0515c9> : 10 01                      dup.x1 sp(1)
	<.main+1388 @0515cb> : 10 01                      dup.x1 sp(1)
	<.main+1390 @0515cd> : 58                         clt.i32
	<.main+1391 @0515ce> : 06 0a 00 00                jz <.main+1401 @0515d8>
	<.main+1395 @0515d2> : 10 01                      dup.x1 sp(1)
	<.main+1397 @0515d4> : 04 06 00 00                jmp <.main+1403 @0515da>
	<.main+1401 @0515d8> : 10 00                      dup.x1 sp(0)
	<.main+1403 @0515da> : 13 02                      set.x1 sp(2)
	<.main+1405 @0515dc> : 09 fc ff ff                inc.sp(-4)
	<.main+1409 @0515e0> : 10 01                      dup.x1 sp(1)
	<.main+1411 @0515e2> : 10 01                      dup.x1 sp(1)
	<.main+1413 @0515e4> : 58                         clt.i32
	<.main+1414 @0515e5> : 06 0a 00 00                jz <.main+1424 @0515ef>
	<.main+1418 @0515e9> : 10 01                      dup.x1 sp(1)
	<.main+1420 @0515eb> : 04 06 00 00                jmp <.main+1426 @0515f1>
	<.main+1424 @0515ef> : 10 00                      dup.x1 sp(0)
	<.main+1426 @0515f1> : 13 02                      set.x1 sp(2)
	<.main+1428 @0515f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @0515f7> : 10 01                      dup.x1 sp(1)
	<.main+1434 @0515f9> : 10 01                      dup.x1 sp(1)
	<.main+1436 @0515fb> : 58                         clt.i32
	<.main+1437 @0515fc> : 06 0a 00 00                jz <.main+1447 @051606>
	<.main+1441 @051600> : 10 01                      dup.x1 sp(1)
	<.main+1443 @051602> : 04 06 00 00                jmp <.main+1449 @051608>
	<.main+1447 @051606> : 10 00                      dup.x1 sp(0)
	<.main+1449 @051608> : 13 02                      set.x1 sp(2)
	<.main+1451 @05160a> : 09 fc ff ff                inc.sp(-4)
	<.main+1455 @05160e> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:64: (97 bytes: <@051612> - <@051673>): minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1459 @051612> : 10 26                      dup.x1 sp(38)
	<.main+1461 @051614> : 0c 01 00 00                inc.i32(+1)
	<.main+1465 @051618> : 10 26                      dup.x1 sp(38)
	<.main+1467 @05161a> : 0c 01 00 00                inc.i32(+1)
	<.main+1471 @05161e> : 10 01                      dup.x1 sp(1)
	<.main+1473 @051620> : 10 01                      dup.x1 sp(1)
	<.main+1475 @051622> : 58                         clt.i32
	<.main+1476 @051623> : 06 0a 00 00                jz <.main+1486 @05162d>
	<.main+1480 @051627> : 10 01                      dup.x1 sp(1)
	<.main+1482 @051629> : 04 06 00 00                jmp <.main+1488 @05162f>
	<.main+1486 @05162d> : 10 00                      dup.x1 sp(0)
	<.main+1488 @05162f> : 13 02                      set.x1 sp(2)
	<.main+1490 @051631> : 09 fc ff ff                inc.sp(-4)
	<.main+1494 @051635> : 10 25                      dup.x1 sp(37)
	<.main+1496 @051637> : 0c 01 00 00                inc.i32(+1)
	<.main+1500 @05163b> : 10 01                      dup.x1 sp(1)
	<.main+1502 @05163d> : 10 01                      dup.x1 sp(1)
	<.main+1504 @05163f> : 58                         clt.i32
	<.main+1505 @051640> : 06 0a 00 00                jz <.main+1515 @05164a>
	<.main+1509 @051644> : 10 01                      dup.x1 sp(1)
	<.main+1511 @051646> : 04 06 00 00                jmp <.main+1517 @05164c>
	<.main+1515 @05164a> : 10 00                      dup.x1 sp(0)
	<.main+1517 @05164c> : 13 02                      set.x1 sp(2)
	<.main+1519 @05164e> : 09 fc ff ff                inc.sp(-4)
	<.main+1523 @051652> : 10 24                      dup.x1 sp(36)
	<.main+1525 @051654> : 0c 01 00 00                inc.i32(+1)
	<.main+1529 @051658> : 10 01                      dup.x1 sp(1)
	<.main+1531 @05165a> : 10 01                      dup.x1 sp(1)
	<.main+1533 @05165c> : 58                         clt.i32
	<.main+1534 @05165d> : 06 0a 00 00                jz <.main+1544 @051667>
	<.main+1538 @051661> : 10 01                      dup.x1 sp(1)
	<.main+1540 @051663> : 04 06 00 00                jmp <.main+1546 @051669>
	<.main+1544 @051667> : 10 00                      dup.x1 sp(0)
	<.main+1546 @051669> : 13 02                      set.x1 sp(2)
	<.main+1548 @05166b> : 09 fc ff ff                inc.sp(-4)
	<.main+1552 @05166f> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:68: (89 bytes: <@051673> - <@0516cc>): maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1556 @051673> : 1c 03 00 00 00             load.c32 3
	<.main+1561 @051678> : 1c 06 00 00 00             load.c32 6
	<.main+1566 @05167d> : 1c 02 00 00 00             load.c32 2
	<.main+1571 @051682> : 1c 08 00 00 00             load.c32 8
	<.main+1576 @051687> : 10 01                      dup.x1 sp(1)
	<.main+1578 @051689> : 10 01                      dup.x1 sp(1)
	<.main+1580 @05168b> : 59                         cgt.i32
	<.main+1581 @05168c> : 06 0a 00 00                jz <.main+1591 @051696>
	<.main+1585 @051690> : 10 01                      dup.x1 sp(1)
	<.main+1587 @051692> : 04 06 00 00                jmp <.main+1593 @051698>
	<.main+1591 @051696> : 10 00                      dup.x1 sp(0)
	<.main+1593 @051698> : 13 02                      set.x1 sp(2)
	<.main+1595 @05169a> : 09 fc ff ff                inc.sp(-4)
	<.main+1599 @05169e> : 10 01                      dup.x1 sp(1)
	<.main+1601 @0516a0> : 10 01                      dup.x1 sp(1)
	<.main+1603 @0516a2> : 59                         cgt.i32
	<.main+1604 @0516a3> : 06 0a 00 00                jz <.main+1614 @0516ad>
	<.main+1608 @0516a7> : 10 01                      dup.x1 sp(1)
	<.main+1610 @0516a9> : 04 06 00 00                jmp <.main+1616 @0516af>
	<.main+1614 @0516ad> : 10 00                      dup.x1 sp(0)
	<.main+1616 @0516af> : 13 02                      set.x1 sp(2)
	<.main+1618 @0516b1> : 09 fc ff ff                inc.sp(-4)
	<.main+1622 @0516b5> : 10 01                      dup.x1 sp(1)
	<.main+1624 @0516b7> : 10 01                      dup.x1 sp(1)
	<.main+1626 @0516b9> : 59                         cgt.i32
	<.main+1627 @0516ba> : 06 0a 00 00                jz <.main+1637 @0516c4>
	<.main+1631 @0516be> : 10 01                      dup.x1 sp(1)
	<.main+1633 @0516c0> : 04 06 00 00                jmp <.main+1639 @0516c6>
	<.main+1637 @0516c4> : 10 00                      dup.x1 sp(0)
	<.main+1639 @0516c6> : 13 02                      set.x1 sp(2)
	<.main+1641 @0516c8> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:69: (89 bytes: <@0516cc> - <@051725>): maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1645 @0516cc> : 1c 03 00 00 00             load.c32 3
	<.main+1650 @0516d1> : 1c 06 00 00 00             load.c32 6
	<.main+1655 @0516d6> : 10 01                      dup.x1 sp(1)
	<.main+1657 @0516d8> : 10 01                      dup.x1 sp(1)
	<.main+1659 @0516da> : 59                         cgt.i32
	<.main+1660 @0516db> : 06 0a 00 00                jz <.main+1670 @0516e5>
	<.main+1664 @0516df> : 10 01                      dup.x1 sp(1)
	<.main+1666 @0516e1> : 04 06 00 00                jmp <.main+1672 @0516e7>
	<.main+1670 @0516e5> : 10 00                      dup.x1 sp(0)
	<.main+1672 @0516e7> : 13 02                      set.x1 sp(2)
	<.main+1674 @0516e9> : 09 fc ff ff                inc.sp(-4)
	<.main+1678 @0516ed> : 1c 02 00 00 00             load.c32 2
	<.main+1683 @0516f2> : 10 01                      dup.x1 sp(1)
	<.main+1685 @0516f4> : 10 01                      dup.x1 sp(1)
	<.main+1687 @0516f6> : 59                         cgt.i32
	<.main+1688 @0516f7> : 06 0a 00 00                jz <.main+1698 @051701>
	<.main+1692 @0516fb> : 10 01                      dup.x1 sp(1)
	<.main+1694 @0516fd> : 04 06 00 00                jmp <.main+1700 @051703>
	<.main+1698 @051701> : 10 00                      dup.x1 sp(0)
	<.main+1700 @051703> : 13 02                      set.x1 sp(2)
	<.main+1702 @051705> : 09 fc ff ff                inc.sp(-4)
	<.main+1706 @051709> : 1c 08 00 00 00             load.c32 8
	<.main+1711 @05170e> : 10 01                      dup.x1 sp(1)
	<.main+1713 @051710> : 10 01                      dup.x1 sp(1)
	<.main+1715 @051712> : 59                         cgt.i32
	<.main+1716 @051713> : 06 0a 00 00                jz <.main+1726 @05171d>
	<.main+1720 @051717> : 10 01                      dup.x1 sp(1)
	<.main+1722 @051719> : 04 06 00 00                jmp <.main+1728 @05171f>
	<.main+1726 @05171d> : 10 00                      dup.x1 sp(0)
	<.main+1728 @05171f> : 13 02                      set.x1 sp(2)
	<.main+1730 @051721> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:70: (77 bytes: <@051725> - <@051772>): maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+1734 @051725> : 10 29                      dup.x1 sp(41)
	<.main+1736 @051727> : 10 29                      dup.x1 sp(41)
	<.main+1738 @051729> : 10 29                      dup.x1 sp(41)
	<.main+1740 @05172b> : 10 29                      dup.x1 sp(41)
	<.main+1742 @05172d> : 10 01                      dup.x1 sp(1)
	<.main+1744 @05172f> : 10 01                      dup.x1 sp(1)
	<.main+1746 @051731> : 59                         cgt.i32
	<.main+1747 @051732> : 06 0a 00 00                jz <.main+1757 @05173c>
	<.main+1751 @051736> : 10 01                      dup.x1 sp(1)
	<.main+1753 @051738> : 04 06 00 00                jmp <.main+1759 @05173e>
	<.main+1757 @05173c> : 10 00                      dup.x1 sp(0)
	<.main+1759 @05173e> : 13 02                      set.x1 sp(2)
	<.main+1761 @051740> : 09 fc ff ff                inc.sp(-4)
	<.main+1765 @051744> : 10 01                      dup.x1 sp(1)
	<.main+1767 @051746> : 10 01                      dup.x1 sp(1)
	<.main+1769 @051748> : 59                         cgt.i32
	<.main+1770 @051749> : 06 0a 00 00                jz <.main+1780 @051753>
	<.main+1774 @05174d> : 10 01                      dup.x1 sp(1)
	<.main+1776 @05174f> : 04 06 00 00                jmp <.main+1782 @051755>
	<.main+1780 @051753> : 10 00                      dup.x1 sp(0)
	<.main+1782 @051755> : 13 02                      set.x1 sp(2)
	<.main+1784 @051757> : 09 fc ff ff                inc.sp(-4)
	<.main+1788 @05175b> : 10 01                      dup.x1 sp(1)
	<.main+1790 @05175d> : 10 01                      dup.x1 sp(1)
	<.main+1792 @05175f> : 59                         cgt.i32
	<.main+1793 @051760> : 06 0a 00 00                jz <.main+1803 @05176a>
	<.main+1797 @051764> : 10 01                      dup.x1 sp(1)
	<.main+1799 @051766> : 04 06 00 00                jmp <.main+1805 @05176c>
	<.main+1803 @05176a> : 10 00                      dup.x1 sp(0)
	<.main+1805 @05176c> : 13 02                      set.x1 sp(2)
	<.main+1807 @05176e> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:71: (77 bytes: <@051772> - <@0517bf>): maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+1811 @051772> : 10 2a                      dup.x1 sp(42)
	<.main+1813 @051774> : 10 2a                      dup.x1 sp(42)
	<.main+1815 @051776> : 10 01                      dup.x1 sp(1)
	<.main+1817 @051778> : 10 01                      dup.x1 sp(1)
	<.main+1819 @05177a> : 59                         cgt.i32
	<.main+1820 @05177b> : 06 0a 00 00                jz <.main+1830 @051785>
	<.main+1824 @05177f> : 10 01                      dup.x1 sp(1)
	<.main+1826 @051781> : 04 06 00 00                jmp <.main+1832 @051787>
	<.main+1830 @051785> : 10 00                      dup.x1 sp(0)
	<.main+1832 @051787> : 13 02                      set.x1 sp(2)
	<.main+1834 @051789> : 09 fc ff ff                inc.sp(-4)
	<.main+1838 @05178d> : 10 29                      dup.x1 sp(41)
	<.main+1840 @05178f> : 10 01                      dup.x1 sp(1)
	<.main+1842 @051791> : 10 01                      dup.x1 sp(1)
	<.main+1844 @051793> : 59                         cgt.i32
	<.main+1845 @051794> : 06 0a 00 00                jz <.main+1855 @05179e>
	<.main+1849 @051798> : 10 01                      dup.x1 sp(1)
	<.main+1851 @05179a> : 04 06 00 00                jmp <.main+1857 @0517a0>
	<.main+1855 @05179e> : 10 00                      dup.x1 sp(0)
	<.main+1857 @0517a0> : 13 02                      set.x1 sp(2)
	<.main+1859 @0517a2> : 09 fc ff ff                inc.sp(-4)
	<.main+1863 @0517a6> : 10 28                      dup.x1 sp(40)
	<.main+1865 @0517a8> : 10 01                      dup.x1 sp(1)
	<.main+1867 @0517aa> : 10 01                      dup.x1 sp(1)
	<.main+1869 @0517ac> : 59                         cgt.i32
	<.main+1870 @0517ad> : 06 0a 00 00                jz <.main+1880 @0517b7>
	<.main+1874 @0517b1> : 10 01                      dup.x1 sp(1)
	<.main+1876 @0517b3> : 04 06 00 00                jmp <.main+1882 @0517b9>
	<.main+1880 @0517b7> : 10 00                      dup.x1 sp(0)
	<.main+1882 @0517b9> : 13 02                      set.x1 sp(2)
	<.main+1884 @0517bb> : 09 fc ff ff                inc.sp(-4)
	test/lang/inlineMacros.ci:72: (97 bytes: <@0517bf> - <@051820>): maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1888 @0517bf> : 10 2b                      dup.x1 sp(43)
	<.main+1890 @0517c1> : 0c 01 00 00                inc.i32(+1)
	<.main+1894 @0517c5> : 10 2b                      dup.x1 sp(43)
	<.main+1896 @0517c7> : 0c 01 00 00                inc.i32(+1)
	<.main+1900 @0517cb> : 10 2b                      dup.x1 sp(43)
	<.main+1902 @0517cd> : 0c 01 00 00                inc.i32(+1)
	<.main+1906 @0517d1> : 10 2b                      dup.x1 sp(43)
	<.main+1908 @0517d3> : 0c 01 00 00                inc.i32(+1)
	<.main+1912 @0517d7> : 10 01                      dup.x1 sp(1)
	<.main+1914 @0517d9> : 10 01                      dup.x1 sp(1)
	<.main+1916 @0517db> : 59                         cgt.i32
	<.main+1917 @0517dc> : 06 0a 00 00                jz <.main+1927 @0517e6>
	<.main+1921 @0517e0> : 10 01                      dup.x1 sp(1)
	<.main+1923 @0517e2> : 04 06 00 00                jmp <.main+1929 @0517e8>
	<.main+1927 @0517e6> : 10 00                      dup.x1 sp(0)
	<.main+1929 @0517e8> : 13 02                      set.x1 sp(2)
	<.main+1931 @0517ea> : 09 fc ff ff                inc.sp(-4)
	<.main+1935 @0517ee> : 10 01                      dup.x1 sp(1)
	<.main+1937 @0517f0> : 10 01                      dup.x1 sp(1)
	<.main+1939 @0517f2> : 59                         cgt.i32
	<.main+1940 @0517f3> : 06 0a 00 00                jz <.main+1950 @0517fd>
	<.main+1944 @0517f7> : 10 01                      dup.x1 sp(1)
	<.main+1946 @0517f9> : 04 06 00 00                jmp <.main+1952 @0517ff>
	<.main+1950 @0517fd> : 10 00                      dup.x1 sp(0)
	<.main+1952 @0517ff> : 13 02                      set.x1 sp(2)
	<.main+1954 @051801> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @051805> : 10 01                      dup.x1 sp(1)
	<.main+1960 @051807> : 10 01                      dup.x1 sp(1)
	<.main+1962 @051809> : 59                         cgt.i32
	<.main+1963 @05180a> : 06 0a 00 00                jz <.main+1973 @051814>
	<.main+1967 @05180e> : 10 01                      dup.x1 sp(1)
	<.main+1969 @051810> : 04 06 00 00                jmp <.main+1975 @051816>
	<.main+1973 @051814> : 10 00                      dup.x1 sp(0)
	<.main+1975 @051816> : 13 02                      set.x1 sp(2)
	<.main+1977 @051818> : 09 fc ff ff                inc.sp(-4)
	<.main+1981 @05181c> : 0c ff ff ff                inc.i32(-1)
	test/lang/inlineMacros.ci:73: (97 bytes: <@051820> - <@051881>): maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1985 @051820> : 10 2c                      dup.x1 sp(44)
	<.main+1987 @051822> : 0c 01 00 00                inc.i32(+1)
	<.main+1991 @051826> : 10 2c                      dup.x1 sp(44)
	<.main+1993 @051828> : 0c 01 00 00                inc.i32(+1)
	<.main+1997 @05182c> : 10 01                      dup.x1 sp(1)
	<.main+1999 @05182e> : 10 01                      dup.x1 sp(1)
	<.main+2001 @051830> : 59                         cgt.i32
	<.main+2002 @051831> : 06 0a 00 00                jz <.main+2012 @05183b>
	<.main+2006 @051835> : 10 01                      dup.x1 sp(1)
	<.main+2008 @051837> : 04 06 00 00                jmp <.main+2014 @05183d>
	<.main+2012 @05183b> : 10 00                      dup.x1 sp(0)
	<.main+2014 @05183d> : 13 02                      set.x1 sp(2)
	<.main+2016 @05183f> : 09 fc ff ff                inc.sp(-4)
	<.main+2020 @051843> : 10 2b                      dup.x1 sp(43)
	<.main+2022 @051845> : 0c 01 00 00                inc.i32(+1)
	<.main+2026 @051849> : 10 01                      dup.x1 sp(1)
	<.main+2028 @05184b> : 10 01                      dup.x1 sp(1)
	<.main+2030 @05184d> : 59                         cgt.i32
	<.main+2031 @05184e> : 06 0a 00 00                jz <.main+2041 @051858>
	<.main+2035 @051852> : 10 01                      dup.x1 sp(1)
	<.main+2037 @051854> : 04 06 00 00                jmp <.main+2043 @05185a>
	<.main+2041 @051858> : 10 00                      dup.x1 sp(0)
	<.main+2043 @05185a> : 13 02                      set.x1 sp(2)
	<.main+2045 @05185c> : 09 fc ff ff                inc.sp(-4)
	<.main+2049 @051860> : 10 2a                      dup.x1 sp(42)
	<.main+2051 @051862> : 0c 01 00 00                inc.i32(+1)
	<.main+2055 @051866> : 10 01                      dup.x1 sp(1)
	<.main+2057 @051868> : 10 01                      dup.x1 sp(1)
	<.main+2059 @05186a> : 59                         cgt.i32
	<.main+2060 @05186b> : 06 0a 00 00                jz <.main+2070 @051875>
	<.main+2064 @05186f> : 10 01                      dup.x1 sp(1)
	<.main+2066 @051871> : 04 06 00 00                jmp <.main+2072 @051877>
	<.main+2070 @051875> : 10 00                      dup.x1 sp(0)
	<.main+2072 @051877> : 13 02                      set.x1 sp(2)
	<.main+2074 @051879> : 09 fc ff ff                inc.sp(-4)
	<.main+2078 @05187d> : 0c ff ff ff                inc.i32(-1)
	test/lang/overload.inline.ci:9: (5 bytes: <@051881> - <@051886>): overload1: float32 := overload
	<.main+2082 @051881> : 7f 00 00 80 3f             load.f32 1.000000
	test/lang/overload.inline.ci:10: (5 bytes: <@051886> - <@05188b>): overload2: float32 := overload()
	<.main+2087 @051886> : 7f 00 00 00 40             load.f32 2.000000
	test/lang/overload.inline.ci:11: (5 bytes: <@05188b> - <@051890>): overload3: float32 := overload(0)
	<.main+2092 @05188b> : 7f 00 00 40 40             load.f32 3.000000
	test/lang/overload.inline.ci:12: (5 bytes: <@051890> - <@051895>): overload4: float32 := overload(0.000000)
	<.main+2097 @051890> : 7f 00 00 80 40             load.f32 4.000000
	test/lang/overload.inline.ci:13: (5 bytes: <@051895> - <@05189a>): overload5: float32 := overload(void(0, 0))
	<.main+2102 @051895> : 7f 00 00 a0 40             load.f32 5.000000
	test/lang/overload.inline.ci:28: (9 bytes: <@05189a> - <@0518a3>): boilC: Celsius := Celsius(100.000000)
	<.main+2107 @05189a> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	test/lang/overload.inline.ci:29: (22 bytes: <@0518a3> - <@0518b9>): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2116 @0518a3> : 11 00                      dup.x2 sp(0)
	<.main+2118 @0518a5> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2127 @0518ae> : 83                         mul.f64
	<.main+2128 @0518af> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2137 @0518b8> : 81                         add.f64
	test/lang/initByRef.ci:8: (5 bytes: <@0518b9> - <@0518be>): valueRef: int64 := value
	<.main+2138 @0518b9> : 1f e0 0d 05 00             load.ref <@050de0> ;value
	test/lang/initByRef.ci:9: (5 bytes: <@0518be> - <@0518c3>): valuePtr: pointer := value
	<.main+2143 @0518be> : 1f e0 0d 05 00             load.ref <@050de0> ;value
	test/lang/initByRef.ci:10: (10 bytes: <@0518c3> - <@0518cd>): valueVar: variant := value
	<.main+2148 @0518c3> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2153 @0518c8> : 1f e0 0d 05 00             load.ref <@050de0> ;value
	test/lang/initByRef.ci:12: (3 bytes: <@0518cd> - <@0518d0>): fromRef: int64 := valueRef
	<.main+2158 @0518cd> : 10 03                      dup.x1 sp(3)
	<.main+2160 @0518cf> : 23                         load.i64
	test/lang/initByRef.ci:13: (2 bytes: <@0518d0> - <@0518d2>): fromPtr: int64 := valuePtr
	<.main+2161 @0518d0> : 10 04                      dup.x1 sp(4)
	test/lang/initByRef.ci:14: (2 bytes: <@0518d2> - <@0518d4>): fromVar: int64 := valueVar
	<.main+2163 @0518d2> : 10 03                      dup.x1 sp(3)
	test/lang/initByRef.ci:16: (5 bytes: <@0518d4> - <@0518d9>): nullRef: int64 := null
	<.main+2165 @0518d4> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:17: (5 bytes: <@0518d9> - <@0518de>): nullPtr: pointer := null
	<.main+2170 @0518d9> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:18: (10 bytes: <@0518de> - <@0518e8>): nullVar: variant := null
	<.main+2175 @0518de> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2180 @0518e3> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:19: (5 bytes: <@0518e8> - <@0518ed>): nullTyp: typename := null
	<.main+2185 @0518e8> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:20: (5 bytes: <@0518ed> - <@0518f2>): nullFun: function := null
	<.main+2190 @0518ed> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:21: (5 bytes: <@0518f2> - <@0518f7>): nullObj: object := null
	<.main+2195 @0518f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/initByRef.ci:23: (5 bytes: <@0518f7> - <@0518fc>): typePtr: pointer := int64
	<.main+2200 @0518f7> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:24: (10 bytes: <@0518fc> - <@051906>): typeVar: variant := int64
	<.main+2205 @0518fc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2210 @051901> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:25: (5 bytes: <@051906> - <@05190b>): typeTyp: typename := int64
	<.main+2215 @051906> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:27: (4 bytes: <@05190b> - <@05190f>): local: int64 := value
	<.main+2220 @05190b> : 2b e0 0d 05                load.m64 <@050de0> ;value
	test/lang/initByRef.ci:28: (2 bytes: <@05190f> - <@051911>): copyVal: int64 := local
	<.main+2224 @05190f> : 11 00                      dup.x2 sp(0)
	test/lang/initByRef.ci:29: (2 bytes: <@051911> - <@051913>): copyRef: int64 := valueRef
	<.main+2226 @051911> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:30: (2 bytes: <@051913> - <@051915>): copyPtr: pointer := valuePtr
	<.main+2228 @051913> : 10 16                      dup.x1 sp(22)
	test/lang/initByRef.ci:31: (2 bytes: <@051915> - <@051917>): copyVar: variant := valueVar
	<.main+2230 @051915> : 11 15                      dup.x2 sp(21)
	test/lang/initByRef.ci:32: (2 bytes: <@051917> - <@051919>): copyTyp: typename := typeTyp
	<.main+2232 @051917> : 10 08                      dup.x1 sp(8)
	test/lang/initByRef.ci:35: (5 bytes: <@051919> - <@05191e>): ptrVoid: pointer := void
	<.main+2234 @051919> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:36: (5 bytes: <@05191e> - <@051923>): ptrBool: pointer := bool
	<.main+2239 @05191e> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:37: (5 bytes: <@051923> - <@051928>): ptrChar: pointer := char
	<.main+2244 @051923> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:38: (5 bytes: <@051928> - <@05192d>): ptrInt8: pointer := int8
	<.main+2249 @051928> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:39: (5 bytes: <@05192d> - <@051932>): ptrInt16: pointer := int16
	<.main+2254 @05192d> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:40: (5 bytes: <@051932> - <@051937>): ptrInt32: pointer := int32
	<.main+2259 @051932> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:41: (5 bytes: <@051937> - <@05193c>): ptrInt64: pointer := int64
	<.main+2264 @051937> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:42: (5 bytes: <@05193c> - <@051941>): ptrUint8: pointer := uint8
	<.main+2269 @05193c> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:43: (5 bytes: <@051941> - <@051946>): ptrUint16: pointer := uint16
	<.main+2274 @051941> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:44: (5 bytes: <@051946> - <@05194b>): ptrUint32: pointer := uint32
	<.main+2279 @051946> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:45: (5 bytes: <@05194b> - <@051950>): ptrUint64: pointer := uint64
	<.main+2284 @05194b> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:46: (5 bytes: <@051950> - <@051955>): ptrFloat32: pointer := float32
	<.main+2289 @051950> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:47: (5 bytes: <@051955> - <@05195a>): ptrFloat64: pointer := float64
	<.main+2294 @051955> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:48: (5 bytes: <@05195a> - <@05195f>): ptrTypename: pointer := typename
	<.main+2299 @05195a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:49: (5 bytes: <@05195f> - <@051964>): ptrFunction: pointer := function
	<.main+2304 @05195f> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:50: (5 bytes: <@051964> - <@051969>): ptrPointer: pointer := pointer
	<.main+2309 @051964> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:51: (5 bytes: <@051969> - <@05196e>): ptrVariant: pointer := variant
	<.main+2314 @051969> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:52: (5 bytes: <@05196e> - <@051973>): ptrObject: pointer := object
	<.main+2319 @05196e> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:55: (10 bytes: <@051973> - <@05197d>): varVoid: variant := void
	<.main+2324 @051973> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2329 @051978> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:56: (10 bytes: <@05197d> - <@051987>): varBool: variant := bool
	<.main+2334 @05197d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2339 @051982> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:57: (10 bytes: <@051987> - <@051991>): varChar: variant := char
	<.main+2344 @051987> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2349 @05198c> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:58: (10 bytes: <@051991> - <@05199b>): varInt8: variant := int8
	<.main+2354 @051991> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2359 @051996> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:59: (10 bytes: <@05199b> - <@0519a5>): varInt16: variant := int16
	<.main+2364 @05199b> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2369 @0519a0> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:60: (10 bytes: <@0519a5> - <@0519af>): varInt32: variant := int32
	<.main+2374 @0519a5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2379 @0519aa> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:61: (10 bytes: <@0519af> - <@0519b9>): varInt64: variant := int64
	<.main+2384 @0519af> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2389 @0519b4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:62: (10 bytes: <@0519b9> - <@0519c3>): varUint8: variant := uint8
	<.main+2394 @0519b9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2399 @0519be> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:63: (10 bytes: <@0519c3> - <@0519cd>): varUint16: variant := uint16
	<.main+2404 @0519c3> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2409 @0519c8> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:64: (10 bytes: <@0519cd> - <@0519d7>): varUint32: variant := uint32
	<.main+2414 @0519cd> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2419 @0519d2> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:65: (10 bytes: <@0519d7> - <@0519e1>): varUint64: variant := uint64
	<.main+2424 @0519d7> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2429 @0519dc> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:66: (10 bytes: <@0519e1> - <@0519eb>): varFloat32: variant := float32
	<.main+2434 @0519e1> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2439 @0519e6> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:67: (10 bytes: <@0519eb> - <@0519f5>): varFloat64: variant := float64
	<.main+2444 @0519eb> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2449 @0519f0> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:68: (10 bytes: <@0519f5> - <@0519ff>): varTypename: variant := typename
	<.main+2454 @0519f5> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2459 @0519fa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:69: (10 bytes: <@0519ff> - <@051a09>): varFunction: variant := function
	<.main+2464 @0519ff> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2469 @051a04> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:70: (10 bytes: <@051a09> - <@051a13>): varPointer: variant := pointer
	<.main+2474 @051a09> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2479 @051a0e> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:71: (10 bytes: <@051a13> - <@051a1d>): varVariant: variant := variant
	<.main+2484 @051a13> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2489 @051a18> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:72: (10 bytes: <@051a1d> - <@051a27>): varObject: variant := object
	<.main+2494 @051a1d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2499 @051a22> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:75: (5 bytes: <@051a27> - <@051a2c>): typVoid: typename := void
	<.main+2504 @051a27> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	test/lang/initByRef.ci:76: (5 bytes: <@051a2c> - <@051a31>): typBool: typename := bool
	<.main+2509 @051a2c> : 1f 50 01 00 00             load.ref <@000150> ;bool
	test/lang/initByRef.ci:77: (5 bytes: <@051a31> - <@051a36>): typChar: typename := char
	<.main+2514 @051a31> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	test/lang/initByRef.ci:78: (5 bytes: <@051a36> - <@051a3b>): typInt8: typename := int8
	<.main+2519 @051a36> : 1f 90 02 00 00             load.ref <@000290> ;int8
	test/lang/initByRef.ci:79: (5 bytes: <@051a3b> - <@051a40>): typInt16: typename := int16
	<.main+2524 @051a3b> : 1f 30 03 00 00             load.ref <@000330> ;int16
	test/lang/initByRef.ci:80: (5 bytes: <@051a40> - <@051a45>): typInt32: typename := int32
	<.main+2529 @051a40> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	test/lang/initByRef.ci:81: (5 bytes: <@051a45> - <@051a4a>): typInt64: typename := int64
	<.main+2534 @051a45> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:82: (5 bytes: <@051a4a> - <@051a4f>): typUint8: typename := uint8
	<.main+2539 @051a4a> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	test/lang/initByRef.ci:83: (5 bytes: <@051a4f> - <@051a54>): typUint16: typename := uint16
	<.main+2544 @051a4f> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	test/lang/initByRef.ci:84: (5 bytes: <@051a54> - <@051a59>): typUint32: typename := uint32
	<.main+2549 @051a54> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	test/lang/initByRef.ci:85: (5 bytes: <@051a59> - <@051a5e>): typUint64: typename := uint64
	<.main+2554 @051a59> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	test/lang/initByRef.ci:86: (5 bytes: <@051a5e> - <@051a63>): typFloat32: typename := float32
	<.main+2559 @051a5e> : 1f 90 07 00 00             load.ref <@000790> ;float32
	test/lang/initByRef.ci:87: (5 bytes: <@051a63> - <@051a68>): typFloat64: typename := float64
	<.main+2564 @051a63> : 1f 30 08 00 00             load.ref <@000830> ;float64
	test/lang/initByRef.ci:88: (5 bytes: <@051a68> - <@051a6d>): typTypename: typename := typename
	<.main+2569 @051a68> : 1f 08 00 00 00             load.ref <@000008> ;typename
	test/lang/initByRef.ci:89: (5 bytes: <@051a6d> - <@051a72>): typFunction: typename := function
	<.main+2574 @051a6d> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	test/lang/initByRef.ci:90: (5 bytes: <@051a72> - <@051a77>): typPointer: typename := pointer
	<.main+2579 @051a72> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	test/lang/initByRef.ci:91: (5 bytes: <@051a77> - <@051a7c>): typVariant: typename := variant
	<.main+2584 @051a77> : 1f 70 09 00 00             load.ref <@000970> ;variant
	test/lang/initByRef.ci:92: (5 bytes: <@051a7c> - <@051a81>): typObject: typename := object
	<.main+2589 @051a7c> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	test/lang/initByRef.ci:95: (5 bytes: <@051a81> - <@051a86>): valueOfPtr: pointer := pointer(value)
	<.main+2594 @051a81> : 1f e0 0d 05 00             load.ref <@050de0> ;value
	test/lang/initByRef.ci:96: (10 bytes: <@051a86> - <@051a90>): valueOfVar: variant := variant(value)
	<.main+2599 @051a86> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2604 @051a8b> : 1f e0 0d 05 00             load.ref <@050de0> ;value
	test/lang/initByRef.ci:97: (5 bytes: <@051a90> - <@051a95>): valueOfTyp: typename := typename(value)
	<.main+2609 @051a90> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:99: (5 bytes: <@051a95> - <@051a9a>): typeOfValue: typename := typename(value)
	<.main+2614 @051a95> : 1f 70 04 00 00             load.ref <@000470> ;int64
	test/lang/initByRef.ci:105: (7 bytes: <@051a9a> - <@051aa1>): copyPtrFloat64: variant := ptrFloat64
	<.main+2619 @051a9a> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2624 @051a9f> : 10 41                      dup.x1 sp(65)
	test/lang/initByRef.ci:108: (2 bytes: <@051aa1> - <@051aa3>): copyVarFloat64: pointer := varFloat64
	<.main+2626 @051aa1> : 10 23                      dup.x1 sp(35)
	test/lang/function.ci:11: (21 bytes: <@051aa3> - <@051ab8>): funAddResult: int32 := funAdd(void(2, 7))
	<.main+2628 @051aa3> : 19                         load.z32
	<.main+2629 @051aa4> : 1c 02 00 00 00             load.c32 2
	<.main+2634 @051aa9> : 1c 07 00 00 00             load.c32 7
	<.main+2639 @051aae> : 1f f0 0d 05 00             load.ref <@050df0> ;funAdd(x: int32, y: int32): int32
	<.main+2644 @051ab3> : 02                         call
	<.main+2645 @051ab4> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:14: (5 bytes: <@051ab8> - <@051abd>): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+2649 @051ab8> : 1f f0 0d 05 00             load.ref <@050df0> ;funAdd(x: int32, y: int32): int32
	test/lang/function.ci:17: (18 bytes: <@051abd> - <@051acf>): funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+2654 @051abd> : 19                         load.z32
	<.main+2655 @051abe> : 1c 02 00 00 00             load.c32 2
	<.main+2660 @051ac3> : 1c 08 00 00 00             load.c32 8
	<.main+2665 @051ac8> : 10 03                      dup.x1 sp(3)
	<.main+2667 @051aca> : 02                         call
	<.main+2668 @051acb> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:20: (5 bytes: <@051acf> - <@051ad4>): funMul(x: int32, y: int32): int32 := funMul
	<.main+2672 @051acf> : 1f f8 0d 05 00             load.ref <@050df8> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:23: (18 bytes: <@051ad4> - <@051ae6>): funMulResult: int32 := funMul(void(2, 6))
	<.main+2677 @051ad4> : 19                         load.z32
	<.main+2678 @051ad5> : 1c 02 00 00 00             load.c32 2
	<.main+2683 @051ada> : 1c 06 00 00 00             load.c32 6
	<.main+2688 @051adf> : 10 03                      dup.x1 sp(3)
	<.main+2690 @051ae1> : 02                         call
	<.main+2691 @051ae2> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:26: (2 bytes: <@051ae6> - <@051ae8>): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+2695 @051ae6> : 10 01                      dup.x1 sp(1)
	test/lang/function.ci:29: (18 bytes: <@051ae8> - <@051afa>): funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+2697 @051ae8> : 19                         load.z32
	<.main+2698 @051ae9> : 1c 02 00 00 00             load.c32 2
	<.main+2703 @051aee> : 1c 07 00 00 00             load.c32 7
	<.main+2708 @051af3> : 10 03                      dup.x1 sp(3)
	<.main+2710 @051af5> : 02                         call
	<.main+2711 @051af6> : 09 f8 ff ff                inc.sp(-8)
	test/lang/function.ci:45: (16 bytes: <@051afa> - <@051b0a>): fibonacci_13: uint32 := fib(13)
	<.main+2715 @051afa> : 19                         load.z32
	<.main+2716 @051afb> : 1c 0d 00 00 00             load.c32 13
	<.main+2721 @051b00> : 1f 00 0e 05 00             load.ref <@050e00> ;fib(n: uint32): uint32
	<.main+2726 @051b05> : 02                         call
	<.main+2727 @051b06> : 09 fc ff ff                inc.sp(-4)
	test/lang/reflect.ci:3: (4 bytes: <@051b0a> - <@051b0e>): sizeofVoid: int32 := sizeof(void)
	<.main+2731 @051b0a> : 2a d0 00 00                load.m32 <@0000d0>
	test/lang/reflect.ci:4: (4 bytes: <@051b0e> - <@051b12>): sizeofBool: int32 := sizeof(bool)
	<.main+2735 @051b0e> : 2a 70 01 00                load.m32 <@000170>
	test/lang/reflect.ci:5: (4 bytes: <@051b12> - <@051b16>): sizeofChar: int32 := sizeof(char)
	<.main+2739 @051b12> : 2a 10 02 00                load.m32 <@000210>
	test/lang/reflect.ci:6: (4 bytes: <@051b16> - <@051b1a>): sizeofInt8: int32 := sizeof(int8)
	<.main+2743 @051b16> : 2a b0 02 00                load.m32 <@0002b0>
	test/lang/reflect.ci:7: (4 bytes: <@051b1a> - <@051b1e>): sizeofInt16: int32 := sizeof(int16)
	<.main+2747 @051b1a> : 2a 50 03 00                load.m32 <@000350>
	test/lang/reflect.ci:8: (4 bytes: <@051b1e> - <@051b22>): sizeofInt32: int32 := sizeof(int32)
	<.main+2751 @051b1e> : 2a f0 03 00                load.m32 <@0003f0>
	test/lang/reflect.ci:9: (4 bytes: <@051b22> - <@051b26>): sizeofInt64: int32 := sizeof(int64)
	<.main+2755 @051b22> : 2a 90 04 00                load.m32 <@000490>
	test/lang/reflect.ci:10: (4 bytes: <@051b26> - <@051b2a>): sizeofUint8: int32 := sizeof(uint8)
	<.main+2759 @051b26> : 2a 30 05 00                load.m32 <@000530>
	test/lang/reflect.ci:11: (4 bytes: <@051b2a> - <@051b2e>): sizeofUint16: int32 := sizeof(uint16)
	<.main+2763 @051b2a> : 2a d0 05 00                load.m32 <@0005d0>
	test/lang/reflect.ci:12: (4 bytes: <@051b2e> - <@051b32>): sizeofUint32: int32 := sizeof(uint32)
	<.main+2767 @051b2e> : 2a 70 06 00                load.m32 <@000670>
	test/lang/reflect.ci:13: (4 bytes: <@051b32> - <@051b36>): sizeofUint64: int32 := sizeof(uint64)
	<.main+2771 @051b32> : 2a 10 07 00                load.m32 <@000710>
	test/lang/reflect.ci:14: (4 bytes: <@051b36> - <@051b3a>): sizeofFloat32: int32 := sizeof(float32)
	<.main+2775 @051b36> : 2a b0 07 00                load.m32 <@0007b0>
	test/lang/reflect.ci:15: (4 bytes: <@051b3a> - <@051b3e>): sizeofFloat64: int32 := sizeof(float64)
	<.main+2779 @051b3a> : 2a 50 08 00                load.m32 <@000850>
	test/lang/reflect.ci:16: (4 bytes: <@051b3e> - <@051b42>): sizeofPointer: int32 := sizeof(pointer)
	<.main+2783 @051b3e> : 2a f0 08 00                load.m32 <@0008f0>
	test/lang/reflect.ci:17: (4 bytes: <@051b42> - <@051b46>): sizeofVariant: int32 := sizeof(variant)
	<.main+2787 @051b42> : 2a 90 09 00                load.m32 <@000990>
	test/lang/reflect.ci:18: (4 bytes: <@051b46> - <@051b4a>): sizeofTypename: int32 := sizeof(typename)
	<.main+2791 @051b46> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	test/lang/reflect.ci:19: (4 bytes: <@051b4a> - <@051b4e>): sizeofFunction: int32 := sizeof(function)
	<.main+2795 @051b4a> : 2a 30 0a 00                load.m32 <@000a30>
	test/lang/reflect.ci:20: (4 bytes: <@051b4e> - <@051b52>): sizeofObject: int32 := sizeof(object)
	<.main+2799 @051b4e> : 2a d8 0a 00                load.m32 <@000ad8>
	test/lang/reflect.ci:30: (5 bytes: <@051b52> - <@051b57>): typeofRecord: typename := RecordSizeofExt
	<.main+2803 @051b52> : 1f b8 6f 03 00             load.ref <@036fb8> ;RecordSizeofExt
	test/lang/reflect.ci:31: (6 bytes: <@051b57> - <@051b5d>): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+2808 @051b57> : 10 00                      dup.x1 sp(0)
	<.main+2810 @051b59> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:32: (7 bytes: <@051b5d> - <@051b64>): offsetOfRecord: int32 := typeofRecord.offset
	<.main+2814 @051b5d> : 10 01                      dup.x1 sp(1)
	<.main+2816 @051b5f> : 0c 28 00 00                inc.i32(+40)
	<.main+2820 @051b63> : 22                         load.i32
	test/lang/reflect.ci:33: (7 bytes: <@051b64> - <@051b6b>): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+2821 @051b64> : 10 02                      dup.x1 sp(2)
	<.main+2823 @051b66> : 0c 20 00 00                inc.i32(+32)
	<.main+2827 @051b6a> : 22                         load.i32
	test/lang/reflect.ci:34: (6 bytes: <@051b6b> - <@051b71>): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+2828 @051b6b> : 10 03                      dup.x1 sp(3)
	<.main+2830 @051b6d> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:35: (6 bytes: <@051b71> - <@051b77>): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+2834 @051b71> : 10 04                      dup.x1 sp(4)
	<.main+2836 @051b73> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:37: (6 bytes: <@051b77> - <@051b7d>): typeofBase: typename := typename.base(typeofRecord)
	<.main+2840 @051b77> : 10 05                      dup.x1 sp(5)
	<.main+2842 @051b79> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:38: (6 bytes: <@051b7d> - <@051b83>): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+2846 @051b7d> : 10 00                      dup.x1 sp(0)
	<.main+2848 @051b7f> : 01 04 00 00                nfc(4) ;typename.name(type: typename): .cstr
	test/lang/reflect.ci:39: (7 bytes: <@051b83> - <@051b8a>): offsetOfBase: int32 := typeofBase.offset
	<.main+2852 @051b83> : 10 01                      dup.x1 sp(1)
	<.main+2854 @051b85> : 0c 28 00 00                inc.i32(+40)
	<.main+2858 @051b89> : 22                         load.i32
	test/lang/reflect.ci:40: (7 bytes: <@051b8a> - <@051b91>): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+2859 @051b8a> : 10 02                      dup.x1 sp(2)
	<.main+2861 @051b8c> : 0c 20 00 00                inc.i32(+32)
	<.main+2865 @051b90> : 22                         load.i32
	test/lang/reflect.ci:41: (6 bytes: <@051b91> - <@051b97>): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+2866 @051b91> : 10 03                      dup.x1 sp(3)
	<.main+2868 @051b93> : 01 02 00 00                nfc(2) ;typename.file(type: typename): .cstr
	test/lang/reflect.ci:42: (6 bytes: <@051b97> - <@051b9d>): lineOfBase: int32 := typename.line(typeofBase)
	<.main+2872 @051b97> : 10 04                      dup.x1 sp(4)
	<.main+2874 @051b99> : 01 03 00 00                nfc(3) ;typename.line(type: typename): int32
	test/lang/reflect.ci:44: (6 bytes: <@051b9d> - <@051ba3>): typeofBase1: typename := typename.base(typeofBase)
	<.main+2878 @051b9d> : 10 05                      dup.x1 sp(5)
	<.main+2880 @051b9f> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:45: (7 bytes: <@051ba3> - <@051baa>): offsetOfBase1: int32 := typeofBase1.offset
	<.main+2884 @051ba3> : 10 00                      dup.x1 sp(0)
	<.main+2886 @051ba5> : 0c 28 00 00                inc.i32(+40)
	<.main+2890 @051ba9> : 22                         load.i32
	test/lang/reflect.ci:46: (7 bytes: <@051baa> - <@051bb1>): sizeOfBase1: int32 := typeofBase1.size
	<.main+2891 @051baa> : 10 01                      dup.x1 sp(1)
	<.main+2893 @051bac> : 0c 20 00 00                inc.i32(+32)
	<.main+2897 @051bb0> : 22                         load.i32
	test/lang/reflect.ci:48: (6 bytes: <@051bb1> - <@051bb7>): typeofBase2: typename := typename.base(typeofBase1)
	<.main+2898 @051bb1> : 10 02                      dup.x1 sp(2)
	<.main+2900 @051bb3> : 01 01 00 00                nfc(1) ;typename.base(type: typename): typename
	test/lang/reflect.ci:49: (7 bytes: <@051bb7> - <@051bbe>): offsetOfBase2: int32 := typeofBase2.offset
	<.main+2904 @051bb7> : 10 00                      dup.x1 sp(0)
	<.main+2906 @051bb9> : 0c 28 00 00                inc.i32(+40)
	<.main+2910 @051bbd> : 22                         load.i32
	test/lang/reflect.ci:50: (7 bytes: <@051bbe> - <@051bc5>): sizeOfBase2: int32 := typeofBase2.size
	<.main+2911 @051bbe> : 10 01                      dup.x1 sp(1)
	<.main+2913 @051bc0> : 0c 20 00 00                inc.i32(+32)
	<.main+2917 @051bc4> : 22                         load.i32
	test/stdc/number.ci:3: (9 bytes: <@051bc5> - <@051bce>): pi64: float64 := 3.141593
	<.main+2918 @051bc5> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	test/stdc/number.ci:4: (9 bytes: <@051bce> - <@051bd7>): e64: float64 := 2.718282
	<.main+2927 @051bce> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	test/stdc/number.ci:6: (3 bytes: <@051bd7> - <@051bda>): pi32: float32 := pi64
	<.main+2936 @051bd7> : 11 02                      dup.x2 sp(2)
	<.main+2938 @051bd9> : 8b                         f64.2f32
	test/stdc/number.ci:7: (3 bytes: <@051bda> - <@051bdd>): e32: float32 := e64
	<.main+2939 @051bda> : 11 01                      dup.x2 sp(1)
	<.main+2941 @051bdc> : 8b                         f64.2f32
	test/stdc/number.ci:14: (7 bytes: <@051bdd> - <@051be4>): r_comp: int32 := int32(14 << 3)
	<.main+2942 @051bdd> : 1c 0e 00 00 00             load.c32 14
	<.main+2947 @051be2> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:15: (7 bytes: <@051be4> - <@051beb>): g_comp: int32 := int32(63 << 2)
	<.main+2949 @051be4> : 1c 3f 00 00 00             load.c32 63
	<.main+2954 @051be9> : 3f 42                      b32.shl 0x002
	test/stdc/number.ci:16: (7 bytes: <@051beb> - <@051bf2>): b_comp: int32 := int32(31 << 3)
	<.main+2956 @051beb> : 1c 1f 00 00 00             load.c32 31
	<.main+2961 @051bf0> : 3f 43                      b32.shl 0x003
	test/stdc/number.ci:18: (28 bytes: <@051bf2> - <@051c0e>): r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+2963 @051bf2> : 10 02                      dup.x1 sp(2)
	<.main+2965 @051bf4> : 3f 48                      b32.shl 0x008
	<.main+2967 @051bf6> : 1c 00 f8 00 00             load.c32 63488
	<.main+2972 @051bfb> : 31                         and.b32
	<.main+2973 @051bfc> : 10 02                      dup.x1 sp(2)
	<.main+2975 @051bfe> : 3f 43                      b32.shl 0x003
	<.main+2977 @051c00> : 1c e0 07 00 00             load.c32 2016
	<.main+2982 @051c05> : 31                         and.b32
	<.main+2983 @051c06> : 32                         or.b32
	<.main+2984 @051c07> : 10 01                      dup.x1 sp(1)
	<.main+2986 @051c09> : 3f c3                      b32.sar 0x003
	<.main+2988 @051c0b> : 3f 05                      b32.and 0x01f
	<.main+2990 @051c0d> : 32                         or.b32
	test/stdc/number.ci:19: (26 bytes: <@051c0e> - <@051c28>): r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+2991 @051c0e> : 10 03                      dup.x1 sp(3)
	<.main+2993 @051c10> : 3f 50                      b32.shl 0x010
	<.main+2995 @051c12> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3000 @051c17> : 31                         and.b32
	<.main+3001 @051c18> : 10 03                      dup.x1 sp(3)
	<.main+3003 @051c1a> : 3f 48                      b32.shl 0x008
	<.main+3005 @051c1c> : 1c 00 ff 00 00             load.c32 65280
	<.main+3010 @051c21> : 31                         and.b32
	<.main+3011 @051c22> : 32                         or.b32
	<.main+3012 @051c23> : 10 02                      dup.x1 sp(2)
	<.main+3014 @051c25> : 3f 08                      b32.and 0x0ff
	<.main+3016 @051c27> : 32                         or.b32
	test/stdc/number.ci:21: (16 bytes: <@051c28> - <@051c38>): zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3017 @051c28> : 10 01                      dup.x1 sp(1)
	<.main+3019 @051c2a> : 1c 0b 00 00 00             load.c32 11
	<.main+3024 @051c2f> : 1c 05 00 00 00             load.c32 5
	<.main+3029 @051c34> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:22: (16 bytes: <@051c38> - <@051c48>): zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+3033 @051c38> : 10 02                      dup.x1 sp(2)
	<.main+3035 @051c3a> : 1c 05 00 00 00             load.c32 5
	<.main+3040 @051c3f> : 1c 06 00 00 00             load.c32 6
	<.main+3045 @051c44> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:23: (12 bytes: <@051c48> - <@051c54>): zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3049 @051c48> : 10 03                      dup.x1 sp(3)
	<.main+3051 @051c4a> : 19                         load.z32
	<.main+3052 @051c4b> : 1c 05 00 00 00             load.c32 5
	<.main+3057 @051c50> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:25: (16 bytes: <@051c54> - <@051c64>): sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+3061 @051c54> : 10 04                      dup.x1 sp(4)
	<.main+3063 @051c56> : 1c 0b 00 00 00             load.c32 11
	<.main+3068 @051c5b> : 1c 05 00 00 00             load.c32 5
	<.main+3073 @051c60> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:26: (16 bytes: <@051c64> - <@051c74>): sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+3077 @051c64> : 10 05                      dup.x1 sp(5)
	<.main+3079 @051c66> : 1c 05 00 00 00             load.c32 5
	<.main+3084 @051c6b> : 1c 06 00 00 00             load.c32 6
	<.main+3089 @051c70> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:27: (12 bytes: <@051c74> - <@051c80>): sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3093 @051c74> : 10 06                      dup.x1 sp(6)
	<.main+3095 @051c76> : 19                         load.z32
	<.main+3096 @051c77> : 1c 05 00 00 00             load.c32 5
	<.main+3101 @051c7c> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:29: (16 bytes: <@051c80> - <@051c90>): zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+3105 @051c80> : 10 06                      dup.x1 sp(6)
	<.main+3107 @051c82> : 1c 10 00 00 00             load.c32 16
	<.main+3112 @051c87> : 1c 08 00 00 00             load.c32 8
	<.main+3117 @051c8c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:30: (16 bytes: <@051c90> - <@051ca0>): zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+3121 @051c90> : 10 07                      dup.x1 sp(7)
	<.main+3123 @051c92> : 1c 08 00 00 00             load.c32 8
	<.main+3128 @051c97> : 1c 08 00 00 00             load.c32 8
	<.main+3133 @051c9c> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:31: (12 bytes: <@051ca0> - <@051cac>): zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+3137 @051ca0> : 10 08                      dup.x1 sp(8)
	<.main+3139 @051ca2> : 19                         load.z32
	<.main+3140 @051ca3> : 1c 08 00 00 00             load.c32 8
	<.main+3145 @051ca8> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:33: (16 bytes: <@051cac> - <@051cbc>): sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+3149 @051cac> : 10 09                      dup.x1 sp(9)
	<.main+3151 @051cae> : 1c 10 00 00 00             load.c32 16
	<.main+3156 @051cb3> : 1c 08 00 00 00             load.c32 8
	<.main+3161 @051cb8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:34: (16 bytes: <@051cbc> - <@051ccc>): sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+3165 @051cbc> : 10 0a                      dup.x1 sp(10)
	<.main+3167 @051cbe> : 1c 08 00 00 00             load.c32 8
	<.main+3172 @051cc3> : 1c 08 00 00 00             load.c32 8
	<.main+3177 @051cc8> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:35: (12 bytes: <@051ccc> - <@051cd8>): sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+3181 @051ccc> : 10 0b                      dup.x1 sp(11)
	<.main+3183 @051cce> : 19                         load.z32
	<.main+3184 @051ccf> : 1c 08 00 00 00             load.c32 8
	<.main+3189 @051cd4> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:37: (16 bytes: <@051cd8> - <@051ce8>): testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+3193 @051cd8> : 11 15                      dup.x2 sp(21)
	<.main+3195 @051cda> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3204 @051ce3> : 84                         div.f64
	<.main+3205 @051ce4> : 01 24 00 00                nfc(36) ;float64.sin(x: float64): float64
	test/stdc/number.ci:38: (16 bytes: <@051ce8> - <@051cf8>): testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+3209 @051ce8> : 11 17                      dup.x2 sp(23)
	<.main+3211 @051cea> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+3220 @051cf3> : 84                         div.f64
	<.main+3221 @051cf4> : 01 25 00 00                nfc(37) ;float64.cos(x: float64): float64
	test/stdc/number.ci:39: (16 bytes: <@051cf8> - <@051d08>): testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+3225 @051cf8> : 11 19                      dup.x2 sp(25)
	<.main+3227 @051cfa> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+3236 @051d03> : 84                         div.f64
	<.main+3237 @051d04> : 01 26 00 00                nfc(38) ;float64.tan(x: float64): float64
	test/stdc/number.ci:40: (12 bytes: <@051d08> - <@051d14>): testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+3241 @051d08> : 11 19                      dup.x2 sp(25)
	<.main+3243 @051d0a> : 11 1b                      dup.x2 sp(27)
	<.main+3245 @051d0c> : 83                         mul.f64
	<.main+3246 @051d0d> : 11 1b                      dup.x2 sp(27)
	<.main+3248 @051d0f> : 83                         mul.f64
	<.main+3249 @051d10> : 01 27 00 00                nfc(39) ;float64.log(x: float64): float64
	test/stdc/number.ci:41: (13 bytes: <@051d14> - <@051d21>): testExp_f64: float64 := float64.exp(1.000000)
	<.main+3253 @051d14> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3262 @051d1d> : 01 28 00 00                nfc(40) ;float64.exp(x: float64): float64
	test/stdc/number.ci:42: (18 bytes: <@051d21> - <@051d33>): testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+3266 @051d21> : 11 1f                      dup.x2 sp(31)
	<.main+3268 @051d23> : 11 21                      dup.x2 sp(33)
	<.main+3270 @051d25> : 83                         mul.f64
	<.main+3271 @051d26> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3280 @051d2f> : 01 29 00 00                nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc/number.ci:43: (9 bytes: <@051d33> - <@051d3c>): testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+3284 @051d33> : 11 21                      dup.x2 sp(33)
	<.main+3286 @051d35> : 11 23                      dup.x2 sp(35)
	<.main+3288 @051d37> : 83                         mul.f64
	<.main+3289 @051d38> : 01 2a 00 00                nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc/number.ci:44: (15 bytes: <@051d3c> - <@051d4b>): testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+3293 @051d3c> : 11 23                      dup.x2 sp(35)
	<.main+3295 @051d3e> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3304 @051d47> : 01 2b 00 00                nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc/number.ci:46: (12 bytes: <@051d4b> - <@051d57>): testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+3308 @051d4b> : 10 22                      dup.x1 sp(34)
	<.main+3310 @051d4d> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3315 @051d52> : 74                         div.f32
	<.main+3316 @051d53> : 01 1c 00 00                nfc(28) ;float32.sin(x: float32): float32
	test/stdc/number.ci:47: (12 bytes: <@051d57> - <@051d63>): testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+3320 @051d57> : 10 23                      dup.x1 sp(35)
	<.main+3322 @051d59> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3327 @051d5e> : 74                         div.f32
	<.main+3328 @051d5f> : 01 1d 00 00                nfc(29) ;float32.cos(x: float32): float32
	test/stdc/number.ci:48: (12 bytes: <@051d63> - <@051d6f>): testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+3332 @051d63> : 10 24                      dup.x1 sp(36)
	<.main+3334 @051d65> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3339 @051d6a> : 74                         div.f32
	<.main+3340 @051d6b> : 01 1e 00 00                nfc(30) ;float32.tan(x: float32): float32
	test/stdc/number.ci:49: (12 bytes: <@051d6f> - <@051d7b>): testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+3344 @051d6f> : 10 24                      dup.x1 sp(36)
	<.main+3346 @051d71> : 10 25                      dup.x1 sp(37)
	<.main+3348 @051d73> : 73                         mul.f32
	<.main+3349 @051d74> : 10 25                      dup.x1 sp(37)
	<.main+3351 @051d76> : 73                         mul.f32
	<.main+3352 @051d77> : 01 1f 00 00                nfc(31) ;float32.log(x: float32): float32
	test/stdc/number.ci:50: (9 bytes: <@051d7b> - <@051d84>): testExp_f32: float32 := float32.exp(1.000000)
	<.main+3356 @051d7b> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3361 @051d80> : 01 20 00 00                nfc(32) ;float32.exp(x: float32): float32
	test/stdc/number.ci:51: (14 bytes: <@051d84> - <@051d92>): testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+3365 @051d84> : 10 27                      dup.x1 sp(39)
	<.main+3367 @051d86> : 10 28                      dup.x1 sp(40)
	<.main+3369 @051d88> : 73                         mul.f32
	<.main+3370 @051d89> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3375 @051d8e> : 01 21 00 00                nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc/number.ci:52: (9 bytes: <@051d92> - <@051d9b>): testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+3379 @051d92> : 10 28                      dup.x1 sp(40)
	<.main+3381 @051d94> : 10 29                      dup.x1 sp(41)
	<.main+3383 @051d96> : 73                         mul.f32
	<.main+3384 @051d97> : 01 22 00 00                nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc/number.ci:53: (11 bytes: <@051d9b> - <@051da6>): testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+3388 @051d9b> : 10 29                      dup.x1 sp(41)
	<.main+3390 @051d9d> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3395 @051da2> : 01 23 00 00                nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc/number.ci:55: (6 bytes: <@051da6> - <@051dac>): testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3399 @051da6> : 10 25                      dup.x1 sp(37)
	<.main+3401 @051da8> : 01 14 00 00                nfc(20) ;uint32.pop(value: int32): int32
	test/stdc/number.ci:56: (6 bytes: <@051dac> - <@051db2>): testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3405 @051dac> : 10 26                      dup.x1 sp(38)
	<.main+3407 @051dae> : 01 15 00 00                nfc(21) ;uint32.swap(value: int32): int32
	test/stdc/number.ci:57: (6 bytes: <@051db2> - <@051db8>): testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3411 @051db2> : 10 27                      dup.x1 sp(39)
	<.main+3413 @051db4> : 01 16 00 00                nfc(22) ;uint32.bsr(value: int32): int32
	test/stdc/number.ci:58: (6 bytes: <@051db8> - <@051dbe>): testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3417 @051db8> : 10 28                      dup.x1 sp(40)
	<.main+3419 @051dba> : 01 17 00 00                nfc(23) ;uint32.bsf(value: int32): int32
	test/stdc/number.ci:59: (6 bytes: <@051dbe> - <@051dc4>): testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3423 @051dbe> : 10 29                      dup.x1 sp(41)
	<.main+3425 @051dc0> : 01 18 00 00                nfc(24) ;uint32.hib(value: int32): int32
	test/stdc/number.ci:60: (6 bytes: <@051dc4> - <@051dca>): testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3429 @051dc4> : 10 2a                      dup.x1 sp(42)
	<.main+3431 @051dc6> : 01 19 00 00                nfc(25) ;uint32.lob(value: int32): int32
	test/stdc/number.ci:62: (12 bytes: <@051dca> - <@051dd6>): testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+3435 @051dca> : 10 2b                      dup.x1 sp(43)
	<.main+3437 @051dcc> : 19                         load.z32
	<.main+3438 @051dcd> : 1c 05 00 00 00             load.c32 5
	<.main+3443 @051dd2> : 01 12 00 00                nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:63: (12 bytes: <@051dd6> - <@051de2>): testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+3447 @051dd6> : 10 2c                      dup.x1 sp(44)
	<.main+3449 @051dd8> : 19                         load.z32
	<.main+3450 @051dd9> : 1c 05 00 00 00             load.c32 5
	<.main+3455 @051dde> : 01 13 00 00                nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc/number.ci:65: (14 bytes: <@051de2> - <@051df0>): testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+3459 @051de2> : 10 2d                      dup.x1 sp(45)
	<.main+3461 @051de4> : 5c                         i32.2i64
	<.main+3462 @051de5> : 19                         load.z32
	<.main+3463 @051de6> : 1c 05 00 00 00             load.c32 5
	<.main+3468 @051deb> : 01 1a 00 00                nfc(26) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3472 @051def> : 6a                         i64.2i32
	test/stdc/number.ci:66: (14 bytes: <@051df0> - <@051dfe>): testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+3473 @051df0> : 10 2e                      dup.x1 sp(46)
	<.main+3475 @051df2> : 5c                         i32.2i64
	<.main+3476 @051df3> : 19                         load.z32
	<.main+3477 @051df4> : 1c 05 00 00 00             load.c32 5
	<.main+3482 @051df9> : 01 1b 00 00                nfc(27) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3486 @051dfd> : 6a                         i64.2i32
	test/stdc/memory.ci:7: (14 bytes: <@051dfe> - <@051e0c>): p1: pointer := malloc(1024)
	<.main+3487 @051dfe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3492 @051e03> : 1c 00 04 00 00             load.c32 1024
	<.main+3497 @051e08> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:8: (14 bytes: <@051e0c> - <@051e1a>): p2: pointer := malloc(80)
	<.main+3501 @051e0c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3506 @051e11> : 1c 50 00 00 00             load.c32 80
	<.main+3511 @051e16> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:9: (14 bytes: <@051e1a> - <@051e28>): p3: pointer := malloc(160)
	<.main+3515 @051e1a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3520 @051e1f> : 1c a0 00 00 00             load.c32 160
	<.main+3525 @051e24> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:10: (14 bytes: <@051e28> - <@051e36>): p4: pointer := malloc(820)
	<.main+3529 @051e28> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3534 @051e2d> : 1c 34 03 00 00             load.c32 820
	<.main+3539 @051e32> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc/memory.ci:13: (16 bytes: <@051e36> - <@051e46>): pointer.fill(void(void(p1, 0), 1024));
	<.main+3543 @051e36> : 10 03                      dup.x1 sp(3)
	<.main+3545 @051e38> : 19                         load.z32
	<.main+3546 @051e39> : 1c 00 04 00 00             load.c32 1024
	<.main+3551 @051e3e> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3555 @051e42> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (17 bytes: <@051e46> - <@051e57>): pointer.copy(void(void(p1, p3), 160));
	<.main+3559 @051e46> : 10 03                      dup.x1 sp(3)
	<.main+3561 @051e48> : 10 02                      dup.x1 sp(2)
	<.main+3563 @051e4a> : 1c a0 00 00 00             load.c32 160
	<.main+3568 @051e4f> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+3572 @051e53> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (11 bytes: <@051e57> - <@051e62>): free(p1);
	<.main+3576 @051e57> : 10 03                      dup.x1 sp(3)
	<.main+3578 @051e59> : 19                         load.z32
	<.main+3579 @051e5a> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3583 @051e5e> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (11 bytes: <@051e62> - <@051e6d>): free(p2);
	<.main+3587 @051e62> : 10 02                      dup.x1 sp(2)
	<.main+3589 @051e64> : 19                         load.z32
	<.main+3590 @051e65> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3594 @051e69> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (11 bytes: <@051e6d> - <@051e78>): free(p3);
	<.main+3598 @051e6d> : 10 01                      dup.x1 sp(1)
	<.main+3600 @051e6f> : 19                         load.z32
	<.main+3601 @051e70> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3605 @051e74> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (11 bytes: <@051e78> - <@051e83>): free(p4);
	<.main+3609 @051e78> : 10 00                      dup.x1 sp(0)
	<.main+3611 @051e7a> : 19                         load.z32
	<.main+3612 @051e7b> : 01 07 00 00                nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3616 @051e7f> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:23: (9 bytes: <@051e83> - <@051e8c>): val1: int64 := 42
	<.main+3620 @051e83> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/stdc/memory.ci:24: (9 bytes: <@051e8c> - <@051e95>): val2: int64 := 96
	<.main+3629 @051e8c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/stdc/memory.ci:26: (34 bytes: <@051e95> - <@051eb7>): debug(void("val1", val1));
	<.main+3638 @051e95> : 1f 70 a2 03 00             load.ref <@03a270> ;"test/stdc/memory.ci"
	<.main+3643 @051e9a> : 1c 1a 00 00 00             load.c32 26
	<.main+3648 @051e9f> : 1c 0e 00 00 00             load.c32 14
	<.main+3653 @051ea4> : 19                         load.z32
	<.main+3654 @051ea5> : 1f 98 a2 03 00             load.ref <@03a298> ;"val1"
	<.main+3659 @051eaa> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3664 @051eaf> : 0a 20 00 00                load.sp(+32)
	<.main+3668 @051eb3> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (34 bytes: <@051eb7> - <@051ed9>): debug(void("val2", val2));
	<.main+3672 @051eb7> : 1f 70 a2 03 00             load.ref <@03a270> ;"test/stdc/memory.ci"
	<.main+3677 @051ebc> : 1c 1b 00 00 00             load.c32 27
	<.main+3682 @051ec1> : 1c 0e 00 00 00             load.c32 14
	<.main+3687 @051ec6> : 19                         load.z32
	<.main+3688 @051ec7> : 1f 9d a2 03 00             load.ref <@03a29d> ;"val2"
	<.main+3693 @051ecc> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3698 @051ed1> : 0a 18 00 00                load.sp(+24)
	<.main+3702 @051ed5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (20 bytes: <@051ed9> - <@051eed>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+3706 @051ed9> : 0a 00 00 00                load.sp(+0)
	<.main+3710 @051edd> : 0a 0c 00 00                load.sp(+12)
	<.main+3714 @051ee1> : 2a 90 04 00                load.m32 <@000490>
	<.main+3718 @051ee5> : 01 0a 00 00                nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+3722 @051ee9> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (17 bytes: <@051eed> - <@051efe>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+3726 @051eed> : 0a 08 00 00                load.sp(+8)
	<.main+3730 @051ef1> : 19                         load.z32
	<.main+3731 @051ef2> : 2a 90 04 00                load.m32 <@000490>
	<.main+3735 @051ef6> : 01 08 00 00                nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+3739 @051efa> : 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (34 bytes: <@051efe> - <@051f20>): debug(void("val1", val1));
	<.main+3743 @051efe> : 1f 70 a2 03 00             load.ref <@03a270> ;"test/stdc/memory.ci"
	<.main+3748 @051f03> : 1c 20 00 00 00             load.c32 32
	<.main+3753 @051f08> : 1c 0e 00 00 00             load.c32 14
	<.main+3758 @051f0d> : 19                         load.z32
	<.main+3759 @051f0e> : 1f 98 a2 03 00             load.ref <@03a298> ;"val1"
	<.main+3764 @051f13> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3769 @051f18> : 0a 20 00 00                load.sp(+32)
	<.main+3773 @051f1c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (34 bytes: <@051f20> - <@051f42>): debug(void("val2", val2));
	<.main+3777 @051f20> : 1f 70 a2 03 00             load.ref <@03a270> ;"test/stdc/memory.ci"
	<.main+3782 @051f25> : 1c 21 00 00 00             load.c32 33
	<.main+3787 @051f2a> : 1c 0e 00 00 00             load.c32 14
	<.main+3792 @051f2f> : 19                         load.z32
	<.main+3793 @051f30> : 1f 9d a2 03 00             load.ref <@03a29d> ;"val2"
	<.main+3798 @051f35> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3803 @051f3a> : 0a 18 00 00                load.sp(+24)
	<.main+3807 @051f3e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/tryExec.ci:46: (14 bytes: <@051f42> - <@051f50>): tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+3811 @051f42> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3816 @051f47> : 1f 38 0e 05 00             load.ref <@050e38> ;noError(ptr: pointer): void
	<.main+3821 @051f4c> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:47: (14 bytes: <@051f50> - <@051f5e>): tryExecErr1: int32 := tryExec(void(null, null))
	<.main+3825 @051f50> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3830 @051f55> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3835 @051f5a> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:48: (14 bytes: <@051f5e> - <@051f6c>): tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+3839 @051f5e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3844 @051f63> : 1f 40 0e 05 00             load.ref <@050e40> ;stackOverflow(ptr: pointer): void
	<.main+3849 @051f68> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:49: (14 bytes: <@051f6c> - <@051f7a>): tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+3853 @051f6c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3858 @051f71> : 1f 58 0e 05 00             load.ref <@050e58> ;divisionByZero(args: pointer): void
	<.main+3863 @051f76> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:50: (14 bytes: <@051f7a> - <@051f88>): tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+3867 @051f7a> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3872 @051f7f> : 1f c0 0e 05 00             load.ref <@050ec0> ;invalidInstruction(args: pointer): void
	<.main+3877 @051f84> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:51: (14 bytes: <@051f88> - <@051f96>): tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+3881 @051f88> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3886 @051f8d> : 1f b0 0e 05 00             load.ref <@050eb0> ;invalidMemoryAccess(args: pointer): void
	<.main+3891 @051f92> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc/tryExec.ci:52: (14 bytes: <@051f96> - <@051fa4>): tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+3895 @051f96> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3900 @051f9b> : 1f 68 0e 05 00             load.ref <@050e68> ;abortExecution(args: pointer): void
	<.main+3905 @051fa0> : 01 06 00 00                nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang/array.ci:49: (4 bytes: <@051fa4> - <@051fa8>): arrFixedNoInit: int64[7]
	<.main+3909 @051fa4> : 09 38 00 00                inc.sp(+56)
	test/lang/array.ci:50: (4 bytes: <@051fa8> - <@051fac>): arrArrayNoInit: int64[*]
	<.main+3913 @051fa8> : 09 04 00 00                inc.sp(+4)
	test/lang/array.ci:51: (4 bytes: <@051fac> - <@051fb0>): arrSliceNoInit: int64[]
	<.main+3917 @051fac> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:54: (45 bytes: <@051fb0> - <@051fdd>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+3921 @051fb0> : 19                         load.z32
	<.main+3922 @051fb1> : 04 1c 00 00                jmp <.main+3950 @051fcd>
	test/lang/array.ci:55: (20 bytes: <@051fb5> - <@051fc9>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+3926 @051fb5> : 1c 2a 00 00 00             load.c32 42
	<.main+3931 @051fba> : 10 01                      dup.x1 sp(1)
	<.main+3933 @051fbc> : 51                         add.i32
	<.main+3934 @051fbd> : 5c                         i32.2i64
	<.main+3935 @051fbe> : 0a 18 00 00                load.sp(+24)
	<.main+3939 @051fc2> : 10 03                      dup.x1 sp(3)
	<.main+3941 @051fc4> : 0d 08 00 00                mad.u32 8
	<.main+3945 @051fc8> : 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@051fc9> - <@051fcd>): int32(i := int32(i + 1))
	<.main+3946 @051fc9> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@051fcd> - <@051fd9>): bool(i < arrFixedNoInit.length)
	<.main+3950 @051fcd> : 10 00                      dup.x1 sp(0)
	<.main+3952 @051fcf> : 1c 07 00 00 00             load.c32 7
	<.main+3957 @051fd4> : 58                         clt.i32
	<.main+3958 @051fd5> : 05 e0 ff ff                jnz <.main+3926 @051fb5>
	<.main+3962 @051fd9> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:59: (5 bytes: <@051fdd> - <@051fe2>): arrArrayInitNull: int64[*] := null
	<.main+3966 @051fdd> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:60: (6 bytes: <@051fe2> - <@051fe8>): arrSliceInitNull: int64[] := null
	<.main+3971 @051fe2> : 19                         load.z32
	<.main+3972 @051fe3> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/array.ci:63: (4 bytes: <@051fe8> - <@051fec>): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+3977 @051fe8> : 0a 18 00 00                load.sp(+24)
	test/lang/array.ci:64: (9 bytes: <@051fec> - <@051ff5>): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+3981 @051fec> : 1c 07 00 00 00             load.c32 7
	<.main+3986 @051ff1> : 0a 20 00 00                load.sp(+32)
	test/lang/array.ci:67: (2 bytes: <@051ff5> - <@051ff7>): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+3990 @051ff5> : 10 00                      dup.x1 sp(0)
	test/lang/array.ci:68: (2 bytes: <@051ff7> - <@051ff9>): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+3992 @051ff7> : 11 01                      dup.x2 sp(1)
	test/lang/array.ci:71: (2 bytes: <@051ff9> - <@051ffb>): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+3994 @051ff9> : 10 05                      dup.x1 sp(5)
	test/lang/array.ci:81: (4 bytes: <@051ffb> - <@051fff>): strFixed: char[7]
	<.main+3996 @051ffb> : 09 08 00 00                inc.sp(+8)
	test/lang/array.ci:82: (22 bytes: <@051fff> - <@052015>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+4000 @051fff> : 0a 00 00 00                load.sp(+0)
	<.main+4004 @052003> : 1f a4 b2 02 00             load.ref <@02b2a4> ;"string"
	<.main+4009 @052008> : 1c 07 00 00 00             load.c32 7
	<.main+4014 @05200d> : 01 09 00 00                nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+4018 @052011> : 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (34 bytes: <@052015> - <@052037>): debug(void("string as variant", strFixed));
	<.main+4022 @052015> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4027 @05201a> : 1c 53 00 00 00             load.c32 83
	<.main+4032 @05201f> : 1c 0e 00 00 00             load.c32 14
	<.main+4037 @052024> : 19                         load.z32
	<.main+4038 @052025> : 1f c3 c3 03 00             load.ref <@03c3c3> ;"string as variant"
	<.main+4043 @05202a> : 1f d0 d1 03 00             load.ref <@03d1d0>
	<.main+4048 @05202f> : 0a 18 00 00                load.sp(+24)
	<.main+4052 @052033> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (34 bytes: <@052037> - <@052059>): debug(void("string to variant", variant(strFixed)));
	<.main+4056 @052037> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4061 @05203c> : 1c 54 00 00 00             load.c32 84
	<.main+4066 @052041> : 1c 0e 00 00 00             load.c32 14
	<.main+4071 @052046> : 19                         load.z32
	<.main+4072 @052047> : 1f d5 c3 03 00             load.ref <@03c3d5> ;"string to variant"
	<.main+4077 @05204c> : 1f d0 d1 03 00             load.ref <@03d1d0>
	<.main+4082 @052051> : 0a 18 00 00                load.sp(+24)
	<.main+4086 @052055> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:86: (5 bytes: <@052059> - <@05205e>): strArray: char[*] := "string"
	<.main+4090 @052059> : 1f a4 b2 02 00             load.ref <@02b2a4> ;"string"
	test/lang/array.ci:87: (32 bytes: <@05205e> - <@05207e>): debug(void("string as variant", strArray));
	<.main+4095 @05205e> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4100 @052063> : 1c 57 00 00 00             load.c32 87
	<.main+4105 @052068> : 1c 0e 00 00 00             load.c32 14
	<.main+4110 @05206d> : 19                         load.z32
	<.main+4111 @05206e> : 1f c3 c3 03 00             load.ref <@03c3c3> ;"string as variant"
	<.main+4116 @052073> : 1f 98 d3 03 00             load.ref <@03d398>
	<.main+4121 @052078> : 10 06                      dup.x1 sp(6)
	<.main+4123 @05207a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (32 bytes: <@05207e> - <@05209e>): debug(void("string to variant", variant(strArray)));
	<.main+4127 @05207e> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4132 @052083> : 1c 58 00 00 00             load.c32 88
	<.main+4137 @052088> : 1c 0e 00 00 00             load.c32 14
	<.main+4142 @05208d> : 19                         load.z32
	<.main+4143 @05208e> : 1f d5 c3 03 00             load.ref <@03c3d5> ;"string to variant"
	<.main+4148 @052093> : 1f 98 d3 03 00             load.ref <@03d398>
	<.main+4153 @052098> : 10 06                      dup.x1 sp(6)
	<.main+4155 @05209a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:90: (10 bytes: <@05209e> - <@0520a8>): strSlice: char[] := "string"
	<.main+4159 @05209e> : 1c 06 00 00 00             load.c32 6
	<.main+4164 @0520a3> : 1f a4 b2 02 00             load.ref <@02b2a4> ;"string"
	test/lang/array.ci:91: (32 bytes: <@0520a8> - <@0520c8>): debug(void("string as variant", strSlice));
	<.main+4169 @0520a8> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4174 @0520ad> : 1c 5b 00 00 00             load.c32 91
	<.main+4179 @0520b2> : 1c 0e 00 00 00             load.c32 14
	<.main+4184 @0520b7> : 19                         load.z32
	<.main+4185 @0520b8> : 1f c3 c3 03 00             load.ref <@03c3c3> ;"string as variant"
	<.main+4190 @0520bd> : 1f c8 d4 03 00             load.ref <@03d4c8>
	<.main+4195 @0520c2> : 10 06                      dup.x1 sp(6)
	<.main+4197 @0520c4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (32 bytes: <@0520c8> - <@0520e8>): debug(void("string to variant", variant(strSlice)));
	<.main+4201 @0520c8> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4206 @0520cd> : 1c 5c 00 00 00             load.c32 92
	<.main+4211 @0520d2> : 1c 0e 00 00 00             load.c32 14
	<.main+4216 @0520d7> : 19                         load.z32
	<.main+4217 @0520d8> : 1f d5 c3 03 00             load.ref <@03c3d5> ;"string to variant"
	<.main+4222 @0520dd> : 1f c8 d4 03 00             load.ref <@03d4c8>
	<.main+4227 @0520e2> : 10 06                      dup.x1 sp(6)
	<.main+4229 @0520e4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (51 bytes: <@0520e8> - <@05211b>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+4233 @0520e8> : 10 10                      dup.x1 sp(16)
	<.main+4235 @0520ea> : 19                         load.z32
	<.main+4236 @0520eb> : 38                         clt.u32
	<.main+4237 @0520ec> : 05 08 00 00                jnz <.main+4245 @0520f4>
	<.main+4241 @0520f0> : 04 2b 00 00                jmp <.main+4284 @05211b>
	<.main+4245 @0520f4> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4250 @0520f9> : 1c 62 00 00 00             load.c32 98
	<.main+4255 @0520fe> : 1c fe ff ff ff             load.c32 -2
	<.main+4260 @052103> : 1c 80 00 00 00             load.c32 128
	<.main+4265 @052108> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4270 @05210d> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4275 @052112> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4280 @052117> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (51 bytes: <@05211b> - <@05214e>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+4284 @05211b> : 10 0d                      dup.x1 sp(13)
	<.main+4286 @05211d> : 19                         load.z32
	<.main+4287 @05211e> : 57                         ceq.i32
	<.main+4288 @05211f> : 06 08 00 00                jz <.main+4296 @052127>
	<.main+4292 @052123> : 04 2b 00 00                jmp <.main+4335 @05214e>
	<.main+4296 @052127> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4301 @05212c> : 1c 63 00 00 00             load.c32 99
	<.main+4306 @052131> : 1c fe ff ff ff             load.c32 -2
	<.main+4311 @052136> : 1c 80 00 00 00             load.c32 128
	<.main+4316 @05213b> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4321 @052140> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4326 @052145> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4331 @05214a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (59 bytes: <@05214e> - <@052189>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+4335 @05214e> : 11 12                      dup.x2 sp(18)
	<.main+4337 @052150> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4346 @052159> : 67                         ceq.i64
	<.main+4347 @05215a> : 06 08 00 00                jz <.main+4355 @052162>
	<.main+4351 @05215e> : 04 2b 00 00                jmp <.main+4394 @052189>
	<.main+4355 @052162> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4360 @052167> : 1c 65 00 00 00             load.c32 101
	<.main+4365 @05216c> : 1c fe ff ff ff             load.c32 -2
	<.main+4370 @052171> : 1c 80 00 00 00             load.c32 128
	<.main+4375 @052176> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4380 @05217b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4385 @052180> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4390 @052185> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@052189> - <@0521a2>): assertEq(void(7, arrFixedNoInit.length));
	<.main+4394 @052189> : 1c 07 00 00 00             load.c32 7
	<.main+4399 @05218e> : 1c 07 00 00 00             load.c32 7
	<.main+4404 @052193> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4409 @052198> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4414 @05219d> : 02                         call
	<.main+4415 @05219e> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (22 bytes: <@0521a2> - <@0521b8>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+4419 @0521a2> : 1c 07 00 00 00             load.c32 7
	<.main+4424 @0521a7> : 10 0b                      dup.x1 sp(11)
	<.main+4426 @0521a9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4431 @0521ae> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4436 @0521b3> : 02                         call
	<.main+4437 @0521b4> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (22 bytes: <@0521b8> - <@0521ce>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+4441 @0521b8> : 1c 07 00 00 00             load.c32 7
	<.main+4446 @0521bd> : 10 08                      dup.x1 sp(8)
	<.main+4448 @0521bf> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4453 @0521c4> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4458 @0521c9> : 02                         call
	<.main+4459 @0521ca> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@0521ce> - <@0521ee>): assertEq(void(0, lenSlice(null)));
	<.main+4463 @0521ce> : 19                         load.z32
	<.main+4464 @0521cf> : 1a                         load.z64
	<.main+4465 @0521d0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4470 @0521d5> : 1f c8 0e 05 00             load.ref <@050ec8> ;lenSlice(values: int64[]): int32
	<.main+4475 @0521da> : 02                         call
	<.main+4476 @0521db> : 09 f8 ff ff                inc.sp(-8)
	<.main+4480 @0521df> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4485 @0521e4> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4490 @0521e9> : 02                         call
	<.main+4491 @0521ea> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (29 bytes: <@0521ee> - <@05220b>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+4495 @0521ee> : 19                         load.z32
	<.main+4496 @0521ef> : 19                         load.z32
	<.main+4497 @0521f0> : 11 0e                      dup.x2 sp(14)
	<.main+4499 @0521f2> : 1f c8 0e 05 00             load.ref <@050ec8> ;lenSlice(values: int64[]): int32
	<.main+4504 @0521f7> : 02                         call
	<.main+4505 @0521f8> : 09 f8 ff ff                inc.sp(-8)
	<.main+4509 @0521fc> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4514 @052201> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4519 @052206> : 02                         call
	<.main+4520 @052207> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (40 bytes: <@05220b> - <@052233>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+4524 @05220b> : 1c 07 00 00 00             load.c32 7
	<.main+4529 @052210> : 19                         load.z32
	<.main+4530 @052211> : 1c 07 00 00 00             load.c32 7
	<.main+4535 @052216> : 0a 54 00 00                load.sp(+84)
	<.main+4539 @05221a> : 1f c8 0e 05 00             load.ref <@050ec8> ;lenSlice(values: int64[]): int32
	<.main+4544 @05221f> : 02                         call
	<.main+4545 @052220> : 09 f8 ff ff                inc.sp(-8)
	<.main+4549 @052224> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4554 @052229> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4559 @05222e> : 02                         call
	<.main+4560 @05222f> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (33 bytes: <@052233> - <@052254>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+4564 @052233> : 1c 07 00 00 00             load.c32 7
	<.main+4569 @052238> : 19                         load.z32
	<.main+4570 @052239> : 11 0b                      dup.x2 sp(11)
	<.main+4572 @05223b> : 1f c8 0e 05 00             load.ref <@050ec8> ;lenSlice(values: int64[]): int32
	<.main+4577 @052240> : 02                         call
	<.main+4578 @052241> : 09 f8 ff ff                inc.sp(-8)
	<.main+4582 @052245> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4587 @05224a> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4592 @05224f> : 02                         call
	<.main+4593 @052250> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (33 bytes: <@052254> - <@052275>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+4597 @052254> : 1c 07 00 00 00             load.c32 7
	<.main+4602 @052259> : 19                         load.z32
	<.main+4603 @05225a> : 11 08                      dup.x2 sp(8)
	<.main+4605 @05225c> : 1f c8 0e 05 00             load.ref <@050ec8> ;lenSlice(values: int64[]): int32
	<.main+4610 @052261> : 02                         call
	<.main+4611 @052262> : 09 f8 ff ff                inc.sp(-8)
	<.main+4615 @052266> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4620 @05226b> : 1f 10 fd 04 00             load.ref <@04fd10> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+4625 @052270> : 02                         call
	<.main+4626 @052271> : 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (807 bytes: <@052275> - <@05259c>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+4630 @052275> : 19                         load.z32
	<.main+4631 @052276> : 04 16 03 00                jmp <.main+5421 @05258c>
	test/lang/array.ci:119: (9 bytes: <@05227a> - <@052283>): expected: int64 := int32(42 + i)
	<.main+4635 @05227a> : 1c 2a 00 00 00             load.c32 42
	<.main+4640 @05227f> : 10 01                      dup.x1 sp(1)
	<.main+4642 @052281> : 51                         add.i32
	<.main+4643 @052282> : 5c                         i32.2i64
	test/lang/array.ci:120: (61 bytes: <@052283> - <@0522c0>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+4644 @052283> : 11 00                      dup.x2 sp(0)
	<.main+4646 @052285> : 0a 5c 00 00                load.sp(+92)
	<.main+4650 @052289> : 10 05                      dup.x1 sp(5)
	<.main+4652 @05228b> : 0d 08 00 00                mad.u32 8
	<.main+4656 @05228f> : 23                         load.i64
	<.main+4657 @052290> : 67                         ceq.i64
	<.main+4658 @052291> : 06 08 00 00                jz <.main+4666 @052299>
	<.main+4662 @052295> : 04 2b 00 00                jmp <.main+4705 @0522c0>
	<.main+4666 @052299> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4671 @05229e> : 1c 78 00 00 00             load.c32 120
	<.main+4676 @0522a3> : 1c fe ff ff ff             load.c32 -2
	<.main+4681 @0522a8> : 1c 80 00 00 00             load.c32 128
	<.main+4686 @0522ad> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4691 @0522b2> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4696 @0522b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4701 @0522bc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (59 bytes: <@0522c0> - <@0522fb>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+4705 @0522c0> : 11 00                      dup.x2 sp(0)
	<.main+4707 @0522c2> : 10 10                      dup.x1 sp(16)
	<.main+4709 @0522c4> : 10 05                      dup.x1 sp(5)
	<.main+4711 @0522c6> : 0d 08 00 00                mad.u32 8
	<.main+4715 @0522ca> : 23                         load.i64
	<.main+4716 @0522cb> : 67                         ceq.i64
	<.main+4717 @0522cc> : 06 08 00 00                jz <.main+4725 @0522d4>
	<.main+4721 @0522d0> : 04 2b 00 00                jmp <.main+4764 @0522fb>
	<.main+4725 @0522d4> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4730 @0522d9> : 1c 79 00 00 00             load.c32 121
	<.main+4735 @0522de> : 1c fe ff ff ff             load.c32 -2
	<.main+4740 @0522e3> : 1c 80 00 00 00             load.c32 128
	<.main+4745 @0522e8> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4750 @0522ed> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4755 @0522f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4760 @0522f7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (59 bytes: <@0522fb> - <@052336>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+4764 @0522fb> : 11 00                      dup.x2 sp(0)
	<.main+4766 @0522fd> : 10 0e                      dup.x1 sp(14)
	<.main+4768 @0522ff> : 10 05                      dup.x1 sp(5)
	<.main+4770 @052301> : 0d 08 00 00                mad.u32 8
	<.main+4774 @052305> : 23                         load.i64
	<.main+4775 @052306> : 67                         ceq.i64
	<.main+4776 @052307> : 06 08 00 00                jz <.main+4784 @05230f>
	<.main+4780 @05230b> : 04 2b 00 00                jmp <.main+4823 @052336>
	<.main+4784 @05230f> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4789 @052314> : 1c 7a 00 00 00             load.c32 122
	<.main+4794 @052319> : 1c fe ff ff ff             load.c32 -2
	<.main+4799 @05231e> : 1c 80 00 00 00             load.c32 128
	<.main+4804 @052323> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4809 @052328> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4814 @05232d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4819 @052332> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (67 bytes: <@052336> - <@052379>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+4823 @052336> : 11 00                      dup.x2 sp(0)
	<.main+4825 @052338> : 1a                         load.z64
	<.main+4826 @052339> : 10 06                      dup.x1 sp(6)
	<.main+4828 @05233b> : 0a 68 00 00                load.sp(+104)
	<.main+4832 @05233f> : 1f d0 0e 05 00             load.ref <@050ed0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4837 @052344> : 02                         call
	<.main+4838 @052345> : 09 f8 ff ff                inc.sp(-8)
	<.main+4842 @052349> : 67                         ceq.i64
	<.main+4843 @05234a> : 06 08 00 00                jz <.main+4851 @052352>
	<.main+4847 @05234e> : 04 2b 00 00                jmp <.main+4890 @052379>
	<.main+4851 @052352> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4856 @052357> : 1c 7c 00 00 00             load.c32 124
	<.main+4861 @05235c> : 1c fe ff ff ff             load.c32 -2
	<.main+4866 @052361> : 1c 80 00 00 00             load.c32 128
	<.main+4871 @052366> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4876 @05236b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4881 @052370> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4886 @052375> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (65 bytes: <@052379> - <@0523ba>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+4890 @052379> : 11 00                      dup.x2 sp(0)
	<.main+4892 @05237b> : 1a                         load.z64
	<.main+4893 @05237c> : 10 06                      dup.x1 sp(6)
	<.main+4895 @05237e> : 10 13                      dup.x1 sp(19)
	<.main+4897 @052380> : 1f d0 0e 05 00             load.ref <@050ed0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4902 @052385> : 02                         call
	<.main+4903 @052386> : 09 f8 ff ff                inc.sp(-8)
	<.main+4907 @05238a> : 67                         ceq.i64
	<.main+4908 @05238b> : 06 08 00 00                jz <.main+4916 @052393>
	<.main+4912 @05238f> : 04 2b 00 00                jmp <.main+4955 @0523ba>
	<.main+4916 @052393> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4921 @052398> : 1c 7d 00 00 00             load.c32 125
	<.main+4926 @05239d> : 1c fe ff ff ff             load.c32 -2
	<.main+4931 @0523a2> : 1c 80 00 00 00             load.c32 128
	<.main+4936 @0523a7> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+4941 @0523ac> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+4946 @0523b1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4951 @0523b6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (65 bytes: <@0523ba> - <@0523fb>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+4955 @0523ba> : 11 00                      dup.x2 sp(0)
	<.main+4957 @0523bc> : 1a                         load.z64
	<.main+4958 @0523bd> : 10 06                      dup.x1 sp(6)
	<.main+4960 @0523bf> : 10 11                      dup.x1 sp(17)
	<.main+4962 @0523c1> : 1f d0 0e 05 00             load.ref <@050ed0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+4967 @0523c6> : 02                         call
	<.main+4968 @0523c7> : 09 f8 ff ff                inc.sp(-8)
	<.main+4972 @0523cb> : 67                         ceq.i64
	<.main+4973 @0523cc> : 06 08 00 00                jz <.main+4981 @0523d4>
	<.main+4977 @0523d0> : 04 2b 00 00                jmp <.main+5020 @0523fb>
	<.main+4981 @0523d4> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+4986 @0523d9> : 1c 7e 00 00 00             load.c32 126
	<.main+4991 @0523de> : 1c fe ff ff ff             load.c32 -2
	<.main+4996 @0523e3> : 1c 80 00 00 00             load.c32 128
	<.main+5001 @0523e8> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5006 @0523ed> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5011 @0523f2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5016 @0523f7> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (67 bytes: <@0523fb> - <@05243e>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+5020 @0523fb> : 11 00                      dup.x2 sp(0)
	<.main+5022 @0523fd> : 1a                         load.z64
	<.main+5023 @0523fe> : 10 06                      dup.x1 sp(6)
	<.main+5025 @052400> : 0a 68 00 00                load.sp(+104)
	<.main+5029 @052404> : 1f e0 0e 05 00             load.ref <@050ee0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5034 @052409> : 02                         call
	<.main+5035 @05240a> : 09 f8 ff ff                inc.sp(-8)
	<.main+5039 @05240e> : 67                         ceq.i64
	<.main+5040 @05240f> : 06 08 00 00                jz <.main+5048 @052417>
	<.main+5044 @052413> : 04 2b 00 00                jmp <.main+5087 @05243e>
	<.main+5048 @052417> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5053 @05241c> : 1c 80 00 00 00             load.c32 128
	<.main+5058 @052421> : 1c fe ff ff ff             load.c32 -2
	<.main+5063 @052426> : 1c 80 00 00 00             load.c32 128
	<.main+5068 @05242b> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5073 @052430> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5078 @052435> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5083 @05243a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (65 bytes: <@05243e> - <@05247f>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+5087 @05243e> : 11 00                      dup.x2 sp(0)
	<.main+5089 @052440> : 1a                         load.z64
	<.main+5090 @052441> : 10 06                      dup.x1 sp(6)
	<.main+5092 @052443> : 10 13                      dup.x1 sp(19)
	<.main+5094 @052445> : 1f e0 0e 05 00             load.ref <@050ee0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5099 @05244a> : 02                         call
	<.main+5100 @05244b> : 09 f8 ff ff                inc.sp(-8)
	<.main+5104 @05244f> : 67                         ceq.i64
	<.main+5105 @052450> : 06 08 00 00                jz <.main+5113 @052458>
	<.main+5109 @052454> : 04 2b 00 00                jmp <.main+5152 @05247f>
	<.main+5113 @052458> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5118 @05245d> : 1c 81 00 00 00             load.c32 129
	<.main+5123 @052462> : 1c fe ff ff ff             load.c32 -2
	<.main+5128 @052467> : 1c 80 00 00 00             load.c32 128
	<.main+5133 @05246c> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5138 @052471> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5143 @052476> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5148 @05247b> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (65 bytes: <@05247f> - <@0524c0>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+5152 @05247f> : 11 00                      dup.x2 sp(0)
	<.main+5154 @052481> : 1a                         load.z64
	<.main+5155 @052482> : 10 06                      dup.x1 sp(6)
	<.main+5157 @052484> : 10 11                      dup.x1 sp(17)
	<.main+5159 @052486> : 1f e0 0e 05 00             load.ref <@050ee0> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+5164 @05248b> : 02                         call
	<.main+5165 @05248c> : 09 f8 ff ff                inc.sp(-8)
	<.main+5169 @052490> : 67                         ceq.i64
	<.main+5170 @052491> : 06 08 00 00                jz <.main+5178 @052499>
	<.main+5174 @052495> : 04 2b 00 00                jmp <.main+5217 @0524c0>
	<.main+5178 @052499> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5183 @05249e> : 1c 82 00 00 00             load.c32 130
	<.main+5188 @0524a3> : 1c fe ff ff ff             load.c32 -2
	<.main+5193 @0524a8> : 1c 80 00 00 00             load.c32 128
	<.main+5198 @0524ad> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5203 @0524b2> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5208 @0524b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5213 @0524bc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (72 bytes: <@0524c0> - <@052508>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+5217 @0524c0> : 11 00                      dup.x2 sp(0)
	<.main+5219 @0524c2> : 1a                         load.z64
	<.main+5220 @0524c3> : 10 06                      dup.x1 sp(6)
	<.main+5222 @0524c5> : 1c 07 00 00 00             load.c32 7
	<.main+5227 @0524ca> : 0a 6c 00 00                load.sp(+108)
	<.main+5231 @0524ce> : 1f f0 0e 05 00             load.ref <@050ef0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5236 @0524d3> : 02                         call
	<.main+5237 @0524d4> : 09 f4 ff ff                inc.sp(-12)
	<.main+5241 @0524d8> : 67                         ceq.i64
	<.main+5242 @0524d9> : 06 08 00 00                jz <.main+5250 @0524e1>
	<.main+5246 @0524dd> : 04 2b 00 00                jmp <.main+5289 @052508>
	<.main+5250 @0524e1> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5255 @0524e6> : 1c 84 00 00 00             load.c32 132
	<.main+5260 @0524eb> : 1c fe ff ff ff             load.c32 -2
	<.main+5265 @0524f0> : 1c 80 00 00 00             load.c32 128
	<.main+5270 @0524f5> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5275 @0524fa> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5280 @0524ff> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5285 @052504> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (65 bytes: <@052508> - <@052549>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+5289 @052508> : 11 00                      dup.x2 sp(0)
	<.main+5291 @05250a> : 1a                         load.z64
	<.main+5292 @05250b> : 10 06                      dup.x1 sp(6)
	<.main+5294 @05250d> : 11 11                      dup.x2 sp(17)
	<.main+5296 @05250f> : 1f f0 0e 05 00             load.ref <@050ef0> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+5301 @052514> : 02                         call
	<.main+5302 @052515> : 09 f4 ff ff                inc.sp(-12)
	<.main+5306 @052519> : 67                         ceq.i64
	<.main+5307 @05251a> : 06 08 00 00                jz <.main+5315 @052522>
	<.main+5311 @05251e> : 04 2b 00 00                jmp <.main+5354 @052549>
	<.main+5315 @052522> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5320 @052527> : 1c 86 00 00 00             load.c32 134
	<.main+5325 @05252c> : 1c fe ff ff ff             load.c32 -2
	<.main+5330 @052531> : 1c 80 00 00 00             load.c32 128
	<.main+5335 @052536> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5340 @05253b> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5345 @052540> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5350 @052545> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (59 bytes: <@052549> - <@052584>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+5354 @052549> : 11 00                      dup.x2 sp(0)
	<.main+5356 @05254b> : 10 0b                      dup.x1 sp(11)
	<.main+5358 @05254d> : 10 05                      dup.x1 sp(5)
	<.main+5360 @05254f> : 0d 08 00 00                mad.u32 8
	<.main+5364 @052553> : 23                         load.i64
	<.main+5365 @052554> : 67                         ceq.i64
	<.main+5366 @052555> : 06 08 00 00                jz <.main+5374 @05255d>
	<.main+5370 @052559> : 04 2b 00 00                jmp <.main+5413 @052584>
	<.main+5374 @05255d> : 1f 00 c3 03 00             load.ref <@03c300> ;"test/lang/array.ci"
	<.main+5379 @052562> : 1c 88 00 00 00             load.c32 136
	<.main+5384 @052567> : 1c fe ff ff ff             load.c32 -2
	<.main+5389 @05256c> : 1c 80 00 00 00             load.c32 128
	<.main+5394 @052571> : 1f 61 cb 00 00             load.ref <@00cb61> ;"assertion failed!"
	<.main+5399 @052576> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+5404 @05257b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5409 @052580> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+5413 @052584> : 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@052588> - <@05258c>): int32(i := int32(i + 1))
	<.main+5417 @052588> : 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@05258c> - <@052598>): bool(i < arrFixedNoInit.length)
	<.main+5421 @05258c> : 10 00                      dup.x1 sp(0)
	<.main+5423 @05258e> : 1c 07 00 00 00             load.c32 7
	<.main+5428 @052593> : 58                         clt.i32
	<.main+5429 @052594> : 05 e6 fc ff                jnz <.main+4635 @05227a>
	<.main+5433 @052598> : 09 fc ff ff                inc.sp(-4)
	test/lang/member.ci:53: (60 bytes: <@05259c> - <@0525d8>): recordMemberTest: RecordMemberTest := {...}
	<.main+5437 @05259c> : 09 20 00 00                inc.sp(+32)
	test/lang/member.ci:54: (7 bytes: <@0525a0> - <@0525a7>): void(recordMemberTest.member := 10);
	<.main+5441 @0525a0> : 1c 0a 00 00 00             load.c32 10
	<.main+5446 @0525a5> : 13 01                      set.x1 sp(1)
	test/lang/member.ci:55: (7 bytes: <@0525a7> - <@0525ae>): void(recordMemberTest.constant := 11);
	<.main+5448 @0525a7> : 1c 0b 00 00 00             load.c32 11
	<.main+5453 @0525ac> : 13 02                      set.x1 sp(2)
	test/lang/member.ci:56: (7 bytes: <@0525ae> - <@0525b5>): void(recordMemberTest.memberInit := 12);
	<.main+5455 @0525ae> : 1c 0c 00 00 00             load.c32 12
	<.main+5460 @0525b3> : 13 03                      set.x1 sp(3)
	test/lang/member.ci:57: (7 bytes: <@0525b5> - <@0525bc>): void(recordMemberTest.constantInit := 13);
	<.main+5462 @0525b5> : 1c 0d 00 00 00             load.c32 13
	<.main+5467 @0525ba> : 13 04                      set.x1 sp(4)
	test/lang/member.ci:60: (7 bytes: <@0525bc> - <@0525c3>): void(recordMemberTest.memberRec.member := 14);
	<.main+5469 @0525bc> : 1c 0e 00 00 00             load.c32 14
	<.main+5474 @0525c1> : 13 05                      set.x1 sp(5)
	test/lang/member.ci:61: (7 bytes: <@0525c3> - <@0525ca>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5476 @0525c3> : 1c 0f 00 00 00             load.c32 15
	<.main+5481 @0525c8> : 13 06                      set.x1 sp(6)
	test/lang/member.ci:65: (7 bytes: <@0525ca> - <@0525d1>): void(recordMemberTest.constantRec.member := 16);
	<.main+5483 @0525ca> : 1c 10 00 00 00             load.c32 16
	<.main+5488 @0525cf> : 13 07                      set.x1 sp(7)
	test/lang/member.ci:66: (7 bytes: <@0525d1> - <@0525d8>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5490 @0525d1> : 1c 11 00 00 00             load.c32 17
	<.main+5495 @0525d6> : 13 08                      set.x1 sp(8)
	test/lang/method.ci:44: (24 bytes: <@0525d8> - <@0525f0>): recordMethodTest: RecordMethodTest := {...}
	<.main+5497 @0525d8> : 09 10 00 00                inc.sp(+16)
	test/lang/method.ci:46: (7 bytes: <@0525dc> - <@0525e3>): void(recordMethodTest.abstractMethod := globalFunction);
	<.main+5501 @0525dc> : 1f b0 0f 05 00             load.ref <@050fb0> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5506 @0525e1> : 13 01                      set.x1 sp(1)
	:: (6 bytes: <@0525e3> - <@0525e9>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5508 @0525e3> : 2a 58 0f 05                load.m32 <@050f58> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5512 @0525e7> : 13 02                      set.x1 sp(2)
	:: (7 bytes: <@0525e9> - <@0525f0>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5514 @0525e9> : 1f 60 0f 05 00             load.ref <@050f60> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5519 @0525ee> : 13 03                      set.x1 sp(3)
	test/lang/method.ci:58: (19 bytes: <@0525f0> - <@052603>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+5521 @0525f0> : 12 00                      dup.x4 sp(0)
	<.main+5523 @0525f2> : 1c 01 00 00 00             load.c32 1
	<.main+5528 @0525f7> : 13 04                      set.x1 sp(4)
	<.main+5530 @0525f9> : 1f 30 0f 05 00             load.ref <@050f30> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5535 @0525fe> : 02                         call
	<.main+5536 @0525ff> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:59: (16 bytes: <@052603> - <@052613>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+5540 @052603> : 12 00                      dup.x4 sp(0)
	<.main+5542 @052605> : 1c 01 00 00 00             load.c32 1
	<.main+5547 @05260a> : 13 04                      set.x1 sp(4)
	<.main+5549 @05260c> : 10 06                      dup.x1 sp(6)
	<.main+5551 @05260e> : 02                         call
	<.main+5552 @05260f> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:75: (17 bytes: <@052613> - <@052624>): staticMethod(void(recordMethodTest, 2));
	<.main+5556 @052613> : 12 00                      dup.x4 sp(0)
	<.main+5558 @052615> : 1c 02 00 00 00             load.c32 2
	<.main+5563 @05261a> : 1f d8 0f 05 00             load.ref <@050fd8> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5568 @05261f> : 02                         call
	<.main+5569 @052620> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:76: (17 bytes: <@052624> - <@052635>): virtualMethod(void(recordMethodTest, 2));
	<.main+5573 @052624> : 12 00                      dup.x4 sp(0)
	<.main+5575 @052626> : 1c 02 00 00 00             load.c32 2
	<.main+5580 @05262b> : 1f 20 10 05 00             load.ref <@051020> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5585 @052630> : 02                         call
	<.main+5586 @052631> : 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:79: (19 bytes: <@052635> - <@052648>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+5590 @052635> : 12 00                      dup.x4 sp(0)
	<.main+5592 @052637> : 1c 03 00 00 00             load.c32 3
	<.main+5597 @05263c> : 13 04                      set.x1 sp(4)
	<.main+5599 @05263e> : 1f 30 0f 05 00             load.ref <@050f30> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+5604 @052643> : 02                         call
	<.main+5605 @052644> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:80: (19 bytes: <@052648> - <@05265b>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5609 @052648> : 12 00                      dup.x4 sp(0)
	<.main+5611 @05264a> : 1c 03 00 00 00             load.c32 3
	<.main+5616 @05264f> : 13 04                      set.x1 sp(4)
	<.main+5618 @052651> : 1f 60 0f 05 00             load.ref <@050f60> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5623 @052656> : 02                         call
	<.main+5624 @052657> : 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:81: (16 bytes: <@05265b> - <@05266b>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+5628 @05265b> : 12 00                      dup.x4 sp(0)
	<.main+5630 @05265d> : 1c 03 00 00 00             load.c32 3
	<.main+5635 @052662> : 13 04                      set.x1 sp(4)
	<.main+5637 @052664> : 10 06                      dup.x1 sp(6)
	<.main+5639 @052666> : 02                         call
	<.main+5640 @052667> : 09 f0 ff ff                inc.sp(-16)
	test/lang/recUnion.ci:26: (22 bytes: <@05266b> - <@052681>): black: rgbU8 := {...}
	<.main+5644 @05266b> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:26: (6 bytes: <@05266f> - <@052675>): void(black.r := (0));
	<.main+5648 @05266f> : 19                         load.z32
	<.main+5649 @052670> : 0a 06 00 00                load.sp(+6)
	<.main+5653 @052674> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@052675> - <@05267b>): void(black.g := (0));
	<.main+5654 @052675> : 19                         load.z32
	<.main+5655 @052676> : 0a 05 00 00                load.sp(+5)
	<.main+5659 @05267a> : 25                         store.i8
	test/lang/recUnion.ci:26: (6 bytes: <@05267b> - <@052681>): void(black.b := (0));
	<.main+5660 @05267b> : 19                         load.z32
	<.main+5661 @05267c> : 0a 04 00 00                load.sp(+4)
	<.main+5665 @052680> : 25                         store.i8
	test/lang/recUnion.ci:27: (26 bytes: <@052681> - <@05269b>): green: rgbU8 := {...}
	<.main+5666 @052681> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:27: (6 bytes: <@052685> - <@05268b>): void(green.r := (0));
	<.main+5670 @052685> : 19                         load.z32
	<.main+5671 @052686> : 0a 06 00 00                load.sp(+6)
	<.main+5675 @05268a> : 25                         store.i8
	test/lang/recUnion.ci:27: (10 bytes: <@05268b> - <@052695>): void(green.g := (255));
	<.main+5676 @05268b> : 1c ff 00 00 00             load.c32 255
	<.main+5681 @052690> : 0a 05 00 00                load.sp(+5)
	<.main+5685 @052694> : 25                         store.i8
	test/lang/recUnion.ci:27: (6 bytes: <@052695> - <@05269b>): void(green.b := (0));
	<.main+5686 @052695> : 19                         load.z32
	<.main+5687 @052696> : 0a 04 00 00                load.sp(+4)
	<.main+5691 @05269a> : 25                         store.i8
	test/lang/recUnion.ci:28: (34 bytes: <@05269b> - <@0526bd>): white: rgbU8 := {...}
	<.main+5692 @05269b> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:28: (10 bytes: <@05269f> - <@0526a9>): void(white.r := (255));
	<.main+5696 @05269f> : 1c ff 00 00 00             load.c32 255
	<.main+5701 @0526a4> : 0a 06 00 00                load.sp(+6)
	<.main+5705 @0526a8> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@0526a9> - <@0526b3>): void(white.g := (255));
	<.main+5706 @0526a9> : 1c ff 00 00 00             load.c32 255
	<.main+5711 @0526ae> : 0a 05 00 00                load.sp(+5)
	<.main+5715 @0526b2> : 25                         store.i8
	test/lang/recUnion.ci:28: (10 bytes: <@0526b3> - <@0526bd>): void(white.b := (255));
	<.main+5716 @0526b3> : 1c ff 00 00 00             load.c32 255
	<.main+5721 @0526b8> : 0a 04 00 00                load.sp(+4)
	<.main+5725 @0526bc> : 25                         store.i8
	test/lang/recUnion.ci:30: (11 bytes: <@0526bd> - <@0526c8>): cyan: color := {...}
	<.main+5726 @0526bd> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:30: (7 bytes: <@0526c1> - <@0526c8>): void(cyan.col := (65535));
	<.main+5730 @0526c1> : 1c ff ff 00 00             load.c32 65535
	<.main+5735 @0526c6> : 13 01                      set.x1 sp(1)
	test/lang/recUnion.ci:31: (26 bytes: <@0526c8> - <@0526e2>): blue: color := {...}
	<.main+5737 @0526c8> : 09 04 00 00                inc.sp(+4)
	test/lang/recUnion.ci:31: (6 bytes: <@0526cc> - <@0526d2>): void(blue.rgb.r := (0));
	<.main+5741 @0526cc> : 19                         load.z32
	<.main+5742 @0526cd> : 0a 06 00 00                load.sp(+6)
	<.main+5746 @0526d1> : 25                         store.i8
	test/lang/recUnion.ci:31: (6 bytes: <@0526d2> - <@0526d8>): void(blue.rgb.g := (0));
	<.main+5747 @0526d2> : 19                         load.z32
	<.main+5748 @0526d3> : 0a 05 00 00                load.sp(+5)
	<.main+5752 @0526d7> : 25                         store.i8
	test/lang/recUnion.ci:31: (10 bytes: <@0526d8> - <@0526e2>): void(blue.rgb.b := (255));
	<.main+5753 @0526d8> : 1c ff 00 00 00             load.c32 255
	<.main+5758 @0526dd> : 0a 04 00 00                load.sp(+4)
	<.main+5762 @0526e1> : 25                         store.i8
	test/lang/useOperator.ci:5: (5 bytes: <@0526e2> - <@0526e7>): shift: int32 := 2
	<.main+5763 @0526e2> : 1c 02 00 00 00             load.c32 2
	test/lang/useOperator.ci:7: (5 bytes: <@0526e7> - <@0526ec>): boolA: bool := true
	<.main+5768 @0526e7> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:8: (5 bytes: <@0526ec> - <@0526f1>): boolB: bool := bool(!false)
	<.main+5773 @0526ec> : 1c 01 00 00 00             load.c32 1
	test/lang/useOperator.ci:17: (11 bytes: <@0526f1> - <@0526fc>): boolAnd: bool := bool(boolA & boolB)
	<.main+5778 @0526f1> : 0a 04 00 00                load.sp(+4)
	<.main+5782 @0526f5> : 20                         load.i8
	<.main+5783 @0526f6> : 0a 04 00 00                load.sp(+4)
	<.main+5787 @0526fa> : 20                         load.i8
	<.main+5788 @0526fb> : 31                         and.b32
	test/lang/useOperator.ci:18: (11 bytes: <@0526fc> - <@052707>): boolIor: bool := bool(boolA | boolB)
	<.main+5789 @0526fc> : 0a 08 00 00                load.sp(+8)
	<.main+5793 @052700> : 20                         load.i8
	<.main+5794 @052701> : 0a 08 00 00                load.sp(+8)
	<.main+5798 @052705> : 20                         load.i8
	<.main+5799 @052706> : 32                         or.b32
	test/lang/useOperator.ci:19: (11 bytes: <@052707> - <@052712>): boolXor: bool := bool(boolA ^ boolB)
	<.main+5800 @052707> : 0a 0c 00 00                load.sp(+12)
	<.main+5804 @05270b> : 20                         load.i8
	<.main+5805 @05270c> : 0a 0c 00 00                load.sp(+12)
	<.main+5809 @052710> : 20                         load.i8
	<.main+5810 @052711> : 36                         xor.b32
	test/lang/useOperator.ci:22: (6 bytes: <@052712> - <@052718>): boolNot: bool := bool(!boolB)
	<.main+5811 @052712> : 0a 0c 00 00                load.sp(+12)
	<.main+5815 @052716> : 20                         load.i8
	<.main+5816 @052717> : 0b                         not.b32
	test/lang/useOperator.ci:23: (11 bytes: <@052718> - <@052723>): boolCeq: bool := bool(boolA == boolB)
	<.main+5817 @052718> : 0a 14 00 00                load.sp(+20)
	<.main+5821 @05271c> : 20                         load.i8
	<.main+5822 @05271d> : 0a 14 00 00                load.sp(+20)
	<.main+5826 @052721> : 20                         load.i8
	<.main+5827 @052722> : 57                         ceq.i32
	test/lang/useOperator.ci:24: (12 bytes: <@052723> - <@05272f>): boolCne: bool := bool(boolA != boolB)
	<.main+5828 @052723> : 0a 18 00 00                load.sp(+24)
	<.main+5832 @052727> : 20                         load.i8
	<.main+5833 @052728> : 0a 18 00 00                load.sp(+24)
	<.main+5837 @05272c> : 20                         load.i8
	<.main+5838 @05272d> : 57                         ceq.i32
	<.main+5839 @05272e> : 0b                         not.b32
	test/lang/useOperator.ci:25: (11 bytes: <@05272f> - <@05273a>): boolClt: bool := bool(boolA < boolB)
	<.main+5840 @05272f> : 0a 1c 00 00                load.sp(+28)
	<.main+5844 @052733> : 20                         load.i8
	<.main+5845 @052734> : 0a 1c 00 00                load.sp(+28)
	<.main+5849 @052738> : 20                         load.i8
	<.main+5850 @052739> : 58                         clt.i32
	test/lang/useOperator.ci:26: (12 bytes: <@05273a> - <@052746>): boolCle: bool := bool(boolA <= boolB)
	<.main+5851 @05273a> : 0a 20 00 00                load.sp(+32)
	<.main+5855 @05273e> : 20                         load.i8
	<.main+5856 @05273f> : 0a 20 00 00                load.sp(+32)
	<.main+5860 @052743> : 20                         load.i8
	<.main+5861 @052744> : 59                         cgt.i32
	<.main+5862 @052745> : 0b                         not.b32
	test/lang/useOperator.ci:27: (11 bytes: <@052746> - <@052751>): boolCgt: bool := bool(boolA > boolB)
	<.main+5863 @052746> : 0a 24 00 00                load.sp(+36)
	<.main+5867 @05274a> : 20                         load.i8
	<.main+5868 @05274b> : 0a 24 00 00                load.sp(+36)
	<.main+5872 @05274f> : 20                         load.i8
	<.main+5873 @052750> : 59                         cgt.i32
	test/lang/useOperator.ci:28: (12 bytes: <@052751> - <@05275d>): boolCge: bool := bool(boolA >= boolB)
	<.main+5874 @052751> : 0a 28 00 00                load.sp(+40)
	<.main+5878 @052755> : 20                         load.i8
	<.main+5879 @052756> : 0a 28 00 00                load.sp(+40)
	<.main+5883 @05275a> : 20                         load.i8
	<.main+5884 @05275b> : 58                         clt.i32
	<.main+5885 @05275c> : 0b                         not.b32
	test/lang/useOperator.ci:30: (5 bytes: <@05275d> - <@052762>): chrA: char := 'a'
	<.main+5886 @05275d> : 1c 61 00 00 00             load.c32 97
	test/lang/useOperator.ci:31: (5 bytes: <@052762> - <@052767>): chrB: char := 'b'
	<.main+5891 @052762> : 1c 62 00 00 00             load.c32 98
	test/lang/useOperator.ci:32: (5 bytes: <@052767> - <@05276c>): chrPls: char := char(+chrB)
	<.main+5896 @052767> : 0a 00 00 00                load.sp(+0)
	<.main+5900 @05276b> : 20                         load.i8
	test/lang/useOperator.ci:33: (6 bytes: <@05276c> - <@052772>): chrNeg: char := char(-chrB)
	<.main+5901 @05276c> : 0a 04 00 00                load.sp(+4)
	<.main+5905 @052770> : 20                         load.i8
	<.main+5906 @052771> : 50                         neg.i32
	test/lang/useOperator.ci:34: (6 bytes: <@052772> - <@052778>): chrCmt: char := char(~chrB)
	<.main+5907 @052772> : 0a 08 00 00                load.sp(+8)
	<.main+5911 @052776> : 20                         load.i8
	<.main+5912 @052777> : 30                         cmt.b32
	test/lang/useOperator.ci:35: (11 bytes: <@052778> - <@052783>): chrAdd: char := char(chrA + chrB)
	<.main+5913 @052778> : 0a 10 00 00                load.sp(+16)
	<.main+5917 @05277c> : 20                         load.i8
	<.main+5918 @05277d> : 0a 10 00 00                load.sp(+16)
	<.main+5922 @052781> : 20                         load.i8
	<.main+5923 @052782> : 51                         add.i32
	test/lang/useOperator.ci:36: (11 bytes: <@052783> - <@05278e>): chrSub: char := char(chrA - chrB)
	<.main+5924 @052783> : 0a 14 00 00                load.sp(+20)
	<.main+5928 @052787> : 20                         load.i8
	<.main+5929 @052788> : 0a 14 00 00                load.sp(+20)
	<.main+5933 @05278c> : 20                         load.i8
	<.main+5934 @05278d> : 52                         sub.i32
	test/lang/useOperator.ci:37: (11 bytes: <@05278e> - <@052799>): chrMul: char := char(chrA * chrB)
	<.main+5935 @05278e> : 0a 18 00 00                load.sp(+24)
	<.main+5939 @052792> : 20                         load.i8
	<.main+5940 @052793> : 0a 18 00 00                load.sp(+24)
	<.main+5944 @052797> : 20                         load.i8
	<.main+5945 @052798> : 53                         mul.i32
	test/lang/useOperator.ci:38: (11 bytes: <@052799> - <@0527a4>): chrDiv: char := char(chrA / chrB)
	<.main+5946 @052799> : 0a 1c 00 00                load.sp(+28)
	<.main+5950 @05279d> : 20                         load.i8
	<.main+5951 @05279e> : 0a 1c 00 00                load.sp(+28)
	<.main+5955 @0527a2> : 20                         load.i8
	<.main+5956 @0527a3> : 54                         div.i32
	test/lang/useOperator.ci:39: (11 bytes: <@0527a4> - <@0527af>): chrMod: char := char(chrA % chrB)
	<.main+5957 @0527a4> : 0a 20 00 00                load.sp(+32)
	<.main+5961 @0527a8> : 20                         load.i8
	<.main+5962 @0527a9> : 0a 20 00 00                load.sp(+32)
	<.main+5966 @0527ad> : 20                         load.i8
	<.main+5967 @0527ae> : 55                         mod.i32
	test/lang/useOperator.ci:40: (11 bytes: <@0527af> - <@0527ba>): chrAnd: char := char(chrA & chrB)
	<.main+5968 @0527af> : 0a 24 00 00                load.sp(+36)
	<.main+5972 @0527b3> : 20                         load.i8
	<.main+5973 @0527b4> : 0a 24 00 00                load.sp(+36)
	<.main+5977 @0527b8> : 20                         load.i8
	<.main+5978 @0527b9> : 31                         and.b32
	test/lang/useOperator.ci:41: (11 bytes: <@0527ba> - <@0527c5>): chrIor: char := char(chrA | chrB)
	<.main+5979 @0527ba> : 0a 28 00 00                load.sp(+40)
	<.main+5983 @0527be> : 20                         load.i8
	<.main+5984 @0527bf> : 0a 28 00 00                load.sp(+40)
	<.main+5988 @0527c3> : 20                         load.i8
	<.main+5989 @0527c4> : 32                         or.b32
	test/lang/useOperator.ci:42: (11 bytes: <@0527c5> - <@0527d0>): chrXor: char := char(chrA ^ chrB)
	<.main+5990 @0527c5> : 0a 2c 00 00                load.sp(+44)
	<.main+5994 @0527c9> : 20                         load.i8
	<.main+5995 @0527ca> : 0a 2c 00 00                load.sp(+44)
	<.main+5999 @0527ce> : 20                         load.i8
	<.main+6000 @0527cf> : 36                         xor.b32
	test/lang/useOperator.ci:43: (8 bytes: <@0527d0> - <@0527d8>): chrShl: char := int32((chrA) << shift)
	<.main+6001 @0527d0> : 0a 30 00 00                load.sp(+48)
	<.main+6005 @0527d4> : 20                         load.i8
	<.main+6006 @0527d5> : 10 1a                      dup.x1 sp(26)
	<.main+6008 @0527d7> : 3a                         shl.b32
	test/lang/useOperator.ci:44: (8 bytes: <@0527d8> - <@0527e0>): chrShr: char := int32((chrA) >> shift)
	<.main+6009 @0527d8> : 0a 34 00 00                load.sp(+52)
	<.main+6013 @0527dc> : 20                         load.i8
	<.main+6014 @0527dd> : 10 1b                      dup.x1 sp(27)
	<.main+6016 @0527df> : 3c                         sar.b32
	test/lang/useOperator.ci:45: (7 bytes: <@0527e0> - <@0527e7>): chrNot: bool := bool(!(chrB))
	<.main+6017 @0527e0> : 0a 34 00 00                load.sp(+52)
	<.main+6021 @0527e4> : 20                         load.i8
	<.main+6022 @0527e5> : 5a                         i32.2bool
	<.main+6023 @0527e6> : 0b                         not.b32
	test/lang/useOperator.ci:46: (11 bytes: <@0527e7> - <@0527f2>): chrCeq: bool := bool(chrA == chrB)
	<.main+6024 @0527e7> : 0a 3c 00 00                load.sp(+60)
	<.main+6028 @0527eb> : 20                         load.i8
	<.main+6029 @0527ec> : 0a 3c 00 00                load.sp(+60)
	<.main+6033 @0527f0> : 20                         load.i8
	<.main+6034 @0527f1> : 57                         ceq.i32
	test/lang/useOperator.ci:47: (12 bytes: <@0527f2> - <@0527fe>): chrCne: bool := bool(chrA != chrB)
	<.main+6035 @0527f2> : 0a 40 00 00                load.sp(+64)
	<.main+6039 @0527f6> : 20                         load.i8
	<.main+6040 @0527f7> : 0a 40 00 00                load.sp(+64)
	<.main+6044 @0527fb> : 20                         load.i8
	<.main+6045 @0527fc> : 57                         ceq.i32
	<.main+6046 @0527fd> : 0b                         not.b32
	test/lang/useOperator.ci:48: (11 bytes: <@0527fe> - <@052809>): chrClt: bool := bool(chrA < chrB)
	<.main+6047 @0527fe> : 0a 44 00 00                load.sp(+68)
	<.main+6051 @052802> : 20                         load.i8
	<.main+6052 @052803> : 0a 44 00 00                load.sp(+68)
	<.main+6056 @052807> : 20                         load.i8
	<.main+6057 @052808> : 58                         clt.i32
	test/lang/useOperator.ci:49: (12 bytes: <@052809> - <@052815>): chrCle: bool := bool(chrA <= chrB)
	<.main+6058 @052809> : 0a 48 00 00                load.sp(+72)
	<.main+6062 @05280d> : 20                         load.i8
	<.main+6063 @05280e> : 0a 48 00 00                load.sp(+72)
	<.main+6067 @052812> : 20                         load.i8
	<.main+6068 @052813> : 59                         cgt.i32
	<.main+6069 @052814> : 0b                         not.b32
	test/lang/useOperator.ci:50: (11 bytes: <@052815> - <@052820>): chrCgt: bool := bool(chrA > chrB)
	<.main+6070 @052815> : 0a 4c 00 00                load.sp(+76)
	<.main+6074 @052819> : 20                         load.i8
	<.main+6075 @05281a> : 0a 4c 00 00                load.sp(+76)
	<.main+6079 @05281e> : 20                         load.i8
	<.main+6080 @05281f> : 59                         cgt.i32
	test/lang/useOperator.ci:51: (12 bytes: <@052820> - <@05282c>): chrCge: bool := bool(chrA >= chrB)
	<.main+6081 @052820> : 0a 50 00 00                load.sp(+80)
	<.main+6085 @052824> : 20                         load.i8
	<.main+6086 @052825> : 0a 50 00 00                load.sp(+80)
	<.main+6090 @052829> : 20                         load.i8
	<.main+6091 @05282a> : 58                         clt.i32
	<.main+6092 @05282b> : 0b                         not.b32
	test/lang/useOperator.ci:53: (5 bytes: <@05282c> - <@052831>): i8A: int8 := a
	<.main+6093 @05282c> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:54: (5 bytes: <@052831> - <@052836>): i8B: int8 := b
	<.main+6098 @052831> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:55: (5 bytes: <@052836> - <@05283b>): i8Pls: int8 := int8(+i8B)
	<.main+6103 @052836> : 0a 00 00 00                load.sp(+0)
	<.main+6107 @05283a> : 20                         load.i8
	test/lang/useOperator.ci:56: (6 bytes: <@05283b> - <@052841>): i8Neg: int8 := int8(-i8B)
	<.main+6108 @05283b> : 0a 04 00 00                load.sp(+4)
	<.main+6112 @05283f> : 20                         load.i8
	<.main+6113 @052840> : 50                         neg.i32
	test/lang/useOperator.ci:57: (6 bytes: <@052841> - <@052847>): i8Cmt: int8 := int8(~i8B)
	<.main+6114 @052841> : 0a 08 00 00                load.sp(+8)
	<.main+6118 @052845> : 20                         load.i8
	<.main+6119 @052846> : 30                         cmt.b32
	test/lang/useOperator.ci:58: (11 bytes: <@052847> - <@052852>): i8Add: int8 := int8(i8A + i8B)
	<.main+6120 @052847> : 0a 10 00 00                load.sp(+16)
	<.main+6124 @05284b> : 20                         load.i8
	<.main+6125 @05284c> : 0a 10 00 00                load.sp(+16)
	<.main+6129 @052850> : 20                         load.i8
	<.main+6130 @052851> : 51                         add.i32
	test/lang/useOperator.ci:59: (11 bytes: <@052852> - <@05285d>): i8Sub: int8 := int8(i8A - i8B)
	<.main+6131 @052852> : 0a 14 00 00                load.sp(+20)
	<.main+6135 @052856> : 20                         load.i8
	<.main+6136 @052857> : 0a 14 00 00                load.sp(+20)
	<.main+6140 @05285b> : 20                         load.i8
	<.main+6141 @05285c> : 52                         sub.i32
	test/lang/useOperator.ci:60: (11 bytes: <@05285d> - <@052868>): i8Mul: int8 := int8(i8A * i8B)
	<.main+6142 @05285d> : 0a 18 00 00                load.sp(+24)
	<.main+6146 @052861> : 20                         load.i8
	<.main+6147 @052862> : 0a 18 00 00                load.sp(+24)
	<.main+6151 @052866> : 20                         load.i8
	<.main+6152 @052867> : 53                         mul.i32
	test/lang/useOperator.ci:61: (11 bytes: <@052868> - <@052873>): i8Div: int8 := int8(i8A / i8B)
	<.main+6153 @052868> : 0a 1c 00 00                load.sp(+28)
	<.main+6157 @05286c> : 20                         load.i8
	<.main+6158 @05286d> : 0a 1c 00 00                load.sp(+28)
	<.main+6162 @052871> : 20                         load.i8
	<.main+6163 @052872> : 54                         div.i32
	test/lang/useOperator.ci:62: (11 bytes: <@052873> - <@05287e>): i8Mod: int8 := int8(i8A % i8B)
	<.main+6164 @052873> : 0a 20 00 00                load.sp(+32)
	<.main+6168 @052877> : 20                         load.i8
	<.main+6169 @052878> : 0a 20 00 00                load.sp(+32)
	<.main+6173 @05287c> : 20                         load.i8
	<.main+6174 @05287d> : 55                         mod.i32
	test/lang/useOperator.ci:63: (11 bytes: <@05287e> - <@052889>): i8And: int8 := int8(i8A & i8B)
	<.main+6175 @05287e> : 0a 24 00 00                load.sp(+36)
	<.main+6179 @052882> : 20                         load.i8
	<.main+6180 @052883> : 0a 24 00 00                load.sp(+36)
	<.main+6184 @052887> : 20                         load.i8
	<.main+6185 @052888> : 31                         and.b32
	test/lang/useOperator.ci:64: (11 bytes: <@052889> - <@052894>): i8Ior: int8 := int8(i8A | i8B)
	<.main+6186 @052889> : 0a 28 00 00                load.sp(+40)
	<.main+6190 @05288d> : 20                         load.i8
	<.main+6191 @05288e> : 0a 28 00 00                load.sp(+40)
	<.main+6195 @052892> : 20                         load.i8
	<.main+6196 @052893> : 32                         or.b32
	test/lang/useOperator.ci:65: (11 bytes: <@052894> - <@05289f>): i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6197 @052894> : 0a 2c 00 00                load.sp(+44)
	<.main+6201 @052898> : 20                         load.i8
	<.main+6202 @052899> : 0a 2c 00 00                load.sp(+44)
	<.main+6206 @05289d> : 20                         load.i8
	<.main+6207 @05289e> : 36                         xor.b32
	test/lang/useOperator.ci:66: (8 bytes: <@05289f> - <@0528a7>): i8Shl: int8 := int32((i8A) << shift)
	<.main+6208 @05289f> : 0a 30 00 00                load.sp(+48)
	<.main+6212 @0528a3> : 20                         load.i8
	<.main+6213 @0528a4> : 10 30                      dup.x1 sp(48)
	<.main+6215 @0528a6> : 3a                         shl.b32
	test/lang/useOperator.ci:67: (8 bytes: <@0528a7> - <@0528af>): i8Shr: int8 := int32((i8A) >> shift)
	<.main+6216 @0528a7> : 0a 34 00 00                load.sp(+52)
	<.main+6220 @0528ab> : 20                         load.i8
	<.main+6221 @0528ac> : 10 31                      dup.x1 sp(49)
	<.main+6223 @0528ae> : 3c                         sar.b32
	test/lang/useOperator.ci:68: (7 bytes: <@0528af> - <@0528b6>): i8Not: bool := bool(!(i8B))
	<.main+6224 @0528af> : 0a 34 00 00                load.sp(+52)
	<.main+6228 @0528b3> : 20                         load.i8
	<.main+6229 @0528b4> : 5a                         i32.2bool
	<.main+6230 @0528b5> : 0b                         not.b32
	test/lang/useOperator.ci:69: (11 bytes: <@0528b6> - <@0528c1>): i8Ceq: bool := bool(i8A == i8B)
	<.main+6231 @0528b6> : 0a 3c 00 00                load.sp(+60)
	<.main+6235 @0528ba> : 20                         load.i8
	<.main+6236 @0528bb> : 0a 3c 00 00                load.sp(+60)
	<.main+6240 @0528bf> : 20                         load.i8
	<.main+6241 @0528c0> : 57                         ceq.i32
	test/lang/useOperator.ci:70: (12 bytes: <@0528c1> - <@0528cd>): i8Cne: bool := bool(i8A != i8B)
	<.main+6242 @0528c1> : 0a 40 00 00                load.sp(+64)
	<.main+6246 @0528c5> : 20                         load.i8
	<.main+6247 @0528c6> : 0a 40 00 00                load.sp(+64)
	<.main+6251 @0528ca> : 20                         load.i8
	<.main+6252 @0528cb> : 57                         ceq.i32
	<.main+6253 @0528cc> : 0b                         not.b32
	test/lang/useOperator.ci:71: (11 bytes: <@0528cd> - <@0528d8>): i8Clt: bool := bool(i8A < i8B)
	<.main+6254 @0528cd> : 0a 44 00 00                load.sp(+68)
	<.main+6258 @0528d1> : 20                         load.i8
	<.main+6259 @0528d2> : 0a 44 00 00                load.sp(+68)
	<.main+6263 @0528d6> : 20                         load.i8
	<.main+6264 @0528d7> : 58                         clt.i32
	test/lang/useOperator.ci:72: (12 bytes: <@0528d8> - <@0528e4>): i8Cle: bool := bool(i8A <= i8B)
	<.main+6265 @0528d8> : 0a 48 00 00                load.sp(+72)
	<.main+6269 @0528dc> : 20                         load.i8
	<.main+6270 @0528dd> : 0a 48 00 00                load.sp(+72)
	<.main+6274 @0528e1> : 20                         load.i8
	<.main+6275 @0528e2> : 59                         cgt.i32
	<.main+6276 @0528e3> : 0b                         not.b32
	test/lang/useOperator.ci:73: (11 bytes: <@0528e4> - <@0528ef>): i8Cgt: bool := bool(i8A > i8B)
	<.main+6277 @0528e4> : 0a 4c 00 00                load.sp(+76)
	<.main+6281 @0528e8> : 20                         load.i8
	<.main+6282 @0528e9> : 0a 4c 00 00                load.sp(+76)
	<.main+6286 @0528ed> : 20                         load.i8
	<.main+6287 @0528ee> : 59                         cgt.i32
	test/lang/useOperator.ci:74: (12 bytes: <@0528ef> - <@0528fb>): i8Cge: bool := bool(i8A >= i8B)
	<.main+6288 @0528ef> : 0a 50 00 00                load.sp(+80)
	<.main+6292 @0528f3> : 20                         load.i8
	<.main+6293 @0528f4> : 0a 50 00 00                load.sp(+80)
	<.main+6297 @0528f8> : 20                         load.i8
	<.main+6298 @0528f9> : 58                         clt.i32
	<.main+6299 @0528fa> : 0b                         not.b32
	test/lang/useOperator.ci:76: (5 bytes: <@0528fb> - <@052900>): u8A: uint8 := a
	<.main+6300 @0528fb> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:77: (5 bytes: <@052900> - <@052905>): u8B: uint8 := b
	<.main+6305 @052900> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:78: (5 bytes: <@052905> - <@05290a>): u8Pls: uint8 := uint8(+u8B)
	<.main+6310 @052905> : 0a 00 00 00                load.sp(+0)
	<.main+6314 @052909> : 20                         load.i8
	test/lang/useOperator.ci:79: (6 bytes: <@05290a> - <@052910>): u8Neg: uint8 := uint8(-u8B)
	<.main+6315 @05290a> : 0a 04 00 00                load.sp(+4)
	<.main+6319 @05290e> : 20                         load.i8
	<.main+6320 @05290f> : 50                         neg.i32
	test/lang/useOperator.ci:80: (6 bytes: <@052910> - <@052916>): u8Cmt: uint8 := uint8(~u8B)
	<.main+6321 @052910> : 0a 08 00 00                load.sp(+8)
	<.main+6325 @052914> : 20                         load.i8
	<.main+6326 @052915> : 30                         cmt.b32
	test/lang/useOperator.ci:81: (11 bytes: <@052916> - <@052921>): u8Add: uint8 := uint8(u8A + u8B)
	<.main+6327 @052916> : 0a 10 00 00                load.sp(+16)
	<.main+6331 @05291a> : 20                         load.i8
	<.main+6332 @05291b> : 0a 10 00 00                load.sp(+16)
	<.main+6336 @05291f> : 20                         load.i8
	<.main+6337 @052920> : 51                         add.i32
	test/lang/useOperator.ci:82: (11 bytes: <@052921> - <@05292c>): u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6338 @052921> : 0a 14 00 00                load.sp(+20)
	<.main+6342 @052925> : 20                         load.i8
	<.main+6343 @052926> : 0a 14 00 00                load.sp(+20)
	<.main+6347 @05292a> : 20                         load.i8
	<.main+6348 @05292b> : 52                         sub.i32
	test/lang/useOperator.ci:83: (11 bytes: <@05292c> - <@052937>): u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6349 @05292c> : 0a 18 00 00                load.sp(+24)
	<.main+6353 @052930> : 20                         load.i8
	<.main+6354 @052931> : 0a 18 00 00                load.sp(+24)
	<.main+6358 @052935> : 20                         load.i8
	<.main+6359 @052936> : 33                         mul.u32
	test/lang/useOperator.ci:84: (11 bytes: <@052937> - <@052942>): u8Div: uint8 := uint8(u8A / u8B)
	<.main+6360 @052937> : 0a 1c 00 00                load.sp(+28)
	<.main+6364 @05293b> : 20                         load.i8
	<.main+6365 @05293c> : 0a 1c 00 00                load.sp(+28)
	<.main+6369 @052940> : 20                         load.i8
	<.main+6370 @052941> : 34                         div.u32
	test/lang/useOperator.ci:85: (11 bytes: <@052942> - <@05294d>): u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6371 @052942> : 0a 20 00 00                load.sp(+32)
	<.main+6375 @052946> : 20                         load.i8
	<.main+6376 @052947> : 0a 20 00 00                load.sp(+32)
	<.main+6380 @05294b> : 20                         load.i8
	<.main+6381 @05294c> : 35                         mod.u32
	test/lang/useOperator.ci:86: (11 bytes: <@05294d> - <@052958>): u8And: uint8 := uint8(u8A & u8B)
	<.main+6382 @05294d> : 0a 24 00 00                load.sp(+36)
	<.main+6386 @052951> : 20                         load.i8
	<.main+6387 @052952> : 0a 24 00 00                load.sp(+36)
	<.main+6391 @052956> : 20                         load.i8
	<.main+6392 @052957> : 31                         and.b32
	test/lang/useOperator.ci:87: (11 bytes: <@052958> - <@052963>): u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6393 @052958> : 0a 28 00 00                load.sp(+40)
	<.main+6397 @05295c> : 20                         load.i8
	<.main+6398 @05295d> : 0a 28 00 00                load.sp(+40)
	<.main+6402 @052961> : 20                         load.i8
	<.main+6403 @052962> : 32                         or.b32
	test/lang/useOperator.ci:88: (11 bytes: <@052963> - <@05296e>): u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6404 @052963> : 0a 2c 00 00                load.sp(+44)
	<.main+6408 @052967> : 20                         load.i8
	<.main+6409 @052968> : 0a 2c 00 00                load.sp(+44)
	<.main+6413 @05296c> : 20                         load.i8
	<.main+6414 @05296d> : 36                         xor.b32
	test/lang/useOperator.ci:89: (8 bytes: <@05296e> - <@052976>): u8Shl: uint8 := int32((u8A) << shift)
	<.main+6415 @05296e> : 0a 30 00 00                load.sp(+48)
	<.main+6419 @052972> : 20                         load.i8
	<.main+6420 @052973> : 10 46                      dup.x1 sp(70)
	<.main+6422 @052975> : 3a                         shl.b32
	test/lang/useOperator.ci:90: (8 bytes: <@052976> - <@05297e>): u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6423 @052976> : 0a 34 00 00                load.sp(+52)
	<.main+6427 @05297a> : 20                         load.i8
	<.main+6428 @05297b> : 10 47                      dup.x1 sp(71)
	<.main+6430 @05297d> : 3c                         sar.b32
	test/lang/useOperator.ci:91: (7 bytes: <@05297e> - <@052985>): u8Not: bool := bool(!(u8B))
	<.main+6431 @05297e> : 0a 34 00 00                load.sp(+52)
	<.main+6435 @052982> : 20                         load.i8
	<.main+6436 @052983> : 5a                         i32.2bool
	<.main+6437 @052984> : 0b                         not.b32
	test/lang/useOperator.ci:92: (11 bytes: <@052985> - <@052990>): u8Ceq: bool := bool(u8A == u8B)
	<.main+6438 @052985> : 0a 3c 00 00                load.sp(+60)
	<.main+6442 @052989> : 20                         load.i8
	<.main+6443 @05298a> : 0a 3c 00 00                load.sp(+60)
	<.main+6447 @05298e> : 20                         load.i8
	<.main+6448 @05298f> : 57                         ceq.i32
	test/lang/useOperator.ci:93: (12 bytes: <@052990> - <@05299c>): u8Cne: bool := bool(u8A != u8B)
	<.main+6449 @052990> : 0a 40 00 00                load.sp(+64)
	<.main+6453 @052994> : 20                         load.i8
	<.main+6454 @052995> : 0a 40 00 00                load.sp(+64)
	<.main+6458 @052999> : 20                         load.i8
	<.main+6459 @05299a> : 57                         ceq.i32
	<.main+6460 @05299b> : 0b                         not.b32
	test/lang/useOperator.ci:94: (11 bytes: <@05299c> - <@0529a7>): u8Clt: bool := bool(u8A < u8B)
	<.main+6461 @05299c> : 0a 44 00 00                load.sp(+68)
	<.main+6465 @0529a0> : 20                         load.i8
	<.main+6466 @0529a1> : 0a 44 00 00                load.sp(+68)
	<.main+6470 @0529a5> : 20                         load.i8
	<.main+6471 @0529a6> : 38                         clt.u32
	test/lang/useOperator.ci:95: (12 bytes: <@0529a7> - <@0529b3>): u8Cle: bool := bool(u8A <= u8B)
	<.main+6472 @0529a7> : 0a 48 00 00                load.sp(+72)
	<.main+6476 @0529ab> : 20                         load.i8
	<.main+6477 @0529ac> : 0a 48 00 00                load.sp(+72)
	<.main+6481 @0529b0> : 20                         load.i8
	<.main+6482 @0529b1> : 39                         cgt.u32
	<.main+6483 @0529b2> : 0b                         not.b32
	test/lang/useOperator.ci:96: (11 bytes: <@0529b3> - <@0529be>): u8Cgt: bool := bool(u8A > u8B)
	<.main+6484 @0529b3> : 0a 4c 00 00                load.sp(+76)
	<.main+6488 @0529b7> : 20                         load.i8
	<.main+6489 @0529b8> : 0a 4c 00 00                load.sp(+76)
	<.main+6493 @0529bc> : 20                         load.i8
	<.main+6494 @0529bd> : 39                         cgt.u32
	test/lang/useOperator.ci:97: (12 bytes: <@0529be> - <@0529ca>): u8Cge: bool := bool(u8A >= u8B)
	<.main+6495 @0529be> : 0a 50 00 00                load.sp(+80)
	<.main+6499 @0529c2> : 20                         load.i8
	<.main+6500 @0529c3> : 0a 50 00 00                load.sp(+80)
	<.main+6504 @0529c7> : 20                         load.i8
	<.main+6505 @0529c8> : 38                         clt.u32
	<.main+6506 @0529c9> : 0b                         not.b32
	test/lang/useOperator.ci:99: (5 bytes: <@0529ca> - <@0529cf>): i16A: int16 := a
	<.main+6507 @0529ca> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:100: (5 bytes: <@0529cf> - <@0529d4>): i16B: int16 := b
	<.main+6512 @0529cf> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:101: (5 bytes: <@0529d4> - <@0529d9>): i16Pls: int16 := int16(+i16B)
	<.main+6517 @0529d4> : 0a 00 00 00                load.sp(+0)
	<.main+6521 @0529d8> : 21                         load.i16
	test/lang/useOperator.ci:102: (6 bytes: <@0529d9> - <@0529df>): i16Neg: int16 := int16(-i16B)
	<.main+6522 @0529d9> : 0a 04 00 00                load.sp(+4)
	<.main+6526 @0529dd> : 21                         load.i16
	<.main+6527 @0529de> : 50                         neg.i32
	test/lang/useOperator.ci:103: (6 bytes: <@0529df> - <@0529e5>): i16Cmt: int16 := int16(~i16B)
	<.main+6528 @0529df> : 0a 08 00 00                load.sp(+8)
	<.main+6532 @0529e3> : 21                         load.i16
	<.main+6533 @0529e4> : 30                         cmt.b32
	test/lang/useOperator.ci:104: (11 bytes: <@0529e5> - <@0529f0>): i16Add: int16 := int16(i16A + i16B)
	<.main+6534 @0529e5> : 0a 10 00 00                load.sp(+16)
	<.main+6538 @0529e9> : 21                         load.i16
	<.main+6539 @0529ea> : 0a 10 00 00                load.sp(+16)
	<.main+6543 @0529ee> : 21                         load.i16
	<.main+6544 @0529ef> : 51                         add.i32
	test/lang/useOperator.ci:105: (11 bytes: <@0529f0> - <@0529fb>): i16Sub: int16 := int16(i16A - i16B)
	<.main+6545 @0529f0> : 0a 14 00 00                load.sp(+20)
	<.main+6549 @0529f4> : 21                         load.i16
	<.main+6550 @0529f5> : 0a 14 00 00                load.sp(+20)
	<.main+6554 @0529f9> : 21                         load.i16
	<.main+6555 @0529fa> : 52                         sub.i32
	test/lang/useOperator.ci:106: (11 bytes: <@0529fb> - <@052a06>): i16Mul: int16 := int16(i16A * i16B)
	<.main+6556 @0529fb> : 0a 18 00 00                load.sp(+24)
	<.main+6560 @0529ff> : 21                         load.i16
	<.main+6561 @052a00> : 0a 18 00 00                load.sp(+24)
	<.main+6565 @052a04> : 21                         load.i16
	<.main+6566 @052a05> : 53                         mul.i32
	test/lang/useOperator.ci:107: (11 bytes: <@052a06> - <@052a11>): i16Div: int16 := int16(i16A / i16B)
	<.main+6567 @052a06> : 0a 1c 00 00                load.sp(+28)
	<.main+6571 @052a0a> : 21                         load.i16
	<.main+6572 @052a0b> : 0a 1c 00 00                load.sp(+28)
	<.main+6576 @052a0f> : 21                         load.i16
	<.main+6577 @052a10> : 54                         div.i32
	test/lang/useOperator.ci:108: (11 bytes: <@052a11> - <@052a1c>): i16Mod: int16 := int16(i16A % i16B)
	<.main+6578 @052a11> : 0a 20 00 00                load.sp(+32)
	<.main+6582 @052a15> : 21                         load.i16
	<.main+6583 @052a16> : 0a 20 00 00                load.sp(+32)
	<.main+6587 @052a1a> : 21                         load.i16
	<.main+6588 @052a1b> : 55                         mod.i32
	test/lang/useOperator.ci:109: (11 bytes: <@052a1c> - <@052a27>): i16And: int16 := int16(i16A & i16B)
	<.main+6589 @052a1c> : 0a 24 00 00                load.sp(+36)
	<.main+6593 @052a20> : 21                         load.i16
	<.main+6594 @052a21> : 0a 24 00 00                load.sp(+36)
	<.main+6598 @052a25> : 21                         load.i16
	<.main+6599 @052a26> : 31                         and.b32
	test/lang/useOperator.ci:110: (11 bytes: <@052a27> - <@052a32>): i16Ior: int16 := int16(i16A | i16B)
	<.main+6600 @052a27> : 0a 28 00 00                load.sp(+40)
	<.main+6604 @052a2b> : 21                         load.i16
	<.main+6605 @052a2c> : 0a 28 00 00                load.sp(+40)
	<.main+6609 @052a30> : 21                         load.i16
	<.main+6610 @052a31> : 32                         or.b32
	test/lang/useOperator.ci:111: (11 bytes: <@052a32> - <@052a3d>): i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6611 @052a32> : 0a 2c 00 00                load.sp(+44)
	<.main+6615 @052a36> : 21                         load.i16
	<.main+6616 @052a37> : 0a 2c 00 00                load.sp(+44)
	<.main+6620 @052a3b> : 21                         load.i16
	<.main+6621 @052a3c> : 36                         xor.b32
	test/lang/useOperator.ci:112: (8 bytes: <@052a3d> - <@052a45>): i16Shl: int16 := int32((i16A) << shift)
	<.main+6622 @052a3d> : 0a 30 00 00                load.sp(+48)
	<.main+6626 @052a41> : 21                         load.i16
	<.main+6627 @052a42> : 10 5c                      dup.x1 sp(92)
	<.main+6629 @052a44> : 3a                         shl.b32
	test/lang/useOperator.ci:113: (8 bytes: <@052a45> - <@052a4d>): i16Shr: int16 := int32((i16A) >> shift)
	<.main+6630 @052a45> : 0a 34 00 00                load.sp(+52)
	<.main+6634 @052a49> : 21                         load.i16
	<.main+6635 @052a4a> : 10 5d                      dup.x1 sp(93)
	<.main+6637 @052a4c> : 3c                         sar.b32
	test/lang/useOperator.ci:114: (7 bytes: <@052a4d> - <@052a54>): i16Not: bool := bool(!(i16B))
	<.main+6638 @052a4d> : 0a 34 00 00                load.sp(+52)
	<.main+6642 @052a51> : 21                         load.i16
	<.main+6643 @052a52> : 5a                         i32.2bool
	<.main+6644 @052a53> : 0b                         not.b32
	test/lang/useOperator.ci:115: (11 bytes: <@052a54> - <@052a5f>): i16Ceq: bool := bool(i16A == i16B)
	<.main+6645 @052a54> : 0a 3c 00 00                load.sp(+60)
	<.main+6649 @052a58> : 21                         load.i16
	<.main+6650 @052a59> : 0a 3c 00 00                load.sp(+60)
	<.main+6654 @052a5d> : 21                         load.i16
	<.main+6655 @052a5e> : 57                         ceq.i32
	test/lang/useOperator.ci:116: (12 bytes: <@052a5f> - <@052a6b>): i16Cne: bool := bool(i16A != i16B)
	<.main+6656 @052a5f> : 0a 40 00 00                load.sp(+64)
	<.main+6660 @052a63> : 21                         load.i16
	<.main+6661 @052a64> : 0a 40 00 00                load.sp(+64)
	<.main+6665 @052a68> : 21                         load.i16
	<.main+6666 @052a69> : 57                         ceq.i32
	<.main+6667 @052a6a> : 0b                         not.b32
	test/lang/useOperator.ci:117: (11 bytes: <@052a6b> - <@052a76>): i16Clt: bool := bool(i16A < i16B)
	<.main+6668 @052a6b> : 0a 44 00 00                load.sp(+68)
	<.main+6672 @052a6f> : 21                         load.i16
	<.main+6673 @052a70> : 0a 44 00 00                load.sp(+68)
	<.main+6677 @052a74> : 21                         load.i16
	<.main+6678 @052a75> : 58                         clt.i32
	test/lang/useOperator.ci:118: (12 bytes: <@052a76> - <@052a82>): i16Cle: bool := bool(i16A <= i16B)
	<.main+6679 @052a76> : 0a 48 00 00                load.sp(+72)
	<.main+6683 @052a7a> : 21                         load.i16
	<.main+6684 @052a7b> : 0a 48 00 00                load.sp(+72)
	<.main+6688 @052a7f> : 21                         load.i16
	<.main+6689 @052a80> : 59                         cgt.i32
	<.main+6690 @052a81> : 0b                         not.b32
	test/lang/useOperator.ci:119: (11 bytes: <@052a82> - <@052a8d>): i16Cgt: bool := bool(i16A > i16B)
	<.main+6691 @052a82> : 0a 4c 00 00                load.sp(+76)
	<.main+6695 @052a86> : 21                         load.i16
	<.main+6696 @052a87> : 0a 4c 00 00                load.sp(+76)
	<.main+6700 @052a8b> : 21                         load.i16
	<.main+6701 @052a8c> : 59                         cgt.i32
	test/lang/useOperator.ci:120: (12 bytes: <@052a8d> - <@052a99>): i16Cge: bool := bool(i16A >= i16B)
	<.main+6702 @052a8d> : 0a 50 00 00                load.sp(+80)
	<.main+6706 @052a91> : 21                         load.i16
	<.main+6707 @052a92> : 0a 50 00 00                load.sp(+80)
	<.main+6711 @052a96> : 21                         load.i16
	<.main+6712 @052a97> : 58                         clt.i32
	<.main+6713 @052a98> : 0b                         not.b32
	test/lang/useOperator.ci:122: (5 bytes: <@052a99> - <@052a9e>): u16A: uint16 := a
	<.main+6714 @052a99> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:123: (5 bytes: <@052a9e> - <@052aa3>): u16B: uint16 := b
	<.main+6719 @052a9e> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:124: (5 bytes: <@052aa3> - <@052aa8>): u16Pls: uint16 := uint16(+u16B)
	<.main+6724 @052aa3> : 0a 00 00 00                load.sp(+0)
	<.main+6728 @052aa7> : 21                         load.i16
	test/lang/useOperator.ci:125: (6 bytes: <@052aa8> - <@052aae>): u16Neg: uint16 := uint16(-u16B)
	<.main+6729 @052aa8> : 0a 04 00 00                load.sp(+4)
	<.main+6733 @052aac> : 21                         load.i16
	<.main+6734 @052aad> : 50                         neg.i32
	test/lang/useOperator.ci:126: (6 bytes: <@052aae> - <@052ab4>): u16Cmt: uint16 := uint16(~u16B)
	<.main+6735 @052aae> : 0a 08 00 00                load.sp(+8)
	<.main+6739 @052ab2> : 21                         load.i16
	<.main+6740 @052ab3> : 30                         cmt.b32
	test/lang/useOperator.ci:127: (11 bytes: <@052ab4> - <@052abf>): u16Add: uint16 := uint16(u16A + u16B)
	<.main+6741 @052ab4> : 0a 10 00 00                load.sp(+16)
	<.main+6745 @052ab8> : 21                         load.i16
	<.main+6746 @052ab9> : 0a 10 00 00                load.sp(+16)
	<.main+6750 @052abd> : 21                         load.i16
	<.main+6751 @052abe> : 51                         add.i32
	test/lang/useOperator.ci:128: (11 bytes: <@052abf> - <@052aca>): u16Sub: uint16 := uint16(u16A - u16B)
	<.main+6752 @052abf> : 0a 14 00 00                load.sp(+20)
	<.main+6756 @052ac3> : 21                         load.i16
	<.main+6757 @052ac4> : 0a 14 00 00                load.sp(+20)
	<.main+6761 @052ac8> : 21                         load.i16
	<.main+6762 @052ac9> : 52                         sub.i32
	test/lang/useOperator.ci:129: (11 bytes: <@052aca> - <@052ad5>): u16Mul: uint16 := uint16(u16A * u16B)
	<.main+6763 @052aca> : 0a 18 00 00                load.sp(+24)
	<.main+6767 @052ace> : 21                         load.i16
	<.main+6768 @052acf> : 0a 18 00 00                load.sp(+24)
	<.main+6772 @052ad3> : 21                         load.i16
	<.main+6773 @052ad4> : 33                         mul.u32
	test/lang/useOperator.ci:130: (11 bytes: <@052ad5> - <@052ae0>): u16Div: uint16 := uint16(u16A / u16B)
	<.main+6774 @052ad5> : 0a 1c 00 00                load.sp(+28)
	<.main+6778 @052ad9> : 21                         load.i16
	<.main+6779 @052ada> : 0a 1c 00 00                load.sp(+28)
	<.main+6783 @052ade> : 21                         load.i16
	<.main+6784 @052adf> : 34                         div.u32
	test/lang/useOperator.ci:131: (11 bytes: <@052ae0> - <@052aeb>): u16Mod: uint16 := uint16(u16A % u16B)
	<.main+6785 @052ae0> : 0a 20 00 00                load.sp(+32)
	<.main+6789 @052ae4> : 21                         load.i16
	<.main+6790 @052ae5> : 0a 20 00 00                load.sp(+32)
	<.main+6794 @052ae9> : 21                         load.i16
	<.main+6795 @052aea> : 35                         mod.u32
	test/lang/useOperator.ci:132: (11 bytes: <@052aeb> - <@052af6>): u16And: uint16 := uint16(u16A & u16B)
	<.main+6796 @052aeb> : 0a 24 00 00                load.sp(+36)
	<.main+6800 @052aef> : 21                         load.i16
	<.main+6801 @052af0> : 0a 24 00 00                load.sp(+36)
	<.main+6805 @052af4> : 21                         load.i16
	<.main+6806 @052af5> : 31                         and.b32
	test/lang/useOperator.ci:133: (11 bytes: <@052af6> - <@052b01>): u16Ior: uint16 := uint16(u16A | u16B)
	<.main+6807 @052af6> : 0a 28 00 00                load.sp(+40)
	<.main+6811 @052afa> : 21                         load.i16
	<.main+6812 @052afb> : 0a 28 00 00                load.sp(+40)
	<.main+6816 @052aff> : 21                         load.i16
	<.main+6817 @052b00> : 32                         or.b32
	test/lang/useOperator.ci:134: (11 bytes: <@052b01> - <@052b0c>): u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+6818 @052b01> : 0a 2c 00 00                load.sp(+44)
	<.main+6822 @052b05> : 21                         load.i16
	<.main+6823 @052b06> : 0a 2c 00 00                load.sp(+44)
	<.main+6827 @052b0a> : 21                         load.i16
	<.main+6828 @052b0b> : 36                         xor.b32
	test/lang/useOperator.ci:135: (8 bytes: <@052b0c> - <@052b14>): u16Shl: uint16 := int32((u16A) << shift)
	<.main+6829 @052b0c> : 0a 30 00 00                load.sp(+48)
	<.main+6833 @052b10> : 21                         load.i16
	<.main+6834 @052b11> : 10 72                      dup.x1 sp(114)
	<.main+6836 @052b13> : 3a                         shl.b32
	test/lang/useOperator.ci:136: (8 bytes: <@052b14> - <@052b1c>): u16Shr: uint16 := int32((u16A) >> shift)
	<.main+6837 @052b14> : 0a 34 00 00                load.sp(+52)
	<.main+6841 @052b18> : 21                         load.i16
	<.main+6842 @052b19> : 10 73                      dup.x1 sp(115)
	<.main+6844 @052b1b> : 3c                         sar.b32
	test/lang/useOperator.ci:137: (7 bytes: <@052b1c> - <@052b23>): u16Not: bool := bool(!(u16B))
	<.main+6845 @052b1c> : 0a 34 00 00                load.sp(+52)
	<.main+6849 @052b20> : 21                         load.i16
	<.main+6850 @052b21> : 5a                         i32.2bool
	<.main+6851 @052b22> : 0b                         not.b32
	test/lang/useOperator.ci:138: (11 bytes: <@052b23> - <@052b2e>): u16Ceq: bool := bool(u16A == u16B)
	<.main+6852 @052b23> : 0a 3c 00 00                load.sp(+60)
	<.main+6856 @052b27> : 21                         load.i16
	<.main+6857 @052b28> : 0a 3c 00 00                load.sp(+60)
	<.main+6861 @052b2c> : 21                         load.i16
	<.main+6862 @052b2d> : 57                         ceq.i32
	test/lang/useOperator.ci:139: (12 bytes: <@052b2e> - <@052b3a>): u16Cne: bool := bool(u16A != u16B)
	<.main+6863 @052b2e> : 0a 40 00 00                load.sp(+64)
	<.main+6867 @052b32> : 21                         load.i16
	<.main+6868 @052b33> : 0a 40 00 00                load.sp(+64)
	<.main+6872 @052b37> : 21                         load.i16
	<.main+6873 @052b38> : 57                         ceq.i32
	<.main+6874 @052b39> : 0b                         not.b32
	test/lang/useOperator.ci:140: (11 bytes: <@052b3a> - <@052b45>): u16Clt: bool := bool(u16A < u16B)
	<.main+6875 @052b3a> : 0a 44 00 00                load.sp(+68)
	<.main+6879 @052b3e> : 21                         load.i16
	<.main+6880 @052b3f> : 0a 44 00 00                load.sp(+68)
	<.main+6884 @052b43> : 21                         load.i16
	<.main+6885 @052b44> : 38                         clt.u32
	test/lang/useOperator.ci:141: (12 bytes: <@052b45> - <@052b51>): u16Cle: bool := bool(u16A <= u16B)
	<.main+6886 @052b45> : 0a 48 00 00                load.sp(+72)
	<.main+6890 @052b49> : 21                         load.i16
	<.main+6891 @052b4a> : 0a 48 00 00                load.sp(+72)
	<.main+6895 @052b4e> : 21                         load.i16
	<.main+6896 @052b4f> : 39                         cgt.u32
	<.main+6897 @052b50> : 0b                         not.b32
	test/lang/useOperator.ci:142: (11 bytes: <@052b51> - <@052b5c>): u16Cgt: bool := bool(u16A > u16B)
	<.main+6898 @052b51> : 0a 4c 00 00                load.sp(+76)
	<.main+6902 @052b55> : 21                         load.i16
	<.main+6903 @052b56> : 0a 4c 00 00                load.sp(+76)
	<.main+6907 @052b5a> : 21                         load.i16
	<.main+6908 @052b5b> : 39                         cgt.u32
	test/lang/useOperator.ci:143: (12 bytes: <@052b5c> - <@052b68>): u16Cge: bool := bool(u16A >= u16B)
	<.main+6909 @052b5c> : 0a 50 00 00                load.sp(+80)
	<.main+6913 @052b60> : 21                         load.i16
	<.main+6914 @052b61> : 0a 50 00 00                load.sp(+80)
	<.main+6918 @052b65> : 21                         load.i16
	<.main+6919 @052b66> : 38                         clt.u32
	<.main+6920 @052b67> : 0b                         not.b32
	test/lang/useOperator.ci:145: (5 bytes: <@052b68> - <@052b6d>): i32A: int32 := a
	<.main+6921 @052b68> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:146: (5 bytes: <@052b6d> - <@052b72>): i32B: int32 := b
	<.main+6926 @052b6d> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:147: (2 bytes: <@052b72> - <@052b74>): i32Pls: int32 := int32(+i32B)
	<.main+6931 @052b72> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:148: (3 bytes: <@052b74> - <@052b77>): i32Neg: int32 := int32(-i32B)
	<.main+6933 @052b74> : 10 01                      dup.x1 sp(1)
	<.main+6935 @052b76> : 50                         neg.i32
	test/lang/useOperator.ci:149: (3 bytes: <@052b77> - <@052b7a>): i32Cmt: int32 := int32(~i32B)
	<.main+6936 @052b77> : 10 02                      dup.x1 sp(2)
	<.main+6938 @052b79> : 30                         cmt.b32
	test/lang/useOperator.ci:150: (5 bytes: <@052b7a> - <@052b7f>): i32Add: int32 := int32(i32A + i32B)
	<.main+6939 @052b7a> : 10 04                      dup.x1 sp(4)
	<.main+6941 @052b7c> : 10 04                      dup.x1 sp(4)
	<.main+6943 @052b7e> : 51                         add.i32
	test/lang/useOperator.ci:151: (5 bytes: <@052b7f> - <@052b84>): i32Sub: int32 := int32(i32A - i32B)
	<.main+6944 @052b7f> : 10 05                      dup.x1 sp(5)
	<.main+6946 @052b81> : 10 05                      dup.x1 sp(5)
	<.main+6948 @052b83> : 52                         sub.i32
	test/lang/useOperator.ci:152: (5 bytes: <@052b84> - <@052b89>): i32Mul: int32 := int32(i32A * i32B)
	<.main+6949 @052b84> : 10 06                      dup.x1 sp(6)
	<.main+6951 @052b86> : 10 06                      dup.x1 sp(6)
	<.main+6953 @052b88> : 53                         mul.i32
	test/lang/useOperator.ci:153: (5 bytes: <@052b89> - <@052b8e>): i32Div: int32 := int32(i32A / i32B)
	<.main+6954 @052b89> : 10 07                      dup.x1 sp(7)
	<.main+6956 @052b8b> : 10 07                      dup.x1 sp(7)
	<.main+6958 @052b8d> : 54                         div.i32
	test/lang/useOperator.ci:154: (5 bytes: <@052b8e> - <@052b93>): i32Mod: int32 := int32(i32A % i32B)
	<.main+6959 @052b8e> : 10 08                      dup.x1 sp(8)
	<.main+6961 @052b90> : 10 08                      dup.x1 sp(8)
	<.main+6963 @052b92> : 55                         mod.i32
	test/lang/useOperator.ci:155: (5 bytes: <@052b93> - <@052b98>): i32And: int32 := int32(i32A & i32B)
	<.main+6964 @052b93> : 10 09                      dup.x1 sp(9)
	<.main+6966 @052b95> : 10 09                      dup.x1 sp(9)
	<.main+6968 @052b97> : 31                         and.b32
	test/lang/useOperator.ci:156: (5 bytes: <@052b98> - <@052b9d>): i32Ior: int32 := int32(i32A | i32B)
	<.main+6969 @052b98> : 10 0a                      dup.x1 sp(10)
	<.main+6971 @052b9a> : 10 0a                      dup.x1 sp(10)
	<.main+6973 @052b9c> : 32                         or.b32
	test/lang/useOperator.ci:157: (5 bytes: <@052b9d> - <@052ba2>): i32Xor: int32 := int32(i32A ^ i32B)
	<.main+6974 @052b9d> : 10 0b                      dup.x1 sp(11)
	<.main+6976 @052b9f> : 10 0b                      dup.x1 sp(11)
	<.main+6978 @052ba1> : 36                         xor.b32
	test/lang/useOperator.ci:158: (5 bytes: <@052ba2> - <@052ba7>): i32Shl: int32 := int32(i32A << shift)
	<.main+6979 @052ba2> : 10 0c                      dup.x1 sp(12)
	<.main+6981 @052ba4> : 10 88                      dup.x1 sp(136)
	<.main+6983 @052ba6> : 3a                         shl.b32
	test/lang/useOperator.ci:159: (5 bytes: <@052ba7> - <@052bac>): i32Shr: int32 := int32(i32A >> shift)
	<.main+6984 @052ba7> : 10 0d                      dup.x1 sp(13)
	<.main+6986 @052ba9> : 10 89                      dup.x1 sp(137)
	<.main+6988 @052bab> : 3c                         sar.b32
	test/lang/useOperator.ci:160: (4 bytes: <@052bac> - <@052bb0>): i32Not: bool := bool(!(i32B))
	<.main+6989 @052bac> : 10 0d                      dup.x1 sp(13)
	<.main+6991 @052bae> : 5a                         i32.2bool
	<.main+6992 @052baf> : 0b                         not.b32
	test/lang/useOperator.ci:161: (5 bytes: <@052bb0> - <@052bb5>): i32Ceq: bool := bool(i32A == i32B)
	<.main+6993 @052bb0> : 10 0f                      dup.x1 sp(15)
	<.main+6995 @052bb2> : 10 0f                      dup.x1 sp(15)
	<.main+6997 @052bb4> : 57                         ceq.i32
	test/lang/useOperator.ci:162: (6 bytes: <@052bb5> - <@052bbb>): i32Cne: bool := bool(i32A != i32B)
	<.main+6998 @052bb5> : 10 10                      dup.x1 sp(16)
	<.main+7000 @052bb7> : 10 10                      dup.x1 sp(16)
	<.main+7002 @052bb9> : 57                         ceq.i32
	<.main+7003 @052bba> : 0b                         not.b32
	test/lang/useOperator.ci:163: (5 bytes: <@052bbb> - <@052bc0>): i32Clt: bool := bool(i32A < i32B)
	<.main+7004 @052bbb> : 10 11                      dup.x1 sp(17)
	<.main+7006 @052bbd> : 10 11                      dup.x1 sp(17)
	<.main+7008 @052bbf> : 58                         clt.i32
	test/lang/useOperator.ci:164: (6 bytes: <@052bc0> - <@052bc6>): i32Cle: bool := bool(i32A <= i32B)
	<.main+7009 @052bc0> : 10 12                      dup.x1 sp(18)
	<.main+7011 @052bc2> : 10 12                      dup.x1 sp(18)
	<.main+7013 @052bc4> : 59                         cgt.i32
	<.main+7014 @052bc5> : 0b                         not.b32
	test/lang/useOperator.ci:165: (5 bytes: <@052bc6> - <@052bcb>): i32Cgt: bool := bool(i32A > i32B)
	<.main+7015 @052bc6> : 10 13                      dup.x1 sp(19)
	<.main+7017 @052bc8> : 10 13                      dup.x1 sp(19)
	<.main+7019 @052bca> : 59                         cgt.i32
	test/lang/useOperator.ci:166: (6 bytes: <@052bcb> - <@052bd1>): i32Cge: bool := bool(i32A >= i32B)
	<.main+7020 @052bcb> : 10 14                      dup.x1 sp(20)
	<.main+7022 @052bcd> : 10 14                      dup.x1 sp(20)
	<.main+7024 @052bcf> : 58                         clt.i32
	<.main+7025 @052bd0> : 0b                         not.b32
	test/lang/useOperator.ci:168: (5 bytes: <@052bd1> - <@052bd6>): u32A: uint32 := a
	<.main+7026 @052bd1> : 1c 60 00 00 00             load.c32 96
	test/lang/useOperator.ci:169: (5 bytes: <@052bd6> - <@052bdb>): u32B: uint32 := b
	<.main+7031 @052bd6> : 1c 2a 00 00 00             load.c32 42
	test/lang/useOperator.ci:170: (2 bytes: <@052bdb> - <@052bdd>): u32Pls: uint32 := uint32(+u32B)
	<.main+7036 @052bdb> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:171: (3 bytes: <@052bdd> - <@052be0>): u32Neg: uint32 := uint32(-u32B)
	<.main+7038 @052bdd> : 10 01                      dup.x1 sp(1)
	<.main+7040 @052bdf> : 50                         neg.i32
	test/lang/useOperator.ci:172: (3 bytes: <@052be0> - <@052be3>): u32Cmt: uint32 := uint32(~u32B)
	<.main+7041 @052be0> : 10 02                      dup.x1 sp(2)
	<.main+7043 @052be2> : 30                         cmt.b32
	test/lang/useOperator.ci:173: (5 bytes: <@052be3> - <@052be8>): u32Add: uint32 := uint32(u32A + u32B)
	<.main+7044 @052be3> : 10 04                      dup.x1 sp(4)
	<.main+7046 @052be5> : 10 04                      dup.x1 sp(4)
	<.main+7048 @052be7> : 51                         add.i32
	test/lang/useOperator.ci:174: (5 bytes: <@052be8> - <@052bed>): u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7049 @052be8> : 10 05                      dup.x1 sp(5)
	<.main+7051 @052bea> : 10 05                      dup.x1 sp(5)
	<.main+7053 @052bec> : 52                         sub.i32
	test/lang/useOperator.ci:175: (5 bytes: <@052bed> - <@052bf2>): u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7054 @052bed> : 10 06                      dup.x1 sp(6)
	<.main+7056 @052bef> : 10 06                      dup.x1 sp(6)
	<.main+7058 @052bf1> : 33                         mul.u32
	test/lang/useOperator.ci:176: (5 bytes: <@052bf2> - <@052bf7>): u32Div: uint32 := uint32(u32A / u32B)
	<.main+7059 @052bf2> : 10 07                      dup.x1 sp(7)
	<.main+7061 @052bf4> : 10 07                      dup.x1 sp(7)
	<.main+7063 @052bf6> : 34                         div.u32
	test/lang/useOperator.ci:177: (5 bytes: <@052bf7> - <@052bfc>): u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7064 @052bf7> : 10 08                      dup.x1 sp(8)
	<.main+7066 @052bf9> : 10 08                      dup.x1 sp(8)
	<.main+7068 @052bfb> : 35                         mod.u32
	test/lang/useOperator.ci:178: (5 bytes: <@052bfc> - <@052c01>): u32And: uint32 := uint32(u32A & u32B)
	<.main+7069 @052bfc> : 10 09                      dup.x1 sp(9)
	<.main+7071 @052bfe> : 10 09                      dup.x1 sp(9)
	<.main+7073 @052c00> : 31                         and.b32
	test/lang/useOperator.ci:179: (5 bytes: <@052c01> - <@052c06>): u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7074 @052c01> : 10 0a                      dup.x1 sp(10)
	<.main+7076 @052c03> : 10 0a                      dup.x1 sp(10)
	<.main+7078 @052c05> : 32                         or.b32
	test/lang/useOperator.ci:180: (5 bytes: <@052c06> - <@052c0b>): u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7079 @052c06> : 10 0b                      dup.x1 sp(11)
	<.main+7081 @052c08> : 10 0b                      dup.x1 sp(11)
	<.main+7083 @052c0a> : 36                         xor.b32
	test/lang/useOperator.ci:181: (5 bytes: <@052c0b> - <@052c10>): u32Shl: uint32 := uint32(u32A << shift)
	<.main+7084 @052c0b> : 10 0c                      dup.x1 sp(12)
	<.main+7086 @052c0d> : 10 9e                      dup.x1 sp(158)
	<.main+7088 @052c0f> : 3a                         shl.b32
	test/lang/useOperator.ci:182: (5 bytes: <@052c10> - <@052c15>): u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7089 @052c10> : 10 0d                      dup.x1 sp(13)
	<.main+7091 @052c12> : 10 9f                      dup.x1 sp(159)
	<.main+7093 @052c14> : 3b                         shr.b32
	test/lang/useOperator.ci:183: (4 bytes: <@052c15> - <@052c19>): u32Not: bool := bool(!(u32B))
	<.main+7094 @052c15> : 10 0d                      dup.x1 sp(13)
	<.main+7096 @052c17> : 5a                         i32.2bool
	<.main+7097 @052c18> : 0b                         not.b32
	test/lang/useOperator.ci:184: (5 bytes: <@052c19> - <@052c1e>): u32Ceq: bool := bool(u32A == u32B)
	<.main+7098 @052c19> : 10 0f                      dup.x1 sp(15)
	<.main+7100 @052c1b> : 10 0f                      dup.x1 sp(15)
	<.main+7102 @052c1d> : 57                         ceq.i32
	test/lang/useOperator.ci:185: (6 bytes: <@052c1e> - <@052c24>): u32Cne: bool := bool(u32A != u32B)
	<.main+7103 @052c1e> : 10 10                      dup.x1 sp(16)
	<.main+7105 @052c20> : 10 10                      dup.x1 sp(16)
	<.main+7107 @052c22> : 57                         ceq.i32
	<.main+7108 @052c23> : 0b                         not.b32
	test/lang/useOperator.ci:186: (5 bytes: <@052c24> - <@052c29>): u32Clt: bool := bool(u32A < u32B)
	<.main+7109 @052c24> : 10 11                      dup.x1 sp(17)
	<.main+7111 @052c26> : 10 11                      dup.x1 sp(17)
	<.main+7113 @052c28> : 38                         clt.u32
	test/lang/useOperator.ci:187: (6 bytes: <@052c29> - <@052c2f>): u32Cle: bool := bool(u32A <= u32B)
	<.main+7114 @052c29> : 10 12                      dup.x1 sp(18)
	<.main+7116 @052c2b> : 10 12                      dup.x1 sp(18)
	<.main+7118 @052c2d> : 39                         cgt.u32
	<.main+7119 @052c2e> : 0b                         not.b32
	test/lang/useOperator.ci:188: (5 bytes: <@052c2f> - <@052c34>): u32Cgt: bool := bool(u32A > u32B)
	<.main+7120 @052c2f> : 10 13                      dup.x1 sp(19)
	<.main+7122 @052c31> : 10 13                      dup.x1 sp(19)
	<.main+7124 @052c33> : 39                         cgt.u32
	test/lang/useOperator.ci:189: (6 bytes: <@052c34> - <@052c3a>): u32Cge: bool := bool(u32A >= u32B)
	<.main+7125 @052c34> : 10 14                      dup.x1 sp(20)
	<.main+7127 @052c36> : 10 14                      dup.x1 sp(20)
	<.main+7129 @052c38> : 38                         clt.u32
	<.main+7130 @052c39> : 0b                         not.b32
	test/lang/useOperator.ci:191: (9 bytes: <@052c3a> - <@052c43>): i64A: int64 := a
	<.main+7131 @052c3a> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:192: (9 bytes: <@052c43> - <@052c4c>): i64B: int64 := b
	<.main+7140 @052c43> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:193: (2 bytes: <@052c4c> - <@052c4e>): i64Pls: int64 := int64(+i64B)
	<.main+7149 @052c4c> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:194: (3 bytes: <@052c4e> - <@052c51>): i64Neg: int64 := int64(-i64B)
	<.main+7151 @052c4e> : 11 02                      dup.x2 sp(2)
	<.main+7153 @052c50> : 60                         neg.i64
	test/lang/useOperator.ci:195: (3 bytes: <@052c51> - <@052c54>): i64Cmt: int64 := int64(~i64B)
	<.main+7154 @052c51> : 11 04                      dup.x2 sp(4)
	<.main+7156 @052c53> : 40                         cmt.b64
	test/lang/useOperator.ci:196: (5 bytes: <@052c54> - <@052c59>): i64Add: int64 := int64(i64A + i64B)
	<.main+7157 @052c54> : 11 08                      dup.x2 sp(8)
	<.main+7159 @052c56> : 11 08                      dup.x2 sp(8)
	<.main+7161 @052c58> : 61                         add.i64
	test/lang/useOperator.ci:197: (5 bytes: <@052c59> - <@052c5e>): i64Sub: int64 := int64(i64A - i64B)
	<.main+7162 @052c59> : 11 0a                      dup.x2 sp(10)
	<.main+7164 @052c5b> : 11 0a                      dup.x2 sp(10)
	<.main+7166 @052c5d> : 62                         sub.i64
	test/lang/useOperator.ci:198: (5 bytes: <@052c5e> - <@052c63>): i64Mul: int64 := int64(i64A * i64B)
	<.main+7167 @052c5e> : 11 0c                      dup.x2 sp(12)
	<.main+7169 @052c60> : 11 0c                      dup.x2 sp(12)
	<.main+7171 @052c62> : 63                         mul.i64
	test/lang/useOperator.ci:199: (5 bytes: <@052c63> - <@052c68>): i64Div: int64 := int64(i64A / i64B)
	<.main+7172 @052c63> : 11 0e                      dup.x2 sp(14)
	<.main+7174 @052c65> : 11 0e                      dup.x2 sp(14)
	<.main+7176 @052c67> : 64                         div.i64
	test/lang/useOperator.ci:200: (5 bytes: <@052c68> - <@052c6d>): i64Mod: int64 := int64(i64A % i64B)
	<.main+7177 @052c68> : 11 10                      dup.x2 sp(16)
	<.main+7179 @052c6a> : 11 10                      dup.x2 sp(16)
	<.main+7181 @052c6c> : 65                         mod.i64
	test/lang/useOperator.ci:201: (5 bytes: <@052c6d> - <@052c72>): i64And: int64 := int64(i64A & i64B)
	<.main+7182 @052c6d> : 11 12                      dup.x2 sp(18)
	<.main+7184 @052c6f> : 11 12                      dup.x2 sp(18)
	<.main+7186 @052c71> : 41                         and.b64
	test/lang/useOperator.ci:202: (5 bytes: <@052c72> - <@052c77>): i64Ior: int64 := int64(i64A | i64B)
	<.main+7187 @052c72> : 11 14                      dup.x2 sp(20)
	<.main+7189 @052c74> : 11 14                      dup.x2 sp(20)
	<.main+7191 @052c76> : 42                         or.b64
	test/lang/useOperator.ci:203: (5 bytes: <@052c77> - <@052c7c>): i64Xor: int64 := int64(i64A ^ i64B)
	<.main+7192 @052c77> : 11 16                      dup.x2 sp(22)
	<.main+7194 @052c79> : 11 16                      dup.x2 sp(22)
	<.main+7196 @052c7b> : 46                         xor.b64
	test/lang/useOperator.ci:204: (5 bytes: <@052c7c> - <@052c81>): i64Shl: int64 := int64(i64A << shift)
	<.main+7197 @052c7c> : 11 18                      dup.x2 sp(24)
	<.main+7199 @052c7e> : 10 c2                      dup.x1 sp(194)
	<.main+7201 @052c80> : 4a                         shl.b64
	test/lang/useOperator.ci:205: (5 bytes: <@052c81> - <@052c86>): i64Shr: int64 := int64(i64A >> shift)
	<.main+7202 @052c81> : 11 1a                      dup.x2 sp(26)
	<.main+7204 @052c83> : 10 c4                      dup.x1 sp(196)
	<.main+7206 @052c85> : 4c                         sar.b64
	test/lang/useOperator.ci:206: (4 bytes: <@052c86> - <@052c8a>): i64Not: bool := bool(!(i64B))
	<.main+7207 @052c86> : 11 1a                      dup.x2 sp(26)
	<.main+7209 @052c88> : 6c                         i64.2bool
	<.main+7210 @052c89> : 0b                         not.b32
	test/lang/useOperator.ci:207: (5 bytes: <@052c8a> - <@052c8f>): i64Ceq: bool := bool(i64A == i64B)
	<.main+7211 @052c8a> : 11 1d                      dup.x2 sp(29)
	<.main+7213 @052c8c> : 11 1d                      dup.x2 sp(29)
	<.main+7215 @052c8e> : 67                         ceq.i64
	test/lang/useOperator.ci:208: (6 bytes: <@052c8f> - <@052c95>): i64Cne: bool := bool(i64A != i64B)
	<.main+7216 @052c8f> : 11 1e                      dup.x2 sp(30)
	<.main+7218 @052c91> : 11 1e                      dup.x2 sp(30)
	<.main+7220 @052c93> : 67                         ceq.i64
	<.main+7221 @052c94> : 0b                         not.b32
	test/lang/useOperator.ci:209: (5 bytes: <@052c95> - <@052c9a>): i64Clt: bool := bool(i64A < i64B)
	<.main+7222 @052c95> : 11 1f                      dup.x2 sp(31)
	<.main+7224 @052c97> : 11 1f                      dup.x2 sp(31)
	<.main+7226 @052c99> : 68                         clt.i64
	test/lang/useOperator.ci:210: (6 bytes: <@052c9a> - <@052ca0>): i64Cle: bool := bool(i64A <= i64B)
	<.main+7227 @052c9a> : 11 20                      dup.x2 sp(32)
	<.main+7229 @052c9c> : 11 20                      dup.x2 sp(32)
	<.main+7231 @052c9e> : 69                         cgt.i64
	<.main+7232 @052c9f> : 0b                         not.b32
	test/lang/useOperator.ci:211: (5 bytes: <@052ca0> - <@052ca5>): i64Cgt: bool := bool(i64A > i64B)
	<.main+7233 @052ca0> : 11 21                      dup.x2 sp(33)
	<.main+7235 @052ca2> : 11 21                      dup.x2 sp(33)
	<.main+7237 @052ca4> : 69                         cgt.i64
	test/lang/useOperator.ci:212: (6 bytes: <@052ca5> - <@052cab>): i64Cge: bool := bool(i64A >= i64B)
	<.main+7238 @052ca5> : 11 22                      dup.x2 sp(34)
	<.main+7240 @052ca7> : 11 22                      dup.x2 sp(34)
	<.main+7242 @052ca9> : 68                         clt.i64
	<.main+7243 @052caa> : 0b                         not.b32
	test/lang/useOperator.ci:214: (9 bytes: <@052cab> - <@052cb4>): u64A: uint64 := a
	<.main+7244 @052cab> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	test/lang/useOperator.ci:215: (9 bytes: <@052cb4> - <@052cbd>): u64B: uint64 := b
	<.main+7253 @052cb4> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	test/lang/useOperator.ci:216: (2 bytes: <@052cbd> - <@052cbf>): u64Pls: uint64 := uint64(+u64B)
	<.main+7262 @052cbd> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:217: (3 bytes: <@052cbf> - <@052cc2>): u64Neg: uint64 := uint64(-u64B)
	<.main+7264 @052cbf> : 11 02                      dup.x2 sp(2)
	<.main+7266 @052cc1> : 60                         neg.i64
	test/lang/useOperator.ci:218: (3 bytes: <@052cc2> - <@052cc5>): u64Cmt: uint64 := uint64(~u64B)
	<.main+7267 @052cc2> : 11 04                      dup.x2 sp(4)
	<.main+7269 @052cc4> : 40                         cmt.b64
	test/lang/useOperator.ci:219: (5 bytes: <@052cc5> - <@052cca>): u64Add: uint64 := uint64(u64A + u64B)
	<.main+7270 @052cc5> : 11 08                      dup.x2 sp(8)
	<.main+7272 @052cc7> : 11 08                      dup.x2 sp(8)
	<.main+7274 @052cc9> : 61                         add.i64
	test/lang/useOperator.ci:220: (5 bytes: <@052cca> - <@052ccf>): u64Sub: uint64 := uint64(u64A - u64B)
	<.main+7275 @052cca> : 11 0a                      dup.x2 sp(10)
	<.main+7277 @052ccc> : 11 0a                      dup.x2 sp(10)
	<.main+7279 @052cce> : 62                         sub.i64
	test/lang/useOperator.ci:221: (5 bytes: <@052ccf> - <@052cd4>): u64Mul: uint64 := uint64(u64A * u64B)
	<.main+7280 @052ccf> : 11 0c                      dup.x2 sp(12)
	<.main+7282 @052cd1> : 11 0c                      dup.x2 sp(12)
	<.main+7284 @052cd3> : 43                         mul.u64
	test/lang/useOperator.ci:222: (5 bytes: <@052cd4> - <@052cd9>): u64Div: uint64 := uint64(u64A / u64B)
	<.main+7285 @052cd4> : 11 0e                      dup.x2 sp(14)
	<.main+7287 @052cd6> : 11 0e                      dup.x2 sp(14)
	<.main+7289 @052cd8> : 44                         div.u64
	test/lang/useOperator.ci:223: (5 bytes: <@052cd9> - <@052cde>): u64Mod: uint64 := uint64(u64A % u64B)
	<.main+7290 @052cd9> : 11 10                      dup.x2 sp(16)
	<.main+7292 @052cdb> : 11 10                      dup.x2 sp(16)
	<.main+7294 @052cdd> : 45                         mod.u64
	test/lang/useOperator.ci:224: (5 bytes: <@052cde> - <@052ce3>): u64And: uint64 := uint64(u64A & u64B)
	<.main+7295 @052cde> : 11 12                      dup.x2 sp(18)
	<.main+7297 @052ce0> : 11 12                      dup.x2 sp(18)
	<.main+7299 @052ce2> : 41                         and.b64
	test/lang/useOperator.ci:225: (5 bytes: <@052ce3> - <@052ce8>): u64Ior: uint64 := uint64(u64A | u64B)
	<.main+7300 @052ce3> : 11 14                      dup.x2 sp(20)
	<.main+7302 @052ce5> : 11 14                      dup.x2 sp(20)
	<.main+7304 @052ce7> : 42                         or.b64
	test/lang/useOperator.ci:226: (5 bytes: <@052ce8> - <@052ced>): u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+7305 @052ce8> : 11 16                      dup.x2 sp(22)
	<.main+7307 @052cea> : 11 16                      dup.x2 sp(22)
	<.main+7309 @052cec> : 46                         xor.b64
	test/lang/useOperator.ci:227: (5 bytes: <@052ced> - <@052cf2>): u64Shl: uint64 := uint64(u64A << shift)
	<.main+7310 @052ced> : 11 18                      dup.x2 sp(24)
	<.main+7312 @052cef> : 10 e7                      dup.x1 sp(231)
	<.main+7314 @052cf1> : 4a                         shl.b64
	test/lang/useOperator.ci:228: (5 bytes: <@052cf2> - <@052cf7>): u64Shr: uint64 := uint64(u64A >> shift)
	<.main+7315 @052cf2> : 11 1a                      dup.x2 sp(26)
	<.main+7317 @052cf4> : 10 e9                      dup.x1 sp(233)
	<.main+7319 @052cf6> : 4b                         shr.b64
	test/lang/useOperator.ci:229: (4 bytes: <@052cf7> - <@052cfb>): u64Not: bool := bool(!(u64B))
	<.main+7320 @052cf7> : 11 1a                      dup.x2 sp(26)
	<.main+7322 @052cf9> : 6c                         i64.2bool
	<.main+7323 @052cfa> : 0b                         not.b32
	test/lang/useOperator.ci:230: (5 bytes: <@052cfb> - <@052d00>): u64Ceq: bool := bool(u64A == u64B)
	<.main+7324 @052cfb> : 11 1d                      dup.x2 sp(29)
	<.main+7326 @052cfd> : 11 1d                      dup.x2 sp(29)
	<.main+7328 @052cff> : 67                         ceq.i64
	test/lang/useOperator.ci:231: (6 bytes: <@052d00> - <@052d06>): u64Cne: bool := bool(u64A != u64B)
	<.main+7329 @052d00> : 11 1e                      dup.x2 sp(30)
	<.main+7331 @052d02> : 11 1e                      dup.x2 sp(30)
	<.main+7333 @052d04> : 67                         ceq.i64
	<.main+7334 @052d05> : 0b                         not.b32
	test/lang/useOperator.ci:232: (5 bytes: <@052d06> - <@052d0b>): u64Clt: bool := bool(u64A < u64B)
	<.main+7335 @052d06> : 11 1f                      dup.x2 sp(31)
	<.main+7337 @052d08> : 11 1f                      dup.x2 sp(31)
	<.main+7339 @052d0a> : 48                         clt.u64
	test/lang/useOperator.ci:233: (6 bytes: <@052d0b> - <@052d11>): u64Cle: bool := bool(u64A <= u64B)
	<.main+7340 @052d0b> : 11 20                      dup.x2 sp(32)
	<.main+7342 @052d0d> : 11 20                      dup.x2 sp(32)
	<.main+7344 @052d0f> : 49                         cgt.u64
	<.main+7345 @052d10> : 0b                         not.b32
	test/lang/useOperator.ci:234: (5 bytes: <@052d11> - <@052d16>): u64Cgt: bool := bool(u64A > u64B)
	<.main+7346 @052d11> : 11 21                      dup.x2 sp(33)
	<.main+7348 @052d13> : 11 21                      dup.x2 sp(33)
	<.main+7350 @052d15> : 49                         cgt.u64
	test/lang/useOperator.ci:235: (6 bytes: <@052d16> - <@052d1c>): u64Cge: bool := bool(u64A >= u64B)
	<.main+7351 @052d16> : 11 22                      dup.x2 sp(34)
	<.main+7353 @052d18> : 11 22                      dup.x2 sp(34)
	<.main+7355 @052d1a> : 48                         clt.u64
	<.main+7356 @052d1b> : 0b                         not.b32
	test/lang/useOperator.ci:237: (5 bytes: <@052d1c> - <@052d21>): f32A: float32 := a
	<.main+7357 @052d1c> : 7f 9a 99 c0 42             load.f32 96.300003
	test/lang/useOperator.ci:238: (5 bytes: <@052d21> - <@052d26>): f32B: float32 := b
	<.main+7362 @052d21> : 7f 5c 8f 28 42             load.f32 42.139999
	test/lang/useOperator.ci:239: (2 bytes: <@052d26> - <@052d28>): f32Pls: float32 := float32(+f32B)
	<.main+7367 @052d26> : 10 00                      dup.x1 sp(0)
	test/lang/useOperator.ci:240: (3 bytes: <@052d28> - <@052d2b>): f32Neg: float32 := float32(-f32B)
	<.main+7369 @052d28> : 10 01                      dup.x1 sp(1)
	<.main+7371 @052d2a> : 70                         neg.f32
	test/lang/useOperator.ci:242: (5 bytes: <@052d2b> - <@052d30>): f32Add: float32 := float32(f32A + f32B)
	<.main+7372 @052d2b> : 10 03                      dup.x1 sp(3)
	<.main+7374 @052d2d> : 10 03                      dup.x1 sp(3)
	<.main+7376 @052d2f> : 71                         add.f32
	test/lang/useOperator.ci:243: (5 bytes: <@052d30> - <@052d35>): f32Sub: float32 := float32(f32A - f32B)
	<.main+7377 @052d30> : 10 04                      dup.x1 sp(4)
	<.main+7379 @052d32> : 10 04                      dup.x1 sp(4)
	<.main+7381 @052d34> : 72                         sub.f32
	test/lang/useOperator.ci:244: (5 bytes: <@052d35> - <@052d3a>): f32Mul: float32 := float32(f32A * f32B)
	<.main+7382 @052d35> : 10 05                      dup.x1 sp(5)
	<.main+7384 @052d37> : 10 05                      dup.x1 sp(5)
	<.main+7386 @052d39> : 73                         mul.f32
	test/lang/useOperator.ci:245: (5 bytes: <@052d3a> - <@052d3f>): f32Div: float32 := float32(f32A / f32B)
	<.main+7387 @052d3a> : 10 06                      dup.x1 sp(6)
	<.main+7389 @052d3c> : 10 06                      dup.x1 sp(6)
	<.main+7391 @052d3e> : 74                         div.f32
	test/lang/useOperator.ci:246: (5 bytes: <@052d3f> - <@052d44>): f32Mod: float32 := float32(f32A % f32B)
	<.main+7392 @052d3f> : 10 07                      dup.x1 sp(7)
	<.main+7394 @052d41> : 10 07                      dup.x1 sp(7)
	<.main+7396 @052d43> : 75                         mod.f32
	test/lang/useOperator.ci:252: (4 bytes: <@052d44> - <@052d48>): f32Not: bool := bool(!(f32B))
	<.main+7397 @052d44> : 10 07                      dup.x1 sp(7)
	<.main+7399 @052d46> : 7b                         f32.2bool
	<.main+7400 @052d47> : 0b                         not.b32
	test/lang/useOperator.ci:253: (5 bytes: <@052d48> - <@052d4d>): f32Ceq: bool := bool(f32A == f32B)
	<.main+7401 @052d48> : 10 09                      dup.x1 sp(9)
	<.main+7403 @052d4a> : 10 09                      dup.x1 sp(9)
	<.main+7405 @052d4c> : 77                         ceq.f32
	test/lang/useOperator.ci:254: (6 bytes: <@052d4d> - <@052d53>): f32Cne: bool := bool(f32A != f32B)
	<.main+7406 @052d4d> : 10 0a                      dup.x1 sp(10)
	<.main+7408 @052d4f> : 10 0a                      dup.x1 sp(10)
	<.main+7410 @052d51> : 77                         ceq.f32
	<.main+7411 @052d52> : 0b                         not.b32
	test/lang/useOperator.ci:255: (5 bytes: <@052d53> - <@052d58>): f32Clt: bool := bool(f32A < f32B)
	<.main+7412 @052d53> : 10 0b                      dup.x1 sp(11)
	<.main+7414 @052d55> : 10 0b                      dup.x1 sp(11)
	<.main+7416 @052d57> : 78                         clt.f32
	test/lang/useOperator.ci:256: (6 bytes: <@052d58> - <@052d5e>): f32Cle: bool := bool(f32A <= f32B)
	<.main+7417 @052d58> : 10 0c                      dup.x1 sp(12)
	<.main+7419 @052d5a> : 10 0c                      dup.x1 sp(12)
	<.main+7421 @052d5c> : 79                         cgt.f32
	<.main+7422 @052d5d> : 0b                         not.b32
	test/lang/useOperator.ci:257: (5 bytes: <@052d5e> - <@052d63>): f32Cgt: bool := bool(f32A > f32B)
	<.main+7423 @052d5e> : 10 0d                      dup.x1 sp(13)
	<.main+7425 @052d60> : 10 0d                      dup.x1 sp(13)
	<.main+7427 @052d62> : 79                         cgt.f32
	test/lang/useOperator.ci:258: (6 bytes: <@052d63> - <@052d69>): f32Cge: bool := bool(f32A >= f32B)
	<.main+7428 @052d63> : 10 0e                      dup.x1 sp(14)
	<.main+7430 @052d65> : 10 0e                      dup.x1 sp(14)
	<.main+7432 @052d67> : 78                         clt.f32
	<.main+7433 @052d68> : 0b                         not.b32
	test/lang/useOperator.ci:260: (9 bytes: <@052d69> - <@052d72>): f64A: float64 := a
	<.main+7434 @052d69> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	test/lang/useOperator.ci:261: (9 bytes: <@052d72> - <@052d7b>): f64B: float64 := b
	<.main+7443 @052d72> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	test/lang/useOperator.ci:262: (2 bytes: <@052d7b> - <@052d7d>): f64Pls: float64 := float64(+f64B)
	<.main+7452 @052d7b> : 11 00                      dup.x2 sp(0)
	test/lang/useOperator.ci:263: (3 bytes: <@052d7d> - <@052d80>): f64Neg: float64 := float64(-f64B)
	<.main+7454 @052d7d> : 11 02                      dup.x2 sp(2)
	<.main+7456 @052d7f> : 80                         neg.f64
	test/lang/useOperator.ci:265: (5 bytes: <@052d80> - <@052d85>): f64Add: float64 := float64(f64A + f64B)
	<.main+7457 @052d80> : 11 06                      dup.x2 sp(6)
	<.main+7459 @052d82> : 11 06                      dup.x2 sp(6)
	<.main+7461 @052d84> : 81                         add.f64
	test/lang/useOperator.ci:266: (5 bytes: <@052d85> - <@052d8a>): f64Sub: float64 := float64(f64A - f64B)
	<.main+7462 @052d85> : 11 08                      dup.x2 sp(8)
	<.main+7464 @052d87> : 11 08                      dup.x2 sp(8)
	<.main+7466 @052d89> : 82                         sub.f64
	test/lang/useOperator.ci:267: (5 bytes: <@052d8a> - <@052d8f>): f64Mul: float64 := float64(f64A * f64B)
	<.main+7467 @052d8a> : 11 0a                      dup.x2 sp(10)
	<.main+7469 @052d8c> : 11 0a                      dup.x2 sp(10)
	<.main+7471 @052d8e> : 83                         mul.f64
	test/lang/useOperator.ci:268: (5 bytes: <@052d8f> - <@052d94>): f64Div: float64 := float64(f64A / f64B)
	<.main+7472 @052d8f> : 11 0c                      dup.x2 sp(12)
	<.main+7474 @052d91> : 11 0c                      dup.x2 sp(12)
	<.main+7476 @052d93> : 84                         div.f64
	test/lang/useOperator.ci:269: (5 bytes: <@052d94> - <@052d99>): f64Mod: float64 := float64(f64A % f64B)
	<.main+7477 @052d94> : 11 0e                      dup.x2 sp(14)
	<.main+7479 @052d96> : 11 0e                      dup.x2 sp(14)
	<.main+7481 @052d98> : 85                         mod.f64
	test/lang/useOperator.ci:275: (4 bytes: <@052d99> - <@052d9d>): f64Not: bool := bool(!(f64B))
	<.main+7482 @052d99> : 11 0e                      dup.x2 sp(14)
	<.main+7484 @052d9b> : 8d                         f64.2bool
	<.main+7485 @052d9c> : 0b                         not.b32
	test/lang/useOperator.ci:276: (5 bytes: <@052d9d> - <@052da2>): f64Ceq: bool := bool(f64A == f64B)
	<.main+7486 @052d9d> : 11 11                      dup.x2 sp(17)
	<.main+7488 @052d9f> : 11 11                      dup.x2 sp(17)
	<.main+7490 @052da1> : 87                         ceq.f64
	test/lang/useOperator.ci:277: (6 bytes: <@052da2> - <@052da8>): f64Cne: bool := bool(f64A != f64B)
	<.main+7491 @052da2> : 11 12                      dup.x2 sp(18)
	<.main+7493 @052da4> : 11 12                      dup.x2 sp(18)
	<.main+7495 @052da6> : 87                         ceq.f64
	<.main+7496 @052da7> : 0b                         not.b32
	test/lang/useOperator.ci:278: (5 bytes: <@052da8> - <@052dad>): f64Clt: bool := bool(f64A < f64B)
	<.main+7497 @052da8> : 11 13                      dup.x2 sp(19)
	<.main+7499 @052daa> : 11 13                      dup.x2 sp(19)
	<.main+7501 @052dac> : 88                         clt.f64
	test/lang/useOperator.ci:279: (6 bytes: <@052dad> - <@052db3>): f64Cle: bool := bool(f64A <= f64B)
	<.main+7502 @052dad> : 11 14                      dup.x2 sp(20)
	<.main+7504 @052daf> : 11 14                      dup.x2 sp(20)
	<.main+7506 @052db1> : 89                         cgt.f64
	<.main+7507 @052db2> : 0b                         not.b32
	test/lang/useOperator.ci:280: (5 bytes: <@052db3> - <@052db8>): f64Cgt: bool := bool(f64A > f64B)
	<.main+7508 @052db3> : 11 15                      dup.x2 sp(21)
	<.main+7510 @052db5> : 11 15                      dup.x2 sp(21)
	<.main+7512 @052db7> : 89                         cgt.f64
	test/lang/useOperator.ci:281: (6 bytes: <@052db8> - <@052dbe>): f64Cge: bool := bool(f64A >= f64B)
	<.main+7513 @052db8> : 11 16                      dup.x2 sp(22)
	<.main+7515 @052dba> : 11 16                      dup.x2 sp(22)
	<.main+7517 @052dbc> : 88                         clt.f64
	<.main+7518 @052dbd> : 0b                         not.b32
	test/lang/useOperator.ci:283: (5 bytes: <@052dbe> - <@052dc3>): ptrA: pointer := null
	<.main+7519 @052dbe> : 1f 00 00 00 00             load.ref <@000000> ;null
	test/lang/useOperator.ci:284: (4 bytes: <@052dc3> - <@052dc7>): ptrB: pointer := pointer(shift)
	<.main+7524 @052dc3> : 0a 68 04 00                load.sp(+1128)
	test/lang/useOperator.ci:299: (5 bytes: <@052dc7> - <@052dcc>): ptrCeq: bool := bool(ptrA == ptrB)
	<.main+7528 @052dc7> : 10 01                      dup.x1 sp(1)
	<.main+7530 @052dc9> : 10 01                      dup.x1 sp(1)
	<.main+7532 @052dcb> : 57                         ceq.i32
	test/lang/useOperator.ci:300: (6 bytes: <@052dcc> - <@052dd2>): ptrCne: bool := bool(ptrA != ptrB)
	<.main+7533 @052dcc> : 10 02                      dup.x1 sp(2)
	<.main+7535 @052dce> : 10 02                      dup.x1 sp(2)
	<.main+7537 @052dd0> : 57                         ceq.i32
	<.main+7538 @052dd1> : 0b                         not.b32
	test/lang/statementIf.ci:4: (39 bytes: <@052dd2> - <@052df9>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+7539 @052dd2> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7544 @052dd7> : 1c 04 00 00 00             load.c32 4
	<.main+7549 @052ddc> : 1c 0e 00 00 00             load.c32 14
	<.main+7554 @052de1> : 1c 01 00 00 00             load.c32 1
	<.main+7559 @052de6> : 1f b9 c4 04 00             load.ref <@04c4b9> ;"0 == 0"
	<.main+7564 @052deb> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7569 @052df0> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7574 @052df5> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@052df9> - <@052e20>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+7578 @052df9> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7583 @052dfe> : 1c 0c 00 00 00             load.c32 12
	<.main+7588 @052e03> : 1c 0e 00 00 00             load.c32 14
	<.main+7593 @052e08> : 1c 03 00 00 00             load.c32 3
	<.main+7598 @052e0d> : 1f b9 c4 04 00             load.ref <@04c4b9> ;"0 == 0"
	<.main+7603 @052e12> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7608 @052e17> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7613 @052e1c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@052e20> - <@052e47>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+7617 @052e20> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7622 @052e25> : 1c 16 00 00 00             load.c32 22
	<.main+7627 @052e2a> : 1c 0e 00 00 00             load.c32 14
	<.main+7632 @052e2f> : 1c 06 00 00 00             load.c32 6
	<.main+7637 @052e34> : 1f b9 c4 04 00             load.ref <@04c4b9> ;"0 == 0"
	<.main+7642 @052e39> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+7647 @052e3e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+7652 @052e43> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:26: (1 byte: <@052e47> - <@052e48>): t: int32 := 0
	<.main+7656 @052e47> : 19                         load.z32
	test/lang/statementIf.ci:28: (46 bytes: <@052e48> - <@052e76>): if (bool(t == 0))
	<.main+7657 @052e48> : 10 00                      dup.x1 sp(0)
	<.main+7659 @052e4a> : 19                         load.z32
	<.main+7660 @052e4b> : 57                         ceq.i32
	<.main+7661 @052e4c> : 06 2a 00 00                jz <.main+7703 @052e76>
	test/lang/statementIf.ci:29: (38 bytes: <@052e50> - <@052e76>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+7665 @052e50> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7670 @052e55> : 1c 1d 00 00 00             load.c32 29
	<.main+7675 @052e5a> : 1c 0e 00 00 00             load.c32 14
	<.main+7680 @052e5f> : 1c 07 00 00 00             load.c32 7
	<.main+7685 @052e64> : 1f c7 c4 04 00             load.ref <@04c4c7> ;"t == 0"
	<.main+7690 @052e69> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7695 @052e6e> : 0a 18 00 00                load.sp(+24)
	<.main+7699 @052e72> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (46 bytes: <@052e76> - <@052ea4>): if (bool(t != 0))
	<.main+7703 @052e76> : 10 00                      dup.x1 sp(0)
	<.main+7705 @052e78> : 19                         load.z32
	<.main+7706 @052e79> : 57                         ceq.i32
	<.main+7707 @052e7a> : 05 2a 00 00                jnz <.main+7749 @052ea4>
	test/lang/statementIf.ci:33: (38 bytes: <@052e7e> - <@052ea4>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+7711 @052e7e> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7716 @052e83> : 1c 21 00 00 00             load.c32 33
	<.main+7721 @052e88> : 1c 0e 00 00 00             load.c32 14
	<.main+7726 @052e8d> : 1c 08 00 00 00             load.c32 8
	<.main+7731 @052e92> : 1f ce c4 04 00             load.ref <@04c4ce> ;"t != 0"
	<.main+7736 @052e97> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7741 @052e9c> : 0a 18 00 00                load.sp(+24)
	<.main+7745 @052ea0> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (88 bytes: <@052ea4> - <@052efc>): if (bool(t == 0))
	<.main+7749 @052ea4> : 10 00                      dup.x1 sp(0)
	<.main+7751 @052ea6> : 19                         load.z32
	<.main+7752 @052ea7> : 57                         ceq.i32
	<.main+7753 @052ea8> : 06 2e 00 00                jz <.main+7799 @052ed6>
	test/lang/statementIf.ci:37: (38 bytes: <@052eac> - <@052ed2>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7757 @052eac> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7762 @052eb1> : 1c 25 00 00 00             load.c32 37
	<.main+7767 @052eb6> : 1c 0e 00 00 00             load.c32 14
	<.main+7772 @052ebb> : 1c 09 00 00 00             load.c32 9
	<.main+7777 @052ec0> : 1f c7 c4 04 00             load.ref <@04c4c7> ;"t == 0"
	<.main+7782 @052ec5> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7787 @052eca> : 0a 18 00 00                load.sp(+24)
	<.main+7791 @052ece> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7795 @052ed2> : 04 2a 00 00                jmp <.main+7837 @052efc>
	test/lang/statementIf.ci:40: (38 bytes: <@052ed6> - <@052efc>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+7799 @052ed6> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7804 @052edb> : 1c 28 00 00 00             load.c32 40
	<.main+7809 @052ee0> : 1c 0e 00 00 00             load.c32 14
	<.main+7814 @052ee5> : 1c 0a 00 00 00             load.c32 10
	<.main+7819 @052eea> : 1f ce c4 04 00             load.ref <@04c4ce> ;"t != 0"
	<.main+7824 @052eef> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7829 @052ef4> : 0a 18 00 00                load.sp(+24)
	<.main+7833 @052ef8> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (88 bytes: <@052efc> - <@052f54>): if (bool(t != 0))
	<.main+7837 @052efc> : 10 00                      dup.x1 sp(0)
	<.main+7839 @052efe> : 19                         load.z32
	<.main+7840 @052eff> : 57                         ceq.i32
	<.main+7841 @052f00> : 05 2e 00 00                jnz <.main+7887 @052f2e>
	test/lang/statementIf.ci:44: (38 bytes: <@052f04> - <@052f2a>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+7845 @052f04> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7850 @052f09> : 1c 2c 00 00 00             load.c32 44
	<.main+7855 @052f0e> : 1c 0e 00 00 00             load.c32 14
	<.main+7860 @052f13> : 1c 0b 00 00 00             load.c32 11
	<.main+7865 @052f18> : 1f ce c4 04 00             load.ref <@04c4ce> ;"t != 0"
	<.main+7870 @052f1d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7875 @052f22> : 0a 18 00 00                load.sp(+24)
	<.main+7879 @052f26> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7883 @052f2a> : 04 2a 00 00                jmp <.main+7925 @052f54>
	test/lang/statementIf.ci:47: (38 bytes: <@052f2e> - <@052f54>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+7887 @052f2e> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7892 @052f33> : 1c 2f 00 00 00             load.c32 47
	<.main+7897 @052f38> : 1c 0e 00 00 00             load.c32 14
	<.main+7902 @052f3d> : 1c 0c 00 00 00             load.c32 12
	<.main+7907 @052f42> : 1f c7 c4 04 00             load.ref <@04c4c7> ;"t == 0"
	<.main+7912 @052f47> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7917 @052f4c> : 0a 18 00 00                load.sp(+24)
	<.main+7921 @052f50> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (358 bytes: <@052f54> - <@0530ba>): if (bool(t == 0))
	<.main+7925 @052f54> : 10 00                      dup.x1 sp(0)
	<.main+7927 @052f56> : 19                         load.z32
	<.main+7928 @052f57> : 57                         ceq.i32
	<.main+7929 @052f58> : 06 2e 00 00                jz <.main+7975 @052f86>
	test/lang/statementIf.ci:51: (38 bytes: <@052f5c> - <@052f82>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+7933 @052f5c> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7938 @052f61> : 1c 33 00 00 00             load.c32 51
	<.main+7943 @052f66> : 1c 0e 00 00 00             load.c32 14
	<.main+7948 @052f6b> : 1c 09 00 00 00             load.c32 9
	<.main+7953 @052f70> : 1f c7 c4 04 00             load.ref <@04c4c7> ;"t == 0"
	<.main+7958 @052f75> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+7963 @052f7a> : 0a 18 00 00                load.sp(+24)
	<.main+7967 @052f7e> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+7971 @052f82> : 04 38 01 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:53: (308 bytes: <@052f86> - <@0530ba>): if (bool(t == 1))
	<.main+7975 @052f86> : 10 00                      dup.x1 sp(0)
	<.main+7977 @052f88> : 1c 01 00 00 00             load.c32 1
	<.main+7982 @052f8d> : 57                         ceq.i32
	<.main+7983 @052f8e> : 06 2e 00 00                jz <.main+8029 @052fbc>
	test/lang/statementIf.ci:54: (38 bytes: <@052f92> - <@052fb8>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+7987 @052f92> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+7992 @052f97> : 1c 36 00 00 00             load.c32 54
	<.main+7997 @052f9c> : 1c 0e 00 00 00             load.c32 14
	<.main+8002 @052fa1> : 1c 0a 00 00 00             load.c32 10
	<.main+8007 @052fa6> : 1f d5 c4 04 00             load.ref <@04c4d5> ;"t == 1"
	<.main+8012 @052fab> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8017 @052fb0> : 0a 18 00 00                load.sp(+24)
	<.main+8021 @052fb4> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8025 @052fb8> : 04 02 01 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:56: (254 bytes: <@052fbc> - <@0530ba>): if (bool(t == 2))
	<.main+8029 @052fbc> : 10 00                      dup.x1 sp(0)
	<.main+8031 @052fbe> : 1c 02 00 00 00             load.c32 2
	<.main+8036 @052fc3> : 57                         ceq.i32
	<.main+8037 @052fc4> : 06 2e 00 00                jz <.main+8083 @052ff2>
	test/lang/statementIf.ci:57: (38 bytes: <@052fc8> - <@052fee>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+8041 @052fc8> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+8046 @052fcd> : 1c 39 00 00 00             load.c32 57
	<.main+8051 @052fd2> : 1c 0e 00 00 00             load.c32 14
	<.main+8056 @052fd7> : 1c 0a 00 00 00             load.c32 10
	<.main+8061 @052fdc> : 1f dc c4 04 00             load.ref <@04c4dc> ;"t == 2"
	<.main+8066 @052fe1> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8071 @052fe6> : 0a 18 00 00                load.sp(+24)
	<.main+8075 @052fea> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8079 @052fee> : 04 cc 00 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:59: (200 bytes: <@052ff2> - <@0530ba>): if (bool(t == 3))
	<.main+8083 @052ff2> : 10 00                      dup.x1 sp(0)
	<.main+8085 @052ff4> : 1c 03 00 00 00             load.c32 3
	<.main+8090 @052ff9> : 57                         ceq.i32
	<.main+8091 @052ffa> : 06 2e 00 00                jz <.main+8137 @053028>
	test/lang/statementIf.ci:60: (38 bytes: <@052ffe> - <@053024>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+8095 @052ffe> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+8100 @053003> : 1c 3c 00 00 00             load.c32 60
	<.main+8105 @053008> : 1c 0e 00 00 00             load.c32 14
	<.main+8110 @05300d> : 1c 0a 00 00 00             load.c32 10
	<.main+8115 @053012> : 1f e3 c4 04 00             load.ref <@04c4e3> ;"t == 3"
	<.main+8120 @053017> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8125 @05301c> : 0a 18 00 00                load.sp(+24)
	<.main+8129 @053020> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8133 @053024> : 04 96 00 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:62: (146 bytes: <@053028> - <@0530ba>): if (bool(t == 4))
	<.main+8137 @053028> : 10 00                      dup.x1 sp(0)
	<.main+8139 @05302a> : 1c 04 00 00 00             load.c32 4
	<.main+8144 @05302f> : 57                         ceq.i32
	<.main+8145 @053030> : 06 2e 00 00                jz <.main+8191 @05305e>
	test/lang/statementIf.ci:63: (38 bytes: <@053034> - <@05305a>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+8149 @053034> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+8154 @053039> : 1c 3f 00 00 00             load.c32 63
	<.main+8159 @05303e> : 1c 0e 00 00 00             load.c32 14
	<.main+8164 @053043> : 1c 0a 00 00 00             load.c32 10
	<.main+8169 @053048> : 1f ea c4 04 00             load.ref <@04c4ea> ;"t == 4"
	<.main+8174 @05304d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8179 @053052> : 0a 18 00 00                load.sp(+24)
	<.main+8183 @053056> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8187 @05305a> : 04 60 00 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:65: (92 bytes: <@05305e> - <@0530ba>): if (bool(t == 5))
	<.main+8191 @05305e> : 10 00                      dup.x1 sp(0)
	<.main+8193 @053060> : 1c 05 00 00 00             load.c32 5
	<.main+8198 @053065> : 57                         ceq.i32
	<.main+8199 @053066> : 06 2e 00 00                jz <.main+8245 @053094>
	test/lang/statementIf.ci:66: (38 bytes: <@05306a> - <@053090>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+8203 @05306a> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+8208 @05306f> : 1c 42 00 00 00             load.c32 66
	<.main+8213 @053074> : 1c 0e 00 00 00             load.c32 14
	<.main+8218 @053079> : 1c 0a 00 00 00             load.c32 10
	<.main+8223 @05307e> : 1f f1 c4 04 00             load.ref <@04c4f1> ;"t == 5"
	<.main+8228 @053083> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8233 @053088> : 0a 18 00 00                load.sp(+24)
	<.main+8237 @05308c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+8241 @053090> : 04 2a 00 00                jmp <.main+8283 @0530ba>
	test/lang/statementIf.ci:69: (38 bytes: <@053094> - <@0530ba>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+8245 @053094> : 1f a0 c4 04 00             load.ref <@04c4a0> ;"test/lang/statementIf.ci"
	<.main+8250 @053099> : 1c 45 00 00 00             load.c32 69
	<.main+8255 @05309e> : 1c 0e 00 00 00             load.c32 14
	<.main+8260 @0530a3> : 1c 0a 00 00 00             load.c32 10
	<.main+8265 @0530a8> : 1f f8 c4 04 00             load.ref <@04c4f8> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+8270 @0530ad> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8275 @0530b2> : 0a 18 00 00                load.sp(+24)
	<.main+8279 @0530b6> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@0530ba> - <@0530e9>): for ( ; ; )
	<.main+8283 @0530ba> : 04 2b 00 00                jmp <.main+8326 @0530e5>
	test/lang/statementFor.ci:4: (35 bytes: <@0530be> - <@0530e1>): debug("for ( ; ; )");
	<.main+8287 @0530be> : 1f e0 c5 04 00             load.ref <@04c5e0> ;"test/lang/statementFor.ci"
	<.main+8292 @0530c3> : 1c 04 00 00 00             load.c32 4
	<.main+8297 @0530c8> : 1c 0e 00 00 00             load.c32 14
	<.main+8302 @0530cd> : 19                         load.z32
	<.main+8303 @0530ce> : 1f fa c5 04 00             load.ref <@04c5fa> ;"for ( ; ; )"
	<.main+8308 @0530d3> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+8313 @0530d8> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8318 @0530dd> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@0530e1> - <@0530e5>): break;
	<.main+8322 @0530e1> : 04 08 00 00                jmp <.main+8330 @0530e9>
	:: (4 bytes: <@0530e5> - <@0530e9>)
	<.main+8326 @0530e5> : 04 d9 ff ff                jmp <.main+8287 @0530be>
	test/lang/statementFor.ci:8: (59 bytes: <@0530e9> - <@053124>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+8330 @0530e9> : 19                         load.z32
	<.main+8331 @0530ea> : 04 2a 00 00                jmp <.main+8373 @053114>
	test/lang/statementFor.ci:9: (34 bytes: <@0530ee> - <@053110>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+8335 @0530ee> : 1f e0 c5 04 00             load.ref <@04c5e0> ;"test/lang/statementFor.ci"
	<.main+8340 @0530f3> : 1c 09 00 00 00             load.c32 9
	<.main+8345 @0530f8> : 1c 0e 00 00 00             load.c32 14
	<.main+8350 @0530fd> : 19                         load.z32
	<.main+8351 @0530fe> : 1f 06 c6 04 00             load.ref <@04c606> ;"for (int i = 0; i < 2; i += 1)"
	<.main+8356 @053103> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8361 @053108> : 0a 18 00 00                load.sp(+24)
	<.main+8365 @05310c> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@053110> - <@053114>): int32(i := int32(i + 1))
	<.main+8369 @053110> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@053114> - <@053120>): bool(i < 2)
	<.main+8373 @053114> : 10 00                      dup.x1 sp(0)
	<.main+8375 @053116> : 1c 02 00 00 00             load.c32 2
	<.main+8380 @05311b> : 58                         clt.i32
	<.main+8381 @05311c> : 05 d2 ff ff                jnz <.main+8335 @0530ee>
	<.main+8385 @053120> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:12: (1 byte: <@053124> - <@053125>): forIdx: int32
	<.main+8389 @053124> : 19                         load.z32
	test/lang/statementFor.ci:13: (57 bytes: <@053125> - <@05315e>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+8390 @053125> : 19                         load.z32
	<.main+8391 @053126> : 13 01                      set.x1 sp(1)
	<.main+8393 @053128> : 04 2a 00 00                jmp <.main+8435 @053152>
	test/lang/statementFor.ci:14: (34 bytes: <@05312c> - <@05314e>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+8397 @05312c> : 1f e0 c5 04 00             load.ref <@04c5e0> ;"test/lang/statementFor.ci"
	<.main+8402 @053131> : 1c 0e 00 00 00             load.c32 14
	<.main+8407 @053136> : 1c 0e 00 00 00             load.c32 14
	<.main+8412 @05313b> : 19                         load.z32
	<.main+8413 @05313c> : 1f 2c c6 04 00             load.ref <@04c62c> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+8418 @053141> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8423 @053146> : 0a 18 00 00                load.sp(+24)
	<.main+8427 @05314a> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (4 bytes: <@05314e> - <@053152>): int32(forIdx := int32(forIdx + 1))
	<.main+8431 @05314e> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:13: (12 bytes: <@053152> - <@05315e>): bool(forIdx < 2)
	<.main+8435 @053152> : 10 00                      dup.x1 sp(0)
	<.main+8437 @053154> : 1c 02 00 00 00             load.c32 2
	<.main+8442 @053159> : 58                         clt.i32
	<.main+8443 @05315a> : 05 d2 ff ff                jnz <.main+8397 @05312c>
	test/lang/statementFor.ci:17: (75 bytes: <@05315e> - <@0531a9>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8447 @05315e> : 19                         load.z32
	<.main+8448 @05315f> : 04 3a 00 00                jmp <.main+8506 @053199>
	test/lang/statementFor.ci:18: (16 bytes: <@053163> - <@053173>): if (bool(i < 2))
	<.main+8452 @053163> : 10 00                      dup.x1 sp(0)
	<.main+8454 @053165> : 1c 02 00 00 00             load.c32 2
	<.main+8459 @05316a> : 58                         clt.i32
	<.main+8460 @05316b> : 06 08 00 00                jz <.main+8468 @053173>
	test/lang/statementFor.ci:19: (4 bytes: <@05316f> - <@053173>): continue;
	<.main+8464 @05316f> : 04 26 00 00                jmp <.main+8502 @053195>
	test/lang/statementFor.ci:21: (34 bytes: <@053173> - <@053195>): debug(void("for with continue", i));
	<.main+8468 @053173> : 1f e0 c5 04 00             load.ref <@04c5e0> ;"test/lang/statementFor.ci"
	<.main+8473 @053178> : 1c 15 00 00 00             load.c32 21
	<.main+8478 @05317d> : 1c 0e 00 00 00             load.c32 14
	<.main+8483 @053182> : 19                         load.z32
	<.main+8484 @053183> : 1f 56 c6 04 00             load.ref <@04c656> ;"for with continue"
	<.main+8489 @053188> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8494 @05318d> : 0a 18 00 00                load.sp(+24)
	<.main+8498 @053191> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@053195> - <@053199>): int32(i := int32(i + 1))
	<.main+8502 @053195> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@053199> - <@0531a5>): bool(i < 7)
	<.main+8506 @053199> : 10 00                      dup.x1 sp(0)
	<.main+8508 @05319b> : 1c 07 00 00 00             load.c32 7
	<.main+8513 @0531a0> : 58                         clt.i32
	<.main+8514 @0531a1> : 05 c2 ff ff                jnz <.main+8452 @053163>
	<.main+8518 @0531a5> : 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@0531a9> - <@0531f4>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+8522 @0531a9> : 19                         load.z32
	<.main+8523 @0531aa> : 04 3a 00 00                jmp <.main+8581 @0531e4>
	test/lang/statementFor.ci:25: (16 bytes: <@0531ae> - <@0531be>): if (bool(i > 2))
	<.main+8527 @0531ae> : 10 00                      dup.x1 sp(0)
	<.main+8529 @0531b0> : 1c 02 00 00 00             load.c32 2
	<.main+8534 @0531b5> : 59                         cgt.i32
	<.main+8535 @0531b6> : 06 08 00 00                jz <.main+8543 @0531be>
	test/lang/statementFor.ci:26: (4 bytes: <@0531ba> - <@0531be>): break;
	<.main+8539 @0531ba> : 04 36 00 00                jmp <.main+8593 @0531f0>
	test/lang/statementFor.ci:28: (34 bytes: <@0531be> - <@0531e0>): debug(void("for with break", i));
	<.main+8543 @0531be> : 1f e0 c5 04 00             load.ref <@04c5e0> ;"test/lang/statementFor.ci"
	<.main+8548 @0531c3> : 1c 1c 00 00 00             load.c32 28
	<.main+8553 @0531c8> : 1c 0e 00 00 00             load.c32 14
	<.main+8558 @0531cd> : 19                         load.z32
	<.main+8559 @0531ce> : 1f 68 c6 04 00             load.ref <@04c668> ;"for with break"
	<.main+8564 @0531d3> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+8569 @0531d8> : 0a 18 00 00                load.sp(+24)
	<.main+8573 @0531dc> : 01 05 00 00                nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@0531e0> - <@0531e4>): int32(i := int32(i + 1))
	<.main+8577 @0531e0> : 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@0531e4> - <@0531f0>): bool(i < 7)
	<.main+8581 @0531e4> : 10 00                      dup.x1 sp(0)
	<.main+8583 @0531e6> : 1c 07 00 00 00             load.c32 7
	<.main+8588 @0531eb> : 58                         clt.i32
	<.main+8589 @0531ec> : 05 c2 ff ff                jnz <.main+8527 @0531ae>
	<.main+8593 @0531f0> : 09 fc ff ff                inc.sp(-4)
	test/stdc/test.math.ci:3: (20 bytes: <@0531f4> - <@053208>): testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+8597 @0531f4> : 1a                         load.z64
	<.main+8598 @0531f5> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+8607 @0531fe> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8612 @053203> : 02                         call
	<.main+8613 @053204> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:4: (20 bytes: <@053208> - <@05321c>): testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+8617 @053208> : 1a                         load.z64
	<.main+8618 @053209> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+8627 @053212> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8632 @053217> : 02                         call
	<.main+8633 @053218> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:5: (20 bytes: <@05321c> - <@053230>): testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+8637 @05321c> : 1a                         load.z64
	<.main+8638 @05321d> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+8647 @053226> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8652 @05322b> : 02                         call
	<.main+8653 @05322c> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:6: (20 bytes: <@053230> - <@053244>): testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+8657 @053230> : 1a                         load.z64
	<.main+8658 @053231> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+8667 @05323a> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8672 @05323f> : 02                         call
	<.main+8673 @053240> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:7: (20 bytes: <@053244> - <@053258>): testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+8677 @053244> : 1a                         load.z64
	<.main+8678 @053245> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+8687 @05324e> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8692 @053253> : 02                         call
	<.main+8693 @053254> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:8: (20 bytes: <@053258> - <@05326c>): testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+8697 @053258> : 1a                         load.z64
	<.main+8698 @053259> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+8707 @053262> : 1f c8 fd 04 00             load.ref <@04fdc8> ;Math.floor(x: float64): float64
	<.main+8712 @053267> : 02                         call
	<.main+8713 @053268> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:10: (25 bytes: <@05326c> - <@053285>): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+8717 @05326c> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8726 @053275> : 11 00                      dup.x2 sp(0)
	<.main+8728 @053277> : 1a                         load.z64
	<.main+8729 @053278> : 89                         cgt.f64
	<.main+8730 @053279> : 11 01                      dup.x2 sp(1)
	<.main+8732 @05327b> : 1a                         load.z64
	<.main+8733 @05327c> : 88                         clt.f64
	<.main+8734 @05327d> : 52                         sub.i32
	<.main+8735 @05327e> : 13 02                      set.x1 sp(2)
	<.main+8737 @053280> : 09 fc ff ff                inc.sp(-4)
	<.main+8741 @053284> : 5d                         i32.2f64
	test/stdc/test.math.ci:11: (17 bytes: <@053285> - <@053296>): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+8742 @053285> : 1a                         load.z64
	<.main+8743 @053286> : 11 00                      dup.x2 sp(0)
	<.main+8745 @053288> : 1a                         load.z64
	<.main+8746 @053289> : 89                         cgt.f64
	<.main+8747 @05328a> : 11 01                      dup.x2 sp(1)
	<.main+8749 @05328c> : 1a                         load.z64
	<.main+8750 @05328d> : 88                         clt.f64
	<.main+8751 @05328e> : 52                         sub.i32
	<.main+8752 @05328f> : 13 02                      set.x1 sp(2)
	<.main+8754 @053291> : 09 fc ff ff                inc.sp(-4)
	<.main+8758 @053295> : 5d                         i32.2f64
	test/stdc/test.math.ci:12: (25 bytes: <@053296> - <@0532af>): testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+8759 @053296> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8768 @05329f> : 11 00                      dup.x2 sp(0)
	<.main+8770 @0532a1> : 1a                         load.z64
	<.main+8771 @0532a2> : 89                         cgt.f64
	<.main+8772 @0532a3> : 11 01                      dup.x2 sp(1)
	<.main+8774 @0532a5> : 1a                         load.z64
	<.main+8775 @0532a6> : 88                         clt.f64
	<.main+8776 @0532a7> : 52                         sub.i32
	<.main+8777 @0532a8> : 13 02                      set.x1 sp(2)
	<.main+8779 @0532aa> : 09 fc ff ff                inc.sp(-4)
	<.main+8783 @0532ae> : 5d                         i32.2f64
	test/stdc/test.math.ci:13: (17 bytes: <@0532af> - <@0532c0>): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+8784 @0532af> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8789 @0532b4> : 10 00                      dup.x1 sp(0)
	<.main+8791 @0532b6> : 19                         load.z32
	<.main+8792 @0532b7> : 79                         cgt.f32
	<.main+8793 @0532b8> : 10 01                      dup.x1 sp(1)
	<.main+8795 @0532ba> : 19                         load.z32
	<.main+8796 @0532bb> : 78                         clt.f32
	<.main+8797 @0532bc> : 52                         sub.i32
	<.main+8798 @0532bd> : 13 01                      set.x1 sp(1)
	<.main+8800 @0532bf> : 5d                         i32.2f64
	test/stdc/test.math.ci:14: (13 bytes: <@0532c0> - <@0532cd>): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+8801 @0532c0> : 19                         load.z32
	<.main+8802 @0532c1> : 10 00                      dup.x1 sp(0)
	<.main+8804 @0532c3> : 19                         load.z32
	<.main+8805 @0532c4> : 79                         cgt.f32
	<.main+8806 @0532c5> : 10 01                      dup.x1 sp(1)
	<.main+8808 @0532c7> : 19                         load.z32
	<.main+8809 @0532c8> : 78                         clt.f32
	<.main+8810 @0532c9> : 52                         sub.i32
	<.main+8811 @0532ca> : 13 01                      set.x1 sp(1)
	<.main+8813 @0532cc> : 5d                         i32.2f64
	test/stdc/test.math.ci:15: (17 bytes: <@0532cd> - <@0532de>): testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+8814 @0532cd> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8819 @0532d2> : 10 00                      dup.x1 sp(0)
	<.main+8821 @0532d4> : 19                         load.z32
	<.main+8822 @0532d5> : 79                         cgt.f32
	<.main+8823 @0532d6> : 10 01                      dup.x1 sp(1)
	<.main+8825 @0532d8> : 19                         load.z32
	<.main+8826 @0532d9> : 78                         clt.f32
	<.main+8827 @0532da> : 52                         sub.i32
	<.main+8828 @0532db> : 13 01                      set.x1 sp(1)
	<.main+8830 @0532dd> : 5d                         i32.2f64
	test/stdc/test.math.ci:17: (20 bytes: <@0532de> - <@0532f2>): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+8831 @0532de> : 1a                         load.z64
	<.main+8832 @0532df> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+8841 @0532e8> : 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<.main+8846 @0532ed> : 02                         call
	<.main+8847 @0532ee> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:18: (11 bytes: <@0532f2> - <@0532fd>): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+8851 @0532f2> : 1b                         load.z128
	<.main+8852 @0532f3> : 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<.main+8857 @0532f8> : 02                         call
	<.main+8858 @0532f9> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:19: (20 bytes: <@0532fd> - <@053311>): testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+8862 @0532fd> : 1a                         load.z64
	<.main+8863 @0532fe> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+8872 @053307> : 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<.main+8877 @05330c> : 02                         call
	<.main+8878 @05330d> : 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:20: (17 bytes: <@053311> - <@053322>): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+8882 @053311> : 19                         load.z32
	<.main+8883 @053312> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+8888 @053317> : 1f e0 fd 04 00             load.ref <@04fde0> ;Math.abs(x: float32): float32
	<.main+8893 @05331c> : 02                         call
	<.main+8894 @05331d> : 09 fc ff ff                inc.sp(-4)
	<.main+8898 @053321> : 7d                         f32.2f64
	test/stdc/test.math.ci:21: (13 bytes: <@053322> - <@05332f>): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+8899 @053322> : 19                         load.z32
	<.main+8900 @053323> : 19                         load.z32
	<.main+8901 @053324> : 1f e0 fd 04 00             load.ref <@04fde0> ;Math.abs(x: float32): float32
	<.main+8906 @053329> : 02                         call
	<.main+8907 @05332a> : 09 fc ff ff                inc.sp(-4)
	<.main+8911 @05332e> : 7d                         f32.2f64
	test/stdc/test.math.ci:22: (17 bytes: <@05332f> - <@053340>): testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+8912 @05332f> : 19                         load.z32
	<.main+8913 @053330> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+8918 @053335> : 1f e0 fd 04 00             load.ref <@04fde0> ;Math.abs(x: float32): float32
	<.main+8923 @05333a> : 02                         call
	<.main+8924 @05333b> : 09 fc ff ff                inc.sp(-4)
	<.main+8928 @05333f> : 7d                         f32.2f64
	test/stdc/test.math.ci:24: (22 bytes: <@053340> - <@053356>): testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8929 @053340> : 19                         load.z32
	<.main+8930 @053341> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8935 @053346> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8940 @05334b> : 1f 50 fe 04 00             load.ref <@04fe50> ;Math.min(a: float32, b: float32): float32
	<.main+8945 @053350> : 02                         call
	<.main+8946 @053351> : 09 f8 ff ff                inc.sp(-8)
	<.main+8950 @053355> : 7d                         f32.2f64
	test/stdc/test.math.ci:25: (22 bytes: <@053356> - <@05336c>): testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+8951 @053356> : 19                         load.z32
	<.main+8952 @053357> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+8957 @05335c> : 7f 00 00 00 40             load.f32 2.000000
	<.main+8962 @053361> : 1f 80 fe 04 00             load.ref <@04fe80> ;Math.max(a: float32, b: float32): float32
	<.main+8967 @053366> : 02                         call
	<.main+8968 @053367> : 09 f8 ff ff                inc.sp(-8)
	<.main+8972 @05336b> : 7d                         f32.2f64
	test/stdc/test.math.ci:26: (29 bytes: <@05336c> - <@053389>): testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+8973 @05336c> : 1a                         load.z64
	<.main+8974 @05336d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+8983 @053376> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+8992 @05337f> : 1f 68 fe 04 00             load.ref <@04fe68> ;Math.min(a: float64, b: float64): float64
	<.main+8997 @053384> : 02                         call
	<.main+8998 @053385> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:27: (29 bytes: <@053389> - <@0533a6>): testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9002 @053389> : 1a                         load.z64
	<.main+9003 @05338a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9012 @053393> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9021 @05339c> : 1f 98 fe 04 00             load.ref <@04fe98> ;Math.max(a: float64, b: float64): float64
	<.main+9026 @0533a1> : 02                         call
	<.main+9027 @0533a2> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:29: (23 bytes: <@0533a6> - <@0533bd>): testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9031 @0533a6> : 19                         load.z32
	<.main+9032 @0533a7> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9037 @0533ac> : 19                         load.z32
	<.main+9038 @0533ad> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9043 @0533b2> : 1f b0 fe 04 00             load.ref <@04feb0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9048 @0533b7> : 02                         call
	<.main+9049 @0533b8> : 09 f4 ff ff                inc.sp(-12)
	<.main+9053 @0533bc> : 7d                         f32.2f64
	test/stdc/test.math.ci:30: (30 bytes: <@0533bd> - <@0533db>): testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9054 @0533bd> : 1a                         load.z64
	<.main+9055 @0533be> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9064 @0533c7> : 1a                         load.z64
	<.main+9065 @0533c8> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9074 @0533d1> : 1f d0 fe 04 00             load.ref <@04fed0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9079 @0533d6> : 02                         call
	<.main+9080 @0533d7> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:32: (21 bytes: <@0533db> - <@0533f0>): testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9084 @0533db> : 19                         load.z32
	<.main+9085 @0533dc> : 10 00                      dup.x1 sp(0)
	<.main+9087 @0533de> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9092 @0533e3> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9097 @0533e8> : 10 03                      dup.x1 sp(3)
	<.main+9099 @0533ea> : 72                         sub.f32
	<.main+9100 @0533eb> : 73                         mul.f32
	<.main+9101 @0533ec> : 71                         add.f32
	<.main+9102 @0533ed> : 13 01                      set.x1 sp(1)
	<.main+9104 @0533ef> : 7d                         f32.2f64
	test/stdc/test.math.ci:33: (28 bytes: <@0533f0> - <@05340c>): testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9105 @0533f0> : 1a                         load.z64
	<.main+9106 @0533f1> : 11 00                      dup.x2 sp(0)
	<.main+9108 @0533f3> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9117 @0533fc> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9126 @053405> : 11 06                      dup.x2 sp(6)
	<.main+9128 @053407> : 82                         sub.f64
	<.main+9129 @053408> : 83                         mul.f64
	<.main+9130 @053409> : 81                         add.f64
	<.main+9131 @05340a> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:35: (60 bytes: <@05340c> - <@053448>): testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9133 @05340c> : 19                         load.z32
	<.main+9134 @05340d> : 19                         load.z32
	<.main+9135 @05340e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9140 @053413> : 10 02                      dup.x1 sp(2)
	<.main+9142 @053415> : 72                         sub.f32
	<.main+9143 @053416> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9148 @05341b> : 10 03                      dup.x1 sp(3)
	<.main+9150 @05341d> : 72                         sub.f32
	<.main+9151 @05341e> : 74                         div.f32
	<.main+9152 @05341f> : 19                         load.z32
	<.main+9153 @053420> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9158 @053425> : 1f b0 fe 04 00             load.ref <@04feb0> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9163 @05342a> : 02                         call
	<.main+9164 @05342b> : 09 f4 ff ff                inc.sp(-12)
	<.main+9168 @05342f> : 10 00                      dup.x1 sp(0)
	<.main+9170 @053431> : 10 01                      dup.x1 sp(1)
	<.main+9172 @053433> : 73                         mul.f32
	<.main+9173 @053434> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9178 @053439> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9183 @05343e> : 10 03                      dup.x1 sp(3)
	<.main+9185 @053440> : 73                         mul.f32
	<.main+9186 @053441> : 72                         sub.f32
	<.main+9187 @053442> : 73                         mul.f32
	<.main+9188 @053443> : 13 01                      set.x1 sp(1)
	<.main+9190 @053445> : 13 01                      set.x1 sp(1)
	<.main+9192 @053447> : 7d                         f32.2f64
	test/stdc/test.math.ci:36: (78 bytes: <@053448> - <@053496>): testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9193 @053448> : 1b                         load.z128
	<.main+9194 @053449> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9203 @053452> : 11 04                      dup.x2 sp(4)
	<.main+9205 @053454> : 82                         sub.f64
	<.main+9206 @053455> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9215 @05345e> : 11 06                      dup.x2 sp(6)
	<.main+9217 @053460> : 82                         sub.f64
	<.main+9218 @053461> : 84                         div.f64
	<.main+9219 @053462> : 1a                         load.z64
	<.main+9220 @053463> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9229 @05346c> : 1f d0 fe 04 00             load.ref <@04fed0> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9234 @053471> : 02                         call
	<.main+9235 @053472> : 09 e8 ff ff                inc.sp(-24)
	<.main+9239 @053476> : 11 00                      dup.x2 sp(0)
	<.main+9241 @053478> : 11 02                      dup.x2 sp(2)
	<.main+9243 @05347a> : 83                         mul.f64
	<.main+9244 @05347b> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9253 @053484> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9262 @05348d> : 11 06                      dup.x2 sp(6)
	<.main+9264 @05348f> : 83                         mul.f64
	<.main+9265 @053490> : 82                         sub.f64
	<.main+9266 @053491> : 83                         mul.f64
	<.main+9267 @053492> : 14 02                      set.x2 sp(2)
	<.main+9269 @053494> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:38: (21 bytes: <@053496> - <@0534ab>): testMathMin_nan: float64 := Math.min()
	<.main+9271 @053496> : 19                         load.z32
	<.main+9272 @053497> : 0a 04 00 00                load.sp(+4)
	<.main+9276 @05349b> : 1a                         load.z64
	<.main+9277 @05349c> : 11 02                      dup.x2 sp(2)
	<.main+9279 @05349e> : 1f f0 fe 04 00             load.ref <@04fef0> ;Math.min(data: float64[]): float64
	<.main+9284 @0534a3> : 02                         call
	<.main+9285 @0534a4> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9288 @0534a7> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:39: (106 bytes: <@0534ab> - <@053515>): testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9292 @0534ab> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9301 @0534b4> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9310 @0534bd> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9319 @0534c6> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9328 @0534cf> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9337 @0534d8> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9346 @0534e1> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9355 @0534ea> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9364 @0534f3> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9373 @0534fc> : 1c 09 00 00 00             load.c32 9
	<.main+9378 @053501> : 0a 04 00 00                load.sp(+4)
	<.main+9382 @053505> : 1a                         load.z64
	<.main+9383 @053506> : 11 02                      dup.x2 sp(2)
	<.main+9385 @053508> : 1f f0 fe 04 00             load.ref <@04fef0> ;Math.min(data: float64[]): float64
	<.main+9390 @05350d> : 02                         call
	<.main+9391 @05350e> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9394 @053511> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:40: (21 bytes: <@053515> - <@05352a>): testMathMax_nan: float64 := Math.max()
	<.main+9398 @053515> : 19                         load.z32
	<.main+9399 @053516> : 0a 04 00 00                load.sp(+4)
	<.main+9403 @05351a> : 1a                         load.z64
	<.main+9404 @05351b> : 11 02                      dup.x2 sp(2)
	<.main+9406 @05351d> : 1f 38 ff 04 00             load.ref <@04ff38> ;Math.max(data: float64[]): float64
	<.main+9411 @053522> : 02                         call
	<.main+9412 @053523> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9415 @053526> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:41: (106 bytes: <@05352a> - <@053594>): testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9419 @05352a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9428 @053533> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9437 @05353c> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9446 @053545> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9455 @05354e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9464 @053557> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9473 @053560> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9482 @053569> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9491 @053572> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9500 @05357b> : 1c 09 00 00 00             load.c32 9
	<.main+9505 @053580> : 0a 04 00 00                load.sp(+4)
	<.main+9509 @053584> : 1a                         load.z64
	<.main+9510 @053585> : 11 02                      dup.x2 sp(2)
	<.main+9512 @053587> : 1f 38 ff 04 00             load.ref <@04ff38> ;Math.max(data: float64[]): float64
	<.main+9517 @05358c> : 02                         call
	<.main+9518 @05358d> : 17 16 02                   mov.x2 sp(22, 2)
	<.main+9521 @053590> : 09 a8 ff ff                inc.sp(-88)
	test/stdc/test.math.ci:43: (21 bytes: <@053594> - <@0535a9>): testMathSum_0: float64 := Math.sum()
	<.main+9525 @053594> : 19                         load.z32
	<.main+9526 @053595> : 0a 04 00 00                load.sp(+4)
	<.main+9530 @053599> : 1a                         load.z64
	<.main+9531 @05359a> : 11 02                      dup.x2 sp(2)
	<.main+9533 @05359c> : 1f 80 ff 04 00             load.ref <@04ff80> ;Math.sum(data: float64[]): float64
	<.main+9538 @0535a1> : 02                         call
	<.main+9539 @0535a2> : 17 04 02                   mov.x2 sp(4, 2)
	<.main+9542 @0535a5> : 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:44: (34 bytes: <@0535a9> - <@0535cb>): testMathSum_1: float64 := Math.sum(1)
	<.main+9546 @0535a9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9555 @0535b2> : 1c 01 00 00 00             load.c32 1
	<.main+9560 @0535b7> : 0a 04 00 00                load.sp(+4)
	<.main+9564 @0535bb> : 1a                         load.z64
	<.main+9565 @0535bc> : 11 02                      dup.x2 sp(2)
	<.main+9567 @0535be> : 1f 80 ff 04 00             load.ref <@04ff80> ;Math.sum(data: float64[]): float64
	<.main+9572 @0535c3> : 02                         call
	<.main+9573 @0535c4> : 17 06 02                   mov.x2 sp(6, 2)
	<.main+9576 @0535c7> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:45: (43 bytes: <@0535cb> - <@0535f6>): testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+9580 @0535cb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9589 @0535d4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9598 @0535dd> : 1c 02 00 00 00             load.c32 2
	<.main+9603 @0535e2> : 0a 04 00 00                load.sp(+4)
	<.main+9607 @0535e6> : 1a                         load.z64
	<.main+9608 @0535e7> : 11 02                      dup.x2 sp(2)
	<.main+9610 @0535e9> : 1f 80 ff 04 00             load.ref <@04ff80> ;Math.sum(data: float64[]): float64
	<.main+9615 @0535ee> : 02                         call
	<.main+9616 @0535ef> : 17 08 02                   mov.x2 sp(8, 2)
	<.main+9619 @0535f2> : 09 e0 ff ff                inc.sp(-32)
	test/stdc/test.math.ci:46: (115 bytes: <@0535f6> - <@053669>): testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+9623 @0535f6> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9632 @0535ff> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9641 @053608> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9650 @053611> : 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+9659 @05361a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9668 @053623> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9677 @05362c> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+9686 @053635> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9695 @05363e> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9704 @053647> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9713 @053650> : 1c 0a 00 00 00             load.c32 10
	<.main+9718 @053655> : 0a 04 00 00                load.sp(+4)
	<.main+9722 @053659> : 1a                         load.z64
	<.main+9723 @05365a> : 11 02                      dup.x2 sp(2)
	<.main+9725 @05365c> : 1f 80 ff 04 00             load.ref <@04ff80> ;Math.sum(data: float64[]): float64
	<.main+9730 @053661> : 02                         call
	<.main+9731 @053662> : 17 18 02                   mov.x2 sp(24, 2)
	<.main+9734 @053665> : 09 a0 ff ff                inc.sp(-96)
	test/stdc/test.math.ci:48: (9 bytes: <@053669> - <@053672>): testMathEval_x: float64 := 10
	<.main+9738 @053669> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	test/stdc/test.math.ci:49: (23 bytes: <@053672> - <@053689>): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+9747 @053672> : 19                         load.z32
	<.main+9748 @053673> : 0a 04 00 00                load.sp(+4)
	<.main+9752 @053677> : 1a                         load.z64
	<.main+9753 @053678> : 11 04                      dup.x2 sp(4)
	<.main+9755 @05367a> : 11 04                      dup.x2 sp(4)
	<.main+9757 @05367c> : 1f a8 ff 04 00             load.ref <@04ffa8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9762 @053681> : 02                         call
	<.main+9763 @053682> : 17 06 04                   mov.x2 sp(6, 4)
	<.main+9766 @053685> : 09 e8 ff ff                inc.sp(-24)
	test/stdc/test.math.ci:50: (9 bytes: <@053689> - <@053692>): testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+9770 @053689> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	test/stdc/test.math.ci:51: (22 bytes: <@053692> - <@0536a8>): testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+9779 @053692> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9788 @05369b> : 11 06                      dup.x2 sp(6)
	<.main+9790 @05369d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9799 @0536a6> : 83                         mul.f64
	<.main+9800 @0536a7> : 81                         add.f64
	test/stdc/test.math.ci:52: (39 bytes: <@0536a8> - <@0536cf>): testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+9801 @0536a8> : 11 06                      dup.x2 sp(6)
	<.main+9803 @0536aa> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9812 @0536b3> : 11 02                      dup.x2 sp(2)
	<.main+9814 @0536b5> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9823 @0536be> : 11 06                      dup.x2 sp(6)
	<.main+9825 @0536c0> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9834 @0536c9> : 83                         mul.f64
	<.main+9835 @0536ca> : 81                         add.f64
	<.main+9836 @0536cb> : 83                         mul.f64
	<.main+9837 @0536cc> : 81                         add.f64
	<.main+9838 @0536cd> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:53: (56 bytes: <@0536cf> - <@053707>): testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9840 @0536cf> : 11 08                      dup.x2 sp(8)
	<.main+9842 @0536d1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9851 @0536da> : 11 02                      dup.x2 sp(2)
	<.main+9853 @0536dc> : 11 04                      dup.x2 sp(4)
	<.main+9855 @0536de> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9864 @0536e7> : 11 02                      dup.x2 sp(2)
	<.main+9866 @0536e9> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9875 @0536f2> : 11 06                      dup.x2 sp(6)
	<.main+9877 @0536f4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9886 @0536fd> : 83                         mul.f64
	<.main+9887 @0536fe> : 81                         add.f64
	<.main+9888 @0536ff> : 83                         mul.f64
	<.main+9889 @053700> : 81                         add.f64
	<.main+9890 @053701> : 14 02                      set.x2 sp(2)
	<.main+9892 @053703> : 83                         mul.f64
	<.main+9893 @053704> : 81                         add.f64
	<.main+9894 @053705> : 14 02                      set.x2 sp(2)
	test/stdc/test.math.ci:54: (72 bytes: <@053707> - <@05374f>): testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9896 @053707> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9905 @053710> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9914 @053719> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9923 @053722> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9932 @05372b> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9941 @053734> : 1c 05 00 00 00             load.c32 5
	<.main+9946 @053739> : 0a 04 00 00                load.sp(+4)
	<.main+9950 @05373d> : 1a                         load.z64
	<.main+9951 @05373e> : 11 18                      dup.x2 sp(24)
	<.main+9953 @053740> : 11 04                      dup.x2 sp(4)
	<.main+9955 @053742> : 1f a8 ff 04 00             load.ref <@04ffa8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+9960 @053747> : 02                         call
	<.main+9961 @053748> : 17 10 04                   mov.x2 sp(16, 4)
	<.main+9964 @05374b> : 09 c0 ff ff                inc.sp(-64)
	test/stdc/test.math.ci:55: (81 bytes: <@05374f> - <@0537a0>): testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+9968 @05374f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9977 @053758> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9986 @053761> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9995 @05376a> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10004 @053773>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10013 @05377c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10022 @053785>: 1c 06 00 00 00             load.c32 6
	<.main+10027 @05378a>: 0a 04 00 00                load.sp(+4)
	<.main+10031 @05378e>: 1a                         load.z64
	<.main+10032 @05378f>: 11 1c                      dup.x2 sp(28)
	<.main+10034 @053791>: 11 04                      dup.x2 sp(4)
	<.main+10036 @053793>: 1f a8 ff 04 00             load.ref <@04ffa8> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10041 @053798>: 02                         call
	<.main+10042 @053799>: 17 12 04                   mov.x2 sp(18, 4)
	<.main+10045 @05379c>: 09 b8 ff ff                inc.sp(-72)
	test/stdc/test.math.ci:57: (31 bytes: <@0537a0> - <@0537bf>): testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10049 @0537a0>: 1a                         load.z64
	<.main+10050 @0537a1>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10059 @0537aa>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10068 @0537b3>: 84                         div.f64
	<.main+10069 @0537b4>: 19                         load.z32
	<.main+10070 @0537b5>: 1f 58 00 05 00             load.ref <@050058> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10075 @0537ba>: 02                         call
	<.main+10076 @0537bb>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:58: (45 bytes: <@0537bf> - <@0537ec>): testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10080 @0537bf>: 1b                         load.z128
	<.main+10081 @0537c0>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10090 @0537c9>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10099 @0537d2>: 84                         div.f64
	<.main+10100 @0537d3>: 1f f8 fd 04 00             load.ref <@04fdf8> ;Math.abs(x: float64): float64
	<.main+10105 @0537d8>: 02                         call
	<.main+10106 @0537d9>: 09 f8 ff ff                inc.sp(-8)
	<.main+10110 @0537dd>: 1c 01 00 00 00             load.c32 1
	<.main+10115 @0537e2>: 1f 58 00 05 00             load.ref <@050058> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10120 @0537e7>: 02                         call
	<.main+10121 @0537e8>: 09 f4 ff ff                inc.sp(-12)
	test/stdc/test.math.ci:59: (30 bytes: <@0537ec> - <@05380a>): testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10125 @0537ec>: 1a                         load.z64
	<.main+10126 @0537ed>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10135 @0537f6>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10144 @0537ff>: 84                         div.f64
	<.main+10145 @053800>: 1f a8 01 05 00             load.ref <@0501a8> ;Math.tan(arg: float64): float64
	<.main+10150 @053805>: 02                         call
	<.main+10151 @053806>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:60: (30 bytes: <@05380a> - <@053828>): testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10155 @05380a>: 1a                         load.z64
	<.main+10156 @05380b>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10165 @053814>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10174 @05381d>: 84                         div.f64
	<.main+10175 @05381e>: 1f 20 03 05 00             load.ref <@050320> ;Math.sinh(x: float64): float64
	<.main+10180 @053823>: 02                         call
	<.main+10181 @053824>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:61: (30 bytes: <@053828> - <@053846>): testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10185 @053828>: 1a                         load.z64
	<.main+10186 @053829>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10195 @053832>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10204 @05383b>: 84                         div.f64
	<.main+10205 @05383c>: 1f 18 04 05 00             load.ref <@050418> ;Math.cosh(x: float64): float64
	<.main+10210 @053841>: 02                         call
	<.main+10211 @053842>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:63: (20 bytes: <@053846> - <@05385a>): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10215 @053846>: 1a                         load.z64
	<.main+10216 @053847>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10225 @053850>: 1f 68 04 05 00             load.ref <@050468> ;Math.asin(x: float64): float64
	<.main+10230 @053855>: 02                         call
	<.main+10231 @053856>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:64: (40 bytes: <@05385a> - <@053882>): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10235 @05385a>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10244 @053863>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10253 @05386c>: 84                         div.f64
	<.main+10254 @05386d>: 1a                         load.z64
	<.main+10255 @05386e>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10264 @053877>: 1f 68 04 05 00             load.ref <@050468> ;Math.asin(x: float64): float64
	<.main+10269 @05387c>: 02                         call
	<.main+10270 @05387d>: 09 f8 ff ff                inc.sp(-8)
	<.main+10274 @053881>: 82                         sub.f64
	test/stdc/test.math.ci:67: (28 bytes: <@053882> - <@05389e>): testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10275 @053882>: 19                         load.z32
	<.main+10276 @053883>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10281 @053888>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10286 @05388d>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10291 @053892>: 1f d8 ff 04 00             load.ref <@04ffd8> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10296 @053897>: 02                         call
	<.main+10297 @053898>: 09 f4 ff ff                inc.sp(-12)
	<.main+10301 @05389c>: 19                         load.z32
	<.main+10302 @05389d>: 57                         ceq.i32
	test/stdc/test.math.ci:68: (40 bytes: <@05389e> - <@0538c6>): testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10303 @05389e>: 19                         load.z32
	<.main+10304 @05389f>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10313 @0538a8>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10322 @0538b1>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10331 @0538ba>: 1f 18 00 05 00             load.ref <@050018> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10336 @0538bf>: 02                         call
	<.main+10337 @0538c0>: 09 e8 ff ff                inc.sp(-24)
	<.main+10341 @0538c4>: 19                         load.z32
	<.main+10342 @0538c5>: 57                         ceq.i32
	test/stdc/test.math.ci:70: (29 bytes: <@0538c6> - <@0538e3>): testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10343 @0538c6>: 1a                         load.z64
	<.main+10344 @0538c7>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10353 @0538d0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10362 @0538d9>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10367 @0538de>: 02                         call
	<.main+10368 @0538df>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:71: (20 bytes: <@0538e3> - <@0538f7>): testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+10372 @0538e3>: 1b                         load.z128
	<.main+10373 @0538e4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10382 @0538ed>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10387 @0538f2>: 02                         call
	<.main+10388 @0538f3>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:72: (29 bytes: <@0538f7> - <@053914>): testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+10392 @0538f7>: 1a                         load.z64
	<.main+10393 @0538f8>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+10402 @053901>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10411 @05390a>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10416 @05390f>: 02                         call
	<.main+10417 @053910>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:74: (29 bytes: <@053914> - <@053931>): testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+10421 @053914>: 1a                         load.z64
	<.main+10422 @053915>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+10431 @05391e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10440 @053927>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10445 @05392c>: 02                         call
	<.main+10446 @05392d>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:75: (29 bytes: <@053931> - <@05394e>): testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+10450 @053931>: 1a                         load.z64
	<.main+10451 @053932>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10460 @05393b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10469 @053944>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10474 @053949>: 02                         call
	<.main+10475 @05394a>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:76: (29 bytes: <@05394e> - <@05396b>): testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+10479 @05394e>: 1a                         load.z64
	<.main+10480 @05394f>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+10489 @053958>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10498 @053961>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10503 @053966>: 02                         call
	<.main+10504 @053967>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:77: (29 bytes: <@05396b> - <@053988>): testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+10508 @05396b>: 1a                         load.z64
	<.main+10509 @05396c>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+10518 @053975>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10527 @05397e>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10532 @053983>: 02                         call
	<.main+10533 @053984>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:79: (29 bytes: <@053988> - <@0539a5>): testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+10537 @053988>: 1a                         load.z64
	<.main+10538 @053989>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+10547 @053992>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10556 @05399b>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10561 @0539a0>: 02                         call
	<.main+10562 @0539a1>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:80: (29 bytes: <@0539a5> - <@0539c2>): testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+10566 @0539a5>: 1a                         load.z64
	<.main+10567 @0539a6>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10576 @0539af>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10585 @0539b8>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10590 @0539bd>: 02                         call
	<.main+10591 @0539be>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:81: (29 bytes: <@0539c2> - <@0539df>): testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+10595 @0539c2>: 1a                         load.z64
	<.main+10596 @0539c3>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+10605 @0539cc>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10614 @0539d5>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10619 @0539da>: 02                         call
	<.main+10620 @0539db>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:82: (29 bytes: <@0539df> - <@0539fc>): testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+10624 @0539df>: 1a                         load.z64
	<.main+10625 @0539e0>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+10634 @0539e9>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10643 @0539f2>: 1f 30 fe 04 00             load.ref <@04fe30> ;Math.absMod(val: float64, mod: float64): float64
	<.main+10648 @0539f7>: 02                         call
	<.main+10649 @0539f8>: 09 f0 ff ff                inc.sp(-16)
	test/stdc/test.math.ci:84: (21 bytes: <@0539fc> - <@053a11>): testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+10653 @0539fc>: 19                         load.z32
	<.main+10654 @0539fd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10659 @053a02>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10664 @053a07>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10669 @053a0c>: 02                         call
	<.main+10670 @053a0d>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:85: (17 bytes: <@053a11> - <@053a22>): testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+10674 @053a11>: 19                         load.z32
	<.main+10675 @053a12>: 19                         load.z32
	<.main+10676 @053a13>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10681 @053a18>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10686 @053a1d>: 02                         call
	<.main+10687 @053a1e>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:86: (21 bytes: <@053a22> - <@053a37>): testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+10691 @053a22>: 19                         load.z32
	<.main+10692 @053a23>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+10697 @053a28>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10702 @053a2d>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10707 @053a32>: 02                         call
	<.main+10708 @053a33>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:88: (21 bytes: <@053a37> - <@053a4c>): testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+10712 @053a37>: 19                         load.z32
	<.main+10713 @053a38>: 7f 00 00 98 41             load.f32 19.000000
	<.main+10718 @053a3d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10723 @053a42>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10728 @053a47>: 02                         call
	<.main+10729 @053a48>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:89: (21 bytes: <@053a4c> - <@053a61>): testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+10733 @053a4c>: 19                         load.z32
	<.main+10734 @053a4d>: 7f 00 00 10 41             load.f32 9.000000
	<.main+10739 @053a52>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10744 @053a57>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10749 @053a5c>: 02                         call
	<.main+10750 @053a5d>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:90: (21 bytes: <@053a61> - <@053a76>): testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+10754 @053a61>: 19                         load.z32
	<.main+10755 @053a62>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+10760 @053a67>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10765 @053a6c>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10770 @053a71>: 02                         call
	<.main+10771 @053a72>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:91: (21 bytes: <@053a76> - <@053a8b>): testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+10775 @053a76>: 19                         load.z32
	<.main+10776 @053a77>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+10781 @053a7c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10786 @053a81>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10791 @053a86>: 02                         call
	<.main+10792 @053a87>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:93: (21 bytes: <@053a8b> - <@053aa0>): testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+10796 @053a8b>: 19                         load.z32
	<.main+10797 @053a8c>: 7f 00 00 90 41             load.f32 18.000000
	<.main+10802 @053a91>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10807 @053a96>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10812 @053a9b>: 02                         call
	<.main+10813 @053a9c>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:94: (21 bytes: <@053aa0> - <@053ab5>): testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+10817 @053aa0>: 19                         load.z32
	<.main+10818 @053aa1>: 7f 00 00 00 41             load.f32 8.000000
	<.main+10823 @053aa6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10828 @053aab>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10833 @053ab0>: 02                         call
	<.main+10834 @053ab1>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:95: (21 bytes: <@053ab5> - <@053aca>): testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+10838 @053ab5>: 19                         load.z32
	<.main+10839 @053ab6>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+10844 @053abb>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10849 @053ac0>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10854 @053ac5>: 02                         call
	<.main+10855 @053ac6>: 09 f8 ff ff                inc.sp(-8)
	test/stdc/test.math.ci:96: (21 bytes: <@053aca> - <@053adf>): testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+10859 @053aca>: 19                         load.z32
	<.main+10860 @053acb>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+10865 @053ad0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+10870 @053ad5>: 1f 10 fe 04 00             load.ref <@04fe10> ;Math.absMod(val: float32, mod: float32): float32
	<.main+10875 @053ada>: 02                         call
	<.main+10876 @053adb>: 09 f8 ff ff                inc.sp(-8)
	<.main+10880 @053adf>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 220.39] > .main
[ 220.94]  > funAdd(x: int32, y: int32): int32
[ 220.96]  < return
[ 220.97]  > funAdd(x: int32, y: int32): int32
[ 220.98]  < return
[ 220.99]  > funMul(x: int32, y: int32): int32
[ 221.00]  < return
[ 221.01]  > funMul(x: int32, y: int32): int32
[ 221.02]  < return
[ 221.03]  > fib(n: uint32): uint32
[ 221.05]   > fib(n: uint32): uint32
[ 221.06]    > fib(n: uint32): uint32
[ 221.07]     > fib(n: uint32): uint32
[ 221.08]      > fib(n: uint32): uint32
[ 221.09]       > fib(n: uint32): uint32
[ 221.11]        > fib(n: uint32): uint32
[ 221.12]         > fib(n: uint32): uint32
[ 221.13]          > fib(n: uint32): uint32
[ 221.14]           > fib(n: uint32): uint32
[ 221.16]            > fib(n: uint32): uint32
[ 221.17]             > fib(n: uint32): uint32
[ 221.18]              > fib(n: uint32): uint32
[ 221.19]              < return
[ 221.20]              > fib(n: uint32): uint32
[ 221.21]              < return
[ 221.22]             < return
[ 221.22]             > fib(n: uint32): uint32
[ 221.24]             < return
[ 221.24]            < return
[ 221.25]            > fib(n: uint32): uint32
[ 221.26]             > fib(n: uint32): uint32
[ 221.27]             < return
[ 221.28]             > fib(n: uint32): uint32
[ 221.29]             < return
[ 221.30]            < return
[ 221.31]           < return
[ 221.32]           > fib(n: uint32): uint32
[ 221.33]            > fib(n: uint32): uint32
[ 221.34]             > fib(n: uint32): uint32
[ 221.35]             < return
[ 221.36]             > fib(n: uint32): uint32
[ 221.37]             < return
[ 221.38]            < return
[ 221.39]            > fib(n: uint32): uint32
[ 221.40]            < return
[ 221.41]           < return
[ 221.41]          < return
[ 221.42]          > fib(n: uint32): uint32
[ 221.44]           > fib(n: uint32): uint32
[ 221.45]            > fib(n: uint32): uint32
[ 221.46]             > fib(n: uint32): uint32
[ 221.47]             < return
[ 221.48]             > fib(n: uint32): uint32
[ 221.49]             < return
[ 221.50]            < return
[ 221.51]            > fib(n: uint32): uint32
[ 221.52]            < return
[ 221.53]           < return
[ 221.53]           > fib(n: uint32): uint32
[ 221.55]            > fib(n: uint32): uint32
[ 221.56]            < return
[ 221.57]            > fib(n: uint32): uint32
[ 221.58]            < return
[ 221.58]           < return
[ 221.59]          < return
[ 221.60]         < return
[ 221.61]         > fib(n: uint32): uint32
[ 221.62]          > fib(n: uint32): uint32
[ 221.63]           > fib(n: uint32): uint32
[ 221.64]            > fib(n: uint32): uint32
[ 221.66]             > fib(n: uint32): uint32
[ 221.66]             < return
[ 221.67]             > fib(n: uint32): uint32
[ 221.68]             < return
[ 221.69]            < return
[ 221.70]            > fib(n: uint32): uint32
[ 221.71]            < return
[ 221.72]           < return
[ 221.73]           > fib(n: uint32): uint32
[ 221.74]            > fib(n: uint32): uint32
[ 221.75]            < return
[ 221.76]            > fib(n: uint32): uint32
[ 221.77]            < return
[ 221.78]           < return
[ 221.78]          < return
[ 221.79]          > fib(n: uint32): uint32
[ 221.80]           > fib(n: uint32): uint32
[ 221.81]            > fib(n: uint32): uint32
[ 221.82]            < return
[ 221.83]            > fib(n: uint32): uint32
[ 221.84]            < return
[ 221.85]           < return
[ 221.86]           > fib(n: uint32): uint32
[ 221.87]           < return
[ 221.88]          < return
[ 221.89]         < return
[ 221.89]        < return
[ 221.90]        > fib(n: uint32): uint32
[ 221.91]         > fib(n: uint32): uint32
[ 221.93]          > fib(n: uint32): uint32
[ 221.94]           > fib(n: uint32): uint32
[ 221.95]            > fib(n: uint32): uint32
[ 221.96]             > fib(n: uint32): uint32
[ 221.97]             < return
[ 221.98]             > fib(n: uint32): uint32
[ 221.99]             < return
[ 222.00]            < return
[ 222.01]            > fib(n: uint32): uint32
[ 222.02]            < return
[ 222.03]           < return
[ 222.03]           > fib(n: uint32): uint32
[ 222.04]            > fib(n: uint32): uint32
[ 222.06]            < return
[ 222.06]            > fib(n: uint32): uint32
[ 222.07]            < return
[ 222.08]           < return
[ 222.09]          < return
[ 222.10]          > fib(n: uint32): uint32
[ 222.11]           > fib(n: uint32): uint32
[ 222.12]            > fib(n: uint32): uint32
[ 222.13]            < return
[ 222.14]            > fib(n: uint32): uint32
[ 222.15]            < return
[ 222.16]           < return
[ 222.17]           > fib(n: uint32): uint32
[ 222.18]           < return
[ 222.19]          < return
[ 222.19]         < return
[ 222.20]         > fib(n: uint32): uint32
[ 222.21]          > fib(n: uint32): uint32
[ 222.22]           > fib(n: uint32): uint32
[ 222.24]            > fib(n: uint32): uint32
[ 222.25]            < return
[ 222.26]            > fib(n: uint32): uint32
[ 222.27]            < return
[ 222.27]           < return
[ 222.28]           > fib(n: uint32): uint32
[ 222.29]           < return
[ 222.30]          < return
[ 222.31]          > fib(n: uint32): uint32
[ 222.32]           > fib(n: uint32): uint32
[ 222.33]           < return
[ 222.34]           > fib(n: uint32): uint32
[ 222.35]           < return
[ 222.36]          < return
[ 222.37]         < return
[ 222.37]        < return
[ 222.38]       < return
[ 222.39]       > fib(n: uint32): uint32
[ 222.40]        > fib(n: uint32): uint32
[ 222.41]         > fib(n: uint32): uint32
[ 222.42]          > fib(n: uint32): uint32
[ 222.44]           > fib(n: uint32): uint32
[ 222.45]            > fib(n: uint32): uint32
[ 222.46]             > fib(n: uint32): uint32
[ 222.47]             < return
[ 222.48]             > fib(n: uint32): uint32
[ 222.49]             < return
[ 222.50]            < return
[ 222.50]            > fib(n: uint32): uint32
[ 222.51]            < return
[ 222.52]           < return
[ 222.53]           > fib(n: uint32): uint32
[ 222.54]            > fib(n: uint32): uint32
[ 222.56]            < return
[ 222.56]            > fib(n: uint32): uint32
[ 222.57]            < return
[ 222.58]           < return
[ 222.59]          < return
[ 222.60]          > fib(n: uint32): uint32
[ 222.61]           > fib(n: uint32): uint32
[ 222.62]            > fib(n: uint32): uint32
[ 222.63]            < return
[ 222.64]            > fib(n: uint32): uint32
[ 222.65]            < return
[ 222.66]           < return
[ 222.67]           > fib(n: uint32): uint32
[ 222.68]           < return
[ 222.69]          < return
[ 222.69]         < return
[ 222.70]         > fib(n: uint32): uint32
[ 222.71]          > fib(n: uint32): uint32
[ 222.72]           > fib(n: uint32): uint32
[ 222.74]            > fib(n: uint32): uint32
[ 222.75]            < return
[ 222.75]            > fib(n: uint32): uint32
[ 222.76]            < return
[ 222.77]           < return
[ 222.78]           > fib(n: uint32): uint32
[ 222.79]           < return
[ 222.80]          < return
[ 222.81]          > fib(n: uint32): uint32
[ 222.82]           > fib(n: uint32): uint32
[ 222.83]           < return
[ 222.84]           > fib(n: uint32): uint32
[ 222.85]           < return
[ 222.86]          < return
[ 222.86]         < return
[ 222.87]        < return
[ 222.88]        > fib(n: uint32): uint32
[ 222.89]         > fib(n: uint32): uint32
[ 222.90]          > fib(n: uint32): uint32
[ 222.91]           > fib(n: uint32): uint32
[ 222.93]            > fib(n: uint32): uint32
[ 222.94]            < return
[ 222.95]            > fib(n: uint32): uint32
[ 222.96]            < return
[ 222.96]           < return
[ 222.97]           > fib(n: uint32): uint32
[ 222.98]           < return
[ 222.99]          < return
[ 223.00]          > fib(n: uint32): uint32
[ 223.01]           > fib(n: uint32): uint32
[ 223.02]           < return
[ 223.03]           > fib(n: uint32): uint32
[ 223.04]           < return
[ 223.05]          < return
[ 223.06]         < return
[ 223.06]         > fib(n: uint32): uint32
[ 223.07]          > fib(n: uint32): uint32
[ 223.09]           > fib(n: uint32): uint32
[ 223.10]           < return
[ 223.11]           > fib(n: uint32): uint32
[ 223.12]           < return
[ 223.12]          < return
[ 223.13]          > fib(n: uint32): uint32
[ 223.14]          < return
[ 223.15]         < return
[ 223.16]        < return
[ 223.16]       < return
[ 223.17]      < return
[ 223.18]      > fib(n: uint32): uint32
[ 223.19]       > fib(n: uint32): uint32
[ 223.20]        > fib(n: uint32): uint32
[ 223.22]         > fib(n: uint32): uint32
[ 223.23]          > fib(n: uint32): uint32
[ 223.24]           > fib(n: uint32): uint32
[ 223.25]            > fib(n: uint32): uint32
[ 223.26]             > fib(n: uint32): uint32
[ 223.27]             < return
[ 223.28]             > fib(n: uint32): uint32
[ 223.29]             < return
[ 223.30]            < return
[ 223.31]            > fib(n: uint32): uint32
[ 223.32]            < return
[ 223.33]           < return
[ 223.34]           > fib(n: uint32): uint32
[ 223.35]            > fib(n: uint32): uint32
[ 223.36]            < return
[ 223.37]            > fib(n: uint32): uint32
[ 223.38]            < return
[ 223.38]           < return
[ 223.39]          < return
[ 223.40]          > fib(n: uint32): uint32
[ 223.41]           > fib(n: uint32): uint32
[ 223.43]            > fib(n: uint32): uint32
[ 223.44]            < return
[ 223.44]            > fib(n: uint32): uint32
[ 223.45]            < return
[ 223.46]           < return
[ 223.47]           > fib(n: uint32): uint32
[ 223.48]           < return
[ 223.49]          < return
[ 223.50]         < return
[ 223.50]         > fib(n: uint32): uint32
[ 223.51]          > fib(n: uint32): uint32
[ 223.53]           > fib(n: uint32): uint32
[ 223.54]            > fib(n: uint32): uint32
[ 223.55]            < return
[ 223.56]            > fib(n: uint32): uint32
[ 223.57]            < return
[ 223.58]           < return
[ 223.59]           > fib(n: uint32): uint32
[ 223.59]           < return
[ 223.60]          < return
[ 223.61]          > fib(n: uint32): uint32
[ 223.62]           > fib(n: uint32): uint32
[ 223.63]           < return
[ 223.64]           > fib(n: uint32): uint32
[ 223.65]           < return
[ 223.66]          < return
[ 223.67]         < return
[ 223.68]        < return
[ 223.69]        > fib(n: uint32): uint32
[ 223.70]         > fib(n: uint32): uint32
[ 223.71]          > fib(n: uint32): uint32
[ 223.72]           > fib(n: uint32): uint32
[ 223.73]            > fib(n: uint32): uint32
[ 223.74]            < return
[ 223.75]            > fib(n: uint32): uint32
[ 223.76]            < return
[ 223.77]           < return
[ 223.78]           > fib(n: uint32): uint32
[ 223.79]           < return
[ 223.79]          < return
[ 223.80]          > fib(n: uint32): uint32
[ 223.81]           > fib(n: uint32): uint32
[ 223.82]           < return
[ 223.83]           > fib(n: uint32): uint32
[ 223.84]           < return
[ 223.85]          < return
[ 223.86]         < return
[ 223.87]         > fib(n: uint32): uint32
[ 223.88]          > fib(n: uint32): uint32
[ 223.89]           > fib(n: uint32): uint32
[ 223.90]           < return
[ 223.91]           > fib(n: uint32): uint32
[ 223.92]           < return
[ 223.93]          < return
[ 223.94]          > fib(n: uint32): uint32
[ 223.95]          < return
[ 223.96]         < return
[ 223.96]        < return
[ 223.97]       < return
[ 223.98]       > fib(n: uint32): uint32
[ 223.99]        > fib(n: uint32): uint32
[ 224.00]         > fib(n: uint32): uint32
[ 224.01]          > fib(n: uint32): uint32
[ 224.03]           > fib(n: uint32): uint32
[ 224.04]            > fib(n: uint32): uint32
[ 224.05]            < return
[ 224.06]            > fib(n: uint32): uint32
[ 224.07]            < return
[ 224.07]           < return
[ 224.08]           > fib(n: uint32): uint32
[ 224.09]           < return
[ 224.10]          < return
[ 224.11]          > fib(n: uint32): uint32
[ 224.12]           > fib(n: uint32): uint32
[ 224.13]           < return
[ 224.14]           > fib(n: uint32): uint32
[ 224.15]           < return
[ 224.16]          < return
[ 224.17]         < return
[ 224.18]         > fib(n: uint32): uint32
[ 224.19]          > fib(n: uint32): uint32
[ 224.21]           > fib(n: uint32): uint32
[ 224.22]           < return
[ 224.22]           > fib(n: uint32): uint32
[ 224.24]           < return
[ 224.24]          < return
[ 224.25]          > fib(n: uint32): uint32
[ 224.26]          < return
[ 224.27]         < return
[ 224.28]        < return
[ 224.28]        > fib(n: uint32): uint32
[ 224.30]         > fib(n: uint32): uint32
[ 224.31]          > fib(n: uint32): uint32
[ 224.32]           > fib(n: uint32): uint32
[ 224.33]           < return
[ 224.34]           > fib(n: uint32): uint32
[ 224.35]           < return
[ 224.36]          < return
[ 224.37]          > fib(n: uint32): uint32
[ 224.38]          < return
[ 224.38]         < return
[ 224.39]         > fib(n: uint32): uint32
[ 224.40]          > fib(n: uint32): uint32
[ 224.41]          < return
[ 224.42]          > fib(n: uint32): uint32
[ 224.43]          < return
[ 224.44]         < return
[ 224.45]        < return
[ 224.46]       < return
[ 224.46]      < return
[ 224.47]     < return
[ 224.48]     > fib(n: uint32): uint32
[ 224.49]      > fib(n: uint32): uint32
[ 224.50]       > fib(n: uint32): uint32
[ 224.51]        > fib(n: uint32): uint32
[ 224.53]         > fib(n: uint32): uint32
[ 224.54]          > fib(n: uint32): uint32
[ 224.55]           > fib(n: uint32): uint32
[ 224.56]            > fib(n: uint32): uint32
[ 224.57]             > fib(n: uint32): uint32
[ 224.59]             < return
[ 224.59]             > fib(n: uint32): uint32
[ 224.60]             < return
[ 224.61]            < return
[ 224.62]            > fib(n: uint32): uint32
[ 224.63]            < return
[ 224.64]           < return
[ 224.65]           > fib(n: uint32): uint32
[ 224.66]            > fib(n: uint32): uint32
[ 224.67]            < return
[ 224.68]            > fib(n: uint32): uint32
[ 224.69]            < return
[ 224.69]           < return
[ 224.71]          < return
[ 224.71]          > fib(n: uint32): uint32
[ 224.73]           > fib(n: uint32): uint32
[ 224.74]            > fib(n: uint32): uint32
[ 224.75]            < return
[ 224.76]            > fib(n: uint32): uint32
[ 224.77]            < return
[ 224.77]           < return
[ 224.78]           > fib(n: uint32): uint32
[ 224.79]           < return
[ 224.80]          < return
[ 224.81]         < return
[ 224.82]         > fib(n: uint32): uint32
[ 224.83]          > fib(n: uint32): uint32
[ 224.84]           > fib(n: uint32): uint32
[ 224.85]            > fib(n: uint32): uint32
[ 224.86]            < return
[ 224.87]            > fib(n: uint32): uint32
[ 224.88]            < return
[ 224.89]           < return
[ 224.90]           > fib(n: uint32): uint32
[ 224.91]           < return
[ 224.91]          < return
[ 224.92]          > fib(n: uint32): uint32
[ 224.94]           > fib(n: uint32): uint32
[ 224.95]           < return
[ 224.96]           > fib(n: uint32): uint32
[ 224.97]           < return
[ 224.97]          < return
[ 224.98]         < return
[ 224.99]        < return
[ 225.00]        > fib(n: uint32): uint32
[ 225.01]         > fib(n: uint32): uint32
[ 225.02]          > fib(n: uint32): uint32
[ 225.03]           > fib(n: uint32): uint32
[ 225.04]            > fib(n: uint32): uint32
[ 225.05]            < return
[ 225.06]            > fib(n: uint32): uint32
[ 225.07]            < return
[ 225.08]           < return
[ 225.09]           > fib(n: uint32): uint32
[ 225.10]           < return
[ 225.11]          < return
[ 225.11]          > fib(n: uint32): uint32
[ 225.13]           > fib(n: uint32): uint32
[ 225.14]           < return
[ 225.15]           > fib(n: uint32): uint32
[ 225.16]           < return
[ 225.16]          < return
[ 225.17]         < return
[ 225.18]         > fib(n: uint32): uint32
[ 225.19]          > fib(n: uint32): uint32
[ 225.20]           > fib(n: uint32): uint32
[ 225.21]           < return
[ 225.22]           > fib(n: uint32): uint32
[ 225.23]           < return
[ 225.24]          < return
[ 225.25]          > fib(n: uint32): uint32
[ 225.26]          < return
[ 225.27]         < return
[ 225.27]        < return
[ 225.28]       < return
[ 225.29]       > fib(n: uint32): uint32
[ 225.30]        > fib(n: uint32): uint32
[ 225.31]         > fib(n: uint32): uint32
[ 225.32]          > fib(n: uint32): uint32
[ 225.34]           > fib(n: uint32): uint32
[ 225.35]            > fib(n: uint32): uint32
[ 225.36]            < return
[ 225.37]            > fib(n: uint32): uint32
[ 225.38]            < return
[ 225.39]           < return
[ 225.40]           > fib(n: uint32): uint32
[ 225.41]           < return
[ 225.41]          < return
[ 225.42]          > fib(n: uint32): uint32
[ 225.43]           > fib(n: uint32): uint32
[ 225.44]           < return
[ 225.45]           > fib(n: uint32): uint32
[ 225.46]           < return
[ 225.47]          < return
[ 225.48]         < return
[ 225.49]         > fib(n: uint32): uint32
[ 225.50]          > fib(n: uint32): uint32
[ 225.51]           > fib(n: uint32): uint32
[ 225.52]           < return
[ 225.53]           > fib(n: uint32): uint32
[ 225.54]           < return
[ 225.55]          < return
[ 225.56]          > fib(n: uint32): uint32
[ 225.56]          < return
[ 225.57]         < return
[ 225.58]        < return
[ 225.59]        > fib(n: uint32): uint32
[ 225.60]         > fib(n: uint32): uint32
[ 225.61]          > fib(n: uint32): uint32
[ 225.62]           > fib(n: uint32): uint32
[ 225.63]           < return
[ 225.64]           > fib(n: uint32): uint32
[ 225.65]           < return
[ 225.66]          < return
[ 225.67]          > fib(n: uint32): uint32
[ 225.68]          < return
[ 225.69]         < return
[ 225.70]         > fib(n: uint32): uint32
[ 225.71]          > fib(n: uint32): uint32
[ 225.72]          < return
[ 225.73]          > fib(n: uint32): uint32
[ 225.74]          < return
[ 225.75]         < return
[ 225.75]        < return
[ 225.76]       < return
[ 225.77]      < return
[ 225.78]      > fib(n: uint32): uint32
[ 225.79]       > fib(n: uint32): uint32
[ 225.80]        > fib(n: uint32): uint32
[ 225.81]         > fib(n: uint32): uint32
[ 225.82]          > fib(n: uint32): uint32
[ 225.84]           > fib(n: uint32): uint32
[ 225.85]            > fib(n: uint32): uint32
[ 225.86]            < return
[ 225.87]            > fib(n: uint32): uint32
[ 225.88]            < return
[ 225.89]           < return
[ 225.89]           > fib(n: uint32): uint32
[ 225.91]           < return
[ 225.91]          < return
[ 225.92]          > fib(n: uint32): uint32
[ 225.93]           > fib(n: uint32): uint32
[ 225.94]           < return
[ 225.95]           > fib(n: uint32): uint32
[ 225.96]           < return
[ 225.97]          < return
[ 225.98]         < return
[ 225.99]         > fib(n: uint32): uint32
[ 226.00]          > fib(n: uint32): uint32
[ 226.01]           > fib(n: uint32): uint32
[ 226.02]           < return
[ 226.03]           > fib(n: uint32): uint32
[ 226.04]           < return
[ 226.05]          < return
[ 226.06]          > fib(n: uint32): uint32
[ 226.06]          < return
[ 226.07]         < return
[ 226.08]        < return
[ 226.09]        > fib(n: uint32): uint32
[ 226.10]         > fib(n: uint32): uint32
[ 226.11]          > fib(n: uint32): uint32
[ 226.12]           > fib(n: uint32): uint32
[ 226.13]           < return
[ 226.14]           > fib(n: uint32): uint32
[ 226.15]           < return
[ 226.16]          < return
[ 226.17]          > fib(n: uint32): uint32
[ 226.18]          < return
[ 226.19]         < return
[ 226.19]         > fib(n: uint32): uint32
[ 226.21]          > fib(n: uint32): uint32
[ 226.22]          < return
[ 226.23]          > fib(n: uint32): uint32
[ 226.24]          < return
[ 226.25]         < return
[ 226.25]        < return
[ 226.26]       < return
[ 226.27]       > fib(n: uint32): uint32
[ 226.28]        > fib(n: uint32): uint32
[ 226.29]         > fib(n: uint32): uint32
[ 226.30]          > fib(n: uint32): uint32
[ 226.31]           > fib(n: uint32): uint32
[ 226.33]           < return
[ 226.34]           > fib(n: uint32): uint32
[ 226.34]           < return
[ 226.35]          < return
[ 226.36]          > fib(n: uint32): uint32
[ 226.37]          < return
[ 226.38]         < return
[ 226.39]         > fib(n: uint32): uint32
[ 226.40]          > fib(n: uint32): uint32
[ 226.41]          < return
[ 226.42]          > fib(n: uint32): uint32
[ 226.43]          < return
[ 226.44]         < return
[ 226.44]        < return
[ 226.45]        > fib(n: uint32): uint32
[ 226.46]         > fib(n: uint32): uint32
[ 226.48]          > fib(n: uint32): uint32
[ 226.49]          < return
[ 226.50]          > fib(n: uint32): uint32
[ 226.51]          < return
[ 226.51]         < return
[ 226.52]         > fib(n: uint32): uint32
[ 226.53]         < return
[ 226.54]        < return
[ 226.55]       < return
[ 226.56]      < return
[ 226.56]     < return
[ 226.57]    < return
[ 226.58]    > fib(n: uint32): uint32
[ 226.59]     > fib(n: uint32): uint32
[ 226.60]      > fib(n: uint32): uint32
[ 226.61]       > fib(n: uint32): uint32
[ 226.63]        > fib(n: uint32): uint32
[ 226.64]         > fib(n: uint32): uint32
[ 226.65]          > fib(n: uint32): uint32
[ 226.66]           > fib(n: uint32): uint32
[ 226.67]            > fib(n: uint32): uint32
[ 226.69]             > fib(n: uint32): uint32
[ 226.70]             < return
[ 226.71]             > fib(n: uint32): uint32
[ 226.72]             < return
[ 226.72]            < return
[ 226.73]            > fib(n: uint32): uint32
[ 226.74]            < return
[ 226.75]           < return
[ 226.76]           > fib(n: uint32): uint32
[ 226.77]            > fib(n: uint32): uint32
[ 226.78]            < return
[ 226.79]            > fib(n: uint32): uint32
[ 226.80]            < return
[ 226.81]           < return
[ 226.81]          < return
[ 226.82]          > fib(n: uint32): uint32
[ 226.84]           > fib(n: uint32): uint32
[ 226.85]            > fib(n: uint32): uint32
[ 226.86]            < return
[ 226.87]            > fib(n: uint32): uint32
[ 226.88]            < return
[ 226.89]           < return
[ 226.89]           > fib(n: uint32): uint32
[ 226.91]           < return
[ 226.91]          < return
[ 226.92]         < return
[ 226.93]         > fib(n: uint32): uint32
[ 226.94]          > fib(n: uint32): uint32
[ 226.95]           > fib(n: uint32): uint32
[ 226.96]            > fib(n: uint32): uint32
[ 226.97]            < return
[ 226.98]            > fib(n: uint32): uint32
[ 226.99]            < return
[ 227.00]           < return
[ 227.01]           > fib(n: uint32): uint32
[ 227.02]           < return
[ 227.03]          < return
[ 227.04]          > fib(n: uint32): uint32
[ 227.05]           > fib(n: uint32): uint32
[ 227.06]           < return
[ 227.07]           > fib(n: uint32): uint32
[ 227.08]           < return
[ 227.09]          < return
[ 227.09]         < return
[ 227.10]        < return
[ 227.11]        > fib(n: uint32): uint32
[ 227.12]         > fib(n: uint32): uint32
[ 227.13]          > fib(n: uint32): uint32
[ 227.14]           > fib(n: uint32): uint32
[ 227.16]            > fib(n: uint32): uint32
[ 227.17]            < return
[ 227.17]            > fib(n: uint32): uint32
[ 227.19]            < return
[ 227.19]           < return
[ 227.20]           > fib(n: uint32): uint32
[ 227.21]           < return
[ 227.22]          < return
[ 227.23]          > fib(n: uint32): uint32
[ 227.24]           > fib(n: uint32): uint32
[ 227.25]           < return
[ 227.26]           > fib(n: uint32): uint32
[ 227.27]           < return
[ 227.28]          < return
[ 227.28]         < return
[ 227.29]         > fib(n: uint32): uint32
[ 227.30]          > fib(n: uint32): uint32
[ 227.31]           > fib(n: uint32): uint32
[ 227.33]           < return
[ 227.33]           > fib(n: uint32): uint32
[ 227.34]           < return
[ 227.35]          < return
[ 227.36]          > fib(n: uint32): uint32
[ 227.37]          < return
[ 227.38]         < return
[ 227.39]        < return
[ 227.39]       < return
[ 227.40]       > fib(n: uint32): uint32
[ 227.41]        > fib(n: uint32): uint32
[ 227.43]         > fib(n: uint32): uint32
[ 227.44]          > fib(n: uint32): uint32
[ 227.45]           > fib(n: uint32): uint32
[ 227.46]            > fib(n: uint32): uint32
[ 227.47]            < return
[ 227.48]            > fib(n: uint32): uint32
[ 227.49]            < return
[ 227.50]           < return
[ 227.51]           > fib(n: uint32): uint32
[ 227.52]           < return
[ 227.53]          < return
[ 227.53]          > fib(n: uint32): uint32
[ 227.54]           > fib(n: uint32): uint32
[ 227.56]           < return
[ 227.56]           > fib(n: uint32): uint32
[ 227.57]           < return
[ 227.58]          < return
[ 227.59]         < return
[ 227.60]         > fib(n: uint32): uint32
[ 227.61]          > fib(n: uint32): uint32
[ 227.62]           > fib(n: uint32): uint32
[ 227.63]           < return
[ 227.64]           > fib(n: uint32): uint32
[ 227.65]           < return
[ 227.66]          < return
[ 227.67]          > fib(n: uint32): uint32
[ 227.68]          < return
[ 227.69]         < return
[ 227.69]        < return
[ 227.70]        > fib(n: uint32): uint32
[ 227.71]         > fib(n: uint32): uint32
[ 227.72]          > fib(n: uint32): uint32
[ 227.74]           > fib(n: uint32): uint32
[ 227.75]           < return
[ 227.75]           > fib(n: uint32): uint32
[ 227.77]           < return
[ 227.77]          < return
[ 227.78]          > fib(n: uint32): uint32
[ 227.79]          < return
[ 227.80]         < return
[ 227.81]         > fib(n: uint32): uint32
[ 227.82]          > fib(n: uint32): uint32
[ 227.83]          < return
[ 227.84]          > fib(n: uint32): uint32
[ 227.85]          < return
[ 227.86]         < return
[ 227.86]        < return
[ 227.87]       < return
[ 227.88]      < return
[ 227.89]      > fib(n: uint32): uint32
[ 227.90]       > fib(n: uint32): uint32
[ 227.91]        > fib(n: uint32): uint32
[ 227.92]         > fib(n: uint32): uint32
[ 227.94]          > fib(n: uint32): uint32
[ 227.95]           > fib(n: uint32): uint32
[ 227.96]            > fib(n: uint32): uint32
[ 227.97]            < return
[ 227.98]            > fib(n: uint32): uint32
[ 227.99]            < return
[ 228.00]           < return
[ 228.01]           > fib(n: uint32): uint32
[ 228.02]           < return
[ 228.03]          < return
[ 228.03]          > fib(n: uint32): uint32
[ 228.04]           > fib(n: uint32): uint32
[ 228.06]           < return
[ 228.06]           > fib(n: uint32): uint32
[ 228.07]           < return
[ 228.08]          < return
[ 228.09]         < return
[ 228.10]         > fib(n: uint32): uint32
[ 228.11]          > fib(n: uint32): uint32
[ 228.12]           > fib(n: uint32): uint32
[ 228.13]           < return
[ 228.14]           > fib(n: uint32): uint32
[ 228.15]           < return
[ 228.16]          < return
[ 228.17]          > fib(n: uint32): uint32
[ 228.18]          < return
[ 228.19]         < return
[ 228.20]        < return
[ 228.21]        > fib(n: uint32): uint32
[ 228.22]         > fib(n: uint32): uint32
[ 228.23]          > fib(n: uint32): uint32
[ 228.24]           > fib(n: uint32): uint32
[ 228.25]           < return
[ 228.26]           > fib(n: uint32): uint32
[ 228.27]           < return
[ 228.28]          < return
[ 228.29]          > fib(n: uint32): uint32
[ 228.30]          < return
[ 228.31]         < return
[ 228.31]         > fib(n: uint32): uint32
[ 228.32]          > fib(n: uint32): uint32
[ 228.34]          < return
[ 228.34]          > fib(n: uint32): uint32
[ 228.35]          < return
[ 228.36]         < return
[ 228.37]        < return
[ 228.38]       < return
[ 228.38]       > fib(n: uint32): uint32
[ 228.40]        > fib(n: uint32): uint32
[ 228.41]         > fib(n: uint32): uint32
[ 228.42]          > fib(n: uint32): uint32
[ 228.43]           > fib(n: uint32): uint32
[ 228.44]           < return
[ 228.45]           > fib(n: uint32): uint32
[ 228.46]           < return
[ 228.47]          < return
[ 228.48]          > fib(n: uint32): uint32
[ 228.49]          < return
[ 228.50]         < return
[ 228.50]         > fib(n: uint32): uint32
[ 228.52]          > fib(n: uint32): uint32
[ 228.53]          < return
[ 228.53]          > fib(n: uint32): uint32
[ 228.54]          < return
[ 228.55]         < return
[ 228.56]        < return
[ 228.57]        > fib(n: uint32): uint32
[ 228.58]         > fib(n: uint32): uint32
[ 228.59]          > fib(n: uint32): uint32
[ 228.60]          < return
[ 228.61]          > fib(n: uint32): uint32
[ 228.62]          < return
[ 228.63]         < return
[ 228.64]         > fib(n: uint32): uint32
[ 228.65]         < return
[ 228.66]        < return
[ 228.66]       < return
[ 228.67]      < return
[ 228.68]     < return
[ 228.69]     > fib(n: uint32): uint32
[ 228.70]      > fib(n: uint32): uint32
[ 228.71]       > fib(n: uint32): uint32
[ 228.72]        > fib(n: uint32): uint32
[ 228.73]         > fib(n: uint32): uint32
[ 228.75]          > fib(n: uint32): uint32
[ 228.76]           > fib(n: uint32): uint32
[ 228.77]            > fib(n: uint32): uint32
[ 228.78]            < return
[ 228.79]            > fib(n: uint32): uint32
[ 228.80]            < return
[ 228.81]           < return
[ 228.81]           > fib(n: uint32): uint32
[ 228.82]           < return
[ 228.83]          < return
[ 228.85]          > fib(n: uint32): uint32
[ 228.86]           > fib(n: uint32): uint32
[ 228.87]           < return
[ 228.88]           > fib(n: uint32): uint32
[ 228.89]           < return
[ 228.90]          < return
[ 228.90]         < return
[ 228.91]         > fib(n: uint32): uint32
[ 228.92]          > fib(n: uint32): uint32
[ 228.93]           > fib(n: uint32): uint32
[ 228.94]           < return
[ 228.95]           > fib(n: uint32): uint32
[ 228.96]           < return
[ 228.97]          < return
[ 228.98]          > fib(n: uint32): uint32
[ 228.99]          < return
[ 229.00]         < return
[ 229.00]        < return
[ 229.01]        > fib(n: uint32): uint32
[ 229.03]         > fib(n: uint32): uint32
[ 229.04]          > fib(n: uint32): uint32
[ 229.05]           > fib(n: uint32): uint32
[ 229.06]           < return
[ 229.07]           > fib(n: uint32): uint32
[ 229.08]           < return
[ 229.09]          < return
[ 229.10]          > fib(n: uint32): uint32
[ 229.11]          < return
[ 229.12]         < return
[ 229.12]         > fib(n: uint32): uint32
[ 229.13]          > fib(n: uint32): uint32
[ 229.15]          < return
[ 229.15]          > fib(n: uint32): uint32
[ 229.16]          < return
[ 229.17]         < return
[ 229.18]        < return
[ 229.19]       < return
[ 229.19]       > fib(n: uint32): uint32
[ 229.21]        > fib(n: uint32): uint32
[ 229.22]         > fib(n: uint32): uint32
[ 229.23]          > fib(n: uint32): uint32
[ 229.24]           > fib(n: uint32): uint32
[ 229.25]           < return
[ 229.26]           > fib(n: uint32): uint32
[ 229.27]           < return
[ 229.28]          < return
[ 229.29]          > fib(n: uint32): uint32
[ 229.30]          < return
[ 229.31]         < return
[ 229.31]         > fib(n: uint32): uint32
[ 229.33]          > fib(n: uint32): uint32
[ 229.34]          < return
[ 229.34]          > fib(n: uint32): uint32
[ 229.35]          < return
[ 229.36]         < return
[ 229.37]        < return
[ 229.38]        > fib(n: uint32): uint32
[ 229.39]         > fib(n: uint32): uint32
[ 229.40]          > fib(n: uint32): uint32
[ 229.41]          < return
[ 229.42]          > fib(n: uint32): uint32
[ 229.43]          < return
[ 229.44]         < return
[ 229.45]         > fib(n: uint32): uint32
[ 229.46]         < return
[ 229.47]        < return
[ 229.47]       < return
[ 229.48]      < return
[ 229.49]      > fib(n: uint32): uint32
[ 229.50]       > fib(n: uint32): uint32
[ 229.51]        > fib(n: uint32): uint32
[ 229.53]         > fib(n: uint32): uint32
[ 229.54]          > fib(n: uint32): uint32
[ 229.55]           > fib(n: uint32): uint32
[ 229.56]           < return
[ 229.57]           > fib(n: uint32): uint32
[ 229.58]           < return
[ 229.59]          < return
[ 229.59]          > fib(n: uint32): uint32
[ 229.60]          < return
[ 229.61]         < return
[ 229.62]         > fib(n: uint32): uint32
[ 229.63]          > fib(n: uint32): uint32
[ 229.64]          < return
[ 229.65]          > fib(n: uint32): uint32
[ 229.66]          < return
[ 229.67]         < return
[ 229.68]        < return
[ 229.69]        > fib(n: uint32): uint32
[ 229.70]         > fib(n: uint32): uint32
[ 229.71]          > fib(n: uint32): uint32
[ 229.72]          < return
[ 229.73]          > fib(n: uint32): uint32
[ 229.74]          < return
[ 229.75]         < return
[ 229.75]         > fib(n: uint32): uint32
[ 229.76]         < return
[ 229.77]        < return
[ 229.78]       < return
[ 229.79]       > fib(n: uint32): uint32
[ 229.80]        > fib(n: uint32): uint32
[ 229.81]         > fib(n: uint32): uint32
[ 229.82]          > fib(n: uint32): uint32
[ 229.83]          < return
[ 229.84]          > fib(n: uint32): uint32
[ 229.85]          < return
[ 229.86]         < return
[ 229.87]         > fib(n: uint32): uint32
[ 229.88]         < return
[ 229.89]        < return
[ 229.90]        > fib(n: uint32): uint32
[ 229.91]         > fib(n: uint32): uint32
[ 229.92]         < return
[ 229.93]         > fib(n: uint32): uint32
[ 229.94]         < return
[ 229.94]        < return
[ 229.95]       < return
[ 229.96]      < return
[ 229.97]     < return
[ 229.97]    < return
[ 229.98]   < return
[ 229.99]   > fib(n: uint32): uint32
[ 230.00]    > fib(n: uint32): uint32
[ 230.01]     > fib(n: uint32): uint32
[ 230.03]      > fib(n: uint32): uint32
[ 230.04]       > fib(n: uint32): uint32
[ 230.05]        > fib(n: uint32): uint32
[ 230.06]         > fib(n: uint32): uint32
[ 230.07]          > fib(n: uint32): uint32
[ 230.09]           > fib(n: uint32): uint32
[ 230.10]            > fib(n: uint32): uint32
[ 230.11]             > fib(n: uint32): uint32
[ 230.12]             < return
[ 230.13]             > fib(n: uint32): uint32
[ 230.14]             < return
[ 230.15]            < return
[ 230.15]            > fib(n: uint32): uint32
[ 230.16]            < return
[ 230.17]           < return
[ 230.18]           > fib(n: uint32): uint32
[ 230.19]            > fib(n: uint32): uint32
[ 230.21]            < return
[ 230.21]            > fib(n: uint32): uint32
[ 230.22]            < return
[ 230.23]           < return
[ 230.24]          < return
[ 230.25]          > fib(n: uint32): uint32
[ 230.26]           > fib(n: uint32): uint32
[ 230.27]            > fib(n: uint32): uint32
[ 230.28]            < return
[ 230.29]            > fib(n: uint32): uint32
[ 230.30]            < return
[ 230.31]           < return
[ 230.32]           > fib(n: uint32): uint32
[ 230.33]           < return
[ 230.33]          < return
[ 230.34]         < return
[ 230.35]         > fib(n: uint32): uint32
[ 230.36]          > fib(n: uint32): uint32
[ 230.37]           > fib(n: uint32): uint32
[ 230.39]            > fib(n: uint32): uint32
[ 230.40]            < return
[ 230.41]            > fib(n: uint32): uint32
[ 230.41]            < return
[ 230.42]           < return
[ 230.43]           > fib(n: uint32): uint32
[ 230.44]           < return
[ 230.45]          < return
[ 230.46]          > fib(n: uint32): uint32
[ 230.47]           > fib(n: uint32): uint32
[ 230.48]           < return
[ 230.49]           > fib(n: uint32): uint32
[ 230.50]           < return
[ 230.51]          < return
[ 230.51]         < return
[ 230.52]        < return
[ 230.53]        > fib(n: uint32): uint32
[ 230.54]         > fib(n: uint32): uint32
[ 230.55]          > fib(n: uint32): uint32
[ 230.56]           > fib(n: uint32): uint32
[ 230.58]            > fib(n: uint32): uint32
[ 230.59]            < return
[ 230.59]            > fib(n: uint32): uint32
[ 230.61]            < return
[ 230.61]           < return
[ 230.62]           > fib(n: uint32): uint32
[ 230.63]           < return
[ 230.64]          < return
[ 230.65]          > fib(n: uint32): uint32
[ 230.66]           > fib(n: uint32): uint32
[ 230.67]           < return
[ 230.68]           > fib(n: uint32): uint32
[ 230.69]           < return
[ 230.70]          < return
[ 230.70]         < return
[ 230.71]         > fib(n: uint32): uint32
[ 230.72]          > fib(n: uint32): uint32
[ 230.74]           > fib(n: uint32): uint32
[ 230.75]           < return
[ 230.75]           > fib(n: uint32): uint32
[ 230.76]           < return
[ 230.77]          < return
[ 230.78]          > fib(n: uint32): uint32
[ 230.79]          < return
[ 230.80]         < return
[ 230.81]        < return
[ 230.81]       < return
[ 230.82]       > fib(n: uint32): uint32
[ 230.83]        > fib(n: uint32): uint32
[ 230.84]         > fib(n: uint32): uint32
[ 230.86]          > fib(n: uint32): uint32
[ 230.87]           > fib(n: uint32): uint32
[ 230.88]            > fib(n: uint32): uint32
[ 230.89]            < return
[ 230.90]            > fib(n: uint32): uint32
[ 230.91]            < return
[ 230.92]           < return
[ 230.93]           > fib(n: uint32): uint32
[ 230.94]           < return
[ 230.94]          < return
[ 230.95]          > fib(n: uint32): uint32
[ 230.96]           > fib(n: uint32): uint32
[ 230.97]           < return
[ 230.98]           > fib(n: uint32): uint32
[ 230.99]           < return
[ 231.00]          < return
[ 231.01]         < return
[ 231.02]         > fib(n: uint32): uint32
[ 231.03]          > fib(n: uint32): uint32
[ 231.04]           > fib(n: uint32): uint32
[ 231.05]           < return
[ 231.06]           > fib(n: uint32): uint32
[ 231.07]           < return
[ 231.08]          < return
[ 231.09]          > fib(n: uint32): uint32
[ 231.09]          < return
[ 231.10]         < return
[ 231.11]        < return
[ 231.12]        > fib(n: uint32): uint32
[ 231.13]         > fib(n: uint32): uint32
[ 231.14]          > fib(n: uint32): uint32
[ 231.15]           > fib(n: uint32): uint32
[ 231.16]           < return
[ 231.17]           > fib(n: uint32): uint32
[ 231.18]           < return
[ 231.19]          < return
[ 231.20]          > fib(n: uint32): uint32
[ 231.21]          < return
[ 231.22]         < return
[ 231.22]         > fib(n: uint32): uint32
[ 231.24]          > fib(n: uint32): uint32
[ 231.25]          < return
[ 231.25]          > fib(n: uint32): uint32
[ 231.27]          < return
[ 231.28]         < return
[ 231.28]        < return
[ 231.29]       < return
[ 231.30]      < return
[ 231.31]      > fib(n: uint32): uint32
[ 231.32]       > fib(n: uint32): uint32
[ 231.33]        > fib(n: uint32): uint32
[ 231.34]         > fib(n: uint32): uint32
[ 231.35]          > fib(n: uint32): uint32
[ 231.36]           > fib(n: uint32): uint32
[ 231.38]            > fib(n: uint32): uint32
[ 231.39]            < return
[ 231.40]            > fib(n: uint32): uint32
[ 231.41]            < return
[ 231.41]           < return
[ 231.42]           > fib(n: uint32): uint32
[ 231.43]           < return
[ 231.44]          < return
[ 231.45]          > fib(n: uint32): uint32
[ 231.46]           > fib(n: uint32): uint32
[ 231.47]           < return
[ 231.48]           > fib(n: uint32): uint32
[ 231.49]           < return
[ 231.50]          < return
[ 231.50]         < return
[ 231.51]         > fib(n: uint32): uint32
[ 231.52]          > fib(n: uint32): uint32
[ 231.54]           > fib(n: uint32): uint32
[ 231.55]           < return
[ 231.56]           > fib(n: uint32): uint32
[ 231.56]           < return
[ 231.57]          < return
[ 231.58]          > fib(n: uint32): uint32
[ 231.59]          < return
[ 231.60]         < return
[ 231.61]        < return
[ 231.61]        > fib(n: uint32): uint32
[ 231.63]         > fib(n: uint32): uint32
[ 231.64]          > fib(n: uint32): uint32
[ 231.65]           > fib(n: uint32): uint32
[ 231.66]           < return
[ 231.67]           > fib(n: uint32): uint32
[ 231.68]           < return
[ 231.69]          < return
[ 231.70]          > fib(n: uint32): uint32
[ 231.71]          < return
[ 231.71]         < return
[ 231.72]         > fib(n: uint32): uint32
[ 231.73]          > fib(n: uint32): uint32
[ 231.74]          < return
[ 231.75]          > fib(n: uint32): uint32
[ 231.76]          < return
[ 231.77]         < return
[ 231.78]        < return
[ 231.78]       < return
[ 231.79]       > fib(n: uint32): uint32
[ 231.81]        > fib(n: uint32): uint32
[ 231.82]         > fib(n: uint32): uint32
[ 231.83]          > fib(n: uint32): uint32
[ 231.84]           > fib(n: uint32): uint32
[ 231.85]           < return
[ 231.86]           > fib(n: uint32): uint32
[ 231.87]           < return
[ 231.88]          < return
[ 231.89]          > fib(n: uint32): uint32
[ 231.90]          < return
[ 231.90]         < return
[ 231.91]         > fib(n: uint32): uint32
[ 231.92]          > fib(n: uint32): uint32
[ 231.94]          < return
[ 231.94]          > fib(n: uint32): uint32
[ 231.95]          < return
[ 231.96]         < return
[ 231.97]        < return
[ 231.98]        > fib(n: uint32): uint32
[ 231.99]         > fib(n: uint32): uint32
[ 232.00]          > fib(n: uint32): uint32
[ 232.01]          < return
[ 232.02]          > fib(n: uint32): uint32
[ 232.03]          < return
[ 232.04]         < return
[ 232.05]         > fib(n: uint32): uint32
[ 232.06]         < return
[ 232.06]        < return
[ 232.07]       < return
[ 232.08]      < return
[ 232.09]     < return
[ 232.10]     > fib(n: uint32): uint32
[ 232.11]      > fib(n: uint32): uint32
[ 232.12]       > fib(n: uint32): uint32
[ 232.13]        > fib(n: uint32): uint32
[ 232.15]         > fib(n: uint32): uint32
[ 232.16]          > fib(n: uint32): uint32
[ 232.18]           > fib(n: uint32): uint32
[ 232.19]            > fib(n: uint32): uint32
[ 232.20]            < return
[ 232.21]            > fib(n: uint32): uint32
[ 232.22]            < return
[ 232.23]           < return
[ 232.23]           > fib(n: uint32): uint32
[ 232.25]           < return
[ 232.25]          < return
[ 232.26]          > fib(n: uint32): uint32
[ 232.27]           > fib(n: uint32): uint32
[ 232.28]           < return
[ 232.29]           > fib(n: uint32): uint32
[ 232.30]           < return
[ 232.31]          < return
[ 232.32]         < return
[ 232.32]         > fib(n: uint32): uint32
[ 232.34]          > fib(n: uint32): uint32
[ 232.35]           > fib(n: uint32): uint32
[ 232.36]           < return
[ 232.37]           > fib(n: uint32): uint32
[ 232.38]           < return
[ 232.39]          < return
[ 232.40]          > fib(n: uint32): uint32
[ 232.41]          < return
[ 232.41]         < return
[ 232.42]        < return
[ 232.43]        > fib(n: uint32): uint32
[ 232.44]         > fib(n: uint32): uint32
[ 232.45]          > fib(n: uint32): uint32
[ 232.47]           > fib(n: uint32): uint32
[ 232.48]           < return
[ 232.49]           > fib(n: uint32): uint32
[ 232.50]           < return
[ 232.50]          < return
[ 232.51]          > fib(n: uint32): uint32
[ 232.52]          < return
[ 232.53]         < return
[ 232.54]         > fib(n: uint32): uint32
[ 232.55]          > fib(n: uint32): uint32
[ 232.56]          < return
[ 232.57]          > fib(n: uint32): uint32
[ 232.58]          < return
[ 232.59]         < return
[ 232.59]        < return
[ 232.60]       < return
[ 232.61]       > fib(n: uint32): uint32
[ 232.62]        > fib(n: uint32): uint32
[ 232.63]         > fib(n: uint32): uint32
[ 232.64]          > fib(n: uint32): uint32
[ 232.66]           > fib(n: uint32): uint32
[ 232.67]           < return
[ 232.68]           > fib(n: uint32): uint32
[ 232.69]           < return
[ 232.69]          < return
[ 232.70]          > fib(n: uint32): uint32
[ 232.71]          < return
[ 232.72]         < return
[ 232.73]         > fib(n: uint32): uint32
[ 232.74]          > fib(n: uint32): uint32
[ 232.75]          < return
[ 232.76]          > fib(n: uint32): uint32
[ 232.77]          < return
[ 232.78]         < return
[ 232.78]        < return
[ 232.79]        > fib(n: uint32): uint32
[ 232.80]         > fib(n: uint32): uint32
[ 232.82]          > fib(n: uint32): uint32
[ 232.83]          < return
[ 232.84]          > fib(n: uint32): uint32
[ 232.85]          < return
[ 232.85]         < return
[ 232.86]         > fib(n: uint32): uint32
[ 232.87]         < return
[ 232.88]        < return
[ 232.89]       < return
[ 232.90]      < return
[ 232.90]      > fib(n: uint32): uint32
[ 232.91]       > fib(n: uint32): uint32
[ 232.93]        > fib(n: uint32): uint32
[ 232.94]         > fib(n: uint32): uint32
[ 232.95]          > fib(n: uint32): uint32
[ 232.96]           > fib(n: uint32): uint32
[ 232.97]           < return
[ 232.98]           > fib(n: uint32): uint32
[ 232.99]           < return
[ 233.00]          < return
[ 233.01]          > fib(n: uint32): uint32
[ 233.02]          < return
[ 233.03]         < return
[ 233.03]         > fib(n: uint32): uint32
[ 233.04]          > fib(n: uint32): uint32
[ 233.06]          < return
[ 233.06]          > fib(n: uint32): uint32
[ 233.07]          < return
[ 233.08]         < return
[ 233.09]        < return
[ 233.10]        > fib(n: uint32): uint32
[ 233.11]         > fib(n: uint32): uint32
[ 233.12]          > fib(n: uint32): uint32
[ 233.13]          < return
[ 233.14]          > fib(n: uint32): uint32
[ 233.15]          < return
[ 233.16]         < return
[ 233.17]         > fib(n: uint32): uint32
[ 233.18]         < return
[ 233.19]        < return
[ 233.19]       < return
[ 233.20]       > fib(n: uint32): uint32
[ 233.21]        > fib(n: uint32): uint32
[ 233.22]         > fib(n: uint32): uint32
[ 233.24]          > fib(n: uint32): uint32
[ 233.25]          < return
[ 233.26]          > fib(n: uint32): uint32
[ 233.27]          < return
[ 233.28]         < return
[ 233.29]         > fib(n: uint32): uint32
[ 233.30]         < return
[ 233.30]        < return
[ 233.31]        > fib(n: uint32): uint32
[ 233.32]         > fib(n: uint32): uint32
[ 233.33]         < return
[ 233.34]         > fib(n: uint32): uint32
[ 233.35]         < return
[ 233.36]        < return
[ 233.37]       < return
[ 233.38]      < return
[ 233.38]     < return
[ 233.39]    < return
[ 233.40]    > fib(n: uint32): uint32
[ 233.41]     > fib(n: uint32): uint32
[ 233.42]      > fib(n: uint32): uint32
[ 233.43]       > fib(n: uint32): uint32
[ 233.45]        > fib(n: uint32): uint32
[ 233.46]         > fib(n: uint32): uint32
[ 233.47]          > fib(n: uint32): uint32
[ 233.48]           > fib(n: uint32): uint32
[ 233.50]            > fib(n: uint32): uint32
[ 233.51]            < return
[ 233.51]            > fib(n: uint32): uint32
[ 233.53]            < return
[ 233.53]           < return
[ 233.54]           > fib(n: uint32): uint32
[ 233.55]           < return
[ 233.56]          < return
[ 233.57]          > fib(n: uint32): uint32
[ 233.58]           > fib(n: uint32): uint32
[ 233.59]           < return
[ 233.60]           > fib(n: uint32): uint32
[ 233.61]           < return
[ 233.62]          < return
[ 233.62]         < return
[ 233.63]         > fib(n: uint32): uint32
[ 233.64]          > fib(n: uint32): uint32
[ 233.66]           > fib(n: uint32): uint32
[ 233.67]           < return
[ 233.68]           > fib(n: uint32): uint32
[ 233.69]           < return
[ 233.69]          < return
[ 233.70]          > fib(n: uint32): uint32
[ 233.71]          < return
[ 233.72]         < return
[ 233.73]        < return
[ 233.74]        > fib(n: uint32): uint32
[ 233.75]         > fib(n: uint32): uint32
[ 233.76]          > fib(n: uint32): uint32
[ 233.77]           > fib(n: uint32): uint32
[ 233.78]           < return
[ 233.79]           > fib(n: uint32): uint32
[ 233.80]           < return
[ 233.81]          < return
[ 233.82]          > fib(n: uint32): uint32
[ 233.83]          < return
[ 233.84]         < return
[ 233.84]         > fib(n: uint32): uint32
[ 233.85]          > fib(n: uint32): uint32
[ 233.87]          < return
[ 233.87]          > fib(n: uint32): uint32
[ 233.88]          < return
[ 233.89]         < return
[ 233.90]        < return
[ 233.91]       < return
[ 233.91]       > fib(n: uint32): uint32
[ 233.93]        > fib(n: uint32): uint32
[ 233.94]         > fib(n: uint32): uint32
[ 233.95]          > fib(n: uint32): uint32
[ 233.96]           > fib(n: uint32): uint32
[ 233.97]           < return
[ 233.98]           > fib(n: uint32): uint32
[ 233.99]           < return
[ 234.00]          < return
[ 234.01]          > fib(n: uint32): uint32
[ 234.02]          < return
[ 234.03]         < return
[ 234.03]         > fib(n: uint32): uint32
[ 234.05]          > fib(n: uint32): uint32
[ 234.06]          < return
[ 234.06]          > fib(n: uint32): uint32
[ 234.08]          < return
[ 234.08]         < return
[ 234.09]        < return
[ 234.10]        > fib(n: uint32): uint32
[ 234.11]         > fib(n: uint32): uint32
[ 234.12]          > fib(n: uint32): uint32
[ 234.13]          < return
[ 234.14]          > fib(n: uint32): uint32
[ 234.15]          < return
[ 234.16]         < return
[ 234.17]         > fib(n: uint32): uint32
[ 234.18]         < return
[ 234.19]        < return
[ 234.19]       < return
[ 234.20]      < return
[ 234.21]      > fib(n: uint32): uint32
[ 234.22]       > fib(n: uint32): uint32
[ 234.23]        > fib(n: uint32): uint32
[ 234.25]         > fib(n: uint32): uint32
[ 234.26]          > fib(n: uint32): uint32
[ 234.27]           > fib(n: uint32): uint32
[ 234.28]           < return
[ 234.29]           > fib(n: uint32): uint32
[ 234.30]           < return
[ 234.31]          < return
[ 234.31]          > fib(n: uint32): uint32
[ 234.32]          < return
[ 234.33]         < return
[ 234.34]         > fib(n: uint32): uint32
[ 234.35]          > fib(n: uint32): uint32
[ 234.36]          < return
[ 234.37]          > fib(n: uint32): uint32
[ 234.38]          < return
[ 234.39]         < return
[ 234.40]        < return
[ 234.41]        > fib(n: uint32): uint32
[ 234.42]         > fib(n: uint32): uint32
[ 234.43]          > fib(n: uint32): uint32
[ 234.44]          < return
[ 234.45]          > fib(n: uint32): uint32
[ 234.46]          < return
[ 234.47]         < return
[ 234.47]         > fib(n: uint32): uint32
[ 234.49]         < return
[ 234.49]        < return
[ 234.50]       < return
[ 234.51]       > fib(n: uint32): uint32
[ 234.52]        > fib(n: uint32): uint32
[ 234.53]         > fib(n: uint32): uint32
[ 234.54]          > fib(n: uint32): uint32
[ 234.55]          < return
[ 234.56]          > fib(n: uint32): uint32
[ 234.57]          < return
[ 234.58]         < return
[ 234.59]         > fib(n: uint32): uint32
[ 234.60]         < return
[ 234.61]        < return
[ 234.62]        > fib(n: uint32): uint32
[ 234.63]         > fib(n: uint32): uint32
[ 234.64]         < return
[ 234.65]         > fib(n: uint32): uint32
[ 234.66]         < return
[ 234.67]        < return
[ 234.67]       < return
[ 234.68]      < return
[ 234.69]     < return
[ 234.70]     > fib(n: uint32): uint32
[ 234.71]      > fib(n: uint32): uint32
[ 234.72]       > fib(n: uint32): uint32
[ 234.73]        > fib(n: uint32): uint32
[ 234.74]         > fib(n: uint32): uint32
[ 234.76]          > fib(n: uint32): uint32
[ 234.77]           > fib(n: uint32): uint32
[ 234.78]           < return
[ 234.79]           > fib(n: uint32): uint32
[ 234.80]           < return
[ 234.81]          < return
[ 234.81]          > fib(n: uint32): uint32
[ 234.82]          < return
[ 234.83]         < return
[ 234.84]         > fib(n: uint32): uint32
[ 234.85]          > fib(n: uint32): uint32
[ 234.86]          < return
[ 234.87]          > fib(n: uint32): uint32
[ 234.88]          < return
[ 234.89]         < return
[ 234.90]        < return
[ 234.90]        > fib(n: uint32): uint32
[ 234.92]         > fib(n: uint32): uint32
[ 234.93]          > fib(n: uint32): uint32
[ 234.94]          < return
[ 234.95]          > fib(n: uint32): uint32
[ 234.96]          < return
[ 234.97]         < return
[ 234.97]         > fib(n: uint32): uint32
[ 234.98]         < return
[ 234.99]        < return
[ 235.00]       < return
[ 235.01]       > fib(n: uint32): uint32
[ 235.02]        > fib(n: uint32): uint32
[ 235.03]         > fib(n: uint32): uint32
[ 235.04]          > fib(n: uint32): uint32
[ 235.05]          < return
[ 235.06]          > fib(n: uint32): uint32
[ 235.07]          < return
[ 235.08]         < return
[ 235.09]         > fib(n: uint32): uint32
[ 235.10]         < return
[ 235.11]        < return
[ 235.12]        > fib(n: uint32): uint32
[ 235.13]         > fib(n: uint32): uint32
[ 235.14]         < return
[ 235.15]         > fib(n: uint32): uint32
[ 235.16]         < return
[ 235.16]        < return
[ 235.17]       < return
[ 235.18]      < return
[ 235.19]      > fib(n: uint32): uint32
[ 235.20]       > fib(n: uint32): uint32
[ 235.21]        > fib(n: uint32): uint32
[ 235.22]         > fib(n: uint32): uint32
[ 235.24]          > fib(n: uint32): uint32
[ 235.25]          < return
[ 235.25]          > fib(n: uint32): uint32
[ 235.26]          < return
[ 235.27]         < return
[ 235.28]         > fib(n: uint32): uint32
[ 235.29]         < return
[ 235.30]        < return
[ 235.31]        > fib(n: uint32): uint32
[ 235.32]         > fib(n: uint32): uint32
[ 235.33]         < return
[ 235.34]         > fib(n: uint32): uint32
[ 235.35]         < return
[ 235.36]        < return
[ 235.36]       < return
[ 235.37]       > fib(n: uint32): uint32
[ 235.38]        > fib(n: uint32): uint32
[ 235.40]         > fib(n: uint32): uint32
[ 235.42]         < return
[ 235.43]         > fib(n: uint32): uint32
[ 235.44]         < return
[ 235.45]        < return
[ 235.46]        > fib(n: uint32): uint32
[ 235.47]        < return
[ 235.48]       < return
[ 235.49]      < return
[ 235.49]     < return
[ 235.50]    < return
[ 235.51]   < return
[ 235.51]  < return
[ 235.55]  > typename.name(type: typename): .cstr
[ 235.56]  < return
[ 235.58]  > typename.file(type: typename): .cstr
[ 235.59]  < return
[ 235.59]  > typename.line(type: typename): int32
[ 235.60]  < return
[ 235.61]  > typename.base(type: typename): typename
[ 235.62]  < return
[ 235.63]  > typename.name(type: typename): .cstr
[ 235.64]  < return
[ 235.65]  > typename.file(type: typename): .cstr
[ 235.66]  < return
[ 235.67]  > typename.line(type: typename): int32
[ 235.68]  < return
[ 235.69]  > typename.base(type: typename): typename
[ 235.69]  < return
[ 235.71]  > typename.base(type: typename): typename
[ 235.72]  < return
[ 235.77]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.78]  < return
[ 235.79]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.80]  < return
[ 235.81]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.82]  < return
[ 235.83]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.84]  < return
[ 235.85]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.86]  < return
[ 235.87]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.88]  < return
[ 235.89]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.90]  < return
[ 235.91]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.91]  < return
[ 235.92]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 235.93]  < return
[ 235.94]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.95]  < return
[ 235.96]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.97]  < return
[ 235.98]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 235.99]  < return
[ 236.00]  > float64.sin(x: float64): float64
[ 236.02]  < return
[ 236.03]  > float64.cos(x: float64): float64
[ 236.05]  < return
[ 236.06]  > float64.tan(x: float64): float64
[ 236.06]  < return
[ 236.08]  > float64.log(x: float64): float64
[ 236.09]  < return
[ 236.09]  > float64.exp(x: float64): float64
[ 236.10]  < return
[ 236.12]  > float64.pow(x: float64, y: float64): float64
[ 236.13]  < return
[ 236.14]  > float64.sqrt(x: float64): float64
[ 236.14]  < return
[ 236.15]  > float64.atan2(x: float64, y: float64): float64
[ 236.17]  < return
[ 236.18]  > float32.sin(x: float32): float32
[ 236.19]  < return
[ 236.20]  > float32.cos(x: float32): float32
[ 236.21]  < return
[ 236.22]  > float32.tan(x: float32): float32
[ 236.22]  < return
[ 236.24]  > float32.log(x: float32): float32
[ 236.25]  < return
[ 236.25]  > float32.exp(x: float32): float32
[ 236.26]  < return
[ 236.27]  > float32.pow(x: float32, y: float32): float32
[ 236.28]  < return
[ 236.29]  > float32.sqrt(x: float32): float32
[ 236.30]  < return
[ 236.31]  > float32.atan2(x: float32, y: float32): float32
[ 236.32]  < return
[ 236.33]  > uint32.pop(value: int32): int32
[ 236.34]  < return
[ 236.34]  > uint32.swap(value: int32): int32
[ 236.35]  < return
[ 236.36]  > uint32.bsr(value: int32): int32
[ 236.37]  < return
[ 236.38]  > uint32.bsf(value: int32): int32
[ 236.39]  < return
[ 236.40]  > uint32.hib(value: int32): int32
[ 236.40]  < return
[ 236.41]  > uint32.lob(value: int32): int32
[ 236.42]  < return
[ 236.43]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 236.44]  < return
[ 236.45]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 236.46]  < return
[ 236.47]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 236.48]  < return
[ 236.49]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 236.50]  < return
[ 236.51]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.52]  < return
[ 236.53]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.54]  < return
[ 236.55]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.56]  < return
[ 236.56]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.57]  < return
[ 236.58]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 236.59]  < return
[ 236.60]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 236.61]  < return
[ 236.62]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.63]  < return
[ 236.64]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.65]  < return
[ 236.66]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.67]  < return
[ 236.68]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 236.69]  < return
[ 236.70]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 236.72]  < return
[ 236.74]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 236.76]  < return
[ 236.77]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 236.78]  < return
[ 236.79]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 236.80]  < return
[ 236.81]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 236.84]  < return
[ 236.85]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 236.87]  < return
[ 236.88]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 236.89]   > noError(ptr: pointer): void
[ 236.90]   < return
[ 236.91]   > halt(): void
[ 236.91]   < return
[ 236.92]  < return
[ 236.93]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 236.94]  < return
[ 236.95]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 236.96]   > stackOverflow(ptr: pointer): void
[ 236.97]    > stackOverflow(ptr: pointer): void
[ 236.98]     > stackOverflow(ptr: pointer): void
[ 236.99]      > stackOverflow(ptr: pointer): void
[ 237.00]       > stackOverflow(ptr: pointer): void
[ 237.01]        > stackOverflow(ptr: pointer): void
[ 237.02]         > stackOverflow(ptr: pointer): void
[ 237.03]          > stackOverflow(ptr: pointer): void
[ 237.04]           > stackOverflow(ptr: pointer): void
[ 237.05]            > stackOverflow(ptr: pointer): void
[ 237.06]             > stackOverflow(ptr: pointer): void
[ 237.07]              > stackOverflow(ptr: pointer): void
[ 237.08]               > stackOverflow(ptr: pointer): void
[ 237.09]                > stackOverflow(ptr: pointer): void
[ 237.10]                 > stackOverflow(ptr: pointer): void
[ 237.11]                  > stackOverflow(ptr: pointer): void
[ 237.12]                   > stackOverflow(ptr: pointer): void
[ 237.13]                    > stackOverflow(ptr: pointer): void
[ 237.14]                     > stackOverflow(ptr: pointer): void
[ 237.15]                      > stackOverflow(ptr: pointer): void
[ 237.16]                       > stackOverflow(ptr: pointer): void
[ 237.17]                        > stackOverflow(ptr: pointer): void
[ 237.18]                         > stackOverflow(ptr: pointer): void
[ 237.19]                          > stackOverflow(ptr: pointer): void
[ 237.20]                           > stackOverflow(ptr: pointer): void
[ 237.21]                            > stackOverflow(ptr: pointer): void
[ 237.22]                             > stackOverflow(ptr: pointer): void
[ 237.23]                              > stackOverflow(ptr: pointer): void
[ 237.24]                               > stackOverflow(ptr: pointer): void
[ 237.25]                                > stackOverflow(ptr: pointer): void
[ 237.26]                                 > stackOverflow(ptr: pointer): void
[ 237.27]                                  > stackOverflow(ptr: pointer): void
[ 237.28]                                   > stackOverflow(ptr: pointer): void
[ 237.29]                                    > stackOverflow(ptr: pointer): void
[ 237.30]                                     > stackOverflow(ptr: pointer): void
[ 237.31]                                      > stackOverflow(ptr: pointer): void
[ 237.32]                                       > stackOverflow(ptr: pointer): void
[ 237.33]                                        > stackOverflow(ptr: pointer): void
[ 237.34]                                         > stackOverflow(ptr: pointer): void
[ 237.35]                                          > stackOverflow(ptr: pointer): void
[ 237.36]                                           > stackOverflow(ptr: pointer): void
[ 237.37]                                            > stackOverflow(ptr: pointer): void
[ 237.38]                                             > stackOverflow(ptr: pointer): void
[ 237.39]                                              > stackOverflow(ptr: pointer): void
[ 237.40]                                               > stackOverflow(ptr: pointer): void
[ 237.41]                                                > stackOverflow(ptr: pointer): void
[ 237.42]                                                 > stackOverflow(ptr: pointer): void
[ 237.43]                                                  > stackOverflow(ptr: pointer): void
[ 237.44]                                                   > stackOverflow(ptr: pointer): void
[ 237.45]                                                    > stackOverflow(ptr: pointer): void
[ 237.46]                                                     > stackOverflow(ptr: pointer): void
[ 237.47]                                                      > stackOverflow(ptr: pointer): void
[ 237.48]                                                       > stackOverflow(ptr: pointer): void
[ 237.49]                                                        > stackOverflow(ptr: pointer): void
[ 237.50]                                                         > stackOverflow(ptr: pointer): void
[ 237.51]                                                          > stackOverflow(ptr: pointer): void
[ 237.52]                                                           > stackOverflow(ptr: pointer): void
[ 237.53]                                                            > stackOverflow(ptr: pointer): void
[ 237.54]                                                             > stackOverflow(ptr: pointer): void
[ 237.55]                                                              > stackOverflow(ptr: pointer): void
[ 237.56]                                                               > stackOverflow(ptr: pointer): void
[ 237.57]                                                                > stackOverflow(ptr: pointer): void
[ 237.58]                                                                 > stackOverflow(ptr: pointer): void
[ 237.59]                                                                  > stackOverflow(ptr: pointer): void
[ 237.60]                                                                  < return
[ 237.61]                                                                 < return
[ 237.61]                                                                < return
[ 237.62]                                                               < return
[ 237.63]                                                              < return
[ 237.63]                                                             < return
[ 237.64]                                                            < return
[ 237.65]                                                           < return
[ 237.65]                                                          < return
[ 237.66]                                                         < return
[ 237.66]                                                        < return
[ 237.67]                                                       < return
[ 237.68]                                                      < return
[ 237.68]                                                     < return
[ 237.69]                                                    < return
[ 237.70]                                                   < return
[ 237.70]                                                  < return
[ 237.71]                                                 < return
[ 237.72]                                                < return
[ 237.72]                                               < return
[ 237.73]                                              < return
[ 237.73]                                             < return
[ 237.74]                                            < return
[ 237.75]                                           < return
[ 237.75]                                          < return
[ 237.76]                                         < return
[ 237.76]                                        < return
[ 237.77]                                       < return
[ 237.78]                                      < return
[ 237.78]                                     < return
[ 237.79]                                    < return
[ 237.80]                                   < return
[ 237.80]                                  < return
[ 237.81]                                 < return
[ 237.82]                                < return
[ 237.82]                               < return
[ 237.83]                              < return
[ 237.84]                             < return
[ 237.84]                            < return
[ 237.85]                           < return
[ 237.85]                          < return
[ 237.86]                         < return
[ 237.87]                        < return
[ 237.87]                       < return
[ 237.88]                      < return
[ 237.89]                     < return
[ 237.89]                    < return
[ 237.90]                   < return
[ 237.91]                  < return
[ 237.91]                 < return
[ 237.92]                < return
[ 237.92]               < return
[ 237.93]              < return
[ 237.94]             < return
[ 237.94]            < return
[ 237.95]           < return
[ 237.96]          < return
[ 237.96]         < return
[ 237.97]        < return
[ 237.97]       < return
[ 237.98]      < return
[ 237.99]     < return
[ 237.99]    < return
[ 238.00]   < return
[ 238.00]  < return
[ 238.01]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.02]   > divisionByZero(args: pointer): void
[ 238.03]   < return
[ 238.04]  < return
[ 238.05]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.06]   > invalidInstruction(args: pointer): void
[ 238.06]   < return
[ 238.07]  < return
[ 238.08]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.09]   > invalidMemoryAccess(args: pointer): void
[ 238.10]   < return
[ 238.10]  < return
[ 238.11]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 238.12]   > abortExecution(args: pointer): void
[ 238.14]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 238.23]    < return
[ 238.23]   < return
[ 238.24]  < return
[ 238.37]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 238.38]  < return
[ 238.39]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 238.46]  < return
[ 238.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 238.54]  < return
[ 238.55]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 238.58]  < return
[ 238.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 238.62]  < return
[ 238.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 238.66]  < return
[ 238.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 238.69]  < return
[ 238.72]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.73]  < return
[ 238.74]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.75]  < return
[ 238.76]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.77]  < return
[ 238.78]  > lenSlice(values: int64[]): int32
[ 238.79]  < return
[ 238.80]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.81]  < return
[ 238.82]  > lenSlice(values: int64[]): int32
[ 238.83]  < return
[ 238.84]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.85]  < return
[ 238.87]  > lenSlice(values: int64[]): int32
[ 238.88]  < return
[ 238.89]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.90]  < return
[ 238.91]  > lenSlice(values: int64[]): int32
[ 238.92]  < return
[ 238.93]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.94]  < return
[ 238.95]  > lenSlice(values: int64[]): int32
[ 238.96]  < return
[ 238.97]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 238.98]  < return
[ 239.02]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.03]  < return
[ 239.05]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.06]  < return
[ 239.08]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.09]  < return
[ 239.11]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.12]  < return
[ 239.14]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.15]  < return
[ 239.17]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.18]  < return
[ 239.20]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.21]  < return
[ 239.23]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.24]  < return
[ 239.30]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.31]  < return
[ 239.32]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.34]  < return
[ 239.35]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.37]  < return
[ 239.38]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.39]  < return
[ 239.41]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.42]  < return
[ 239.44]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.45]  < return
[ 239.47]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.48]  < return
[ 239.49]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.51]  < return
[ 239.56]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.58]  < return
[ 239.59]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.61]  < return
[ 239.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.63]  < return
[ 239.65]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.66]  < return
[ 239.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.69]  < return
[ 239.71]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.72]  < return
[ 239.74]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.75]  < return
[ 239.76]  > nthSlice(idx: int32, values: int64[]): int64
[ 239.78]  < return
[ 239.83]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.85]  < return
[ 239.86]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.87]  < return
[ 239.89]  > nthFixed(idx: int32, values: int64[7]): int64
[ 239.90]  < return
[ 239.92]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.93]  < return
[ 239.95]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.96]  < return
[ 239.97]  > nthArray(idx: int32, values: int64[*]): int64
[ 239.99]  < return
[ 240.00]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.01]  < return
[ 240.03]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.04]  < return
[ 240.10]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.11]  < return
[ 240.13]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.14]  < return
[ 240.16]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.18]  < return
[ 240.20]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.21]  < return
[ 240.22]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.24]  < return
[ 240.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.26]  < return
[ 240.28]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.29]  < return
[ 240.31]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.32]  < return
[ 240.38]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.39]  < return
[ 240.41]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.42]  < return
[ 240.44]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.45]  < return
[ 240.46]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.48]  < return
[ 240.49]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.51]  < return
[ 240.52]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.54]  < return
[ 240.55]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.56]  < return
[ 240.58]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.59]  < return
[ 240.65]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.66]  < return
[ 240.68]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.69]  < return
[ 240.71]  > nthFixed(idx: int32, values: int64[7]): int64
[ 240.72]  < return
[ 240.74]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.75]  < return
[ 240.76]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.78]  < return
[ 240.79]  > nthArray(idx: int32, values: int64[*]): int64
[ 240.80]  < return
[ 240.82]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.83]  < return
[ 240.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 240.86]  < return
[ 240.92]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 240.94]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(1)
	test/lang/method.ci:58: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 241.01]   < return
[ 241.02]  < return
[ 241.03]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.04]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(1)
	test/lang/method.ci:59: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 241.12]   < return
[ 241.13]  < return
[ 241.14]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 241.15]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:63: debug: extension.staticMethod
[ 241.16]   < return
[ 241.18]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 241.19]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(2)
	test/lang/method.ci:65: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:75: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 241.31]    < return
[ 241.32]   < return
[ 241.33]  < return
[ 241.34]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.35]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:69: debug: extension.virtualMethod
[ 241.37]   < return
[ 241.38]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.39]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(2)
	test/lang/method.ci:71: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:76: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 241.51]    < return
[ 241.52]   < return
[ 241.53]  < return
[ 241.54]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 241.55]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:7: debug: staticMethod: int32(3)
	test/lang/method.ci:79: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 241.62]   < return
[ 241.63]  < return
[ 241.64]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.66]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:80: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 241.73]   < return
[ 241.74]  < return
[ 241.75]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 241.76]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:26: debug: virtualMethod: int32(3)
	test/lang/method.ci:81: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 241.83]   < return
[ 241.84]  < return
[ 242.99]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 243.01]  < return
[ 243.03]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 243.05]  < return
[ 243.07]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 243.09]  < return
[ 243.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 243.14]  < return
[ 243.17]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 243.20]  < return
[ 243.22]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 243.25]  < return
[ 243.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 243.30]  < return
[ 243.32]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 243.34]  < return
[ 243.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 243.39]  < return
[ 243.41]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 243.44]  < return
[ 243.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 243.50]  < return
[ 243.52]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 243.54]  < return
[ 243.62]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 243.64]  < return
[ 243.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 243.69]  < return
[ 243.73]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 243.75]  < return
[ 243.78]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 243.80]  < return
[ 243.83]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 243.85]  < return
[ 243.90]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 243.92]  < return
[ 243.95]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 243.97]  < return
[ 244.00]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 244.03]  < return
[ 244.06]  > Math.floor(x: float64): float64
[ 244.06]   > Math.modf(x: float64, intPart: float64): float64
[ 244.07]   < return
[ 244.08]  < return
[ 244.09]  > Math.floor(x: float64): float64
[ 244.10]   > Math.modf(x: float64, intPart: float64): float64
[ 244.11]   < return
[ 244.12]  < return
[ 244.13]  > Math.floor(x: float64): float64
[ 244.14]   > Math.modf(x: float64, intPart: float64): float64
[ 244.15]   < return
[ 244.15]  < return
[ 244.17]  > Math.floor(x: float64): float64
[ 244.18]   > Math.modf(x: float64, intPart: float64): float64
[ 244.19]    > Math.modf(x: float64, intPart: float64): float64
[ 244.19]    < return
[ 244.20]   < return
[ 244.21]  < return
[ 244.22]  > Math.floor(x: float64): float64
[ 244.23]   > Math.modf(x: float64, intPart: float64): float64
[ 244.24]    > Math.modf(x: float64, intPart: float64): float64
[ 244.24]    < return
[ 244.25]   < return
[ 244.26]  < return
[ 244.27]  > Math.floor(x: float64): float64
[ 244.28]   > Math.modf(x: float64, intPart: float64): float64
[ 244.28]    > Math.modf(x: float64, intPart: float64): float64
[ 244.29]    < return
[ 244.30]   < return
[ 244.31]  < return
[ 244.41]  > Math.abs(x: float64): float64
[ 244.41]  < return
[ 244.43]  > Math.abs(x: float64): float64
[ 244.43]  < return
[ 244.45]  > Math.abs(x: float64): float64
[ 244.46]  < return
[ 244.47]  > Math.abs(x: float32): float32
[ 244.48]  < return
[ 244.49]  > Math.abs(x: float32): float32
[ 244.50]  < return
[ 244.52]  > Math.abs(x: float32): float32
[ 244.52]  < return
[ 244.54]  > Math.min(a: float32, b: float32): float32
[ 244.55]  < return
[ 244.56]  > Math.max(a: float32, b: float32): float32
[ 244.57]  < return
[ 244.59]  > Math.min(a: float64, b: float64): float64
[ 244.60]  < return
[ 244.61]  > Math.max(a: float64, b: float64): float64
[ 244.62]  < return
[ 244.64]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 244.65]  < return
[ 244.67]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 244.67]  < return
[ 244.73]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 244.74]  < return
[ 244.78]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 244.79]  < return
[ 244.82]  > Math.min(data: float64[]): float64
[ 244.83]  < return
[ 244.86]  > Math.min(data: float64[]): float64
[ 244.89]  < return
[ 244.91]  > Math.max(data: float64[]): float64
[ 244.92]  < return
[ 244.95]  > Math.max(data: float64[]): float64
[ 244.99]  < return
[ 245.01]  > Math.sum(data: float64[]): float64
[ 245.02]  < return
[ 245.04]  > Math.sum(data: float64[]): float64
[ 245.05]  < return
[ 245.07]  > Math.sum(data: float64[]): float64
[ 245.09]  < return
[ 245.12]  > Math.sum(data: float64[]): float64
[ 245.16]  < return
[ 245.19]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.20]  < return
[ 245.28]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.30]  < return
[ 245.33]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 245.36]  < return
[ 245.38]  > Math.sinCos(arg: float64, quad: int32): float64
[ 245.41]  < return
[ 245.43]  > Math.abs(x: float64): float64
[ 245.43]  < return
[ 245.45]  > Math.sinCos(arg: float64, quad: int32): float64
[ 245.47]  < return
[ 245.49]  > Math.tan(arg: float64): float64
[ 245.50]   > Math.modf(x: float64, intPart: float64): float64
[ 245.51]   < return
[ 245.53]  < return
[ 245.55]  > Math.sinh(x: float64): float64
[ 245.56]   > float64.exp(x: float64): float64
[ 245.57]   < return
[ 245.58]   > float64.exp(x: float64): float64
[ 245.58]   < return
[ 245.59]  < return
[ 245.61]  > Math.cosh(x: float64): float64
[ 245.62]   > float64.exp(x: float64): float64
[ 245.63]   < return
[ 245.63]   > float64.exp(x: float64): float64
[ 245.64]   < return
[ 245.64]  < return
[ 245.66]  > Math.asin(x: float64): float64
[ 245.67]   > float64.sqrt(x: float64): float64
[ 245.68]   < return
[ 245.69]   > float64.atan2(x: float64, y: float64): float64
[ 245.69]   < return
[ 245.70]  < return
[ 245.72]  > Math.asin(x: float64): float64
[ 245.73]   > float64.sqrt(x: float64): float64
[ 245.74]   < return
[ 245.75]   > float64.atan2(x: float64, y: float64): float64
[ 245.75]   < return
[ 245.76]  < return
[ 245.78]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 245.79]  < return
[ 245.81]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 245.82]  < return
[ 245.84]  > Math.absMod(val: float64, mod: float64): float64
[ 245.85]  < return
[ 245.86]  > Math.absMod(val: float64, mod: float64): float64
[ 245.87]  < return
[ 245.89]  > Math.absMod(val: float64, mod: float64): float64
[ 245.90]  < return
[ 245.91]  > Math.absMod(val: float64, mod: float64): float64
[ 245.92]  < return
[ 245.94]  > Math.absMod(val: float64, mod: float64): float64
[ 245.94]  < return
[ 245.96]  > Math.absMod(val: float64, mod: float64): float64
[ 245.97]  < return
[ 245.98]  > Math.absMod(val: float64, mod: float64): float64
[ 245.99]  < return
[ 246.01]  > Math.absMod(val: float64, mod: float64): float64
[ 246.02]  < return
[ 246.03]  > Math.absMod(val: float64, mod: float64): float64
[ 246.04]  < return
[ 246.06]  > Math.absMod(val: float64, mod: float64): float64
[ 246.06]  < return
[ 246.08]  > Math.absMod(val: float64, mod: float64): float64
[ 246.09]  < return
[ 246.10]  > Math.absMod(val: float32, mod: float32): float32
[ 246.11]  < return
[ 246.13]  > Math.absMod(val: float32, mod: float32): float32
[ 246.14]  < return
[ 246.15]  > Math.absMod(val: float32, mod: float32): float32
[ 246.16]  < return
[ 246.18]  > Math.absMod(val: float32, mod: float32): float32
[ 246.18]  < return
[ 246.20]  > Math.absMod(val: float32, mod: float32): float32
[ 246.21]  < return
[ 246.22]  > Math.absMod(val: float32, mod: float32): float32
[ 246.23]  < return
[ 246.25]  > Math.absMod(val: float32, mod: float32): float32
[ 246.26]  < return
[ 246.27]  > Math.absMod(val: float32, mod: float32): float32
[ 246.28]  < return
[ 246.30]  > Math.absMod(val: float32, mod: float32): float32
[ 246.30]  < return
[ 246.32]  > Math.absMod(val: float32, mod: float32): float32
[ 246.33]  < return
[ 246.34]  > Math.absMod(val: float32, mod: float32): float32
[ 246.35]  < return
[ 246.36]  > halt(): void
[ 246.37]  < return
[ 246.38] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:50: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:66: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:3: empty: function(<empty>)
test/lang/function.ci:6: funAdd: function(<funAdd>)
test/lang/function.ci:11: funAddResult: int32(9)
test/lang/function.ci:14: funAddRef: function(<funAdd>)
test/lang/function.ci:17: funAddRefResult: int32(10)
test/lang/function.ci:20: funMul: function(<funMul>)
test/lang/function.ci:23: funMulResult: int32(12)
test/lang/function.ci:26: funMulRef: function(<funMul>)
test/lang/function.ci:29: funMulRefResult: int32(14)
test/lang/function.ci:32: funMul: function(<funMul>)
test/lang/function.ci:37: fib: function(<fib>)
test/lang/function.ci:45: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(225208)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(224904)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:11: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:25: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:30: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:40: globalFunction: function(<globalFunction>)
test/lang/method.ci:44: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:62: staticMethod: function(<staticMethod>)
test/lang/method.ci:68: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<?>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 342755(334.7 Kb)
memory[heap] @053ae3; size: 1229851(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 326928(319.3 Kb)
memory[code] @000000; size: 15489(15.1 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @053af8; size: 1229808(1.2 Mb)

---------- Profile functions: 79/113, coverage: 69.91%
::[.005c20, .005c20): exec(2), time(0.015 ms): halt(): void
::[.005f68, .005f68): exec(3), time(0.025 ms): typename.base(type: typename): typename
::[.006168, .006168): exec(2), time(0.018 ms): typename.file(type: typename): .cstr
::[.006368, .006368): exec(2), time(0.018 ms): typename.line(type: typename): int32
::[.006568, .006568): exec(2), time(0.020 ms): typename.name(type: typename): .cstr
::[.006d00, .006d00): exec(40), time(1.470 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0075e0, .0075e0): exec(7), time(1.305 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007880, .007880): exec(8), time(0.069 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007bb8, .007bb8): exec(2), time(0.018 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.007ef0, .007ef0): exec(2), time(0.018 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008220, .008220): exec(1), time(0.009 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0084c8, .0084c8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0086d0, .0086d0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008838, .008838): exec(0), time(0.000 ms): System.rand(): int32
::[.0089a0, .0089a0): exec(0), time(0.000 ms): System.time(): int32
::[.008b08, .008b08): exec(0), time(0.000 ms): System.clock(): int32
::[.008c70, .008c70): exec(0), time(0.000 ms): System.millis(): int64
::[.008e70, .008e70): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0091a8, .0091a8): exec(7), time(0.060 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0094d8, .0094d8): exec(7), time(0.059 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0096d8, .0096d8): exec(1), time(0.009 ms): uint32.pop(value: int32): int32
::[.0098d8, .0098d8): exec(1), time(0.008 ms): uint32.swap(value: int32): int32
::[.009ad8, .009ad8): exec(1), time(0.008 ms): uint32.bsr(value: int32): int32
::[.009cd8, .009cd8): exec(1), time(0.008 ms): uint32.bsf(value: int32): int32
::[.009ed8, .009ed8): exec(1), time(0.008 ms): uint32.hib(value: int32): int32
::[.00a0d8, .00a0d8): exec(1), time(0.011 ms): uint32.lob(value: int32): int32
::[.00a400, .00a400): exec(1), time(0.008 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a728, .00a728): exec(1), time(0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00a928, .00a928): exec(1), time(0.009 ms): float32.sin(x: float32): float32
::[.00ab28, .00ab28): exec(1), time(0.008 ms): float32.cos(x: float32): float32
::[.00ad28, .00ad28): exec(1), time(0.009 ms): float32.tan(x: float32): float32
::[.00af28, .00af28): exec(1), time(0.008 ms): float32.log(x: float32): float32
::[.00b128, .00b128): exec(1), time(0.008 ms): float32.exp(x: float32): float32
::[.00b3c0, .00b3c0): exec(1), time(0.008 ms): float32.pow(x: float32, y: float32): float32
::[.00b5c0, .00b5c0): exec(1), time(0.009 ms): float32.sqrt(x: float32): float32
::[.00b858, .00b858): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00ba50, .00ba50): exec(1), time(0.022 ms): float64.sin(x: float64): float64
::[.00bc48, .00bc48): exec(1), time(0.013 ms): float64.cos(x: float64): float64
::[.00be40, .00be40): exec(1), time(0.008 ms): float64.tan(x: float64): float64
::[.00c038, .00c038): exec(1), time(0.011 ms): float64.log(x: float64): float64
::[.00c230, .00c230): exec(5), time(0.037 ms): float64.exp(x: float64): float64
::[.00c4c0, .00c4c0): exec(1), time(0.010 ms): float64.pow(x: float64, y: float64): float64
::[.00c6b8, .00c6b8): exec(3), time(0.023 ms): float64.sqrt(x: float64): float64
::[.00c948, .00c948): exec(3), time(0.028 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:66:[.04fd10, .04fd6e): exec(8), time(0.078 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.04fd70, .04fdc6): exec(10), time(0.100 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.04fdc8, .04fde0): exec(6), time(0.182-0.092 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.04fde0, .04fdf2): exec(3), time(0.026 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.04fdf8, .04fe0a): exec(4), time(0.036 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.04fe10, .04fe2b): exec(11), time(0.098 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.04fe30, .04fe4b): exec(11), time(0.103 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.04fe50, .04fe61): exec(1), time(0.009 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.04fe68, .04fe79): exec(1), time(0.009 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.04fe80, .04fe91): exec(1), time(0.010 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.04fe98, .04fea9): exec(1), time(0.009 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.04feb0, .04fece): exec(2), time(0.019 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.04fed0, .04feee): exec(2), time(0.020 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.04fef0, .04ff38): exec(2), time(0.048 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.04ff38, .04ff80): exec(2), time(0.049 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.04ff80, .04ffa8): exec(4), time(0.088 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.04ffa8, .04ffd7): exec(3), time(0.075 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.04ffd8, .050011): exec(1), time(0.011 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.050018, .050051): exec(1), time(0.012 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.050058, .0501a7): exec(2), time(0.054 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.0501a8, .05031b): exec(1), time(0.044-0.008 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.050320, .050411): exec(1), time(0.042-0.015 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.050418, .050463): exec(1), time(0.036-0.013 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.050468, .05050e): exec(2), time(0.088-0.029 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.050510, .050517): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.050518, .05051f): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.050520, .05059b): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.0505a0, .0505bf): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.0505c0, .050624): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.050628, .05064e): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.050650, .050682): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.050688, .0506ba): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.0506c0, .050709): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.050710, .05078e): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.050790, .0507cf): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.0507d0, .050817): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.050818, .05083c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.050840, .05084e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.050850, .0508a4): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.0508b8, .050b49): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.050b50, .050b67): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.050b68, .050b99): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.050bb0, .050bc9): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.050bd0, .050bd7): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.050bd8, .050be5): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:27:[.050be8, .050c19): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:40:[.050c20, .050c35): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:52:[.050c38, .050dd9): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:3:[.050de8, .050de9): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:6:[.050df0, .050df8): exec(2), time(0.022 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:32:[.050df8, .050e00): exec(2), time(0.021 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:37:[.050e00, .050e36): exec(753), time(14.479 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.050e38, .050e39): exec(1), time(0.010 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.050e40, .050e58): exec(64-64), time(1.042 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.050e58, .050e64): exec(1-1), time(0.010 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.050e68, .050eac): exec(1-1), time(0.112-0.087 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.050eb0, .050ebd): exec(1-1), time(0.010 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.050ec0, .050ec2): exec(1-1), time(0.010 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.050ec8, .050ecc): exec(5), time(0.053 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.050ed0, .050edc): exec(21), time(0.277 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.050ee0, .050eec): exec(21), time(0.270 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.050ef0, .050efc): exec(14), time(0.174 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:6:[.050f30, .050f57): exec(3), time(0.330-0.270 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:25:[.050f60, .050f87): exec(4), time(0.413-0.335 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:30:[.050f88, .050faf): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.050fb0, .050fd7): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:62:[.050fd8, .05101a): exec(1), time(0.189-0.156 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:68:[.051020, .05105f): exec(1), time(0.186-0.153 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.05105f, .053ae3): exec(1), time(25.989-19.896 ms): .main

---------- Profile statements: 886/1136, coverage: 77.99%
lib/stdlib.ci:68:[.04fd19, .04fd1a) exec(8), time(0.040-0.040 ms): <assertEq+9>
lib/stdlib.ci:67:[.04fd10, .04fd1a) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:71:[.04fd1e, .04fd29) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:72:[.04fd29, .04fd34) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:73:[.04fd34, .04fd37) exec(0), time(0.000 ms): <assertEq+36>
::[.04fd37, .04fd43) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:70:[.04fd1a, .04fd43) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:75:[.04fd43, .04fd69) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.04fd88, .04fd99) exec(3), time(0.044-0.044 ms): <modf+24>
lib/std/math.ci:26:[.04fd99, .04fda0) exec(3), time(0.000 ms): <modf+41>
lib/std/math.ci:27:[.04fda0, .04fda3) exec(3), time(0.015-0.015 ms): <modf+48>
lib/std/math.ci:24:[.04fd80, .04fda7) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.04fda7, .04fdab) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.04fdab, .04fdaf) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.04fd70, .04fdaf) exec(10-3), time(0.006-0.006 ms): <modf+0>
lib/std/math.ci:32:[.04fdaf, .04fdbb) exec(7), time(0.006-0.006 ms): <modf+63>
lib/std/math.ci:33:[.04fdbb, .04fdc3) exec(7), time(0.004-0.004 ms): <modf+75>
lib/std/math.ci:34:[.04fdc3, .04fdc6) exec(7), time(0.035-0.035 ms): <modf+83>
lib/std/math.ci:48:[.04fdc8, .04fdc9) exec(6), time(0.001-0.001 ms): <floor+0>
lib/std/math.ci:49:[.04fdc9, .04fddd) exec(6), time(0.128-0.128 ms): <floor+1>
lib/std/math.ci:50:[.04fddd, .04fde0) exec(6), time(0.030-0.030 ms): <floor+21>
lib/std/math.ci:79:[.04fde8, .04fdee) exec(1), time(0.005-0.005 ms): <abs+8>
lib/std/math.ci:78:[.04fde0, .04fdee) exec(3-1), time(0.001-0.001 ms): <abs+0>
lib/std/math.ci:81:[.04fdee, .04fdf2) exec(2), time(0.011-0.011 ms): <abs+14>
lib/std/math.ci:87:[.04fe00, .04fe06) exec(1), time(0.006-0.006 ms): <abs+8>
lib/std/math.ci:86:[.04fdf8, .04fe06) exec(4-1), time(0.000 ms): <abs+0>
lib/std/math.ci:89:[.04fe06, .04fe0a) exec(3), time(0.015-0.015 ms): <abs+14>
lib/std/math.ci:95:[.04fe1f, .04fe27) exec(4), time(0.020-0.020 ms): <absMod+15>
lib/std/math.ci:94:[.04fe10, .04fe27) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:97:[.04fe27, .04fe2b) exec(7), time(0.037-0.037 ms): <absMod+23>
lib/std/math.ci:103:[.04fe3f, .04fe47) exec(4), time(0.021-0.021 ms): <absMod+15>
lib/std/math.ci:102:[.04fe30, .04fe47) exec(11-4), time(0.007-0.007 ms): <absMod+0>
lib/std/math.ci:105:[.04fe47, .04fe4b) exec(7), time(0.040-0.040 ms): <absMod+23>
lib/std/math.ci:117:[.04fe59, .04fe5d) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:116:[.04fe50, .04fe5d) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.04fe5d, .04fe61) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.04fe71, .04fe75) exec(1), time(0.005-0.005 ms): <min+9>
lib/std/math.ci:124:[.04fe68, .04fe75) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.04fe75, .04fe79) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.04fe89, .04fe8d) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.04fe80, .04fe8d) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.04fe8d, .04fe91) exec(1), time(0.005-0.005 ms): <max+13>
lib/std/math.ci:147:[.04fea1, .04fea5) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.04fe98, .04fea5) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:149:[.04fea5, .04fea9) exec(1), time(0.005-0.005 ms): <max+13>
lib/std/math.ci:161:[.04feb9, .04febd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.04feb0, .04febd) exec(2), time(0.001-0.001 ms): <clamp+0>
lib/std/math.ci:164:[.04fec6, .04feca) exec(1), time(0.005-0.005 ms): <clamp+22>
lib/std/math.ci:163:[.04febd, .04feca) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:166:[.04feca, .04fece) exec(1), time(0.006-0.006 ms): <clamp+26>
lib/std/math.ci:172:[.04fed9, .04fedd) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.04fed0, .04fedd) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:175:[.04fee6, .04feea) exec(1), time(0.005-0.005 ms): <clamp+22>
lib/std/math.ci:174:[.04fedd, .04feea) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:177:[.04feea, .04feee) exec(1), time(0.005-0.005 ms): <clamp+26>
lib/std/math.ci:203:[.04fef8, .04fefd) exec(1), time(0.005-0.005 ms): <min+8>
lib/std/math.ci:202:[.04fef0, .04fefd) exec(2-1), time(0.001-0.001 ms): <min+0>
lib/std/math.ci:205:[.04fefd, .04ff00) exec(1), time(0.001-0.001 ms): <min+13>
lib/std/math.ci:208:[.04ff19, .04ff24) exec(2), time(0.001-0.001 ms): <min+41>
lib/std/math.ci:207:[.04ff09, .04ff24) exec(8-2), time(0.006-0.006 ms): <min+25>
lib/std/math.ci:206:[.04ff24, .04ff28) exec(8), time(0.004-0.004 ms): <min+52>
lib/std/math.ci:206:[.04ff28, .04ff31) exec(9), time(0.005-0.005 ms): <min+56>
lib/std/math.ci:206:[.04ff00, .04ff35) exec(1), time(0.001-0.001 ms): <min+16>
lib/std/math.ci:211:[.04ff35, .04ff38) exec(1), time(0.006-0.006 ms): <min+69>
lib/std/math.ci:217:[.04ff40, .04ff45) exec(1), time(0.006-0.006 ms): <max+8>
lib/std/math.ci:216:[.04ff38, .04ff45) exec(2-1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:219:[.04ff45, .04ff48) exec(1), time(0.001-0.001 ms): <max+13>
lib/std/math.ci:222:[.04ff61, .04ff6c) exec(2), time(0.001-0.001 ms): <max+41>
lib/std/math.ci:221:[.04ff51, .04ff6c) exec(8-2), time(0.005-0.005 ms): <max+25>
lib/std/math.ci:220:[.04ff6c, .04ff70) exec(8), time(0.003-0.003 ms): <max+52>
lib/std/math.ci:220:[.04ff70, .04ff79) exec(9), time(0.005-0.005 ms): <max+56>
lib/std/math.ci:220:[.04ff48, .04ff7d) exec(1), time(0.001-0.001 ms): <max+16>
lib/std/math.ci:225:[.04ff7d, .04ff80) exec(1), time(0.005-0.005 ms): <max+69>
lib/std/math.ci:230:[.04ff80, .04ff81) exec(4), time(0.000 ms): <sum+0>
lib/std/math.ci:232:[.04ff86, .04ff94) exec(13), time(0.013-0.013 ms): <sum+6>
lib/std/math.ci:231:[.04ff94, .04ff98) exec(13), time(0.007-0.007 ms): <sum+20>
lib/std/math.ci:231:[.04ff98, .04ffa1) exec(17), time(0.013-0.013 ms): <sum+24>
lib/std/math.ci:231:[.04ff81, .04ffa5) exec(4), time(0.004-0.004 ms): <sum+1>
lib/std/math.ci:234:[.04ffa5, .04ffa8) exec(4), time(0.021-0.021 ms): <sum+37>
lib/std/math.ci:257:[.04ffa8, .04ffa9) exec(3), time(0.001-0.001 ms): <eval+0>
lib/std/math.ci:259:[.04ffb3, .04ffc4) exec(11), time(0.011-0.011 ms): <eval+11>
lib/std/math.ci:258:[.04ffc4, .04ffc8) exec(11), time(0.004-0.004 ms): <eval+28>
lib/std/math.ci:258:[.04ffc8, .04ffd0) exec(14), time(0.009-0.009 ms): <eval+32>
lib/std/math.ci:258:[.04ffa9, .04ffd4) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:261:[.04ffd4, .04ffd7) exec(3), time(0.016-0.016 ms): <eval+44>
lib/std/math.ci:268:[.04ffed, .04fff5) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.04ffe1, .04fff5) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:273:[.050005, .05000d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.04fff9, .05000d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.04ffd8, .05000d) exec(1), time(0.001-0.001 ms): <cmp+0>
lib/std/math.ci:276:[.05000d, .050011) exec(1), time(0.005-0.005 ms): <cmp+53>
lib/std/math.ci:283:[.05002d, .050035) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.050021, .050035) exec(1), time(0.001-0.001 ms): <cmp+9>
lib/std/math.ci:288:[.050045, .05004d) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.050039, .05004d) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.050018, .05004d) exec(1), time(0.002-0.002 ms): <cmp+0>
lib/std/math.ci:291:[.05004d, .050051) exec(1), time(0.006-0.006 ms): <cmp+53>
lib/std/math.ci:309:[.050058, .05005a) exec(2), time(0.001-0.001 ms): <sinCos+0>
lib/std/math.ci:311:[.050062, .050063) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.050063, .05006b) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.05005a, .05006b) exec(2), time(0.002-0.002 ms): <sinCos+2>
lib/std/math.ci:315:[.05006b, .05006c) exec(2), time(0.001-0.001 ms): <sinCos+19>
lib/std/math.ci:316:[.05006c, .050084) exec(2), time(0.002-0.002 ms): <sinCos+20>
lib/std/math.ci:318:[.050094, .050095) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.050095, .0500a7) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.0500a7, .0500ab) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.0500ab, .0500ac) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.0500ac, .0500ca) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.0500ca, .0500dc) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.0500e4, .0500e7) exec(2), time(0.000 ms): <sinCos+140>
lib/std/math.ci:328:[.0500e7, .0500ef) exec(2), time(0.002-0.002 ms): <sinCos+143>
lib/std/math.ci:329:[.0500ef, .0500f6) exec(2), time(0.002-0.002 ms): <sinCos+151>
lib/std/math.ci:330:[.0500f6, .0500fc) exec(2), time(0.002-0.002 ms): <sinCos+158>
lib/std/math.ci:317:[.050084, .050100) exec(2), time(0.002-0.002 ms): <sinCos+44>
lib/std/math.ci:333:[.050108, .050116) exec(1), time(0.001-0.001 ms): <sinCos+176>
lib/std/math.ci:332:[.050100, .050116) exec(2-1), time(0.000 ms): <sinCos+168>
lib/std/math.ci:336:[.050122, .050123) exec(1), time(0.001-0.001 ms): <sinCos+202>
lib/std/math.ci:335:[.050116, .050123) exec(2-1), time(0.001-0.001 ms): <sinCos+190>
lib/std/math.ci:339:[.050123, .050128) exec(2), time(0.002-0.002 ms): <sinCos+203>
lib/std/math.ci:340:[.050128, .050168) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:341:[.050168, .05019b) exec(2), time(0.004-0.004 ms): <sinCos+272>
lib/std/math.ci:342:[.05019b, .0501a7) exec(2), time(0.012-0.012 ms): <sinCos+323>
lib/std/math.ci:365:[.0501a8, .0501a9) exec(1), time(0.000 ms): <tan+0>
lib/std/math.ci:366:[.0501a9, .0501aa) exec(1), time(0.000 ms): <tan+1>
lib/std/math.ci:369:[.0501b2, .0501b7) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.0501b7, .0501c1) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.0501aa, .0501c1) exec(1), time(0.000 ms): <tan+2>
lib/std/math.ci:372:[.0501c1, .0501d9) exec(1), time(0.001-0.001 ms): <tan+25>
lib/std/math.ci:374:[.0501d9, .0501da) exec(1), time(0.001-0.001 ms): <tan+49>
lib/std/math.ci:375:[.0501da, .0501ea) exec(1), time(0.015-0.015 ms): <tan+50>
lib/std/math.ci:376:[.0501ea, .0501f3) exec(1), time(0.001-0.001 ms): <tan+66>
lib/std/math.ci:380:[.050207, .050215) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:381:[.050215, .05021f) exec(1), time(0.001-0.001 ms): <tan+109>
lib/std/math.ci:384:[.05022f, .05023a) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.05023a, .050244) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.050254, .050262) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.050262, .05026d) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.050248, .05026d) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.050223, .05026d) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.0501fb, .05026d) exec(1), time(0.001-0.001 ms): <tan+83>
lib/std/math.ci:378:[.0501f3, .05026d) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.05026d, .050272) exec(1), time(0.000 ms): <tan+197>
lib/std/math.ci:393:[.050272, .0502b2) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.0502b2, .0502d9) exec(1), time(0.001-0.001 ms): <tan+266>
lib/std/math.ci:398:[.0502ea, .0502f3) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.0502e2, .0502f3) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.0502f3, .050301) exec(1), time(0.000 ms): <tan+331>
lib/std/math.ci:396:[.0502d9, .050301) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.05030a, .050314) exec(0), time(0.000 ms): <tan+354>
lib/std/math.ci:402:[.050301, .050314) exec(1), time(0.000 ms): <tan+345>
lib/std/math.ci:405:[.050314, .05031b) exec(1), time(0.005-0.005 ms): <tan+364>
lib/std/math.ci:421:[.050320, .050321) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:423:[.050329, .05032e) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.05032e, .050338) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.050321, .050338) exec(1), time(0.000 ms): <sinh+1>
lib/std/math.ci:428:[.050348, .05035f) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.050338, .05035f) exec(1), time(0.001-0.001 ms): <sinh+24>
lib/std/math.ci:431:[.05035f, .050360) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:433:[.050370, .05038a) exec(1), time(0.027-0.027 ms): <sinh+80>
lib/std/math.ci:436:[.05038e, .050393) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.050393, .0503c8) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.0503c8, .0503f3) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.050360, .0503f7) exec(1), time(0.027-0.027 ms): <sinh+64>
lib/std/math.ci:442:[.050400, .05040a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.0503f7, .05040a) exec(1), time(0.000 ms): <sinh+215>
lib/std/math.ci:444:[.05040a, .050411) exec(1), time(0.005-0.005 ms): <sinh+234>
lib/std/math.ci:450:[.050420, .050425) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.050418, .050425) exec(1), time(0.001-0.001 ms): <cosh+0>
lib/std/math.ci:453:[.050435, .050448) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.050425, .050448) exec(1), time(0.001-0.001 ms): <cosh+13>
lib/std/math.ci:455:[.050448, .050463) exec(1), time(0.031-0.031 ms): <cosh+48>
lib/std/math.ci:466:[.050470, .050474) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.050468, .050474) exec(2), time(0.002-0.002 ms): <asin+0>
lib/std/math.ci:469:[.050474, .050475) exec(2), time(0.001-0.001 ms): <asin+12>
lib/std/math.ci:471:[.05047d, .050487) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.050487, .05048c) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.050475, .05048c) exec(2), time(0.001-0.001 ms): <asin+13>
lib/std/math.ci:477:[.05049c, .0504a5) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.05048c, .0504a5) exec(2), time(0.002-0.002 ms): <asin+36>
lib/std/math.ci:480:[.0504a5, .0504b8) exec(2), time(0.027-0.027 ms): <asin+61>
lib/std/math.ci:482:[.0504c8, .0504e6) exec(0), time(0.000 ms): <asin+96>
lib/std/math.ci:485:[.0504ea, .0504f4) exec(2), time(0.026-0.026 ms): <asin+130>
lib/std/math.ci:481:[.0504b8, .0504f4) exec(2-2), time(0.000 ms): <asin+80>
lib/std/math.ci:489:[.0504fd, .050507) exec(0), time(0.000 ms): <asin+149>
lib/std/math.ci:488:[.0504f4, .050507) exec(2), time(0.000 ms): <asin+140>
lib/std/math.ci:491:[.050507, .05050e) exec(2), time(0.012-0.012 ms): <asin+159>
::[.050513, .050516) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.050510, .050517) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.05051b, .05051e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.050518, .05051f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.05053f, .050544) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.050544, .05054c) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.050559, .050566) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.05054c, .05056b) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.050520, .05056f) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.05056f, .050574) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.050574, .05057c) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.050589, .050596) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.05057c, .05059b) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.0505a0, .0505ab) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.0505b2, .0505ba) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.0505ab, .0505bf) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.0505c0, .0505d7) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.0505d7, .0505e7) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.0505e7, .0505f6) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.0505f6, .050609) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.050614, .05061f) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.050609, .050624) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.050634, .050638) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.050628, .050638) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.050638, .050639) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.05063d, .050641) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.050641, .05064b) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.050639, .05064b) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.05064b, .05064e) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.050665, .050668) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.050655, .050668) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.050668, .05066c) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.05066c, .050676) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.050650, .05067a) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.05067a, .050682) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.050688, .05068d) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.0506a2, .0506a5) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.050692, .0506a5) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.0506a5, .0506a9) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.0506a9, .0506b3) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.05068d, .0506b7) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.0506b7, .0506ba) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.0506df, .0506ea) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.0506c5, .0506ea) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.0506ea, .0506ee) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.0506ee, .0506fa) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.0506c0, .0506fe) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.0506fe, .050709) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.050710, .05071d) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.05071d, .05072a) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.050733, .05073e) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.05072a, .05073e) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.050763, .05076e) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.050743, .05076e) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.05076e, .050772) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.050772, .05077b) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.05073e, .05077f) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.05077f, .05078e) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.050790, .050791) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.050796, .0507ac) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.0507b8, .0507bc) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.0507ac, .0507bc) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.0507bc, .0507c0) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.0507c0, .0507c8) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.050791, .0507cc) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.0507cc, .0507cf) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.0507df, .0507ea) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.0507d0, .0507ea) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.0507f9, .050804) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.0507ea, .050804) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.050804, .050817) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.050818, .05083c) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.050840, .05084e) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.05085e, .050862) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.050855, .050862) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.050862, .05086e) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.05086e, .050876) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.050876, .05087a) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.05087a, .050884) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.050850, .050888) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.050891, .050899) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.050888, .050899) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.050899, .0508a0) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.0508a0, .0508a4) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.0508b8, .0508b9) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.0508b9, .0508bd) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.0508bd, .0508c0) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.0508c0, .0508f6) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.0508f6, .05092b) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.05092f, .05094a) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.05094a, .050951) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.050951, .050959) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.05092b, .050959) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.050961, .050976) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.050959, .050976) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.050976, .050980) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.050980, .050987) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.050992, .05099c) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.050987, .05099c) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.0509a7, .0509af) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.0509cd, .050a01) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.050a01, .050a0c) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.050a0c, .050a14) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.050a14, .050a1c) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.050a1c, .050a24) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.0509c9, .050a24) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.0509af, .050a24) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.050a24, .050a58) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.050a58, .050a63) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.050a63, .050a6b) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.05099c, .050a6b) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.050a6f, .050aa3) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.050aa3, .050aae) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.050aae, .050ab6) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.050ab6, .050abe) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.050abe, .050ac6) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.050a6b, .050ac6) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.050acb, .050aff) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.050aff, .050b10) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.050b10, .050b18) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.050b18, .050b1c) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.050b1c, .050b25) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.050ac6, .050b29) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.050b32, .050b3a) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.050b29, .050b3a) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.050b3a, .050b41) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.050b41, .050b49) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.050b50, .050b67) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.050b68, .050b69) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.050b71, .050b78) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.050b78, .050b7d) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.050b69, .050b7d) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.050b7d, .050b99) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.050bb0, .050bc9) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.050bd3, .050bd6) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.050bd0, .050bd7) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.050bdb, .050bde) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.050bde, .050be1) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.050be1, .050be4) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.050bd8, .050be5) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:32:[.050beb, .050bee) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:32:[.050bee, .050bf1) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:32:[.050bf1, .050bf4) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:33:[.050bf4, .050bf7) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:33:[.050bf7, .050bfa) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:33:[.050bfa, .050bfd) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:33:[.050bfd, .050c00) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:34:[.050c00, .050c03) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:34:[.050c03, .050c06) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:34:[.050c06, .050c09) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:34:[.050c09, .050c0c) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:35:[.050c0c, .050c0f) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:35:[.050c0f, .050c12) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:35:[.050c12, .050c15) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:35:[.050c15, .050c18) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:31:[.050be8, .050c19) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:41:[.050c25, .050c2a) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:41:[.050c2a, .050c2f) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:41:[.050c2f, .050c34) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:41:[.050c20, .050c35) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:54:[.050c3c, .050c41) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:54:[.050c41, .050c4a) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:54:[.050c4a, .050c53) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:54:[.050c53, .050c5c) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:55:[.050c5c, .050c65) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:55:[.050c65, .050c6e) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:55:[.050c6e, .050c77) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:55:[.050c77, .050c80) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:56:[.050c80, .050c89) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:56:[.050c89, .050c92) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:56:[.050c92, .050c9b) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:56:[.050c9b, .050ca4) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:57:[.050ca4, .050cad) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:57:[.050cad, .050cb6) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:57:[.050cb6, .050cbf) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:57:[.050cbf, .050cc8) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:53:[.050c38, .050cc8) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:61:[.050d08, .050d4c) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:62:[.050d4c, .050d90) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:63:[.050d90, .050dd4) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:59:[.050cc8, .050dd9) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:7:[.050df0, .050df8) exec(2), time(0.016-0.016 ms): <funAdd+0>
test/lang/function.ci:33:[.050df8, .050e00) exec(2), time(0.016-0.016 ms): <funMul+0>
test/lang/function.ci:39:[.050e0c, .050e10) exec(377), time(2.396-2.396 ms): <fib+12>
test/lang/function.ci:38:[.050e00, .050e10) exec(753-377), time(0.656-0.656 ms): <fib+0>
test/lang/function.ci:41:[.050e10, .050e36) exec(376-375), time(14.474-14.474 ms): <fib+16>
test/stdc/tryExec.ci:15:[.050e40, .050e44) exec(64-1), time(0.030-0.030 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.050e44, .050e53) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.050e58, .050e5f) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.050e6c, .050e73) exec(1), time(0.001-0.001 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.050e73, .050e7a) exec(1), time(0.000 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.050e7a, .050e81) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.050e68, .050e81) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.050e81, .050ea7) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.050eb0, .050eb5) exec(1), time(0.001-0.001 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.050eb5, .050eb8) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.050ec0, .050ec2) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.050ec8, .050ecc) exec(5), time(0.033-0.033 ms): <lenSlice+0>
test/lang/array.ci:104:[.050ed0, .050edc) exec(21), time(0.174-0.174 ms): <nthFixed+0>
test/lang/array.ci:105:[.050ee0, .050eec) exec(21), time(0.179-0.179 ms): <nthArray+0>
test/lang/array.ci:106:[.050ef0, .050efc) exec(14), time(0.117-0.117 ms): <nthSlice+0>
test/lang/method.ci:7:[.050f30, .050f56) exec(3), time(0.300-0.300 ms): <staticMethod+0>
test/lang/method.ci:26:[.050f60, .050f86) exec(4), time(0.373-0.373 ms): <virtualMethod+0>
test/lang/method.ci:31:[.050f88, .050fae) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:41:[.050fb0, .050fd6) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:63:[.050fd8, .050ffb) exec(1), time(0.025-0.025 ms): <staticMethod+0>
test/lang/method.ci:65:[.051009, .051019) exec(1), time(0.150-0.150 ms): <staticMethod+49>
test/lang/method.ci:64:[.050ffb, .051019) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:69:[.051020, .051043) exec(1), time(0.024-0.024 ms): <virtualMethod+0>
test/lang/method.ci:71:[.051051, .05105e) exec(1), time(0.147-0.147 ms): <virtualMethod+49>
test/lang/method.ci:70:[.051043, .05105e) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.05105f, .05106d) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.05106d, .05107b) exec(1), time(0.002-0.002 ms): <.main+14>
::[.051084, .05108b) exec(1), time(0.002-0.002 ms): <.main+37>
::[.05108b, .051090) exec(1), time(0.001-0.001 ms): <.main+44>
::[.051090, .051095) exec(1), time(0.001-0.001 ms): <.main+49>
lib/std/string.ci:223:[.05107b, .051095) exec(1-1), time(0.000 ms): <.main+28>
test/lang/initByRef.ci:7:[.051095, .0510a2) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/member.ci:35:[.0510a2, .0510a7) exec(1), time(0.001-0.001 ms): <.main+67>
test/lang/member.ci:38:[.0510a7, .0510b0) exec(1), time(0.001-0.001 ms): <.main+72>
test/lang/member.ci:41:[.0510b0, .0510b9) exec(1), time(0.001-0.001 ms): <.main+81>
test/lang/member.ci:47:[.0510c2, .0510cb) exec(1), time(0.001-0.001 ms): <.main+99>
test/lang/member.ci:47:[.0510b9, .0510cb) exec(1-1), time(0.000 ms): <.main+90>
test/lang/member.ci:50:[.0510d4, .0510dd) exec(1), time(0.001-0.001 ms): <.main+117>
test/lang/member.ci:50:[.0510cb, .0510dd) exec(1-1), time(0.000 ms): <.main+108>
test/lang/method.ci:11:[.0510dd, .0510e6) exec(1), time(0.001-0.001 ms): <.main+126>
test/lang/emit.ci:3:[.0510e6, .0510e7) exec(1), time(0.000 ms): <.main+135>
test/lang/emit.ci:4:[.0510e7, .0510e8) exec(1), time(0.001-0.001 ms): <.main+136>
test/lang/emit.ci:6:[.0510e8, .0510ed) exec(1), time(0.000 ms): <.main+137>
test/lang/emit.ci:7:[.0510ed, .0510f2) exec(1), time(0.000 ms): <.main+142>
test/lang/emit.ci:9:[.0510f2, .0510f7) exec(1), time(0.002-0.002 ms): <.main+147>
test/lang/emit.ci:10:[.0510f7, .051102) exec(1), time(0.001-0.001 ms): <.main+152>
test/lang/emit.ci:17:[.051102, .051107) exec(1), time(0.001-0.001 ms): <.main+163>
test/lang/emit.ci:18:[.051107, .05110d) exec(1), time(0.001-0.001 ms): <.main+168>
test/lang/emit.ci:19:[.05110d, .051117) exec(1), time(0.001-0.001 ms): <.main+174>
test/lang/emit.ci:20:[.051117, .051120) exec(1), time(0.000 ms): <.main+184>
test/lang/emit.ci:23:[.051120, .05112a) exec(1), time(0.001-0.001 ms): <.main+193>
test/lang/inlineMacros.ci:10:[.05112a, .05112f) exec(1), time(0.000 ms): <.main+203>
test/lang/inlineMacros.ci:11:[.05112f, .051134) exec(1), time(0.001-0.001 ms): <.main+208>
test/lang/inlineMacros.ci:12:[.051134, .051139) exec(1), time(0.000 ms): <.main+213>
test/lang/inlineMacros.ci:13:[.051139, .05113e) exec(1), time(0.000 ms): <.main+218>
test/lang/inlineMacros.ci:15:[.05113e, .05113f) exec(1), time(0.000 ms): <.main+223>
test/lang/inlineMacros.ci:16:[.05113f, .051140) exec(1), time(0.001-0.001 ms): <.main+224>
test/lang/inlineMacros.ci:17:[.051140, .051141) exec(1), time(0.000 ms): <.main+225>
test/lang/inlineMacros.ci:19:[.051141, .051146) exec(1), time(0.000 ms): <.main+226>
test/lang/inlineMacros.ci:20:[.051146, .051148) exec(1), time(0.000 ms): <.main+231>
test/lang/inlineMacros.ci:21:[.051148, .051152) exec(1), time(0.002-0.002 ms): <.main+233>
test/lang/inlineMacros.ci:23:[.051152, .05115b) exec(1), time(0.001-0.001 ms): <.main+243>
test/lang/inlineMacros.ci:24:[.05115b, .051160) exec(1), time(0.001-0.001 ms): <.main+252>
test/lang/inlineMacros.ci:25:[.051160, .051171) exec(1), time(0.003-0.003 ms): <.main+257>
test/lang/inlineMacros.ci:27:[.051171, .051189) exec(1), time(0.004-0.004 ms): <.main+274>
test/lang/inlineMacros.ci:28:[.051189, .05119b) exec(1), time(0.003-0.003 ms): <.main+298>
test/lang/inlineMacros.ci:29:[.05119b, .0511b9) exec(1), time(0.004-0.004 ms): <.main+316>
test/lang/inlineMacros.ci:31:[.0511b9, .0511da) exec(1), time(0.005-0.005 ms): <.main+346>
test/lang/inlineMacros.ci:32:[.0511da, .0511f5) exec(1), time(0.006-0.006 ms): <.main+379>
test/lang/inlineMacros.ci:33:[.0511f5, .05121c) exec(1), time(0.007-0.007 ms): <.main+406>
test/lang/inlineMacros.ci:35:[.05121c, .05123d) exec(1), time(0.005-0.005 ms): <.main+445>
test/lang/inlineMacros.ci:36:[.05123d, .051258) exec(1), time(0.004-0.004 ms): <.main+478>
test/lang/inlineMacros.ci:37:[.051258, .05127f) exec(1), time(0.007-0.007 ms): <.main+505>
test/lang/inlineMacros.ci:41:[.05127f, .051294) exec(1), time(0.003-0.003 ms): <.main+544>
test/lang/inlineMacros.ci:42:[.051294, .0512a5) exec(1), time(0.002-0.002 ms): <.main+565>
test/lang/inlineMacros.ci:43:[.0512a5, .0512b0) exec(1), time(0.004-0.004 ms): <.main+582>
test/lang/inlineMacros.ci:44:[.0512b0, .0512bb) exec(1), time(0.004-0.004 ms): <.main+593>
test/lang/inlineMacros.ci:45:[.0512bb, .0512da) exec(1), time(0.006-0.006 ms): <.main+604>
test/lang/inlineMacros.ci:46:[.0512da, .0512f9) exec(1), time(0.007-0.007 ms): <.main+635>
test/lang/inlineMacros.ci:50:[.0512f9, .051337) exec(1), time(0.003-0.003 ms): <.main+666>
test/lang/inlineMacros.ci:51:[.051337, .051375) exec(1), time(0.009-0.009 ms): <.main+728>
test/lang/inlineMacros.ci:52:[.051375, .0513a7) exec(1), time(0.003-0.003 ms): <.main+790>
test/lang/inlineMacros.ci:53:[.0513a7, .0513d9) exec(1), time(0.009-0.009 ms): <.main+840>
test/lang/inlineMacros.ci:54:[.0513d9, .05141f) exec(1), time(0.004-0.004 ms): <.main+890>
test/lang/inlineMacros.ci:55:[.05141f, .051465) exec(1), time(0.011-0.011 ms): <.main+960>
test/lang/inlineMacros.ci:59:[.051465, .0514be) exec(1), time(0.014-0.014 ms): <.main+1030>
test/lang/inlineMacros.ci:60:[.0514be, .051517) exec(1), time(0.016-0.016 ms): <.main+1119>
test/lang/inlineMacros.ci:61:[.051517, .051564) exec(1), time(0.015-0.015 ms): <.main+1208>
test/lang/inlineMacros.ci:62:[.051564, .0515b1) exec(1), time(0.015-0.015 ms): <.main+1285>
test/lang/inlineMacros.ci:63:[.0515b1, .051612) exec(1), time(0.018-0.018 ms): <.main+1362>
test/lang/inlineMacros.ci:64:[.051612, .051673) exec(1), time(0.019-0.019 ms): <.main+1459>
test/lang/inlineMacros.ci:68:[.051673, .0516cc) exec(1), time(0.014-0.014 ms): <.main+1556>
test/lang/inlineMacros.ci:69:[.0516cc, .051725) exec(1), time(0.015-0.015 ms): <.main+1645>
test/lang/inlineMacros.ci:70:[.051725, .051772) exec(1), time(0.015-0.015 ms): <.main+1734>
test/lang/inlineMacros.ci:71:[.051772, .0517bf) exec(1), time(0.015-0.015 ms): <.main+1811>
test/lang/inlineMacros.ci:72:[.0517bf, .051820) exec(1), time(0.017-0.017 ms): <.main+1888>
test/lang/inlineMacros.ci:73:[.051820, .051881) exec(1), time(0.018-0.018 ms): <.main+1985>
test/lang/overload.inline.ci:9:[.051881, .051886) exec(1), time(0.001-0.001 ms): <.main+2082>
test/lang/overload.inline.ci:10:[.051886, .05188b) exec(1), time(0.000 ms): <.main+2087>
test/lang/overload.inline.ci:11:[.05188b, .051890) exec(1), time(0.000 ms): <.main+2092>
test/lang/overload.inline.ci:12:[.051890, .051895) exec(1), time(0.001-0.001 ms): <.main+2097>
test/lang/overload.inline.ci:13:[.051895, .05189a) exec(1), time(0.000 ms): <.main+2102>
test/lang/overload.inline.ci:28:[.05189a, .0518a3) exec(1), time(0.000 ms): <.main+2107>
test/lang/overload.inline.ci:29:[.0518a3, .0518b9) exec(1), time(0.003-0.003 ms): <.main+2116>
test/lang/initByRef.ci:8:[.0518b9, .0518be) exec(1), time(0.001-0.001 ms): <.main+2138>
test/lang/initByRef.ci:9:[.0518be, .0518c3) exec(1), time(0.001-0.001 ms): <.main+2143>
test/lang/initByRef.ci:10:[.0518c3, .0518cd) exec(1), time(0.001-0.001 ms): <.main+2148>
test/lang/initByRef.ci:12:[.0518cd, .0518d0) exec(1), time(0.001-0.001 ms): <.main+2158>
test/lang/initByRef.ci:13:[.0518d0, .0518d2) exec(1), time(0.000 ms): <.main+2161>
test/lang/initByRef.ci:14:[.0518d2, .0518d4) exec(1), time(0.000 ms): <.main+2163>
test/lang/initByRef.ci:16:[.0518d4, .0518d9) exec(1), time(0.001-0.001 ms): <.main+2165>
test/lang/initByRef.ci:17:[.0518d9, .0518de) exec(1), time(0.000 ms): <.main+2170>
test/lang/initByRef.ci:18:[.0518de, .0518e8) exec(1), time(0.001-0.001 ms): <.main+2175>
test/lang/initByRef.ci:19:[.0518e8, .0518ed) exec(1), time(0.000 ms): <.main+2185>
test/lang/initByRef.ci:20:[.0518ed, .0518f2) exec(1), time(0.001-0.001 ms): <.main+2190>
test/lang/initByRef.ci:21:[.0518f2, .0518f7) exec(1), time(0.000 ms): <.main+2195>
test/lang/initByRef.ci:23:[.0518f7, .0518fc) exec(1), time(0.000 ms): <.main+2200>
test/lang/initByRef.ci:24:[.0518fc, .051906) exec(1), time(0.001-0.001 ms): <.main+2205>
test/lang/initByRef.ci:25:[.051906, .05190b) exec(1), time(0.001-0.001 ms): <.main+2215>
test/lang/initByRef.ci:27:[.05190b, .05190f) exec(1), time(0.000 ms): <.main+2220>
test/lang/initByRef.ci:28:[.05190f, .051911) exec(1), time(0.000 ms): <.main+2224>
test/lang/initByRef.ci:29:[.051911, .051913) exec(1), time(0.001-0.001 ms): <.main+2226>
test/lang/initByRef.ci:30:[.051913, .051915) exec(1), time(0.000 ms): <.main+2228>
test/lang/initByRef.ci:31:[.051915, .051917) exec(1), time(0.000 ms): <.main+2230>
test/lang/initByRef.ci:32:[.051917, .051919) exec(1), time(0.001-0.001 ms): <.main+2232>
test/lang/initByRef.ci:35:[.051919, .05191e) exec(1), time(0.000 ms): <.main+2234>
test/lang/initByRef.ci:36:[.05191e, .051923) exec(1), time(0.001-0.001 ms): <.main+2239>
test/lang/initByRef.ci:37:[.051923, .051928) exec(1), time(0.000 ms): <.main+2244>
test/lang/initByRef.ci:38:[.051928, .05192d) exec(1), time(0.000 ms): <.main+2249>
test/lang/initByRef.ci:39:[.05192d, .051932) exec(1), time(0.001-0.001 ms): <.main+2254>
test/lang/initByRef.ci:40:[.051932, .051937) exec(1), time(0.000 ms): <.main+2259>
test/lang/initByRef.ci:41:[.051937, .05193c) exec(1), time(0.000 ms): <.main+2264>
test/lang/initByRef.ci:42:[.05193c, .051941) exec(1), time(0.001-0.001 ms): <.main+2269>
test/lang/initByRef.ci:43:[.051941, .051946) exec(1), time(0.000 ms): <.main+2274>
test/lang/initByRef.ci:44:[.051946, .05194b) exec(1), time(0.000 ms): <.main+2279>
test/lang/initByRef.ci:45:[.05194b, .051950) exec(1), time(0.001-0.001 ms): <.main+2284>
test/lang/initByRef.ci:46:[.051950, .051955) exec(1), time(0.000 ms): <.main+2289>
test/lang/initByRef.ci:47:[.051955, .05195a) exec(1), time(0.000 ms): <.main+2294>
test/lang/initByRef.ci:48:[.05195a, .05195f) exec(1), time(0.001-0.001 ms): <.main+2299>
test/lang/initByRef.ci:49:[.05195f, .051964) exec(1), time(0.000 ms): <.main+2304>
test/lang/initByRef.ci:50:[.051964, .051969) exec(1), time(0.001-0.001 ms): <.main+2309>
test/lang/initByRef.ci:51:[.051969, .05196e) exec(1), time(0.001-0.001 ms): <.main+2314>
test/lang/initByRef.ci:52:[.05196e, .051973) exec(1), time(0.000 ms): <.main+2319>
test/lang/initByRef.ci:55:[.051973, .05197d) exec(1), time(0.001-0.001 ms): <.main+2324>
test/lang/initByRef.ci:56:[.05197d, .051987) exec(1), time(0.001-0.001 ms): <.main+2334>
test/lang/initByRef.ci:57:[.051987, .051991) exec(1), time(0.001-0.001 ms): <.main+2344>
test/lang/initByRef.ci:58:[.051991, .05199b) exec(1), time(0.001-0.001 ms): <.main+2354>
test/lang/initByRef.ci:59:[.05199b, .0519a5) exec(1), time(0.001-0.001 ms): <.main+2364>
test/lang/initByRef.ci:60:[.0519a5, .0519af) exec(1), time(0.002-0.002 ms): <.main+2374>
test/lang/initByRef.ci:61:[.0519af, .0519b9) exec(1), time(0.001-0.001 ms): <.main+2384>
test/lang/initByRef.ci:62:[.0519b9, .0519c3) exec(1), time(0.001-0.001 ms): <.main+2394>
test/lang/initByRef.ci:63:[.0519c3, .0519cd) exec(1), time(0.001-0.001 ms): <.main+2404>
test/lang/initByRef.ci:64:[.0519cd, .0519d7) exec(1), time(0.001-0.001 ms): <.main+2414>
test/lang/initByRef.ci:65:[.0519d7, .0519e1) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/initByRef.ci:66:[.0519e1, .0519eb) exec(1), time(0.001-0.001 ms): <.main+2434>
test/lang/initByRef.ci:67:[.0519eb, .0519f5) exec(1), time(0.001-0.001 ms): <.main+2444>
test/lang/initByRef.ci:68:[.0519f5, .0519ff) exec(1), time(0.001-0.001 ms): <.main+2454>
test/lang/initByRef.ci:69:[.0519ff, .051a09) exec(1), time(0.001-0.001 ms): <.main+2464>
test/lang/initByRef.ci:70:[.051a09, .051a13) exec(1), time(0.001-0.001 ms): <.main+2474>
test/lang/initByRef.ci:71:[.051a13, .051a1d) exec(1), time(0.001-0.001 ms): <.main+2484>
test/lang/initByRef.ci:72:[.051a1d, .051a27) exec(1), time(0.001-0.001 ms): <.main+2494>
test/lang/initByRef.ci:75:[.051a27, .051a2c) exec(1), time(0.001-0.001 ms): <.main+2504>
test/lang/initByRef.ci:76:[.051a2c, .051a31) exec(1), time(0.000 ms): <.main+2509>
test/lang/initByRef.ci:77:[.051a31, .051a36) exec(1), time(0.001-0.001 ms): <.main+2514>
test/lang/initByRef.ci:78:[.051a36, .051a3b) exec(1), time(0.000 ms): <.main+2519>
test/lang/initByRef.ci:79:[.051a3b, .051a40) exec(1), time(0.000 ms): <.main+2524>
test/lang/initByRef.ci:80:[.051a40, .051a45) exec(1), time(0.001-0.001 ms): <.main+2529>
test/lang/initByRef.ci:81:[.051a45, .051a4a) exec(1), time(0.000 ms): <.main+2534>
test/lang/initByRef.ci:82:[.051a4a, .051a4f) exec(1), time(0.001-0.001 ms): <.main+2539>
test/lang/initByRef.ci:83:[.051a4f, .051a54) exec(1), time(0.000 ms): <.main+2544>
test/lang/initByRef.ci:84:[.051a54, .051a59) exec(1), time(0.000 ms): <.main+2549>
test/lang/initByRef.ci:85:[.051a59, .051a5e) exec(1), time(0.001-0.001 ms): <.main+2554>
test/lang/initByRef.ci:86:[.051a5e, .051a63) exec(1), time(0.000 ms): <.main+2559>
test/lang/initByRef.ci:87:[.051a63, .051a68) exec(1), time(0.001-0.001 ms): <.main+2564>
test/lang/initByRef.ci:88:[.051a68, .051a6d) exec(1), time(0.000 ms): <.main+2569>
test/lang/initByRef.ci:89:[.051a6d, .051a72) exec(1), time(0.000 ms): <.main+2574>
test/lang/initByRef.ci:90:[.051a72, .051a77) exec(1), time(0.000 ms): <.main+2579>
test/lang/initByRef.ci:91:[.051a77, .051a7c) exec(1), time(0.000 ms): <.main+2584>
test/lang/initByRef.ci:92:[.051a7c, .051a81) exec(1), time(0.001-0.001 ms): <.main+2589>
test/lang/initByRef.ci:95:[.051a81, .051a86) exec(1), time(0.000 ms): <.main+2594>
test/lang/initByRef.ci:96:[.051a86, .051a90) exec(1), time(0.001-0.001 ms): <.main+2599>
test/lang/initByRef.ci:97:[.051a90, .051a95) exec(1), time(0.001-0.001 ms): <.main+2609>
test/lang/initByRef.ci:99:[.051a95, .051a9a) exec(1), time(0.000 ms): <.main+2614>
test/lang/initByRef.ci:105:[.051a9a, .051aa1) exec(1), time(0.001-0.001 ms): <.main+2619>
test/lang/initByRef.ci:108:[.051aa1, .051aa3) exec(1), time(0.001-0.001 ms): <.main+2626>
test/lang/function.ci:11:[.051aa3, .051ab8) exec(1), time(0.022-0.022 ms): <.main+2628>
test/lang/function.ci:14:[.051ab8, .051abd) exec(1), time(0.000 ms): <.main+2649>
test/lang/function.ci:17:[.051abd, .051acf) exec(1), time(0.021-0.021 ms): <.main+2654>
test/lang/function.ci:20:[.051acf, .051ad4) exec(1), time(0.000 ms): <.main+2672>
test/lang/function.ci:23:[.051ad4, .051ae6) exec(1), time(0.021-0.021 ms): <.main+2677>
test/lang/function.ci:26:[.051ae6, .051ae8) exec(1), time(0.000 ms): <.main+2695>
test/lang/function.ci:29:[.051ae8, .051afa) exec(1), time(0.020-0.020 ms): <.main+2697>
test/lang/function.ci:45:[.051afa, .051b0a) exec(1), time(14.489-14.489 ms): <.main+2715>
test/lang/reflect.ci:3:[.051b0a, .051b0e) exec(1), time(0.000 ms): <.main+2731>
test/lang/reflect.ci:4:[.051b0e, .051b12) exec(1), time(0.001-0.001 ms): <.main+2735>
test/lang/reflect.ci:5:[.051b12, .051b16) exec(1), time(0.000 ms): <.main+2739>
test/lang/reflect.ci:6:[.051b16, .051b1a) exec(1), time(0.000 ms): <.main+2743>
test/lang/reflect.ci:7:[.051b1a, .051b1e) exec(1), time(0.000 ms): <.main+2747>
test/lang/reflect.ci:8:[.051b1e, .051b22) exec(1), time(0.000 ms): <.main+2751>
test/lang/reflect.ci:9:[.051b22, .051b26) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/reflect.ci:10:[.051b26, .051b2a) exec(1), time(0.000 ms): <.main+2759>
test/lang/reflect.ci:11:[.051b2a, .051b2e) exec(1), time(0.001-0.001 ms): <.main+2763>
test/lang/reflect.ci:12:[.051b2e, .051b32) exec(1), time(0.000 ms): <.main+2767>
test/lang/reflect.ci:13:[.051b32, .051b36) exec(1), time(0.000 ms): <.main+2771>
test/lang/reflect.ci:14:[.051b36, .051b3a) exec(1), time(0.001-0.001 ms): <.main+2775>
test/lang/reflect.ci:15:[.051b3a, .051b3e) exec(1), time(0.000 ms): <.main+2779>
test/lang/reflect.ci:16:[.051b3e, .051b42) exec(1), time(0.001-0.001 ms): <.main+2783>
test/lang/reflect.ci:17:[.051b42, .051b46) exec(1), time(0.000 ms): <.main+2787>
test/lang/reflect.ci:18:[.051b46, .051b4a) exec(1), time(0.000 ms): <.main+2791>
test/lang/reflect.ci:19:[.051b4a, .051b4e) exec(1), time(0.001-0.001 ms): <.main+2795>
test/lang/reflect.ci:20:[.051b4e, .051b52) exec(1), time(0.000 ms): <.main+2799>
test/lang/reflect.ci:30:[.051b52, .051b57) exec(1), time(0.001-0.001 ms): <.main+2803>
test/lang/reflect.ci:31:[.051b57, .051b5d) exec(1), time(0.018-0.018 ms): <.main+2808>
test/lang/reflect.ci:32:[.051b5d, .051b64) exec(1), time(0.002-0.002 ms): <.main+2814>
test/lang/reflect.ci:33:[.051b64, .051b6b) exec(1), time(0.002-0.002 ms): <.main+2821>
test/lang/reflect.ci:34:[.051b6b, .051b71) exec(1), time(0.017-0.017 ms): <.main+2828>
test/lang/reflect.ci:35:[.051b71, .051b77) exec(1), time(0.016-0.016 ms): <.main+2834>
test/lang/reflect.ci:37:[.051b77, .051b7d) exec(1), time(0.016-0.016 ms): <.main+2840>
test/lang/reflect.ci:38:[.051b7d, .051b83) exec(1), time(0.016-0.016 ms): <.main+2846>
test/lang/reflect.ci:39:[.051b83, .051b8a) exec(1), time(0.002-0.002 ms): <.main+2852>
test/lang/reflect.ci:40:[.051b8a, .051b91) exec(1), time(0.002-0.002 ms): <.main+2859>
test/lang/reflect.ci:41:[.051b91, .051b97) exec(1), time(0.016-0.016 ms): <.main+2866>
test/lang/reflect.ci:42:[.051b97, .051b9d) exec(1), time(0.016-0.016 ms): <.main+2872>
test/lang/reflect.ci:44:[.051b9d, .051ba3) exec(1), time(0.016-0.016 ms): <.main+2878>
test/lang/reflect.ci:45:[.051ba3, .051baa) exec(1), time(0.002-0.002 ms): <.main+2884>
test/lang/reflect.ci:46:[.051baa, .051bb1) exec(1), time(0.002-0.002 ms): <.main+2891>
test/lang/reflect.ci:48:[.051bb1, .051bb7) exec(1), time(0.015-0.015 ms): <.main+2898>
test/lang/reflect.ci:49:[.051bb7, .051bbe) exec(1), time(0.001-0.001 ms): <.main+2904>
test/lang/reflect.ci:50:[.051bbe, .051bc5) exec(1), time(0.001-0.001 ms): <.main+2911>
test/stdc/number.ci:3:[.051bc5, .051bce) exec(1), time(0.000 ms): <.main+2918>
test/stdc/number.ci:4:[.051bce, .051bd7) exec(1), time(0.000 ms): <.main+2927>
test/stdc/number.ci:6:[.051bd7, .051bda) exec(1), time(0.002-0.002 ms): <.main+2936>
test/stdc/number.ci:7:[.051bda, .051bdd) exec(1), time(0.001-0.001 ms): <.main+2939>
test/stdc/number.ci:14:[.051bdd, .051be4) exec(1), time(0.001-0.001 ms): <.main+2942>
test/stdc/number.ci:15:[.051be4, .051beb) exec(1), time(0.002-0.002 ms): <.main+2949>
test/stdc/number.ci:16:[.051beb, .051bf2) exec(1), time(0.001-0.001 ms): <.main+2956>
test/stdc/number.ci:18:[.051bf2, .051c0e) exec(1), time(0.009-0.009 ms): <.main+2963>
test/stdc/number.ci:19:[.051c0e, .051c28) exec(1), time(0.009-0.009 ms): <.main+2991>
test/stdc/number.ci:21:[.051c28, .051c38) exec(1), time(0.018-0.018 ms): <.main+3017>
test/stdc/number.ci:22:[.051c38, .051c48) exec(1), time(0.022-0.022 ms): <.main+3033>
test/stdc/number.ci:23:[.051c48, .051c54) exec(1), time(0.018-0.018 ms): <.main+3049>
test/stdc/number.ci:25:[.051c54, .051c64) exec(1), time(0.018-0.018 ms): <.main+3061>
test/stdc/number.ci:26:[.051c64, .051c74) exec(1), time(0.017-0.017 ms): <.main+3077>
test/stdc/number.ci:27:[.051c74, .051c80) exec(1), time(0.017-0.017 ms): <.main+3093>
test/stdc/number.ci:29:[.051c80, .051c90) exec(1), time(0.017-0.017 ms): <.main+3105>
test/stdc/number.ci:30:[.051c90, .051ca0) exec(1), time(0.017-0.017 ms): <.main+3121>
test/stdc/number.ci:31:[.051ca0, .051cac) exec(1), time(0.017-0.017 ms): <.main+3137>
test/stdc/number.ci:33:[.051cac, .051cbc) exec(1), time(0.018-0.018 ms): <.main+3149>
test/stdc/number.ci:34:[.051cbc, .051ccc) exec(1), time(0.018-0.018 ms): <.main+3165>
test/stdc/number.ci:35:[.051ccc, .051cd8) exec(1), time(0.017-0.017 ms): <.main+3181>
test/stdc/number.ci:37:[.051cd8, .051ce8) exec(1), time(0.032-0.032 ms): <.main+3193>
test/stdc/number.ci:38:[.051ce8, .051cf8) exec(1), time(0.023-0.023 ms): <.main+3209>
test/stdc/number.ci:39:[.051cf8, .051d08) exec(1), time(0.018-0.018 ms): <.main+3225>
test/stdc/number.ci:40:[.051d08, .051d14) exec(1), time(0.021-0.021 ms): <.main+3241>
test/stdc/number.ci:41:[.051d14, .051d21) exec(1), time(0.016-0.016 ms): <.main+3253>
test/stdc/number.ci:42:[.051d21, .051d33) exec(1), time(0.020-0.020 ms): <.main+3266>
test/stdc/number.ci:43:[.051d33, .051d3c) exec(1), time(0.017-0.017 ms): <.main+3284>
test/stdc/number.ci:44:[.051d3c, .051d4b) exec(1), time(0.022-0.022 ms): <.main+3293>
test/stdc/number.ci:46:[.051d4b, .051d57) exec(1), time(0.019-0.019 ms): <.main+3308>
test/stdc/number.ci:47:[.051d57, .051d63) exec(1), time(0.017-0.017 ms): <.main+3320>
test/stdc/number.ci:48:[.051d63, .051d6f) exec(1), time(0.017-0.017 ms): <.main+3332>
test/stdc/number.ci:49:[.051d6f, .051d7b) exec(1), time(0.018-0.018 ms): <.main+3344>
test/stdc/number.ci:50:[.051d7b, .051d84) exec(1), time(0.016-0.016 ms): <.main+3356>
test/stdc/number.ci:51:[.051d84, .051d92) exec(1), time(0.018-0.018 ms): <.main+3365>
test/stdc/number.ci:52:[.051d92, .051d9b) exec(1), time(0.017-0.017 ms): <.main+3379>
test/stdc/number.ci:53:[.051d9b, .051da6) exec(1), time(0.019-0.019 ms): <.main+3388>
test/stdc/number.ci:55:[.051da6, .051dac) exec(1), time(0.016-0.016 ms): <.main+3399>
test/stdc/number.ci:56:[.051dac, .051db2) exec(1), time(0.016-0.016 ms): <.main+3405>
test/stdc/number.ci:57:[.051db2, .051db8) exec(1), time(0.015-0.015 ms): <.main+3411>
test/stdc/number.ci:58:[.051db8, .051dbe) exec(1), time(0.015-0.015 ms): <.main+3417>
test/stdc/number.ci:59:[.051dbe, .051dc4) exec(1), time(0.016-0.016 ms): <.main+3423>
test/stdc/number.ci:60:[.051dc4, .051dca) exec(1), time(0.018-0.018 ms): <.main+3429>
test/stdc/number.ci:62:[.051dca, .051dd6) exec(1), time(0.017-0.017 ms): <.main+3435>
test/stdc/number.ci:63:[.051dd6, .051de2) exec(1), time(0.017-0.017 ms): <.main+3447>
test/stdc/number.ci:65:[.051de2, .051df0) exec(1), time(0.019-0.019 ms): <.main+3459>
test/stdc/number.ci:66:[.051df0, .051dfe) exec(1), time(0.019-0.019 ms): <.main+3473>
test/stdc/memory.ci:7:[.051dfe, .051e0c) exec(1), time(0.019-0.019 ms): <.main+3487>
test/stdc/memory.ci:8:[.051e0c, .051e1a) exec(1), time(0.016-0.016 ms): <.main+3501>
test/stdc/memory.ci:9:[.051e1a, .051e28) exec(1), time(0.016-0.016 ms): <.main+3515>
test/stdc/memory.ci:10:[.051e28, .051e36) exec(1), time(0.017-0.017 ms): <.main+3529>
test/stdc/memory.ci:13:[.051e36, .051e46) exec(1), time(0.019-0.019 ms): <.main+3543>
test/stdc/memory.ci:14:[.051e46, .051e57) exec(1), time(0.018-0.018 ms): <.main+3559>
test/stdc/memory.ci:17:[.051e57, .051e62) exec(1), time(0.017-0.017 ms): <.main+3576>
test/stdc/memory.ci:18:[.051e62, .051e6d) exec(1), time(0.018-0.018 ms): <.main+3587>
test/stdc/memory.ci:19:[.051e6d, .051e78) exec(1), time(0.017-0.017 ms): <.main+3598>
test/stdc/memory.ci:20:[.051e78, .051e83) exec(1), time(0.017-0.017 ms): <.main+3609>
test/stdc/memory.ci:23:[.051e83, .051e8c) exec(1), time(0.000 ms): <.main+3620>
test/stdc/memory.ci:24:[.051e8c, .051e95) exec(1), time(0.000 ms): <.main+3629>
test/stdc/memory.ci:26:[.051e95, .051eb7) exec(1), time(0.034-0.034 ms): <.main+3638>
test/stdc/memory.ci:27:[.051eb7, .051ed9) exec(1), time(0.032-0.032 ms): <.main+3672>
test/stdc/memory.ci:29:[.051ed9, .051eed) exec(1), time(0.022-0.022 ms): <.main+3706>
test/stdc/memory.ci:30:[.051eed, .051efe) exec(1), time(0.019-0.019 ms): <.main+3726>
test/stdc/memory.ci:32:[.051efe, .051f20) exec(1), time(0.032-0.032 ms): <.main+3743>
test/stdc/memory.ci:33:[.051f20, .051f42) exec(1), time(0.032-0.032 ms): <.main+3777>
test/stdc/tryExec.ci:46:[.051f42, .051f50) exec(1), time(0.049-0.049 ms): <.main+3811>
test/stdc/tryExec.ci:47:[.051f50, .051f5e) exec(1), time(0.019-0.019 ms): <.main+3825>
test/stdc/tryExec.ci:48:[.051f5e, .051f6c) exec(1), time(1.064-1.064 ms): <.main+3839>
test/stdc/tryExec.ci:49:[.051f6c, .051f7a) exec(1), time(0.032-0.032 ms): <.main+3853>
test/stdc/tryExec.ci:50:[.051f7a, .051f88) exec(1), time(0.031-0.031 ms): <.main+3867>
test/stdc/tryExec.ci:51:[.051f88, .051f96) exec(1), time(0.033-0.033 ms): <.main+3881>
test/stdc/tryExec.ci:52:[.051f96, .051fa4) exec(1), time(0.134-0.134 ms): <.main+3895>
test/lang/array.ci:49:[.051fa4, .051fa8) exec(1), time(0.001-0.001 ms): <.main+3909>
test/lang/array.ci:50:[.051fa8, .051fac) exec(1), time(0.000 ms): <.main+3913>
test/lang/array.ci:51:[.051fac, .051fb0) exec(1), time(0.001-0.001 ms): <.main+3917>
test/lang/array.ci:55:[.051fb5, .051fc9) exec(7), time(0.042-0.042 ms): <.main+3926>
test/lang/array.ci:54:[.051fc9, .051fcd) exec(7), time(0.002-0.002 ms): <.main+3946>
test/lang/array.ci:54:[.051fcd, .051fd9) exec(8), time(0.023-0.023 ms): <.main+3950>
test/lang/array.ci:54:[.051fb0, .051fdd) exec(1), time(0.004-0.004 ms): <.main+3921>
test/lang/array.ci:59:[.051fdd, .051fe2) exec(1), time(0.001-0.001 ms): <.main+3966>
test/lang/array.ci:60:[.051fe2, .051fe8) exec(1), time(0.001-0.001 ms): <.main+3971>
test/lang/array.ci:63:[.051fe8, .051fec) exec(1), time(0.001-0.001 ms): <.main+3977>
test/lang/array.ci:64:[.051fec, .051ff5) exec(1), time(0.001-0.001 ms): <.main+3981>
test/lang/array.ci:67:[.051ff5, .051ff7) exec(1), time(0.001-0.001 ms): <.main+3990>
test/lang/array.ci:68:[.051ff7, .051ff9) exec(1), time(0.000 ms): <.main+3992>
test/lang/array.ci:71:[.051ff9, .051ffb) exec(1), time(0.001-0.001 ms): <.main+3994>
test/lang/array.ci:81:[.051ffb, .051fff) exec(1), time(0.000 ms): <.main+3996>
test/lang/array.ci:82:[.051fff, .052015) exec(1), time(0.020-0.020 ms): <.main+4000>
test/lang/array.ci:83:[.052015, .052037) exec(1), time(0.079-0.079 ms): <.main+4022>
test/lang/array.ci:84:[.052037, .052059) exec(1), time(0.078-0.078 ms): <.main+4056>
test/lang/array.ci:86:[.052059, .05205e) exec(1), time(0.001-0.001 ms): <.main+4090>
test/lang/array.ci:87:[.05205e, .05207e) exec(1), time(0.037-0.037 ms): <.main+4095>
test/lang/array.ci:88:[.05207e, .05209e) exec(1), time(0.037-0.037 ms): <.main+4127>
test/lang/array.ci:90:[.05209e, .0520a8) exec(1), time(0.001-0.001 ms): <.main+4159>
test/lang/array.ci:91:[.0520a8, .0520c8) exec(1), time(0.036-0.036 ms): <.main+4169>
test/lang/array.ci:92:[.0520c8, .0520e8) exec(1), time(0.036-0.036 ms): <.main+4201>
test/lang/array.ci:98:[.0520e8, .05211b) exec(1), time(0.004-0.004 ms): <.main+4233>
test/lang/array.ci:99:[.05211b, .05214e) exec(1), time(0.004-0.004 ms): <.main+4284>
test/lang/array.ci:101:[.05214e, .052189) exec(1), time(0.004-0.004 ms): <.main+4335>
test/lang/array.ci:108:[.052189, .0521a2) exec(1), time(0.020-0.020 ms): <.main+4394>
test/lang/array.ci:109:[.0521a2, .0521b8) exec(1), time(0.019-0.019 ms): <.main+4419>
test/lang/array.ci:110:[.0521b8, .0521ce) exec(1), time(0.019-0.019 ms): <.main+4441>
test/lang/array.ci:112:[.0521ce, .0521ee) exec(1), time(0.039-0.039 ms): <.main+4463>
test/lang/array.ci:113:[.0521ee, .05220b) exec(1), time(0.043-0.043 ms): <.main+4495>
test/lang/array.ci:114:[.05220b, .052233) exec(1), time(0.040-0.040 ms): <.main+4524>
test/lang/array.ci:115:[.052233, .052254) exec(1), time(0.040-0.040 ms): <.main+4564>
test/lang/array.ci:116:[.052254, .052275) exec(1), time(0.039-0.039 ms): <.main+4597>
test/lang/array.ci:119:[.05227a, .052283) exec(7), time(0.021-0.021 ms): <.main+4635>
test/lang/array.ci:120:[.052283, .0522c0) exec(7), time(0.045-0.045 ms): <.main+4644>
test/lang/array.ci:121:[.0522c0, .0522fb) exec(7), time(0.043-0.043 ms): <.main+4705>
test/lang/array.ci:122:[.0522fb, .052336) exec(7), time(0.045-0.045 ms): <.main+4764>
test/lang/array.ci:124:[.052336, .052379) exec(7), time(0.189-0.189 ms): <.main+4823>
test/lang/array.ci:125:[.052379, .0523ba) exec(7), time(0.189-0.189 ms): <.main+4890>
test/lang/array.ci:126:[.0523ba, .0523fb) exec(7), time(0.199-0.199 ms): <.main+4955>
test/lang/array.ci:128:[.0523fb, .05243e) exec(7), time(0.194-0.194 ms): <.main+5020>
test/lang/array.ci:129:[.05243e, .05247f) exec(7), time(0.190-0.190 ms): <.main+5087>
test/lang/array.ci:130:[.05247f, .0524c0) exec(7), time(0.188-0.188 ms): <.main+5152>
test/lang/array.ci:132:[.0524c0, .052508) exec(7), time(0.194-0.194 ms): <.main+5217>
test/lang/array.ci:134:[.052508, .052549) exec(7), time(0.188-0.188 ms): <.main+5289>
test/lang/array.ci:136:[.052549, .052584) exec(7), time(0.045-0.045 ms): <.main+5354>
test/lang/array.ci:118:[.052588, .05258c) exec(7), time(0.002-0.002 ms): <.main+5417>
test/lang/array.ci:118:[.05258c, .052598) exec(8), time(0.024-0.024 ms): <.main+5421>
test/lang/array.ci:118:[.052275, .05259c) exec(1), time(0.005-0.005 ms): <.main+4630>
test/lang/member.ci:54:[.0525a0, .0525a7) exec(1), time(0.002-0.002 ms): <.main+5441>
test/lang/member.ci:55:[.0525a7, .0525ae) exec(1), time(0.001-0.001 ms): <.main+5448>
test/lang/member.ci:56:[.0525ae, .0525b5) exec(1), time(0.002-0.002 ms): <.main+5455>
test/lang/member.ci:57:[.0525b5, .0525bc) exec(1), time(0.001-0.001 ms): <.main+5462>
test/lang/member.ci:60:[.0525bc, .0525c3) exec(1), time(0.002-0.002 ms): <.main+5469>
test/lang/member.ci:61:[.0525c3, .0525ca) exec(1), time(0.001-0.001 ms): <.main+5476>
test/lang/member.ci:65:[.0525ca, .0525d1) exec(1), time(0.001-0.001 ms): <.main+5483>
test/lang/member.ci:66:[.0525d1, .0525d8) exec(1), time(0.001-0.001 ms): <.main+5490>
test/lang/member.ci:53:[.05259c, .0525d8) exec(1-1), time(0.000 ms): <.main+5437>
test/lang/method.ci:46:[.0525dc, .0525e3) exec(1), time(0.001-0.001 ms): <.main+5501>
::[.0525e3, .0525e9) exec(1), time(0.001-0.001 ms): <.main+5508>
::[.0525e9, .0525f0) exec(1), time(0.001-0.001 ms): <.main+5514>
test/lang/method.ci:44:[.0525d8, .0525f0) exec(1-1), time(0.000 ms): <.main+5497>
test/lang/method.ci:58:[.0525f0, .052603) exec(1), time(0.107-0.107 ms): <.main+5521>
test/lang/method.ci:59:[.052603, .052613) exec(1), time(0.106-0.106 ms): <.main+5540>
test/lang/method.ci:75:[.052613, .052624) exec(1), time(0.200-0.200 ms): <.main+5556>
test/lang/method.ci:76:[.052624, .052635) exec(1), time(0.197-0.197 ms): <.main+5573>
test/lang/method.ci:79:[.052635, .052648) exec(1), time(0.105-0.105 ms): <.main+5590>
test/lang/method.ci:80:[.052648, .05265b) exec(1), time(0.102-0.102 ms): <.main+5609>
test/lang/method.ci:81:[.05265b, .05266b) exec(1), time(0.102-0.102 ms): <.main+5628>
test/lang/recUnion.ci:26:[.05266f, .052675) exec(1), time(0.002-0.002 ms): <.main+5648>
test/lang/recUnion.ci:26:[.052675, .05267b) exec(1), time(0.003-0.003 ms): <.main+5654>
test/lang/recUnion.ci:26:[.05267b, .052681) exec(1), time(0.002-0.002 ms): <.main+5660>
test/lang/recUnion.ci:26:[.05266b, .052681) exec(1-1), time(0.000 ms): <.main+5644>
test/lang/recUnion.ci:27:[.052685, .05268b) exec(1), time(0.003-0.003 ms): <.main+5670>
test/lang/recUnion.ci:27:[.05268b, .052695) exec(1), time(0.002-0.002 ms): <.main+5676>
test/lang/recUnion.ci:27:[.052695, .05269b) exec(1), time(0.002-0.002 ms): <.main+5686>
test/lang/recUnion.ci:27:[.052681, .05269b) exec(1-1), time(0.000 ms): <.main+5666>
test/lang/recUnion.ci:28:[.05269f, .0526a9) exec(1), time(0.002-0.002 ms): <.main+5696>
test/lang/recUnion.ci:28:[.0526a9, .0526b3) exec(1), time(0.002-0.002 ms): <.main+5706>
test/lang/recUnion.ci:28:[.0526b3, .0526bd) exec(1), time(0.002-0.002 ms): <.main+5716>
test/lang/recUnion.ci:28:[.05269b, .0526bd) exec(1-1), time(0.000 ms): <.main+5692>
test/lang/recUnion.ci:30:[.0526c1, .0526c8) exec(1), time(0.002-0.002 ms): <.main+5730>
test/lang/recUnion.ci:30:[.0526bd, .0526c8) exec(1-1), time(0.000 ms): <.main+5726>
test/lang/recUnion.ci:31:[.0526cc, .0526d2) exec(1), time(0.002-0.002 ms): <.main+5741>
test/lang/recUnion.ci:31:[.0526d2, .0526d8) exec(1), time(0.002-0.002 ms): <.main+5747>
test/lang/recUnion.ci:31:[.0526d8, .0526e2) exec(1), time(0.002-0.002 ms): <.main+5753>
test/lang/recUnion.ci:31:[.0526c8, .0526e2) exec(1-1), time(0.000 ms): <.main+5737>
test/lang/useOperator.ci:5:[.0526e2, .0526e7) exec(1), time(0.000 ms): <.main+5763>
test/lang/useOperator.ci:7:[.0526e7, .0526ec) exec(1), time(0.001-0.001 ms): <.main+5768>
test/lang/useOperator.ci:8:[.0526ec, .0526f1) exec(1), time(0.000 ms): <.main+5773>
test/lang/useOperator.ci:17:[.0526f1, .0526fc) exec(1), time(0.004-0.004 ms): <.main+5778>
test/lang/useOperator.ci:18:[.0526fc, .052707) exec(1), time(0.004-0.004 ms): <.main+5789>
test/lang/useOperator.ci:19:[.052707, .052712) exec(1), time(0.004-0.004 ms): <.main+5800>
test/lang/useOperator.ci:22:[.052712, .052718) exec(1), time(0.002-0.002 ms): <.main+5811>
test/lang/useOperator.ci:23:[.052718, .052723) exec(1), time(0.004-0.004 ms): <.main+5817>
test/lang/useOperator.ci:24:[.052723, .05272f) exec(1), time(0.005-0.005 ms): <.main+5828>
test/lang/useOperator.ci:25:[.05272f, .05273a) exec(1), time(0.004-0.004 ms): <.main+5840>
test/lang/useOperator.ci:26:[.05273a, .052746) exec(1), time(0.005-0.005 ms): <.main+5851>
test/lang/useOperator.ci:27:[.052746, .052751) exec(1), time(0.004-0.004 ms): <.main+5863>
test/lang/useOperator.ci:28:[.052751, .05275d) exec(1), time(0.005-0.005 ms): <.main+5874>
test/lang/useOperator.ci:30:[.05275d, .052762) exec(1), time(0.000 ms): <.main+5886>
test/lang/useOperator.ci:31:[.052762, .052767) exec(1), time(0.000 ms): <.main+5891>
test/lang/useOperator.ci:32:[.052767, .05276c) exec(1), time(0.002-0.002 ms): <.main+5896>
test/lang/useOperator.ci:33:[.05276c, .052772) exec(1), time(0.002-0.002 ms): <.main+5901>
test/lang/useOperator.ci:34:[.052772, .052778) exec(1), time(0.003-0.003 ms): <.main+5907>
test/lang/useOperator.ci:35:[.052778, .052783) exec(1), time(0.004-0.004 ms): <.main+5913>
test/lang/useOperator.ci:36:[.052783, .05278e) exec(1), time(0.004-0.004 ms): <.main+5924>
test/lang/useOperator.ci:37:[.05278e, .052799) exec(1), time(0.004-0.004 ms): <.main+5935>
test/lang/useOperator.ci:38:[.052799, .0527a4) exec(1), time(0.004-0.004 ms): <.main+5946>
test/lang/useOperator.ci:39:[.0527a4, .0527af) exec(1), time(0.004-0.004 ms): <.main+5957>
test/lang/useOperator.ci:40:[.0527af, .0527ba) exec(1), time(0.004-0.004 ms): <.main+5968>
test/lang/useOperator.ci:41:[.0527ba, .0527c5) exec(1), time(0.004-0.004 ms): <.main+5979>
test/lang/useOperator.ci:42:[.0527c5, .0527d0) exec(1), time(0.004-0.004 ms): <.main+5990>
test/lang/useOperator.ci:43:[.0527d0, .0527d8) exec(1), time(0.003-0.003 ms): <.main+6001>
test/lang/useOperator.ci:44:[.0527d8, .0527e0) exec(1), time(0.003-0.003 ms): <.main+6009>
test/lang/useOperator.ci:45:[.0527e0, .0527e7) exec(1), time(0.003-0.003 ms): <.main+6017>
test/lang/useOperator.ci:46:[.0527e7, .0527f2) exec(1), time(0.004-0.004 ms): <.main+6024>
test/lang/useOperator.ci:47:[.0527f2, .0527fe) exec(1), time(0.005-0.005 ms): <.main+6035>
test/lang/useOperator.ci:48:[.0527fe, .052809) exec(1), time(0.004-0.004 ms): <.main+6047>
test/lang/useOperator.ci:49:[.052809, .052815) exec(1), time(0.005-0.005 ms): <.main+6058>
test/lang/useOperator.ci:50:[.052815, .052820) exec(1), time(0.004-0.004 ms): <.main+6070>
test/lang/useOperator.ci:51:[.052820, .05282c) exec(1), time(0.005-0.005 ms): <.main+6081>
test/lang/useOperator.ci:53:[.05282c, .052831) exec(1), time(0.000 ms): <.main+6093>
test/lang/useOperator.ci:54:[.052831, .052836) exec(1), time(0.000 ms): <.main+6098>
test/lang/useOperator.ci:55:[.052836, .05283b) exec(1), time(0.002-0.002 ms): <.main+6103>
test/lang/useOperator.ci:56:[.05283b, .052841) exec(1), time(0.002-0.002 ms): <.main+6108>
test/lang/useOperator.ci:57:[.052841, .052847) exec(1), time(0.003-0.003 ms): <.main+6114>
test/lang/useOperator.ci:58:[.052847, .052852) exec(1), time(0.004-0.004 ms): <.main+6120>
test/lang/useOperator.ci:59:[.052852, .05285d) exec(1), time(0.004-0.004 ms): <.main+6131>
test/lang/useOperator.ci:60:[.05285d, .052868) exec(1), time(0.004-0.004 ms): <.main+6142>
test/lang/useOperator.ci:61:[.052868, .052873) exec(1), time(0.004-0.004 ms): <.main+6153>
test/lang/useOperator.ci:62:[.052873, .05287e) exec(1), time(0.004-0.004 ms): <.main+6164>
test/lang/useOperator.ci:63:[.05287e, .052889) exec(1), time(0.004-0.004 ms): <.main+6175>
test/lang/useOperator.ci:64:[.052889, .052894) exec(1), time(0.004-0.004 ms): <.main+6186>
test/lang/useOperator.ci:65:[.052894, .05289f) exec(1), time(0.004-0.004 ms): <.main+6197>
test/lang/useOperator.ci:66:[.05289f, .0528a7) exec(1), time(0.004-0.004 ms): <.main+6208>
test/lang/useOperator.ci:67:[.0528a7, .0528af) exec(1), time(0.003-0.003 ms): <.main+6216>
test/lang/useOperator.ci:68:[.0528af, .0528b6) exec(1), time(0.003-0.003 ms): <.main+6224>
test/lang/useOperator.ci:69:[.0528b6, .0528c1) exec(1), time(0.004-0.004 ms): <.main+6231>
test/lang/useOperator.ci:70:[.0528c1, .0528cd) exec(1), time(0.005-0.005 ms): <.main+6242>
test/lang/useOperator.ci:71:[.0528cd, .0528d8) exec(1), time(0.004-0.004 ms): <.main+6254>
test/lang/useOperator.ci:72:[.0528d8, .0528e4) exec(1), time(0.005-0.005 ms): <.main+6265>
test/lang/useOperator.ci:73:[.0528e4, .0528ef) exec(1), time(0.005-0.005 ms): <.main+6277>
test/lang/useOperator.ci:74:[.0528ef, .0528fb) exec(1), time(0.005-0.005 ms): <.main+6288>
test/lang/useOperator.ci:76:[.0528fb, .052900) exec(1), time(0.001-0.001 ms): <.main+6300>
test/lang/useOperator.ci:77:[.052900, .052905) exec(1), time(0.001-0.001 ms): <.main+6305>
test/lang/useOperator.ci:78:[.052905, .05290a) exec(1), time(0.001-0.001 ms): <.main+6310>
test/lang/useOperator.ci:79:[.05290a, .052910) exec(1), time(0.002-0.002 ms): <.main+6315>
test/lang/useOperator.ci:80:[.052910, .052916) exec(1), time(0.003-0.003 ms): <.main+6321>
test/lang/useOperator.ci:81:[.052916, .052921) exec(1), time(0.004-0.004 ms): <.main+6327>
test/lang/useOperator.ci:82:[.052921, .05292c) exec(1), time(0.004-0.004 ms): <.main+6338>
test/lang/useOperator.ci:83:[.05292c, .052937) exec(1), time(0.005-0.005 ms): <.main+6349>
test/lang/useOperator.ci:84:[.052937, .052942) exec(1), time(0.004-0.004 ms): <.main+6360>
test/lang/useOperator.ci:85:[.052942, .05294d) exec(1), time(0.004-0.004 ms): <.main+6371>
test/lang/useOperator.ci:86:[.05294d, .052958) exec(1), time(0.004-0.004 ms): <.main+6382>
test/lang/useOperator.ci:87:[.052958, .052963) exec(1), time(0.004-0.004 ms): <.main+6393>
test/lang/useOperator.ci:88:[.052963, .05296e) exec(1), time(0.004-0.004 ms): <.main+6404>
test/lang/useOperator.ci:89:[.05296e, .052976) exec(1), time(0.004-0.004 ms): <.main+6415>
test/lang/useOperator.ci:90:[.052976, .05297e) exec(1), time(0.003-0.003 ms): <.main+6423>
test/lang/useOperator.ci:91:[.05297e, .052985) exec(1), time(0.003-0.003 ms): <.main+6431>
test/lang/useOperator.ci:92:[.052985, .052990) exec(1), time(0.005-0.005 ms): <.main+6438>
test/lang/useOperator.ci:93:[.052990, .05299c) exec(1), time(0.005-0.005 ms): <.main+6449>
test/lang/useOperator.ci:94:[.05299c, .0529a7) exec(1), time(0.004-0.004 ms): <.main+6461>
test/lang/useOperator.ci:95:[.0529a7, .0529b3) exec(1), time(0.006-0.006 ms): <.main+6472>
test/lang/useOperator.ci:96:[.0529b3, .0529be) exec(1), time(0.005-0.005 ms): <.main+6484>
test/lang/useOperator.ci:97:[.0529be, .0529ca) exec(1), time(0.005-0.005 ms): <.main+6495>
test/lang/useOperator.ci:99:[.0529ca, .0529cf) exec(1), time(0.000 ms): <.main+6507>
test/lang/useOperator.ci:100:[.0529cf, .0529d4) exec(1), time(0.001-0.001 ms): <.main+6512>
test/lang/useOperator.ci:101:[.0529d4, .0529d9) exec(1), time(0.002-0.002 ms): <.main+6517>
test/lang/useOperator.ci:102:[.0529d9, .0529df) exec(1), time(0.002-0.002 ms): <.main+6522>
test/lang/useOperator.ci:103:[.0529df, .0529e5) exec(1), time(0.002-0.002 ms): <.main+6528>
test/lang/useOperator.ci:104:[.0529e5, .0529f0) exec(1), time(0.004-0.004 ms): <.main+6534>
test/lang/useOperator.ci:105:[.0529f0, .0529fb) exec(1), time(0.005-0.005 ms): <.main+6545>
test/lang/useOperator.ci:106:[.0529fb, .052a06) exec(1), time(0.005-0.005 ms): <.main+6556>
test/lang/useOperator.ci:107:[.052a06, .052a11) exec(1), time(0.004-0.004 ms): <.main+6567>
test/lang/useOperator.ci:108:[.052a11, .052a1c) exec(1), time(0.004-0.004 ms): <.main+6578>
test/lang/useOperator.ci:109:[.052a1c, .052a27) exec(1), time(0.005-0.005 ms): <.main+6589>
test/lang/useOperator.ci:110:[.052a27, .052a32) exec(1), time(0.005-0.005 ms): <.main+6600>
test/lang/useOperator.ci:111:[.052a32, .052a3d) exec(1), time(0.004-0.004 ms): <.main+6611>
test/lang/useOperator.ci:112:[.052a3d, .052a45) exec(1), time(0.003-0.003 ms): <.main+6622>
test/lang/useOperator.ci:113:[.052a45, .052a4d) exec(1), time(0.003-0.003 ms): <.main+6630>
test/lang/useOperator.ci:114:[.052a4d, .052a54) exec(1), time(0.003-0.003 ms): <.main+6638>
test/lang/useOperator.ci:115:[.052a54, .052a5f) exec(1), time(0.005-0.005 ms): <.main+6645>
test/lang/useOperator.ci:116:[.052a5f, .052a6b) exec(1), time(0.006-0.006 ms): <.main+6656>
test/lang/useOperator.ci:117:[.052a6b, .052a76) exec(1), time(0.005-0.005 ms): <.main+6668>
test/lang/useOperator.ci:118:[.052a76, .052a82) exec(1), time(0.005-0.005 ms): <.main+6679>
test/lang/useOperator.ci:119:[.052a82, .052a8d) exec(1), time(0.004-0.004 ms): <.main+6691>
test/lang/useOperator.ci:120:[.052a8d, .052a99) exec(1), time(0.005-0.005 ms): <.main+6702>
test/lang/useOperator.ci:122:[.052a99, .052a9e) exec(1), time(0.000 ms): <.main+6714>
test/lang/useOperator.ci:123:[.052a9e, .052aa3) exec(1), time(0.000 ms): <.main+6719>
test/lang/useOperator.ci:124:[.052aa3, .052aa8) exec(1), time(0.002-0.002 ms): <.main+6724>
test/lang/useOperator.ci:125:[.052aa8, .052aae) exec(1), time(0.003-0.003 ms): <.main+6729>
test/lang/useOperator.ci:126:[.052aae, .052ab4) exec(1), time(0.002-0.002 ms): <.main+6735>
test/lang/useOperator.ci:127:[.052ab4, .052abf) exec(1), time(0.004-0.004 ms): <.main+6741>
test/lang/useOperator.ci:128:[.052abf, .052aca) exec(1), time(0.004-0.004 ms): <.main+6752>
test/lang/useOperator.ci:129:[.052aca, .052ad5) exec(1), time(0.004-0.004 ms): <.main+6763>
test/lang/useOperator.ci:130:[.052ad5, .052ae0) exec(1), time(0.004-0.004 ms): <.main+6774>
test/lang/useOperator.ci:131:[.052ae0, .052aeb) exec(1), time(0.005-0.005 ms): <.main+6785>
test/lang/useOperator.ci:132:[.052aeb, .052af6) exec(1), time(0.005-0.005 ms): <.main+6796>
test/lang/useOperator.ci:133:[.052af6, .052b01) exec(1), time(0.005-0.005 ms): <.main+6807>
test/lang/useOperator.ci:134:[.052b01, .052b0c) exec(1), time(0.005-0.005 ms): <.main+6818>
test/lang/useOperator.ci:135:[.052b0c, .052b14) exec(1), time(0.004-0.004 ms): <.main+6829>
test/lang/useOperator.ci:136:[.052b14, .052b1c) exec(1), time(0.004-0.004 ms): <.main+6837>
test/lang/useOperator.ci:137:[.052b1c, .052b23) exec(1), time(0.004-0.004 ms): <.main+6845>
test/lang/useOperator.ci:138:[.052b23, .052b2e) exec(1), time(0.004-0.004 ms): <.main+6852>
test/lang/useOperator.ci:139:[.052b2e, .052b3a) exec(1), time(0.006-0.006 ms): <.main+6863>
test/lang/useOperator.ci:140:[.052b3a, .052b45) exec(1), time(0.004-0.004 ms): <.main+6875>
test/lang/useOperator.ci:141:[.052b45, .052b51) exec(1), time(0.006-0.006 ms): <.main+6886>
test/lang/useOperator.ci:142:[.052b51, .052b5c) exec(1), time(0.005-0.005 ms): <.main+6898>
test/lang/useOperator.ci:143:[.052b5c, .052b68) exec(1), time(0.006-0.006 ms): <.main+6909>
test/lang/useOperator.ci:145:[.052b68, .052b6d) exec(1), time(0.000 ms): <.main+6921>
test/lang/useOperator.ci:146:[.052b6d, .052b72) exec(1), time(0.000 ms): <.main+6926>
test/lang/useOperator.ci:147:[.052b72, .052b74) exec(1), time(0.000 ms): <.main+6931>
test/lang/useOperator.ci:148:[.052b74, .052b77) exec(1), time(0.002-0.002 ms): <.main+6933>
test/lang/useOperator.ci:149:[.052b77, .052b7a) exec(1), time(0.002-0.002 ms): <.main+6936>
test/lang/useOperator.ci:150:[.052b7a, .052b7f) exec(1), time(0.003-0.003 ms): <.main+6939>
test/lang/useOperator.ci:151:[.052b7f, .052b84) exec(1), time(0.003-0.003 ms): <.main+6944>
test/lang/useOperator.ci:152:[.052b84, .052b89) exec(1), time(0.003-0.003 ms): <.main+6949>
test/lang/useOperator.ci:153:[.052b89, .052b8e) exec(1), time(0.003-0.003 ms): <.main+6954>
test/lang/useOperator.ci:154:[.052b8e, .052b93) exec(1), time(0.003-0.003 ms): <.main+6959>
test/lang/useOperator.ci:155:[.052b93, .052b98) exec(1), time(0.003-0.003 ms): <.main+6964>
test/lang/useOperator.ci:156:[.052b98, .052b9d) exec(1), time(0.003-0.003 ms): <.main+6969>
test/lang/useOperator.ci:157:[.052b9d, .052ba2) exec(1), time(0.003-0.003 ms): <.main+6974>
test/lang/useOperator.ci:158:[.052ba2, .052ba7) exec(1), time(0.002-0.002 ms): <.main+6979>
test/lang/useOperator.ci:159:[.052ba7, .052bac) exec(1), time(0.003-0.003 ms): <.main+6984>
test/lang/useOperator.ci:160:[.052bac, .052bb0) exec(1), time(0.003-0.003 ms): <.main+6989>
test/lang/useOperator.ci:161:[.052bb0, .052bb5) exec(1), time(0.002-0.002 ms): <.main+6993>
test/lang/useOperator.ci:162:[.052bb5, .052bbb) exec(1), time(0.004-0.004 ms): <.main+6998>
test/lang/useOperator.ci:163:[.052bbb, .052bc0) exec(1), time(0.002-0.002 ms): <.main+7004>
test/lang/useOperator.ci:164:[.052bc0, .052bc6) exec(1), time(0.004-0.004 ms): <.main+7009>
test/lang/useOperator.ci:165:[.052bc6, .052bcb) exec(1), time(0.003-0.003 ms): <.main+7015>
test/lang/useOperator.ci:166:[.052bcb, .052bd1) exec(1), time(0.004-0.004 ms): <.main+7020>
test/lang/useOperator.ci:168:[.052bd1, .052bd6) exec(1), time(0.000 ms): <.main+7026>
test/lang/useOperator.ci:169:[.052bd6, .052bdb) exec(1), time(0.000 ms): <.main+7031>
test/lang/useOperator.ci:170:[.052bdb, .052bdd) exec(1), time(0.000 ms): <.main+7036>
test/lang/useOperator.ci:171:[.052bdd, .052be0) exec(1), time(0.002-0.002 ms): <.main+7038>
test/lang/useOperator.ci:172:[.052be0, .052be3) exec(1), time(0.002-0.002 ms): <.main+7041>
test/lang/useOperator.ci:173:[.052be3, .052be8) exec(1), time(0.003-0.003 ms): <.main+7044>
test/lang/useOperator.ci:174:[.052be8, .052bed) exec(1), time(0.003-0.003 ms): <.main+7049>
test/lang/useOperator.ci:175:[.052bed, .052bf2) exec(1), time(0.003-0.003 ms): <.main+7054>
test/lang/useOperator.ci:176:[.052bf2, .052bf7) exec(1), time(0.003-0.003 ms): <.main+7059>
test/lang/useOperator.ci:177:[.052bf7, .052bfc) exec(1), time(0.003-0.003 ms): <.main+7064>
test/lang/useOperator.ci:178:[.052bfc, .052c01) exec(1), time(0.003-0.003 ms): <.main+7069>
test/lang/useOperator.ci:179:[.052c01, .052c06) exec(1), time(0.002-0.002 ms): <.main+7074>
test/lang/useOperator.ci:180:[.052c06, .052c0b) exec(1), time(0.003-0.003 ms): <.main+7079>
test/lang/useOperator.ci:181:[.052c0b, .052c10) exec(1), time(0.002-0.002 ms): <.main+7084>
test/lang/useOperator.ci:182:[.052c10, .052c15) exec(1), time(0.002-0.002 ms): <.main+7089>
test/lang/useOperator.ci:183:[.052c15, .052c19) exec(1), time(0.002-0.002 ms): <.main+7094>
test/lang/useOperator.ci:184:[.052c19, .052c1e) exec(1), time(0.002-0.002 ms): <.main+7098>
test/lang/useOperator.ci:185:[.052c1e, .052c24) exec(1), time(0.004-0.004 ms): <.main+7103>
test/lang/useOperator.ci:186:[.052c24, .052c29) exec(1), time(0.003-0.003 ms): <.main+7109>
test/lang/useOperator.ci:187:[.052c29, .052c2f) exec(1), time(0.004-0.004 ms): <.main+7114>
test/lang/useOperator.ci:188:[.052c2f, .052c34) exec(1), time(0.003-0.003 ms): <.main+7120>
test/lang/useOperator.ci:189:[.052c34, .052c3a) exec(1), time(0.004-0.004 ms): <.main+7125>
test/lang/useOperator.ci:191:[.052c3a, .052c43) exec(1), time(0.000 ms): <.main+7131>
test/lang/useOperator.ci:192:[.052c43, .052c4c) exec(1), time(0.001-0.001 ms): <.main+7140>
test/lang/useOperator.ci:193:[.052c4c, .052c4e) exec(1), time(0.001-0.001 ms): <.main+7149>
test/lang/useOperator.ci:194:[.052c4e, .052c51) exec(1), time(0.002-0.002 ms): <.main+7151>
test/lang/useOperator.ci:195:[.052c51, .052c54) exec(1), time(0.002-0.002 ms): <.main+7154>
test/lang/useOperator.ci:196:[.052c54, .052c59) exec(1), time(0.003-0.003 ms): <.main+7157>
test/lang/useOperator.ci:197:[.052c59, .052c5e) exec(1), time(0.003-0.003 ms): <.main+7162>
test/lang/useOperator.ci:198:[.052c5e, .052c63) exec(1), time(0.003-0.003 ms): <.main+7167>
test/lang/useOperator.ci:199:[.052c63, .052c68) exec(1), time(0.002-0.002 ms): <.main+7172>
test/lang/useOperator.ci:200:[.052c68, .052c6d) exec(1), time(0.002-0.002 ms): <.main+7177>
test/lang/useOperator.ci:201:[.052c6d, .052c72) exec(1), time(0.002-0.002 ms): <.main+7182>
test/lang/useOperator.ci:202:[.052c72, .052c77) exec(1), time(0.002-0.002 ms): <.main+7187>
test/lang/useOperator.ci:203:[.052c77, .052c7c) exec(1), time(0.003-0.003 ms): <.main+7192>
test/lang/useOperator.ci:204:[.052c7c, .052c81) exec(1), time(0.003-0.003 ms): <.main+7197>
test/lang/useOperator.ci:205:[.052c81, .052c86) exec(1), time(0.003-0.003 ms): <.main+7202>
test/lang/useOperator.ci:206:[.052c86, .052c8a) exec(1), time(0.003-0.003 ms): <.main+7207>
test/lang/useOperator.ci:207:[.052c8a, .052c8f) exec(1), time(0.002-0.002 ms): <.main+7211>
test/lang/useOperator.ci:208:[.052c8f, .052c95) exec(1), time(0.003-0.003 ms): <.main+7216>
test/lang/useOperator.ci:209:[.052c95, .052c9a) exec(1), time(0.003-0.003 ms): <.main+7222>
test/lang/useOperator.ci:210:[.052c9a, .052ca0) exec(1), time(0.004-0.004 ms): <.main+7227>
test/lang/useOperator.ci:211:[.052ca0, .052ca5) exec(1), time(0.003-0.003 ms): <.main+7233>
test/lang/useOperator.ci:212:[.052ca5, .052cab) exec(1), time(0.003-0.003 ms): <.main+7238>
test/lang/useOperator.ci:214:[.052cab, .052cb4) exec(1), time(0.000 ms): <.main+7244>
test/lang/useOperator.ci:215:[.052cb4, .052cbd) exec(1), time(0.000 ms): <.main+7253>
test/lang/useOperator.ci:216:[.052cbd, .052cbf) exec(1), time(0.000 ms): <.main+7262>
test/lang/useOperator.ci:217:[.052cbf, .052cc2) exec(1), time(0.002-0.002 ms): <.main+7264>
test/lang/useOperator.ci:218:[.052cc2, .052cc5) exec(1), time(0.002-0.002 ms): <.main+7267>
test/lang/useOperator.ci:219:[.052cc5, .052cca) exec(1), time(0.003-0.003 ms): <.main+7270>
test/lang/useOperator.ci:220:[.052cca, .052ccf) exec(1), time(0.002-0.002 ms): <.main+7275>
test/lang/useOperator.ci:221:[.052ccf, .052cd4) exec(1), time(0.002-0.002 ms): <.main+7280>
test/lang/useOperator.ci:222:[.052cd4, .052cd9) exec(1), time(0.003-0.003 ms): <.main+7285>
test/lang/useOperator.ci:223:[.052cd9, .052cde) exec(1), time(0.003-0.003 ms): <.main+7290>
test/lang/useOperator.ci:224:[.052cde, .052ce3) exec(1), time(0.003-0.003 ms): <.main+7295>
test/lang/useOperator.ci:225:[.052ce3, .052ce8) exec(1), time(0.002-0.002 ms): <.main+7300>
test/lang/useOperator.ci:226:[.052ce8, .052ced) exec(1), time(0.003-0.003 ms): <.main+7305>
test/lang/useOperator.ci:227:[.052ced, .052cf2) exec(1), time(0.003-0.003 ms): <.main+7310>
test/lang/useOperator.ci:228:[.052cf2, .052cf7) exec(1), time(0.003-0.003 ms): <.main+7315>
test/lang/useOperator.ci:229:[.052cf7, .052cfb) exec(1), time(0.003-0.003 ms): <.main+7320>
test/lang/useOperator.ci:230:[.052cfb, .052d00) exec(1), time(0.002-0.002 ms): <.main+7324>
test/lang/useOperator.ci:231:[.052d00, .052d06) exec(1), time(0.004-0.004 ms): <.main+7329>
test/lang/useOperator.ci:232:[.052d06, .052d0b) exec(1), time(0.003-0.003 ms): <.main+7335>
test/lang/useOperator.ci:233:[.052d0b, .052d11) exec(1), time(0.004-0.004 ms): <.main+7340>
test/lang/useOperator.ci:234:[.052d11, .052d16) exec(1), time(0.002-0.002 ms): <.main+7346>
test/lang/useOperator.ci:235:[.052d16, .052d1c) exec(1), time(0.004-0.004 ms): <.main+7351>
test/lang/useOperator.ci:237:[.052d1c, .052d21) exec(1), time(0.001-0.001 ms): <.main+7357>
test/lang/useOperator.ci:238:[.052d21, .052d26) exec(1), time(0.001-0.001 ms): <.main+7362>
test/lang/useOperator.ci:239:[.052d26, .052d28) exec(1), time(0.001-0.001 ms): <.main+7367>
test/lang/useOperator.ci:240:[.052d28, .052d2b) exec(1), time(0.002-0.002 ms): <.main+7369>
test/lang/useOperator.ci:242:[.052d2b, .052d30) exec(1), time(0.003-0.003 ms): <.main+7372>
test/lang/useOperator.ci:243:[.052d30, .052d35) exec(1), time(0.002-0.002 ms): <.main+7377>
test/lang/useOperator.ci:244:[.052d35, .052d3a) exec(1), time(0.003-0.003 ms): <.main+7382>
test/lang/useOperator.ci:245:[.052d3a, .052d3f) exec(1), time(0.003-0.003 ms): <.main+7387>
test/lang/useOperator.ci:246:[.052d3f, .052d44) exec(1), time(0.003-0.003 ms): <.main+7392>
test/lang/useOperator.ci:252:[.052d44, .052d48) exec(1), time(0.003-0.003 ms): <.main+7397>
test/lang/useOperator.ci:253:[.052d48, .052d4d) exec(1), time(0.003-0.003 ms): <.main+7401>
test/lang/useOperator.ci:254:[.052d4d, .052d53) exec(1), time(0.004-0.004 ms): <.main+7406>
test/lang/useOperator.ci:255:[.052d53, .052d58) exec(1), time(0.003-0.003 ms): <.main+7412>
test/lang/useOperator.ci:256:[.052d58, .052d5e) exec(1), time(0.004-0.004 ms): <.main+7417>
test/lang/useOperator.ci:257:[.052d5e, .052d63) exec(1), time(0.002-0.002 ms): <.main+7423>
test/lang/useOperator.ci:258:[.052d63, .052d69) exec(1), time(0.004-0.004 ms): <.main+7428>
test/lang/useOperator.ci:260:[.052d69, .052d72) exec(1), time(0.001-0.001 ms): <.main+7434>
test/lang/useOperator.ci:261:[.052d72, .052d7b) exec(1), time(0.001-0.001 ms): <.main+7443>
test/lang/useOperator.ci:262:[.052d7b, .052d7d) exec(1), time(0.000 ms): <.main+7452>
test/lang/useOperator.ci:263:[.052d7d, .052d80) exec(1), time(0.002-0.002 ms): <.main+7454>
test/lang/useOperator.ci:265:[.052d80, .052d85) exec(1), time(0.003-0.003 ms): <.main+7457>
test/lang/useOperator.ci:266:[.052d85, .052d8a) exec(1), time(0.003-0.003 ms): <.main+7462>
test/lang/useOperator.ci:267:[.052d8a, .052d8f) exec(1), time(0.003-0.003 ms): <.main+7467>
test/lang/useOperator.ci:268:[.052d8f, .052d94) exec(1), time(0.003-0.003 ms): <.main+7472>
test/lang/useOperator.ci:269:[.052d94, .052d99) exec(1), time(0.003-0.003 ms): <.main+7477>
test/lang/useOperator.ci:275:[.052d99, .052d9d) exec(1), time(0.003-0.003 ms): <.main+7482>
test/lang/useOperator.ci:276:[.052d9d, .052da2) exec(1), time(0.003-0.003 ms): <.main+7486>
test/lang/useOperator.ci:277:[.052da2, .052da8) exec(1), time(0.004-0.004 ms): <.main+7491>
test/lang/useOperator.ci:278:[.052da8, .052dad) exec(1), time(0.003-0.003 ms): <.main+7497>
test/lang/useOperator.ci:279:[.052dad, .052db3) exec(1), time(0.004-0.004 ms): <.main+7502>
test/lang/useOperator.ci:280:[.052db3, .052db8) exec(1), time(0.003-0.003 ms): <.main+7508>
test/lang/useOperator.ci:281:[.052db8, .052dbe) exec(1), time(0.004-0.004 ms): <.main+7513>
test/lang/useOperator.ci:283:[.052dbe, .052dc3) exec(1), time(0.000 ms): <.main+7519>
test/lang/useOperator.ci:284:[.052dc3, .052dc7) exec(1), time(0.000 ms): <.main+7524>
test/lang/useOperator.ci:299:[.052dc7, .052dcc) exec(1), time(0.002-0.002 ms): <.main+7528>
test/lang/useOperator.ci:300:[.052dcc, .052dd2) exec(1), time(0.004-0.004 ms): <.main+7533>
test/lang/statementIf.ci:4:[.052dd2, .052df9) exec(1), time(0.036-0.036 ms): <.main+7539>
test/lang/statementIf.ci:12:[.052df9, .052e20) exec(1), time(0.037-0.037 ms): <.main+7578>
test/lang/statementIf.ci:22:[.052e20, .052e47) exec(1), time(0.037-0.037 ms): <.main+7617>
test/lang/statementIf.ci:26:[.052e47, .052e48) exec(1), time(0.000 ms): <.main+7656>
test/lang/statementIf.ci:29:[.052e50, .052e76) exec(1), time(0.042-0.042 ms): <.main+7665>
test/lang/statementIf.ci:28:[.052e48, .052e76) exec(1-1), time(0.000 ms): <.main+7657>
test/lang/statementIf.ci:33:[.052e7e, .052ea4) exec(0), time(0.000 ms): <.main+7711>
test/lang/statementIf.ci:32:[.052e76, .052ea4) exec(1), time(0.004-0.004 ms): <.main+7703>
test/lang/statementIf.ci:37:[.052eac, .052ed2) exec(1), time(0.042-0.042 ms): <.main+7757>
test/lang/statementIf.ci:40:[.052ed6, .052efc) exec(0), time(0.000 ms): <.main+7799>
test/lang/statementIf.ci:36:[.052ea4, .052efc) exec(1), time(0.044-0.044 ms): <.main+7749>
test/lang/statementIf.ci:44:[.052f04, .052f2a) exec(0), time(0.000 ms): <.main+7845>
test/lang/statementIf.ci:47:[.052f2e, .052f54) exec(1), time(0.042-0.042 ms): <.main+7887>
test/lang/statementIf.ci:43:[.052efc, .052f54) exec(1-1), time(0.000 ms): <.main+7837>
test/lang/statementIf.ci:51:[.052f5c, .052f82) exec(1), time(0.042-0.042 ms): <.main+7933>
test/lang/statementIf.ci:54:[.052f92, .052fb8) exec(0), time(0.000 ms): <.main+7987>
test/lang/statementIf.ci:57:[.052fc8, .052fee) exec(0), time(0.000 ms): <.main+8041>
test/lang/statementIf.ci:60:[.052ffe, .053024) exec(0), time(0.000 ms): <.main+8095>
test/lang/statementIf.ci:63:[.053034, .05305a) exec(0), time(0.000 ms): <.main+8149>
test/lang/statementIf.ci:66:[.05306a, .053090) exec(0), time(0.000 ms): <.main+8203>
test/lang/statementIf.ci:69:[.053094, .0530ba) exec(0), time(0.000 ms): <.main+8245>
test/lang/statementIf.ci:65:[.05305e, .0530ba) exec(0), time(0.000 ms): <.main+8191>
test/lang/statementIf.ci:62:[.053028, .0530ba) exec(0), time(0.000 ms): <.main+8137>
test/lang/statementIf.ci:59:[.052ff2, .0530ba) exec(0), time(0.000 ms): <.main+8083>
test/lang/statementIf.ci:56:[.052fbc, .0530ba) exec(0), time(0.000 ms): <.main+8029>
test/lang/statementIf.ci:53:[.052f86, .0530ba) exec(0), time(0.000 ms): <.main+7975>
test/lang/statementIf.ci:50:[.052f54, .0530ba) exec(1), time(0.044-0.044 ms): <.main+7925>
test/lang/statementFor.ci:4:[.0530be, .0530e1) exec(1), time(0.033-0.033 ms): <.main+8287>
test/lang/statementFor.ci:5:[.0530e1, .0530e5) exec(1), time(0.000 ms): <.main+8322>
::[.0530e5, .0530e9) exec(1), time(0.001-0.001 ms): <.main+8326>
test/lang/statementFor.ci:3:[.0530ba, .0530e9) exec(1-1), time(0.000 ms): <.main+8283>
test/lang/statementFor.ci:9:[.0530ee, .053110) exec(2), time(0.074-0.074 ms): <.main+8335>
test/lang/statementFor.ci:8:[.053110, .053114) exec(2), time(0.000 ms): <.main+8369>
test/lang/statementFor.ci:8:[.053114, .053120) exec(3), time(0.012-0.012 ms): <.main+8373>
test/lang/statementFor.ci:8:[.0530e9, .053124) exec(1), time(0.006-0.006 ms): <.main+8330>
test/lang/statementFor.ci:12:[.053124, .053125) exec(1), time(0.000 ms): <.main+8389>
test/lang/statementFor.ci:14:[.05312c, .05314e) exec(2), time(0.075-0.075 ms): <.main+8397>
test/lang/statementFor.ci:13:[.05314e, .053152) exec(2), time(0.001-0.001 ms): <.main+8431>
test/lang/statementFor.ci:13:[.053152, .05315e) exec(3), time(0.013-0.013 ms): <.main+8435>
test/lang/statementFor.ci:13:[.053125, .05315e) exec(1-1), time(0.000 ms): <.main+8390>
test/lang/statementFor.ci:19:[.05316f, .053173) exec(2), time(0.000 ms): <.main+8464>
test/lang/statementFor.ci:18:[.053163, .053173) exec(7-2), time(0.022-0.022 ms): <.main+8452>
test/lang/statementFor.ci:21:[.053173, .053195) exec(5), time(0.190-0.190 ms): <.main+8468>
test/lang/statementFor.ci:17:[.053195, .053199) exec(7), time(0.002-0.002 ms): <.main+8502>
test/lang/statementFor.ci:17:[.053199, .0531a5) exec(8), time(0.036-0.036 ms): <.main+8506>
test/lang/statementFor.ci:17:[.05315e, .0531a9) exec(1), time(0.006-0.006 ms): <.main+8447>
test/lang/statementFor.ci:26:[.0531ba, .0531be) exec(1), time(0.000 ms): <.main+8539>
test/lang/statementFor.ci:25:[.0531ae, .0531be) exec(4-1), time(0.013-0.013 ms): <.main+8527>
test/lang/statementFor.ci:28:[.0531be, .0531e0) exec(3), time(0.111-0.111 ms): <.main+8543>
test/lang/statementFor.ci:24:[.0531e0, .0531e4) exec(3), time(0.002-0.002 ms): <.main+8577>
test/lang/statementFor.ci:24:[.0531e4, .0531f0) exec(4), time(0.018-0.018 ms): <.main+8581>
test/lang/statementFor.ci:24:[.0531a9, .0531f4) exec(1), time(0.002-0.002 ms): <.main+8522>
test/stdc/test.math.ci:3:[.0531f4, .053208) exec(1), time(0.034-0.034 ms): <.main+8597>
test/stdc/test.math.ci:4:[.053208, .05321c) exec(1), time(0.035-0.035 ms): <.main+8617>
test/stdc/test.math.ci:5:[.05321c, .053230) exec(1), time(0.034-0.034 ms): <.main+8637>
test/stdc/test.math.ci:6:[.053230, .053244) exec(1), time(0.049-0.049 ms): <.main+8657>
test/stdc/test.math.ci:7:[.053244, .053258) exec(1), time(0.048-0.048 ms): <.main+8677>
test/stdc/test.math.ci:8:[.053258, .05326c) exec(1), time(0.048-0.048 ms): <.main+8697>
test/stdc/test.math.ci:10:[.05326c, .053285) exec(1), time(0.013-0.013 ms): <.main+8717>
test/stdc/test.math.ci:11:[.053285, .053296) exec(1), time(0.013-0.013 ms): <.main+8742>
test/stdc/test.math.ci:12:[.053296, .0532af) exec(1), time(0.013-0.013 ms): <.main+8759>
test/stdc/test.math.ci:13:[.0532af, .0532c0) exec(1), time(0.012-0.012 ms): <.main+8784>
test/stdc/test.math.ci:14:[.0532c0, .0532cd) exec(1), time(0.012-0.012 ms): <.main+8801>
test/stdc/test.math.ci:15:[.0532cd, .0532de) exec(1), time(0.011-0.011 ms): <.main+8814>
test/stdc/test.math.ci:17:[.0532de, .0532f2) exec(1), time(0.020-0.020 ms): <.main+8831>
test/stdc/test.math.ci:18:[.0532f2, .0532fd) exec(1), time(0.019-0.019 ms): <.main+8851>
test/stdc/test.math.ci:19:[.0532fd, .053311) exec(1), time(0.020-0.020 ms): <.main+8862>
test/stdc/test.math.ci:20:[.053311, .053322) exec(1), time(0.021-0.021 ms): <.main+8882>
test/stdc/test.math.ci:21:[.053322, .05332f) exec(1), time(0.021-0.021 ms): <.main+8899>
test/stdc/test.math.ci:22:[.05332f, .053340) exec(1), time(0.021-0.021 ms): <.main+8912>
test/stdc/test.math.ci:24:[.053340, .053356) exec(1), time(0.023-0.023 ms): <.main+8929>
test/stdc/test.math.ci:25:[.053356, .05336c) exec(1), time(0.023-0.023 ms): <.main+8951>
test/stdc/test.math.ci:26:[.05336c, .053389) exec(1), time(0.021-0.021 ms): <.main+8973>
test/stdc/test.math.ci:27:[.053389, .0533a6) exec(1), time(0.022-0.022 ms): <.main+9002>
test/stdc/test.math.ci:29:[.0533a6, .0533bd) exec(1), time(0.026-0.026 ms): <.main+9031>
test/stdc/test.math.ci:30:[.0533bd, .0533db) exec(1), time(0.024-0.024 ms): <.main+9054>
test/stdc/test.math.ci:32:[.0533db, .0533f0) exec(1), time(0.012-0.012 ms): <.main+9084>
test/stdc/test.math.ci:33:[.0533f0, .05340c) exec(1), time(0.011-0.011 ms): <.main+9105>
test/stdc/test.math.ci:35:[.05340c, .053448) exec(1), time(0.050-0.050 ms): <.main+9133>
test/stdc/test.math.ci:36:[.053448, .053496) exec(1), time(0.047-0.047 ms): <.main+9193>
test/stdc/test.math.ci:38:[.053496, .0534ab) exec(1), time(0.026-0.026 ms): <.main+9271>
test/stdc/test.math.ci:39:[.0534ab, .053515) exec(1), time(0.065-0.065 ms): <.main+9292>
test/stdc/test.math.ci:40:[.053515, .05352a) exec(1), time(0.026-0.026 ms): <.main+9398>
test/stdc/test.math.ci:41:[.05352a, .053594) exec(1), time(0.066-0.066 ms): <.main+9419>
test/stdc/test.math.ci:43:[.053594, .0535a9) exec(1), time(0.029-0.029 ms): <.main+9525>
test/stdc/test.math.ci:44:[.0535a9, .0535cb) exec(1), time(0.033-0.033 ms): <.main+9546>
test/stdc/test.math.ci:45:[.0535cb, .0535f6) exec(1), time(0.037-0.037 ms): <.main+9580>
test/stdc/test.math.ci:46:[.0535f6, .053669) exec(1), time(0.070-0.070 ms): <.main+9623>
test/stdc/test.math.ci:48:[.053669, .053672) exec(1), time(0.000 ms): <.main+9738>
test/stdc/test.math.ci:49:[.053672, .053689) exec(1), time(0.033-0.033 ms): <.main+9747>
test/stdc/test.math.ci:50:[.053689, .053692) exec(1), time(0.000 ms): <.main+9770>
test/stdc/test.math.ci:51:[.053692, .0536a8) exec(1), time(0.006-0.006 ms): <.main+9779>
test/stdc/test.math.ci:52:[.0536a8, .0536cf) exec(1), time(0.013-0.013 ms): <.main+9801>
test/stdc/test.math.ci:53:[.0536cf, .053707) exec(1), time(0.022-0.022 ms): <.main+9840>
test/stdc/test.math.ci:54:[.053707, .05374f) exec(1), time(0.053-0.053 ms): <.main+9896>
test/stdc/test.math.ci:55:[.05374f, .0537a0) exec(1), time(0.056-0.056 ms): <.main+9968>
test/stdc/test.math.ci:57:[.0537a0, .0537bf) exec(1), time(0.043-0.043 ms): <.main+10049>
test/stdc/test.math.ci:58:[.0537bf, .0537ec) exec(1), time(0.061-0.061 ms): <.main+10080>
test/stdc/test.math.ci:59:[.0537ec, .05380a) exec(1), time(0.059-0.059 ms): <.main+10125>
test/stdc/test.math.ci:60:[.05380a, .053828) exec(1), time(0.058-0.058 ms): <.main+10155>
test/stdc/test.math.ci:61:[.053828, .053846) exec(1), time(0.052-0.052 ms): <.main+10185>
test/stdc/test.math.ci:63:[.053846, .05385a) exec(1), time(0.056-0.056 ms): <.main+10215>
test/stdc/test.math.ci:64:[.05385a, .053882) exec(1), time(0.060-0.060 ms): <.main+10235>
test/stdc/test.math.ci:67:[.053882, .05389e) exec(1), time(0.028-0.028 ms): <.main+10275>
test/stdc/test.math.ci:68:[.05389e, .0538c6) exec(1), time(0.029-0.029 ms): <.main+10303>
test/stdc/test.math.ci:70:[.0538c6, .0538e3) exec(1), time(0.023-0.023 ms): <.main+10343>
test/stdc/test.math.ci:71:[.0538e3, .0538f7) exec(1), time(0.021-0.021 ms): <.main+10372>
test/stdc/test.math.ci:72:[.0538f7, .053914) exec(1), time(0.022-0.022 ms): <.main+10392>
test/stdc/test.math.ci:74:[.053914, .053931) exec(1), time(0.023-0.023 ms): <.main+10421>
test/stdc/test.math.ci:75:[.053931, .05394e) exec(1), time(0.023-0.023 ms): <.main+10450>
test/stdc/test.math.ci:76:[.05394e, .05396b) exec(1), time(0.022-0.022 ms): <.main+10479>
test/stdc/test.math.ci:77:[.05396b, .053988) exec(1), time(0.022-0.022 ms): <.main+10508>
test/stdc/test.math.ci:79:[.053988, .0539a5) exec(1), time(0.022-0.022 ms): <.main+10537>
test/stdc/test.math.ci:80:[.0539a5, .0539c2) exec(1), time(0.022-0.022 ms): <.main+10566>
test/stdc/test.math.ci:81:[.0539c2, .0539df) exec(1), time(0.022-0.022 ms): <.main+10595>
test/stdc/test.math.ci:82:[.0539df, .0539fc) exec(1), time(0.022-0.022 ms): <.main+10624>
test/stdc/test.math.ci:84:[.0539fc, .053a11) exec(1), time(0.023-0.023 ms): <.main+10653>
test/stdc/test.math.ci:85:[.053a11, .053a22) exec(1), time(0.022-0.022 ms): <.main+10674>
test/stdc/test.math.ci:86:[.053a22, .053a37) exec(1), time(0.022-0.022 ms): <.main+10691>
test/stdc/test.math.ci:88:[.053a37, .053a4c) exec(1), time(0.022-0.022 ms): <.main+10712>
test/stdc/test.math.ci:89:[.053a4c, .053a61) exec(1), time(0.022-0.022 ms): <.main+10733>
test/stdc/test.math.ci:90:[.053a61, .053a76) exec(1), time(0.022-0.022 ms): <.main+10754>
test/stdc/test.math.ci:91:[.053a76, .053a8b) exec(1), time(0.022-0.022 ms): <.main+10775>
test/stdc/test.math.ci:93:[.053a8b, .053aa0) exec(1), time(0.023-0.023 ms): <.main+10796>
test/stdc/test.math.ci:94:[.053aa0, .053ab5) exec(1), time(0.022-0.022 ms): <.main+10817>
test/stdc/test.math.ci:95:[.053ab5, .053aca) exec(1), time(0.022-0.022 ms): <.main+10838>
test/stdc/test.math.ci:96:[.053aca, .053adf) exec(1), time(0.022-0.022 ms): <.main+10859>

---------- Exitcode: 0, time: 25.997 ms
