
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:59: warn: padding `NotEquals` with 4 bytes: (28 -> 32)
lib/stdlib.ci:80: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:81: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:82: warn: adding implicit cast char[*](message: char[*])
lib/stdlib.ci:79: debug: using default field initializer: NotEquals.argument := null
lib/stdlib.ci:67: warn: adding implicit cast variant(null: pointer)
lib/stdlib.ci:94: debug: inline file: `lib/std/math.ci`
lib/std/math.ci:17: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:18: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:64: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:67: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:78: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:86: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:94: warn: adding implicit cast float32(0: int32)
lib/std/math.ci:102: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(2: int32)
lib/std/math.ci:191: warn: adding implicit cast float32(3: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:192: warn: adding implicit cast float64(3: int32)
lib/std/math.ci:202: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:216: warn: adding implicit cast uint32(0: int32)
lib/std/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
lib/std/math.ci:258: warn: adding implicit cast uint32(1: int32)
lib/std/math.ci:310: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:316: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:317: warn: adding implicit cast float64(32764: int32)
lib/std/math.ci:318: warn: variable `Math.sinCos.e` hides previous declaration
lib/std/math.ci:320: warn: adding implicit cast float64(quad: int32)
lib/std/math.ci:324: warn: adding implicit cast float64(4: int32)
lib/std/math.ci:324: warn: adding implicit cast int32(e - (4) * f: float64)
lib/std/math.ci:328: warn: adding implicit cast float64(k: int32)
lib/std/math.ci:333: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:372: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:374: warn: variable `Math.tan.e` hides previous declaration
lib/std/math.ci:380: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:388: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:387: warn: statement should be a block statement {if (i == 3)}
lib/std/math.ci:383: warn: statement should be a block statement {if (i == 2)}
lib/std/math.ci:379: warn: statement should be a block statement {if (i == 1)}
lib/std/math.ci:397: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:400: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:422: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:427: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:428: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:433: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:449: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:452: warn: adding implicit cast float64(21: int32)
lib/std/math.ci:453: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:455: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:464: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:470: warn: adding implicit cast float64(0: int32)
lib/std/math.ci:475: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:480: warn: adding implicit cast float64(1: int32)
lib/std/math.ci:482: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:498: warn: adding implicit cast float64(2: int32)
lib/std/math.ci:522: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:525: warn: adding implicit cast float64(180: int32)
lib/std/math.ci:532: debug: inline file: `lib/std/math.Complex.ci`
lib/std/math.Complex.ci:24: debug: using default field initializer: Complex.im := 0
lib/std/math.Complex.ci:8: warn: adding implicit cast float64(0: int32)
lib/stdlib.ci:95: debug: inline file: `lib/std/string.ci`
lib/std/string.ci:5: warn: adding implicit cast pointer(str: char[*])
lib/std/string.ci:37: warn: adding implicit cast int32(with[i]: char)
lib/std/string.ci:65: warn: adding implicit cast int32(str[i]: char)
lib/std/string.ci:119: warn: padding `FormatFlags.padLen` with 3 bytes: (5 -> 8)
lib/std/string.ci:128: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:135: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:136: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:136: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:138: warn: adding implicit cast char(0: int32)
lib/std/string.ci:152: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/std/string.ci:155: warn: adding implicit cast uint32(0: int32)
lib/std/string.ci:155: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:156: warn: adding implicit cast uint32(radix: int32)
lib/std/string.ci:170: warn: adding implicit cast int32(sign: char)
lib/std/string.ci:175: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:180: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:187: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:194: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:199: warn: adding implicit cast int32(output.length: uint32)
lib/std/string.ci:200: warn: adding implicit cast uint32(1: int32)
lib/std/string.ci:200: warn: adding implicit cast int32(output.length - (1): uint32)
lib/std/string.ci:202: warn: adding implicit cast char(0: int32)
lib/std/string.ci:215: warn: adding implicit cast int32('-': char)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.radix := 10
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padChr := 0
lib/std/string.ci:116: warn: adding implicit cast char(0: int32)
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.padLen := 0
lib/std/string.ci:223: debug: using default field initializer: FormatFlags.precision := 0
lib/stdlib.ci:97: debug: inline file: `lib/vec/vec2d.ci`
lib/vec/vec2d.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:98: debug: inline file: `lib/vec/vec4f.ci`
lib/vec/vec4f.ci:1: warn: adding implicit cast pointer(null: typename)
lib/stdlib.ci:99: debug: inline file: `lib/vec/mat4f.ci`
lib/vec/mat4f.ci:1: warn: adding implicit cast pointer(null: typename)

---------- Compile: `test/test.ci`
test/test.ci:9: debug: inline file: `test/lang/emit.ci`
test/test.ci:10: debug: inline file: `test/lang/inlineMacros.ci`
test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.ci:11: debug: inline file: `test/lang/overload.inline.ci`
test/lang/overload.inline.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
test/test.ci:15: debug: inline file: `test/lang/initByRef.ci`
test/lang/initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:20: debug: inline file: `test/lang/function.ci`
test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
test/test.ci:21: debug: inline file: `test/lang/reflect.ci`
test/test.ci:25: debug: inline file: `test/stdc/number.ci`
test/stdc/number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc/number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc/number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc/number.ci:48: warn: adding implicit cast float32(4: int32)
test/test.ci:26: debug: inline file: `test/stdc/memory.ci`
test/test.ci:27: debug: inline file: `test/stdc/tryExec.ci`
test/stdc/tryExec.ci:20: warn: variable `divisionByZero.value` hides previous declaration
test/stdc/tryExec.ci:24: warn: variable `abortExecution.NotEquals` hides previous declaration
test/stdc/tryExec.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc/tryExec.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/test.ci:31: debug: inline file: `test/lang/array.ci`
test/lang/array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang/array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang/array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang/array.ci:101: warn: adding implicit cast int64(42: int32)
test/test.ci:32: debug: inline file: `test/lang/member.ci`
test/lang/member.ci:82: warn: ignoring nested comment
test/test.ci:33: debug: inline file: `test/lang/method.ci`
test/lang/method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
test/lang/method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
test/lang/method.ci:78: warn: comment does not belong to a declaration
test/lang/method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
test/lang/method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
test/test.ci:34: debug: inline file: `test/lang/recUnion.ci`
test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang/recUnion.ci:23: warn: variable `Color.value` hides previous declaration
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/test.ci:35: debug: inline file: `test/lang/recPacking.ci`
test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/test.ci:42: debug: inline file: `test/lang/useOperator.ci`
test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/test.ci:46: debug: inline file: `test/lang/statementIf.ci`
test/lang/statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang/statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang/statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang/statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang/statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang/statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
test/test.ci:47: debug: inline file: `test/lang/statementFor.ci`
test/test.ci:50: debug: inline file: `test/stdc/test.math.ci`
test/stdc/test.math.ci:57: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:58: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:59: warn: adding implicit cast float64(4: int32)
test/stdc/test.math.ci:60: warn: adding implicit cast float64(2: int32)
test/stdc/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
lib/std/math.ci:48: warn: using default type initializer: Math.floor.result := 0
lib/std/math.ci:315: warn: using default type initializer: Math.sinCos.y := 0
lib/std/math.ci:318: warn: using default type initializer: e := 0
lib/std/math.ci:322: warn: using default type initializer: f := 0
lib/std/math.ci:374: warn: using default type initializer: Math.tan.e := 0
lib/std/math.ci:431: warn: using default type initializer: Math.sinh.result := 0
lib/std/string.ci:148: warn: uninitialized variable `append.digits`
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:52: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
lib/vec/mat4f.ci:49: warn: uninitialized variable `.result`
test/stdc/tryExec.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang/array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang/array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang/array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang/array.ci:81: warn: uninitialized variable `strFixed`
test/lang/member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang/member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang/useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang/statementFor.ci:12: warn: using default type initializer: forIdx := 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
lib/stdlib.ci:56: warn: no code will be generated for statement: 0
test/lang/method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 152
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006178>, cast: static const inline)
.field file: function (size: 0, offs: <@006378>, cast: static const inline)
.field line: function (size: 0, offs: <@006578>, cast: static const inline)
.field name: function (size: 0, offs: <@006778>, cast: static const inline)
.usages:
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:77: referenced as `typename`
	test/lang/statementIf.ci:73: referenced as `typename`
	test/lang/array.ci:44: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:48: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:44: referenced as `typename`
	test/lang/reflect.ci:42: referenced as `typename`
	test/lang/reflect.ci:41: referenced as `typename`
	test/lang/reflect.ci:38: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:37: referenced as `typename`
	test/lang/reflect.ci:35: referenced as `typename`
	test/lang/reflect.ci:34: referenced as `typename`
	test/lang/reflect.ci:31: referenced as `typename`
	test/lang/reflect.ci:30: referenced as `typename`
	test/lang/reflect.ci:18: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:99: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:97: referenced as `typename`
	test/lang/initByRef.ci:92: referenced as `typename`
	test/lang/initByRef.ci:91: referenced as `typename`
	test/lang/initByRef.ci:90: referenced as `typename`
	test/lang/initByRef.ci:89: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:88: referenced as `typename`
	test/lang/initByRef.ci:87: referenced as `typename`
	test/lang/initByRef.ci:86: referenced as `typename`
	test/lang/initByRef.ci:85: referenced as `typename`
	test/lang/initByRef.ci:84: referenced as `typename`
	test/lang/initByRef.ci:83: referenced as `typename`
	test/lang/initByRef.ci:82: referenced as `typename`
	test/lang/initByRef.ci:81: referenced as `typename`
	test/lang/initByRef.ci:80: referenced as `typename`
	test/lang/initByRef.ci:79: referenced as `typename`
	test/lang/initByRef.ci:78: referenced as `typename`
	test/lang/initByRef.ci:77: referenced as `typename`
	test/lang/initByRef.ci:76: referenced as `typename`
	test/lang/initByRef.ci:75: referenced as `typename`
	test/lang/initByRef.ci:68: referenced as `typename`
	test/lang/initByRef.ci:48: referenced as `typename`
	test/lang/initByRef.ci:32: referenced as `typename`
	test/lang/initByRef.ci:25: referenced as `typename`
	test/lang/initByRef.ci:19: referenced as `typename`
	test/lang/initByRef.ci:3: referenced as `typename`
	lib/vec/mat4f.ci:1: referenced as `typename`
	lib/vec/vec4f.ci:1: referenced as `typename`
	lib/vec/vec2d.ci:1: referenced as `typename`
	lib/stdlib.ci:92: referenced as `typename`
	lib/stdlib.ci:12: referenced as `typename`
	internal usages: 9
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	test/lang/reflect.ci:50: referenced as `size`
	test/lang/reflect.ci:46: referenced as `size`
	lib/stdlib.ci:92: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	test/lang/reflect.ci:49: referenced as `offset`
	test/lang/reflect.ci:45: referenced as `offset`
	test/lang/reflect.ci:39: referenced as `offset`
	test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006178>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	test/lang/reflect.ci:48: referenced as `base`
	test/lang/reflect.ci:44: referenced as `base`
	test/lang/reflect.ci:37: referenced as `base`
	internal usages: 1
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006378>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	test/lang/reflect.ci:41: referenced as `file`
	test/lang/reflect.ci:34: referenced as `file`
	internal usages: 1
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006578>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	test/lang/reflect.ci:42: referenced as `line`
	test/lang/reflect.ci:35: referenced as `line`
	internal usages: 1
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006778>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
	test/lang/reflect.ci:38: referenced as `name`
	test/lang/reflect.ci:31: referenced as `name`
	internal usages: 1
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b0>
.name: 'void'
.usages:
	test/lang/method.ci:90: referenced as `void`
	test/lang/method.ci:84: referenced as `void`
	test/lang/method.ci:57: referenced as `void`
	test/lang/method.ci:47: referenced as `void`
	test/lang/method.ci:40: referenced as `void`
	test/lang/method.ci:32: referenced as `void`
	test/lang/method.ci:25: referenced as `void`
	test/lang/method.ci:18: referenced as `void`
	test/lang/method.ci:10: referenced as `void`
	test/stdc/tryExec.ci:42: referenced as `void`
	test/stdc/tryExec.ci:37: referenced as `void`
	test/stdc/tryExec.ci:23: referenced as `void`
	test/stdc/tryExec.ci:19: referenced as `void`
	test/stdc/tryExec.ci:14: referenced as `void`
	test/stdc/tryExec.ci:11: referenced as `void`
	test/lang/reflect.ci:3: referenced as `void`
	test/lang/function.ci:4: referenced as `void`
	test/lang/initByRef.ci:75: referenced as `void`
	test/lang/initByRef.ci:55: referenced as `void`
	test/lang/initByRef.ci:35: referenced as `void`
	lib/stdlib.ci:75: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:56: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:54: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	lib/stdlib.ci:52: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000150>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	test/stdc/test.math.ci:68: referenced as `bool`
	test/stdc/test.math.ci:67: referenced as `bool`
	test/lang/useOperator.ci:300: referenced as `bool`
	test/lang/useOperator.ci:299: referenced as `bool`
	test/lang/useOperator.ci:281: referenced as `bool`
	test/lang/useOperator.ci:280: referenced as `bool`
	test/lang/useOperator.ci:279: referenced as `bool`
	test/lang/useOperator.ci:278: referenced as `bool`
	test/lang/useOperator.ci:277: referenced as `bool`
	test/lang/useOperator.ci:276: referenced as `bool`
	test/lang/useOperator.ci:275: referenced as `bool`
	test/lang/useOperator.ci:258: referenced as `bool`
	test/lang/useOperator.ci:257: referenced as `bool`
	test/lang/useOperator.ci:256: referenced as `bool`
	test/lang/useOperator.ci:255: referenced as `bool`
	test/lang/useOperator.ci:254: referenced as `bool`
	test/lang/useOperator.ci:253: referenced as `bool`
	test/lang/useOperator.ci:252: referenced as `bool`
	test/lang/useOperator.ci:235: referenced as `bool`
	test/lang/useOperator.ci:234: referenced as `bool`
	test/lang/useOperator.ci:233: referenced as `bool`
	test/lang/useOperator.ci:232: referenced as `bool`
	test/lang/useOperator.ci:231: referenced as `bool`
	test/lang/useOperator.ci:230: referenced as `bool`
	test/lang/useOperator.ci:229: referenced as `bool`
	test/lang/useOperator.ci:212: referenced as `bool`
	test/lang/useOperator.ci:211: referenced as `bool`
	test/lang/useOperator.ci:210: referenced as `bool`
	test/lang/useOperator.ci:209: referenced as `bool`
	test/lang/useOperator.ci:208: referenced as `bool`
	test/lang/useOperator.ci:207: referenced as `bool`
	test/lang/useOperator.ci:206: referenced as `bool`
	test/lang/useOperator.ci:189: referenced as `bool`
	test/lang/useOperator.ci:188: referenced as `bool`
	test/lang/useOperator.ci:187: referenced as `bool`
	test/lang/useOperator.ci:186: referenced as `bool`
	test/lang/useOperator.ci:185: referenced as `bool`
	test/lang/useOperator.ci:184: referenced as `bool`
	test/lang/useOperator.ci:183: referenced as `bool`
	test/lang/useOperator.ci:166: referenced as `bool`
	test/lang/useOperator.ci:165: referenced as `bool`
	test/lang/useOperator.ci:164: referenced as `bool`
	test/lang/useOperator.ci:163: referenced as `bool`
	test/lang/useOperator.ci:162: referenced as `bool`
	test/lang/useOperator.ci:161: referenced as `bool`
	test/lang/useOperator.ci:160: referenced as `bool`
	test/lang/useOperator.ci:143: referenced as `bool`
	test/lang/useOperator.ci:142: referenced as `bool`
	test/lang/useOperator.ci:141: referenced as `bool`
	test/lang/useOperator.ci:140: referenced as `bool`
	test/lang/useOperator.ci:139: referenced as `bool`
	test/lang/useOperator.ci:138: referenced as `bool`
	test/lang/useOperator.ci:137: referenced as `bool`
	test/lang/useOperator.ci:120: referenced as `bool`
	test/lang/useOperator.ci:119: referenced as `bool`
	test/lang/useOperator.ci:118: referenced as `bool`
	test/lang/useOperator.ci:117: referenced as `bool`
	test/lang/useOperator.ci:116: referenced as `bool`
	test/lang/useOperator.ci:115: referenced as `bool`
	test/lang/useOperator.ci:114: referenced as `bool`
	test/lang/useOperator.ci:97: referenced as `bool`
	test/lang/useOperator.ci:96: referenced as `bool`
	test/lang/useOperator.ci:95: referenced as `bool`
	test/lang/useOperator.ci:94: referenced as `bool`
	test/lang/useOperator.ci:93: referenced as `bool`
	test/lang/useOperator.ci:92: referenced as `bool`
	test/lang/useOperator.ci:91: referenced as `bool`
	test/lang/useOperator.ci:74: referenced as `bool`
	test/lang/useOperator.ci:73: referenced as `bool`
	test/lang/useOperator.ci:72: referenced as `bool`
	test/lang/useOperator.ci:71: referenced as `bool`
	test/lang/useOperator.ci:70: referenced as `bool`
	test/lang/useOperator.ci:69: referenced as `bool`
	test/lang/useOperator.ci:68: referenced as `bool`
	test/lang/useOperator.ci:51: referenced as `bool`
	test/lang/useOperator.ci:50: referenced as `bool`
	test/lang/useOperator.ci:49: referenced as `bool`
	test/lang/useOperator.ci:48: referenced as `bool`
	test/lang/useOperator.ci:47: referenced as `bool`
	test/lang/useOperator.ci:46: referenced as `bool`
	test/lang/useOperator.ci:45: referenced as `bool`
	test/lang/useOperator.ci:28: referenced as `bool`
	test/lang/useOperator.ci:27: referenced as `bool`
	test/lang/useOperator.ci:26: referenced as `bool`
	test/lang/useOperator.ci:25: referenced as `bool`
	test/lang/useOperator.ci:24: referenced as `bool`
	test/lang/useOperator.ci:23: referenced as `bool`
	test/lang/useOperator.ci:22: referenced as `bool`
	test/lang/useOperator.ci:19: referenced as `bool`
	test/lang/useOperator.ci:18: referenced as `bool`
	test/lang/useOperator.ci:17: referenced as `bool`
	test/lang/useOperator.ci:8: referenced as `bool`
	test/lang/useOperator.ci:7: referenced as `bool`
	test/lang/reflect.ci:4: referenced as `bool`
	test/lang/initByRef.ci:76: referenced as `bool`
	test/lang/initByRef.ci:56: referenced as `bool`
	test/lang/initByRef.ci:36: referenced as `bool`
	lib/std/string.ci:46: referenced as `bool`
	lib/std/string.ci:36: referenced as `bool`
	lib/std/math.ci:469: referenced as `bool`
	lib/std/math.ci:421: referenced as `bool`
	lib/std/math.ci:366: referenced as `bool`
	lib/std/math.ci:365: referenced as `bool`
	lib/stdlib.ci:56: referenced as `bool`
	lib/stdlib.ci:54: referenced as `bool`
	lib/stdlib.ci:52: referenced as `bool`
	lib/stdlib.ci:3: referenced as `bool`
	internal usages: 1
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0001f0>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	test/lang/useOperator.ci:44: referenced as `char`
	test/lang/useOperator.ci:43: referenced as `char`
	test/lang/useOperator.ci:42: referenced as `char`
	test/lang/useOperator.ci:41: referenced as `char`
	test/lang/useOperator.ci:40: referenced as `char`
	test/lang/useOperator.ci:39: referenced as `char`
	test/lang/useOperator.ci:38: referenced as `char`
	test/lang/useOperator.ci:37: referenced as `char`
	test/lang/useOperator.ci:36: referenced as `char`
	test/lang/useOperator.ci:35: referenced as `char`
	test/lang/useOperator.ci:34: referenced as `char`
	test/lang/useOperator.ci:33: referenced as `char`
	test/lang/useOperator.ci:32: referenced as `char`
	test/lang/useOperator.ci:31: referenced as `char`
	test/lang/useOperator.ci:30: referenced as `char`
	test/lang/array.ci:90: referenced as `char`
	test/lang/array.ci:86: referenced as `char`
	test/lang/array.ci:81: referenced as `char`
	test/stdc/tryExec.ci:25: referenced as `char`
	test/lang/reflect.ci:41: referenced as `char`
	test/lang/reflect.ci:38: referenced as `char`
	test/lang/reflect.ci:34: referenced as `char`
	test/lang/reflect.ci:31: referenced as `char`
	test/lang/reflect.ci:5: referenced as `char`
	test/lang/initByRef.ci:77: referenced as `char`
	test/lang/initByRef.ci:57: referenced as `char`
	test/lang/initByRef.ci:37: referenced as `char`
	test/lang/emit.ci:23: referenced as `char`
	lib/std/string.ci:222: referenced as `char`
	lib/std/string.ci:212: referenced as `char`
	lib/std/string.ci:207: referenced as `char`
	lib/std/string.ci:164: referenced as `char`
	lib/std/string.ci:148: referenced as `char`
	lib/std/string.ci:145: referenced as `char`
	lib/std/string.ci:144: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:143: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:126: referenced as `char`
	lib/std/string.ci:116: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:97: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:94: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:93: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:92: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:88: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:74: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:73: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:61: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:46: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:36: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:25: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:15: referenced as `char`
	lib/std/string.ci:4: referenced as `char`
	lib/stdlib.ci:75: referenced as `char`
	lib/stdlib.ci:70: referenced as `char`
	lib/stdlib.ci:54: referenced as `char`
	lib/stdlib.ci:52: referenced as `char`
	lib/stdlib.ci:47: referenced as `char`
	lib/stdlib.ci:45: referenced as `char`
	lib/stdlib.ci:42: referenced as `char`
	lib/stdlib.ci:40: referenced as `char`
	lib/stdlib.ci:37: referenced as `char`
	lib/stdlib.ci:35: referenced as `char`
	lib/stdlib.ci:32: referenced as `char`
	lib/stdlib.ci:30: referenced as `char`
	lib/stdlib.ci:27: referenced as `char`
	lib/stdlib.ci:25: referenced as `char`
	lib/stdlib.ci:22: referenced as `char`
	lib/stdlib.ci:20: referenced as `char`
	lib/stdlib.ci:17: referenced as `char`
	lib/stdlib.ci:15: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000290>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:67: referenced as `int8`
	test/lang/useOperator.ci:66: referenced as `int8`
	test/lang/useOperator.ci:65: referenced as `int8`
	test/lang/useOperator.ci:64: referenced as `int8`
	test/lang/useOperator.ci:63: referenced as `int8`
	test/lang/useOperator.ci:62: referenced as `int8`
	test/lang/useOperator.ci:61: referenced as `int8`
	test/lang/useOperator.ci:60: referenced as `int8`
	test/lang/useOperator.ci:59: referenced as `int8`
	test/lang/useOperator.ci:58: referenced as `int8`
	test/lang/useOperator.ci:57: referenced as `int8`
	test/lang/useOperator.ci:56: referenced as `int8`
	test/lang/useOperator.ci:55: referenced as `int8`
	test/lang/useOperator.ci:54: referenced as `int8`
	test/lang/useOperator.ci:53: referenced as `int8`
	test/lang/reflect.ci:6: referenced as `int8`
	test/lang/initByRef.ci:78: referenced as `int8`
	test/lang/initByRef.ci:58: referenced as `int8`
	test/lang/initByRef.ci:38: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000330>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	test/lang/useOperator.ci:113: referenced as `int16`
	test/lang/useOperator.ci:112: referenced as `int16`
	test/lang/useOperator.ci:111: referenced as `int16`
	test/lang/useOperator.ci:110: referenced as `int16`
	test/lang/useOperator.ci:109: referenced as `int16`
	test/lang/useOperator.ci:108: referenced as `int16`
	test/lang/useOperator.ci:107: referenced as `int16`
	test/lang/useOperator.ci:106: referenced as `int16`
	test/lang/useOperator.ci:105: referenced as `int16`
	test/lang/useOperator.ci:104: referenced as `int16`
	test/lang/useOperator.ci:103: referenced as `int16`
	test/lang/useOperator.ci:102: referenced as `int16`
	test/lang/useOperator.ci:101: referenced as `int16`
	test/lang/useOperator.ci:100: referenced as `int16`
	test/lang/useOperator.ci:99: referenced as `int16`
	test/lang/reflect.ci:7: referenced as `int16`
	test/lang/initByRef.ci:79: referenced as `int16`
	test/lang/initByRef.ci:59: referenced as `int16`
	test/lang/initByRef.ci:39: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@0003d0>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	test/lang/statementFor.ci:24: referenced as `int32`
	test/lang/statementFor.ci:17: referenced as `int32`
	test/lang/statementFor.ci:12: referenced as `int32`
	test/lang/statementFor.ci:8: referenced as `int32`
	test/lang/statementIf.ci:26: referenced as `int32`
	test/lang/useOperator.ci:159: referenced as `int32`
	test/lang/useOperator.ci:158: referenced as `int32`
	test/lang/useOperator.ci:157: referenced as `int32`
	test/lang/useOperator.ci:156: referenced as `int32`
	test/lang/useOperator.ci:155: referenced as `int32`
	test/lang/useOperator.ci:154: referenced as `int32`
	test/lang/useOperator.ci:153: referenced as `int32`
	test/lang/useOperator.ci:152: referenced as `int32`
	test/lang/useOperator.ci:151: referenced as `int32`
	test/lang/useOperator.ci:150: referenced as `int32`
	test/lang/useOperator.ci:149: referenced as `int32`
	test/lang/useOperator.ci:148: referenced as `int32`
	test/lang/useOperator.ci:147: referenced as `int32`
	test/lang/useOperator.ci:146: referenced as `int32`
	test/lang/useOperator.ci:145: referenced as `int32`
	test/lang/useOperator.ci:5: referenced as `int32`
	test/lang/method.ci:90: referenced as `int32`
	test/lang/method.ci:84: referenced as `int32`
	test/lang/method.ci:57: referenced as `int32`
	test/lang/method.ci:47: referenced as `int32`
	test/lang/method.ci:40: referenced as `int32`
	test/lang/method.ci:32: referenced as `int32`
	test/lang/method.ci:25: referenced as `int32`
	test/lang/method.ci:18: referenced as `int32`
	test/lang/method.ci:10: referenced as `int32`
	test/lang/member.ci:41: referenced as `int32`
	test/lang/member.ci:38: referenced as `int32`
	test/lang/member.ci:35: referenced as `int32`
	test/lang/member.ci:20: referenced as `int32`
	test/lang/member.ci:17: referenced as `int32`
	test/lang/member.ci:14: referenced as `int32`
	test/lang/member.ci:11: referenced as `int32`
	test/lang/member.ci:7: referenced as `int32`
	test/lang/member.ci:6: referenced as `int32`
	test/lang/array.ci:118: referenced as `int32`
	test/lang/array.ci:106: referenced as `int32`
	test/lang/array.ci:105: referenced as `int32`
	test/lang/array.ci:104: referenced as `int32`
	test/lang/array.ci:103: referenced as `int32`
	test/lang/array.ci:54: referenced as `int32`
	test/lang/array.ci:45: referenced as `int32`
	test/stdc/tryExec.ci:52: referenced as `int32`
	test/stdc/tryExec.ci:51: referenced as `int32`
	test/stdc/tryExec.ci:50: referenced as `int32`
	test/stdc/tryExec.ci:49: referenced as `int32`
	test/stdc/tryExec.ci:48: referenced as `int32`
	test/stdc/tryExec.ci:47: referenced as `int32`
	test/stdc/tryExec.ci:46: referenced as `int32`
	test/stdc/tryExec.ci:39: referenced as `int32`
	test/stdc/tryExec.ci:38: referenced as `int32`
	test/stdc/tryExec.ci:27: referenced as `int32`
	test/stdc/tryExec.ci:26: referenced as `int32`
	test/stdc/tryExec.ci:20: referenced as `int32`
	test/stdc/memory.ci:4: referenced as `int32`
	test/stdc/memory.ci:3: referenced as `int32`
	test/stdc/number.ci:66: referenced as `int32`
	test/stdc/number.ci:65: referenced as `int32`
	test/stdc/number.ci:63: referenced as `int32`
	test/stdc/number.ci:62: referenced as `int32`
	test/stdc/number.ci:60: referenced as `int32`
	test/stdc/number.ci:59: referenced as `int32`
	test/stdc/number.ci:58: referenced as `int32`
	test/stdc/number.ci:57: referenced as `int32`
	test/stdc/number.ci:55: referenced as `int32`
	test/stdc/number.ci:35: referenced as `int32`
	test/stdc/number.ci:34: referenced as `int32`
	test/stdc/number.ci:33: referenced as `int32`
	test/stdc/number.ci:31: referenced as `int32`
	test/stdc/number.ci:30: referenced as `int32`
	test/stdc/number.ci:29: referenced as `int32`
	test/stdc/number.ci:27: referenced as `int32`
	test/stdc/number.ci:26: referenced as `int32`
	test/stdc/number.ci:25: referenced as `int32`
	test/stdc/number.ci:23: referenced as `int32`
	test/stdc/number.ci:22: referenced as `int32`
	test/stdc/number.ci:21: referenced as `int32`
	test/stdc/number.ci:19: referenced as `int32`
	test/stdc/number.ci:18: referenced as `int32`
	test/stdc/number.ci:16: referenced as `int32`
	test/stdc/number.ci:15: referenced as `int32`
	test/stdc/number.ci:14: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:12: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/stdc/number.ci:10: referenced as `int32`
	test/lang/reflect.ci:50: referenced as `int32`
	test/lang/reflect.ci:49: referenced as `int32`
	test/lang/reflect.ci:46: referenced as `int32`
	test/lang/reflect.ci:45: referenced as `int32`
	test/lang/reflect.ci:42: referenced as `int32`
	test/lang/reflect.ci:40: referenced as `int32`
	test/lang/reflect.ci:39: referenced as `int32`
	test/lang/reflect.ci:35: referenced as `int32`
	test/lang/reflect.ci:33: referenced as `int32`
	test/lang/reflect.ci:32: referenced as `int32`
	test/lang/reflect.ci:27: referenced as `int32`
	test/lang/reflect.ci:20: referenced as `int32`
	test/lang/reflect.ci:19: referenced as `int32`
	test/lang/reflect.ci:18: referenced as `int32`
	test/lang/reflect.ci:17: referenced as `int32`
	test/lang/reflect.ci:16: referenced as `int32`
	test/lang/reflect.ci:15: referenced as `int32`
	test/lang/reflect.ci:14: referenced as `int32`
	test/lang/reflect.ci:13: referenced as `int32`
	test/lang/reflect.ci:12: referenced as `int32`
	test/lang/reflect.ci:11: referenced as `int32`
	test/lang/reflect.ci:10: referenced as `int32`
	test/lang/reflect.ci:9: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:8: referenced as `int32`
	test/lang/reflect.ci:7: referenced as `int32`
	test/lang/reflect.ci:6: referenced as `int32`
	test/lang/reflect.ci:5: referenced as `int32`
	test/lang/reflect.ci:4: referenced as `int32`
	test/lang/reflect.ci:3: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:33: referenced as `int32`
	test/lang/function.ci:30: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:27: referenced as `int32`
	test/lang/function.ci:24: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:21: referenced as `int32`
	test/lang/function.ci:18: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:15: referenced as `int32`
	test/lang/function.ci:12: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/function.ci:7: referenced as `int32`
	test/lang/initByRef.ci:80: referenced as `int32`
	test/lang/initByRef.ci:60: referenced as `int32`
	test/lang/initByRef.ci:40: referenced as `int32`
	test/lang/initByRef.ci:4: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:7: referenced as `int32`
	test/lang/overload.inline.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:73: referenced as `int32`
	test/lang/inlineMacros.ci:72: referenced as `int32`
	test/lang/inlineMacros.ci:71: referenced as `int32`
	test/lang/inlineMacros.ci:70: referenced as `int32`
	test/lang/inlineMacros.ci:69: referenced as `int32`
	test/lang/inlineMacros.ci:68: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:67: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:66: referenced as `int32`
	test/lang/inlineMacros.ci:64: referenced as `int32`
	test/lang/inlineMacros.ci:63: referenced as `int32`
	test/lang/inlineMacros.ci:62: referenced as `int32`
	test/lang/inlineMacros.ci:61: referenced as `int32`
	test/lang/inlineMacros.ci:60: referenced as `int32`
	test/lang/inlineMacros.ci:59: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:58: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:57: referenced as `int32`
	test/lang/inlineMacros.ci:55: referenced as `int32`
	test/lang/inlineMacros.ci:54: referenced as `int32`
	test/lang/inlineMacros.ci:53: referenced as `int32`
	test/lang/inlineMacros.ci:52: referenced as `int32`
	test/lang/inlineMacros.ci:51: referenced as `int32`
	test/lang/inlineMacros.ci:50: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:49: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:48: referenced as `int32`
	test/lang/inlineMacros.ci:46: referenced as `int32`
	test/lang/inlineMacros.ci:45: referenced as `int32`
	test/lang/inlineMacros.ci:44: referenced as `int32`
	test/lang/inlineMacros.ci:43: referenced as `int32`
	test/lang/inlineMacros.ci:42: referenced as `int32`
	test/lang/inlineMacros.ci:41: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:40: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:39: referenced as `int32`
	test/lang/inlineMacros.ci:37: referenced as `int32`
	test/lang/inlineMacros.ci:36: referenced as `int32`
	test/lang/inlineMacros.ci:35: referenced as `int32`
	test/lang/inlineMacros.ci:33: referenced as `int32`
	test/lang/inlineMacros.ci:32: referenced as `int32`
	test/lang/inlineMacros.ci:31: referenced as `int32`
	test/lang/inlineMacros.ci:29: referenced as `int32`
	test/lang/inlineMacros.ci:28: referenced as `int32`
	test/lang/inlineMacros.ci:27: referenced as `int32`
	test/lang/inlineMacros.ci:25: referenced as `int32`
	test/lang/inlineMacros.ci:24: referenced as `int32`
	test/lang/inlineMacros.ci:23: referenced as `int32`
	test/lang/inlineMacros.ci:21: referenced as `int32`
	test/lang/inlineMacros.ci:20: referenced as `int32`
	test/lang/inlineMacros.ci:19: referenced as `int32`
	test/lang/inlineMacros.ci:17: referenced as `int32`
	test/lang/inlineMacros.ci:16: referenced as `int32`
	test/lang/inlineMacros.ci:15: referenced as `int32`
	test/lang/inlineMacros.ci:13: referenced as `int32`
	test/lang/inlineMacros.ci:12: referenced as `int32`
	test/lang/inlineMacros.ci:11: referenced as `int32`
	test/lang/inlineMacros.ci:10: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:8: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:7: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:6: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:5: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:4: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/inlineMacros.ci:3: referenced as `int32`
	test/lang/emit.ci:23: referenced as `int32`
	test/lang/emit.ci:19: referenced as `int32`
	test/lang/emit.ci:17: referenced as `int32`
	test/lang/emit.ci:14: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:10: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:9: referenced as `int32`
	test/lang/emit.ci:7: referenced as `int32`
	test/lang/emit.ci:6: referenced as `int32`
	test/lang/emit.ci:3: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:222: referenced as `int32`
	lib/std/string.ci:213: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:212: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:207: referenced as `int32`
	lib/std/string.ci:193: referenced as `int32`
	lib/std/string.ci:162: referenced as `int32`
	lib/std/string.ci:150: referenced as `int32`
	lib/std/string.ci:147: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:143: referenced as `int32`
	lib/std/string.ci:127: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:126: referenced as `int32`
	lib/std/string.ci:122: referenced as `int32`
	lib/std/string.ci:119: referenced as `int32`
	lib/std/string.ci:113: referenced as `int32`
	lib/std/string.ci:88: referenced as `int32`
	lib/std/string.ci:73: referenced as `int32`
	lib/std/string.ci:63: referenced as `int32`
	lib/std/string.ci:62: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:61: referenced as `int32`
	lib/std/string.ci:52: referenced as `int32`
	lib/std/string.ci:48: referenced as `int32`
	lib/std/string.ci:47: referenced as `int32`
	lib/std/string.ci:46: referenced as `int32`
	lib/std/string.ci:37: referenced as `int32`
	lib/std/string.ci:36: referenced as `int32`
	lib/std/string.ci:27: referenced as `int32`
	lib/std/string.ci:26: referenced as `int32`
	lib/std/string.ci:25: referenced as `int32`
	lib/std/string.ci:16: referenced as `int32`
	lib/std/string.ci:15: referenced as `int32`
	lib/std/string.ci:8: referenced as `int32`
	lib/std/string.ci:4: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:376: referenced as `int32`
	lib/std/math.ci:327: referenced as `int32`
	lib/std/math.ci:295: referenced as `int32`
	lib/std/math.ci:280: referenced as `int32`
	lib/std/math.ci:265: referenced as `int32`
	lib/std/math.ci:258: referenced as `int32`
	lib/std/math.ci:231: referenced as `int32`
	lib/std/math.ci:220: referenced as `int32`
	lib/std/math.ci:206: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:67: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/std/math.ci:64: referenced as `int32`
	lib/stdlib.ci:92: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:87: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	lib/stdlib.ci:75: referenced as `int32`
	internal usages: 39
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@000470>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	test/lang/statementIf.ci:77: referenced as `int64`
	test/lang/statementIf.ci:73: referenced as `int64`
	test/lang/useOperator.ci:205: referenced as `int64`
	test/lang/useOperator.ci:204: referenced as `int64`
	test/lang/useOperator.ci:203: referenced as `int64`
	test/lang/useOperator.ci:202: referenced as `int64`
	test/lang/useOperator.ci:201: referenced as `int64`
	test/lang/useOperator.ci:200: referenced as `int64`
	test/lang/useOperator.ci:199: referenced as `int64`
	test/lang/useOperator.ci:198: referenced as `int64`
	test/lang/useOperator.ci:197: referenced as `int64`
	test/lang/useOperator.ci:196: referenced as `int64`
	test/lang/useOperator.ci:195: referenced as `int64`
	test/lang/useOperator.ci:194: referenced as `int64`
	test/lang/useOperator.ci:193: referenced as `int64`
	test/lang/useOperator.ci:192: referenced as `int64`
	test/lang/useOperator.ci:191: referenced as `int64`
	test/lang/array.ci:119: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:106: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:105: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:104: referenced as `int64`
	test/lang/array.ci:103: referenced as `int64`
	test/lang/array.ci:71: referenced as `int64`
	test/lang/array.ci:68: referenced as `int64`
	test/lang/array.ci:67: referenced as `int64`
	test/lang/array.ci:64: referenced as `int64`
	test/lang/array.ci:63: referenced as `int64`
	test/lang/array.ci:60: referenced as `int64`
	test/lang/array.ci:59: referenced as `int64`
	test/lang/array.ci:51: referenced as `int64`
	test/lang/array.ci:50: referenced as `int64`
	test/lang/array.ci:49: referenced as `int64`
	test/lang/array.ci:44: referenced as `int64`
	test/stdc/memory.ci:30: referenced as `int64`
	test/stdc/memory.ci:29: referenced as `int64`
	test/stdc/memory.ci:24: referenced as `int64`
	test/stdc/memory.ci:23: referenced as `int64`
	test/lang/reflect.ci:23: referenced as `int64`
	test/lang/reflect.ci:9: referenced as `int64`
	test/lang/initByRef.ci:81: referenced as `int64`
	test/lang/initByRef.ci:61: referenced as `int64`
	test/lang/initByRef.ci:41: referenced as `int64`
	test/lang/initByRef.ci:29: referenced as `int64`
	test/lang/initByRef.ci:28: referenced as `int64`
	test/lang/initByRef.ci:27: referenced as `int64`
	test/lang/initByRef.ci:25: referenced as `int64`
	test/lang/initByRef.ci:24: referenced as `int64`
	test/lang/initByRef.ci:23: referenced as `int64`
	test/lang/initByRef.ci:16: referenced as `int64`
	test/lang/initByRef.ci:14: referenced as `int64`
	test/lang/initByRef.ci:13: referenced as `int64`
	test/lang/initByRef.ci:12: referenced as `int64`
	test/lang/initByRef.ci:8: referenced as `int64`
	test/lang/initByRef.ci:7: referenced as `int64`
	test/lang/initByRef.ci:3: referenced as `int64`
	test/lang/emit.ci:20: referenced as `int64`
	test/lang/emit.ci:18: referenced as `int64`
	test/lang/emit.ci:15: referenced as `int64`
	test/lang/emit.ci:4: referenced as `int64`
	test/test.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000510>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:90: referenced as `uint8`
	test/lang/useOperator.ci:89: referenced as `uint8`
	test/lang/useOperator.ci:88: referenced as `uint8`
	test/lang/useOperator.ci:87: referenced as `uint8`
	test/lang/useOperator.ci:86: referenced as `uint8`
	test/lang/useOperator.ci:85: referenced as `uint8`
	test/lang/useOperator.ci:84: referenced as `uint8`
	test/lang/useOperator.ci:83: referenced as `uint8`
	test/lang/useOperator.ci:82: referenced as `uint8`
	test/lang/useOperator.ci:81: referenced as `uint8`
	test/lang/useOperator.ci:80: referenced as `uint8`
	test/lang/useOperator.ci:79: referenced as `uint8`
	test/lang/useOperator.ci:78: referenced as `uint8`
	test/lang/useOperator.ci:77: referenced as `uint8`
	test/lang/useOperator.ci:76: referenced as `uint8`
	test/lang/recPacking.ci:57: referenced as `uint8`
	test/lang/recPacking.ci:55: referenced as `uint8`
	test/lang/recPacking.ci:53: referenced as `uint8`
	test/lang/recPacking.ci:47: referenced as `uint8`
	test/lang/recPacking.ci:45: referenced as `uint8`
	test/lang/recPacking.ci:43: referenced as `uint8`
	test/lang/recPacking.ci:37: referenced as `uint8`
	test/lang/recPacking.ci:35: referenced as `uint8`
	test/lang/recPacking.ci:33: referenced as `uint8`
	test/lang/recPacking.ci:27: referenced as `uint8`
	test/lang/recPacking.ci:25: referenced as `uint8`
	test/lang/recPacking.ci:23: referenced as `uint8`
	test/lang/recPacking.ci:17: referenced as `uint8`
	test/lang/recPacking.ci:15: referenced as `uint8`
	test/lang/recPacking.ci:13: referenced as `uint8`
	test/lang/recPacking.ci:7: referenced as `uint8`
	test/lang/recPacking.ci:5: referenced as `uint8`
	test/lang/recPacking.ci:3: referenced as `uint8`
	test/lang/recUnion.ci:12: referenced as `uint8`
	test/lang/recUnion.ci:11: referenced as `uint8`
	test/lang/recUnion.ci:10: referenced as `uint8`
	test/stdc/tryExec.ci:15: referenced as `uint8`
	test/lang/reflect.ci:10: referenced as `uint8`
	test/lang/initByRef.ci:82: referenced as `uint8`
	test/lang/initByRef.ci:62: referenced as `uint8`
	test/lang/initByRef.ci:42: referenced as `uint8`
	lib/stdlib.ci:8: referenced as `uint8`
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005b0>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	test/lang/useOperator.ci:136: referenced as `uint16`
	test/lang/useOperator.ci:135: referenced as `uint16`
	test/lang/useOperator.ci:134: referenced as `uint16`
	test/lang/useOperator.ci:133: referenced as `uint16`
	test/lang/useOperator.ci:132: referenced as `uint16`
	test/lang/useOperator.ci:131: referenced as `uint16`
	test/lang/useOperator.ci:130: referenced as `uint16`
	test/lang/useOperator.ci:129: referenced as `uint16`
	test/lang/useOperator.ci:128: referenced as `uint16`
	test/lang/useOperator.ci:127: referenced as `uint16`
	test/lang/useOperator.ci:126: referenced as `uint16`
	test/lang/useOperator.ci:125: referenced as `uint16`
	test/lang/useOperator.ci:124: referenced as `uint16`
	test/lang/useOperator.ci:123: referenced as `uint16`
	test/lang/useOperator.ci:122: referenced as `uint16`
	test/lang/recPacking.ci:58: referenced as `uint16`
	test/lang/recPacking.ci:48: referenced as `uint16`
	test/lang/recPacking.ci:38: referenced as `uint16`
	test/lang/recPacking.ci:28: referenced as `uint16`
	test/lang/recPacking.ci:18: referenced as `uint16`
	test/lang/recPacking.ci:8: referenced as `uint16`
	test/lang/reflect.ci:11: referenced as `uint16`
	test/lang/initByRef.ci:83: referenced as `uint16`
	test/lang/initByRef.ci:63: referenced as `uint16`
	test/lang/initByRef.ci:43: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@000650>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@0093b8>, cast: static const inline)
.field sxt: function (size: 0, offs: <@0096e8>, cast: static const inline)
.field pop: function (size: 0, offs: <@0098e8>, cast: static const inline)
.field swap: function (size: 0, offs: <@009ae8>, cast: static const inline)
.field bsr: function (size: 0, offs: <@009ce8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@009ee8>, cast: static const inline)
.field hib: function (size: 0, offs: <@00a0e8>, cast: static const inline)
.field lob: function (size: 0, offs: <@00a2e8>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:182: referenced as `uint32`
	test/lang/useOperator.ci:181: referenced as `uint32`
	test/lang/useOperator.ci:180: referenced as `uint32`
	test/lang/useOperator.ci:179: referenced as `uint32`
	test/lang/useOperator.ci:178: referenced as `uint32`
	test/lang/useOperator.ci:177: referenced as `uint32`
	test/lang/useOperator.ci:176: referenced as `uint32`
	test/lang/useOperator.ci:175: referenced as `uint32`
	test/lang/useOperator.ci:174: referenced as `uint32`
	test/lang/useOperator.ci:173: referenced as `uint32`
	test/lang/useOperator.ci:172: referenced as `uint32`
	test/lang/useOperator.ci:171: referenced as `uint32`
	test/lang/useOperator.ci:170: referenced as `uint32`
	test/lang/useOperator.ci:169: referenced as `uint32`
	test/lang/useOperator.ci:168: referenced as `uint32`
	test/lang/recPacking.ci:56: referenced as `uint32`
	test/lang/recPacking.ci:46: referenced as `uint32`
	test/lang/recPacking.ci:36: referenced as `uint32`
	test/lang/recPacking.ci:26: referenced as `uint32`
	test/lang/recPacking.ci:16: referenced as `uint32`
	test/lang/recPacking.ci:6: referenced as `uint32`
	test/lang/recUnion.ci:17: referenced as `uint32`
	test/stdc/number.ci:63: referenced as `uint32`
	test/stdc/number.ci:62: referenced as `uint32`
	test/stdc/number.ci:60: referenced as `uint32`
	test/stdc/number.ci:59: referenced as `uint32`
	test/stdc/number.ci:58: referenced as `uint32`
	test/stdc/number.ci:57: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:56: referenced as `uint32`
	test/stdc/number.ci:55: referenced as `uint32`
	test/stdc/number.ci:35: referenced as `uint32`
	test/stdc/number.ci:34: referenced as `uint32`
	test/stdc/number.ci:33: referenced as `uint32`
	test/stdc/number.ci:31: referenced as `uint32`
	test/stdc/number.ci:30: referenced as `uint32`
	test/stdc/number.ci:29: referenced as `uint32`
	test/stdc/number.ci:27: referenced as `uint32`
	test/stdc/number.ci:26: referenced as `uint32`
	test/stdc/number.ci:25: referenced as `uint32`
	test/stdc/number.ci:23: referenced as `uint32`
	test/stdc/number.ci:22: referenced as `uint32`
	test/stdc/number.ci:21: referenced as `uint32`
	test/lang/reflect.ci:12: referenced as `uint32`
	test/lang/function.ci:46: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/function.ci:38: referenced as `uint32`
	test/lang/initByRef.ci:84: referenced as `uint32`
	test/lang/initByRef.ci:64: referenced as `uint32`
	test/lang/initByRef.ci:44: referenced as `uint32`
	lib/std/string.ci:222: referenced as `uint32`
	lib/std/string.ci:207: referenced as `uint32`
	lib/std/string.ci:143: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093b8>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(20)
.usages:
	test/stdc/number.ci:62: referenced as `zxt`
	test/stdc/number.ci:31: referenced as `zxt`
	test/stdc/number.ci:30: referenced as `zxt`
	test/stdc/number.ci:29: referenced as `zxt`
	test/stdc/number.ci:23: referenced as `zxt`
	test/stdc/number.ci:22: referenced as `zxt`
	test/stdc/number.ci:21: referenced as `zxt`
	internal usages: 1
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096e8>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(21)
.usages:
	test/stdc/number.ci:63: referenced as `sxt`
	test/stdc/number.ci:35: referenced as `sxt`
	test/stdc/number.ci:34: referenced as `sxt`
	test/stdc/number.ci:33: referenced as `sxt`
	test/stdc/number.ci:27: referenced as `sxt`
	test/stdc/number.ci:26: referenced as `sxt`
	test/stdc/number.ci:25: referenced as `sxt`
	internal usages: 1
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0098e8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(22)
.usages:
	test/stdc/number.ci:55: referenced as `pop`
	internal usages: 1
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ae8>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	test/stdc/number.ci:56: referenced as `swap`
	internal usages: 1
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ce8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	test/stdc/number.ci:57: referenced as `bsr`
	internal usages: 1
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009ee8>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	test/stdc/number.ci:58: referenced as `bsf`
	internal usages: 1
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a0e8>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	test/stdc/number.ci:59: referenced as `hib`
	internal usages: 1
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2e8>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	test/stdc/number.ci:60: referenced as `lob`
	internal usages: 1
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@0006f0>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00a610>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a938>, cast: static const inline)
.value: 0
.usages:
	test/lang/useOperator.ci:228: referenced as `uint64`
	test/lang/useOperator.ci:227: referenced as `uint64`
	test/lang/useOperator.ci:226: referenced as `uint64`
	test/lang/useOperator.ci:225: referenced as `uint64`
	test/lang/useOperator.ci:224: referenced as `uint64`
	test/lang/useOperator.ci:223: referenced as `uint64`
	test/lang/useOperator.ci:222: referenced as `uint64`
	test/lang/useOperator.ci:221: referenced as `uint64`
	test/lang/useOperator.ci:220: referenced as `uint64`
	test/lang/useOperator.ci:219: referenced as `uint64`
	test/lang/useOperator.ci:218: referenced as `uint64`
	test/lang/useOperator.ci:217: referenced as `uint64`
	test/lang/useOperator.ci:216: referenced as `uint64`
	test/lang/useOperator.ci:215: referenced as `uint64`
	test/lang/useOperator.ci:214: referenced as `uint64`
	test/lang/recPacking.ci:54: referenced as `uint64`
	test/lang/recPacking.ci:44: referenced as `uint64`
	test/lang/recPacking.ci:34: referenced as `uint64`
	test/lang/recPacking.ci:24: referenced as `uint64`
	test/lang/recPacking.ci:14: referenced as `uint64`
	test/lang/recPacking.ci:4: referenced as `uint64`
	test/stdc/number.ci:66: referenced as `uint64`
	test/stdc/number.ci:65: referenced as `uint64`
	test/lang/reflect.ci:13: referenced as `uint64`
	test/lang/initByRef.ci:85: referenced as `uint64`
	test/lang/initByRef.ci:65: referenced as `uint64`
	test/lang/initByRef.ci:45: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a610>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(28)
.usages:
	test/stdc/number.ci:65: referenced as `zxt`
	internal usages: 1
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a938>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(29)
.usages:
	test/stdc/number.ci:66: referenced as `sxt`
	internal usages: 1
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@000790>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00ab38>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ad38>, cast: static const inline)
.field tan: function (size: 0, offs: <@00af38>, cast: static const inline)
.field log: function (size: 0, offs: <@00b138>, cast: static const inline)
.field exp: function (size: 0, offs: <@00b338>, cast: static const inline)
.field pow: function (size: 0, offs: <@00b5d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00b7d0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00ba68>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:96: referenced as `float32`
	test/stdc/test.math.ci:95: referenced as `float32`
	test/stdc/test.math.ci:94: referenced as `float32`
	test/stdc/test.math.ci:93: referenced as `float32`
	test/stdc/test.math.ci:91: referenced as `float32`
	test/stdc/test.math.ci:90: referenced as `float32`
	test/stdc/test.math.ci:89: referenced as `float32`
	test/stdc/test.math.ci:88: referenced as `float32`
	test/stdc/test.math.ci:86: referenced as `float32`
	test/stdc/test.math.ci:85: referenced as `float32`
	test/stdc/test.math.ci:84: referenced as `float32`
	test/lang/useOperator.ci:246: referenced as `float32`
	test/lang/useOperator.ci:245: referenced as `float32`
	test/lang/useOperator.ci:244: referenced as `float32`
	test/lang/useOperator.ci:243: referenced as `float32`
	test/lang/useOperator.ci:242: referenced as `float32`
	test/lang/useOperator.ci:240: referenced as `float32`
	test/lang/useOperator.ci:239: referenced as `float32`
	test/lang/useOperator.ci:238: referenced as `float32`
	test/lang/useOperator.ci:237: referenced as `float32`
	test/lang/recUnion.ci:5: referenced as `float32`
	test/lang/recUnion.ci:4: referenced as `float32`
	test/lang/recUnion.ci:3: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:53: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:52: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:51: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:50: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:49: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:48: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:47: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:46: referenced as `float32`
	test/stdc/number.ci:7: referenced as `float32`
	test/stdc/number.ci:6: referenced as `float32`
	test/lang/reflect.ci:14: referenced as `float32`
	test/lang/initByRef.ci:86: referenced as `float32`
	test/lang/initByRef.ci:66: referenced as `float32`
	test/lang/initByRef.ci:46: referenced as `float32`
	test/lang/overload.inline.ci:13: referenced as `float32`
	test/lang/overload.inline.ci:12: referenced as `float32`
	test/lang/overload.inline.ci:11: referenced as `float32`
	test/lang/overload.inline.ci:10: referenced as `float32`
	test/lang/overload.inline.ci:9: referenced as `float32`
	test/lang/overload.inline.ci:6: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	test/lang/emit.ci:14: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:30: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:29: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:28: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:27: referenced as `float32`
	lib/vec/mat4f.ci:9: referenced as `float32`
	lib/vec/mat4f.ci:6: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:103: referenced as `float32`
	lib/vec/vec4f.ci:98: referenced as `float32`
	lib/vec/vec4f.ci:92: referenced as `float32`
	lib/vec/vec4f.ci:88: referenced as `float32`
	lib/vec/vec4f.ci:84: referenced as `float32`
	lib/vec/vec4f.ci:80: referenced as `float32`
	lib/vec/vec4f.ci:78: referenced as `float32`
	lib/vec/vec4f.ci:36: referenced as `float32`
	lib/vec/vec4f.ci:34: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:32: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:28: referenced as `float32`
	lib/vec/vec4f.ci:15: referenced as `float32`
	lib/vec/vec4f.ci:13: referenced as `float32`
	lib/vec/vec4f.ci:11: referenced as `float32`
	lib/vec/vec4f.ci:9: referenced as `float32`
	lib/vec/vec4f.ci:6: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:265: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:195: referenced as `float32`
	lib/std/math.ci:191: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:186: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:159: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:137: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:115: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:93: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:77: referenced as `float32`
	lib/std/math.ci:64: referenced as `float32`
	lib/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab38>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(30)
.usages:
	test/stdc/number.ci:46: referenced as `sin`
	internal usages: 1
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad38>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	test/stdc/number.ci:47: referenced as `cos`
	internal usages: 1
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af38>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	test/stdc/number.ci:48: referenced as `tan`
	internal usages: 1
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b138>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	test/stdc/number.ci:49: referenced as `log`
	internal usages: 1
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b338>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	test/stdc/number.ci:50: referenced as `exp`
	internal usages: 1
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5d0>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(35)
.usages:
	test/stdc/number.ci:51: referenced as `pow`
	internal usages: 1
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b7d0>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(36)
.usages:
	test/stdc/number.ci:52: referenced as `sqrt`
	lib/vec/vec4f.ci:98: referenced as `sqrt`
	internal usages: 1
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba68>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(37)
.usages:
	test/stdc/number.ci:53: referenced as `atan2`
	internal usages: 1
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000830>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00bc60>, cast: static const inline)
.field cos: function (size: 0, offs: <@00be58>, cast: static const inline)
.field tan: function (size: 0, offs: <@00c050>, cast: static const inline)
.field log: function (size: 0, offs: <@00c248>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c440>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c6d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c8c8>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00cb58>, cast: static const inline)
.value: 0
.usages:
	test/stdc/test.math.ci:82: referenced as `float64`
	test/stdc/test.math.ci:81: referenced as `float64`
	test/stdc/test.math.ci:80: referenced as `float64`
	test/stdc/test.math.ci:79: referenced as `float64`
	test/stdc/test.math.ci:77: referenced as `float64`
	test/stdc/test.math.ci:76: referenced as `float64`
	test/stdc/test.math.ci:75: referenced as `float64`
	test/stdc/test.math.ci:74: referenced as `float64`
	test/stdc/test.math.ci:72: referenced as `float64`
	test/stdc/test.math.ci:71: referenced as `float64`
	test/stdc/test.math.ci:70: referenced as `float64`
	test/stdc/test.math.ci:64: referenced as `float64`
	test/stdc/test.math.ci:63: referenced as `float64`
	test/stdc/test.math.ci:61: referenced as `float64`
	test/stdc/test.math.ci:60: referenced as `float64`
	test/stdc/test.math.ci:59: referenced as `float64`
	test/stdc/test.math.ci:58: referenced as `float64`
	test/stdc/test.math.ci:57: referenced as `float64`
	test/stdc/test.math.ci:55: referenced as `float64`
	test/stdc/test.math.ci:54: referenced as `float64`
	test/stdc/test.math.ci:53: referenced as `float64`
	test/stdc/test.math.ci:52: referenced as `float64`
	test/stdc/test.math.ci:51: referenced as `float64`
	test/stdc/test.math.ci:50: referenced as `float64`
	test/stdc/test.math.ci:49: referenced as `float64`
	test/stdc/test.math.ci:48: referenced as `float64`
	test/stdc/test.math.ci:46: referenced as `float64`
	test/stdc/test.math.ci:45: referenced as `float64`
	test/stdc/test.math.ci:44: referenced as `float64`
	test/stdc/test.math.ci:43: referenced as `float64`
	test/stdc/test.math.ci:41: referenced as `float64`
	test/stdc/test.math.ci:40: referenced as `float64`
	test/stdc/test.math.ci:39: referenced as `float64`
	test/stdc/test.math.ci:38: referenced as `float64`
	test/stdc/test.math.ci:36: referenced as `float64`
	test/stdc/test.math.ci:35: referenced as `float64`
	test/stdc/test.math.ci:33: referenced as `float64`
	test/stdc/test.math.ci:32: referenced as `float64`
	test/stdc/test.math.ci:30: referenced as `float64`
	test/stdc/test.math.ci:29: referenced as `float64`
	test/stdc/test.math.ci:27: referenced as `float64`
	test/stdc/test.math.ci:26: referenced as `float64`
	test/stdc/test.math.ci:25: referenced as `float64`
	test/stdc/test.math.ci:24: referenced as `float64`
	test/stdc/test.math.ci:22: referenced as `float64`
	test/stdc/test.math.ci:21: referenced as `float64`
	test/stdc/test.math.ci:20: referenced as `float64`
	test/stdc/test.math.ci:19: referenced as `float64`
	test/stdc/test.math.ci:18: referenced as `float64`
	test/stdc/test.math.ci:17: referenced as `float64`
	test/stdc/test.math.ci:15: referenced as `float64`
	test/stdc/test.math.ci:14: referenced as `float64`
	test/stdc/test.math.ci:13: referenced as `float64`
	test/stdc/test.math.ci:12: referenced as `float64`
	test/stdc/test.math.ci:11: referenced as `float64`
	test/stdc/test.math.ci:10: referenced as `float64`
	test/stdc/test.math.ci:8: referenced as `float64`
	test/stdc/test.math.ci:7: referenced as `float64`
	test/stdc/test.math.ci:6: referenced as `float64`
	test/stdc/test.math.ci:5: referenced as `float64`
	test/stdc/test.math.ci:4: referenced as `float64`
	test/stdc/test.math.ci:3: referenced as `float64`
	test/lang/useOperator.ci:269: referenced as `float64`
	test/lang/useOperator.ci:268: referenced as `float64`
	test/lang/useOperator.ci:267: referenced as `float64`
	test/lang/useOperator.ci:266: referenced as `float64`
	test/lang/useOperator.ci:265: referenced as `float64`
	test/lang/useOperator.ci:263: referenced as `float64`
	test/lang/useOperator.ci:262: referenced as `float64`
	test/lang/useOperator.ci:261: referenced as `float64`
	test/lang/useOperator.ci:260: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:44: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:43: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:42: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:41: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:40: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:39: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:38: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:37: referenced as `float64`
	test/stdc/number.ci:4: referenced as `float64`
	test/stdc/number.ci:3: referenced as `float64`
	test/lang/reflect.ci:15: referenced as `float64`
	test/lang/initByRef.ci:87: referenced as `float64`
	test/lang/initByRef.ci:67: referenced as `float64`
	test/lang/initByRef.ci:47: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:22: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:21: referenced as `float64`
	test/lang/overload.inline.ci:16: referenced as `float64`
	test/lang/overload.inline.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	test/lang/emit.ci:15: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:16: referenced as `float64`
	lib/vec/vec2d.ci:11: referenced as `float64`
	lib/vec/vec2d.ci:9: referenced as `float64`
	lib/vec/vec2d.ci:6: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:184: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:148: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:146: referenced as `float64`
	lib/std/math.Complex.ci:143: referenced as `float64`
	lib/std/math.Complex.ci:139: referenced as `float64`
	lib/std/math.Complex.ci:138: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:136: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:135: referenced as `float64`
	lib/std/math.Complex.ci:134: referenced as `float64`
	lib/std/math.Complex.ci:133: referenced as `float64`
	lib/std/math.Complex.ci:129: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:126: referenced as `float64`
	lib/std/math.Complex.ci:115: referenced as `float64`
	lib/std/math.Complex.ci:111: referenced as `float64`
	lib/std/math.Complex.ci:109: referenced as `float64`
	lib/std/math.Complex.ci:106: referenced as `float64`
	lib/std/math.Complex.ci:104: referenced as `float64`
	lib/std/math.Complex.ci:96: referenced as `float64`
	lib/std/math.Complex.ci:95: referenced as `float64`
	lib/std/math.Complex.ci:89: referenced as `float64`
	lib/std/math.Complex.ci:88: referenced as `float64`
	lib/std/math.Complex.ci:80: referenced as `float64`
	lib/std/math.Complex.ci:78: referenced as `float64`
	lib/std/math.Complex.ci:73: referenced as `float64`
	lib/std/math.Complex.ci:71: referenced as `float64`
	lib/std/math.Complex.ci:66: referenced as `float64`
	lib/std/math.Complex.ci:64: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:31: referenced as `float64`
	lib/std/math.Complex.ci:24: referenced as `float64`
	lib/std/math.Complex.ci:8: referenced as `float64`
	lib/std/math.Complex.ci:5: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:525: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:522: referenced as `float64`
	lib/std/math.ci:498: referenced as `float64`
	lib/std/math.ci:485: referenced as `float64`
	lib/std/math.ci:482: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:480: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:463: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:455: referenced as `float64`
	lib/std/math.ci:453: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:448: referenced as `float64`
	lib/std/math.ci:436: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:433: referenced as `float64`
	lib/std/math.ci:431: referenced as `float64`
	lib/std/math.ci:428: referenced as `float64`
	lib/std/math.ci:411: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:409: referenced as `float64`
	lib/std/math.ci:393: referenced as `float64`
	lib/std/math.ci:392: referenced as `float64`
	lib/std/math.ci:375: referenced as `float64`
	lib/std/math.ci:374: referenced as `float64`
	lib/std/math.ci:353: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:352: referenced as `float64`
	lib/std/math.ci:349: referenced as `float64`
	lib/std/math.ci:346: referenced as `float64`
	lib/std/math.ci:341: referenced as `float64`
	lib/std/math.ci:340: referenced as `float64`
	lib/std/math.ci:339: referenced as `float64`
	lib/std/math.ci:322: referenced as `float64`
	lib/std/math.ci:318: referenced as `float64`
	lib/std/math.ci:315: referenced as `float64`
	lib/std/math.ci:309: referenced as `float64`
	lib/std/math.ci:296: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:295: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:280: referenced as `float64`
	lib/std/math.ci:257: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:256: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:253: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:250: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:247: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:244: referenced as `float64`
	lib/std/math.ci:230: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:229: referenced as `float64`
	lib/std/math.ci:219: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:215: referenced as `float64`
	lib/std/math.ci:205: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:201: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:198: referenced as `float64`
	lib/std/math.ci:192: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:189: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:170: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:145: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:123: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:101: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:85: referenced as `float64`
	lib/std/math.ci:67: referenced as `float64`
	lib/std/math.ci:57: referenced as `float64`
	lib/std/math.ci:54: referenced as `float64`
	lib/std/math.ci:48: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:47: referenced as `float64`
	lib/std/math.ci:32: referenced as `float64`
	lib/std/math.ci:25: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:22: referenced as `float64`
	lib/std/math.ci:5: referenced as `float64`
	lib/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc60>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(38)
.usages:
	test/stdc/number.ci:37: referenced as `sin`
	lib/std/math.Complex.ci:184: referenced as `sin`
	lib/std/math.Complex.ci:148: referenced as `sin`
	lib/std/math.Complex.ci:146: referenced as `sin`
	lib/std/math.Complex.ci:139: referenced as `sin`
	lib/std/math.Complex.ci:126: referenced as `sin`
	internal usages: 1
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be58>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	test/stdc/number.ci:38: referenced as `cos`
	lib/std/math.Complex.ci:184: referenced as `cos`
	lib/std/math.Complex.ci:148: referenced as `cos`
	lib/std/math.Complex.ci:146: referenced as `cos`
	lib/std/math.Complex.ci:138: referenced as `cos`
	lib/std/math.Complex.ci:126: referenced as `cos`
	internal usages: 1
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c050>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	test/stdc/number.ci:39: referenced as `tan`
	internal usages: 1
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c248>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	test/stdc/number.ci:40: referenced as `log`
	lib/std/math.Complex.ci:135: referenced as `log`
	lib/std/math.Complex.ci:129: referenced as `log`
	internal usages: 1
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c440>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	test/stdc/number.ci:41: referenced as `exp`
	lib/std/math.Complex.ci:136: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.Complex.ci:126: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:455: referenced as `exp`
	lib/std/math.ci:453: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:433: referenced as `exp`
	lib/std/math.ci:428: referenced as `exp`
	internal usages: 1
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c6d0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(43)
.usages:
	test/stdc/number.ci:42: referenced as `pow`
	lib/std/math.Complex.ci:136: referenced as `pow`
	internal usages: 1
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c8c8>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(44)
.usages:
	test/stdc/number.ci:43: referenced as `sqrt`
	lib/std/math.Complex.ci:109: referenced as `sqrt`
	lib/std/math.ci:480: referenced as `sqrt`
	internal usages: 1
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cb58>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(45)
.usages:
	test/stdc/number.ci:44: referenced as `atan2`
	lib/std/math.Complex.ci:111: referenced as `atan2`
	lib/std/math.ci:485: referenced as `atan2`
	lib/std/math.ci:482: referenced as `atan2`
	internal usages: 1
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@0008d0>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@007a90>, cast: static const inline)
.field fill: function (size: 0, offs: <@007dc8>, cast: static const inline)
.field copy: function (size: 0, offs: <@008100>, cast: static const inline)
.field move: function (size: 0, offs: <@008430>, cast: static const inline)
.usages:
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:284: referenced as `pointer`
	test/lang/useOperator.ci:283: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/lang/array.ci:82: referenced as `pointer`
	test/stdc/tryExec.ci:42: referenced as `pointer`
	test/stdc/tryExec.ci:37: referenced as `pointer`
	test/stdc/tryExec.ci:23: referenced as `pointer`
	test/stdc/tryExec.ci:19: referenced as `pointer`
	test/stdc/tryExec.ci:14: referenced as `pointer`
	test/stdc/tryExec.ci:11: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:30: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:29: referenced as `pointer`
	test/stdc/memory.ci:14: referenced as `pointer`
	test/stdc/memory.ci:13: referenced as `pointer`
	test/stdc/memory.ci:10: referenced as `pointer`
	test/stdc/memory.ci:9: referenced as `pointer`
	test/stdc/memory.ci:8: referenced as `pointer`
	test/stdc/memory.ci:7: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:5: referenced as `pointer`
	test/stdc/memory.ci:4: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/stdc/memory.ci:3: referenced as `pointer`
	test/lang/reflect.ci:16: referenced as `pointer`
	test/lang/initByRef.ci:108: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:95: referenced as `pointer`
	test/lang/initByRef.ci:90: referenced as `pointer`
	test/lang/initByRef.ci:70: referenced as `pointer`
	test/lang/initByRef.ci:52: referenced as `pointer`
	test/lang/initByRef.ci:51: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:50: referenced as `pointer`
	test/lang/initByRef.ci:49: referenced as `pointer`
	test/lang/initByRef.ci:48: referenced as `pointer`
	test/lang/initByRef.ci:47: referenced as `pointer`
	test/lang/initByRef.ci:46: referenced as `pointer`
	test/lang/initByRef.ci:45: referenced as `pointer`
	test/lang/initByRef.ci:44: referenced as `pointer`
	test/lang/initByRef.ci:43: referenced as `pointer`
	test/lang/initByRef.ci:42: referenced as `pointer`
	test/lang/initByRef.ci:41: referenced as `pointer`
	test/lang/initByRef.ci:40: referenced as `pointer`
	test/lang/initByRef.ci:39: referenced as `pointer`
	test/lang/initByRef.ci:38: referenced as `pointer`
	test/lang/initByRef.ci:37: referenced as `pointer`
	test/lang/initByRef.ci:36: referenced as `pointer`
	test/lang/initByRef.ci:35: referenced as `pointer`
	test/lang/initByRef.ci:30: referenced as `pointer`
	test/lang/initByRef.ci:23: referenced as `pointer`
	test/lang/initByRef.ci:17: referenced as `pointer`
	test/lang/initByRef.ci:9: referenced as `pointer`
	test/lang/emit.ci:23: referenced as `pointer`
	internal usages: 13
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007a90>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(9)
.usages:
	test/stdc/memory.ci:5: referenced as `alloc`
	test/stdc/memory.ci:4: referenced as `alloc`
	test/stdc/memory.ci:3: referenced as `alloc`
	internal usages: 1
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@007dc8>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(10)
.usages:
	test/stdc/memory.ci:30: referenced as `fill`
	test/stdc/memory.ci:13: referenced as `fill`
	internal usages: 1
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008100>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(11)
.usages:
	test/lang/array.ci:82: referenced as `copy`
	test/stdc/memory.ci:14: referenced as `copy`
	internal usages: 1
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008430>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	test/stdc/memory.ci:29: referenced as `move`
	internal usages: 1
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@000970>
.name: 'variant'
.field is: function (size: 0, offs: <@005ba0>, cast: static const inline)
.field as: function (size: 0, offs: <@005e38>, cast: static const inline)
.usages:
	test/lang/array.ci:92: referenced as `variant`
	test/lang/array.ci:88: referenced as `variant`
	test/lang/array.ci:84: referenced as `variant`
	test/lang/reflect.ci:17: referenced as `variant`
	test/lang/initByRef.ci:105: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:96: referenced as `variant`
	test/lang/initByRef.ci:91: referenced as `variant`
	test/lang/initByRef.ci:72: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:71: referenced as `variant`
	test/lang/initByRef.ci:70: referenced as `variant`
	test/lang/initByRef.ci:69: referenced as `variant`
	test/lang/initByRef.ci:68: referenced as `variant`
	test/lang/initByRef.ci:67: referenced as `variant`
	test/lang/initByRef.ci:66: referenced as `variant`
	test/lang/initByRef.ci:65: referenced as `variant`
	test/lang/initByRef.ci:64: referenced as `variant`
	test/lang/initByRef.ci:63: referenced as `variant`
	test/lang/initByRef.ci:62: referenced as `variant`
	test/lang/initByRef.ci:61: referenced as `variant`
	test/lang/initByRef.ci:60: referenced as `variant`
	test/lang/initByRef.ci:59: referenced as `variant`
	test/lang/initByRef.ci:58: referenced as `variant`
	test/lang/initByRef.ci:57: referenced as `variant`
	test/lang/initByRef.ci:56: referenced as `variant`
	test/lang/initByRef.ci:55: referenced as `variant`
	test/lang/initByRef.ci:51: referenced as `variant`
	test/lang/initByRef.ci:31: referenced as `variant`
	test/lang/initByRef.ci:24: referenced as `variant`
	test/lang/initByRef.ci:18: referenced as `variant`
	test/lang/initByRef.ci:10: referenced as `variant`
	lib/stdlib.ci:67: referenced as `variant`
	lib/stdlib.ci:64: referenced as `variant`
	lib/stdlib.ci:61: referenced as `variant`
	lib/stdlib.ci:52: referenced as `variant`
	lib/stdlib.ci:45: referenced as `variant`
	lib/stdlib.ci:40: referenced as `variant`
	lib/stdlib.ci:35: referenced as `variant`
	lib/stdlib.ci:30: referenced as `variant`
	lib/stdlib.ci:25: referenced as `variant`
	lib/stdlib.ci:20: referenced as `variant`
	lib/stdlib.ci:15: referenced as `variant`
	internal usages: 3
}
variant.is(var: variant, type: typename): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ba0>
.name: 'is'
.owner: variant
.param .result: bool (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
	internal usages: 1
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005e38>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(2)
.usages:
	internal usages: 1
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a10>
.name: 'function'
.usages:
	test/lang/reflect.ci:19: referenced as `function`
	test/lang/initByRef.ci:89: referenced as `function`
	test/lang/initByRef.ci:69: referenced as `function`
	test/lang/initByRef.ci:49: referenced as `function`
	test/lang/initByRef.ci:20: referenced as `function`
	lib/stdlib.ci:12: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000ab8>
.name: 'object'
.usages:
	test/lang/recUnion.ci:22: referenced as `object`
	test/lang/reflect.ci:22: referenced as `object`
	test/lang/reflect.ci:20: referenced as `object`
	test/lang/initByRef.ci:92: referenced as `object`
	test/lang/initByRef.ci:72: referenced as `object`
	test/lang/initByRef.ci:52: referenced as `object`
	test/lang/initByRef.ci:21: referenced as `object`
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	test/lang/statementIf.ci:73: referenced as `null`
	test/lang/statementIf.ci:22: referenced as `null`
	test/lang/statementIf.ci:19: referenced as `null`
	test/lang/statementIf.ci:15: referenced as `null`
	test/lang/statementIf.ci:12: referenced as `null`
	test/lang/statementIf.ci:8: referenced as `null`
	test/lang/statementIf.ci:4: referenced as `null`
	test/lang/useOperator.ci:283: referenced as `null`
	test/lang/method.ci:92: referenced as `null`
	test/lang/method.ci:86: referenced as `null`
	test/lang/array.ci:112: referenced as `null`
	test/lang/array.ci:60: referenced as `null`
	test/lang/array.ci:59: referenced as `null`
	test/lang/array.ci:44: referenced as `null`
	test/stdc/tryExec.ci:52: referenced as `null`
	test/stdc/tryExec.ci:51: referenced as `null`
	test/stdc/tryExec.ci:50: referenced as `null`
	test/stdc/tryExec.ci:49: referenced as `null`
	test/stdc/tryExec.ci:48: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:47: referenced as `null`
	test/stdc/tryExec.ci:46: referenced as `null`
	test/stdc/tryExec.ci:38: referenced as `null`
	test/stdc/memory.ci:4: referenced as `null`
	test/lang/initByRef.ci:21: referenced as `null`
	test/lang/initByRef.ci:20: referenced as `null`
	test/lang/initByRef.ci:19: referenced as `null`
	test/lang/initByRef.ci:18: referenced as `null`
	test/lang/initByRef.ci:17: referenced as `null`
	test/lang/initByRef.ci:16: referenced as `null`
	test/lang/initByRef.ci:3: referenced as `null`
	lib/vec/mat4f.ci:1: referenced as `null`
	lib/vec/vec4f.ci:1: referenced as `null`
	lib/vec/vec2d.ci:1: referenced as `null`
	lib/std/string.ci:5: referenced as `null`
	lib/stdlib.ci:87: referenced as `null`
	lib/stdlib.ci:70: referenced as `null`
	lib/stdlib.ci:67: referenced as `null`
	lib/stdlib.ci:49: referenced as `null`
	lib/stdlib.ci:47: referenced as `null`
	lib/stdlib.ci:42: referenced as `null`
	lib/stdlib.ci:37: referenced as `null`
	lib/stdlib.ci:32: referenced as `null`
	lib/stdlib.ci:27: referenced as `null`
	lib/stdlib.ci:22: referenced as `null`
	lib/stdlib.ci:17: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
.usages:
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000d38>
.name: '.cstr'
.print: '%s'
.usages:
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000dd8>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001198>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001238>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0014b8>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001a58>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001df0>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@001fd0>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@0021a0>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002370>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002540>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002710>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002a10>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@002e60>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003290>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@0036c0>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003c20>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@004180>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@0045b0>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@0049e0>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@004e10>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005240>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005410>, cast: static const typename(void))
.usages:
	test/stdc/tryExec.ci:43: referenced as `emit`
	test/lang/overload.inline.ci:22: referenced as `emit`
	test/lang/overload.inline.ci:21: referenced as `emit`
	test/lang/emit.ci:23: referenced as `emit`
	test/lang/emit.ci:15: referenced as `emit`
	test/lang/emit.ci:14: referenced as `emit`
	test/lang/emit.ci:10: referenced as `emit`
	test/lang/emit.ci:9: referenced as `emit`
	test/lang/emit.ci:4: referenced as `emit`
	test/lang/emit.ci:3: referenced as `emit`
	lib/vec/vec4f.ci:92: referenced as `emit`
	lib/vec/vec4f.ci:88: referenced as `emit`
	lib/vec/vec4f.ci:84: referenced as `emit`
	lib/vec/vec4f.ci:80: referenced as `emit`
	lib/vec/vec4f.ci:78: referenced as `emit`
	lib/vec/vec4f.ci:75: referenced as `emit`
	lib/vec/vec4f.ci:73: referenced as `emit`
	lib/vec/vec4f.ci:71: referenced as `emit`
	lib/vec/vec4f.ci:69: referenced as `emit`
	lib/vec/vec4f.ci:67: referenced as `emit`
	lib/vec/vec2d.ci:24: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
.usages:
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
.usages:
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
.usages:
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	test/stdc/tryExec.ci:43: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
.usages:
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001198>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:92: referenced as `p4x`
	lib/vec/vec4f.ci:88: referenced as `p4x`
	lib/vec/vec4f.ci:84: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	lib/vec/vec4f.ci:84: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	lib/vec/vec4f.ci:92: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	lib/vec/vec4f.ci:88: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001238>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
.usages:
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
.usages:
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
.usages:
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0014b8>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/stdc/tryExec.ci:43: referenced as `load`
	test/lang/emit.ci:4: referenced as `load`
	test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	test/stdc/tryExec.ci:43: referenced as `z32`
	test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
.usages:
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
.usages:
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
.usages:
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
.usages:
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
.usages:
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
.usages:
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001a58>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
.usages:
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
.usages:
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
.usages:
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
.usages:
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
.usages:
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001df0>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
.usages:
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
.usages:
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001fd0>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
.usages:
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
.usages:
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0021a0>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
.usages:
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
.usages:
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002370>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
.usages:
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
.usages:
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002540>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
.usages:
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
.usages:
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002710>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
.usages:
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
.usages:
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
.usages:
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
.usages:
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002a10>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
.usages:
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
.usages:
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
.usages:
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
.usages:
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	lib/vec/vec4f.ci:67: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002e60>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:9: referenced as `add`
	lib/vec/vec4f.ci:69: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	test/lang/emit.ci:9: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
.usages:
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
.usages:
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	lib/vec/vec4f.ci:69: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003290>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:71: referenced as `sub`
	lib/vec/vec2d.ci:24: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
.usages:
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
.usages:
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
.usages:
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	lib/vec/vec4f.ci:71: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	lib/vec/vec2d.ci:24: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0036c0>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:73: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
.usages:
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
.usages:
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
.usages:
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
.usages:
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
.usages:
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
.usages:
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	lib/vec/vec4f.ci:73: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003c20>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	test/lang/emit.ci:10: referenced as `div`
	lib/vec/vec4f.ci:75: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	test/lang/emit.ci:10: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
.usages:
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
.usages:
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
.usages:
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
.usages:
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	lib/vec/vec4f.ci:75: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004180>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
.usages:
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
.usages:
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
.usages:
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
.usages:
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
.usages:
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
.usages:
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0045b0>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
.usages:
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
.usages:
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
.usages:
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
.usages:
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
.usages:
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0049e0>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
.usages:
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
.usages:
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
.usages:
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
.usages:
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
.usages:
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
.usages:
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004e10>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
.usages:
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
.usages:
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
.usages:
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
.usages:
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
.usages:
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
.usages:
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005240>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:78: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	lib/vec/vec4f.ci:78: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005410>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	lib/vec/vec4f.ci:80: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	lib/vec/vec4f.ci:80: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005900>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
	internal usages: 1
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
.usages:
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
.usages:
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006f10>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(7)
.usages:
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:69: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:66: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:63: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:60: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:57: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:54: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:51: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:47: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:44: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:40: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:37: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:33: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:29: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:22: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:19: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:15: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:12: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:8: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	test/lang/statementIf.ci:4: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:84: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:49: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:47: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:45: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:42: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:40: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:37: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:35: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:32: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:30: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:27: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:25: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:22: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:20: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:17: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:15: referenced as `raise`
	lib/stdlib.ci:12: referenced as `raise`
	internal usages: 1
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	lib/stdlib.ci:84: referenced as `abort`
	lib/stdlib.ci:49: referenced as `abort`
	lib/stdlib.ci:47: referenced as `abort`
	lib/stdlib.ci:45: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	lib/stdlib.ci:42: referenced as `error`
	lib/stdlib.ci:40: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	lib/stdlib.ci:37: referenced as `warn`
	lib/stdlib.ci:35: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	lib/stdlib.ci:32: referenced as `info`
	lib/stdlib.ci:30: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	test/lang/statementIf.ci:69: referenced as `debug`
	test/lang/statementIf.ci:66: referenced as `debug`
	test/lang/statementIf.ci:63: referenced as `debug`
	test/lang/statementIf.ci:60: referenced as `debug`
	test/lang/statementIf.ci:57: referenced as `debug`
	test/lang/statementIf.ci:54: referenced as `debug`
	test/lang/statementIf.ci:51: referenced as `debug`
	test/lang/statementIf.ci:47: referenced as `debug`
	test/lang/statementIf.ci:44: referenced as `debug`
	test/lang/statementIf.ci:40: referenced as `debug`
	test/lang/statementIf.ci:37: referenced as `debug`
	test/lang/statementIf.ci:33: referenced as `debug`
	test/lang/statementIf.ci:29: referenced as `debug`
	test/lang/statementIf.ci:22: referenced as `debug`
	test/lang/statementIf.ci:19: referenced as `debug`
	test/lang/statementIf.ci:15: referenced as `debug`
	test/lang/statementIf.ci:12: referenced as `debug`
	test/lang/statementIf.ci:8: referenced as `debug`
	test/lang/statementIf.ci:4: referenced as `debug`
	lib/stdlib.ci:27: referenced as `debug`
	lib/stdlib.ci:25: referenced as `debug`
	lib/stdlib.ci:22: referenced as `debug`
	lib/stdlib.ci:20: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	lib/stdlib.ci:17: referenced as `verbose`
	lib/stdlib.ci:15: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	lib/stdlib.ci:37: referenced as `noTrace`
	lib/stdlib.ci:35: referenced as `noTrace`
	lib/stdlib.ci:32: referenced as `noTrace`
	lib/stdlib.ci:30: referenced as `noTrace`
	lib/stdlib.ci:22: referenced as `noTrace`
	lib/stdlib.ci:20: referenced as `noTrace`
	lib/stdlib.ci:17: referenced as `noTrace`
	lib/stdlib.ci:15: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	lib/stdlib.ci:84: referenced as `defTrace`
	lib/stdlib.ci:49: referenced as `defTrace`
	lib/stdlib.ci:47: referenced as `defTrace`
	lib/stdlib.ci:45: referenced as `defTrace`
	lib/stdlib.ci:42: referenced as `defTrace`
	lib/stdlib.ci:40: referenced as `defTrace`
	lib/stdlib.ci:27: referenced as `defTrace`
	lib/stdlib.ci:25: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0077f0>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(8)
.usages:
	test/stdc/tryExec.ci:52: referenced as `tryExec`
	test/stdc/tryExec.ci:51: referenced as `tryExec`
	test/stdc/tryExec.ci:50: referenced as `tryExec`
	test/stdc/tryExec.ci:49: referenced as `tryExec`
	test/stdc/tryExec.ci:48: referenced as `tryExec`
	test/stdc/tryExec.ci:47: referenced as `tryExec`
	test/stdc/tryExec.ci:46: referenced as `tryExec`
	internal usages: 1
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008460>
.name: 'System'
.field exit: function (size: 0, offs: <@0086d8>, cast: static const inline)
.field srand: function (size: 0, offs: <@0088e0>, cast: static const inline)
.field rand: function (size: 0, offs: <@008a48>, cast: static const inline)
.field time: function (size: 0, offs: <@008bb0>, cast: static const inline)
.field clock: function (size: 0, offs: <@008d18>, cast: static const inline)
.field millis: function (size: 0, offs: <@008e80>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009080>, cast: static const inline)
.usages:
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0086d8>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(13)
.usages:
	internal usages: 1
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0088e0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(14)
.usages:
	internal usages: 1
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008a48>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(15)
.usages:
	internal usages: 1
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008bb0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(16)
.usages:
	internal usages: 1
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008d18>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
	internal usages: 1
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008e80>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(18)
.usages:
	internal usages: 1
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009080>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(19)
.usages:
	internal usages: 1
}
true: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'true'
.file: 'lib/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	test/lang/useOperator.ci:7: referenced as `true`
	lib/std/string.ci:57: referenced as `true`
	lib/std/string.ci:42: referenced as `true`
	lib/std/math.ci:471: referenced as `true`
	lib/std/math.ci:424: referenced as `true`
	lib/std/math.ci:385: referenced as `true`
	lib/std/math.ci:381: referenced as `true`
	lib/std/math.ci:370: referenced as `true`
	lib/stdlib.ci:4: defined as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 1
.offset: <@000000>
.name: 'false'
.file: 'lib/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	test/lang/useOperator.ci:8: referenced as `false`
	lib/std/string.ci:54: referenced as `false`
	lib/std/string.ci:50: referenced as `false`
	lib/std/string.ci:39: referenced as `false`
	lib/std/math.ci:469: referenced as `false`
	lib/std/math.ci:421: referenced as `false`
	lib/std/math.ci:366: referenced as `false`
	lib/std/math.ci:365: referenced as `false`
	lib/stdlib.ci:5: defined as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'lib/stdlib.ci:8'
.value: uint8
.usages:
	lib/stdlib.ci:8: defined as `byte`
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'lib/stdlib.ci:9'
.value: float32
.usages:
	lib/stdlib.ci:9: defined as `float`
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'lib/stdlib.ci:10'
.value: float64
.usages:
	lib/stdlib.ci:10: defined as `double`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:15: defined as `verbose(message: char[*], inspect: variant): void`
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:17: defined as `verbose(message: char[*]): void`
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	test/lang/statementFor.ci:28: referenced as `debug`
	test/lang/statementFor.ci:21: referenced as `debug`
	test/lang/statementFor.ci:14: referenced as `debug`
	test/lang/statementFor.ci:9: referenced as `debug`
	test/lang/array.ci:92: referenced as `debug`
	test/lang/array.ci:91: referenced as `debug`
	test/lang/array.ci:88: referenced as `debug`
	test/lang/array.ci:87: referenced as `debug`
	test/lang/array.ci:84: referenced as `debug`
	test/lang/array.ci:83: referenced as `debug`
	test/stdc/memory.ci:33: referenced as `debug`
	test/stdc/memory.ci:32: referenced as `debug`
	test/stdc/memory.ci:27: referenced as `debug`
	test/stdc/memory.ci:26: referenced as `debug`
	lib/stdlib.ci:20: defined as `debug(message: char[*], inspect: variant): void`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'lib/stdlib.ci:22'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	test/lang/statementFor.ci:4: referenced as `debug`
	test/lang/method.ci:91: referenced as `debug`
	test/lang/method.ci:85: referenced as `debug`
	lib/stdlib.ci:22: defined as `debug(message: char[*]): void`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	test/lang/method.ci:58: referenced as `trace`
	test/lang/method.ci:48: referenced as `trace`
	test/lang/method.ci:41: referenced as `trace`
	test/lang/method.ci:11: referenced as `trace`
	lib/stdlib.ci:25: defined as `trace(message: char[*], inspect: variant): void`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:27: defined as `trace(message: char[*]): void`
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:30'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:30: defined as `info(message: char[*], inspect: variant): void`
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'lib/stdlib.ci:32'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:32: defined as `info(message: char[*]): void`
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:35'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
	lib/stdlib.ci:35: defined as `warn(message: char[*], inspect: variant): void`
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'lib/stdlib.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
	lib/stdlib.ci:37: defined as `warn(message: char[*]): void`
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:40'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
	lib/stdlib.ci:40: defined as `error(message: char[*], inspect: variant): void`
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'lib/stdlib.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	test/lang/statementIf.ci:78: referenced as `error`
	test/lang/statementIf.ci:74: referenced as `error`
	lib/stdlib.ci:42: defined as `error(message: char[*]): void`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.param inspect: variant (size: 8, offs: <+12>, cast: var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	test/stdc/tryExec.ci:34: referenced as `abort`
	lib/stdlib.ci:52: referenced as `abort`
	lib/stdlib.ci:45: defined as `abort(message: char[*], inspect: variant): void`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:47'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	lib/stdlib.ci:56: referenced as `abort`
	lib/stdlib.ci:54: referenced as `abort`
	lib/stdlib.ci:47: defined as `abort(message: char[*]): void`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
	lib/stdlib.ci:49: defined as `abort(): void`
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:52'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.param inspect: variant (size: 8, offs: <+16>, cast: var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	lib/std/string.ci:152: referenced as `assert`
	lib/std/string.ci:151: referenced as `assert`
	lib/stdlib.ci:52: defined as `assert(condition: bool, message: char[*], inspect: variant): void`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:54'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
	lib/stdlib.ci:54: defined as `assert(condition: bool, message: char[*]): void`
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'lib/stdlib.ci:56'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	test/lang/array.ci:136: referenced as `assert`
	test/lang/array.ci:134: referenced as `assert`
	test/lang/array.ci:132: referenced as `assert`
	test/lang/array.ci:130: referenced as `assert`
	test/lang/array.ci:129: referenced as `assert`
	test/lang/array.ci:128: referenced as `assert`
	test/lang/array.ci:126: referenced as `assert`
	test/lang/array.ci:125: referenced as `assert`
	test/lang/array.ci:124: referenced as `assert`
	test/lang/array.ci:122: referenced as `assert`
	test/lang/array.ci:121: referenced as `assert`
	test/lang/array.ci:120: referenced as `assert`
	test/lang/array.ci:101: referenced as `assert`
	test/lang/array.ci:99: referenced as `assert`
	test/lang/array.ci:98: referenced as `assert`
	lib/std/string.ci:194: referenced as `assert`
	lib/std/string.ci:187: referenced as `assert`
	lib/std/string.ci:180: referenced as `assert`
	lib/std/string.ci:175: referenced as `assert`
	lib/stdlib.ci:56: defined as `assert(condition: bool): void`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@010108>
.name: 'NotEquals'
.file: 'lib/stdlib.ci:59'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field argument: variant (size: 8, offs: <+16>, cast: const variable(var))
.field message: char[*] (size: 4, offs: <+24>, cast: const variable(ref))
.doc: '@public'
.usages:
	lib/stdlib.ci:79: referenced as `NotEquals`
	lib/stdlib.ci:59: defined as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'lib/stdlib.ci:61'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	lib/stdlib.ci:80: referenced as `expected`
	lib/stdlib.ci:61: defined as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'lib/stdlib.ci:64'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	lib/stdlib.ci:81: referenced as `returned`
	lib/stdlib.ci:64: defined as `returned`
}
NotEquals.argument: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+16>
.name: 'argument'
.file: 'lib/stdlib.ci:67'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:67: defined as `argument`
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.offset: <+24>
.name: 'message'
.file: 'lib/stdlib.ci:70'
.owner: NotEquals
.doc: 'Extra message to identify what happened'
.value: null
.usages:
	lib/stdlib.ci:82: referenced as `message`
	lib/stdlib.ci:70: defined as `message`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 94
.offset: <@050748>
.name: 'assertEq'
.file: 'lib/stdlib.ci:75'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.message := (message));
		void(details.argument := (null));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (94 bytes: <@050748> - <@0507a6>)
	lib/stdlib.ci:76: (10 bytes: <@050748> - <@050752>): if (bool(returned == expected))
	<assertEq @050748>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @05074a>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @05074c>    : 57                         ceq.i32
	<assertEq+5 @05074d>    : 06 05 00 00                jz <assertEq+10 @050752>
	lib/stdlib.ci:77: (1 byte: <@050751> - <@050752>): return;
	<assertEq+9 @050751>    : 03                         ret
	lib/stdlib.ci:79: (41 bytes: <@050752> - <@05077b>): details: NotEquals := {...}
	<assertEq+10 @050752>   : 09 20 00 00                inc.sp(+32)
	lib/stdlib.ci:80: (11 bytes: <@050756> - <@050761>): void(details.expected := (expected));
	<assertEq+14 @050756>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+19 @05075b>   : 0a 30 00 00                load.sp(+48)
	<assertEq+23 @05075f>   : 14 02                      set.x64 sp(2)
	lib/stdlib.ci:81: (11 bytes: <@050761> - <@05076c>): void(details.returned := (returned));
	<assertEq+25 @050761>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<assertEq+30 @050766>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+34 @05076a>   : 14 04                      set.x64 sp(4)
	lib/stdlib.ci:82: (3 bytes: <@05076c> - <@05076f>): void(details.message := (message));
	<assertEq+36 @05076c>   : 16 06 09                   mov.x32 sp(6, 9)
	:: (12 bytes: <@05076f> - <@05077b>): void(details.argument := (null))
	<assertEq+39 @05076f>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<assertEq+44 @050774>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<assertEq+49 @050779>   : 14 06                      set.x64 sp(6)
	lib/stdlib.ci:84: (38 bytes: <@05077b> - <@0507a1>): raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
	<assertEq+51 @05077b>   : 1f 88 cb 00 00             load.ref <@00cb88> ;"lib/stdlib.ci"
	<assertEq+56 @050780>   : 1c 54 00 00 00             load.c32 84
	<assertEq+61 @050785>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+66 @05078a>   : 1c 80 00 00 00             load.c32 128
	<assertEq+71 @05078f>   : 1f a8 ce 00 00             load.ref <@00cea8> ;"assertion failed"
	<assertEq+76 @050794>   : 1f 08 01 01 00             load.ref <@010108> ;NotEquals
	<assertEq+81 @050799>   : 0a 18 00 00                load.sp(+24)
	<assertEq+85 @05079d>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+89 @0507a1>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+93 @0507a5>   : 03                         ret
.usages:
	lib/stdlib.ci:87: referenced as `assertEq`
	lib/stdlib.ci:75: defined as `assertEq(expected: int32, returned: int32, message: char[*]): void`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'lib/stdlib.ci:87'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	test/lang/array.ci:116: referenced as `assertEq`
	test/lang/array.ci:115: referenced as `assertEq`
	test/lang/array.ci:114: referenced as `assertEq`
	test/lang/array.ci:113: referenced as `assertEq`
	test/lang/array.ci:112: referenced as `assertEq`
	test/lang/array.ci:110: referenced as `assertEq`
	test/lang/array.ci:109: referenced as `assertEq`
	test/lang/array.ci:108: referenced as `assertEq`
	lib/stdlib.ci:87: defined as `assertEq(expected: int32, returned: int32): void`
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'lib/stdlib.ci:92'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	test/stdc/memory.ci:30: referenced as `sizeof`
	test/stdc/memory.ci:29: referenced as `sizeof`
	test/lang/reflect.ci:40: referenced as `sizeof`
	test/lang/reflect.ci:33: referenced as `sizeof`
	test/lang/reflect.ci:20: referenced as `sizeof`
	test/lang/reflect.ci:19: referenced as `sizeof`
	test/lang/reflect.ci:18: referenced as `sizeof`
	test/lang/reflect.ci:17: referenced as `sizeof`
	test/lang/reflect.ci:16: referenced as `sizeof`
	test/lang/reflect.ci:15: referenced as `sizeof`
	test/lang/reflect.ci:14: referenced as `sizeof`
	test/lang/reflect.ci:13: referenced as `sizeof`
	test/lang/reflect.ci:12: referenced as `sizeof`
	test/lang/reflect.ci:11: referenced as `sizeof`
	test/lang/reflect.ci:10: referenced as `sizeof`
	test/lang/reflect.ci:9: referenced as `sizeof`
	test/lang/reflect.ci:8: referenced as `sizeof`
	test/lang/reflect.ci:7: referenced as `sizeof`
	test/lang/reflect.ci:6: referenced as `sizeof`
	test/lang/reflect.ci:5: referenced as `sizeof`
	test/lang/reflect.ci:4: referenced as `sizeof`
	test/lang/reflect.ci:3: referenced as `sizeof`
	lib/stdlib.ci:92: defined as `sizeof(type: typename): int32`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@011380>
.name: 'Math'
.file: 'lib/std/math.ci:2'
.field pi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field e: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 8, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 8, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 8, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 8, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 8, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@0507a8>, cast: static const function)
.field floor: function (size: 24, offs: <@050800>, cast: static const function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@050818>, cast: static const function)
.field abs: function (size: 18, offs: <@050830>, cast: static const function)
.field absMod: function (size: 27, offs: <@050848>, cast: static const function)
.field absMod: function (size: 27, offs: <@050868>, cast: static const function)
.field min: function (size: 17, offs: <@050888>, cast: static const function)
.field min: function (size: 17, offs: <@0508a0>, cast: static const function)
.field max: function (size: 17, offs: <@0508b8>, cast: static const function)
.field max: function (size: 17, offs: <@0508d0>, cast: static const function)
.field clamp: function (size: 30, offs: <@0508e8>, cast: static const function)
.field clamp: function (size: 30, offs: <@050908>, cast: static const function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@050928>, cast: static const function)
.field max: function (size: 79, offs: <@050978>, cast: static const function)
.field sum: function (size: 40, offs: <@0509c8>, cast: static const function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@0509f0>, cast: static const function)
.field cmp: function (size: 57, offs: <@050a20>, cast: static const function)
.field cmp: function (size: 57, offs: <@050a60>, cast: static const function)
.field sinCos: function (size: 335, offs: <@050aa0>, cast: static const function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@050bf0>, cast: static const function)
.field sinh: function (size: 241, offs: <@050d70>, cast: static const function)
.field cosh: function (size: 75, offs: <@050e68>, cast: static const function)
.field asin: function (size: 173, offs: <@050eb8>, cast: static const function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	test/stdc/test.math.ci:96: referenced as `Math`
	test/stdc/test.math.ci:95: referenced as `Math`
	test/stdc/test.math.ci:94: referenced as `Math`
	test/stdc/test.math.ci:93: referenced as `Math`
	test/stdc/test.math.ci:91: referenced as `Math`
	test/stdc/test.math.ci:90: referenced as `Math`
	test/stdc/test.math.ci:89: referenced as `Math`
	test/stdc/test.math.ci:88: referenced as `Math`
	test/stdc/test.math.ci:86: referenced as `Math`
	test/stdc/test.math.ci:85: referenced as `Math`
	test/stdc/test.math.ci:84: referenced as `Math`
	test/stdc/test.math.ci:82: referenced as `Math`
	test/stdc/test.math.ci:81: referenced as `Math`
	test/stdc/test.math.ci:80: referenced as `Math`
	test/stdc/test.math.ci:79: referenced as `Math`
	test/stdc/test.math.ci:77: referenced as `Math`
	test/stdc/test.math.ci:76: referenced as `Math`
	test/stdc/test.math.ci:75: referenced as `Math`
	test/stdc/test.math.ci:74: referenced as `Math`
	test/stdc/test.math.ci:72: referenced as `Math`
	test/stdc/test.math.ci:71: referenced as `Math`
	test/stdc/test.math.ci:70: referenced as `Math`
	test/stdc/test.math.ci:68: referenced as `Math`
	test/stdc/test.math.ci:67: referenced as `Math`
	test/stdc/test.math.ci:64: referenced as `Math`
	test/stdc/test.math.ci:63: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:61: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:60: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:59: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:58: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:57: referenced as `Math`
	test/stdc/test.math.ci:55: referenced as `Math`
	test/stdc/test.math.ci:54: referenced as `Math`
	test/stdc/test.math.ci:53: referenced as `Math`
	test/stdc/test.math.ci:52: referenced as `Math`
	test/stdc/test.math.ci:51: referenced as `Math`
	test/stdc/test.math.ci:50: referenced as `Math`
	test/stdc/test.math.ci:49: referenced as `Math`
	test/stdc/test.math.ci:46: referenced as `Math`
	test/stdc/test.math.ci:45: referenced as `Math`
	test/stdc/test.math.ci:44: referenced as `Math`
	test/stdc/test.math.ci:43: referenced as `Math`
	test/stdc/test.math.ci:41: referenced as `Math`
	test/stdc/test.math.ci:40: referenced as `Math`
	test/stdc/test.math.ci:39: referenced as `Math`
	test/stdc/test.math.ci:38: referenced as `Math`
	test/stdc/test.math.ci:36: referenced as `Math`
	test/stdc/test.math.ci:35: referenced as `Math`
	test/stdc/test.math.ci:33: referenced as `Math`
	test/stdc/test.math.ci:32: referenced as `Math`
	test/stdc/test.math.ci:30: referenced as `Math`
	test/stdc/test.math.ci:29: referenced as `Math`
	test/stdc/test.math.ci:27: referenced as `Math`
	test/stdc/test.math.ci:26: referenced as `Math`
	test/stdc/test.math.ci:25: referenced as `Math`
	test/stdc/test.math.ci:24: referenced as `Math`
	test/stdc/test.math.ci:22: referenced as `Math`
	test/stdc/test.math.ci:21: referenced as `Math`
	test/stdc/test.math.ci:20: referenced as `Math`
	test/stdc/test.math.ci:19: referenced as `Math`
	test/stdc/test.math.ci:18: referenced as `Math`
	test/stdc/test.math.ci:17: referenced as `Math`
	test/stdc/test.math.ci:15: referenced as `Math`
	test/stdc/test.math.ci:14: referenced as `Math`
	test/stdc/test.math.ci:13: referenced as `Math`
	test/stdc/test.math.ci:12: referenced as `Math`
	test/stdc/test.math.ci:11: referenced as `Math`
	test/stdc/test.math.ci:10: referenced as `Math`
	test/stdc/test.math.ci:8: referenced as `Math`
	test/stdc/test.math.ci:7: referenced as `Math`
	test/stdc/test.math.ci:6: referenced as `Math`
	test/stdc/test.math.ci:5: referenced as `Math`
	test/stdc/test.math.ci:4: referenced as `Math`
	test/stdc/test.math.ci:3: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:148: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:146: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.Complex.ci:87: referenced as `Math`
	lib/std/math.ci:2: defined as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'pi'
.file: 'lib/std/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	test/stdc/test.math.ci:61: referenced as `pi`
	test/stdc/test.math.ci:60: referenced as `pi`
	test/stdc/test.math.ci:59: referenced as `pi`
	test/stdc/test.math.ci:58: referenced as `pi`
	test/stdc/test.math.ci:57: referenced as `pi`
	lib/std/math.ci:525: referenced as `pi`
	lib/std/math.ci:522: referenced as `pi`
	lib/std/math.ci:498: referenced as `pi`
	lib/std/math.ci:482: referenced as `pi`
	lib/std/math.ci:6: defined as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'e'
.file: 'lib/std/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
	lib/std/math.ci:7: defined as `e`
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln2'
.file: 'lib/std/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	lib/std/math.ci:9: referenced as `ln2`
	lib/std/math.ci:8: defined as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log2E'
.file: 'lib/std/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
	lib/std/math.ci:9: defined as `log2E`
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'ln10'
.file: 'lib/std/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	lib/std/math.ci:11: referenced as `ln10`
	lib/std/math.ci:10: defined as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'log10E'
.file: 'lib/std/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
	lib/std/math.ci:11: defined as `log10E`
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'phi'
.file: 'lib/std/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
	lib/std/math.ci:12: defined as `phi`
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrt2'
.file: 'lib/std/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
	lib/std/math.ci:13: defined as `sqrt2`
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtE'
.file: 'lib/std/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
	lib/std/math.ci:14: defined as `sqrtE`
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPi'
.file: 'lib/std/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
	lib/std/math.ci:15: defined as `sqrtPi`
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'lib/std/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
	lib/std/math.ci:16: defined as `sqrtPhi`
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'nan'
.file: 'lib/std/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	lib/std/math.ci:477: referenced as `nan`
	lib/std/math.ci:398: referenced as `nan`
	lib/std/math.ci:217: referenced as `nan`
	lib/std/math.ci:203: referenced as `nan`
	lib/std/math.ci:17: defined as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.offset: <@000000>
.name: 'inf'
.file: 'lib/std/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	lib/std/math.ci:18: defined as `inf`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 86
.offset: <@0507a8>
.name: 'modf'
.file: 'lib/std/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), intPart)));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <@0507a8> - <@0507fe>)
	lib/std/math.ci:23: (63 bytes: <@0507a8> - <@0507e7>): if (bool(x < (1)))
	<modf @0507a8>      : 11 02                      dup.x64 sp(2)
	<modf+2 @0507aa>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @0507b3>   : 88                         clt.f64
	<modf+12 @0507b4>   : 06 33 00 00                jz <modf+63 @0507e7>
	lib/std/math.ci:24: (39 bytes: <@0507b8> - <@0507df>): if (bool(x < (0)))
	<modf+16 @0507b8>   : 11 02                      dup.x64 sp(2)
	<modf+18 @0507ba>   : 1a                         load.z64
	<modf+19 @0507bb>   : 88                         clt.f64
	<modf+20 @0507bc>   : 06 23 00 00                jz <modf+55 @0507df>
	lib/std/math.ci:25: (17 bytes: <@0507c0> - <@0507d1>): result: float64 := float64(-modf(void(float64(-x), intPart)))
	<modf+24 @0507c0>   : 1a                         load.z64
	<modf+25 @0507c1>   : 11 04                      dup.x64 sp(4)
	<modf+27 @0507c3>   : 80                         neg.f64
	<modf+28 @0507c4>   : 10 05                      dup.x32 sp(5)
	<modf+30 @0507c6>   : 1f a8 07 05 00             load.ref <@0507a8> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @0507cb>   : 02                         call
	<modf+36 @0507cc>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @0507d0>   : 80                         neg.f64
	lib/std/math.ci:26: (7 bytes: <@0507d1> - <@0507d8>): float64(intPart := float64(-intPart));
	<modf+41 @0507d1>   : 10 03                      dup.x32 sp(3)
	<modf+43 @0507d3>   : 23                         load.i64
	<modf+44 @0507d4>   : 80                         neg.f64
	<modf+45 @0507d5>   : 10 05                      dup.x32 sp(5)
	<modf+47 @0507d7>   : 28                         store.i64
	lib/std/math.ci:27: (3 bytes: <@0507d8> - <@0507db>): return float64(.result := result);
	<modf+48 @0507d8>   : 14 06                      set.x64 sp(6)
	<modf+50 @0507da>   : 03                         ret
	<modf+51 @0507db>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:29: (4 bytes: <@0507df> - <@0507e3>): float64(intPart := (0));
	<modf+55 @0507df>   : 1a                         load.z64
	<modf+56 @0507e0>   : 10 03                      dup.x32 sp(3)
	<modf+58 @0507e2>   : 28                         store.i64
	lib/std/math.ci:30: (4 bytes: <@0507e3> - <@0507e7>): return float64(.result := x);
	<modf+59 @0507e3>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @0507e6>   : 03                         ret
	lib/std/math.ci:32: (12 bytes: <@0507e7> - <@0507f3>): result: float64 := float64(x % (1))
	<modf+63 @0507e7>   : 11 02                      dup.x64 sp(2)
	<modf+65 @0507e9>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @0507f2>   : 85                         mod.f64
	lib/std/math.ci:33: (8 bytes: <@0507f3> - <@0507fb>): float64(intPart := float64(x - result));
	<modf+75 @0507f3>   : 11 04                      dup.x64 sp(4)
	<modf+77 @0507f5>   : 11 02                      dup.x64 sp(2)
	<modf+79 @0507f7>   : 82                         sub.f64
	<modf+80 @0507f8>   : 10 05                      dup.x32 sp(5)
	<modf+82 @0507fa>   : 28                         store.i64
	lib/std/math.ci:34: (3 bytes: <@0507fb> - <@0507fe>): return float64(.result := result);
	<modf+83 @0507fb>   : 14 06                      set.x64 sp(6)
	<modf+85 @0507fd>   : 03                         ret
.usages:
	lib/std/math.ci:375: referenced as `modf`
	lib/std/math.ci:323: referenced as `modf`
	lib/std/math.ci:319: referenced as `modf`
	lib/std/math.ci:49: referenced as `modf`
	lib/std/math.ci:25: referenced as `modf`
	lib/std/math.ci:22: defined as `modf(x: float64, intPart: float64): float64`
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@050800>
.name: 'floor'
.file: 'lib/std/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, result));
	return float64(.result := result);
}
.instructions: (24 bytes: <@050800> - <@050818>)
	lib/std/math.ci:48: (1 byte: <@050800> - <@050801>): result: float64
	<floor @050800>      : 1b                         load.z128
	lib/std/math.ci:49: (20 bytes: <@050801> - <@050815>): modf(void(x, result));
	<floor+1 @050801>    : 11 05                      dup.x64 sp(5)
	<floor+3 @050803>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @050807>    : 1f a8 07 05 00             load.ref <@0507a8> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @05080c>   : 02                         call
	<floor+13 @05080d>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @050811>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:50: (3 bytes: <@050815> - <@050818>): return float64(.result := result);
	<floor+21 @050815>   : 14 05                      set.x64 sp(5)
	<floor+23 @050817>   : 03                         ret
.usages:
	test/stdc/test.math.ci:8: referenced as `floor`
	test/stdc/test.math.ci:7: referenced as `floor`
	test/stdc/test.math.ci:6: referenced as `floor`
	test/stdc/test.math.ci:5: referenced as `floor`
	test/stdc/test.math.ci:4: referenced as `floor`
	test/stdc/test.math.ci:3: referenced as `floor`
	lib/std/math.ci:57: referenced as `floor`
	lib/std/math.ci:54: referenced as `floor`
	lib/std/math.ci:47: defined as `floor(x: float64): float64`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'lib/std/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
	lib/std/math.ci:54: defined as `ceil(x: float64): float64`
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'lib/std/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
	lib/std/math.ci:57: defined as `round(x: float64): float64`
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:15: referenced as `sign`
	test/stdc/test.math.ci:14: referenced as `sign`
	test/stdc/test.math.ci:13: referenced as `sign`
	lib/std/math.ci:64: defined as `sign(x: float32): int32`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'lib/std/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	test/stdc/test.math.ci:12: referenced as `sign`
	test/stdc/test.math.ci:11: referenced as `sign`
	test/stdc/test.math.ci:10: referenced as `sign`
	lib/std/math.ci:67: defined as `sign(x: float64): int32`
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@050818>
.name: 'abs'
.file: 'lib/std/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <@050818> - <@05082a>)
	lib/std/math.ci:78: (14 bytes: <@050818> - <@050826>): if (bool(x < (0)))
	<abs @050818>      : 10 01                      dup.x32 sp(1)
	<abs+2 @05081a>    : 19                         load.z32
	<abs+3 @05081b>    : 78                         clt.f32
	<abs+4 @05081c>    : 06 0a 00 00                jz <abs+14 @050826>
	lib/std/math.ci:79: (6 bytes: <@050820> - <@050826>): return float32(.result := float32(-x));
	<abs+8 @050820>    : 10 01                      dup.x32 sp(1)
	<abs+10 @050822>   : 70                         neg.f32
	<abs+11 @050823>   : 13 03                      set.x32 sp(3)
	<abs+13 @050825>   : 03                         ret
	lib/std/math.ci:81: (4 bytes: <@050826> - <@05082a>): return float32(.result := x);
	<abs+14 @050826>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @050829>   : 03                         ret
.usages:
	test/stdc/test.math.ci:22: referenced as `abs`
	test/stdc/test.math.ci:21: referenced as `abs`
	test/stdc/test.math.ci:20: referenced as `abs`
	lib/std/math.ci:77: defined as `abs(x: float32): float32`
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 18
.offset: <@050830>
.name: 'abs'
.file: 'lib/std/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <@050830> - <@050842>)
	lib/std/math.ci:86: (14 bytes: <@050830> - <@05083e>): if (bool(x < (0)))
	<abs @050830>      : 11 01                      dup.x64 sp(1)
	<abs+2 @050832>    : 1a                         load.z64
	<abs+3 @050833>    : 88                         clt.f64
	<abs+4 @050834>    : 06 0a 00 00                jz <abs+14 @05083e>
	lib/std/math.ci:87: (6 bytes: <@050838> - <@05083e>): return float64(.result := float64(-x));
	<abs+8 @050838>    : 11 01                      dup.x64 sp(1)
	<abs+10 @05083a>   : 80                         neg.f64
	<abs+11 @05083b>   : 14 05                      set.x64 sp(5)
	<abs+13 @05083d>   : 03                         ret
	lib/std/math.ci:89: (4 bytes: <@05083e> - <@050842>): return float64(.result := x);
	<abs+14 @05083e>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @050841>   : 03                         ret
.usages:
	test/stdc/test.math.ci:19: referenced as `abs`
	test/stdc/test.math.ci:18: referenced as `abs`
	test/stdc/test.math.ci:17: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.Complex.ci:87: referenced as `abs`
	lib/std/math.ci:349: referenced as `abs`
	lib/std/math.ci:85: defined as `abs(x: float64): float64`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050848>
.name: 'absMod'
.file: 'lib/std/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <@050848> - <@050863>)
	lib/std/math.ci:94: (23 bytes: <@050848> - <@05085f>): if (bool((float32(val := float32(val % mod))) < (0)))
	<absMod @050848>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @05084a>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @05084c>    : 75                         mod.f32
	<absMod+5 @05084d>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @05084f>    : 13 04                      set.x32 sp(4)
	<absMod+9 @050851>    : 19                         load.z32
	<absMod+10 @050852>   : 78                         clt.f32
	<absMod+11 @050853>   : 06 0c 00 00                jz <absMod+23 @05085f>
	lib/std/math.ci:95: (8 bytes: <@050857> - <@05085f>): return float32(.result := float32(val + mod));
	<absMod+15 @050857>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @050859>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @05085b>   : 71                         add.f32
	<absMod+20 @05085c>   : 13 04                      set.x32 sp(4)
	<absMod+22 @05085e>   : 03                         ret
	lib/std/math.ci:97: (4 bytes: <@05085f> - <@050863>): return float32(.result := val);
	<absMod+23 @05085f>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @050862>   : 03                         ret
.usages:
	test/stdc/test.math.ci:96: referenced as `absMod`
	test/stdc/test.math.ci:95: referenced as `absMod`
	test/stdc/test.math.ci:94: referenced as `absMod`
	test/stdc/test.math.ci:93: referenced as `absMod`
	test/stdc/test.math.ci:91: referenced as `absMod`
	test/stdc/test.math.ci:90: referenced as `absMod`
	test/stdc/test.math.ci:89: referenced as `absMod`
	test/stdc/test.math.ci:88: referenced as `absMod`
	test/stdc/test.math.ci:86: referenced as `absMod`
	test/stdc/test.math.ci:85: referenced as `absMod`
	test/stdc/test.math.ci:84: referenced as `absMod`
	lib/std/math.ci:93: defined as `absMod(val: float32, mod: float32): float32`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static const function
.base: `function`
.size: 27
.offset: <@050868>
.name: 'absMod'
.file: 'lib/std/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <@050868> - <@050883>)
	lib/std/math.ci:102: (23 bytes: <@050868> - <@05087f>): if (bool((float64(val := float64(val % mod))) < (0)))
	<absMod @050868>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @05086a>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @05086c>    : 85                         mod.f64
	<absMod+5 @05086d>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @05086f>    : 14 07                      set.x64 sp(7)
	<absMod+9 @050871>    : 1a                         load.z64
	<absMod+10 @050872>   : 88                         clt.f64
	<absMod+11 @050873>   : 06 0c 00 00                jz <absMod+23 @05087f>
	lib/std/math.ci:103: (8 bytes: <@050877> - <@05087f>): return float64(.result := float64(val + mod));
	<absMod+15 @050877>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @050879>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @05087b>   : 81                         add.f64
	<absMod+20 @05087c>   : 14 07                      set.x64 sp(7)
	<absMod+22 @05087e>   : 03                         ret
	lib/std/math.ci:105: (4 bytes: <@05087f> - <@050883>): return float64(.result := val);
	<absMod+23 @05087f>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @050882>   : 03                         ret
.usages:
	test/stdc/test.math.ci:82: referenced as `absMod`
	test/stdc/test.math.ci:81: referenced as `absMod`
	test/stdc/test.math.ci:80: referenced as `absMod`
	test/stdc/test.math.ci:79: referenced as `absMod`
	test/stdc/test.math.ci:77: referenced as `absMod`
	test/stdc/test.math.ci:76: referenced as `absMod`
	test/stdc/test.math.ci:75: referenced as `absMod`
	test/stdc/test.math.ci:74: referenced as `absMod`
	test/stdc/test.math.ci:72: referenced as `absMod`
	test/stdc/test.math.ci:71: referenced as `absMod`
	test/stdc/test.math.ci:70: referenced as `absMod`
	lib/std/math.ci:101: defined as `absMod(val: float64, mod: float64): float64`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@050888>
.name: 'min'
.file: 'lib/std/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@050888> - <@050899>)
	lib/std/math.ci:116: (13 bytes: <@050888> - <@050895>): if (bool(a < b))
	<min @050888>      : 10 02                      dup.x32 sp(2)
	<min+2 @05088a>    : 10 02                      dup.x32 sp(2)
	<min+4 @05088c>    : 78                         clt.f32
	<min+5 @05088d>    : 06 08 00 00                jz <min+13 @050895>
	lib/std/math.ci:117: (4 bytes: <@050891> - <@050895>): return float32(.result := a);
	<min+9 @050891>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @050894>   : 03                         ret
	lib/std/math.ci:119: (4 bytes: <@050895> - <@050899>): return float32(.result := b);
	<min+13 @050895>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @050898>   : 03                         ret
.usages:
	test/stdc/test.math.ci:24: referenced as `min`
	lib/std/math.ci:115: defined as `min(a: float32, b: float32): float32`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0508a0>
.name: 'min'
.file: 'lib/std/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0508a0> - <@0508b1>)
	lib/std/math.ci:124: (13 bytes: <@0508a0> - <@0508ad>): if (bool(a < b))
	<min @0508a0>      : 11 03                      dup.x64 sp(3)
	<min+2 @0508a2>    : 11 03                      dup.x64 sp(3)
	<min+4 @0508a4>    : 88                         clt.f64
	<min+5 @0508a5>    : 06 08 00 00                jz <min+13 @0508ad>
	lib/std/math.ci:125: (4 bytes: <@0508a9> - <@0508ad>): return float64(.result := a);
	<min+9 @0508a9>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @0508ac>   : 03                         ret
	lib/std/math.ci:127: (4 bytes: <@0508ad> - <@0508b1>): return float64(.result := b);
	<min+13 @0508ad>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @0508b0>   : 03                         ret
.usages:
	test/stdc/test.math.ci:26: referenced as `min`
	lib/std/math.ci:123: defined as `min(a: float64, b: float64): float64`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0508b8>
.name: 'max'
.file: 'lib/std/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <@0508b8> - <@0508c9>)
	lib/std/math.ci:138: (13 bytes: <@0508b8> - <@0508c5>): if (bool(a > b))
	<max @0508b8>      : 10 02                      dup.x32 sp(2)
	<max+2 @0508ba>    : 10 02                      dup.x32 sp(2)
	<max+4 @0508bc>    : 79                         cgt.f32
	<max+5 @0508bd>    : 06 08 00 00                jz <max+13 @0508c5>
	lib/std/math.ci:139: (4 bytes: <@0508c1> - <@0508c5>): return float32(.result := a);
	<max+9 @0508c1>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @0508c4>   : 03                         ret
	lib/std/math.ci:141: (4 bytes: <@0508c5> - <@0508c9>): return float32(.result := b);
	<max+13 @0508c5>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @0508c8>   : 03                         ret
.usages:
	test/stdc/test.math.ci:25: referenced as `max`
	lib/std/math.ci:137: defined as `max(a: float32, b: float32): float32`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 17
.offset: <@0508d0>
.name: 'max'
.file: 'lib/std/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <@0508d0> - <@0508e1>)
	lib/std/math.ci:146: (13 bytes: <@0508d0> - <@0508dd>): if (bool(a > b))
	<max @0508d0>      : 11 03                      dup.x64 sp(3)
	<max+2 @0508d2>    : 11 03                      dup.x64 sp(3)
	<max+4 @0508d4>    : 89                         cgt.f64
	<max+5 @0508d5>    : 06 08 00 00                jz <max+13 @0508dd>
	lib/std/math.ci:147: (4 bytes: <@0508d9> - <@0508dd>): return float64(.result := a);
	<max+9 @0508d9>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @0508dc>   : 03                         ret
	lib/std/math.ci:149: (4 bytes: <@0508dd> - <@0508e1>): return float64(.result := b);
	<max+13 @0508dd>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @0508e0>   : 03                         ret
.usages:
	test/stdc/test.math.ci:27: referenced as `max`
	lib/std/math.ci:145: defined as `max(a: float64, b: float64): float64`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@0508e8>
.name: 'clamp'
.file: 'lib/std/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <@0508e8> - <@050906>)
	lib/std/math.ci:160: (13 bytes: <@0508e8> - <@0508f5>): if (bool(t < a))
	<clamp @0508e8>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @0508ea>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @0508ec>    : 78                         clt.f32
	<clamp+5 @0508ed>    : 06 08 00 00                jz <clamp+13 @0508f5>
	lib/std/math.ci:161: (4 bytes: <@0508f1> - <@0508f5>): return float32(.result := a);
	<clamp+9 @0508f1>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @0508f4>   : 03                         ret
	lib/std/math.ci:163: (13 bytes: <@0508f5> - <@050902>): if (bool(t > b))
	<clamp+13 @0508f5>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @0508f7>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @0508f9>   : 79                         cgt.f32
	<clamp+18 @0508fa>   : 06 08 00 00                jz <clamp+26 @050902>
	lib/std/math.ci:164: (4 bytes: <@0508fe> - <@050902>): return float32(.result := b);
	<clamp+22 @0508fe>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @050901>   : 03                         ret
	lib/std/math.ci:166: (4 bytes: <@050902> - <@050906>): return float32(.result := t);
	<clamp+26 @050902>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @050905>   : 03                         ret
.usages:
	test/stdc/test.math.ci:29: referenced as `clamp`
	lib/std/math.ci:195: referenced as `clamp`
	lib/std/math.ci:159: defined as `clamp(t: float32, a: float32, b: float32): float32`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 30
.offset: <@050908>
.name: 'clamp'
.file: 'lib/std/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <@050908> - <@050926>)
	lib/std/math.ci:171: (13 bytes: <@050908> - <@050915>): if (bool(t < a))
	<clamp @050908>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @05090a>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @05090c>    : 88                         clt.f64
	<clamp+5 @05090d>    : 06 08 00 00                jz <clamp+13 @050915>
	lib/std/math.ci:172: (4 bytes: <@050911> - <@050915>): return float64(.result := a);
	<clamp+9 @050911>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @050914>   : 03                         ret
	lib/std/math.ci:174: (13 bytes: <@050915> - <@050922>): if (bool(t > b))
	<clamp+13 @050915>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @050917>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @050919>   : 89                         cgt.f64
	<clamp+18 @05091a>   : 06 08 00 00                jz <clamp+26 @050922>
	lib/std/math.ci:175: (4 bytes: <@05091e> - <@050922>): return float64(.result := b);
	<clamp+22 @05091e>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @050921>   : 03                         ret
	lib/std/math.ci:177: (4 bytes: <@050922> - <@050926>): return float64(.result := t);
	<clamp+26 @050922>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @050925>   : 03                         ret
.usages:
	test/stdc/test.math.ci:30: referenced as `clamp`
	lib/std/math.ci:198: referenced as `clamp`
	lib/std/math.ci:170: defined as `clamp(t: float64, a: float64, b: float64): float64`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	test/stdc/test.math.ci:32: referenced as `lerp`
	lib/std/math.ci:186: defined as `lerp(t: float32, a: float32, b: float32): float32`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'lib/std/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	test/stdc/test.math.ci:33: referenced as `lerp`
	lib/std/math.ci:189: defined as `lerp(t: float64, a: float64, b: float64): float64`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	lib/std/math.ci:195: referenced as `smooth`
	lib/std/math.ci:191: defined as `smooth(t: float32): float32`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	lib/std/math.ci:198: referenced as `smooth`
	lib/std/math.ci:192: defined as `smooth(t: float64): float64`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	test/stdc/test.math.ci:35: referenced as `smooth`
	lib/std/math.ci:195: defined as `smooth(t: float32, a: float32, b: float32): float32`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'lib/std/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	test/stdc/test.math.ci:36: referenced as `smooth`
	lib/std/math.ci:198: defined as `smooth(t: float64, a: float64, b: float64): float64`
}
Math.min(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@050928>
.name: 'min'
.file: 'lib/std/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@050928> - <@050977>)
	lib/std/math.ci:202: (20 bytes: <@050928> - <@05093c>): if (bool(data.length == (0)))
	<min @050928>      : 10 02                      dup.x32 sp(2)
	<min+2 @05092a>    : 19                         load.z32
	<min+3 @05092b>    : 57                         ceq.i32
	<min+4 @05092c>    : 06 10 00 00                jz <min+20 @05093c>
	lib/std/math.ci:203: (12 bytes: <@050930> - <@05093c>): return float64(.result := nan);
	<min+8 @050930>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @050939>   : 14 05                      set.x64 sp(5)
	<min+19 @05093b>   : 03                         ret
	lib/std/math.ci:205: (3 bytes: <@05093c> - <@05093f>): result: float64 := data[0]
	<min+20 @05093c>   : 10 01                      dup.x32 sp(1)
	<min+22 @05093e>   : 23                         load.i64
	lib/std/math.ci:206: (53 bytes: <@05093f> - <@050974>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<min+23 @05093f>   : 1c 01 00 00 00             load.c32 1
	<min+28 @050944>   : 04 23 00 00                jmp <min+63 @050967>
	lib/std/math.ci:207: (27 bytes: <@050948> - <@050963>): if (bool(result > data[i]))
	<min+32 @050948>   : 11 01                      dup.x64 sp(1)
	<min+34 @05094a>   : 10 06                      dup.x32 sp(6)
	<min+36 @05094c>   : 10 03                      dup.x32 sp(3)
	<min+38 @05094e>   : 0d 08 00 00                mad.u32 8
	<min+42 @050952>   : 23                         load.i64
	<min+43 @050953>   : 89                         cgt.f64
	<min+44 @050954>   : 06 0f 00 00                jz <min+59 @050963>
	lib/std/math.ci:208: (11 bytes: <@050958> - <@050963>): float64(result := data[i]);
	<min+48 @050958>   : 10 04                      dup.x32 sp(4)
	<min+50 @05095a>   : 10 01                      dup.x32 sp(1)
	<min+52 @05095c>   : 0d 08 00 00                mad.u32 8
	<min+56 @050960>   : 23                         load.i64
	<min+57 @050961>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:206: (4 bytes: <@050963> - <@050967>): int32(i := int32(i + 1))
	<min+59 @050963>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:206: (9 bytes: <@050967> - <@050970>): bool(i < (data.length))
	<min+63 @050967>   : 10 00                      dup.x32 sp(0)
	<min+65 @050969>   : 10 06                      dup.x32 sp(6)
	<min+67 @05096b>   : 58                         clt.i32
	<min+68 @05096c>   : 05 dc ff ff                jnz <min+32 @050948>
	<min+72 @050970>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:211: (3 bytes: <@050974> - <@050977>): return float64(.result := result);
	<min+76 @050974>   : 14 05                      set.x64 sp(5)
	<min+78 @050976>   : 03                         ret
.usages:
	test/stdc/test.math.ci:39: referenced as `min`
	test/stdc/test.math.ci:38: referenced as `min`
	lib/std/math.ci:201: defined as `min(data: float64[]): float64`
}
Math.max(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 79
.offset: <@050978>
.name: 'max'
.file: 'lib/std/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <@050978> - <@0509c7>)
	lib/std/math.ci:216: (20 bytes: <@050978> - <@05098c>): if (bool(data.length == (0)))
	<max @050978>      : 10 02                      dup.x32 sp(2)
	<max+2 @05097a>    : 19                         load.z32
	<max+3 @05097b>    : 57                         ceq.i32
	<max+4 @05097c>    : 06 10 00 00                jz <max+20 @05098c>
	lib/std/math.ci:217: (12 bytes: <@050980> - <@05098c>): return float64(.result := nan);
	<max+8 @050980>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @050989>   : 14 05                      set.x64 sp(5)
	<max+19 @05098b>   : 03                         ret
	lib/std/math.ci:219: (3 bytes: <@05098c> - <@05098f>): result: float64 := data[0]
	<max+20 @05098c>   : 10 01                      dup.x32 sp(1)
	<max+22 @05098e>   : 23                         load.i64
	lib/std/math.ci:220: (53 bytes: <@05098f> - <@0509c4>): for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1)))
	<max+23 @05098f>   : 1c 01 00 00 00             load.c32 1
	<max+28 @050994>   : 04 23 00 00                jmp <max+63 @0509b7>
	lib/std/math.ci:221: (27 bytes: <@050998> - <@0509b3>): if (bool(result < data[i]))
	<max+32 @050998>   : 11 01                      dup.x64 sp(1)
	<max+34 @05099a>   : 10 06                      dup.x32 sp(6)
	<max+36 @05099c>   : 10 03                      dup.x32 sp(3)
	<max+38 @05099e>   : 0d 08 00 00                mad.u32 8
	<max+42 @0509a2>   : 23                         load.i64
	<max+43 @0509a3>   : 88                         clt.f64
	<max+44 @0509a4>   : 06 0f 00 00                jz <max+59 @0509b3>
	lib/std/math.ci:222: (11 bytes: <@0509a8> - <@0509b3>): float64(result := data[i]);
	<max+48 @0509a8>   : 10 04                      dup.x32 sp(4)
	<max+50 @0509aa>   : 10 01                      dup.x32 sp(1)
	<max+52 @0509ac>   : 0d 08 00 00                mad.u32 8
	<max+56 @0509b0>   : 23                         load.i64
	<max+57 @0509b1>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:220: (4 bytes: <@0509b3> - <@0509b7>): int32(i := int32(i + 1))
	<max+59 @0509b3>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:220: (9 bytes: <@0509b7> - <@0509c0>): bool(i < (data.length))
	<max+63 @0509b7>   : 10 00                      dup.x32 sp(0)
	<max+65 @0509b9>   : 10 06                      dup.x32 sp(6)
	<max+67 @0509bb>   : 58                         clt.i32
	<max+68 @0509bc>   : 05 dc ff ff                jnz <max+32 @050998>
	<max+72 @0509c0>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:225: (3 bytes: <@0509c4> - <@0509c7>): return float64(.result := result);
	<max+76 @0509c4>   : 14 05                      set.x64 sp(5)
	<max+78 @0509c6>   : 03                         ret
.usages:
	test/stdc/test.math.ci:41: referenced as `max`
	test/stdc/test.math.ci:40: referenced as `max`
	lib/std/math.ci:215: defined as `max(data: float64[]): float64`
}
Math.sum(data: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 40
.offset: <@0509c8>
.name: 'sum'
.file: 'lib/std/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: parallel variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <@0509c8> - <@0509f0>)
	lib/std/math.ci:230: (1 byte: <@0509c8> - <@0509c9>): result: float64 := 0
	<sum @0509c8>      : 1b                         load.z128
	lib/std/math.ci:231: (36 bytes: <@0509c9> - <@0509ed>): for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1)))
	<sum+1 @0509c9>    : 6a                         i64.2i32
	<sum+2 @0509ca>    : 04 16 00 00                jmp <sum+24 @0509e0>
	lib/std/math.ci:232: (14 bytes: <@0509ce> - <@0509dc>): float64(result := float64(result + data[i]));
	<sum+6 @0509ce>    : 11 01                      dup.x64 sp(1)
	<sum+8 @0509d0>    : 10 06                      dup.x32 sp(6)
	<sum+10 @0509d2>   : 10 03                      dup.x32 sp(3)
	<sum+12 @0509d4>   : 0d 08 00 00                mad.u32 8
	<sum+16 @0509d8>   : 23                         load.i64
	<sum+17 @0509d9>   : 81                         add.f64
	<sum+18 @0509da>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:231: (4 bytes: <@0509dc> - <@0509e0>): int32(i := int32(i + 1))
	<sum+20 @0509dc>   : 0c 01 00 00                inc.i32(+1)
	lib/std/math.ci:231: (9 bytes: <@0509e0> - <@0509e9>): bool(i < (data.length))
	<sum+24 @0509e0>   : 10 00                      dup.x32 sp(0)
	<sum+26 @0509e2>   : 10 06                      dup.x32 sp(6)
	<sum+28 @0509e4>   : 58                         clt.i32
	<sum+29 @0509e5>   : 05 e9 ff ff                jnz <sum+6 @0509ce>
	<sum+33 @0509e9>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:234: (3 bytes: <@0509ed> - <@0509f0>): return float64(.result := result);
	<sum+37 @0509ed>   : 14 05                      set.x64 sp(5)
	<sum+39 @0509ef>   : 03                         ret
.usages:
	test/stdc/test.math.ci:46: referenced as `sum`
	test/stdc/test.math.ci:45: referenced as `sum`
	test/stdc/test.math.ci:44: referenced as `sum`
	test/stdc/test.math.ci:43: referenced as `sum`
	lib/std/math.ci:229: defined as `sum(data: float64[]): float64`
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:244'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	test/stdc/test.math.ci:50: referenced as `eval`
	lib/std/math.ci:244: defined as `eval(x: float64, a0: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:247'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	test/stdc/test.math.ci:51: referenced as `eval`
	lib/std/math.ci:250: referenced as `eval`
	lib/std/math.ci:247: defined as `eval(x: float64, a0: float64, a1: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:250'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	test/stdc/test.math.ci:52: referenced as `eval`
	lib/std/math.ci:253: referenced as `eval`
	lib/std/math.ci:250: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64): float64`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/std/math.ci:253'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	test/stdc/test.math.ci:53: referenced as `eval`
	lib/std/math.ci:253: defined as `eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static const function
.base: `function`
.size: 47
.offset: <@0509f0>
.name: 'eval'
.file: 'lib/std/math.ci:256'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: parallel variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <@0509f0> - <@050a1f>)
	lib/std/math.ci:257: (1 byte: <@0509f0> - <@0509f1>): result: float64 := 0
	<eval @0509f0>      : 1a                         load.z64
	lib/std/math.ci:258: (43 bytes: <@0509f1> - <@050a1c>): for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1)))
	<eval+1 @0509f1>    : 10 04                      dup.x32 sp(4)
	<eval+3 @0509f3>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @0509f7>    : 04 19 00 00                jmp <eval+32 @050a10>
	lib/std/math.ci:259: (17 bytes: <@0509fb> - <@050a0c>): float64(result := float64(float64(result * x) + polynomial[i]));
	<eval+11 @0509fb>   : 11 01                      dup.x64 sp(1)
	<eval+13 @0509fd>   : 11 08                      dup.x64 sp(8)
	<eval+15 @0509ff>   : 83                         mul.f64
	<eval+16 @050a00>   : 10 06                      dup.x32 sp(6)
	<eval+18 @050a02>   : 10 03                      dup.x32 sp(3)
	<eval+20 @050a04>   : 0d 08 00 00                mad.u32 8
	<eval+24 @050a08>   : 23                         load.i64
	<eval+25 @050a09>   : 81                         add.f64
	<eval+26 @050a0a>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:258: (4 bytes: <@050a0c> - <@050a10>): int32(i := int32(i - 1))
	<eval+28 @050a0c>   : 0c ff ff ff                inc.i32(-1)
	lib/std/math.ci:258: (8 bytes: <@050a10> - <@050a18>): bool(i >= 0)
	<eval+32 @050a10>   : 10 00                      dup.x32 sp(0)
	<eval+34 @050a12>   : 19                         load.z32
	<eval+35 @050a13>   : 58                         clt.i32
	<eval+36 @050a14>   : 06 e7 ff ff                jz <eval+11 @0509fb>
	<eval+40 @050a18>   : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:261: (3 bytes: <@050a1c> - <@050a1f>): return float64(.result := result);
	<eval+44 @050a1c>   : 14 07                      set.x64 sp(7)
	<eval+46 @050a1e>   : 03                         ret
.usages:
	test/stdc/test.math.ci:55: referenced as `eval`
	test/stdc/test.math.ci:54: referenced as `eval`
	test/stdc/test.math.ci:49: referenced as `eval`
	lib/std/math.ci:256: defined as `eval(x: float64, polynomial: float64[]): float64`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@050a20>
.name: 'cmp'
.file: 'lib/std/math.ci:265'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float32(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@050a20> - <@050a59>)
	lib/std/math.ci:266: (53 bytes: <@050a20> - <@050a55>): if (bool(a < b))
	<cmp @050a20>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @050a22>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @050a24>    : 78                         clt.f32
	<cmp+5 @050a25>    : 06 1c 00 00                jz <cmp+33 @050a41>
	lib/std/math.ci:267: (20 bytes: <@050a29> - <@050a3d>): if (bool(eps < (float32(b - a))))
	<cmp+9 @050a29>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @050a2b>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @050a2d>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @050a2f>   : 72                         sub.f32
	<cmp+16 @050a30>   : 78                         clt.f32
	<cmp+17 @050a31>   : 06 0c 00 00                jz <cmp+29 @050a3d>
	lib/std/math.ci:268: (8 bytes: <@050a35> - <@050a3d>): return int32(.result := int32(-1));
	<cmp+21 @050a35>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @050a3a>   : 13 05                      set.x32 sp(5)
	<cmp+28 @050a3c>   : 03                         ret
	<cmp+29 @050a3d>   : 04 18 00 00                jmp <cmp+53 @050a55>
	lib/std/math.ci:272: (20 bytes: <@050a41> - <@050a55>): if (bool(eps < (float32(a - b))))
	<cmp+33 @050a41>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @050a43>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @050a45>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @050a47>   : 72                         sub.f32
	<cmp+40 @050a48>   : 78                         clt.f32
	<cmp+41 @050a49>   : 06 0c 00 00                jz <cmp+53 @050a55>
	lib/std/math.ci:273: (8 bytes: <@050a4d> - <@050a55>): return int32(.result := int32(+1));
	<cmp+45 @050a4d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @050a52>   : 13 05                      set.x32 sp(5)
	<cmp+52 @050a54>   : 03                         ret
	lib/std/math.ci:276: (4 bytes: <@050a55> - <@050a59>): return int32(.result := 0);
	<cmp+53 @050a55>   : 19                         load.z32
	<cmp+54 @050a56>   : 13 05                      set.x32 sp(5)
	<cmp+56 @050a58>   : 03                         ret
.usages:
	test/stdc/test.math.ci:67: referenced as `cmp`
	lib/std/math.ci:265: defined as `cmp(a: float32, b: float32, eps: float32): int32`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.offset: <@050a60>
.name: 'cmp'
.file: 'lib/std/math.ci:280'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else {
		if (bool(eps < (float64(a - b)))) {
			return int32(.result := int32(+1));
		}
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <@050a60> - <@050a99>)
	lib/std/math.ci:281: (53 bytes: <@050a60> - <@050a95>): if (bool(a < b))
	<cmp @050a60>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @050a62>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @050a64>    : 88                         clt.f64
	<cmp+5 @050a65>    : 06 1c 00 00                jz <cmp+33 @050a81>
	lib/std/math.ci:282: (20 bytes: <@050a69> - <@050a7d>): if (bool(eps < (float64(b - a))))
	<cmp+9 @050a69>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @050a6b>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @050a6d>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @050a6f>   : 82                         sub.f64
	<cmp+16 @050a70>   : 88                         clt.f64
	<cmp+17 @050a71>   : 06 0c 00 00                jz <cmp+29 @050a7d>
	lib/std/math.ci:283: (8 bytes: <@050a75> - <@050a7d>): return int32(.result := int32(-1));
	<cmp+21 @050a75>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @050a7a>   : 13 08                      set.x32 sp(8)
	<cmp+28 @050a7c>   : 03                         ret
	<cmp+29 @050a7d>   : 04 18 00 00                jmp <cmp+53 @050a95>
	lib/std/math.ci:287: (20 bytes: <@050a81> - <@050a95>): if (bool(eps < (float64(a - b))))
	<cmp+33 @050a81>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @050a83>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @050a85>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @050a87>   : 82                         sub.f64
	<cmp+40 @050a88>   : 88                         clt.f64
	<cmp+41 @050a89>   : 06 0c 00 00                jz <cmp+53 @050a95>
	lib/std/math.ci:288: (8 bytes: <@050a8d> - <@050a95>): return int32(.result := int32(+1));
	<cmp+45 @050a8d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @050a92>   : 13 08                      set.x32 sp(8)
	<cmp+52 @050a94>   : 03                         ret
	lib/std/math.ci:291: (4 bytes: <@050a95> - <@050a99>): return int32(.result := 0);
	<cmp+53 @050a95>   : 19                         load.z32
	<cmp+54 @050a96>   : 13 08                      set.x32 sp(8)
	<cmp+56 @050a98>   : 03                         ret
.usages:
	test/stdc/test.math.ci:68: referenced as `cmp`
	lib/std/math.ci:280: defined as `cmp(a: float64, b: float64, eps: float64): int32`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 335
.offset: <@050aa0>
.name: 'sinCos'
.file: 'lib/std/math.ci:295'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, e)));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), f));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <@050aa0> - <@050bef>)
	lib/std/math.ci:309: (2 bytes: <@050aa0> - <@050aa2>): x: float64 := arg
	<sinCos @050aa0>      : 11 02                      dup.x64 sp(2)
	lib/std/math.ci:310: (17 bytes: <@050aa2> - <@050ab3>): if (bool(x < (0)))
	<sinCos+2 @050aa2>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @050aa4>    : 1a                         load.z64
	<sinCos+5 @050aa5>    : 88                         clt.f64
	<sinCos+6 @050aa6>    : 06 0d 00 00                jz <sinCos+19 @050ab3>
	lib/std/math.ci:311: (1 byte: <@050aaa> - <@050aab>): float64(x := float64(-x));
	<sinCos+10 @050aaa>   : 80                         neg.f64
	lib/std/math.ci:312: (8 bytes: <@050aab> - <@050ab3>): int32(quad := int32(quad + 2));
	<sinCos+11 @050aab>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @050aad>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @050ab1>   : 13 04                      set.x32 sp(4)
	lib/std/math.ci:315: (1 byte: <@050ab3> - <@050ab4>): y: float64
	<sinCos+19 @050ab3>   : 1a                         load.z64
	lib/std/math.ci:316: (24 bytes: <@050ab4> - <@050acc>): float64(x := float64(x * float64((1) / PIO2)));
	<sinCos+20 @050ab4>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @050ab6>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @050abf>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @050ac8>   : 84                         div.f64
	<sinCos+41 @050ac9>   : 83                         mul.f64
	<sinCos+42 @050aca>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:317: (124 bytes: <@050acc> - <@050b48>): if (bool(x > (32764)))
	<sinCos+44 @050acc>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @050ace>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @050ad7>   : 89                         cgt.f64
	<sinCos+56 @050ad8>   : 06 54 00 00                jz <sinCos+140 @050b2c>
	lib/std/math.ci:318: (1 byte: <@050adc> - <@050add>): e: float64
	<sinCos+60 @050adc>   : 1b                         load.z128
	lib/std/math.ci:319: (18 bytes: <@050add> - <@050aef>): float64(y := modf(void(x, e)));
	<sinCos+61 @050add>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @050adf>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @050ae3>   : 1f a8 07 05 00             load.ref <@0507a8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @050ae8>   : 02                         call
	<sinCos+73 @050ae9>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @050aed>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:320: (4 bytes: <@050aef> - <@050af3>): float64(e := float64(e + (quad)));
	<sinCos+79 @050aef>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @050af1>   : 5d                         i32.2f64
	<sinCos+82 @050af2>   : 81                         add.f64
	lib/std/math.ci:322: (1 byte: <@050af3> - <@050af4>): f: float64
	<sinCos+83 @050af3>   : 1b                         load.z128
	lib/std/math.ci:323: (30 bytes: <@050af4> - <@050b12>): modf(void(float64(0.250000 * e), f));
	<sinCos+84 @050af4>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @050afd>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @050aff>   : 83                         mul.f64
	<sinCos+96 @050b00>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @050b04>  : 1f a8 07 05 00             load.ref <@0507a8> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @050b09>  : 02                         call
	<sinCos+106 @050b0a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @050b0e>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:324: (18 bytes: <@050b12> - <@050b24>): int32(quad := (float64(e - float64((4) * f))));
	<sinCos+114 @050b12>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @050b14>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @050b1d>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @050b1f>  : 83                         mul.f64
	<sinCos+128 @050b20>  : 82                         sub.f64
	<sinCos+129 @050b21>  : 8a                         f64.2i32
	<sinCos+130 @050b22>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @050b24>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @050b28>  : 04 20 00 00                jmp <sinCos+168 @050b48>
	lib/std/math.ci:327: (3 bytes: <@050b2c> - <@050b2f>): k: int32 := x
	<sinCos+140 @050b2c>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @050b2e>  : 8a                         f64.2i32
	lib/std/math.ci:328: (8 bytes: <@050b2f> - <@050b37>): float64(y := float64(x - (k)));
	<sinCos+143 @050b2f>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @050b31>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @050b33>  : 5d                         i32.2f64
	<sinCos+148 @050b34>  : 82                         sub.f64
	<sinCos+149 @050b35>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:329: (7 bytes: <@050b37> - <@050b3e>): int32(quad := int32(quad + k));
	<sinCos+151 @050b37>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @050b39>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @050b3b>  : 51                         add.i32
	<sinCos+156 @050b3c>  : 13 07                      set.x32 sp(7)
	lib/std/math.ci:330: (6 bytes: <@050b3e> - <@050b44>): int32(quad := int32(quad & 3));
	<sinCos+158 @050b3e>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @050b40>  : 3f 02                      b32.and 0x003
	<sinCos+162 @050b42>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @050b44>  : 09 fc ff ff                inc.sp(-4)
	lib/std/math.ci:332: (22 bytes: <@050b48> - <@050b5e>): if (int32(quad & 1))
	<sinCos+168 @050b48>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @050b4a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @050b4c>  : 06 12 00 00                jz <sinCos+190 @050b5e>
	lib/std/math.ci:333: (14 bytes: <@050b50> - <@050b5e>): float64(y := float64((1) - y));
	<sinCos+176 @050b50>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @050b59>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @050b5b>  : 82                         sub.f64
	<sinCos+188 @050b5c>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:335: (13 bytes: <@050b5e> - <@050b6b>): if (bool(quad > 1))
	<sinCos+190 @050b5e>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @050b60>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @050b65>  : 59                         cgt.i32
	<sinCos+198 @050b66>  : 06 05 00 00                jz <sinCos+203 @050b6b>
	lib/std/math.ci:336: (1 byte: <@050b6a> - <@050b6b>): float64(y := float64(-y));
	<sinCos+202 @050b6a>  : 80                         neg.f64
	lib/std/math.ci:339: (5 bytes: <@050b6b> - <@050b70>): ysq: float64 := float64(y * y)
	<sinCos+203 @050b6b>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @050b6d>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @050b6f>  : 83                         mul.f64
	lib/std/math.ci:340: (64 bytes: <@050b70> - <@050bb0>): temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y)
	<sinCos+208 @050b70>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @050b79>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @050b7b>  : 83                         mul.f64
	<sinCos+220 @050b7c>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @050b85>  : 81                         add.f64
	<sinCos+230 @050b86>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @050b88>  : 83                         mul.f64
	<sinCos+233 @050b89>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @050b92>  : 81                         add.f64
	<sinCos+243 @050b93>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @050b95>  : 83                         mul.f64
	<sinCos+246 @050b96>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @050b9f>  : 81                         add.f64
	<sinCos+256 @050ba0>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @050ba2>  : 83                         mul.f64
	<sinCos+259 @050ba3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @050bac>  : 81                         add.f64
	<sinCos+269 @050bad>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @050baf>  : 83                         mul.f64
	lib/std/math.ci:341: (51 bytes: <@050bb0> - <@050be3>): temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0))
	<sinCos+272 @050bb0>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @050bb2>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @050bbb>  : 81                         add.f64
	<sinCos+284 @050bbc>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @050bbe>  : 83                         mul.f64
	<sinCos+287 @050bbf>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @050bc8>  : 81                         add.f64
	<sinCos+297 @050bc9>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @050bcb>  : 83                         mul.f64
	<sinCos+300 @050bcc>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @050bd5>  : 81                         add.f64
	<sinCos+310 @050bd6>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @050bd8>  : 83                         mul.f64
	<sinCos+313 @050bd9>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @050be2>  : 81                         add.f64
	lib/std/math.ci:342: (12 bytes: <@050be3> - <@050bef>): return float64(.result := float64(temp1 / temp2));
	<sinCos+323 @050be3>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @050be5>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @050be7>  : 84                         div.f64
	<sinCos+328 @050be8>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @050bea>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @050bee>  : 03                         ret
.usages:
	lib/std/math.ci:349: referenced as `sinCos`
	lib/std/math.ci:346: referenced as `sinCos`
	lib/std/math.ci:295: defined as `sinCos(arg: float64, quad: int32): float64`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.ci:346'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	test/stdc/test.math.ci:57: referenced as `sin`
	lib/std/math.ci:346: defined as `sin(arg: float64): float64`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.ci:349'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	test/stdc/test.math.ci:58: referenced as `cos`
	lib/std/math.ci:349: defined as `cos(arg: float64): float64`
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 378
.offset: <@050bf0>
.name: 'tan'
.file: 'lib/std/math.ci:352'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, e));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else {
		if (bool(i == 1)) {
			float64(x := float64((1) - x));
			bool(complement := true);
		}
		else {
			if (bool(i == 2)) {
				bool(negate := bool(!negate));
				bool(complement := true);
			}
			else {
				if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
			}
		}
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <@050bf0> - <@050d6a>)
	lib/std/math.ci:365: (1 byte: <@050bf0> - <@050bf1>): complement: bool := false
	<tan @050bf0>      : 19                         load.z32
	lib/std/math.ci:366: (1 byte: <@050bf1> - <@050bf2>): negate: bool := false
	<tan+1 @050bf1>    : 19                         load.z32
	lib/std/math.ci:368: (23 bytes: <@050bf2> - <@050c09>): if (bool(arg < (0)))
	<tan+2 @050bf2>    : 11 03                      dup.x64 sp(3)
	<tan+4 @050bf4>    : 1a                         load.z64
	<tan+5 @050bf5>    : 88                         clt.f64
	<tan+6 @050bf6>    : 06 13 00 00                jz <tan+25 @050c09>
	lib/std/math.ci:369: (5 bytes: <@050bfa> - <@050bff>): float64(arg := float64(-arg));
	<tan+10 @050bfa>   : 11 03                      dup.x64 sp(3)
	<tan+12 @050bfc>   : 80                         neg.f64
	<tan+13 @050bfd>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:370: (10 bytes: <@050bff> - <@050c09>): bool(negate := true);
	<tan+15 @050bff>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @050c04>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @050c08>   : 25                         store.i8
	lib/std/math.ci:372: (24 bytes: <@050c09> - <@050c21>): float64(arg := float64(float64((2) * arg) / PIO2));
	<tan+25 @050c09>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @050c12>   : 11 05                      dup.x64 sp(5)
	<tan+36 @050c14>   : 83                         mul.f64
	<tan+37 @050c15>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @050c1e>   : 84                         div.f64
	<tan+47 @050c1f>   : 14 05                      set.x64 sp(5)
	lib/std/math.ci:374: (1 byte: <@050c21> - <@050c22>): e: float64
	<tan+49 @050c21>   : 1b                         load.z128
	lib/std/math.ci:375: (16 bytes: <@050c22> - <@050c32>): x: float64 := modf(void(arg, e))
	<tan+50 @050c22>   : 11 07                      dup.x64 sp(7)
	<tan+52 @050c24>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @050c28>   : 1f a8 07 05 00             load.ref <@0507a8> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @050c2d>   : 02                         call
	<tan+62 @050c2e>   : 09 f4 ff ff                inc.sp(-12)
	lib/std/math.ci:376: (9 bytes: <@050c32> - <@050c3b>): i: int32 := int32(int32(e) % 4)
	<tan+66 @050c32>   : 11 02                      dup.x64 sp(2)
	<tan+68 @050c34>   : 8a                         f64.2i32
	<tan+69 @050c35>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @050c3a>   : 55                         mod.i32
	lib/std/math.ci:378: (122 bytes: <@050c3b> - <@050cb5>): if (bool(i == 0))
	<tan+75 @050c3b>   : 10 00                      dup.x32 sp(0)
	<tan+77 @050c3d>   : 19                         load.z32
	<tan+78 @050c3e>   : 57                         ceq.i32
	<tan+79 @050c3f>   : 05 76 00 00                jnz <tan+197 @050cb5>
	lib/std/math.ci:379: (114 bytes: <@050c43> - <@050cb5>): if (bool(i == 1))
	<tan+83 @050c43>   : 10 00                      dup.x32 sp(0)
	<tan+85 @050c45>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @050c4a>   : 57                         ceq.i32
	<tan+91 @050c4b>   : 06 20 00 00                jz <tan+123 @050c6b>
	lib/std/math.ci:380: (14 bytes: <@050c4f> - <@050c5d>): float64(x := float64((1) - x));
	<tan+95 @050c4f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @050c58>  : 11 03                      dup.x64 sp(3)
	<tan+106 @050c5a>  : 82                         sub.f64
	<tan+107 @050c5b>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:381: (10 bytes: <@050c5d> - <@050c67>): bool(complement := true);
	<tan+109 @050c5d>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @050c62>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @050c66>  : 25                         store.i8
	<tan+119 @050c67>  : 04 4e 00 00                jmp <tan+197 @050cb5>
	lib/std/math.ci:383: (74 bytes: <@050c6b> - <@050cb5>): if (bool(i == 2))
	<tan+123 @050c6b>  : 10 00                      dup.x32 sp(0)
	<tan+125 @050c6d>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @050c72>  : 57                         ceq.i32
	<tan+131 @050c73>  : 06 1d 00 00                jz <tan+160 @050c90>
	lib/std/math.ci:384: (11 bytes: <@050c77> - <@050c82>): bool(negate := bool(!negate));
	<tan+135 @050c77>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @050c7b>  : 20                         load.i8
	<tan+140 @050c7c>  : 0b                         not.b32
	<tan+141 @050c7d>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @050c81>  : 25                         store.i8
	lib/std/math.ci:385: (10 bytes: <@050c82> - <@050c8c>): bool(complement := true);
	<tan+146 @050c82>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @050c87>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @050c8b>  : 25                         store.i8
	<tan+156 @050c8c>  : 04 29 00 00                jmp <tan+197 @050cb5>
	lib/std/math.ci:387: (37 bytes: <@050c90> - <@050cb5>): if (bool(i == 3))
	<tan+160 @050c90>  : 10 00                      dup.x32 sp(0)
	<tan+162 @050c92>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @050c97>  : 57                         ceq.i32
	<tan+168 @050c98>  : 06 1d 00 00                jz <tan+197 @050cb5>
	lib/std/math.ci:388: (14 bytes: <@050c9c> - <@050caa>): float64(x := float64((1) - x));
	<tan+172 @050c9c>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @050ca5>  : 11 03                      dup.x64 sp(3)
	<tan+183 @050ca7>  : 82                         sub.f64
	<tan+184 @050ca8>  : 14 03                      set.x64 sp(3)
	lib/std/math.ci:389: (11 bytes: <@050caa> - <@050cb5>): bool(negate := bool(!negate));
	<tan+186 @050caa>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @050cae>  : 20                         load.i8
	<tan+191 @050caf>  : 0b                         not.b32
	<tan+192 @050cb0>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @050cb4>  : 25                         store.i8
	lib/std/math.ci:392: (5 bytes: <@050cb5> - <@050cba>): xsq: float64 := float64(x * x)
	<tan+197 @050cb5>  : 11 01                      dup.x64 sp(1)
	<tan+199 @050cb7>  : 11 03                      dup.x64 sp(3)
	<tan+201 @050cb9>  : 83                         mul.f64
	lib/std/math.ci:393: (64 bytes: <@050cba> - <@050cfa>): result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x)
	<tan+202 @050cba>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @050cc3>  : 11 02                      dup.x64 sp(2)
	<tan+213 @050cc5>  : 83                         mul.f64
	<tan+214 @050cc6>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @050ccf>  : 81                         add.f64
	<tan+224 @050cd0>  : 11 02                      dup.x64 sp(2)
	<tan+226 @050cd2>  : 83                         mul.f64
	<tan+227 @050cd3>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @050cdc>  : 81                         add.f64
	<tan+237 @050cdd>  : 11 02                      dup.x64 sp(2)
	<tan+239 @050cdf>  : 83                         mul.f64
	<tan+240 @050ce0>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @050ce9>  : 81                         add.f64
	<tan+250 @050cea>  : 11 02                      dup.x64 sp(2)
	<tan+252 @050cec>  : 83                         mul.f64
	<tan+253 @050ced>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @050cf6>  : 81                         add.f64
	<tan+263 @050cf7>  : 11 05                      dup.x64 sp(5)
	<tan+265 @050cf9>  : 83                         mul.f64
	lib/std/math.ci:394: (39 bytes: <@050cfa> - <@050d21>): float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	<tan+266 @050cfa>  : 11 02                      dup.x64 sp(2)
	<tan+268 @050cfc>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @050d05>  : 81                         add.f64
	<tan+278 @050d06>  : 11 04                      dup.x64 sp(4)
	<tan+280 @050d08>  : 83                         mul.f64
	<tan+281 @050d09>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @050d12>  : 81                         add.f64
	<tan+291 @050d13>  : 11 04                      dup.x64 sp(4)
	<tan+293 @050d15>  : 83                         mul.f64
	<tan+294 @050d16>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @050d1f>  : 81                         add.f64
	<tan+304 @050d20>  : 84                         div.f64
	lib/std/math.ci:396: (47 bytes: <@050d21> - <@050d50>): if (complement)
	<tan+305 @050d21>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @050d25>  : 20                         load.i8
	<tan+310 @050d26>  : 06 2a 00 00                jz <tan+352 @050d50>
	lib/std/math.ci:397: (24 bytes: <@050d2a> - <@050d42>): if (bool(result == (0)))
	<tan+314 @050d2a>  : 11 00                      dup.x64 sp(0)
	<tan+316 @050d2c>  : 1a                         load.z64
	<tan+317 @050d2d>  : 87                         ceq.f64
	<tan+318 @050d2e>  : 06 14 00 00                jz <tan+338 @050d42>
	lib/std/math.ci:398: (16 bytes: <@050d32> - <@050d42>): return float64(.result := nan);
	<tan+322 @050d32>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @050d3b>  : 14 10                      set.x64 sp(16)
	<tan+333 @050d3d>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @050d41>  : 03                         ret
	lib/std/math.ci:400: (14 bytes: <@050d42> - <@050d50>): float64(result := float64((1) / result));
	<tan+338 @050d42>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @050d4b>  : 11 02                      dup.x64 sp(2)
	<tan+349 @050d4d>  : 84                         div.f64
	<tan+350 @050d4e>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:402: (19 bytes: <@050d50> - <@050d63>): if (negate)
	<tan+352 @050d50>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @050d54>  : 20                         load.i8
	<tan+357 @050d55>  : 06 0e 00 00                jz <tan+371 @050d63>
	lib/std/math.ci:403: (10 bytes: <@050d59> - <@050d63>): return float64(.result := float64(-result));
	<tan+361 @050d59>  : 11 00                      dup.x64 sp(0)
	<tan+363 @050d5b>  : 80                         neg.f64
	<tan+364 @050d5c>  : 14 10                      set.x64 sp(16)
	<tan+366 @050d5e>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @050d62>  : 03                         ret
	lib/std/math.ci:405: (7 bytes: <@050d63> - <@050d6a>): return float64(.result := result);
	<tan+371 @050d63>  : 14 0e                      set.x64 sp(14)
	<tan+373 @050d65>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @050d69>  : 03                         ret
.usages:
	test/stdc/test.math.ci:59: referenced as `tan`
	lib/std/math.ci:352: defined as `tan(arg: float64): float64`
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 241
.offset: <@050d70>
.name: 'sinh'
.file: 'lib/std/math.ci:409'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <@050d70> - <@050e61>)
	lib/std/math.ci:421: (1 byte: <@050d70> - <@050d71>): negate: bool := false
	<sinh @050d70>      : 19                         load.z32
	lib/std/math.ci:422: (23 bytes: <@050d71> - <@050d88>): if (bool(x < (0)))
	<sinh+1 @050d71>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @050d73>    : 1a                         load.z64
	<sinh+4 @050d74>    : 88                         clt.f64
	<sinh+5 @050d75>    : 06 13 00 00                jz <sinh+24 @050d88>
	lib/std/math.ci:423: (5 bytes: <@050d79> - <@050d7e>): float64(x := float64(-x));
	<sinh+9 @050d79>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @050d7b>   : 80                         neg.f64
	<sinh+12 @050d7c>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:424: (10 bytes: <@050d7e> - <@050d88>): bool(negate := true);
	<sinh+14 @050d7e>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @050d83>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @050d87>   : 25                         store.i8
	lib/std/math.ci:427: (39 bytes: <@050d88> - <@050daf>): if (bool(x > (21)))
	<sinh+24 @050d88>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @050d8a>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @050d93>   : 89                         cgt.f64
	<sinh+36 @050d94>   : 06 1b 00 00                jz <sinh+63 @050daf>
	lib/std/math.ci:428: (23 bytes: <@050d98> - <@050daf>): return float64(.result := float64(float64.exp(x) / (2)));
	<sinh+40 @050d98>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @050d9a>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+46 @050d9e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @050da7>   : 84                         div.f64
	<sinh+56 @050da8>   : 14 06                      set.x64 sp(6)
	<sinh+58 @050daa>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @050dae>   : 03                         ret
	lib/std/math.ci:431: (1 byte: <@050daf> - <@050db0>): result: float64
	<sinh+63 @050daf>   : 1a                         load.z64
	lib/std/math.ci:432: (151 bytes: <@050db0> - <@050e47>): if (bool(x > 0.500000))
	<sinh+64 @050db0>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @050db2>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @050dbb>   : 89                         cgt.f64
	<sinh+76 @050dbc>   : 06 22 00 00                jz <sinh+110 @050dde>
	lib/std/math.ci:433: (26 bytes: <@050dc0> - <@050dda>): float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	<sinh+80 @050dc0>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @050dc2>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+86 @050dc6>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @050dc8>   : 80                         neg.f64
	<sinh+89 @050dc9>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<sinh+93 @050dcd>   : 82                         sub.f64
	<sinh+94 @050dce>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @050dd7>  : 84                         div.f64
	<sinh+104 @050dd8>  : 14 02                      set.x64 sp(2)
	<sinh+106 @050dda>  : 04 6d 00 00                jmp <sinh+215 @050e47>
	lib/std/math.ci:436: (5 bytes: <@050dde> - <@050de3>): sq: float64 := float64(x * x)
	<sinh+110 @050dde>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @050de0>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @050de2>  : 83                         mul.f64
	lib/std/math.ci:437: (53 bytes: <@050de3> - <@050e18>): float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
	<sinh+115 @050de3>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @050dec>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @050dee>  : 83                         mul.f64
	<sinh+127 @050def>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @050df8>  : 81                         add.f64
	<sinh+137 @050df9>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @050dfb>  : 83                         mul.f64
	<sinh+140 @050dfc>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @050e05>  : 81                         add.f64
	<sinh+150 @050e06>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @050e08>  : 83                         mul.f64
	<sinh+153 @050e09>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @050e12>  : 81                         add.f64
	<sinh+163 @050e13>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @050e15>  : 83                         mul.f64
	<sinh+166 @050e16>  : 14 04                      set.x64 sp(4)
	lib/std/math.ci:438: (43 bytes: <@050e18> - <@050e43>): float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	<sinh+168 @050e18>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @050e1a>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @050e1c>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @050e25>  : 81                         add.f64
	<sinh+182 @050e26>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @050e28>  : 83                         mul.f64
	<sinh+185 @050e29>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @050e32>  : 81                         add.f64
	<sinh+195 @050e33>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @050e35>  : 83                         mul.f64
	<sinh+198 @050e36>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @050e3f>  : 81                         add.f64
	<sinh+208 @050e40>  : 84                         div.f64
	<sinh+209 @050e41>  : 14 04                      set.x64 sp(4)
	<sinh+211 @050e43>  : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.ci:441: (19 bytes: <@050e47> - <@050e5a>): if (negate)
	<sinh+215 @050e47>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @050e4b>  : 20                         load.i8
	<sinh+220 @050e4c>  : 06 0e 00 00                jz <sinh+234 @050e5a>
	lib/std/math.ci:442: (10 bytes: <@050e50> - <@050e5a>): return float64(.result := float64(-result));
	<sinh+224 @050e50>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @050e52>  : 80                         neg.f64
	<sinh+227 @050e53>  : 14 08                      set.x64 sp(8)
	<sinh+229 @050e55>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @050e59>  : 03                         ret
	lib/std/math.ci:444: (7 bytes: <@050e5a> - <@050e61>): return float64(.result := result);
	<sinh+234 @050e5a>  : 14 06                      set.x64 sp(6)
	<sinh+236 @050e5c>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @050e60>  : 03                         ret
.usages:
	test/stdc/test.math.ci:60: referenced as `sinh`
	lib/std/math.Complex.ci:148: referenced as `sinh`
	lib/std/math.Complex.ci:146: referenced as `sinh`
	lib/std/math.ci:409: defined as `sinh(x: float64): float64`
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.offset: <@050e68>
.name: 'cosh'
.file: 'lib/std/math.ci:448'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <@050e68> - <@050eb3>)
	lib/std/math.ci:449: (13 bytes: <@050e68> - <@050e75>): if (bool(x < (0)))
	<cosh @050e68>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @050e6a>    : 1a                         load.z64
	<cosh+3 @050e6b>    : 88                         clt.f64
	<cosh+4 @050e6c>    : 06 09 00 00                jz <cosh+13 @050e75>
	lib/std/math.ci:450: (5 bytes: <@050e70> - <@050e75>): float64(x := float64(-x));
	<cosh+8 @050e70>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @050e72>   : 80                         neg.f64
	<cosh+11 @050e73>   : 14 03                      set.x64 sp(3)
	lib/std/math.ci:452: (35 bytes: <@050e75> - <@050e98>): if (bool(x > (21)))
	<cosh+13 @050e75>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @050e77>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @050e80>   : 89                         cgt.f64
	<cosh+25 @050e81>   : 06 17 00 00                jz <cosh+48 @050e98>
	lib/std/math.ci:453: (19 bytes: <@050e85> - <@050e98>): return float64(.result := float64(float64.exp(x) / (2)));
	<cosh+29 @050e85>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @050e87>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+35 @050e8b>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @050e94>   : 84                         div.f64
	<cosh+45 @050e95>   : 14 05                      set.x64 sp(5)
	<cosh+47 @050e97>   : 03                         ret
	lib/std/math.ci:455: (27 bytes: <@050e98> - <@050eb3>): return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
	<cosh+48 @050e98>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @050e9a>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+54 @050e9e>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @050ea0>   : 80                         neg.f64
	<cosh+57 @050ea1>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<cosh+61 @050ea5>   : 81                         add.f64
	<cosh+62 @050ea6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @050eaf>   : 84                         div.f64
	<cosh+72 @050eb0>   : 14 05                      set.x64 sp(5)
	<cosh+74 @050eb2>   : 03                         ret
.usages:
	test/stdc/test.math.ci:61: referenced as `cosh`
	lib/std/math.Complex.ci:148: referenced as `cosh`
	lib/std/math.Complex.ci:146: referenced as `cosh`
	lib/std/math.ci:448: defined as `cosh(x: float64): float64`
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 173
.offset: <@050eb8>
.name: 'asin'
.file: 'lib/std/math.ci:463'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <@050eb8> - <@050f65>)
	lib/std/math.ci:464: (12 bytes: <@050eb8> - <@050ec4>): if (bool(x == (0)))
	<asin @050eb8>      : 11 01                      dup.x64 sp(1)
	<asin+2 @050eba>    : 1a                         load.z64
	<asin+3 @050ebb>    : 87                         ceq.f64
	<asin+4 @050ebc>    : 06 08 00 00                jz <asin+12 @050ec4>
	lib/std/math.ci:466: (4 bytes: <@050ec0> - <@050ec4>): return float64(.result := x);
	<asin+8 @050ec0>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @050ec3>   : 03                         ret
	lib/std/math.ci:469: (1 byte: <@050ec4> - <@050ec5>): negate: bool := false
	<asin+12 @050ec4>   : 19                         load.z32
	lib/std/math.ci:470: (23 bytes: <@050ec5> - <@050edc>): if (bool(x < (0)))
	<asin+13 @050ec5>   : 11 02                      dup.x64 sp(2)
	<asin+15 @050ec7>   : 1a                         load.z64
	<asin+16 @050ec8>   : 88                         clt.f64
	<asin+17 @050ec9>   : 06 13 00 00                jz <asin+36 @050edc>
	lib/std/math.ci:471: (10 bytes: <@050ecd> - <@050ed7>): bool(negate := true);
	<asin+21 @050ecd>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @050ed2>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @050ed6>   : 25                         store.i8
	lib/std/math.ci:472: (5 bytes: <@050ed7> - <@050edc>): float64(x := float64(-x));
	<asin+31 @050ed7>   : 11 02                      dup.x64 sp(2)
	<asin+33 @050ed9>   : 80                         neg.f64
	<asin+34 @050eda>   : 14 04                      set.x64 sp(4)
	lib/std/math.ci:475: (32 bytes: <@050edc> - <@050efc>): if (bool(x > (1)))
	<asin+36 @050edc>   : 11 02                      dup.x64 sp(2)
	<asin+38 @050ede>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @050ee7>   : 89                         cgt.f64
	<asin+48 @050ee8>   : 06 14 00 00                jz <asin+68 @050efc>
	lib/std/math.ci:477: (16 bytes: <@050eec> - <@050efc>): return float64(.result := nan);
	<asin+52 @050eec>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @050ef5>   : 14 06                      set.x64 sp(6)
	<asin+63 @050ef7>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @050efb>   : 03                         ret
	lib/std/math.ci:480: (19 bytes: <@050efc> - <@050f0f>): result: float64 := float64.sqrt(float64((1) - float64(x * x)))
	<asin+68 @050efc>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @050f05>   : 11 04                      dup.x64 sp(4)
	<asin+79 @050f07>   : 11 06                      dup.x64 sp(6)
	<asin+81 @050f09>   : 83                         mul.f64
	<asin+82 @050f0a>   : 82                         sub.f64
	<asin+83 @050f0b>   : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	lib/std/math.ci:481: (60 bytes: <@050f0f> - <@050f4b>): if (bool(x > 0.700000))
	<asin+87 @050f0f>   : 11 04                      dup.x64 sp(4)
	<asin+89 @050f11>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @050f1a>   : 89                         cgt.f64
	<asin+99 @050f1b>   : 06 26 00 00                jz <asin+137 @050f41>
	lib/std/math.ci:482: (30 bytes: <@050f1f> - <@050f3d>): float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	<asin+103 @050f1f>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @050f28>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @050f31>  : 84                         div.f64
	<asin+122 @050f32>  : 11 02                      dup.x64 sp(2)
	<asin+124 @050f34>  : 11 08                      dup.x64 sp(8)
	<asin+126 @050f36>  : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @050f3a>  : 82                         sub.f64
	<asin+131 @050f3b>  : 14 02                      set.x64 sp(2)
	<asin+133 @050f3d>  : 04 0e 00 00                jmp <asin+147 @050f4b>
	lib/std/math.ci:485: (10 bytes: <@050f41> - <@050f4b>): float64(result := float64.atan2(void(x, result)));
	<asin+137 @050f41>  : 11 04                      dup.x64 sp(4)
	<asin+139 @050f43>  : 11 02                      dup.x64 sp(2)
	<asin+141 @050f45>  : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @050f49>  : 14 02                      set.x64 sp(2)
	lib/std/math.ci:488: (19 bytes: <@050f4b> - <@050f5e>): if (negate)
	<asin+147 @050f4b>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @050f4f>  : 20                         load.i8
	<asin+152 @050f50>  : 06 0e 00 00                jz <asin+166 @050f5e>
	lib/std/math.ci:489: (10 bytes: <@050f54> - <@050f5e>): return float64(.result := float64(-result));
	<asin+156 @050f54>  : 11 00                      dup.x64 sp(0)
	<asin+158 @050f56>  : 80                         neg.f64
	<asin+159 @050f57>  : 14 08                      set.x64 sp(8)
	<asin+161 @050f59>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @050f5d>  : 03                         ret
	lib/std/math.ci:491: (7 bytes: <@050f5e> - <@050f65>): return float64(.result := result);
	<asin+166 @050f5e>  : 14 06                      set.x64 sp(6)
	<asin+168 @050f60>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @050f64>  : 03                         ret
.usages:
	test/stdc/test.math.ci:63: referenced as `asin`
	lib/std/math.ci:498: referenced as `asin`
	lib/std/math.ci:463: defined as `asin(x: float64): float64`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'lib/std/math.ci:498'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	test/stdc/test.math.ci:64: referenced as `acos`
	lib/std/math.ci:498: defined as `acos(x: float64): float64`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'lib/std/math.ci:522'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
	lib/std/math.ci:522: defined as `radians(degrees: float64): float64`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'lib/std/math.ci:525'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
	lib/std/math.ci:525: defined as `degrees(radians: float64): float64`
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01a0a0>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:181: referenced as `Complex`
	lib/std/math.Complex.ci:179: referenced as `Complex`
	lib/std/math.Complex.ci:177: referenced as `Complex`
	lib/std/math.Complex.ci:175: referenced as `Complex`
	lib/std/math.Complex.ci:172: referenced as `Complex`
	lib/std/math.Complex.ci:170: referenced as `Complex`
	lib/std/math.Complex.ci:168: referenced as `Complex`
	lib/std/math.Complex.ci:166: referenced as `Complex`
	lib/std/math.Complex.ci:163: referenced as `Complex`
	lib/std/math.Complex.ci:161: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:132: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:114: referenced as `Complex`
	lib/std/math.Complex.ci:111: referenced as `Complex`
	lib/std/math.Complex.ci:109: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:83: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: referenced as `Complex`
	lib/std/math.Complex.ci:24: referenced as `Complex`
	lib/std/math.Complex.ci:2: defined as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'lib/std/math.Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:184: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:148: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:146: referenced as `re`
	lib/std/math.Complex.ci:138: referenced as `re`
	lib/std/math.Complex.ci:136: referenced as `re`
	lib/std/math.Complex.ci:135: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:126: referenced as `re`
	lib/std/math.Complex.ci:123: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:117: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:115: referenced as `re`
	lib/std/math.Complex.ci:111: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:109: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:99: referenced as `re`
	lib/std/math.Complex.ci:98: referenced as `re`
	lib/std/math.Complex.ci:96: referenced as `re`
	lib/std/math.Complex.ci:95: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:92: referenced as `re`
	lib/std/math.Complex.ci:91: referenced as `re`
	lib/std/math.Complex.ci:89: referenced as `re`
	lib/std/math.Complex.ci:88: referenced as `re`
	lib/std/math.Complex.ci:87: referenced as `re`
	lib/std/math.Complex.ci:80: referenced as `re`
	lib/std/math.Complex.ci:78: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:76: referenced as `re`
	lib/std/math.Complex.ci:73: referenced as `re`
	lib/std/math.Complex.ci:71: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:69: referenced as `re`
	lib/std/math.Complex.ci:66: referenced as `re`
	lib/std/math.Complex.ci:64: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:62: referenced as `re`
	lib/std/math.Complex.ci:59: referenced as `re`
	lib/std/math.Complex.ci:33: referenced as `re`
	lib/std/math.Complex.ci:26: referenced as `re`
	lib/std/math.Complex.ci:5: defined as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'lib/std/math.Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:184: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:148: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:146: referenced as `im`
	lib/std/math.Complex.ci:139: referenced as `im`
	lib/std/math.Complex.ci:136: referenced as `im`
	lib/std/math.Complex.ci:135: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:126: referenced as `im`
	lib/std/math.Complex.ci:123: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:118: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:115: referenced as `im`
	lib/std/math.Complex.ci:111: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:109: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:99: referenced as `im`
	lib/std/math.Complex.ci:98: referenced as `im`
	lib/std/math.Complex.ci:96: referenced as `im`
	lib/std/math.Complex.ci:95: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:92: referenced as `im`
	lib/std/math.Complex.ci:91: referenced as `im`
	lib/std/math.Complex.ci:89: referenced as `im`
	lib/std/math.Complex.ci:88: referenced as `im`
	lib/std/math.Complex.ci:87: referenced as `im`
	lib/std/math.Complex.ci:80: referenced as `im`
	lib/std/math.Complex.ci:78: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:76: referenced as `im`
	lib/std/math.Complex.ci:73: referenced as `im`
	lib/std/math.Complex.ci:71: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:69: referenced as `im`
	lib/std/math.Complex.ci:66: referenced as `im`
	lib/std/math.Complex.ci:64: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:62: referenced as `im`
	lib/std/math.Complex.ci:59: referenced as `im`
	lib/std/math.Complex.ci:34: referenced as `im`
	lib/std/math.Complex.ci:8: defined as `im`
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050f68>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <@050f68> - <@050f6f>)
	lib/std/math.Complex.ci:25: (7 bytes: <@050f68> - <@050f6f>): return void(.result := {...});
	<Complex @050f68>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <@050f6b> - <@050f6e>): void(.result.im := (0))
	<Complex+3 @050f6b>    : 1a                         load.z64
	<Complex+4 @050f6c>    : 14 07                      set.x64 sp(7)
	<Complex+6 @050f6e>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `Complex`
	lib/std/math.Complex.ci:106: referenced as `Complex`
	lib/std/math.Complex.ci:104: referenced as `Complex`
	lib/std/math.Complex.ci:24: defined as `Complex(re: float64): Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@050f70>
.name: 'Complex'
.file: 'lib/std/math.Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <@050f70> - <@050f77>)
	lib/std/math.Complex.ci:32: (7 bytes: <@050f70> - <@050f77>): return void(.result := {...});
	<Complex @050f70>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/std/math.Complex.ci:34: (3 bytes: <@050f73> - <@050f76>): void(.result.im := im);
	<Complex+3 @050f73>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @050f76>    : 03                         ret
.usages:
	lib/std/math.Complex.ci:186: referenced as `Complex`
	lib/std/math.Complex.ci:184: referenced as `Complex`
	lib/std/math.Complex.ci:148: referenced as `Complex`
	lib/std/math.Complex.ci:146: referenced as `Complex`
	lib/std/math.Complex.ci:129: referenced as `Complex`
	lib/std/math.Complex.ci:126: referenced as `Complex`
	lib/std/math.Complex.ci:123: referenced as `Complex`
	lib/std/math.Complex.ci:80: referenced as `Complex`
	lib/std/math.Complex.ci:78: referenced as `Complex`
	lib/std/math.Complex.ci:76: referenced as `Complex`
	lib/std/math.Complex.ci:73: referenced as `Complex`
	lib/std/math.Complex.ci:71: referenced as `Complex`
	lib/std/math.Complex.ci:69: referenced as `Complex`
	lib/std/math.Complex.ci:66: referenced as `Complex`
	lib/std/math.Complex.ci:64: referenced as `Complex`
	lib/std/math.Complex.ci:62: referenced as `Complex`
	lib/std/math.Complex.ci:59: referenced as `Complex`
	lib/std/math.Complex.ci:31: defined as `Complex(re: float64, im: float64): Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/std/math.Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(-a.re), float64(-a.im)))
.usages:
	lib/vec/vec4f.ci:67: referenced as `neg`
	lib/std/math.Complex.ci:168: referenced as `neg`
	lib/std/math.Complex.ci:166: referenced as `neg`
	lib/std/math.Complex.ci:59: defined as `neg(a: Complex): Complex`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re + b.re), float64(a.im + b.im)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `add`
	lib/std/math.Complex.ci:62: defined as `add(a: Complex, b: Complex): Complex`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `add`
	lib/std/math.Complex.ci:170: referenced as `add`
	lib/std/math.Complex.ci:64: defined as `add(a: Complex, b: float64): Complex`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/std/math.Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
	lib/std/math.Complex.ci:66: defined as `add(a: float64, b: Complex): Complex`
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a.re - b.re), float64(a.im - b.im)))
.usages:
	lib/std/math.Complex.ci:166: referenced as `sub`
	lib/std/math.Complex.ci:69: defined as `sub(a: Complex, b: Complex): Complex`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	lib/std/math.Complex.ci:172: referenced as `sub`
	lib/std/math.Complex.ci:170: referenced as `sub`
	lib/std/math.Complex.ci:71: defined as `sub(a: Complex, b: float64): Complex`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/std/math.Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
	lib/std/math.Complex.ci:73: defined as `sub(a: float64, b: Complex): Complex`
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))))
.usages:
	lib/std/math.Complex.ci:76: defined as `mul(a: Complex, b: Complex): Complex`
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:78'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
	lib/std/math.Complex.ci:78: defined as `mul(a: Complex, b: float64): Complex`
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/std/math.Complex.ci:80'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:172: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:170: referenced as `mul`
	lib/std/math.Complex.ci:80: defined as `mul(a: float64, b: Complex): Complex`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 123
.offset: <@050f78>
.name: 'div'
.file: 'lib/std/math.Complex.ci:83'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <@050f78> - <@050ff3>)
	lib/std/math.Complex.ci:87: (79 bytes: <@050f78> - <@050fc7>): if (bool(Math.abs(b.re) >= Math.abs(b.im)))
	<div @050f78>      : 1a                         load.z64
	<div+1 @050f79>    : 11 03                      dup.x64 sp(3)
	<div+3 @050f7b>    : 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<div+8 @050f80>    : 02                         call
	<div+9 @050f81>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @050f85>   : 1a                         load.z64
	<div+14 @050f86>   : 11 07                      dup.x64 sp(7)
	<div+16 @050f88>   : 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<div+21 @050f8d>   : 02                         call
	<div+22 @050f8e>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @050f92>   : 88                         clt.f64
	<div+27 @050f93>   : 05 34 00 00                jnz <div+79 @050fc7>
	lib/std/math.Complex.ci:88: (5 bytes: <@050f97> - <@050f9c>): r: float64 := float64(b.im / b.re)
	<div+31 @050f97>   : 11 03                      dup.x64 sp(3)
	<div+33 @050f99>   : 11 03                      dup.x64 sp(3)
	<div+35 @050f9b>   : 84                         div.f64
	lib/std/math.Complex.ci:89: (8 bytes: <@050f9c> - <@050fa4>): den: float64 := float64(b.re + float64(r * b.im))
	<div+36 @050f9c>   : 11 03                      dup.x64 sp(3)
	<div+38 @050f9e>   : 11 02                      dup.x64 sp(2)
	<div+40 @050fa0>   : 11 09                      dup.x64 sp(9)
	<div+42 @050fa2>   : 83                         mul.f64
	<div+43 @050fa3>   : 81                         add.f64
	lib/std/math.Complex.ci:90: (31 bytes: <@050fa4> - <@050fc3>): return void(.result := {...});
	<div+44 @050fa4>   : 11 09                      dup.x64 sp(9)
	<div+46 @050fa6>   : 11 04                      dup.x64 sp(4)
	<div+48 @050fa8>   : 11 0f                      dup.x64 sp(15)
	<div+50 @050faa>   : 83                         mul.f64
	<div+51 @050fab>   : 81                         add.f64
	<div+52 @050fac>   : 11 02                      dup.x64 sp(2)
	<div+54 @050fae>   : 84                         div.f64
	<div+55 @050faf>   : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:92: (13 bytes: <@050fb1> - <@050fbe>): void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
	<div+57 @050fb1>   : 11 0b                      dup.x64 sp(11)
	<div+59 @050fb3>   : 11 04                      dup.x64 sp(4)
	<div+61 @050fb5>   : 11 0d                      dup.x64 sp(13)
	<div+63 @050fb7>   : 83                         mul.f64
	<div+64 @050fb8>   : 82                         sub.f64
	<div+65 @050fb9>   : 11 02                      dup.x64 sp(2)
	<div+67 @050fbb>   : 84                         div.f64
	<div+68 @050fbc>   : 14 11                      set.x64 sp(17)
	<div+70 @050fbe>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @050fc2>   : 03                         ret
	<div+75 @050fc3>   : 09 f0 ff ff                inc.sp(-16)
	lib/std/math.Complex.ci:95: (5 bytes: <@050fc7> - <@050fcc>): r: float64 := float64(b.re / b.im)
	<div+79 @050fc7>   : 11 01                      dup.x64 sp(1)
	<div+81 @050fc9>   : 11 05                      dup.x64 sp(5)
	<div+83 @050fcb>   : 84                         div.f64
	lib/std/math.Complex.ci:96: (8 bytes: <@050fcc> - <@050fd4>): den: float64 := float64(b.im + float64(r * b.re))
	<div+84 @050fcc>   : 11 05                      dup.x64 sp(5)
	<div+86 @050fce>   : 11 02                      dup.x64 sp(2)
	<div+88 @050fd0>   : 11 07                      dup.x64 sp(7)
	<div+90 @050fd2>   : 83                         mul.f64
	<div+91 @050fd3>   : 81                         add.f64
	lib/std/math.Complex.ci:97: (31 bytes: <@050fd4> - <@050ff3>): return void(.result := {...});
	<div+92 @050fd4>   : 11 09                      dup.x64 sp(9)
	<div+94 @050fd6>   : 11 04                      dup.x64 sp(4)
	<div+96 @050fd8>   : 83                         mul.f64
	<div+97 @050fd9>   : 11 0d                      dup.x64 sp(13)
	<div+99 @050fdb>   : 81                         add.f64
	<div+100 @050fdc>  : 11 02                      dup.x64 sp(2)
	<div+102 @050fde>  : 84                         div.f64
	<div+103 @050fdf>  : 14 0f                      set.x64 sp(15)
	lib/std/math.Complex.ci:99: (13 bytes: <@050fe1> - <@050fee>): void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
	<div+105 @050fe1>  : 11 0b                      dup.x64 sp(11)
	<div+107 @050fe3>  : 11 04                      dup.x64 sp(4)
	<div+109 @050fe5>  : 83                         mul.f64
	<div+110 @050fe6>  : 11 0b                      dup.x64 sp(11)
	<div+112 @050fe8>  : 82                         sub.f64
	<div+113 @050fe9>  : 11 02                      dup.x64 sp(2)
	<div+115 @050feb>  : 84                         div.f64
	<div+116 @050fec>  : 14 11                      set.x64 sp(17)
	<div+118 @050fee>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @050ff2>  : 03                         ret
.usages:
	lib/std/math.Complex.ci:172: referenced as `div`
	lib/std/math.Complex.ci:170: referenced as `div`
	lib/std/math.Complex.ci:163: referenced as `div`
	lib/std/math.Complex.ci:161: referenced as `div`
	lib/std/math.Complex.ci:106: referenced as `div`
	lib/std/math.Complex.ci:104: referenced as `div`
	lib/std/math.Complex.ci:83: defined as `div(a: Complex, b: Complex): Complex`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:104'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:168: referenced as `div`
	lib/std/math.Complex.ci:166: referenced as `div`
	lib/std/math.Complex.ci:104: defined as `div(a: Complex, b: float64): Complex`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/std/math.Complex.ci:106'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
	lib/std/math.Complex.ci:106: defined as `div(a: float64, b: Complex): Complex`
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'lib/std/math.Complex.ci:109'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	lib/std/math.Complex.ci:186: referenced as `abs`
	lib/std/math.Complex.ci:133: referenced as `abs`
	lib/std/math.Complex.ci:129: referenced as `abs`
	lib/std/math.Complex.ci:109: defined as `abs(a: Complex): float64`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'lib/std/math.Complex.ci:111'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	lib/std/math.Complex.ci:186: referenced as `arg`
	lib/std/math.Complex.ci:134: referenced as `arg`
	lib/std/math.Complex.ci:129: referenced as `arg`
	lib/std/math.Complex.ci:111: defined as `arg(a: Complex): float64`
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 31
.offset: <@050ff8>
.name: 'inv'
.file: 'lib/std/math.Complex.ci:114'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <@050ff8> - <@051017>)
	lib/std/math.Complex.ci:115: (11 bytes: <@050ff8> - <@051003>): d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)))
	<inv @050ff8>      : 11 01                      dup.x64 sp(1)
	<inv+2 @050ffa>    : 11 03                      dup.x64 sp(3)
	<inv+4 @050ffc>    : 83                         mul.f64
	<inv+5 @050ffd>    : 11 05                      dup.x64 sp(5)
	<inv+7 @050fff>    : 11 07                      dup.x64 sp(7)
	<inv+9 @051001>    : 83                         mul.f64
	<inv+10 @051002>   : 81                         add.f64
	lib/std/math.Complex.ci:116: (20 bytes: <@051003> - <@051017>): return void(.result := {...});
	<inv+11 @051003>   : 11 03                      dup.x64 sp(3)
	<inv+13 @051005>   : 11 02                      dup.x64 sp(2)
	<inv+15 @051007>   : 84                         div.f64
	<inv+16 @051008>   : 14 09                      set.x64 sp(9)
	lib/std/math.Complex.ci:118: (8 bytes: <@05100a> - <@051012>): void(.result.im := float64(float64(-a.im) / d));
	<inv+18 @05100a>   : 11 05                      dup.x64 sp(5)
	<inv+20 @05100c>   : 80                         neg.f64
	<inv+21 @05100d>   : 11 02                      dup.x64 sp(2)
	<inv+23 @05100f>   : 84                         div.f64
	<inv+24 @051010>   : 14 0b                      set.x64 sp(11)
	<inv+26 @051012>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @051016>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:181: referenced as `inv`
	lib/std/math.Complex.ci:179: referenced as `inv`
	lib/std/math.Complex.ci:177: referenced as `inv`
	lib/std/math.Complex.ci:175: referenced as `inv`
	lib/std/math.Complex.ci:114: defined as `inv(a: Complex): Complex`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'lib/std/math.Complex.ci:123'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
	lib/std/math.Complex.ci:123: defined as `conj(a: Complex): Complex`
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'lib/std/math.Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:172: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:170: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:168: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:166: referenced as `exp`
	lib/std/math.Complex.ci:126: defined as `exp(a: Complex): Complex`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'lib/std/math.Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
	lib/std/math.Complex.ci:129: defined as `log(a: Complex): Complex`
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 100
.offset: <@051018>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:132'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <@051018> - <@05107c>)
	lib/std/math.Complex.ci:133: (23 bytes: <@051018> - <@05102f>): r: float64 := abs(a)
	<pow @051018>      : 12 05                      dup.x128 sp(5)
	<pow+2 @05101a>    : 11 00                      dup.x64 sp(0)
	<pow+4 @05101c>    : 11 02                      dup.x64 sp(2)
	<pow+6 @05101e>    : 83                         mul.f64
	<pow+7 @05101f>    : 11 04                      dup.x64 sp(4)
	<pow+9 @051021>    : 11 06                      dup.x64 sp(6)
	<pow+11 @051023>   : 83                         mul.f64
	<pow+12 @051024>   : 81                         add.f64
	<pow+13 @051025>   : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	<pow+17 @051029>   : 14 04                      set.x64 sp(4)
	<pow+19 @05102b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:134: (16 bytes: <@05102f> - <@05103f>): t: float64 := arg(a)
	<pow+23 @05102f>   : 12 07                      dup.x128 sp(7)
	<pow+25 @051031>   : 11 00                      dup.x64 sp(0)
	<pow+27 @051033>   : 11 04                      dup.x64 sp(4)
	<pow+29 @051035>   : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @051039>   : 14 04                      set.x64 sp(4)
	<pow+35 @05103b>   : 09 f8 ff ff                inc.sp(-8)
	lib/std/math.Complex.ci:135: (15 bytes: <@05103f> - <@05104e>): u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)))
	<pow+39 @05103f>   : 11 05                      dup.x64 sp(5)
	<pow+41 @051041>   : 11 02                      dup.x64 sp(2)
	<pow+43 @051043>   : 83                         mul.f64
	<pow+44 @051044>   : 11 09                      dup.x64 sp(9)
	<pow+46 @051046>   : 11 06                      dup.x64 sp(6)
	<pow+48 @051048>   : 01 29 00 00                nfc(41) ;float64.log(x: float64): float64
	<pow+52 @05104c>   : 83                         mul.f64
	<pow+53 @05104d>   : 81                         add.f64
	lib/std/math.Complex.ci:136: (19 bytes: <@05104e> - <@051061>): v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)))
	<pow+54 @05104e>   : 11 04                      dup.x64 sp(4)
	<pow+56 @051050>   : 11 09                      dup.x64 sp(9)
	<pow+58 @051052>   : 01 2b 00 00                nfc(43) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @051056>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @051058>   : 80                         neg.f64
	<pow+65 @051059>   : 11 06                      dup.x64 sp(6)
	<pow+67 @05105b>   : 83                         mul.f64
	<pow+68 @05105c>   : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<pow+72 @051060>   : 83                         mul.f64
	lib/std/math.Complex.ci:137: (27 bytes: <@051061> - <@05107c>): return void(.result := {...});
	<pow+73 @051061>   : 11 00                      dup.x64 sp(0)
	<pow+75 @051063>   : 11 04                      dup.x64 sp(4)
	<pow+77 @051065>   : 01 27 00 00                nfc(39) ;float64.cos(x: float64): float64
	<pow+81 @051069>   : 83                         mul.f64
	<pow+82 @05106a>   : 14 13                      set.x64 sp(19)
	lib/std/math.Complex.ci:139: (11 bytes: <@05106c> - <@051077>): void(.result.im := float64(v * float64.sin(u)));
	<pow+84 @05106c>   : 11 00                      dup.x64 sp(0)
	<pow+86 @05106e>   : 11 04                      dup.x64 sp(4)
	<pow+88 @051070>   : 01 26 00 00                nfc(38) ;float64.sin(x: float64): float64
	<pow+92 @051074>   : 83                         mul.f64
	<pow+93 @051075>   : 14 15                      set.x64 sp(21)
	<pow+95 @051077>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @05107b>   : 03                         ret
.usages:
	lib/std/math.Complex.ci:143: referenced as `pow`
	lib/std/math.Complex.ci:132: defined as `pow(a: Complex, b: Complex): Complex`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'lib/std/math.Complex.ci:143'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
	lib/std/math.Complex.ci:143: defined as `pow(a: Complex, b: float64): Complex`
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'lib/std/math.Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:177: referenced as `sin`
	lib/std/math.Complex.ci:163: referenced as `sin`
	lib/std/math.Complex.ci:161: referenced as `sin`
	lib/std/math.Complex.ci:146: defined as `sin(a: Complex): Complex`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'lib/std/math.Complex.ci:148'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	lib/std/math.Complex.ci:175: referenced as `cos`
	lib/std/math.Complex.ci:163: referenced as `cos`
	lib/std/math.Complex.ci:161: referenced as `cos`
	lib/std/math.Complex.ci:148: defined as `cos(a: Complex): Complex`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'lib/std/math.Complex.ci:161'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
	lib/std/math.Complex.ci:161: defined as `tan(a: Complex): Complex`
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'lib/std/math.Complex.ci:163'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
	lib/std/math.Complex.ci:163: defined as `cot(a: Complex): Complex`
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'lib/std/math.Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:181: referenced as `sinh`
	lib/std/math.Complex.ci:166: defined as `sinh(a: Complex): Complex`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'lib/std/math.Complex.ci:168'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	lib/std/math.Complex.ci:179: referenced as `cosh`
	lib/std/math.Complex.ci:168: defined as `cosh(a: Complex): Complex`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'lib/std/math.Complex.ci:170'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:170: defined as `tanh(a: Complex): Complex`
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'lib/std/math.Complex.ci:172'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
	lib/std/math.Complex.ci:172: defined as `coth(a: Complex): Complex`
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'lib/std/math.Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
	lib/std/math.Complex.ci:175: defined as `sec(a: Complex): Complex`
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'lib/std/math.Complex.ci:177'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
	lib/std/math.Complex.ci:177: defined as `csc(a: Complex): Complex`
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'lib/std/math.Complex.ci:179'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
	lib/std/math.Complex.ci:179: defined as `sech(a: Complex): Complex`
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'lib/std/math.Complex.ci:181'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
	lib/std/math.Complex.ci:181: defined as `csch(a: Complex): Complex`
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'lib/std/math.Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
	lib/std/math.Complex.ci:184: defined as `toCartesian(x: Complex): Complex`
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'lib/std/math.Complex.ci:186'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
	lib/std/math.Complex.ci:186: defined as `toPolar(x: Complex): Complex`
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 38
.offset: <@051080>
.name: 'length'
.file: 'lib/std/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <@051080> - <@0510a6>)
	lib/std/string.ci:5: (16 bytes: <@051080> - <@051090>): if (bool((str) == null))
	<length @051080>      : 10 01                      dup.x32 sp(1)
	<length+2 @051082>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @051087>    : 57                         ceq.i32
	<length+8 @051088>    : 06 08 00 00                jz <length+16 @051090>
	lib/std/string.ci:6: (4 bytes: <@05108c> - <@051090>): return int32(.result := 0);
	<length+12 @05108c>   : 19                         load.z32
	<length+13 @05108d>   : 13 03                      set.x32 sp(3)
	<length+15 @05108f>   : 03                         ret
	lib/std/string.ci:8: (1 byte: <@051090> - <@051091>): result: int32 := 0
	<length+16 @051090>   : 19                         load.z32
	lib/std/string.ci:9: (18 bytes: <@051091> - <@0510a3>): for ( ; str[result]; int32(result := int32(result + 1)))
	<length+17 @051091>   : 04 08 00 00                jmp <length+25 @051099>
	lib/std/string.ci:9: (4 bytes: <@051095> - <@051099>): int32(result := int32(result + 1))
	<length+21 @051095>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:9: (10 bytes: <@051099> - <@0510a3>): str[result]
	<length+25 @051099>   : 10 02                      dup.x32 sp(2)
	<length+27 @05109b>   : 10 01                      dup.x32 sp(1)
	<length+29 @05109d>   : 51                         add.i32
	<length+30 @05109e>   : 20                         load.i8
	<length+31 @05109f>   : 05 f6 ff ff                jnz <length+21 @051095>
	lib/std/string.ci:11: (3 bytes: <@0510a3> - <@0510a6>): return int32(.result := result);
	<length+35 @0510a3>   : 13 03                      set.x32 sp(3)
	<length+37 @0510a5>   : 03                         ret
.usages:
	lib/std/string.ci:48: referenced as `length`
	lib/std/string.ci:47: referenced as `length`
	lib/std/string.ci:4: defined as `length(str: char[*]): int32`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@0510a8>
.name: 'indexOf'
.file: 'lib/std/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <@0510a8> - <@0510da>)
	lib/std/string.ci:16: (42 bytes: <@0510a8> - <@0510d2>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<indexOf @0510a8>      : 19                         load.z32
	<indexOf+1 @0510a9>    : 04 1b 00 00                jmp <indexOf+28 @0510c4>
	lib/std/string.ci:17: (19 bytes: <@0510ad> - <@0510c0>): if (bool(str[i] == chr))
	<indexOf+5 @0510ad>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @0510af>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @0510b1>    : 51                         add.i32
	<indexOf+10 @0510b2>   : 20                         load.i8
	<indexOf+11 @0510b3>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @0510b7>   : 20                         load.i8
	<indexOf+16 @0510b8>   : 57                         ceq.i32
	<indexOf+17 @0510b9>   : 06 07 00 00                jz <indexOf+24 @0510c0>
	lib/std/string.ci:18: (3 bytes: <@0510bd> - <@0510c0>): return int32(.result := i);
	<indexOf+21 @0510bd>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @0510bf>   : 03                         ret
	lib/std/string.ci:16: (4 bytes: <@0510c0> - <@0510c4>): int32(i := int32(i + 1))
	<indexOf+24 @0510c0>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:16: (10 bytes: <@0510c4> - <@0510ce>): str[i]
	<indexOf+28 @0510c4>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @0510c6>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @0510c8>   : 51                         add.i32
	<indexOf+33 @0510c9>   : 20                         load.i8
	<indexOf+34 @0510ca>   : 05 e3 ff ff                jnz <indexOf+5 @0510ad>
	<indexOf+38 @0510ce>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:21: (8 bytes: <@0510d2> - <@0510da>): return int32(.result := int32(-1));
	<indexOf+42 @0510d2>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @0510d7>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @0510d9>   : 03                         ret
.usages:
	lib/std/string.ci:97: referenced as `indexOf`
	lib/std/string.ci:15: defined as `indexOf(str: char[*], chr: char): int32`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 50
.offset: <@0510e0>
.name: 'lastIndexOf'
.file: 'lib/std/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <@0510e0> - <@051112>)
	lib/std/string.ci:26: (5 bytes: <@0510e0> - <@0510e5>): result: int32 := int32(-1)
	<lastIndexOf @0510e0>      : 1c ff ff ff ff             load.c32 -1
	lib/std/string.ci:27: (42 bytes: <@0510e5> - <@05110f>): for (i: int32 := 0; str[i]; int32(i := int32(i + 1)))
	<lastIndexOf+5 @0510e5>    : 19                         load.z32
	<lastIndexOf+6 @0510e6>    : 04 1b 00 00                jmp <lastIndexOf+33 @051101>
	lib/std/string.ci:28: (19 bytes: <@0510ea> - <@0510fd>): if (bool(str[i] == chr))
	<lastIndexOf+10 @0510ea>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @0510ec>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @0510ee>   : 51                         add.i32
	<lastIndexOf+15 @0510ef>   : 20                         load.i8
	<lastIndexOf+16 @0510f0>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @0510f4>   : 20                         load.i8
	<lastIndexOf+21 @0510f5>   : 57                         ceq.i32
	<lastIndexOf+22 @0510f6>   : 06 07 00 00                jz <lastIndexOf+29 @0510fd>
	lib/std/string.ci:29: (3 bytes: <@0510fa> - <@0510fd>): int32(result := i);
	<lastIndexOf+26 @0510fa>   : 16 01 00                   mov.x32 sp(1, 0)
	lib/std/string.ci:27: (4 bytes: <@0510fd> - <@051101>): int32(i := int32(i + 1))
	<lastIndexOf+29 @0510fd>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:27: (10 bytes: <@051101> - <@05110b>): str[i]
	<lastIndexOf+33 @051101>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @051103>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @051105>   : 51                         add.i32
	<lastIndexOf+38 @051106>   : 20                         load.i8
	<lastIndexOf+39 @051107>   : 05 e3 ff ff                jnz <lastIndexOf+10 @0510ea>
	<lastIndexOf+43 @05110b>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:32: (3 bytes: <@05110f> - <@051112>): return int32(.result := result);
	<lastIndexOf+47 @05110f>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @051111>   : 03                         ret
.usages:
	lib/std/string.ci:25: defined as `lastIndexOf(str: char[*], chr: char): int32`
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.offset: <@051118>
.name: 'startsWith'
.file: 'lib/std/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <@051118> - <@051161>)
	lib/std/string.ci:37: (62 bytes: <@051118> - <@051156>): for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1)))
	<startsWith @051118>      : 19                         load.z32
	<startsWith+1 @051119>    : 04 2d 00 00                jmp <startsWith+46 @051146>
	lib/std/string.ci:38: (37 bytes: <@05111d> - <@051142>): if (bool(cmp(void(str[i], with[i])) != 0))
	<startsWith+5 @05111d>    : 19                         load.z32
	<startsWith+6 @05111e>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @051120>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @051122>   : 51                         add.i32
	<startsWith+11 @051123>   : 20                         load.i8
	<startsWith+12 @051124>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @051126>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @051128>   : 51                         add.i32
	<startsWith+17 @051129>   : 20                         load.i8
	<startsWith+18 @05112a>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @05112c>   : 02                         call
	<startsWith+21 @05112d>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @051131>   : 19                         load.z32
	<startsWith+26 @051132>   : 57                         ceq.i32
	<startsWith+27 @051133>   : 05 0f 00 00                jnz <startsWith+42 @051142>
	lib/std/string.ci:39: (11 bytes: <@051137> - <@051142>): return bool(.result := false);
	<startsWith+31 @051137>   : 19                         load.z32
	<startsWith+32 @051138>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @05113c>   : 25                         store.i8
	<startsWith+37 @05113d>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @051141>   : 03                         ret
	lib/std/string.ci:37: (4 bytes: <@051142> - <@051146>): int32(i := int32(i + 1))
	<startsWith+42 @051142>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:37: (12 bytes: <@051146> - <@051152>): bool((with[i]) != 0)
	<startsWith+46 @051146>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @051148>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @05114a>   : 51                         add.i32
	<startsWith+51 @05114b>   : 20                         load.i8
	<startsWith+52 @05114c>   : 19                         load.z32
	<startsWith+53 @05114d>   : 57                         ceq.i32
	<startsWith+54 @05114e>   : 06 cf ff ff                jz <startsWith+5 @05111d>
	<startsWith+58 @051152>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:42: (11 bytes: <@051156> - <@051161>): return bool(.result := true);
	<startsWith+62 @051156>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @05115b>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @05115f>   : 25                         store.i8
	<startsWith+72 @051160>   : 03                         ret
.usages:
	lib/std/string.ci:92: referenced as `startsWith`
	lib/std/string.ci:36: defined as `startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 126
.offset: <@051168>
.name: 'endsWith'
.file: 'lib/std/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <@051168> - <@0511e6>)
	lib/std/string.ci:47: (13 bytes: <@051168> - <@051175>): withLen: int32 := length(with)
	<endsWith @051168>      : 19                         load.z32
	<endsWith+1 @051169>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @05116b>    : 1f 80 10 05 00             load.ref <@051080> ;length(str: char[*]): int32
	<endsWith+8 @051170>    : 02                         call
	<endsWith+9 @051171>    : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:48: (13 bytes: <@051175> - <@051182>): strLen: int32 := length(str)
	<endsWith+13 @051175>   : 19                         load.z32
	<endsWith+14 @051176>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @051178>   : 1f 80 10 05 00             load.ref <@051080> ;length(str: char[*]): int32
	<endsWith+21 @05117d>   : 02                         call
	<endsWith+22 @05117e>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:49: (20 bytes: <@051182> - <@051196>): if (bool(strLen < withLen))
	<endsWith+26 @051182>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @051184>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @051186>   : 58                         clt.i32
	<endsWith+31 @051187>   : 06 0f 00 00                jz <endsWith+46 @051196>
	lib/std/string.ci:50: (11 bytes: <@05118b> - <@051196>): return bool(.result := false);
	<endsWith+35 @05118b>   : 19                         load.z32
	<endsWith+36 @05118c>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @051190>   : 25                         store.i8
	<endsWith+41 @051191>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @051195>   : 03                         ret
	lib/std/string.ci:52: (65 bytes: <@051196> - <@0511d7>): for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1)))
	<endsWith+46 @051196>   : 19                         load.z32
	<endsWith+47 @051197>   : 04 33 00 00                jmp <endsWith+98 @0511ca>
	lib/std/string.ci:53: (43 bytes: <@05119b> - <@0511c6>): if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0))
	<endsWith+51 @05119b>   : 19                         load.z32
	<endsWith+52 @05119c>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @05119e>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @0511a0>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @0511a2>   : 52                         sub.i32
	<endsWith+59 @0511a3>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @0511a5>   : 51                         add.i32
	<endsWith+62 @0511a6>   : 51                         add.i32
	<endsWith+63 @0511a7>   : 20                         load.i8
	<endsWith+64 @0511a8>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @0511aa>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @0511ac>   : 51                         add.i32
	<endsWith+69 @0511ad>   : 20                         load.i8
	<endsWith+70 @0511ae>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @0511b0>   : 02                         call
	<endsWith+73 @0511b1>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @0511b5>   : 19                         load.z32
	<endsWith+78 @0511b6>   : 57                         ceq.i32
	<endsWith+79 @0511b7>   : 05 0f 00 00                jnz <endsWith+94 @0511c6>
	lib/std/string.ci:54: (11 bytes: <@0511bb> - <@0511c6>): return bool(.result := false);
	<endsWith+83 @0511bb>   : 19                         load.z32
	<endsWith+84 @0511bc>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @0511c0>   : 25                         store.i8
	<endsWith+89 @0511c1>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @0511c5>   : 03                         ret
	lib/std/string.ci:52: (4 bytes: <@0511c6> - <@0511ca>): int32(i := int32(i + 1))
	<endsWith+94 @0511c6>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:52: (9 bytes: <@0511ca> - <@0511d3>): bool(i < withLen)
	<endsWith+98 @0511ca>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @0511cc>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @0511ce>  : 58                         clt.i32
	<endsWith+103 @0511cf>  : 05 cc ff ff                jnz <endsWith+51 @05119b>
	<endsWith+107 @0511d3>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:57: (15 bytes: <@0511d7> - <@0511e6>): return bool(.result := true);
	<endsWith+111 @0511d7>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @0511dc>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @0511e0>  : 25                         store.i8
	<endsWith+121 @0511e1>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @0511e5>  : 03                         ret
.usages:
	lib/std/string.ci:93: referenced as `endsWith`
	lib/std/string.ci:46: defined as `endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@0511e8>
.name: 'compare'
.file: 'lib/std/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <@0511e8> - <@051227>)
	lib/std/string.ci:62: (1 byte: <@0511e8> - <@0511e9>): result: int32 := 0
	<compare @0511e8>      : 19                         load.z32
	lib/std/string.ci:63: (59 bytes: <@0511e9> - <@051224>): for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1)))
	<compare+1 @0511e9>    : 19                         load.z32
	<compare+2 @0511ea>    : 04 2e 00 00                jmp <compare+48 @051218>
	lib/std/string.ci:64: (22 bytes: <@0511ee> - <@051204>): int32(result := cmp(void(str[i], with[i])));
	<compare+6 @0511ee>    : 19                         load.z32
	<compare+7 @0511ef>    : 10 06                      dup.x32 sp(6)
	<compare+9 @0511f1>    : 10 02                      dup.x32 sp(2)
	<compare+11 @0511f3>   : 51                         add.i32
	<compare+12 @0511f4>   : 20                         load.i8
	<compare+13 @0511f5>   : 10 06                      dup.x32 sp(6)
	<compare+15 @0511f7>   : 10 03                      dup.x32 sp(3)
	<compare+17 @0511f9>   : 51                         add.i32
	<compare+18 @0511fa>   : 20                         load.i8
	<compare+19 @0511fb>   : 10 06                      dup.x32 sp(6)
	<compare+21 @0511fd>   : 02                         call
	<compare+22 @0511fe>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @051202>   : 13 02                      set.x32 sp(2)
	lib/std/string.ci:65: (16 bytes: <@051204> - <@051214>): if (bool((str[i]) == 0))
	<compare+28 @051204>   : 10 05                      dup.x32 sp(5)
	<compare+30 @051206>   : 10 01                      dup.x32 sp(1)
	<compare+32 @051208>   : 51                         add.i32
	<compare+33 @051209>   : 20                         load.i8
	<compare+34 @05120a>   : 19                         load.z32
	<compare+35 @05120b>   : 57                         ceq.i32
	<compare+36 @05120c>   : 06 08 00 00                jz <compare+44 @051214>
	lib/std/string.ci:66: (4 bytes: <@051210> - <@051214>): break;
	<compare+40 @051210>   : 04 10 00 00                jmp <compare+56 @051220>
	lib/std/string.ci:63: (4 bytes: <@051214> - <@051218>): int32(i := int32(i + 1))
	<compare+44 @051214>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:63: (8 bytes: <@051218> - <@051220>): bool(result == 0)
	<compare+48 @051218>   : 10 01                      dup.x32 sp(1)
	<compare+50 @05121a>   : 19                         load.z32
	<compare+51 @05121b>   : 57                         ceq.i32
	<compare+52 @05121c>   : 05 d2 ff ff                jnz <compare+6 @0511ee>
	<compare+56 @051220>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:69: (3 bytes: <@051224> - <@051227>): return int32(.result := result);
	<compare+60 @051224>   : 13 05                      set.x32 sp(5)
	<compare+62 @051226>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `compare`
	lib/std/string.ci:61: defined as `compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.offset: <@051270>
.name: 'ignCaseCmp'
.file: 'lib/std/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static const ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <@051270> - <@051294>)
	lib/std/string.ci:84: (36 bytes: <@051270> - <@051294>): return char(.result := char(ignCase(chr) - ignCase(with)));
	<ignCaseCmp @051270>      : 19                         load.z32
	<ignCaseCmp+1 @051271>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @051275>    : 20                         load.i8
	<ignCaseCmp+6 @051276>    : 1f 28 12 05 00             load.ref <@051228> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @05127b>   : 02                         call
	<ignCaseCmp+12 @05127c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @051280>   : 19                         load.z32
	<ignCaseCmp+17 @051281>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @051285>   : 20                         load.i8
	<ignCaseCmp+22 @051286>   : 1f 28 12 05 00             load.ref <@051228> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @05128b>   : 02                         call
	<ignCaseCmp+28 @05128c>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @051290>   : 52                         sub.i32
	<ignCaseCmp+33 @051291>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @051293>   : 03                         ret
.usages:
	lib/std/string.ci:73: defined as `ignCaseCmp(chr: char, with: char): int32`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.offset: <@051298>
.name: 'caseCmp'
.file: 'lib/std/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <@051298> - <@0512a6>)
	lib/std/string.ci:89: (14 bytes: <@051298> - <@0512a6>): return char(.result := char(chr - with));
	<caseCmp @051298>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @05129c>    : 20                         load.i8
	<caseCmp+5 @05129d>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @0512a1>    : 20                         load.i8
	<caseCmp+10 @0512a2>   : 52                         sub.i32
	<caseCmp+11 @0512a3>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @0512a5>   : 03                         ret
.usages:
	lib/std/string.ci:94: referenced as `caseCmp`
	lib/std/string.ci:93: referenced as `caseCmp`
	lib/std/string.ci:92: referenced as `caseCmp`
	lib/std/string.ci:88: defined as `caseCmp(chr: char, with: char): int32`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'lib/std/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:92: defined as `startsWith(str: char[*], with: char[*]): bool`
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'lib/std/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:93: defined as `endsWith(str: char[*], with: char[*]): bool`
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'lib/std/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param with: char[*] (size: 4, offs: <+8>, cast: ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
	lib/std/string.ci:94: defined as `compare(str: char[*], with: char[*]): int32`
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'lib/std/string.ci:97'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	lib/std/string.ci:172: referenced as `contains`
	lib/std/string.ci:97: defined as `contains(str: char[*], chr: char): bool`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@022ac8>
.name: 'FormatFlags'
.file: 'lib/std/string.ci:111'
.field radix: int32 (size: 4, offs: <+0>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+4>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+8>, cast: const variable(i32))
.field precision: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	lib/std/string.ci:223: referenced as `FormatFlags`
	lib/std/string.ci:212: referenced as `FormatFlags`
	lib/std/string.ci:207: referenced as `FormatFlags`
	lib/std/string.ci:143: referenced as `FormatFlags`
	lib/std/string.ci:111: defined as `FormatFlags`
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'radix'
.file: 'lib/std/string.ci:113'
.owner: FormatFlags
.doc: 'radix to be used at the conversion'
.value: 10
.usages:
	lib/std/string.ci:150: referenced as `radix`
	lib/std/string.ci:113: defined as `radix`
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+4>
.name: 'padChr'
.file: 'lib/std/string.ci:116'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	lib/std/string.ci:164: referenced as `padChr`
	lib/std/string.ci:116: defined as `padChr`
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'padLen'
.file: 'lib/std/string.ci:119'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	lib/std/string.ci:162: referenced as `padLen`
	lib/std/string.ci:119: defined as `padLen`
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'precision'
.file: 'lib/std/string.ci:122'
.owner: FormatFlags
.doc: 'precision'
.value: 0
.usages:
	lib/std/string.ci:122: defined as `precision`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 84
.offset: <@0512a8>
.name: 'append'
.file: 'lib/std/string.ci:126'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <@0512a8> - <@0512fc>)
	lib/std/string.ci:127: (56 bytes: <@0512a8> - <@0512e0>): for (i: int32 := 0; value[i]; int32(i := int32(i + 1)))
	<append @0512a8>      : 19                         load.z32
	<append+1 @0512a9>    : 04 29 00 00                jmp <append+42 @0512d2>
	lib/std/string.ci:128: (13 bytes: <@0512ad> - <@0512ba>): if (bool(pos >= (output.length)))
	<append+5 @0512ad>    : 10 03                      dup.x32 sp(3)
	<append+7 @0512af>    : 10 06                      dup.x32 sp(6)
	<append+9 @0512b1>    : 58                         clt.i32
	<append+10 @0512b2>   : 05 08 00 00                jnz <append+18 @0512ba>
	lib/std/string.ci:129: (4 bytes: <@0512b6> - <@0512ba>): break;
	<append+14 @0512b6>   : 04 26 00 00                jmp <append+52 @0512dc>
	lib/std/string.ci:131: (12 bytes: <@0512ba> - <@0512c6>): char(output[pos] := value[i]);
	<append+18 @0512ba>   : 10 02                      dup.x32 sp(2)
	<append+20 @0512bc>   : 10 01                      dup.x32 sp(1)
	<append+22 @0512be>   : 51                         add.i32
	<append+23 @0512bf>   : 20                         load.i8
	<append+24 @0512c0>   : 10 05                      dup.x32 sp(5)
	<append+26 @0512c2>   : 10 05                      dup.x32 sp(5)
	<append+28 @0512c4>   : 51                         add.i32
	<append+29 @0512c5>   : 25                         store.i8
	lib/std/string.ci:132: (8 bytes: <@0512c6> - <@0512ce>): int32(pos := int32(pos + 1));
	<append+30 @0512c6>   : 10 03                      dup.x32 sp(3)
	<append+32 @0512c8>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @0512cc>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:127: (4 bytes: <@0512ce> - <@0512d2>): int32(i := int32(i + 1))
	<append+38 @0512ce>   : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:127: (10 bytes: <@0512d2> - <@0512dc>): value[i]
	<append+42 @0512d2>   : 10 02                      dup.x32 sp(2)
	<append+44 @0512d4>   : 10 01                      dup.x32 sp(1)
	<append+46 @0512d6>   : 51                         add.i32
	<append+47 @0512d7>   : 20                         load.i8
	<append+48 @0512d8>   : 05 d5 ff ff                jnz <append+5 @0512ad>
	<append+52 @0512dc>   : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:135: (17 bytes: <@0512e0> - <@0512f1>): if (bool(pos >= (output.length)))
	<append+56 @0512e0>   : 10 02                      dup.x32 sp(2)
	<append+58 @0512e2>   : 10 05                      dup.x32 sp(5)
	<append+60 @0512e4>   : 58                         clt.i32
	<append+61 @0512e5>   : 05 0c 00 00                jnz <append+73 @0512f1>
	lib/std/string.ci:136: (8 bytes: <@0512e9> - <@0512f1>): int32(pos := (uint32(output.length - (1))));
	<append+65 @0512e9>   : 10 04                      dup.x32 sp(4)
	<append+67 @0512eb>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @0512ef>   : 13 03                      set.x32 sp(3)
	lib/std/string.ci:138: (7 bytes: <@0512f1> - <@0512f8>): char(output[pos] := (0));
	<append+73 @0512f1>   : 19                         load.z32
	<append+74 @0512f2>   : 10 04                      dup.x32 sp(4)
	<append+76 @0512f4>   : 10 04                      dup.x32 sp(4)
	<append+78 @0512f6>   : 51                         add.i32
	<append+79 @0512f7>   : 25                         store.i8
	lib/std/string.ci:139: (4 bytes: <@0512f8> - <@0512fc>): return int32(.result := pos);
	<append+80 @0512f8>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @0512fb>   : 03                         ret
.usages:
	lib/std/string.ci:126: defined as `append(output: char[], pos: int32, value: char[*]): int32`
}
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 657
.offset: <@051310>
.name: 'append'
.file: 'lib/std/string.ci:143'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+24>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+28>, cast: variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (657 bytes: <@051310> - <@0515a1>)
	lib/std/string.ci:147: (1 byte: <@051310> - <@051311>): len: int32 := 0
	<append @051310>      : 19                         load.z32
	lib/std/string.ci:148: (4 bytes: <@051311> - <@051315>): digits: char[80]
	<append+1 @051311>    : 09 50 00 00                inc.sp(+80)
	lib/std/string.ci:150: (3 bytes: <@051315> - <@051318>): radix: int32 := format.radix
	<append+5 @051315>    : 10 16                      dup.x32 sp(22)
	<append+7 @051317>    : 22                         load.i32
	lib/std/string.ci:151: (54 bytes: <@051318> - <@05134e>): assert(void(void(bool(radix > 1), "radix is too small"), radix));
	<append+8 @051318>    : 10 00                      dup.x32 sp(0)
	<append+10 @05131a>   : 1c 01 00 00 00             load.c32 1
	<append+15 @05131f>   : 59                         cgt.i32
	<append+16 @051320>   : 06 08 00 00                jz <append+24 @051328>
	<append+20 @051324>   : 04 2a 00 00                jmp <append+62 @05134e>
	<append+24 @051328>   : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+29 @05132d>   : 1c 97 00 00 00             load.c32 151
	<append+34 @051332>   : 1c fe ff ff ff             load.c32 -2
	<append+39 @051337>   : 1c 80 00 00 00             load.c32 128
	<append+44 @05133c>   : 1f 22 f6 01 00             load.ref <@01f622> ;"radix is too small"
	<append+49 @051341>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+54 @051346>   : 0a 18 00 00                load.sp(+24)
	<append+58 @05134a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:152: (53 bytes: <@05134e> - <@051383>): assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	<append+62 @05134e>   : 10 00                      dup.x32 sp(0)
	<append+64 @051350>   : 2a 0c 13 05                load.m32 <@05130c> ;append.radixDigits+4
	<append+68 @051354>   : 58                         clt.i32
	<append+69 @051355>   : 06 08 00 00                jz <append+77 @05135d>
	<append+73 @051359>   : 04 2a 00 00                jmp <append+115 @051383>
	<append+77 @05135d>   : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+82 @051362>   : 1c 98 00 00 00             load.c32 152
	<append+87 @051367>   : 1c fe ff ff ff             load.c32 -2
	<append+92 @05136c>   : 1c 80 00 00 00             load.c32 128
	<append+97 @051371>   : 1f 35 f6 01 00             load.ref <@01f635> ;"radix is too big"
	<append+102 @051376>  : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<append+107 @05137b>  : 0a 18 00 00                load.sp(+24)
	<append+111 @05137f>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:155: (46 bytes: <@051383> - <@0513b1>): for ( ; bool(value > (0)); uint32(value := uint32(value / (radix))))
	<append+115 @051383>  : 04 26 00 00                jmp <append+153 @0513a9>
	lib/std/string.ci:156: (27 bytes: <@051387> - <@0513a2>): char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
	<append+119 @051387>  : 2a 08 13 05                load.m32 <@051308> ;append.radixDigits
	<append+123 @05138b>  : 10 19                      dup.x32 sp(25)
	<append+125 @05138d>  : 10 02                      dup.x32 sp(2)
	<append+127 @05138f>  : 35                         mod.u32
	<append+128 @051390>  : 51                         add.i32
	<append+129 @051391>  : 20                         load.i8
	<append+130 @051392>  : 0a 08 00 00                load.sp(+8)
	<append+134 @051396>  : 10 17                      dup.x32 sp(23)
	<append+136 @051398>  : 0c 01 00 00                inc.i32(+1)
	<append+140 @05139c>  : 10 00                      dup.x32 sp(0)
	<append+142 @05139e>  : 13 19                      set.x32 sp(25)
	<append+144 @0513a0>  : 51                         add.i32
	<append+145 @0513a1>  : 25                         store.i8
	lib/std/string.ci:155: (7 bytes: <@0513a2> - <@0513a9>): uint32(value := uint32(value / (radix)))
	<append+146 @0513a2>  : 10 18                      dup.x32 sp(24)
	<append+148 @0513a4>  : 10 01                      dup.x32 sp(1)
	<append+150 @0513a6>  : 34                         div.u32
	<append+151 @0513a7>  : 13 19                      set.x32 sp(25)
	lib/std/string.ci:155: (8 bytes: <@0513a9> - <@0513b1>): bool(value > (0))
	<append+153 @0513a9>  : 10 18                      dup.x32 sp(24)
	<append+155 @0513ab>  : 19                         load.z32
	<append+156 @0513ac>  : 39                         cgt.u32
	<append+157 @0513ad>  : 05 da ff ff                jnz <append+119 @051387>
	lib/std/string.ci:158: (29 bytes: <@0513b1> - <@0513ce>): if (bool(len == 0))
	<append+161 @0513b1>  : 10 15                      dup.x32 sp(21)
	<append+163 @0513b3>  : 19                         load.z32
	<append+164 @0513b4>  : 57                         ceq.i32
	<append+165 @0513b5>  : 06 19 00 00                jz <append+190 @0513ce>
	lib/std/string.ci:159: (21 bytes: <@0513b9> - <@0513ce>): char(digits[int32(len := int32(len + 1))] := '0');
	<append+169 @0513b9>  : 1c 30 00 00 00             load.c32 48
	<append+174 @0513be>  : 0a 08 00 00                load.sp(+8)
	<append+178 @0513c2>  : 10 17                      dup.x32 sp(23)
	<append+180 @0513c4>  : 0c 01 00 00                inc.i32(+1)
	<append+184 @0513c8>  : 10 00                      dup.x32 sp(0)
	<append+186 @0513ca>  : 13 19                      set.x32 sp(25)
	<append+188 @0513cc>  : 51                         add.i32
	<append+189 @0513cd>  : 25                         store.i8
	lib/std/string.ci:162: (10 bytes: <@0513ce> - <@0513d8>): maxLen: int32 := int32(format.padLen - len)
	<append+190 @0513ce>  : 10 17                      dup.x32 sp(23)
	<append+192 @0513d0>  : 0c 08 00 00                inc.i32(+8)
	<append+196 @0513d4>  : 22                         load.i32
	<append+197 @0513d5>  : 10 16                      dup.x32 sp(22)
	<append+199 @0513d7>  : 52                         sub.i32
	lib/std/string.ci:164: (7 bytes: <@0513d8> - <@0513df>): padChr: char := format.padChr
	<append+200 @0513d8>  : 10 18                      dup.x32 sp(24)
	<append+202 @0513da>  : 0c 04 00 00                inc.i32(+4)
	<append+206 @0513de>  : 20                         load.i8
	lib/std/string.ci:165: (21 bytes: <@0513df> - <@0513f4>): if (bool(padChr == ''))
	<append+207 @0513df>  : 0a 00 00 00                load.sp(+0)
	<append+211 @0513e3>  : 20                         load.i8
	<append+212 @0513e4>  : 19                         load.z32
	<append+213 @0513e5>  : 57                         ceq.i32
	<append+214 @0513e6>  : 06 0e 00 00                jz <append+228 @0513f4>
	lib/std/string.ci:166: (10 bytes: <@0513ea> - <@0513f4>): char(padChr := ' ');
	<append+218 @0513ea>  : 1c 20 00 00 00             load.c32 32
	<append+223 @0513ef>  : 0a 04 00 00                load.sp(+4)
	<append+227 @0513f3>  : 25                         store.i8
	lib/std/string.ci:170: (207 bytes: <@0513f4> - <@0514c3>): if (bool((sign) != 0))
	<append+228 @0513f4>  : 0a 6c 00 00                load.sp(+108)
	<append+232 @0513f8>  : 20                         load.i8
	<append+233 @0513f9>  : 19                         load.z32
	<append+234 @0513fa>  : 57                         ceq.i32
	<append+235 @0513fb>  : 05 c8 00 00                jnz <append+435 @0514c3>
	lib/std/string.ci:171: (8 bytes: <@0513ff> - <@051407>): int32(maxLen := int32(maxLen - 1));
	<append+239 @0513ff>  : 10 01                      dup.x32 sp(1)
	<append+241 @051401>  : 0c ff ff ff                inc.i32(-1)
	<append+245 @051405>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:172: (117 bytes: <@051407> - <@05147c>): if (contains(void(whiteSpace, padChr)))
	<append+247 @051407>  : 19                         load.z32
	<append+248 @051408>  : 2a 00 13 05                load.m32 <@051300> ;append.whiteSpace
	<append+252 @05140c>  : 0a 08 00 00                load.sp(+8)
	<append+256 @051410>  : 20                         load.i8
	<append+257 @051411>  : 1f a8 10 05 00             load.ref <@0510a8> ;indexOf(str: char[*], chr: char): int32
	<append+262 @051416>  : 02                         call
	<append+263 @051417>  : 09 f8 ff ff                inc.sp(-8)
	<append+267 @05141b>  : 19                         load.z32
	<append+268 @05141c>  : 58                         clt.i32
	<append+269 @05141d>  : 05 5f 00 00                jnz <append+364 @05147c>
	lib/std/string.ci:174: (91 bytes: <@051421> - <@05147c>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+273 @051421>  : 04 53 00 00                jmp <append+356 @051474>
	lib/std/string.ci:175: (52 bytes: <@051425> - <@051459>): assert(bool(pos < (output.length)));
	<append+277 @051425>  : 10 1c                      dup.x32 sp(28)
	<append+279 @051427>  : 10 1f                      dup.x32 sp(31)
	<append+281 @051429>  : 58                         clt.i32
	<append+282 @05142a>  : 06 08 00 00                jz <append+290 @051432>
	<append+286 @05142e>  : 04 2b 00 00                jmp <append+329 @051459>
	<append+290 @051432>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+295 @051437>  : 1c af 00 00 00             load.c32 175
	<append+300 @05143c>  : 1c fe ff ff ff             load.c32 -2
	<append+305 @051441>  : 1c 80 00 00 00             load.c32 128
	<append+310 @051446>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+315 @05144b>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+320 @051450>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+325 @051455>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:176: (11 bytes: <@051459> - <@051464>): char(output[pos] := padChr);
	<append+329 @051459>  : 0a 00 00 00                load.sp(+0)
	<append+333 @05145d>  : 20                         load.i8
	<append+334 @05145e>  : 10 1e                      dup.x32 sp(30)
	<append+336 @051460>  : 10 1e                      dup.x32 sp(30)
	<append+338 @051462>  : 51                         add.i32
	<append+339 @051463>  : 25                         store.i8
	lib/std/string.ci:177: (8 bytes: <@051464> - <@05146c>): int32(pos := int32(pos + 1));
	<append+340 @051464>  : 10 1c                      dup.x32 sp(28)
	<append+342 @051466>  : 0c 01 00 00                inc.i32(+1)
	<append+346 @05146a>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:174: (8 bytes: <@05146c> - <@051474>): int32(maxLen := int32(maxLen - 1))
	<append+348 @05146c>  : 10 01                      dup.x32 sp(1)
	<append+350 @05146e>  : 0c ff ff ff                inc.i32(-1)
	<append+354 @051472>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:174: (8 bytes: <@051474> - <@05147c>): bool(maxLen > 0)
	<append+356 @051474>  : 10 01                      dup.x32 sp(1)
	<append+358 @051476>  : 19                         load.z32
	<append+359 @051477>  : 59                         cgt.i32
	<append+360 @051478>  : 05 ad ff ff                jnz <append+277 @051425>
	lib/std/string.ci:180: (52 bytes: <@05147c> - <@0514b0>): assert(bool(pos < (output.length)));
	<append+364 @05147c>  : 10 1c                      dup.x32 sp(28)
	<append+366 @05147e>  : 10 1f                      dup.x32 sp(31)
	<append+368 @051480>  : 58                         clt.i32
	<append+369 @051481>  : 06 08 00 00                jz <append+377 @051489>
	<append+373 @051485>  : 04 2b 00 00                jmp <append+416 @0514b0>
	<append+377 @051489>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+382 @05148e>  : 1c b4 00 00 00             load.c32 180
	<append+387 @051493>  : 1c fe ff ff ff             load.c32 -2
	<append+392 @051498>  : 1c 80 00 00 00             load.c32 128
	<append+397 @05149d>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+402 @0514a2>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+407 @0514a7>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+412 @0514ac>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:181: (11 bytes: <@0514b0> - <@0514bb>): char(output[pos] := sign);
	<append+416 @0514b0>  : 0a 6c 00 00                load.sp(+108)
	<append+420 @0514b4>  : 20                         load.i8
	<append+421 @0514b5>  : 10 1e                      dup.x32 sp(30)
	<append+423 @0514b7>  : 10 1e                      dup.x32 sp(30)
	<append+425 @0514b9>  : 51                         add.i32
	<append+426 @0514ba>  : 25                         store.i8
	lib/std/string.ci:182: (8 bytes: <@0514bb> - <@0514c3>): int32(pos := int32(pos + 1));
	<append+427 @0514bb>  : 10 1c                      dup.x32 sp(28)
	<append+429 @0514bd>  : 0c 01 00 00                inc.i32(+1)
	<append+433 @0514c1>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (91 bytes: <@0514c3> - <@05151e>): for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1)))
	<append+435 @0514c3>  : 04 53 00 00                jmp <append+518 @051516>
	lib/std/string.ci:187: (52 bytes: <@0514c7> - <@0514fb>): assert(bool(pos < (output.length)));
	<append+439 @0514c7>  : 10 1c                      dup.x32 sp(28)
	<append+441 @0514c9>  : 10 1f                      dup.x32 sp(31)
	<append+443 @0514cb>  : 58                         clt.i32
	<append+444 @0514cc>  : 06 08 00 00                jz <append+452 @0514d4>
	<append+448 @0514d0>  : 04 2b 00 00                jmp <append+491 @0514fb>
	<append+452 @0514d4>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+457 @0514d9>  : 1c bb 00 00 00             load.c32 187
	<append+462 @0514de>  : 1c fe ff ff ff             load.c32 -2
	<append+467 @0514e3>  : 1c 80 00 00 00             load.c32 128
	<append+472 @0514e8>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+477 @0514ed>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+482 @0514f2>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+487 @0514f7>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:188: (11 bytes: <@0514fb> - <@051506>): char(output[pos] := padChr);
	<append+491 @0514fb>  : 0a 00 00 00                load.sp(+0)
	<append+495 @0514ff>  : 20                         load.i8
	<append+496 @051500>  : 10 1e                      dup.x32 sp(30)
	<append+498 @051502>  : 10 1e                      dup.x32 sp(30)
	<append+500 @051504>  : 51                         add.i32
	<append+501 @051505>  : 25                         store.i8
	lib/std/string.ci:189: (8 bytes: <@051506> - <@05150e>): int32(pos := int32(pos + 1));
	<append+502 @051506>  : 10 1c                      dup.x32 sp(28)
	<append+504 @051508>  : 0c 01 00 00                inc.i32(+1)
	<append+508 @05150c>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:186: (8 bytes: <@05150e> - <@051516>): int32(maxLen := int32(maxLen - 1))
	<append+510 @05150e>  : 10 01                      dup.x32 sp(1)
	<append+512 @051510>  : 0c ff ff ff                inc.i32(-1)
	<append+516 @051514>  : 13 02                      set.x32 sp(2)
	lib/std/string.ci:186: (8 bytes: <@051516> - <@05151e>): bool(maxLen > 0)
	<append+518 @051516>  : 10 01                      dup.x32 sp(1)
	<append+520 @051518>  : 19                         load.z32
	<append+521 @051519>  : 59                         cgt.i32
	<append+522 @05151a>  : 05 ad ff ff                jnz <append+439 @0514c7>
	lib/std/string.ci:193: (99 bytes: <@05151e> - <@051581>): for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1)))
	<append+526 @05151e>  : 19                         load.z32
	<append+527 @05151f>  : 04 55 00 00                jmp <append+612 @051574>
	lib/std/string.ci:194: (52 bytes: <@051523> - <@051557>): assert(bool(i < (output.length)));
	<append+531 @051523>  : 10 00                      dup.x32 sp(0)
	<append+533 @051525>  : 10 20                      dup.x32 sp(32)
	<append+535 @051527>  : 58                         clt.i32
	<append+536 @051528>  : 06 08 00 00                jz <append+544 @051530>
	<append+540 @05152c>  : 04 2b 00 00                jmp <append+583 @051557>
	<append+544 @051530>  : 1f 90 f2 01 00             load.ref <@01f290> ;"lib/std/string.ci"
	<append+549 @051535>  : 1c c2 00 00 00             load.c32 194
	<append+554 @05153a>  : 1c fe ff ff ff             load.c32 -2
	<append+559 @05153f>  : 1c 80 00 00 00             load.c32 128
	<append+564 @051544>  : 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<append+569 @051549>  : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<append+574 @05154e>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+579 @051553>  : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/std/string.ci:195: (17 bytes: <@051557> - <@051568>): char(output[pos] := digits[int32(len - i)]);
	<append+583 @051557>  : 0a 10 00 00                load.sp(+16)
	<append+587 @05155b>  : 10 19                      dup.x32 sp(25)
	<append+589 @05155d>  : 10 02                      dup.x32 sp(2)
	<append+591 @05155f>  : 52                         sub.i32
	<append+592 @051560>  : 51                         add.i32
	<append+593 @051561>  : 20                         load.i8
	<append+594 @051562>  : 10 1f                      dup.x32 sp(31)
	<append+596 @051564>  : 10 1f                      dup.x32 sp(31)
	<append+598 @051566>  : 51                         add.i32
	<append+599 @051567>  : 25                         store.i8
	lib/std/string.ci:196: (8 bytes: <@051568> - <@051570>): int32(pos := int32(pos + 1));
	<append+600 @051568>  : 10 1d                      dup.x32 sp(29)
	<append+602 @05156a>  : 0c 01 00 00                inc.i32(+1)
	<append+606 @05156e>  : 13 1e                      set.x32 sp(30)
	lib/std/string.ci:193: (4 bytes: <@051570> - <@051574>): int32(i := int32(i + 1))
	<append+608 @051570>  : 0c 01 00 00                inc.i32(+1)
	lib/std/string.ci:193: (9 bytes: <@051574> - <@05157d>): bool(i < len)
	<append+612 @051574>  : 10 00                      dup.x32 sp(0)
	<append+614 @051576>  : 10 19                      dup.x32 sp(25)
	<append+616 @051578>  : 58                         clt.i32
	<append+617 @051579>  : 05 aa ff ff                jnz <append+531 @051523>
	<append+621 @05157d>  : 09 fc ff ff                inc.sp(-4)
	lib/std/string.ci:199: (17 bytes: <@051581> - <@051592>): if (bool(pos >= (output.length)))
	<append+625 @051581>  : 10 1c                      dup.x32 sp(28)
	<append+627 @051583>  : 10 1f                      dup.x32 sp(31)
	<append+629 @051585>  : 58                         clt.i32
	<append+630 @051586>  : 05 0c 00 00                jnz <append+642 @051592>
	lib/std/string.ci:200: (8 bytes: <@05158a> - <@051592>): int32(pos := (uint32(output.length - (1))));
	<append+634 @05158a>  : 10 1e                      dup.x32 sp(30)
	<append+636 @05158c>  : 0c ff ff ff                inc.i32(-1)
	<append+640 @051590>  : 13 1d                      set.x32 sp(29)
	lib/std/string.ci:202: (7 bytes: <@051592> - <@051599>): char(output[pos] := (0));
	<append+642 @051592>  : 19                         load.z32
	<append+643 @051593>  : 10 1e                      dup.x32 sp(30)
	<append+645 @051595>  : 10 1e                      dup.x32 sp(30)
	<append+647 @051597>  : 51                         add.i32
	<append+648 @051598>  : 25                         store.i8
	lib/std/string.ci:203: (8 bytes: <@051599> - <@0515a1>): return int32(.result := pos);
	<append+649 @051599>  : 16 1f 1c                   mov.x32 sp(31, 28)
	<append+652 @05159c>  : 09 a0 ff ff                inc.sp(-96)
	<append+656 @0515a0>  : 03                         ret
.usages:
	lib/std/string.ci:218: referenced as `append`
	lib/std/string.ci:208: referenced as `append`
	lib/std/string.ci:143: defined as `append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 23
.offset: <@0515a8>
.name: 'append'
.file: 'lib/std/string.ci:207'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
}
.instructions: (23 bytes: <@0515a8> - <@0515bf>)
	lib/std/string.ci:208: (23 bytes: <@0515a8> - <@0515bf>): return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
	<append @0515a8>      : 19                         load.z32
	<append+1 @0515a9>    : 11 05                      dup.x64 sp(5)
	<append+3 @0515ab>    : 10 06                      dup.x32 sp(6)
	<append+5 @0515ad>    : 19                         load.z32
	<append+6 @0515ae>    : 10 07                      dup.x32 sp(7)
	<append+8 @0515b0>    : 10 07                      dup.x32 sp(7)
	<append+10 @0515b2>   : 1f 10 13 05 00             load.ref <@051310> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+15 @0515b7>   : 02                         call
	<append+16 @0515b8>   : 09 e8 ff ff                inc.sp(-24)
	<append+20 @0515bc>   : 13 07                      set.x32 sp(7)
	<append+22 @0515be>   : 03                         ret
.usages:
	lib/std/string.ci:224: referenced as `append`
	lib/std/string.ci:207: defined as `append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@0515c0>
.name: 'append'
.file: 'lib/std/string.ci:212'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+24>, cast: variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	sign: int32 := 0;
	if (bool(value < 0)) {
		int32(sign := ('-'));
		int32(value := int32(-value));
	}
	return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
}
.instructions: (49 bytes: <@0515c0> - <@0515f1>)
	lib/std/string.ci:213: (1 byte: <@0515c0> - <@0515c1>): sign: int32 := 0
	<append @0515c0>      : 19                         load.z32
	lib/std/string.ci:214: (20 bytes: <@0515c1> - <@0515d5>): if (bool(value < 0))
	<append+1 @0515c1>    : 10 03                      dup.x32 sp(3)
	<append+3 @0515c3>    : 19                         load.z32
	<append+4 @0515c4>    : 58                         clt.i32
	<append+5 @0515c5>    : 06 10 00 00                jz <append+21 @0515d5>
	lib/std/string.ci:215: (7 bytes: <@0515c9> - <@0515d0>): int32(sign := ('-'));
	<append+9 @0515c9>    : 1c 2d 00 00 00             load.c32 45
	<append+14 @0515ce>   : 13 01                      set.x32 sp(1)
	lib/std/string.ci:216: (5 bytes: <@0515d0> - <@0515d5>): int32(value := int32(-value));
	<append+16 @0515d0>   : 10 03                      dup.x32 sp(3)
	<append+18 @0515d2>   : 50                         neg.i32
	<append+19 @0515d3>   : 13 04                      set.x32 sp(4)
	lib/std/string.ci:218: (28 bytes: <@0515d5> - <@0515f1>): return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
	<append+21 @0515d5>   : 19                         load.z32
	<append+22 @0515d6>   : 11 06                      dup.x64 sp(6)
	<append+24 @0515d8>   : 10 07                      dup.x32 sp(7)
	<append+26 @0515da>   : 10 04                      dup.x32 sp(4)
	<append+28 @0515dc>   : 10 08                      dup.x32 sp(8)
	<append+30 @0515de>   : 10 08                      dup.x32 sp(8)
	<append+32 @0515e0>   : 1f 10 13 05 00             load.ref <@051310> ;append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
	<append+37 @0515e5>   : 02                         call
	<append+38 @0515e6>   : 09 e8 ff ff                inc.sp(-24)
	<append+42 @0515ea>   : 13 08                      set.x32 sp(8)
	<append+44 @0515ec>   : 09 fc ff ff                inc.sp(-4)
	<append+48 @0515f0>   : 03                         ret
.usages:
	lib/std/string.ci:212: defined as `append(output: char[], pos: int32, value: int32, format: FormatFlags): int32`
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.offset: <@051608>
.name: 'append'
.file: 'lib/std/string.ci:222'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.radix := 10);
		void(format.padChr := (0));
		void(format.padLen := 0);
		void(format.precision := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (25 bytes: <@051608> - <@051621>)
	lib/std/string.ci:224: (25 bytes: <@051608> - <@051621>): return int32(.result := append(void(void(void(output, pos), value), format)));
	<append @051608>      : 19                         load.z32
	<append+1 @051609>    : 11 04                      dup.x64 sp(4)
	<append+3 @05160b>    : 10 05                      dup.x32 sp(5)
	<append+5 @05160d>    : 10 05                      dup.x32 sp(5)
	<append+7 @05160f>    : 1f f8 15 05 00             load.ref <@0515f8> ;append.format
	<append+12 @051614>   : 1f a8 15 05 00             load.ref <@0515a8> ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+17 @051619>   : 02                         call
	<append+18 @05161a>   : 09 ec ff ff                inc.sp(-20)
	<append+22 @05161e>   : 13 06                      set.x32 sp(6)
	<append+24 @051620>   : 03                         ret
.usages:
	lib/std/string.ci:222: defined as `append(output: char[], pos: int32, value: uint32): int32`
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@024c58>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:4'
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 2d vector (2x float64)'
.usages:
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:27: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:24: referenced as `vec2d`
	lib/vec/vec2d.ci:16: referenced as `vec2d`
	lib/vec/vec2d.ci:4: defined as `vec2d`
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec2d.ci:6'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec2d.ci:6: defined as `data`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec2d.ci:29'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
	lib/vec/vec2d.ci:29: defined as `<?>`
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:27: referenced as `x`
	lib/vec/vec2d.ci:18: referenced as `x`
	lib/vec/vec2d.ci:9: defined as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:27: referenced as `y`
	lib/vec/vec2d.ci:19: referenced as `y`
	lib/vec/vec2d.ci:11: defined as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec2d.ci:9'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
.usages:
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec2d.ci:11'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static const function
.base: `function`
.size: 7
.offset: <@051628>
.name: 'vec2d'
.file: 'lib/vec/vec2d.ci:16'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <@051628> - <@05162f>)
	lib/vec/vec2d.ci:17: (7 bytes: <@051628> - <@05162f>): return void(.result := {...});
	<vec2d @051628>      : 17 05 03                   mov.x64 sp(5, 3)
	lib/vec/vec2d.ci:19: (3 bytes: <@05162b> - <@05162e>): void(.result.y := y);
	<vec2d+3 @05162b>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @05162e>    : 03                         ret
.usages:
	lib/vec/vec2d.ci:16: defined as `vec2d(x: float64, y: float64): vec2d`
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec2d.ci:24'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	lib/vec/vec2d.ci:24: defined as `sub(a: vec2d, b: vec2d): vec2d`
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'lib/vec/vec2d.ci:27'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
	lib/vec/vec2d.ci:27: defined as `dot(a: vec2d, b: vec2d): float64`
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@025c10>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:4'
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4d vector (4x float32)'
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:40: referenced as `vec4f`
	lib/vec/mat4f.ci:22: referenced as `vec4f`
	lib/vec/mat4f.ci:20: referenced as `vec4f`
	lib/vec/mat4f.ci:18: referenced as `vec4f`
	lib/vec/mat4f.ci:16: referenced as `vec4f`
	lib/vec/mat4f.ci:12: referenced as `vec4f`
	lib/vec/vec4f.ci:103: referenced as `vec4f`
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:98: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:92: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:88: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:84: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:80: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:78: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:75: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:73: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:71: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:69: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:67: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:28: referenced as `vec4f`
	lib/vec/vec4f.ci:4: defined as `vec4f`
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'lib/vec/vec4f.ci:6'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	lib/vec/vec4f.ci:6: defined as `data`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/vec4f.ci:105'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
	lib/vec/vec4f.ci:105: defined as `<?>`
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:35: referenced as `x`
	lib/vec/mat4f.ci:34: referenced as `x`
	lib/vec/mat4f.ci:33: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/vec4f.ci:103: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:95: referenced as `x`
	lib/vec/vec4f.ci:34: referenced as `x`
	lib/vec/vec4f.ci:29: referenced as `x`
	lib/vec/vec4f.ci:9: defined as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:35: referenced as `y`
	lib/vec/mat4f.ci:34: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:32: referenced as `y`
	lib/vec/vec4f.ci:103: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:95: referenced as `y`
	lib/vec/vec4f.ci:34: referenced as `y`
	lib/vec/vec4f.ci:29: referenced as `y`
	lib/vec/vec4f.ci:11: defined as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:35: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:33: referenced as `z`
	lib/vec/mat4f.ci:32: referenced as `z`
	lib/vec/vec4f.ci:103: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:95: referenced as `z`
	lib/vec/vec4f.ci:34: referenced as `z`
	lib/vec/vec4f.ci:29: referenced as `z`
	lib/vec/vec4f.ci:13: defined as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:34: referenced as `w`
	lib/vec/mat4f.ci:33: referenced as `w`
	lib/vec/mat4f.ci:32: referenced as `w`
	lib/vec/vec4f.ci:103: referenced as `w`
	lib/vec/vec4f.ci:29: referenced as `w`
	lib/vec/vec4f.ci:15: defined as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/vec4f.ci:9'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
.usages:
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/vec4f.ci:11'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
.usages:
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/vec4f.ci:13'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
.usages:
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/vec4f.ci:15'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@051630>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:28'
.param .result: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param x: float32 (size: 4, offs: <+20>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+24>, cast: variable(f32))
.param z: float32 (size: 4, offs: <+28>, cast: variable(f32))
.param w: float32 (size: 4, offs: <+32>, cast: variable(f32))
.doc: 'Initialize with given x, y, z, w components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (13 bytes: <@051630> - <@05163d>)
	lib/vec/vec4f.ci:29: (13 bytes: <@051630> - <@05163d>): return void(.result := {...});
	<vec4f @051630>      : 16 05 04                   mov.x32 sp(5, 4)
	lib/vec/vec4f.ci:29: (3 bytes: <@051633> - <@051636>): void(.result.y := y);
	<vec4f+3 @051633>    : 16 06 03                   mov.x32 sp(6, 3)
	lib/vec/vec4f.ci:29: (3 bytes: <@051636> - <@051639>): void(.result.z := z);
	<vec4f+6 @051636>    : 16 07 02                   mov.x32 sp(7, 2)
	lib/vec/vec4f.ci:29: (3 bytes: <@051639> - <@05163c>): void(.result.w := w);
	<vec4f+9 @051639>    : 16 08 01                   mov.x32 sp(8, 1)
	<vec4f+12 @05163c>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:49: referenced as `vec4f`
	lib/vec/mat4f.ci:47: referenced as `vec4f`
	lib/vec/mat4f.ci:45: referenced as `vec4f`
	lib/vec/vec4f.ci:36: referenced as `vec4f`
	lib/vec/vec4f.ci:34: referenced as `vec4f`
	lib/vec/vec4f.ci:32: referenced as `vec4f`
	lib/vec/vec4f.ci:28: defined as `vec4f(x: float32, y: float32, z: float32, w: float32): vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with given x, y, z components, and w with 0'
.value: vec4f(void(void(void(x, y), z), 0.000000))
.usages:
	lib/vec/vec4f.ci:95: referenced as `vec4f`
	lib/vec/vec4f.ci:32: defined as `vec4f(x: float32, y: float32, z: float32): vec4f`
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:34'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
	lib/vec/vec4f.ci:34: defined as `vec4f(xyz: vec4f, w: float32): vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'lib/vec/vec4f.ci:36'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	lib/vec/vec4f.ci:100: referenced as `vec4f`
	lib/vec/vec4f.ci:36: defined as `vec4f(val: float32): vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'lib/vec/vec4f.ci:67'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
	lib/vec/vec4f.ci:67: defined as `neg(rhs: vec4f): vec4f`
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'lib/vec/vec4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	lib/vec/vec4f.ci:69: defined as `add(lhs: vec4f, rhs: vec4f): vec4f`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'lib/vec/vec4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	lib/vec/vec4f.ci:71: defined as `sub(lhs: vec4f, rhs: vec4f): vec4f`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'lib/vec/vec4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	lib/vec/vec4f.ci:73: defined as `mul(lhs: vec4f, rhs: vec4f): vec4f`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'lib/vec/vec4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `div`
	lib/vec/vec4f.ci:75: defined as `div(lhs: vec4f, rhs: vec4f): vec4f`
}
min(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'lib/vec/vec4f.ci:78'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)))
.usages:
	lib/vec/vec4f.ci:78: defined as `min(lhs: vec4f, rhs: vec4f): float32`
}
max(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'lib/vec/vec4f.ci:80'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)))
.usages:
	lib/vec/vec4f.ci:80: defined as `max(lhs: vec4f, rhs: vec4f): float32`
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/vec4f.ci:84'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)))
.usages:
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/mat4f.ci:45: referenced as `dp3`
	lib/vec/vec4f.ci:98: referenced as `dp3`
	lib/vec/vec4f.ci:84: defined as `dp3(lhs: vec4f, rhs: vec4f): float32`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/vec4f.ci:88'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)))
.usages:
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/mat4f.ci:47: referenced as `dph`
	lib/vec/vec4f.ci:88: defined as `dph(lhs: vec4f, rhs: vec4f): float32`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/vec4f.ci:92'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)))
.usages:
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/mat4f.ci:49: referenced as `dp4`
	lib/vec/vec4f.ci:92: defined as `dp4(lhs: vec4f, rhs: vec4f): float32`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'lib/vec/vec4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
	lib/vec/vec4f.ci:95: defined as `cross(a: vec4f, b: vec4f): vec4f`
}
len(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'len'
.file: 'lib/vec/vec4f.ci:98'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	lib/vec/vec4f.ci:100: referenced as `len`
	lib/vec/vec4f.ci:98: defined as `len(v: vec4f): float32`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'lib/vec/vec4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(len(v))))
.usages:
	lib/vec/vec4f.ci:100: defined as `normalize(v: vec4f): vec4f`
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'lib/vec/vec4f.ci:103'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
	lib/vec/vec4f.ci:103: defined as `eval(v: vec4f, x: float32): float32`
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@028ff0>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:4'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	lib/vec/mat4f.ci:53: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:52: referenced as `mat4f`
	lib/vec/mat4f.ci:49: referenced as `mat4f`
	lib/vec/mat4f.ci:47: referenced as `mat4f`
	lib/vec/mat4f.ci:45: referenced as `mat4f`
	lib/vec/mat4f.ci:40: referenced as `mat4f`
	lib/vec/mat4f.ci:27: referenced as `mat4f`
	lib/vec/mat4f.ci:4: defined as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'lib/vec/mat4f.ci:6'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
	lib/vec/mat4f.ci:6: defined as `m`
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'lib/vec/mat4f.ci:9'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	lib/vec/mat4f.ci:9: defined as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'lib/vec/mat4f.ci:12'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
	lib/vec/mat4f.ci:12: defined as `v`
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'lib/vec/mat4f.ci:68'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
	lib/vec/mat4f.ci:68: defined as `<?>`
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:60: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:57: referenced as `x`
	lib/vec/mat4f.ci:56: referenced as `x`
	lib/vec/mat4f.ci:55: referenced as `x`
	lib/vec/mat4f.ci:54: referenced as `x`
	lib/vec/mat4f.ci:49: referenced as `x`
	lib/vec/mat4f.ci:47: referenced as `x`
	lib/vec/mat4f.ci:45: referenced as `x`
	lib/vec/mat4f.ci:41: referenced as `x`
	lib/vec/mat4f.ci:32: referenced as `x`
	lib/vec/mat4f.ci:16: defined as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:61: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:57: referenced as `y`
	lib/vec/mat4f.ci:56: referenced as `y`
	lib/vec/mat4f.ci:55: referenced as `y`
	lib/vec/mat4f.ci:54: referenced as `y`
	lib/vec/mat4f.ci:49: referenced as `y`
	lib/vec/mat4f.ci:47: referenced as `y`
	lib/vec/mat4f.ci:45: referenced as `y`
	lib/vec/mat4f.ci:41: referenced as `y`
	lib/vec/mat4f.ci:33: referenced as `y`
	lib/vec/mat4f.ci:18: defined as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:62: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:57: referenced as `z`
	lib/vec/mat4f.ci:56: referenced as `z`
	lib/vec/mat4f.ci:55: referenced as `z`
	lib/vec/mat4f.ci:54: referenced as `z`
	lib/vec/mat4f.ci:49: referenced as `z`
	lib/vec/mat4f.ci:47: referenced as `z`
	lib/vec/mat4f.ci:45: referenced as `z`
	lib/vec/mat4f.ci:41: referenced as `z`
	lib/vec/mat4f.ci:34: referenced as `z`
	lib/vec/mat4f.ci:20: defined as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:63: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:57: referenced as `w`
	lib/vec/mat4f.ci:56: referenced as `w`
	lib/vec/mat4f.ci:55: referenced as `w`
	lib/vec/mat4f.ci:54: referenced as `w`
	lib/vec/mat4f.ci:49: referenced as `w`
	lib/vec/mat4f.ci:47: referenced as `w`
	lib/vec/mat4f.ci:41: referenced as `w`
	lib/vec/mat4f.ci:35: referenced as `w`
	lib/vec/mat4f.ci:22: defined as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'lib/vec/mat4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
.usages:
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'lib/vec/mat4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
.usages:
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'lib/vec/mat4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
.usages:
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'lib/vec/mat4f.ci:22'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
.usages:
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static const function
.base: `function`
.size: 49
.offset: <@051640>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:27'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
}
.instructions: (49 bytes: <@051640> - <@051671>)
	lib/vec/mat4f.ci:31: (49 bytes: <@051640> - <@051671>): return void(.result := {...});
	<mat4f @051640>      : 16 11 10                   mov.x32 sp(17, 16)
	lib/vec/mat4f.ci:32: (3 bytes: <@051643> - <@051646>): void(.result.x.y := xy);
	<mat4f+3 @051643>    : 16 12 0f                   mov.x32 sp(18, 15)
	lib/vec/mat4f.ci:32: (3 bytes: <@051646> - <@051649>): void(.result.x.z := xz);
	<mat4f+6 @051646>    : 16 13 0e                   mov.x32 sp(19, 14)
	lib/vec/mat4f.ci:32: (3 bytes: <@051649> - <@05164c>): void(.result.x.w := xw);
	<mat4f+9 @051649>    : 16 14 0d                   mov.x32 sp(20, 13)
	lib/vec/mat4f.ci:33: (3 bytes: <@05164c> - <@05164f>): void(.result.y.x := yx);
	<mat4f+12 @05164c>   : 16 15 0c                   mov.x32 sp(21, 12)
	lib/vec/mat4f.ci:33: (3 bytes: <@05164f> - <@051652>): void(.result.y.y := yy);
	<mat4f+15 @05164f>   : 16 16 0b                   mov.x32 sp(22, 11)
	lib/vec/mat4f.ci:33: (3 bytes: <@051652> - <@051655>): void(.result.y.z := yz);
	<mat4f+18 @051652>   : 16 17 0a                   mov.x32 sp(23, 10)
	lib/vec/mat4f.ci:33: (3 bytes: <@051655> - <@051658>): void(.result.y.w := yw);
	<mat4f+21 @051655>   : 16 18 09                   mov.x32 sp(24, 9)
	lib/vec/mat4f.ci:34: (3 bytes: <@051658> - <@05165b>): void(.result.z.x := zx);
	<mat4f+24 @051658>   : 16 19 08                   mov.x32 sp(25, 8)
	lib/vec/mat4f.ci:34: (3 bytes: <@05165b> - <@05165e>): void(.result.z.y := zy);
	<mat4f+27 @05165b>   : 16 1a 07                   mov.x32 sp(26, 7)
	lib/vec/mat4f.ci:34: (3 bytes: <@05165e> - <@051661>): void(.result.z.z := zz);
	<mat4f+30 @05165e>   : 16 1b 06                   mov.x32 sp(27, 6)
	lib/vec/mat4f.ci:34: (3 bytes: <@051661> - <@051664>): void(.result.z.w := zw);
	<mat4f+33 @051661>   : 16 1c 05                   mov.x32 sp(28, 5)
	lib/vec/mat4f.ci:35: (3 bytes: <@051664> - <@051667>): void(.result.w.x := wx);
	<mat4f+36 @051664>   : 16 1d 04                   mov.x32 sp(29, 4)
	lib/vec/mat4f.ci:35: (3 bytes: <@051667> - <@05166a>): void(.result.w.y := wy);
	<mat4f+39 @051667>   : 16 1e 03                   mov.x32 sp(30, 3)
	lib/vec/mat4f.ci:35: (3 bytes: <@05166a> - <@05166d>): void(.result.w.z := wz);
	<mat4f+42 @05166a>   : 16 1f 02                   mov.x32 sp(31, 2)
	lib/vec/mat4f.ci:35: (3 bytes: <@05166d> - <@051670>): void(.result.w.w := ww);
	<mat4f+45 @05166d>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @051670>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:27: defined as `mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f`
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 21
.offset: <@051678>
.name: 'mat4f'
.file: 'lib/vec/mat4f.ci:40'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <@051678> - <@05168d>)
	lib/vec/mat4f.ci:41: (21 bytes: <@051678> - <@05168d>): return void(.result := {...});
	<mat4f @051678>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @05167a>    : 24                         load.i128
	<mat4f+3 @05167b>    : 15 09                      set.x128 sp(9)
	lib/vec/mat4f.ci:41: (5 bytes: <@05167d> - <@051682>): void(.result.y := y);
	<mat4f+5 @05167d>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @05167f>    : 24                         load.i128
	<mat4f+8 @051680>    : 15 0d                      set.x128 sp(13)
	lib/vec/mat4f.ci:41: (5 bytes: <@051682> - <@051687>): void(.result.z := z);
	<mat4f+10 @051682>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @051684>   : 24                         load.i128
	<mat4f+13 @051685>   : 15 11                      set.x128 sp(17)
	lib/vec/mat4f.ci:41: (5 bytes: <@051687> - <@05168c>): void(.result.w := w);
	<mat4f+15 @051687>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @051689>   : 24                         load.i128
	<mat4f+18 @05168a>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @05168c>   : 03                         ret
.usages:
	lib/vec/mat4f.ci:40: defined as `mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f`
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'lib/vec/mat4f.ci:45'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
	lib/vec/mat4f.ci:45: defined as `dp3(mat: mat4f, vec: vec4f): vec4f`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'lib/vec/mat4f.ci:47'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:47: defined as `dph(mat: mat4f, vec: vec4f): vec4f`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'lib/vec/mat4f.ci:49'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	lib/vec/mat4f.ci:63: referenced as `dp4`
	lib/vec/mat4f.ci:62: referenced as `dp4`
	lib/vec/mat4f.ci:61: referenced as `dp4`
	lib/vec/mat4f.ci:60: referenced as `dp4`
	lib/vec/mat4f.ci:49: defined as `dp4(mat: mat4f, vec: vec4f): vec4f`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static const function
.base: `function`
.size: 417
.offset: <@051690>
.name: 'mul'
.file: 'lib/vec/mat4f.ci:52'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := {
		void(transposed.x.x := rhs.x.x);
		void(transposed.x.y := rhs.y.x);
		void(transposed.x.z := rhs.z.x);
		void(transposed.x.w := rhs.w.x);
		void(transposed.y.x := rhs.x.y);
		void(transposed.y.y := rhs.y.y);
		void(transposed.y.z := rhs.z.y);
		void(transposed.y.w := rhs.w.y);
		void(transposed.z.x := rhs.x.z);
		void(transposed.z.y := rhs.y.z);
		void(transposed.z.z := rhs.z.z);
		void(transposed.z.w := rhs.w.z);
		void(transposed.w.x := rhs.x.w);
		void(transposed.w.y := rhs.y.w);
		void(transposed.w.z := rhs.z.w);
		void(transposed.w.w := rhs.w.w);
	};
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (417 bytes: <@051690> - <@051831>)
	lib/vec/mat4f.ci:53: (144 bytes: <@051690> - <@051720>): transposed: mat4f := {...}
	<mul @051690>      : 09 40 00 00                inc.sp(+64)
	lib/vec/mat4f.ci:54: (5 bytes: <@051694> - <@051699>): void(transposed.x.x := rhs.x.x);
	<mul+4 @051694>    : 10 11                      dup.x32 sp(17)
	<mul+6 @051696>    : 22                         load.i32
	<mul+7 @051697>    : 13 01                      set.x32 sp(1)
	lib/vec/mat4f.ci:54: (9 bytes: <@051699> - <@0516a2>): void(transposed.x.y := rhs.y.x);
	<mul+9 @051699>    : 10 11                      dup.x32 sp(17)
	<mul+11 @05169b>   : 0c 10 00 00                inc.i32(+16)
	<mul+15 @05169f>   : 22                         load.i32
	<mul+16 @0516a0>   : 13 02                      set.x32 sp(2)
	lib/vec/mat4f.ci:54: (9 bytes: <@0516a2> - <@0516ab>): void(transposed.x.z := rhs.z.x);
	<mul+18 @0516a2>   : 10 11                      dup.x32 sp(17)
	<mul+20 @0516a4>   : 0c 20 00 00                inc.i32(+32)
	<mul+24 @0516a8>   : 22                         load.i32
	<mul+25 @0516a9>   : 13 03                      set.x32 sp(3)
	lib/vec/mat4f.ci:54: (9 bytes: <@0516ab> - <@0516b4>): void(transposed.x.w := rhs.w.x);
	<mul+27 @0516ab>   : 10 11                      dup.x32 sp(17)
	<mul+29 @0516ad>   : 0c 30 00 00                inc.i32(+48)
	<mul+33 @0516b1>   : 22                         load.i32
	<mul+34 @0516b2>   : 13 04                      set.x32 sp(4)
	lib/vec/mat4f.ci:55: (9 bytes: <@0516b4> - <@0516bd>): void(transposed.y.x := rhs.x.y);
	<mul+36 @0516b4>   : 10 11                      dup.x32 sp(17)
	<mul+38 @0516b6>   : 0c 04 00 00                inc.i32(+4)
	<mul+42 @0516ba>   : 22                         load.i32
	<mul+43 @0516bb>   : 13 05                      set.x32 sp(5)
	lib/vec/mat4f.ci:55: (9 bytes: <@0516bd> - <@0516c6>): void(transposed.y.y := rhs.y.y);
	<mul+45 @0516bd>   : 10 11                      dup.x32 sp(17)
	<mul+47 @0516bf>   : 0c 14 00 00                inc.i32(+20)
	<mul+51 @0516c3>   : 22                         load.i32
	<mul+52 @0516c4>   : 13 06                      set.x32 sp(6)
	lib/vec/mat4f.ci:55: (9 bytes: <@0516c6> - <@0516cf>): void(transposed.y.z := rhs.z.y);
	<mul+54 @0516c6>   : 10 11                      dup.x32 sp(17)
	<mul+56 @0516c8>   : 0c 24 00 00                inc.i32(+36)
	<mul+60 @0516cc>   : 22                         load.i32
	<mul+61 @0516cd>   : 13 07                      set.x32 sp(7)
	lib/vec/mat4f.ci:55: (9 bytes: <@0516cf> - <@0516d8>): void(transposed.y.w := rhs.w.y);
	<mul+63 @0516cf>   : 10 11                      dup.x32 sp(17)
	<mul+65 @0516d1>   : 0c 34 00 00                inc.i32(+52)
	<mul+69 @0516d5>   : 22                         load.i32
	<mul+70 @0516d6>   : 13 08                      set.x32 sp(8)
	lib/vec/mat4f.ci:56: (9 bytes: <@0516d8> - <@0516e1>): void(transposed.z.x := rhs.x.z);
	<mul+72 @0516d8>   : 10 11                      dup.x32 sp(17)
	<mul+74 @0516da>   : 0c 08 00 00                inc.i32(+8)
	<mul+78 @0516de>   : 22                         load.i32
	<mul+79 @0516df>   : 13 09                      set.x32 sp(9)
	lib/vec/mat4f.ci:56: (9 bytes: <@0516e1> - <@0516ea>): void(transposed.z.y := rhs.y.z);
	<mul+81 @0516e1>   : 10 11                      dup.x32 sp(17)
	<mul+83 @0516e3>   : 0c 18 00 00                inc.i32(+24)
	<mul+87 @0516e7>   : 22                         load.i32
	<mul+88 @0516e8>   : 13 0a                      set.x32 sp(10)
	lib/vec/mat4f.ci:56: (9 bytes: <@0516ea> - <@0516f3>): void(transposed.z.z := rhs.z.z);
	<mul+90 @0516ea>   : 10 11                      dup.x32 sp(17)
	<mul+92 @0516ec>   : 0c 28 00 00                inc.i32(+40)
	<mul+96 @0516f0>   : 22                         load.i32
	<mul+97 @0516f1>   : 13 0b                      set.x32 sp(11)
	lib/vec/mat4f.ci:56: (9 bytes: <@0516f3> - <@0516fc>): void(transposed.z.w := rhs.w.z);
	<mul+99 @0516f3>   : 10 11                      dup.x32 sp(17)
	<mul+101 @0516f5>  : 0c 38 00 00                inc.i32(+56)
	<mul+105 @0516f9>  : 22                         load.i32
	<mul+106 @0516fa>  : 13 0c                      set.x32 sp(12)
	lib/vec/mat4f.ci:57: (9 bytes: <@0516fc> - <@051705>): void(transposed.w.x := rhs.x.w);
	<mul+108 @0516fc>  : 10 11                      dup.x32 sp(17)
	<mul+110 @0516fe>  : 0c 0c 00 00                inc.i32(+12)
	<mul+114 @051702>  : 22                         load.i32
	<mul+115 @051703>  : 13 0d                      set.x32 sp(13)
	lib/vec/mat4f.ci:57: (9 bytes: <@051705> - <@05170e>): void(transposed.w.y := rhs.y.w);
	<mul+117 @051705>  : 10 11                      dup.x32 sp(17)
	<mul+119 @051707>  : 0c 1c 00 00                inc.i32(+28)
	<mul+123 @05170b>  : 22                         load.i32
	<mul+124 @05170c>  : 13 0e                      set.x32 sp(14)
	lib/vec/mat4f.ci:57: (9 bytes: <@05170e> - <@051717>): void(transposed.w.z := rhs.z.w);
	<mul+126 @05170e>  : 10 11                      dup.x32 sp(17)
	<mul+128 @051710>  : 0c 2c 00 00                inc.i32(+44)
	<mul+132 @051714>  : 22                         load.i32
	<mul+133 @051715>  : 13 0f                      set.x32 sp(15)
	lib/vec/mat4f.ci:57: (9 bytes: <@051717> - <@051720>): void(transposed.w.w := rhs.w.w);
	<mul+135 @051717>  : 10 11                      dup.x32 sp(17)
	<mul+137 @051719>  : 0c 3c 00 00                inc.i32(+60)
	<mul+141 @05171d>  : 22                         load.i32
	<mul+142 @05171e>  : 13 10                      set.x32 sp(16)
	lib/vec/mat4f.ci:59: (273 bytes: <@051720> - <@051831>): return void(.result := {...});
	<mul+144 @051720>  : 0a 00 00 00                load.sp(+0)
	<mul+148 @051724>  : 10 13                      dup.x32 sp(19)
	<mul+150 @051726>  : 09 10 00 00                inc.sp(+16)
	<mul+154 @05172a>  : 10 04                      dup.x32 sp(4)
	<mul+156 @05172c>  : 24                         load.i128
	<mul+157 @05172d>  : 10 09                      dup.x32 sp(9)
	<mul+159 @05172f>  : 24                         load.i128
	<mul+160 @051730>  : 9b                         dp4.v4f
	<mul+161 @051731>  : 10 05                      dup.x32 sp(5)
	<mul+163 @051733>  : 24                         load.i128
	<mul+164 @051734>  : 10 0a                      dup.x32 sp(10)
	<mul+166 @051736>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @05173a>  : 24                         load.i128
	<mul+171 @05173b>  : 9b                         dp4.v4f
	<mul+172 @05173c>  : 10 06                      dup.x32 sp(6)
	<mul+174 @05173e>  : 24                         load.i128
	<mul+175 @05173f>  : 10 0b                      dup.x32 sp(11)
	<mul+177 @051741>  : 0c 20 00 00                inc.i32(+32)
	<mul+181 @051745>  : 24                         load.i128
	<mul+182 @051746>  : 9b                         dp4.v4f
	<mul+183 @051747>  : 10 07                      dup.x32 sp(7)
	<mul+185 @051749>  : 24                         load.i128
	<mul+186 @05174a>  : 10 0c                      dup.x32 sp(12)
	<mul+188 @05174c>  : 0c 30 00 00                inc.i32(+48)
	<mul+192 @051750>  : 24                         load.i128
	<mul+193 @051751>  : 9b                         dp4.v4f
	<mul+194 @051752>  : 1f 30 16 05 00             load.ref <@051630> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+199 @051757>  : 02                         call
	<mul+200 @051758>  : 09 f0 ff ff                inc.sp(-16)
	<mul+204 @05175c>  : 15 02                      set.x128 sp(2)
	<mul+206 @05175e>  : 15 17                      set.x128 sp(23)
	lib/vec/mat4f.ci:61: (68 bytes: <@051760> - <@0517a4>): void(.result.y := dp4(void(transposed, lhs.y)));
	<mul+208 @051760>  : 0a 00 00 00                load.sp(+0)
	<mul+212 @051764>  : 10 13                      dup.x32 sp(19)
	<mul+214 @051766>  : 0c 10 00 00                inc.i32(+16)
	<mul+218 @05176a>  : 09 10 00 00                inc.sp(+16)
	<mul+222 @05176e>  : 10 04                      dup.x32 sp(4)
	<mul+224 @051770>  : 24                         load.i128
	<mul+225 @051771>  : 10 09                      dup.x32 sp(9)
	<mul+227 @051773>  : 24                         load.i128
	<mul+228 @051774>  : 9b                         dp4.v4f
	<mul+229 @051775>  : 10 05                      dup.x32 sp(5)
	<mul+231 @051777>  : 24                         load.i128
	<mul+232 @051778>  : 10 0a                      dup.x32 sp(10)
	<mul+234 @05177a>  : 0c 10 00 00                inc.i32(+16)
	<mul+238 @05177e>  : 24                         load.i128
	<mul+239 @05177f>  : 9b                         dp4.v4f
	<mul+240 @051780>  : 10 06                      dup.x32 sp(6)
	<mul+242 @051782>  : 24                         load.i128
	<mul+243 @051783>  : 10 0b                      dup.x32 sp(11)
	<mul+245 @051785>  : 0c 20 00 00                inc.i32(+32)
	<mul+249 @051789>  : 24                         load.i128
	<mul+250 @05178a>  : 9b                         dp4.v4f
	<mul+251 @05178b>  : 10 07                      dup.x32 sp(7)
	<mul+253 @05178d>  : 24                         load.i128
	<mul+254 @05178e>  : 10 0c                      dup.x32 sp(12)
	<mul+256 @051790>  : 0c 30 00 00                inc.i32(+48)
	<mul+260 @051794>  : 24                         load.i128
	<mul+261 @051795>  : 9b                         dp4.v4f
	<mul+262 @051796>  : 1f 30 16 05 00             load.ref <@051630> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+267 @05179b>  : 02                         call
	<mul+268 @05179c>  : 09 f0 ff ff                inc.sp(-16)
	<mul+272 @0517a0>  : 15 02                      set.x128 sp(2)
	<mul+274 @0517a2>  : 15 1b                      set.x128 sp(27)
	lib/vec/mat4f.ci:62: (68 bytes: <@0517a4> - <@0517e8>): void(.result.z := dp4(void(transposed, lhs.z)));
	<mul+276 @0517a4>  : 0a 00 00 00                load.sp(+0)
	<mul+280 @0517a8>  : 10 13                      dup.x32 sp(19)
	<mul+282 @0517aa>  : 0c 20 00 00                inc.i32(+32)
	<mul+286 @0517ae>  : 09 10 00 00                inc.sp(+16)
	<mul+290 @0517b2>  : 10 04                      dup.x32 sp(4)
	<mul+292 @0517b4>  : 24                         load.i128
	<mul+293 @0517b5>  : 10 09                      dup.x32 sp(9)
	<mul+295 @0517b7>  : 24                         load.i128
	<mul+296 @0517b8>  : 9b                         dp4.v4f
	<mul+297 @0517b9>  : 10 05                      dup.x32 sp(5)
	<mul+299 @0517bb>  : 24                         load.i128
	<mul+300 @0517bc>  : 10 0a                      dup.x32 sp(10)
	<mul+302 @0517be>  : 0c 10 00 00                inc.i32(+16)
	<mul+306 @0517c2>  : 24                         load.i128
	<mul+307 @0517c3>  : 9b                         dp4.v4f
	<mul+308 @0517c4>  : 10 06                      dup.x32 sp(6)
	<mul+310 @0517c6>  : 24                         load.i128
	<mul+311 @0517c7>  : 10 0b                      dup.x32 sp(11)
	<mul+313 @0517c9>  : 0c 20 00 00                inc.i32(+32)
	<mul+317 @0517cd>  : 24                         load.i128
	<mul+318 @0517ce>  : 9b                         dp4.v4f
	<mul+319 @0517cf>  : 10 07                      dup.x32 sp(7)
	<mul+321 @0517d1>  : 24                         load.i128
	<mul+322 @0517d2>  : 10 0c                      dup.x32 sp(12)
	<mul+324 @0517d4>  : 0c 30 00 00                inc.i32(+48)
	<mul+328 @0517d8>  : 24                         load.i128
	<mul+329 @0517d9>  : 9b                         dp4.v4f
	<mul+330 @0517da>  : 1f 30 16 05 00             load.ref <@051630> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+335 @0517df>  : 02                         call
	<mul+336 @0517e0>  : 09 f0 ff ff                inc.sp(-16)
	<mul+340 @0517e4>  : 15 02                      set.x128 sp(2)
	<mul+342 @0517e6>  : 15 1f                      set.x128 sp(31)
	lib/vec/mat4f.ci:63: (68 bytes: <@0517e8> - <@05182c>): void(.result.w := dp4(void(transposed, lhs.w)));
	<mul+344 @0517e8>  : 0a 00 00 00                load.sp(+0)
	<mul+348 @0517ec>  : 10 13                      dup.x32 sp(19)
	<mul+350 @0517ee>  : 0c 30 00 00                inc.i32(+48)
	<mul+354 @0517f2>  : 09 10 00 00                inc.sp(+16)
	<mul+358 @0517f6>  : 10 04                      dup.x32 sp(4)
	<mul+360 @0517f8>  : 24                         load.i128
	<mul+361 @0517f9>  : 10 09                      dup.x32 sp(9)
	<mul+363 @0517fb>  : 24                         load.i128
	<mul+364 @0517fc>  : 9b                         dp4.v4f
	<mul+365 @0517fd>  : 10 05                      dup.x32 sp(5)
	<mul+367 @0517ff>  : 24                         load.i128
	<mul+368 @051800>  : 10 0a                      dup.x32 sp(10)
	<mul+370 @051802>  : 0c 10 00 00                inc.i32(+16)
	<mul+374 @051806>  : 24                         load.i128
	<mul+375 @051807>  : 9b                         dp4.v4f
	<mul+376 @051808>  : 10 06                      dup.x32 sp(6)
	<mul+378 @05180a>  : 24                         load.i128
	<mul+379 @05180b>  : 10 0b                      dup.x32 sp(11)
	<mul+381 @05180d>  : 0c 20 00 00                inc.i32(+32)
	<mul+385 @051811>  : 24                         load.i128
	<mul+386 @051812>  : 9b                         dp4.v4f
	<mul+387 @051813>  : 10 07                      dup.x32 sp(7)
	<mul+389 @051815>  : 24                         load.i128
	<mul+390 @051816>  : 10 0c                      dup.x32 sp(12)
	<mul+392 @051818>  : 0c 30 00 00                inc.i32(+48)
	<mul+396 @05181c>  : 24                         load.i128
	<mul+397 @05181d>  : 9b                         dp4.v4f
	<mul+398 @05181e>  : 1f 30 16 05 00             load.ref <@051630> ;vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
	<mul+403 @051823>  : 02                         call
	<mul+404 @051824>  : 09 f0 ff ff                inc.sp(-16)
	<mul+408 @051828>  : 15 02                      set.x128 sp(2)
	<mul+410 @05182a>  : 15 23                      set.x128 sp(35)
	<mul+412 @05182c>  : 09 c0 ff ff                inc.sp(-64)
	<mul+416 @051830>  : 03                         ret
.usages:
	lib/vec/mat4f.ci:52: defined as `mul(lhs: mat4f, rhs: mat4f): mat4f`
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'test/test.ci:5'
.value: int64
.usages:
	test/test.ci:5: defined as `integer`
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051838>
.name: 'emitldz32'
.file: 'test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
	test/lang/emit.ci:3: defined as `emitldz32`
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051840>
.name: 'emitldz64'
.file: 'test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
	test/lang/emit.ci:4: defined as `emitldz64`
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051848>
.name: 'emitA'
.file: 'test/lang/emit.ci:6'
.value: 42
.usages:
	test/lang/emit.ci:9: referenced as `emitA`
	test/lang/emit.ci:6: defined as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051850>
.name: 'emitB'
.file: 'test/lang/emit.ci:7'
.value: 96
.usages:
	test/lang/emit.ci:9: referenced as `emitB`
	test/lang/emit.ci:7: defined as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051858>
.name: 'emitAddI32'
.file: 'test/lang/emit.ci:9'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
	test/lang/emit.ci:9: defined as `emitAddI32`
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051860>
.name: 'emitDivI32'
.file: 'test/lang/emit.ci:10'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
	test/lang/emit.ci:10: defined as `emitDivI32`
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'test/lang/emit.ci:14'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.value: int32(emit(float32(value)))
.usages:
	test/lang/emit.ci:18: referenced as `floatAsInt32`
	test/lang/emit.ci:17: referenced as `floatAsInt32`
	test/lang/emit.ci:14: defined as `floatAsInt32(value: float32): int32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'test/lang/emit.ci:15'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: int64(emit(float64(value)))
.usages:
	test/lang/emit.ci:20: referenced as `floatAsInt64`
	test/lang/emit.ci:19: referenced as `floatAsInt64`
	test/lang/emit.ci:15: defined as `floatAsInt64(value: float64): int64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051868>
.name: 'emitFloatAsInt1'
.file: 'test/lang/emit.ci:17'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:17: defined as `emitFloatAsInt1`
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051870>
.name: 'emitFloatAsInt2'
.file: 'test/lang/emit.ci:18'
.value: floatAsInt32(500)
.usages:
	test/lang/emit.ci:18: defined as `emitFloatAsInt2`
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051878>
.name: 'emitFloatAsInt3'
.file: 'test/lang/emit.ci:19'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:19: defined as `emitFloatAsInt3`
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051880>
.name: 'emitFloatAsInt4'
.file: 'test/lang/emit.ci:20'
.value: floatAsInt64(500)
.usages:
	test/lang/emit.ci:20: defined as `emitFloatAsInt4`
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@051888>
.name: 'emitSlice'
.file: 'test/lang/emit.ci:23'
.value: emit(void(int32(3), pointer("string")))
.usages:
	test/lang/emit.ci:23: defined as `emitSlice`
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	test/lang/inlineMacros.ci:17: referenced as `zero`
	test/lang/inlineMacros.ci:16: referenced as `zero`
	test/lang/inlineMacros.ci:15: referenced as `zero`
	test/lang/inlineMacros.ci:3: defined as `zero(a: int32, b: int32): int32`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	test/lang/inlineMacros.ci:21: referenced as `last`
	test/lang/inlineMacros.ci:20: referenced as `last`
	test/lang/inlineMacros.ci:19: referenced as `last`
	test/lang/inlineMacros.ci:4: defined as `last(a: int32, b: int32): int32`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:40: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:39: referenced as `sum`
	test/lang/inlineMacros.ci:25: referenced as `sum`
	test/lang/inlineMacros.ci:24: referenced as `sum`
	test/lang/inlineMacros.ci:23: referenced as `sum`
	test/lang/inlineMacros.ci:5: defined as `sum(a: int32, b: int32): int32`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:49: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:48: referenced as `any`
	test/lang/inlineMacros.ci:29: referenced as `any`
	test/lang/inlineMacros.ci:28: referenced as `any`
	test/lang/inlineMacros.ci:27: referenced as `any`
	test/lang/inlineMacros.ci:6: defined as `any(a: int32, b: int32): int32`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:58: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:57: referenced as `min`
	test/lang/inlineMacros.ci:33: referenced as `min`
	test/lang/inlineMacros.ci:32: referenced as `min`
	test/lang/inlineMacros.ci:31: referenced as `min`
	test/lang/inlineMacros.ci:7: defined as `min(a: int32, b: int32): int32`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:67: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:66: referenced as `max`
	test/lang/inlineMacros.ci:37: referenced as `max`
	test/lang/inlineMacros.ci:36: referenced as `max`
	test/lang/inlineMacros.ci:35: referenced as `max`
	test/lang/inlineMacros.ci:8: defined as `max(a: int32, b: int32): int32`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051890>
.name: 'i3'
.file: 'test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i3`
	test/lang/inlineMacros.ci:72: referenced as `i3`
	test/lang/inlineMacros.ci:71: referenced as `i3`
	test/lang/inlineMacros.ci:70: referenced as `i3`
	test/lang/inlineMacros.ci:64: referenced as `i3`
	test/lang/inlineMacros.ci:63: referenced as `i3`
	test/lang/inlineMacros.ci:62: referenced as `i3`
	test/lang/inlineMacros.ci:61: referenced as `i3`
	test/lang/inlineMacros.ci:55: referenced as `i3`
	test/lang/inlineMacros.ci:54: referenced as `i3`
	test/lang/inlineMacros.ci:53: referenced as `i3`
	test/lang/inlineMacros.ci:52: referenced as `i3`
	test/lang/inlineMacros.ci:46: referenced as `i3`
	test/lang/inlineMacros.ci:45: referenced as `i3`
	test/lang/inlineMacros.ci:44: referenced as `i3`
	test/lang/inlineMacros.ci:43: referenced as `i3`
	test/lang/inlineMacros.ci:37: referenced as `i3`
	test/lang/inlineMacros.ci:36: referenced as `i3`
	test/lang/inlineMacros.ci:33: referenced as `i3`
	test/lang/inlineMacros.ci:32: referenced as `i3`
	test/lang/inlineMacros.ci:29: referenced as `i3`
	test/lang/inlineMacros.ci:28: referenced as `i3`
	test/lang/inlineMacros.ci:25: referenced as `i3`
	test/lang/inlineMacros.ci:24: referenced as `i3`
	test/lang/inlineMacros.ci:21: referenced as `i3`
	test/lang/inlineMacros.ci:20: referenced as `i3`
	test/lang/inlineMacros.ci:17: referenced as `i3`
	test/lang/inlineMacros.ci:16: referenced as `i3`
	test/lang/inlineMacros.ci:10: defined as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051898>
.name: 'i6'
.file: 'test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i6`
	test/lang/inlineMacros.ci:72: referenced as `i6`
	test/lang/inlineMacros.ci:71: referenced as `i6`
	test/lang/inlineMacros.ci:70: referenced as `i6`
	test/lang/inlineMacros.ci:64: referenced as `i6`
	test/lang/inlineMacros.ci:63: referenced as `i6`
	test/lang/inlineMacros.ci:62: referenced as `i6`
	test/lang/inlineMacros.ci:61: referenced as `i6`
	test/lang/inlineMacros.ci:55: referenced as `i6`
	test/lang/inlineMacros.ci:54: referenced as `i6`
	test/lang/inlineMacros.ci:53: referenced as `i6`
	test/lang/inlineMacros.ci:52: referenced as `i6`
	test/lang/inlineMacros.ci:46: referenced as `i6`
	test/lang/inlineMacros.ci:45: referenced as `i6`
	test/lang/inlineMacros.ci:44: referenced as `i6`
	test/lang/inlineMacros.ci:43: referenced as `i6`
	test/lang/inlineMacros.ci:37: referenced as `i6`
	test/lang/inlineMacros.ci:36: referenced as `i6`
	test/lang/inlineMacros.ci:33: referenced as `i6`
	test/lang/inlineMacros.ci:32: referenced as `i6`
	test/lang/inlineMacros.ci:29: referenced as `i6`
	test/lang/inlineMacros.ci:28: referenced as `i6`
	test/lang/inlineMacros.ci:25: referenced as `i6`
	test/lang/inlineMacros.ci:24: referenced as `i6`
	test/lang/inlineMacros.ci:21: referenced as `i6`
	test/lang/inlineMacros.ci:20: referenced as `i6`
	test/lang/inlineMacros.ci:17: referenced as `i6`
	test/lang/inlineMacros.ci:16: referenced as `i6`
	test/lang/inlineMacros.ci:11: defined as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518a0>
.name: 'i2'
.file: 'test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i2`
	test/lang/inlineMacros.ci:72: referenced as `i2`
	test/lang/inlineMacros.ci:71: referenced as `i2`
	test/lang/inlineMacros.ci:70: referenced as `i2`
	test/lang/inlineMacros.ci:64: referenced as `i2`
	test/lang/inlineMacros.ci:63: referenced as `i2`
	test/lang/inlineMacros.ci:62: referenced as `i2`
	test/lang/inlineMacros.ci:61: referenced as `i2`
	test/lang/inlineMacros.ci:55: referenced as `i2`
	test/lang/inlineMacros.ci:54: referenced as `i2`
	test/lang/inlineMacros.ci:53: referenced as `i2`
	test/lang/inlineMacros.ci:52: referenced as `i2`
	test/lang/inlineMacros.ci:46: referenced as `i2`
	test/lang/inlineMacros.ci:45: referenced as `i2`
	test/lang/inlineMacros.ci:44: referenced as `i2`
	test/lang/inlineMacros.ci:43: referenced as `i2`
	test/lang/inlineMacros.ci:12: defined as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518a8>
.name: 'i8'
.file: 'test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	test/lang/inlineMacros.ci:73: referenced as `i8`
	test/lang/inlineMacros.ci:72: referenced as `i8`
	test/lang/inlineMacros.ci:71: referenced as `i8`
	test/lang/inlineMacros.ci:70: referenced as `i8`
	test/lang/inlineMacros.ci:64: referenced as `i8`
	test/lang/inlineMacros.ci:63: referenced as `i8`
	test/lang/inlineMacros.ci:62: referenced as `i8`
	test/lang/inlineMacros.ci:61: referenced as `i8`
	test/lang/inlineMacros.ci:55: referenced as `i8`
	test/lang/inlineMacros.ci:54: referenced as `i8`
	test/lang/inlineMacros.ci:53: referenced as `i8`
	test/lang/inlineMacros.ci:52: referenced as `i8`
	test/lang/inlineMacros.ci:46: referenced as `i8`
	test/lang/inlineMacros.ci:45: referenced as `i8`
	test/lang/inlineMacros.ci:44: referenced as `i8`
	test/lang/inlineMacros.ci:43: referenced as `i8`
	test/lang/inlineMacros.ci:13: defined as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518b0>
.name: 'zeroVal'
.file: 'test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:15: defined as `zeroVal`
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518b8>
.name: 'zeroVar'
.file: 'test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:16: defined as `zeroVar`
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518c0>
.name: 'zeroXpr'
.file: 'test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
	test/lang/inlineMacros.ci:17: defined as `zeroXpr`
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518c8>
.name: 'lastVal'
.file: 'test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:19: defined as `lastVal`
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518d0>
.name: 'lastVar'
.file: 'test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:20: defined as `lastVar`
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518d8>
.name: 'lastXpr'
.file: 'test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:21: defined as `lastXpr`
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518e0>
.name: 'sum2Val'
.file: 'test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:23: defined as `sum2Val`
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518e8>
.name: 'sum2Var'
.file: 'test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:24: defined as `sum2Var`
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518f0>
.name: 'sum2Xpr'
.file: 'test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
	test/lang/inlineMacros.ci:25: defined as `sum2Xpr`
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0518f8>
.name: 'any2Val'
.file: 'test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:27: defined as `any2Val`
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051900>
.name: 'any2Var'
.file: 'test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:28: defined as `any2Var`
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051908>
.name: 'any2Xpr'
.file: 'test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:29: defined as `any2Xpr`
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051910>
.name: 'min2Val'
.file: 'test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:31: defined as `min2Val`
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051918>
.name: 'min2Var'
.file: 'test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:32: defined as `min2Var`
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051920>
.name: 'min2Xpr'
.file: 'test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:33: defined as `min2Xpr`
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051928>
.name: 'max2Val'
.file: 'test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
	test/lang/inlineMacros.ci:35: defined as `max2Val`
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051930>
.name: 'max2Var'
.file: 'test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
	test/lang/inlineMacros.ci:36: defined as `max2Var`
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051938>
.name: 'max2Xpr'
.file: 'test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:37: defined as `max2Xpr`
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:45: referenced as `sumLr`
	test/lang/inlineMacros.ci:43: referenced as `sumLr`
	test/lang/inlineMacros.ci:41: referenced as `sumLr`
	test/lang/inlineMacros.ci:39: defined as `sumLr(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:46: referenced as `sumRl`
	test/lang/inlineMacros.ci:44: referenced as `sumRl`
	test/lang/inlineMacros.ci:42: referenced as `sumRl`
	test/lang/inlineMacros.ci:40: defined as `sumRl(a: int32, b: int32, c: int32, d: int32): int32`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051940>
.name: 'sumRlVal'
.file: 'test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:41: defined as `sumRlVal`
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051948>
.name: 'sumLrVal'
.file: 'test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:42: defined as `sumLrVal`
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051950>
.name: 'sumRlVar'
.file: 'test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:43: defined as `sumRlVar`
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051958>
.name: 'sumLrVar'
.file: 'test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:44: defined as `sumLrVar`
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051960>
.name: 'sumRlXpr'
.file: 'test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:45: defined as `sumRlXpr`
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051968>
.name: 'sumLrXpr'
.file: 'test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
	test/lang/inlineMacros.ci:46: defined as `sumLrXpr`
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:54: referenced as `anyLr`
	test/lang/inlineMacros.ci:52: referenced as `anyLr`
	test/lang/inlineMacros.ci:50: referenced as `anyLr`
	test/lang/inlineMacros.ci:48: defined as `anyLr(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:55: referenced as `anyRl`
	test/lang/inlineMacros.ci:53: referenced as `anyRl`
	test/lang/inlineMacros.ci:51: referenced as `anyRl`
	test/lang/inlineMacros.ci:49: defined as `anyRl(a: int32, b: int32, c: int32, d: int32): int32`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051970>
.name: 'anyRlVal'
.file: 'test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:50: defined as `anyRlVal`
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051978>
.name: 'anyLrVal'
.file: 'test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:51: defined as `anyLrVal`
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051980>
.name: 'anyRlVar'
.file: 'test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:52: defined as `anyRlVar`
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051988>
.name: 'anyLrVar'
.file: 'test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:53: defined as `anyLrVar`
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051990>
.name: 'anyRlXpr'
.file: 'test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:54: defined as `anyRlXpr`
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051998>
.name: 'anyLrXpr'
.file: 'test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:55: defined as `anyLrXpr`
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:63: referenced as `minLr`
	test/lang/inlineMacros.ci:61: referenced as `minLr`
	test/lang/inlineMacros.ci:59: referenced as `minLr`
	test/lang/inlineMacros.ci:57: defined as `minLr(a: int32, b: int32, c: int32, d: int32): int32`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:64: referenced as `minRl`
	test/lang/inlineMacros.ci:62: referenced as `minRl`
	test/lang/inlineMacros.ci:60: referenced as `minRl`
	test/lang/inlineMacros.ci:58: defined as `minRl(a: int32, b: int32, c: int32, d: int32): int32`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519a0>
.name: 'minRlVal'
.file: 'test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:59: defined as `minRlVal`
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519a8>
.name: 'minLrVal'
.file: 'test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:60: defined as `minLrVal`
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519b0>
.name: 'minRlVar'
.file: 'test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:61: defined as `minRlVar`
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519b8>
.name: 'minLrVar'
.file: 'test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:62: defined as `minLrVar`
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519c0>
.name: 'minRlXpr'
.file: 'test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:63: defined as `minRlXpr`
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519c8>
.name: 'minLrXpr'
.file: 'test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:64: defined as `minLrXpr`
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	test/lang/inlineMacros.ci:72: referenced as `maxLr`
	test/lang/inlineMacros.ci:70: referenced as `maxLr`
	test/lang/inlineMacros.ci:68: referenced as `maxLr`
	test/lang/inlineMacros.ci:66: defined as `maxLr(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	test/lang/inlineMacros.ci:73: referenced as `maxRl`
	test/lang/inlineMacros.ci:71: referenced as `maxRl`
	test/lang/inlineMacros.ci:69: referenced as `maxRl`
	test/lang/inlineMacros.ci:67: defined as `maxRl(a: int32, b: int32, c: int32, d: int32): int32`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519d0>
.name: 'maxRlVal'
.file: 'test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:68: defined as `maxRlVal`
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519d8>
.name: 'maxLrVal'
.file: 'test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
	test/lang/inlineMacros.ci:69: defined as `maxLrVal`
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519e0>
.name: 'maxRlVar'
.file: 'test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:70: defined as `maxRlVar`
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519e8>
.name: 'maxLrVar'
.file: 'test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
	test/lang/inlineMacros.ci:71: defined as `maxLrVar`
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519f0>
.name: 'maxRlXpr'
.file: 'test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:72: defined as `maxRlXpr`
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0519f8>
.name: 'maxLrXpr'
.file: 'test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
	test/lang/inlineMacros.ci:73: defined as `maxLrXpr`
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:3'
.value: 1
.usages:
	test/lang/overload.inline.ci:9: referenced as `overload`
	test/lang/overload.inline.ci:3: defined as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	test/lang/overload.inline.ci:10: referenced as `overload`
	test/lang/overload.inline.ci:4: defined as `overload(): int32`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	test/lang/overload.inline.ci:11: referenced as `overload`
	test/lang/overload.inline.ci:5: defined as `overload(a: int32): int32`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	test/lang/overload.inline.ci:12: referenced as `overload`
	test/lang/overload.inline.ci:6: defined as `overload(a: float32): int32`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	test/lang/overload.inline.ci:13: referenced as `overload`
	test/lang/overload.inline.ci:7: defined as `overload(a: int32, b: int32): int32`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a00>
.name: 'overload1'
.file: 'test/lang/overload.inline.ci:9'
.value: overload
.usages:
	test/lang/overload.inline.ci:9: defined as `overload1`
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a08>
.name: 'overload2'
.file: 'test/lang/overload.inline.ci:10'
.value: overload()
.usages:
	test/lang/overload.inline.ci:10: defined as `overload2`
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a10>
.name: 'overload3'
.file: 'test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
	test/lang/overload.inline.ci:11: defined as `overload3`
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a18>
.name: 'overload4'
.file: 'test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
	test/lang/overload.inline.ci:12: defined as `overload4`
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051a20>
.name: 'overload5'
.file: 'test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
	test/lang/overload.inline.ci:13: defined as `overload5`
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031518>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:26: referenced as `Celsius`
	test/lang/overload.inline.ci:21: referenced as `Celsius`
	test/lang/overload.inline.ci:15: defined as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	test/lang/overload.inline.ci:26: referenced as `degrees`
	test/lang/overload.inline.ci:15: defined as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@031648>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:16: defined as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	test/lang/overload.inline.ci:25: referenced as `degrees`
	test/lang/overload.inline.ci:16: defined as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:28: referenced as `Celsius`
	test/lang/overload.inline.ci:25: referenced as `Celsius`
	test/lang/overload.inline.ci:21: defined as `Celsius(value: float64): Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:22: defined as `Fahrenheit(value: float64): Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
	test/lang/overload.inline.ci:25: defined as `Celsius(value: Fahrenheit): Celsius`
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	test/lang/overload.inline.ci:26: defined as `Fahrenheit(value: Celsius): Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@051a28>
.name: 'boilC'
.file: 'test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	test/lang/overload.inline.ci:29: referenced as `boilC`
	test/lang/overload.inline.ci:28: defined as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@051a30>
.name: 'boilF'
.file: 'test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
	test/lang/overload.inline.ci:29: defined as `boilF`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051a38>
.name: 'value'
.file: 'test/lang/initByRef.ci:7'
.value: 42
.usages:
	test/lang/initByRef.ci:99: referenced as `value`
	test/lang/initByRef.ci:97: referenced as `value`
	test/lang/initByRef.ci:96: referenced as `value`
	test/lang/initByRef.ci:95: referenced as `value`
	test/lang/initByRef.ci:27: referenced as `value`
	test/lang/initByRef.ci:10: referenced as `value`
	test/lang/initByRef.ci:9: referenced as `value`
	test/lang/initByRef.ci:8: referenced as `value`
	test/lang/initByRef.ci:7: defined as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051a40>
.name: 'valueRef'
.file: 'test/lang/initByRef.ci:8'
.value: value
.usages:
	test/lang/initByRef.ci:29: referenced as `valueRef`
	test/lang/initByRef.ci:12: referenced as `valueRef`
	test/lang/initByRef.ci:8: defined as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051a48>
.name: 'valuePtr'
.file: 'test/lang/initByRef.ci:9'
.value: value
.usages:
	test/lang/initByRef.ci:30: referenced as `valuePtr`
	test/lang/initByRef.ci:13: referenced as `valuePtr`
	test/lang/initByRef.ci:9: defined as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051a50>
.name: 'valueVar'
.file: 'test/lang/initByRef.ci:10'
.value: value
.usages:
	test/lang/initByRef.ci:31: referenced as `valueVar`
	test/lang/initByRef.ci:14: referenced as `valueVar`
	test/lang/initByRef.ci:10: defined as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051a58>
.name: 'fromRef'
.file: 'test/lang/initByRef.ci:12'
.value: valueRef
.usages:
	test/lang/initByRef.ci:12: defined as `fromRef`
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051a60>
.name: 'fromPtr'
.file: 'test/lang/initByRef.ci:13'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:13: defined as `fromPtr`
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051a68>
.name: 'fromVar'
.file: 'test/lang/initByRef.ci:14'
.value: valueVar
.usages:
	test/lang/initByRef.ci:14: defined as `fromVar`
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051a70>
.name: 'nullRef'
.file: 'test/lang/initByRef.ci:16'
.value: null
.usages:
	test/lang/initByRef.ci:16: defined as `nullRef`
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051a78>
.name: 'nullPtr'
.file: 'test/lang/initByRef.ci:17'
.value: null
.usages:
	test/lang/initByRef.ci:17: defined as `nullPtr`
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051a80>
.name: 'nullVar'
.file: 'test/lang/initByRef.ci:18'
.value: null
.usages:
	test/lang/initByRef.ci:18: defined as `nullVar`
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051a88>
.name: 'nullTyp'
.file: 'test/lang/initByRef.ci:19'
.value: null
.usages:
	test/lang/initByRef.ci:19: defined as `nullTyp`
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051a90>
.name: 'nullFun'
.file: 'test/lang/initByRef.ci:20'
.value: null
.usages:
	test/lang/initByRef.ci:20: defined as `nullFun`
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@051a98>
.name: 'nullObj'
.file: 'test/lang/initByRef.ci:21'
.value: null
.usages:
	test/lang/initByRef.ci:21: defined as `nullObj`
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051aa0>
.name: 'typePtr'
.file: 'test/lang/initByRef.ci:23'
.value: int64
.usages:
	test/lang/initByRef.ci:23: defined as `typePtr`
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051aa8>
.name: 'typeVar'
.file: 'test/lang/initByRef.ci:24'
.value: int64
.usages:
	test/lang/initByRef.ci:24: defined as `typeVar`
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051ab0>
.name: 'typeTyp'
.file: 'test/lang/initByRef.ci:25'
.value: int64
.usages:
	test/lang/initByRef.ci:32: referenced as `typeTyp`
	test/lang/initByRef.ci:25: defined as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051ab8>
.name: 'local'
.file: 'test/lang/initByRef.ci:27'
.value: value
.usages:
	test/lang/initByRef.ci:28: referenced as `local`
	test/lang/initByRef.ci:27: defined as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@051ac0>
.name: 'copyVal'
.file: 'test/lang/initByRef.ci:28'
.value: local
.usages:
	test/lang/initByRef.ci:28: defined as `copyVal`
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@051ac8>
.name: 'copyRef'
.file: 'test/lang/initByRef.ci:29'
.value: valueRef
.usages:
	test/lang/initByRef.ci:29: defined as `copyRef`
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051ad0>
.name: 'copyPtr'
.file: 'test/lang/initByRef.ci:30'
.value: valuePtr
.usages:
	test/lang/initByRef.ci:30: defined as `copyPtr`
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051ad8>
.name: 'copyVar'
.file: 'test/lang/initByRef.ci:31'
.value: valueVar
.usages:
	test/lang/initByRef.ci:31: defined as `copyVar`
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051ae0>
.name: 'copyTyp'
.file: 'test/lang/initByRef.ci:32'
.value: typeTyp
.usages:
	test/lang/initByRef.ci:32: defined as `copyTyp`
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051ae8>
.name: 'ptrVoid'
.file: 'test/lang/initByRef.ci:35'
.value: void
.usages:
	test/lang/initByRef.ci:35: defined as `ptrVoid`
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051af0>
.name: 'ptrBool'
.file: 'test/lang/initByRef.ci:36'
.value: bool
.usages:
	test/lang/initByRef.ci:36: defined as `ptrBool`
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051af8>
.name: 'ptrChar'
.file: 'test/lang/initByRef.ci:37'
.value: char
.usages:
	test/lang/initByRef.ci:37: defined as `ptrChar`
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b00>
.name: 'ptrInt8'
.file: 'test/lang/initByRef.ci:38'
.value: int8
.usages:
	test/lang/initByRef.ci:38: defined as `ptrInt8`
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b08>
.name: 'ptrInt16'
.file: 'test/lang/initByRef.ci:39'
.value: int16
.usages:
	test/lang/initByRef.ci:39: defined as `ptrInt16`
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b10>
.name: 'ptrInt32'
.file: 'test/lang/initByRef.ci:40'
.value: int32
.usages:
	test/lang/initByRef.ci:40: defined as `ptrInt32`
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b18>
.name: 'ptrInt64'
.file: 'test/lang/initByRef.ci:41'
.value: int64
.usages:
	test/lang/initByRef.ci:41: defined as `ptrInt64`
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b20>
.name: 'ptrUint8'
.file: 'test/lang/initByRef.ci:42'
.value: uint8
.usages:
	test/lang/initByRef.ci:42: defined as `ptrUint8`
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b28>
.name: 'ptrUint16'
.file: 'test/lang/initByRef.ci:43'
.value: uint16
.usages:
	test/lang/initByRef.ci:43: defined as `ptrUint16`
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b30>
.name: 'ptrUint32'
.file: 'test/lang/initByRef.ci:44'
.value: uint32
.usages:
	test/lang/initByRef.ci:44: defined as `ptrUint32`
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b38>
.name: 'ptrUint64'
.file: 'test/lang/initByRef.ci:45'
.value: uint64
.usages:
	test/lang/initByRef.ci:45: defined as `ptrUint64`
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b40>
.name: 'ptrFloat32'
.file: 'test/lang/initByRef.ci:46'
.value: float32
.usages:
	test/lang/initByRef.ci:46: defined as `ptrFloat32`
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b48>
.name: 'ptrFloat64'
.file: 'test/lang/initByRef.ci:47'
.value: float64
.usages:
	test/lang/initByRef.ci:105: referenced as `ptrFloat64`
	test/lang/initByRef.ci:47: defined as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b50>
.name: 'ptrTypename'
.file: 'test/lang/initByRef.ci:48'
.value: typename
.usages:
	test/lang/initByRef.ci:48: defined as `ptrTypename`
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b58>
.name: 'ptrFunction'
.file: 'test/lang/initByRef.ci:49'
.value: function
.usages:
	test/lang/initByRef.ci:49: defined as `ptrFunction`
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b60>
.name: 'ptrPointer'
.file: 'test/lang/initByRef.ci:50'
.value: pointer
.usages:
	test/lang/initByRef.ci:50: defined as `ptrPointer`
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b68>
.name: 'ptrVariant'
.file: 'test/lang/initByRef.ci:51'
.value: variant
.usages:
	test/lang/initByRef.ci:51: defined as `ptrVariant`
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051b70>
.name: 'ptrObject'
.file: 'test/lang/initByRef.ci:52'
.value: object
.usages:
	test/lang/initByRef.ci:52: defined as `ptrObject`
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051b78>
.name: 'varVoid'
.file: 'test/lang/initByRef.ci:55'
.value: void
.usages:
	test/lang/initByRef.ci:55: defined as `varVoid`
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051b80>
.name: 'varBool'
.file: 'test/lang/initByRef.ci:56'
.value: bool
.usages:
	test/lang/initByRef.ci:56: defined as `varBool`
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051b88>
.name: 'varChar'
.file: 'test/lang/initByRef.ci:57'
.value: char
.usages:
	test/lang/initByRef.ci:57: defined as `varChar`
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051b90>
.name: 'varInt8'
.file: 'test/lang/initByRef.ci:58'
.value: int8
.usages:
	test/lang/initByRef.ci:58: defined as `varInt8`
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051b98>
.name: 'varInt16'
.file: 'test/lang/initByRef.ci:59'
.value: int16
.usages:
	test/lang/initByRef.ci:59: defined as `varInt16`
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051ba0>
.name: 'varInt32'
.file: 'test/lang/initByRef.ci:60'
.value: int32
.usages:
	test/lang/initByRef.ci:60: defined as `varInt32`
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051ba8>
.name: 'varInt64'
.file: 'test/lang/initByRef.ci:61'
.value: int64
.usages:
	test/lang/initByRef.ci:61: defined as `varInt64`
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bb0>
.name: 'varUint8'
.file: 'test/lang/initByRef.ci:62'
.value: uint8
.usages:
	test/lang/initByRef.ci:62: defined as `varUint8`
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bb8>
.name: 'varUint16'
.file: 'test/lang/initByRef.ci:63'
.value: uint16
.usages:
	test/lang/initByRef.ci:63: defined as `varUint16`
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bc0>
.name: 'varUint32'
.file: 'test/lang/initByRef.ci:64'
.value: uint32
.usages:
	test/lang/initByRef.ci:64: defined as `varUint32`
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bc8>
.name: 'varUint64'
.file: 'test/lang/initByRef.ci:65'
.value: uint64
.usages:
	test/lang/initByRef.ci:65: defined as `varUint64`
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bd0>
.name: 'varFloat32'
.file: 'test/lang/initByRef.ci:66'
.value: float32
.usages:
	test/lang/initByRef.ci:66: defined as `varFloat32`
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bd8>
.name: 'varFloat64'
.file: 'test/lang/initByRef.ci:67'
.value: float64
.usages:
	test/lang/initByRef.ci:108: referenced as `varFloat64`
	test/lang/initByRef.ci:67: defined as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051be0>
.name: 'varTypename'
.file: 'test/lang/initByRef.ci:68'
.value: typename
.usages:
	test/lang/initByRef.ci:68: defined as `varTypename`
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051be8>
.name: 'varFunction'
.file: 'test/lang/initByRef.ci:69'
.value: function
.usages:
	test/lang/initByRef.ci:69: defined as `varFunction`
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bf0>
.name: 'varPointer'
.file: 'test/lang/initByRef.ci:70'
.value: pointer
.usages:
	test/lang/initByRef.ci:70: defined as `varPointer`
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051bf8>
.name: 'varVariant'
.file: 'test/lang/initByRef.ci:71'
.value: variant
.usages:
	test/lang/initByRef.ci:71: defined as `varVariant`
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051c00>
.name: 'varObject'
.file: 'test/lang/initByRef.ci:72'
.value: object
.usages:
	test/lang/initByRef.ci:72: defined as `varObject`
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c08>
.name: 'typVoid'
.file: 'test/lang/initByRef.ci:75'
.value: void
.usages:
	test/lang/initByRef.ci:75: defined as `typVoid`
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c10>
.name: 'typBool'
.file: 'test/lang/initByRef.ci:76'
.value: bool
.usages:
	test/lang/initByRef.ci:76: defined as `typBool`
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c18>
.name: 'typChar'
.file: 'test/lang/initByRef.ci:77'
.value: char
.usages:
	test/lang/initByRef.ci:77: defined as `typChar`
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c20>
.name: 'typInt8'
.file: 'test/lang/initByRef.ci:78'
.value: int8
.usages:
	test/lang/initByRef.ci:78: defined as `typInt8`
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c28>
.name: 'typInt16'
.file: 'test/lang/initByRef.ci:79'
.value: int16
.usages:
	test/lang/initByRef.ci:79: defined as `typInt16`
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c30>
.name: 'typInt32'
.file: 'test/lang/initByRef.ci:80'
.value: int32
.usages:
	test/lang/initByRef.ci:80: defined as `typInt32`
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c38>
.name: 'typInt64'
.file: 'test/lang/initByRef.ci:81'
.value: int64
.usages:
	test/lang/initByRef.ci:81: defined as `typInt64`
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c40>
.name: 'typUint8'
.file: 'test/lang/initByRef.ci:82'
.value: uint8
.usages:
	test/lang/initByRef.ci:82: defined as `typUint8`
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c48>
.name: 'typUint16'
.file: 'test/lang/initByRef.ci:83'
.value: uint16
.usages:
	test/lang/initByRef.ci:83: defined as `typUint16`
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c50>
.name: 'typUint32'
.file: 'test/lang/initByRef.ci:84'
.value: uint32
.usages:
	test/lang/initByRef.ci:84: defined as `typUint32`
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c58>
.name: 'typUint64'
.file: 'test/lang/initByRef.ci:85'
.value: uint64
.usages:
	test/lang/initByRef.ci:85: defined as `typUint64`
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c60>
.name: 'typFloat32'
.file: 'test/lang/initByRef.ci:86'
.value: float32
.usages:
	test/lang/initByRef.ci:86: defined as `typFloat32`
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c68>
.name: 'typFloat64'
.file: 'test/lang/initByRef.ci:87'
.value: float64
.usages:
	test/lang/initByRef.ci:87: defined as `typFloat64`
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c70>
.name: 'typTypename'
.file: 'test/lang/initByRef.ci:88'
.value: typename
.usages:
	test/lang/initByRef.ci:88: defined as `typTypename`
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c78>
.name: 'typFunction'
.file: 'test/lang/initByRef.ci:89'
.value: function
.usages:
	test/lang/initByRef.ci:89: defined as `typFunction`
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c80>
.name: 'typPointer'
.file: 'test/lang/initByRef.ci:90'
.value: pointer
.usages:
	test/lang/initByRef.ci:90: defined as `typPointer`
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c88>
.name: 'typVariant'
.file: 'test/lang/initByRef.ci:91'
.value: variant
.usages:
	test/lang/initByRef.ci:91: defined as `typVariant`
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051c90>
.name: 'typObject'
.file: 'test/lang/initByRef.ci:92'
.value: object
.usages:
	test/lang/initByRef.ci:92: defined as `typObject`
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051c98>
.name: 'valueOfPtr'
.file: 'test/lang/initByRef.ci:95'
.value: pointer(value)
.usages:
	test/lang/initByRef.ci:95: defined as `valueOfPtr`
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051ca0>
.name: 'valueOfVar'
.file: 'test/lang/initByRef.ci:96'
.value: variant(value)
.usages:
	test/lang/initByRef.ci:96: defined as `valueOfVar`
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051ca8>
.name: 'valueOfTyp'
.file: 'test/lang/initByRef.ci:97'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:97: defined as `valueOfTyp`
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051cb0>
.name: 'typeOfValue'
.file: 'test/lang/initByRef.ci:99'
.value: typename(value)
.usages:
	test/lang/initByRef.ci:99: defined as `typeOfValue`
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@051cb8>
.name: 'copyPtrFloat64'
.file: 'test/lang/initByRef.ci:105'
.value: ptrFloat64
.usages:
	test/lang/initByRef.ci:105: defined as `copyPtrFloat64`
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051cc0>
.name: 'copyVarFloat64'
.file: 'test/lang/initByRef.ci:108'
.value: varFloat64
.usages:
	test/lang/initByRef.ci:108: defined as `copyVarFloat64`
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@051cc8>
.name: 'empty'
.file: 'test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <@051cc8> - <@051cc9>)
	<empty @051cc8>      : 03                         ret
.usages:
	test/lang/function.ci:4: defined as `empty(): void`
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@051cd0>
.name: 'funAdd'
.file: 'test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <@051cd0> - <@051cd8>)
	test/lang/function.ci:8: (8 bytes: <@051cd0> - <@051cd8>): return int32(.result := int32(x + y));
	<funAdd @051cd0>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @051cd2>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @051cd4>    : 51                         add.i32
	<funAdd+5 @051cd5>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @051cd7>    : 03                         ret
.usages:
	test/lang/function.ci:15: referenced as `funAdd`
	test/lang/function.ci:12: referenced as `funAdd`
	test/lang/function.ci:7: defined as `funAdd(x: int32, y: int32): int32`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051cd8>
.name: 'funAddResult'
.file: 'test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
	test/lang/function.ci:12: defined as `funAddResult`
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051ce0>
.name: 'funAddRef'
.file: 'test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	test/lang/function.ci:18: referenced as `funAddRef`
	test/lang/function.ci:15: defined as `funAddRef(x: int32, y: int32): int32`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ce8>
.name: 'funAddRefResult'
.file: 'test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
	test/lang/function.ci:18: defined as `funAddRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051cf0>
.name: 'funMul'
.file: 'test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	test/lang/function.ci:27: referenced as `funMul`
	test/lang/function.ci:24: referenced as `funMul`
	test/lang/function.ci:21: defined as `funMul(x: int32, y: int32): int32`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051cf8>
.name: 'funMulResult'
.file: 'test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
	test/lang/function.ci:24: defined as `funMulResult`
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@051d00>
.name: 'funMulRef'
.file: 'test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	test/lang/function.ci:30: referenced as `funMulRef`
	test/lang/function.ci:27: defined as `funMulRef(x: int32, y: int32): int32`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d08>
.name: 'funMulRefResult'
.file: 'test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
	test/lang/function.ci:30: defined as `funMulRefResult`
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.offset: <@051d10>
.name: 'funMul'
.file: 'test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <@051d10> - <@051d18>)
	test/lang/function.ci:34: (8 bytes: <@051d10> - <@051d18>): return int32(.result := int32(x * y));
	<funMul @051d10>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @051d12>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @051d14>    : 53                         mul.i32
	<funMul+5 @051d15>    : 13 04                      set.x32 sp(4)
	<funMul+7 @051d17>    : 03                         ret
.usages:
	test/lang/function.ci:33: defined as `funMul(x: int32, y: int32): int32`
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 54
.offset: <@051d18>
.name: 'fib'
.file: 'test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <@051d18> - <@051d4e>)
	test/lang/function.ci:39: (16 bytes: <@051d18> - <@051d28>): if (bool(n <= (1)))
	<fib @051d18>      : 10 01                      dup.x32 sp(1)
	<fib+2 @051d1a>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @051d1f>    : 39                         cgt.u32
	<fib+8 @051d20>    : 05 08 00 00                jnz <fib+16 @051d28>
	test/lang/function.ci:40: (4 bytes: <@051d24> - <@051d28>): return uint32(.result := n);
	<fib+12 @051d24>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @051d27>   : 03                         ret
	test/lang/function.ci:42: (38 bytes: <@051d28> - <@051d4e>): return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
	<fib+16 @051d28>   : 19                         load.z32
	<fib+17 @051d29>   : 10 02                      dup.x32 sp(2)
	<fib+19 @051d2b>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @051d2f>   : 1f 18 1d 05 00             load.ref <@051d18> ;fib(n: uint32): uint32
	<fib+28 @051d34>   : 02                         call
	<fib+29 @051d35>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @051d39>   : 19                         load.z32
	<fib+34 @051d3a>   : 10 03                      dup.x32 sp(3)
	<fib+36 @051d3c>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @051d40>   : 1f 18 1d 05 00             load.ref <@051d18> ;fib(n: uint32): uint32
	<fib+45 @051d45>   : 02                         call
	<fib+46 @051d46>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @051d4a>   : 51                         add.i32
	<fib+51 @051d4b>   : 13 03                      set.x32 sp(3)
	<fib+53 @051d4d>   : 03                         ret
.usages:
	test/lang/function.ci:46: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:42: referenced as `fib`
	test/lang/function.ci:38: defined as `fib(n: uint32): uint32`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@051d50>
.name: 'fibonacci_13'
.file: 'test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
	test/lang/function.ci:46: defined as `fibonacci_13`
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d58>
.name: 'sizeofVoid'
.file: 'test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
	test/lang/reflect.ci:3: defined as `sizeofVoid`
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d60>
.name: 'sizeofBool'
.file: 'test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
	test/lang/reflect.ci:4: defined as `sizeofBool`
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d68>
.name: 'sizeofChar'
.file: 'test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
	test/lang/reflect.ci:5: defined as `sizeofChar`
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d70>
.name: 'sizeofInt8'
.file: 'test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
	test/lang/reflect.ci:6: defined as `sizeofInt8`
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d78>
.name: 'sizeofInt16'
.file: 'test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
	test/lang/reflect.ci:7: defined as `sizeofInt16`
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d80>
.name: 'sizeofInt32'
.file: 'test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
	test/lang/reflect.ci:8: defined as `sizeofInt32`
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d88>
.name: 'sizeofInt64'
.file: 'test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
	test/lang/reflect.ci:9: defined as `sizeofInt64`
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d90>
.name: 'sizeofUint8'
.file: 'test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
	test/lang/reflect.ci:10: defined as `sizeofUint8`
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051d98>
.name: 'sizeofUint16'
.file: 'test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
	test/lang/reflect.ci:11: defined as `sizeofUint16`
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051da0>
.name: 'sizeofUint32'
.file: 'test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
	test/lang/reflect.ci:12: defined as `sizeofUint32`
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051da8>
.name: 'sizeofUint64'
.file: 'test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
	test/lang/reflect.ci:13: defined as `sizeofUint64`
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051db0>
.name: 'sizeofFloat32'
.file: 'test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
	test/lang/reflect.ci:14: defined as `sizeofFloat32`
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051db8>
.name: 'sizeofFloat64'
.file: 'test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
	test/lang/reflect.ci:15: defined as `sizeofFloat64`
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051dc0>
.name: 'sizeofPointer'
.file: 'test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
	test/lang/reflect.ci:16: defined as `sizeofPointer`
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051dc8>
.name: 'sizeofVariant'
.file: 'test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
	test/lang/reflect.ci:17: defined as `sizeofVariant`
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051dd0>
.name: 'sizeofTypename'
.file: 'test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
	test/lang/reflect.ci:18: defined as `sizeofTypename`
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051dd8>
.name: 'sizeofFunction'
.file: 'test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
	test/lang/reflect.ci:19: defined as `sizeofFunction`
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051de0>
.name: 'sizeofObject'
.file: 'test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
	test/lang/reflect.ci:20: defined as `sizeofObject`
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@0374b0>
.name: 'RecordSizeof'
.file: 'test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.usages:
	test/lang/reflect.ci:26: referenced as `RecordSizeof`
	test/lang/reflect.ci:22: defined as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
	test/lang/reflect.ci:23: defined as `x`
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@0375e0>
.name: 'RecordSizeofExt'
.file: 'test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.usages:
	test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
	test/lang/reflect.ci:26: defined as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
	test/lang/reflect.ci:27: defined as `y`
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051de8>
.name: 'typeofRecord'
.file: 'test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	test/lang/reflect.ci:37: referenced as `typeofRecord`
	test/lang/reflect.ci:35: referenced as `typeofRecord`
	test/lang/reflect.ci:34: referenced as `typeofRecord`
	test/lang/reflect.ci:33: referenced as `typeofRecord`
	test/lang/reflect.ci:32: referenced as `typeofRecord`
	test/lang/reflect.ci:31: referenced as `typeofRecord`
	test/lang/reflect.ci:30: defined as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051df0>
.name: 'nameOfRecord'
.file: 'test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
	test/lang/reflect.ci:31: defined as `nameOfRecord`
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051df8>
.name: 'offsetOfRecord'
.file: 'test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
	test/lang/reflect.ci:32: defined as `offsetOfRecord`
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e00>
.name: 'sizeOfRecord'
.file: 'test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
	test/lang/reflect.ci:33: defined as `sizeOfRecord`
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051e08>
.name: 'fileOfRecord'
.file: 'test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
	test/lang/reflect.ci:34: defined as `fileOfRecord`
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e10>
.name: 'lineOfRecord'
.file: 'test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
	test/lang/reflect.ci:35: defined as `lineOfRecord`
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051e18>
.name: 'typeofBase'
.file: 'test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	test/lang/reflect.ci:44: referenced as `typeofBase`
	test/lang/reflect.ci:42: referenced as `typeofBase`
	test/lang/reflect.ci:41: referenced as `typeofBase`
	test/lang/reflect.ci:40: referenced as `typeofBase`
	test/lang/reflect.ci:39: referenced as `typeofBase`
	test/lang/reflect.ci:38: referenced as `typeofBase`
	test/lang/reflect.ci:37: defined as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051e20>
.name: 'nameOfBase'
.file: 'test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
	test/lang/reflect.ci:38: defined as `nameOfBase`
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e28>
.name: 'offsetOfBase'
.file: 'test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
	test/lang/reflect.ci:39: defined as `offsetOfBase`
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e30>
.name: 'sizeOfBase'
.file: 'test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
	test/lang/reflect.ci:40: defined as `sizeOfBase`
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@051e38>
.name: 'fileOfBase'
.file: 'test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
	test/lang/reflect.ci:41: defined as `fileOfBase`
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e40>
.name: 'lineOfBase'
.file: 'test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
	test/lang/reflect.ci:42: defined as `lineOfBase`
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051e48>
.name: 'typeofBase1'
.file: 'test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	test/lang/reflect.ci:48: referenced as `typeofBase1`
	test/lang/reflect.ci:46: referenced as `typeofBase1`
	test/lang/reflect.ci:45: referenced as `typeofBase1`
	test/lang/reflect.ci:44: defined as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e50>
.name: 'offsetOfBase1'
.file: 'test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
	test/lang/reflect.ci:45: defined as `offsetOfBase1`
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e58>
.name: 'sizeOfBase1'
.file: 'test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
	test/lang/reflect.ci:46: defined as `sizeOfBase1`
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@051e60>
.name: 'typeofBase2'
.file: 'test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	test/lang/reflect.ci:50: referenced as `typeofBase2`
	test/lang/reflect.ci:49: referenced as `typeofBase2`
	test/lang/reflect.ci:48: defined as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e68>
.name: 'offsetOfBase2'
.file: 'test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
	test/lang/reflect.ci:49: defined as `offsetOfBase2`
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e70>
.name: 'sizeOfBase2'
.file: 'test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
	test/lang/reflect.ci:50: defined as `sizeOfBase2`
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051e78>
.name: 'pi64'
.file: 'test/stdc/number.ci:3'
.value: 3.141593
.usages:
	test/stdc/number.ci:44: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:43: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:42: referenced as `pi64`
	test/stdc/number.ci:39: referenced as `pi64`
	test/stdc/number.ci:38: referenced as `pi64`
	test/stdc/number.ci:37: referenced as `pi64`
	test/stdc/number.ci:6: referenced as `pi64`
	test/stdc/number.ci:3: defined as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051e80>
.name: 'e64'
.file: 'test/stdc/number.ci:4'
.value: 2.718282
.usages:
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:40: referenced as `e64`
	test/stdc/number.ci:7: referenced as `e64`
	test/stdc/number.ci:4: defined as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051e88>
.name: 'pi32'
.file: 'test/stdc/number.ci:6'
.value: pi64
.usages:
	test/stdc/number.ci:53: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:52: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:51: referenced as `pi32`
	test/stdc/number.ci:48: referenced as `pi32`
	test/stdc/number.ci:47: referenced as `pi32`
	test/stdc/number.ci:46: referenced as `pi32`
	test/stdc/number.ci:6: defined as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051e90>
.name: 'e32'
.file: 'test/stdc/number.ci:7'
.value: e64
.usages:
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:49: referenced as `e32`
	test/stdc/number.ci:7: defined as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'test/stdc/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	test/stdc/number.ci:19: referenced as `rgb888`
	test/stdc/number.ci:10: defined as `rgb888(r: int32, g: int32, b: int32): int32`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'test/stdc/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	test/stdc/number.ci:18: referenced as `rgb565`
	test/stdc/number.ci:12: defined as `rgb565(r: int32, g: int32, b: int32): int32`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051e98>
.name: 'r_comp'
.file: 'test/stdc/number.ci:14'
.value: int32(14 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `r_comp`
	test/stdc/number.ci:18: referenced as `r_comp`
	test/stdc/number.ci:14: defined as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ea0>
.name: 'g_comp'
.file: 'test/stdc/number.ci:15'
.value: int32(63 << 2)
.usages:
	test/stdc/number.ci:19: referenced as `g_comp`
	test/stdc/number.ci:18: referenced as `g_comp`
	test/stdc/number.ci:15: defined as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ea8>
.name: 'b_comp'
.file: 'test/stdc/number.ci:16'
.value: int32(31 << 3)
.usages:
	test/stdc/number.ci:19: referenced as `b_comp`
	test/stdc/number.ci:18: referenced as `b_comp`
	test/stdc/number.ci:16: defined as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051eb0>
.name: 'r5g6b5'
.file: 'test/stdc/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:66: referenced as `r5g6b5`
	test/stdc/number.ci:65: referenced as `r5g6b5`
	test/stdc/number.ci:63: referenced as `r5g6b5`
	test/stdc/number.ci:62: referenced as `r5g6b5`
	test/stdc/number.ci:60: referenced as `r5g6b5`
	test/stdc/number.ci:59: referenced as `r5g6b5`
	test/stdc/number.ci:58: referenced as `r5g6b5`
	test/stdc/number.ci:57: referenced as `r5g6b5`
	test/stdc/number.ci:56: referenced as `r5g6b5`
	test/stdc/number.ci:55: referenced as `r5g6b5`
	test/stdc/number.ci:27: referenced as `r5g6b5`
	test/stdc/number.ci:26: referenced as `r5g6b5`
	test/stdc/number.ci:25: referenced as `r5g6b5`
	test/stdc/number.ci:23: referenced as `r5g6b5`
	test/stdc/number.ci:22: referenced as `r5g6b5`
	test/stdc/number.ci:21: referenced as `r5g6b5`
	test/stdc/number.ci:18: defined as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051eb8>
.name: 'r8g8b8'
.file: 'test/stdc/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	test/stdc/number.ci:35: referenced as `r8g8b8`
	test/stdc/number.ci:34: referenced as `r8g8b8`
	test/stdc/number.ci:33: referenced as `r8g8b8`
	test/stdc/number.ci:31: referenced as `r8g8b8`
	test/stdc/number.ci:30: referenced as `r8g8b8`
	test/stdc/number.ci:29: referenced as `r8g8b8`
	test/stdc/number.ci:19: defined as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ec0>
.name: 'zxtR5'
.file: 'test/stdc/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:21: defined as `zxtR5`
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ec8>
.name: 'zxtG6'
.file: 'test/stdc/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:22: defined as `zxtG6`
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ed0>
.name: 'zxtB5'
.file: 'test/stdc/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:23: defined as `zxtB5`
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ed8>
.name: 'sxtR5'
.file: 'test/stdc/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
	test/stdc/number.ci:25: defined as `sxtR5`
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ee0>
.name: 'sxtG6'
.file: 'test/stdc/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
	test/stdc/number.ci:26: defined as `sxtG6`
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ee8>
.name: 'sxtB5'
.file: 'test/stdc/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:27: defined as `sxtB5`
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ef0>
.name: 'zxtR8'
.file: 'test/stdc/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:29: defined as `zxtR8`
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051ef8>
.name: 'zxtG8'
.file: 'test/stdc/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:30: defined as `zxtG8`
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051f00>
.name: 'zxtB8'
.file: 'test/stdc/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:31: defined as `zxtB8`
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051f08>
.name: 'sxtR8'
.file: 'test/stdc/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
	test/stdc/number.ci:33: defined as `sxtR8`
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051f10>
.name: 'sxtG8'
.file: 'test/stdc/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
	test/stdc/number.ci:34: defined as `sxtG8`
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051f18>
.name: 'sxtB8'
.file: 'test/stdc/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
	test/stdc/number.ci:35: defined as `sxtB8`
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f20>
.name: 'testSin_f64'
.file: 'test/stdc/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:37: defined as `testSin_f64`
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f28>
.name: 'testCos_f64'
.file: 'test/stdc/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
	test/stdc/number.ci:38: defined as `testCos_f64`
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f30>
.name: 'testTan_f64'
.file: 'test/stdc/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
	test/stdc/number.ci:39: defined as `testTan_f64`
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f38>
.name: 'testLog_f64'
.file: 'test/stdc/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
	test/stdc/number.ci:40: defined as `testLog_f64`
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f40>
.name: 'testExp_f64'
.file: 'test/stdc/number.ci:41'
.value: float64.exp(1.000000)
.usages:
	test/stdc/number.ci:41: defined as `testExp_f64`
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f48>
.name: 'testPow_f64'
.file: 'test/stdc/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
	test/stdc/number.ci:42: defined as `testPow_f64`
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f50>
.name: 'testSqrt_f64'
.file: 'test/stdc/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
	test/stdc/number.ci:43: defined as `testSqrt_f64`
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@051f58>
.name: 'testAtan_f64'
.file: 'test/stdc/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
	test/stdc/number.ci:44: defined as `testAtan_f64`
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f60>
.name: 'testSin_f32'
.file: 'test/stdc/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:46: defined as `testSin_f32`
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f68>
.name: 'testCos_f32'
.file: 'test/stdc/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
	test/stdc/number.ci:47: defined as `testCos_f32`
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f70>
.name: 'testTan_f32'
.file: 'test/stdc/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
	test/stdc/number.ci:48: defined as `testTan_f32`
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f78>
.name: 'testLog_f32'
.file: 'test/stdc/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
	test/stdc/number.ci:49: defined as `testLog_f32`
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f80>
.name: 'testExp_f32'
.file: 'test/stdc/number.ci:50'
.value: float32.exp(1.000000)
.usages:
	test/stdc/number.ci:50: defined as `testExp_f32`
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f88>
.name: 'testPow_f32'
.file: 'test/stdc/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
	test/stdc/number.ci:51: defined as `testPow_f32`
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f90>
.name: 'testSqrt_f32'
.file: 'test/stdc/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
	test/stdc/number.ci:52: defined as `testSqrt_f32`
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@051f98>
.name: 'testAtan_f32'
.file: 'test/stdc/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
	test/stdc/number.ci:53: defined as `testAtan_f32`
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fa0>
.name: 'testPopulation_u32'
.file: 'test/stdc/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
	test/stdc/number.ci:55: defined as `testPopulation_u32`
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@051fa8>
.name: 'testSwapBits_u32'
.file: 'test/stdc/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
	test/stdc/number.ci:56: defined as `testSwapBits_u32`
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fb0>
.name: 'testBitScanReverse_u32'
.file: 'test/stdc/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
	test/stdc/number.ci:57: defined as `testBitScanReverse_u32`
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fb8>
.name: 'testBitScanForward_u32'
.file: 'test/stdc/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
	test/stdc/number.ci:58: defined as `testBitScanForward_u32`
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fc0>
.name: 'testHighBit_u32'
.file: 'test/stdc/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
	test/stdc/number.ci:59: defined as `testHighBit_u32`
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fc8>
.name: 'testLowBit_u32'
.file: 'test/stdc/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
	test/stdc/number.ci:60: defined as `testLowBit_u32`
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fd0>
.name: 'testZeroExtend_u32'
.file: 'test/stdc/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:62: defined as `testZeroExtend_u32`
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fd8>
.name: 'testSignExtend_u32'
.file: 'test/stdc/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:63: defined as `testSignExtend_u32`
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fe0>
.name: 'testZeroExtend_u64'
.file: 'test/stdc/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:65: defined as `testZeroExtend_u64`
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@051fe8>
.name: 'testSignExtend_u64'
.file: 'test/stdc/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
	test/stdc/number.ci:66: defined as `testSignExtend_u64`
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'test/stdc/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
	test/stdc/memory.ci:3: defined as `realloc(data: pointer, size: int32): pointer`
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'test/stdc/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	test/stdc/memory.ci:10: referenced as `malloc`
	test/stdc/memory.ci:9: referenced as `malloc`
	test/stdc/memory.ci:8: referenced as `malloc`
	test/stdc/memory.ci:7: referenced as `malloc`
	test/stdc/memory.ci:4: defined as `malloc(size: int32): pointer`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'test/stdc/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	test/stdc/memory.ci:20: referenced as `free`
	test/stdc/memory.ci:19: referenced as `free`
	test/stdc/memory.ci:18: referenced as `free`
	test/stdc/memory.ci:17: referenced as `free`
	test/stdc/memory.ci:5: defined as `free(data: pointer): pointer`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051ff0>
.name: 'p1'
.file: 'test/stdc/memory.ci:7'
.value: malloc(1024)
.usages:
	test/stdc/memory.ci:17: referenced as `p1`
	test/stdc/memory.ci:14: referenced as `p1`
	test/stdc/memory.ci:13: referenced as `p1`
	test/stdc/memory.ci:7: defined as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@051ff8>
.name: 'p2'
.file: 'test/stdc/memory.ci:8'
.value: malloc(80)
.usages:
	test/stdc/memory.ci:18: referenced as `p2`
	test/stdc/memory.ci:8: defined as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@052000>
.name: 'p3'
.file: 'test/stdc/memory.ci:9'
.value: malloc(160)
.usages:
	test/stdc/memory.ci:19: referenced as `p3`
	test/stdc/memory.ci:14: referenced as `p3`
	test/stdc/memory.ci:9: defined as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@052008>
.name: 'p4'
.file: 'test/stdc/memory.ci:10'
.value: malloc(820)
.usages:
	test/stdc/memory.ci:20: referenced as `p4`
	test/stdc/memory.ci:10: defined as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052010>
.name: 'val1'
.file: 'test/stdc/memory.ci:23'
.value: 42
.usages:
	test/stdc/memory.ci:32: referenced as `val1`
	test/stdc/memory.ci:30: referenced as `val1`
	test/stdc/memory.ci:29: referenced as `val1`
	test/stdc/memory.ci:26: referenced as `val1`
	test/stdc/memory.ci:23: defined as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052018>
.name: 'val2'
.file: 'test/stdc/memory.ci:24'
.value: 96
.usages:
	test/stdc/memory.ci:33: referenced as `val2`
	test/stdc/memory.ci:29: referenced as `val2`
	test/stdc/memory.ci:27: referenced as `val2`
	test/stdc/memory.ci:24: defined as `val2`
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.offset: <@052020>
.name: 'noError'
.file: 'test/stdc/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <@052020> - <@052021>)
	<noError @052020>      : 03                         ret
.usages:
	test/stdc/tryExec.ci:46: referenced as `noError`
	test/stdc/tryExec.ci:11: defined as `noError(ptr: pointer): void`
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.offset: <@052028>
.name: 'stackOverflow'
.file: 'test/stdc/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes: <@052028> - <@052040>)
	test/stdc/tryExec.ci:15: (4 bytes: <@052028> - <@05202c>): data: uint8[8192]
	<stackOverflow @052028>      : 09 00 20 00                inc.sp(+8192)
	test/stdc/tryExec.ci:16: (15 bytes: <@05202c> - <@05203b>): stackOverflow(ptr);
	<stackOverflow+4 @05202c>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @052030>    : 22                         load.i32
	<stackOverflow+9 @052031>    : 1f 28 20 05 00             load.ref <@052028> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @052036>   : 02                         call
	<stackOverflow+15 @052037>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @05203b>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @05203f>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:48: referenced as `stackOverflow`
	test/stdc/tryExec.ci:16: referenced as `stackOverflow`
	test/stdc/tryExec.ci:14: defined as `stackOverflow(ptr: pointer): void`
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@052040>
.name: 'divisionByZero'
.file: 'test/stdc/tryExec.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <@052040> - <@05204c>)
	test/stdc/tryExec.ci:20: (7 bytes: <@052040> - <@052047>): value: int32 := int32(3 / 0)
	<divisionByZero @052040>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @052045>    : 19                         load.z32
	<divisionByZero+6 @052046>    : 54                         div.i32
	<divisionByZero+7 @052047>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @05204b>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:49: referenced as `divisionByZero`
	test/stdc/tryExec.ci:19: defined as `divisionByZero(args: pointer): void`
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.offset: <@052050>
.name: 'abortExecution'
.file: 'test/stdc/tryExec.ci:23'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <@052050> - <@052094>)
	test/stdc/tryExec.ci:29: (25 bytes: <@052050> - <@052069>): details: NotEquals := {...}
	<abortExecution @052050>      : 09 10 00 00                inc.sp(+16)
	test/stdc/tryExec.ci:30: (7 bytes: <@052054> - <@05205b>): void(details.message := ("assertion failed"));
	<abortExecution+4 @052054>    : 1f a8 ce 00 00             load.ref <@00cea8> ;"assertion failed"
	<abortExecution+9 @052059>    : 13 01                      set.x32 sp(1)
	test/stdc/tryExec.ci:31: (7 bytes: <@05205b> - <@052062>): void(details.expected := 97);
	<abortExecution+11 @05205b>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @052060>   : 13 02                      set.x32 sp(2)
	test/stdc/tryExec.ci:32: (7 bytes: <@052062> - <@052069>): void(details.returned := 77);
	<abortExecution+18 @052062>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @052067>   : 13 03                      set.x32 sp(3)
	test/stdc/tryExec.ci:34: (38 bytes: <@052069> - <@05208f>): abort(void("fatal error", details));
	<abortExecution+25 @052069>   : 1f 50 b2 03 00             load.ref <@03b250> ;"test/stdc/tryExec.ci"
	<abortExecution+30 @05206e>   : 1c 22 00 00 00             load.c32 34
	<abortExecution+35 @052073>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @052078>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @05207d>   : 1f 99 b2 03 00             load.ref <@03b299> ;"fatal error"
	<abortExecution+50 @052082>   : 1f b0 bc 03 00             load.ref <@03bcb0> ;abortExecution.NotEquals
	<abortExecution+55 @052087>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @05208b>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @05208f>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @052093>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:52: referenced as `abortExecution`
	test/stdc/tryExec.ci:23: defined as `abortExecution(args: pointer): void`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.offset: <@052098>
.name: 'invalidMemoryAccess'
.file: 'test/stdc/tryExec.ci:37'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <@052098> - <@0520a5>)
	test/stdc/tryExec.ci:38: (5 bytes: <@052098> - <@05209d>): i32Ref: int32 := null
	<invalidMemoryAccess @052098>      : 1f 00 00 00 00             load.ref <@000000> ;null
	test/stdc/tryExec.ci:39: (3 bytes: <@05209d> - <@0520a0>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @05209d>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @05209f>    : 22                         load.i32
	<invalidMemoryAccess+8 @0520a0>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @0520a4>   : 03                         ret
.usages:
	test/stdc/tryExec.ci:51: referenced as `invalidMemoryAccess`
	test/stdc/tryExec.ci:37: defined as `invalidMemoryAccess(args: pointer): void`
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.offset: <@0520a8>
.name: 'invalidInstruction'
.file: 'test/stdc/tryExec.ci:42'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <@0520a8> - <@0520aa>)
	test/stdc/tryExec.ci:43: (2 bytes: <@0520a8> - <@0520aa>): emit(void(load.z32, ret));
	<invalidInstruction @0520a8>      : 19                         load.z32
	<invalidInstruction+1 @0520a9>    : 03                         ret
.usages:
	test/stdc/tryExec.ci:50: referenced as `invalidInstruction`
	test/stdc/tryExec.ci:42: defined as `invalidInstruction(args: pointer): void`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520b0>
.name: 'tryExecErr0'
.file: 'test/stdc/tryExec.ci:46'
.value: tryExec(void(null, noError))
.usages:
	test/stdc/tryExec.ci:46: defined as `tryExecErr0`
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520b8>
.name: 'tryExecErr1'
.file: 'test/stdc/tryExec.ci:47'
.value: tryExec(void(null, null))
.usages:
	test/stdc/tryExec.ci:47: defined as `tryExecErr1`
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520c0>
.name: 'tryExecErr2'
.file: 'test/stdc/tryExec.ci:48'
.value: tryExec(void(null, stackOverflow))
.usages:
	test/stdc/tryExec.ci:48: defined as `tryExecErr2`
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520c8>
.name: 'tryExecErr3'
.file: 'test/stdc/tryExec.ci:49'
.value: tryExec(void(null, divisionByZero))
.usages:
	test/stdc/tryExec.ci:49: defined as `tryExecErr3`
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520d0>
.name: 'tryExecErr4'
.file: 'test/stdc/tryExec.ci:50'
.value: tryExec(void(null, invalidInstruction))
.usages:
	test/stdc/tryExec.ci:50: defined as `tryExecErr4`
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520d8>
.name: 'tryExecErr5'
.file: 'test/stdc/tryExec.ci:51'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
	test/stdc/tryExec.ci:51: defined as `tryExecErr5`
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0520e0>
.name: 'tryExecErr6'
.file: 'test/stdc/tryExec.ci:52'
.value: tryExec(void(null, abortExecution))
.usages:
	test/stdc/tryExec.ci:52: defined as `tryExecErr6`
}
arrFixedNoInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@0520e8>
.name: 'arrFixedNoInit'
.file: 'test/lang/array.ci:49'
.usages:
	test/lang/array.ci:132: referenced as `arrFixedNoInit`
	test/lang/array.ci:128: referenced as `arrFixedNoInit`
	test/lang/array.ci:124: referenced as `arrFixedNoInit`
	test/lang/array.ci:120: referenced as `arrFixedNoInit`
	test/lang/array.ci:118: referenced as `arrFixedNoInit`
	test/lang/array.ci:116: referenced as `arrFixedNoInit`
	test/lang/array.ci:115: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:114: referenced as `arrFixedNoInit`
	test/lang/array.ci:110: referenced as `arrFixedNoInit`
	test/lang/array.ci:109: referenced as `arrFixedNoInit`
	test/lang/array.ci:108: referenced as `arrFixedNoInit`
	test/lang/array.ci:101: referenced as `arrFixedNoInit`
	test/lang/array.ci:64: referenced as `arrFixedNoInit`
	test/lang/array.ci:63: referenced as `arrFixedNoInit`
	test/lang/array.ci:55: referenced as `arrFixedNoInit`
	test/lang/array.ci:54: referenced as `arrFixedNoInit`
	test/lang/array.ci:49: defined as `arrFixedNoInit`
}
arrArrayNoInit: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@052120>
.name: 'arrArrayNoInit'
.file: 'test/lang/array.ci:50'
.usages:
	test/lang/array.ci:50: defined as `arrArrayNoInit`
}
arrSliceNoInit: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@052128>
.name: 'arrSliceNoInit'
.file: 'test/lang/array.ci:51'
.usages:
	test/lang/array.ci:98: referenced as `arrSliceNoInit`
	test/lang/array.ci:51: defined as `arrSliceNoInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@052130>
.name: 'arrArrayInitNull'
.file: 'test/lang/array.ci:59'
.value: null
.usages:
	test/lang/array.ci:59: defined as `arrArrayInitNull`
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@052138>
.name: 'arrSliceInitNull'
.file: 'test/lang/array.ci:60'
.value: null
.usages:
	test/lang/array.ci:113: referenced as `arrSliceInitNull`
	test/lang/array.ci:99: referenced as `arrSliceInitNull`
	test/lang/array.ci:60: defined as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@052140>
.name: 'arrArrayInitFixed'
.file: 'test/lang/array.ci:63'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:129: referenced as `arrArrayInitFixed`
	test/lang/array.ci:125: referenced as `arrArrayInitFixed`
	test/lang/array.ci:121: referenced as `arrArrayInitFixed`
	test/lang/array.ci:71: referenced as `arrArrayInitFixed`
	test/lang/array.ci:63: defined as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@052148>
.name: 'arrSliceInitFixed'
.file: 'test/lang/array.ci:64'
.value: arrFixedNoInit
.usages:
	test/lang/array.ci:134: referenced as `arrSliceInitFixed`
	test/lang/array.ci:130: referenced as `arrSliceInitFixed`
	test/lang/array.ci:126: referenced as `arrSliceInitFixed`
	test/lang/array.ci:122: referenced as `arrSliceInitFixed`
	test/lang/array.ci:115: referenced as `arrSliceInitFixed`
	test/lang/array.ci:109: referenced as `arrSliceInitFixed`
	test/lang/array.ci:68: referenced as `arrSliceInitFixed`
	test/lang/array.ci:67: referenced as `arrSliceInitFixed`
	test/lang/array.ci:64: defined as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@052150>
.name: 'arrArrayInitSlice'
.file: 'test/lang/array.ci:67'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:67: defined as `arrArrayInitSlice`
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@052158>
.name: 'arrSliceInitSlice'
.file: 'test/lang/array.ci:68'
.value: arrSliceInitFixed
.usages:
	test/lang/array.ci:136: referenced as `arrSliceInitSlice`
	test/lang/array.ci:116: referenced as `arrSliceInitSlice`
	test/lang/array.ci:110: referenced as `arrSliceInitSlice`
	test/lang/array.ci:68: defined as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@052160>
.name: 'arrArrayInitPtr'
.file: 'test/lang/array.ci:71'
.value: arrArrayInitFixed
.usages:
	test/lang/array.ci:71: defined as `arrArrayInitPtr`
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@052168>
.name: 'strFixed'
.file: 'test/lang/array.ci:81'
.usages:
	test/lang/array.ci:84: referenced as `strFixed`
	test/lang/array.ci:83: referenced as `strFixed`
	test/lang/array.ci:82: referenced as `strFixed`
	test/lang/array.ci:81: defined as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@052170>
.name: 'strArray'
.file: 'test/lang/array.ci:86'
.value: "string"
.usages:
	test/lang/array.ci:88: referenced as `strArray`
	test/lang/array.ci:87: referenced as `strArray`
	test/lang/array.ci:86: defined as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@052178>
.name: 'strSlice'
.file: 'test/lang/array.ci:90'
.value: "string"
.usages:
	test/lang/array.ci:92: referenced as `strSlice`
	test/lang/array.ci:91: referenced as `strSlice`
	test/lang/array.ci:90: defined as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 4
.offset: <@052180>
.name: 'lenSlice'
.file: 'test/lang/array.ci:103'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <@052180> - <@052184>)
	test/lang/array.ci:103: (4 bytes: <@052180> - <@052184>): return uint32(.result := values.length);
	<lenSlice @052180>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @052183>    : 03                         ret
.usages:
	test/lang/array.ci:116: referenced as `lenSlice`
	test/lang/array.ci:115: referenced as `lenSlice`
	test/lang/array.ci:114: referenced as `lenSlice`
	test/lang/array.ci:113: referenced as `lenSlice`
	test/lang/array.ci:112: referenced as `lenSlice`
	test/lang/array.ci:103: defined as `lenSlice(values: int64[]): int32`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@052188>
.name: 'nthFixed'
.file: 'test/lang/array.ci:104'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@052188> - <@052194>)
	test/lang/array.ci:104: (12 bytes: <@052188> - <@052194>): return int64(.result := values[idx]);
	<nthFixed @052188>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @05218a>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @05218c>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @052190>    : 23                         load.i64
	<nthFixed+9 @052191>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @052193>   : 03                         ret
.usages:
	test/lang/array.ci:126: referenced as `nthFixed`
	test/lang/array.ci:125: referenced as `nthFixed`
	test/lang/array.ci:124: referenced as `nthFixed`
	test/lang/array.ci:104: defined as `nthFixed(idx: int32, values: int64[7]): int64`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@052198>
.name: 'nthArray'
.file: 'test/lang/array.ci:105'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@052198> - <@0521a4>)
	test/lang/array.ci:105: (12 bytes: <@052198> - <@0521a4>): return int64(.result := values[idx]);
	<nthArray @052198>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @05219a>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @05219c>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @0521a0>    : 23                         load.i64
	<nthArray+9 @0521a1>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @0521a3>   : 03                         ret
.usages:
	test/lang/array.ci:130: referenced as `nthArray`
	test/lang/array.ci:129: referenced as `nthArray`
	test/lang/array.ci:128: referenced as `nthArray`
	test/lang/array.ci:105: defined as `nthArray(idx: int32, values: int64[*]): int64`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.offset: <@0521a8>
.name: 'nthSlice'
.file: 'test/lang/array.ci:106'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <@0521a8> - <@0521b4>)
	test/lang/array.ci:106: (12 bytes: <@0521a8> - <@0521b4>): return int64(.result := values[idx]);
	<nthSlice @0521a8>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @0521aa>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @0521ac>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @0521b0>    : 23                         load.i64
	<nthSlice+9 @0521b1>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @0521b3>   : 03                         ret
.usages:
	test/lang/array.ci:134: referenced as `nthSlice`
	test/lang/array.ci:132: referenced as `nthSlice`
	test/lang/array.ci:106: defined as `nthSlice(idx: int32, values: int64[]): int64`
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@03e9f8>
.name: 'RecordMemberTest'
.file: 'test/lang/member.ci:3'
.field Inner: typename (size: 8, offs: <@03ea90>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@0521b8>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@0521c0>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@0521c8>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@0521d0>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@0521d8>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@0521e0>, cast: static const variable(val))
.usages:
	test/lang/member.ci:53: referenced as `RecordMemberTest`
	test/lang/member.ci:3: defined as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03ea90>
.name: 'Inner'
.file: 'test/lang/member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	test/lang/member.ci:50: referenced as `Inner`
	test/lang/member.ci:47: referenced as `Inner`
	test/lang/member.ci:44: referenced as `Inner`
	test/lang/member.ci:26: referenced as `Inner`
	test/lang/member.ci:23: referenced as `Inner`
	test/lang/member.ci:5: defined as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:65: referenced as `member`
	test/lang/member.ci:60: referenced as `member`
	test/lang/member.ci:50: referenced as `member`
	test/lang/member.ci:47: referenced as `member`
	test/lang/member.ci:6: defined as `member`
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:7'
.owner: RecordMemberTest.Inner
.usages:
	test/lang/member.ci:66: referenced as `constant`
	test/lang/member.ci:61: referenced as `constant`
	test/lang/member.ci:50: referenced as `constant`
	test/lang/member.ci:47: referenced as `constant`
	test/lang/member.ci:7: defined as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'test/lang/member.ci:11'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:54: referenced as `member`
	test/lang/member.ci:11: defined as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'test/lang/member.ci:14'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:55: referenced as `constant`
	test/lang/member.ci:14: defined as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'test/lang/member.ci:17'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:56: referenced as `memberInit`
	test/lang/member.ci:17: defined as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'test/lang/member.ci:20'
.owner: RecordMemberTest
.value: 3
.usages:
	test/lang/member.ci:57: referenced as `constantInit`
	test/lang/member.ci:20: defined as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'test/lang/member.ci:23'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:59: referenced as `memberRec`
	test/lang/member.ci:23: defined as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'test/lang/member.ci:26'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:64: referenced as `constantRec`
	test/lang/member.ci:26: defined as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0521b8>
.name: 'global'
.file: 'test/lang/member.ci:35'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:35: defined as `global`
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0521c0>
.name: 'globalInit'
.file: 'test/lang/member.ci:38'
.owner: RecordMemberTest
.value: 1
.usages:
	test/lang/member.ci:38: defined as `globalInit`
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@0521c8>
.name: 'globalConstant'
.file: 'test/lang/member.ci:41'
.owner: RecordMemberTest
.value: 2
.usages:
	test/lang/member.ci:41: defined as `globalConstant`
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0521d0>
.name: 'globalRec'
.file: 'test/lang/member.ci:44'
.owner: RecordMemberTest
.usages:
	test/lang/member.ci:44: defined as `globalRec`
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0521d8>
.name: 'globalRecInit'
.file: 'test/lang/member.ci:47'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
	test/lang/member.ci:47: defined as `globalRecInit`
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@0521e0>
.name: 'globalConstantRec'
.file: 'test/lang/member.ci:50'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
	test/lang/member.ci:50: defined as `globalConstantRec`
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@0521e8>
.name: 'recordMemberTest'
.file: 'test/lang/member.ci:53'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
	test/lang/member.ci:53: defined as `recordMemberTest`
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@03f8d0>
.name: 'RecordMethodTest'
.file: 'test/lang/method.ci:4'
.field staticMethod: function (size: 39, offs: <@052208>, cast: static const function)
.field forwardMethod: function (size: 4, offs: <@052230>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field virtualMethod: function (size: 39, offs: <@052238>, cast: static const function)
.field forwardMethod: function (size: 39, offs: <@052260>, cast: static const function)
.doc: 'static, virtual and abstract methods'
.usages:
	test/lang/method.ci:102: referenced as `RecordMethodTest`
	test/lang/method.ci:101: referenced as `RecordMethodTest`
	test/lang/method.ci:90: referenced as `RecordMethodTest`
	test/lang/method.ci:87: referenced as `RecordMethodTest`
	test/lang/method.ci:84: referenced as `RecordMethodTest`
	test/lang/method.ci:62: referenced as `RecordMethodTest`
	test/lang/method.ci:57: referenced as `RecordMethodTest`
	test/lang/method.ci:47: referenced as `RecordMethodTest`
	test/lang/method.ci:40: referenced as `RecordMethodTest`
	test/lang/method.ci:32: referenced as `RecordMethodTest`
	test/lang/method.ci:25: referenced as `RecordMethodTest`
	test/lang/method.ci:18: referenced as `RecordMethodTest`
	test/lang/method.ci:10: referenced as `RecordMethodTest`
	test/lang/method.ci:4: defined as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@052208>
.name: 'staticMethod'
.file: 'test/lang/method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <@052208> - <@05222f>)
	test/lang/method.ci:11: (38 bytes: <@052208> - <@05222e>): trace(void("staticMethod", x));
	<staticMethod @052208>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<staticMethod+5 @05220d>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @052212>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @052217>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @05221c>   : 1f ad f4 03 00             load.ref <@03f4ad> ;"staticMethod"
	<staticMethod+25 @052221>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<staticMethod+30 @052226>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @05222a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @05222e>   : 03                         ret
.usages:
	test/lang/method.ci:101: referenced as `staticMethod`
	test/lang/method.ci:87: referenced as `staticMethod`
	test/lang/method.ci:78: referenced as `staticMethod`
	test/lang/method.ci:10: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@052230>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: referenced as `forwardMethod`
	test/lang/method.ci:18: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'test/lang/method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	test/lang/method.ci:64: referenced as `abstractMethod`
	test/lang/method.ci:25: defined as `abstractMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'test/lang/method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	test/lang/method.ci:32: defined as `delegateMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	test/lang/method.ci:103: referenced as `virtualMethod`
	test/lang/method.ci:93: referenced as `virtualMethod`
	test/lang/method.ci:79: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@052238>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <@052238> - <@05225f>)
	test/lang/method.ci:41: (38 bytes: <@052238> - <@05225e>): trace(void("virtualMethod", x));
	<virtualMethod @052238>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<virtualMethod+5 @05223d>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @052242>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @052247>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @05224c>   : 1f 9e f7 03 00             load.ref <@03f79e> ;"virtualMethod"
	<virtualMethod+25 @052251>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<virtualMethod+30 @052256>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @05225a>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @05225e>   : 03                         ret
.usages:
	test/lang/method.ci:102: referenced as `virtualMethod`
	test/lang/method.ci:40: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@052260>
.name: 'forwardMethod'
.file: 'test/lang/method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <@052260> - <@052287>)
	test/lang/method.ci:48: (38 bytes: <@052260> - <@052286>): trace(void("forwardMethod", x));
	<forwardMethod @052260>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<forwardMethod+5 @052265>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @05226a>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @05226f>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @052274>   : 1f 25 f5 03 00             load.ref <@03f525> ;"forwardMethod"
	<forwardMethod+25 @052279>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<forwardMethod+30 @05227e>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @052282>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @052286>   : 03                         ret
.usages:
	test/lang/method.ci:47: defined as `forwardMethod(this: RecordMethodTest, x: int32): void`
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 39
.offset: <@052288>
.name: 'globalFunction'
.file: 'test/lang/method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <@052288> - <@0522af>)
	test/lang/method.ci:58: (38 bytes: <@052288> - <@0522ae>): trace(void("globalFunction", x));
	<globalFunction @052288>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<globalFunction+5 @05228d>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @052292>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @052297>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @05229c>   : 1f d1 f7 03 00             load.ref <@03f7d1> ;"globalFunction"
	<globalFunction+25 @0522a1>   : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<globalFunction+30 @0522a6>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @0522aa>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @0522ae>   : 03                         ret
.usages:
	test/lang/method.ci:64: referenced as `globalFunction`
	test/lang/method.ci:57: defined as `globalFunction(this: RecordMethodTest, x: int32): void`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@0522b0>
.name: 'recordMethodTest'
.file: 'test/lang/method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:103: referenced as `recordMethodTest`
	test/lang/method.ci:102: referenced as `recordMethodTest`
	test/lang/method.ci:101: referenced as `recordMethodTest`
	test/lang/method.ci:98: referenced as `recordMethodTest`
	test/lang/method.ci:97: referenced as `recordMethodTest`
	test/lang/method.ci:79: referenced as `recordMethodTest`
	test/lang/method.ci:78: referenced as `recordMethodTest`
	test/lang/method.ci:62: defined as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 66
.offset: <@0522c0>
.name: 'staticMethod'
.file: 'test/lang/method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <@0522c0> - <@052302>)
	test/lang/method.ci:85: (35 bytes: <@0522c0> - <@0522e3>): debug("extension.staticMethod");
	<staticMethod @0522c0>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<staticMethod+5 @0522c5>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @0522ca>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @0522cf>   : 19                         load.z32
	<staticMethod+16 @0522d0>   : 1f 9f f8 03 00             load.ref <@03f89f> ;"extension.staticMethod"
	<staticMethod+21 @0522d5>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<staticMethod+26 @0522da>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @0522df>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:86: (30 bytes: <@0522e3> - <@052301>): if (bool((this) != null))
	<staticMethod+35 @0522e3>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @0522e7>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @0522ec>   : 57                         ceq.i32
	<staticMethod+45 @0522ed>   : 05 14 00 00                jnz <staticMethod+65 @052301>
	test/lang/method.ci:87: (16 bytes: <@0522f1> - <@052301>): RecordMethodTest.staticMethod(void(this, x));
	<staticMethod+49 @0522f1>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @0522f3>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @0522f5>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @0522f7>   : 1f 08 22 05 00             load.ref <@052208> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @0522fc>   : 02                         call
	<staticMethod+61 @0522fd>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @052301>   : 03                         ret
.usages:
	test/lang/method.ci:97: referenced as `staticMethod`
	test/lang/method.ci:84: defined as `staticMethod(this: RecordMethodTest, x: int32): void`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static const function
.base: `function`
.size: 63
.offset: <@052308>
.name: 'virtualMethod'
.file: 'test/lang/method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <@052308> - <@052347>)
	test/lang/method.ci:91: (35 bytes: <@052308> - <@05232b>): debug("extension.virtualMethod");
	<virtualMethod @052308>      : 1f 10 f4 03 00             load.ref <@03f410> ;"test/lang/method.ci"
	<virtualMethod+5 @05230d>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @052312>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @052317>   : 19                         load.z32
	<virtualMethod+16 @052318>   : 1f b6 f8 03 00             load.ref <@03f8b6> ;"extension.virtualMethod"
	<virtualMethod+21 @05231d>   : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<virtualMethod+26 @052322>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @052327>   : 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/method.ci:92: (27 bytes: <@05232b> - <@052346>): if (bool((this) != null))
	<virtualMethod+35 @05232b>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @05232f>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @052334>   : 57                         ceq.i32
	<virtualMethod+45 @052335>   : 05 11 00 00                jnz <virtualMethod+62 @052346>
	test/lang/method.ci:93: (13 bytes: <@052339> - <@052346>): this.virtualMethod(void(this, x));
	<virtualMethod+49 @052339>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @05233b>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @05233d>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @05233f>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @052341>   : 02                         call
	<virtualMethod+58 @052342>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @052346>   : 03                         ret
.usages:
	test/lang/method.ci:98: referenced as `virtualMethod`
	test/lang/method.ci:90: defined as `virtualMethod(this: RecordMethodTest, x: int32): void`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@041050>
.name: 'rgbF32'
.file: 'test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	test/lang/recUnion.ci:23: referenced as `rgbF32`
	test/lang/recUnion.ci:2: defined as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:3: defined as `r`
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:4: defined as `g`
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
	test/lang/recUnion.ci:5: defined as `b`
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@0412b0>
.name: 'rgbU8'
.file: 'test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	test/lang/recUnion.ci:28: referenced as `rgbU8`
	test/lang/recUnion.ci:27: referenced as `rgbU8`
	test/lang/recUnion.ci:26: referenced as `rgbU8`
	test/lang/recUnion.ci:18: referenced as `rgbU8`
	test/lang/recUnion.ci:9: defined as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `b`
	test/lang/recUnion.ci:28: referenced as `b`
	test/lang/recUnion.ci:27: referenced as `b`
	test/lang/recUnion.ci:26: referenced as `b`
	test/lang/recUnion.ci:10: defined as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `g`
	test/lang/recUnion.ci:28: referenced as `g`
	test/lang/recUnion.ci:27: referenced as `g`
	test/lang/recUnion.ci:26: referenced as `g`
	test/lang/recUnion.ci:11: defined as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	test/lang/recUnion.ci:31: referenced as `r`
	test/lang/recUnion.ci:28: referenced as `r`
	test/lang/recUnion.ci:27: referenced as `r`
	test/lang/recUnion.ci:26: referenced as `r`
	test/lang/recUnion.ci:12: defined as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@041510>
.name: 'color'
.file: 'test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:31: referenced as `color`
	test/lang/recUnion.ci:30: referenced as `color`
	test/lang/recUnion.ci:16: defined as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'test/lang/recUnion.ci:17'
.owner: color
.usages:
	test/lang/recUnion.ci:30: referenced as `col`
	test/lang/recUnion.ci:17: defined as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'test/lang/recUnion.ci:18'
.owner: color
.usages:
	test/lang/recUnion.ci:31: referenced as `rgb`
	test/lang/recUnion.ci:18: defined as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@0416d8>
.name: 'Color'
.file: 'test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.usages:
	test/lang/recUnion.ci:22: defined as `Color`
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'test/lang/recUnion.ci:23'
.owner: Color
.usages:
	test/lang/recUnion.ci:23: defined as `value`
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@052348>
.name: 'black'
.file: 'test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
	test/lang/recUnion.ci:26: defined as `black`
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@052350>
.name: 'green'
.file: 'test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
	test/lang/recUnion.ci:27: defined as `green`
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@052358>
.name: 'white'
.file: 'test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
	test/lang/recUnion.ci:28: defined as `white`
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@052360>
.name: 'cyan'
.file: 'test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
	test/lang/recUnion.ci:30: defined as `cyan`
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@052368>
.name: 'blue'
.file: 'test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
	test/lang/recUnion.ci:31: defined as `blue`
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@041b78>
.name: 'record_pack0'
.file: 'test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:2: defined as `record_pack0`
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:3: defined as `_0`
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:4: defined as `a`
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:5: defined as `_1`
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:6: defined as `b`
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:7: defined as `_2`
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
	test/lang/recPacking.ci:8: defined as `c`
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@041fa0>
.name: 'record_pack1'
.file: 'test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:12: defined as `record_pack1`
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:13: defined as `_0`
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:14: defined as `a`
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:15: defined as `_1`
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:16: defined as `b`
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:17: defined as `_2`
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
	test/lang/recPacking.ci:18: defined as `c`
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@0423c8>
.name: 'record_pack2'
.file: 'test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:22: defined as `record_pack2`
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:23: defined as `_0`
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:24: defined as `a`
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:25: defined as `_1`
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:26: defined as `b`
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:27: defined as `_2`
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
	test/lang/recPacking.ci:28: defined as `c`
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@0427f0>
.name: 'record_pack4'
.file: 'test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:32: defined as `record_pack4`
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:33: defined as `_0`
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:34: defined as `a`
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:35: defined as `_1`
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:36: defined as `b`
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:37: defined as `_2`
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
	test/lang/recPacking.ci:38: defined as `c`
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@042c18>
.name: 'record_pack8'
.file: 'test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:42: defined as `record_pack8`
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:43: defined as `_0`
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:44: defined as `a`
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:45: defined as `_1`
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:46: defined as `b`
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:47: defined as `_2`
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
	test/lang/recPacking.ci:48: defined as `c`
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@043040>
.name: 'record_packDef'
.file: 'test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
	test/lang/recPacking.ci:52: defined as `record_packDef`
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:53: defined as `_0`
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:54: defined as `a`
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:55: defined as `_1`
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:56: defined as `b`
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:57: defined as `_2`
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
	test/lang/recPacking.ci:58: defined as `c`
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	test/lang/useOperator.ci:260: referenced as `a`
	test/lang/useOperator.ci:237: referenced as `a`
	test/lang/useOperator.ci:214: referenced as `a`
	test/lang/useOperator.ci:191: referenced as `a`
	test/lang/useOperator.ci:168: referenced as `a`
	test/lang/useOperator.ci:145: referenced as `a`
	test/lang/useOperator.ci:122: referenced as `a`
	test/lang/useOperator.ci:99: referenced as `a`
	test/lang/useOperator.ci:76: referenced as `a`
	test/lang/useOperator.ci:53: referenced as `a`
	test/lang/useOperator.ci:3: defined as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	test/lang/useOperator.ci:261: referenced as `b`
	test/lang/useOperator.ci:238: referenced as `b`
	test/lang/useOperator.ci:215: referenced as `b`
	test/lang/useOperator.ci:192: referenced as `b`
	test/lang/useOperator.ci:169: referenced as `b`
	test/lang/useOperator.ci:146: referenced as `b`
	test/lang/useOperator.ci:123: referenced as `b`
	test/lang/useOperator.ci:100: referenced as `b`
	test/lang/useOperator.ci:77: referenced as `b`
	test/lang/useOperator.ci:54: referenced as `b`
	test/lang/useOperator.ci:4: defined as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052370>
.name: 'shift'
.file: 'test/lang/useOperator.ci:5'
.value: 2
.usages:
	test/lang/useOperator.ci:284: referenced as `shift`
	test/lang/useOperator.ci:228: referenced as `shift`
	test/lang/useOperator.ci:227: referenced as `shift`
	test/lang/useOperator.ci:205: referenced as `shift`
	test/lang/useOperator.ci:204: referenced as `shift`
	test/lang/useOperator.ci:182: referenced as `shift`
	test/lang/useOperator.ci:181: referenced as `shift`
	test/lang/useOperator.ci:159: referenced as `shift`
	test/lang/useOperator.ci:158: referenced as `shift`
	test/lang/useOperator.ci:136: referenced as `shift`
	test/lang/useOperator.ci:135: referenced as `shift`
	test/lang/useOperator.ci:113: referenced as `shift`
	test/lang/useOperator.ci:112: referenced as `shift`
	test/lang/useOperator.ci:90: referenced as `shift`
	test/lang/useOperator.ci:89: referenced as `shift`
	test/lang/useOperator.ci:67: referenced as `shift`
	test/lang/useOperator.ci:66: referenced as `shift`
	test/lang/useOperator.ci:44: referenced as `shift`
	test/lang/useOperator.ci:43: referenced as `shift`
	test/lang/useOperator.ci:5: defined as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052378>
.name: 'boolA'
.file: 'test/lang/useOperator.ci:7'
.value: true
.usages:
	test/lang/useOperator.ci:28: referenced as `boolA`
	test/lang/useOperator.ci:27: referenced as `boolA`
	test/lang/useOperator.ci:26: referenced as `boolA`
	test/lang/useOperator.ci:25: referenced as `boolA`
	test/lang/useOperator.ci:24: referenced as `boolA`
	test/lang/useOperator.ci:23: referenced as `boolA`
	test/lang/useOperator.ci:19: referenced as `boolA`
	test/lang/useOperator.ci:18: referenced as `boolA`
	test/lang/useOperator.ci:17: referenced as `boolA`
	test/lang/useOperator.ci:7: defined as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052380>
.name: 'boolB'
.file: 'test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	test/lang/useOperator.ci:28: referenced as `boolB`
	test/lang/useOperator.ci:27: referenced as `boolB`
	test/lang/useOperator.ci:26: referenced as `boolB`
	test/lang/useOperator.ci:25: referenced as `boolB`
	test/lang/useOperator.ci:24: referenced as `boolB`
	test/lang/useOperator.ci:23: referenced as `boolB`
	test/lang/useOperator.ci:22: referenced as `boolB`
	test/lang/useOperator.ci:19: referenced as `boolB`
	test/lang/useOperator.ci:18: referenced as `boolB`
	test/lang/useOperator.ci:17: referenced as `boolB`
	test/lang/useOperator.ci:8: defined as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052388>
.name: 'boolAnd'
.file: 'test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
	test/lang/useOperator.ci:17: defined as `boolAnd`
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052390>
.name: 'boolIor'
.file: 'test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
	test/lang/useOperator.ci:18: defined as `boolIor`
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052398>
.name: 'boolXor'
.file: 'test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
	test/lang/useOperator.ci:19: defined as `boolXor`
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523a0>
.name: 'boolNot'
.file: 'test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
	test/lang/useOperator.ci:22: defined as `boolNot`
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523a8>
.name: 'boolCeq'
.file: 'test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
	test/lang/useOperator.ci:23: defined as `boolCeq`
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523b0>
.name: 'boolCne'
.file: 'test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
	test/lang/useOperator.ci:24: defined as `boolCne`
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523b8>
.name: 'boolClt'
.file: 'test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
	test/lang/useOperator.ci:25: defined as `boolClt`
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523c0>
.name: 'boolCle'
.file: 'test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
	test/lang/useOperator.ci:26: defined as `boolCle`
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523c8>
.name: 'boolCgt'
.file: 'test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
	test/lang/useOperator.ci:27: defined as `boolCgt`
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0523d0>
.name: 'boolCge'
.file: 'test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
	test/lang/useOperator.ci:28: defined as `boolCge`
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0523d8>
.name: 'chrA'
.file: 'test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrA`
	test/lang/useOperator.ci:50: referenced as `chrA`
	test/lang/useOperator.ci:49: referenced as `chrA`
	test/lang/useOperator.ci:48: referenced as `chrA`
	test/lang/useOperator.ci:47: referenced as `chrA`
	test/lang/useOperator.ci:46: referenced as `chrA`
	test/lang/useOperator.ci:44: referenced as `chrA`
	test/lang/useOperator.ci:43: referenced as `chrA`
	test/lang/useOperator.ci:42: referenced as `chrA`
	test/lang/useOperator.ci:41: referenced as `chrA`
	test/lang/useOperator.ci:40: referenced as `chrA`
	test/lang/useOperator.ci:39: referenced as `chrA`
	test/lang/useOperator.ci:38: referenced as `chrA`
	test/lang/useOperator.ci:37: referenced as `chrA`
	test/lang/useOperator.ci:36: referenced as `chrA`
	test/lang/useOperator.ci:35: referenced as `chrA`
	test/lang/useOperator.ci:30: defined as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0523e0>
.name: 'chrB'
.file: 'test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	test/lang/useOperator.ci:51: referenced as `chrB`
	test/lang/useOperator.ci:50: referenced as `chrB`
	test/lang/useOperator.ci:49: referenced as `chrB`
	test/lang/useOperator.ci:48: referenced as `chrB`
	test/lang/useOperator.ci:47: referenced as `chrB`
	test/lang/useOperator.ci:46: referenced as `chrB`
	test/lang/useOperator.ci:45: referenced as `chrB`
	test/lang/useOperator.ci:42: referenced as `chrB`
	test/lang/useOperator.ci:41: referenced as `chrB`
	test/lang/useOperator.ci:40: referenced as `chrB`
	test/lang/useOperator.ci:39: referenced as `chrB`
	test/lang/useOperator.ci:38: referenced as `chrB`
	test/lang/useOperator.ci:37: referenced as `chrB`
	test/lang/useOperator.ci:36: referenced as `chrB`
	test/lang/useOperator.ci:35: referenced as `chrB`
	test/lang/useOperator.ci:34: referenced as `chrB`
	test/lang/useOperator.ci:33: referenced as `chrB`
	test/lang/useOperator.ci:32: referenced as `chrB`
	test/lang/useOperator.ci:31: defined as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0523e8>
.name: 'chrPls'
.file: 'test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
	test/lang/useOperator.ci:32: defined as `chrPls`
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0523f0>
.name: 'chrNeg'
.file: 'test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
	test/lang/useOperator.ci:33: defined as `chrNeg`
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@0523f8>
.name: 'chrCmt'
.file: 'test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
	test/lang/useOperator.ci:34: defined as `chrCmt`
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052400>
.name: 'chrAdd'
.file: 'test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
	test/lang/useOperator.ci:35: defined as `chrAdd`
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052408>
.name: 'chrSub'
.file: 'test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
	test/lang/useOperator.ci:36: defined as `chrSub`
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052410>
.name: 'chrMul'
.file: 'test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
	test/lang/useOperator.ci:37: defined as `chrMul`
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052418>
.name: 'chrDiv'
.file: 'test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
	test/lang/useOperator.ci:38: defined as `chrDiv`
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052420>
.name: 'chrMod'
.file: 'test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
	test/lang/useOperator.ci:39: defined as `chrMod`
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052428>
.name: 'chrAnd'
.file: 'test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
	test/lang/useOperator.ci:40: defined as `chrAnd`
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052430>
.name: 'chrIor'
.file: 'test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
	test/lang/useOperator.ci:41: defined as `chrIor`
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052438>
.name: 'chrXor'
.file: 'test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
	test/lang/useOperator.ci:42: defined as `chrXor`
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052440>
.name: 'chrShl'
.file: 'test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
	test/lang/useOperator.ci:43: defined as `chrShl`
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@052448>
.name: 'chrShr'
.file: 'test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
	test/lang/useOperator.ci:44: defined as `chrShr`
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052450>
.name: 'chrNot'
.file: 'test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
	test/lang/useOperator.ci:45: defined as `chrNot`
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052458>
.name: 'chrCeq'
.file: 'test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
	test/lang/useOperator.ci:46: defined as `chrCeq`
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052460>
.name: 'chrCne'
.file: 'test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
	test/lang/useOperator.ci:47: defined as `chrCne`
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052468>
.name: 'chrClt'
.file: 'test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
	test/lang/useOperator.ci:48: defined as `chrClt`
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052470>
.name: 'chrCle'
.file: 'test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
	test/lang/useOperator.ci:49: defined as `chrCle`
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052478>
.name: 'chrCgt'
.file: 'test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
	test/lang/useOperator.ci:50: defined as `chrCgt`
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052480>
.name: 'chrCge'
.file: 'test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
	test/lang/useOperator.ci:51: defined as `chrCge`
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@052488>
.name: 'i8A'
.file: 'test/lang/useOperator.ci:53'
.value: a
.usages:
	test/lang/useOperator.ci:74: referenced as `i8A`
	test/lang/useOperator.ci:73: referenced as `i8A`
	test/lang/useOperator.ci:72: referenced as `i8A`
	test/lang/useOperator.ci:71: referenced as `i8A`
	test/lang/useOperator.ci:70: referenced as `i8A`
	test/lang/useOperator.ci:69: referenced as `i8A`
	test/lang/useOperator.ci:67: referenced as `i8A`
	test/lang/useOperator.ci:66: referenced as `i8A`
	test/lang/useOperator.ci:65: referenced as `i8A`
	test/lang/useOperator.ci:64: referenced as `i8A`
	test/lang/useOperator.ci:63: referenced as `i8A`
	test/lang/useOperator.ci:62: referenced as `i8A`
	test/lang/useOperator.ci:61: referenced as `i8A`
	test/lang/useOperator.ci:60: referenced as `i8A`
	test/lang/useOperator.ci:59: referenced as `i8A`
	test/lang/useOperator.ci:58: referenced as `i8A`
	test/lang/useOperator.ci:53: defined as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@052490>
.name: 'i8B'
.file: 'test/lang/useOperator.ci:54'
.value: b
.usages:
	test/lang/useOperator.ci:74: referenced as `i8B`
	test/lang/useOperator.ci:73: referenced as `i8B`
	test/lang/useOperator.ci:72: referenced as `i8B`
	test/lang/useOperator.ci:71: referenced as `i8B`
	test/lang/useOperator.ci:70: referenced as `i8B`
	test/lang/useOperator.ci:69: referenced as `i8B`
	test/lang/useOperator.ci:68: referenced as `i8B`
	test/lang/useOperator.ci:65: referenced as `i8B`
	test/lang/useOperator.ci:64: referenced as `i8B`
	test/lang/useOperator.ci:63: referenced as `i8B`
	test/lang/useOperator.ci:62: referenced as `i8B`
	test/lang/useOperator.ci:61: referenced as `i8B`
	test/lang/useOperator.ci:60: referenced as `i8B`
	test/lang/useOperator.ci:59: referenced as `i8B`
	test/lang/useOperator.ci:58: referenced as `i8B`
	test/lang/useOperator.ci:57: referenced as `i8B`
	test/lang/useOperator.ci:56: referenced as `i8B`
	test/lang/useOperator.ci:55: referenced as `i8B`
	test/lang/useOperator.ci:54: defined as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@052498>
.name: 'i8Pls'
.file: 'test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
	test/lang/useOperator.ci:55: defined as `i8Pls`
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524a0>
.name: 'i8Neg'
.file: 'test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
	test/lang/useOperator.ci:56: defined as `i8Neg`
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524a8>
.name: 'i8Cmt'
.file: 'test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
	test/lang/useOperator.ci:57: defined as `i8Cmt`
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524b0>
.name: 'i8Add'
.file: 'test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
	test/lang/useOperator.ci:58: defined as `i8Add`
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524b8>
.name: 'i8Sub'
.file: 'test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
	test/lang/useOperator.ci:59: defined as `i8Sub`
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524c0>
.name: 'i8Mul'
.file: 'test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
	test/lang/useOperator.ci:60: defined as `i8Mul`
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524c8>
.name: 'i8Div'
.file: 'test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
	test/lang/useOperator.ci:61: defined as `i8Div`
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524d0>
.name: 'i8Mod'
.file: 'test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
	test/lang/useOperator.ci:62: defined as `i8Mod`
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524d8>
.name: 'i8And'
.file: 'test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
	test/lang/useOperator.ci:63: defined as `i8And`
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524e0>
.name: 'i8Ior'
.file: 'test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
	test/lang/useOperator.ci:64: defined as `i8Ior`
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524e8>
.name: 'i8Xor'
.file: 'test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
	test/lang/useOperator.ci:65: defined as `i8Xor`
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524f0>
.name: 'i8Shl'
.file: 'test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
	test/lang/useOperator.ci:66: defined as `i8Shl`
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@0524f8>
.name: 'i8Shr'
.file: 'test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
	test/lang/useOperator.ci:67: defined as `i8Shr`
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052500>
.name: 'i8Not'
.file: 'test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
	test/lang/useOperator.ci:68: defined as `i8Not`
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052508>
.name: 'i8Ceq'
.file: 'test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
	test/lang/useOperator.ci:69: defined as `i8Ceq`
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052510>
.name: 'i8Cne'
.file: 'test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
	test/lang/useOperator.ci:70: defined as `i8Cne`
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052518>
.name: 'i8Clt'
.file: 'test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
	test/lang/useOperator.ci:71: defined as `i8Clt`
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052520>
.name: 'i8Cle'
.file: 'test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
	test/lang/useOperator.ci:72: defined as `i8Cle`
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052528>
.name: 'i8Cgt'
.file: 'test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
	test/lang/useOperator.ci:73: defined as `i8Cgt`
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052530>
.name: 'i8Cge'
.file: 'test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
	test/lang/useOperator.ci:74: defined as `i8Cge`
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052538>
.name: 'u8A'
.file: 'test/lang/useOperator.ci:76'
.value: a
.usages:
	test/lang/useOperator.ci:97: referenced as `u8A`
	test/lang/useOperator.ci:96: referenced as `u8A`
	test/lang/useOperator.ci:95: referenced as `u8A`
	test/lang/useOperator.ci:94: referenced as `u8A`
	test/lang/useOperator.ci:93: referenced as `u8A`
	test/lang/useOperator.ci:92: referenced as `u8A`
	test/lang/useOperator.ci:90: referenced as `u8A`
	test/lang/useOperator.ci:89: referenced as `u8A`
	test/lang/useOperator.ci:88: referenced as `u8A`
	test/lang/useOperator.ci:87: referenced as `u8A`
	test/lang/useOperator.ci:86: referenced as `u8A`
	test/lang/useOperator.ci:85: referenced as `u8A`
	test/lang/useOperator.ci:84: referenced as `u8A`
	test/lang/useOperator.ci:83: referenced as `u8A`
	test/lang/useOperator.ci:82: referenced as `u8A`
	test/lang/useOperator.ci:81: referenced as `u8A`
	test/lang/useOperator.ci:76: defined as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052540>
.name: 'u8B'
.file: 'test/lang/useOperator.ci:77'
.value: b
.usages:
	test/lang/useOperator.ci:97: referenced as `u8B`
	test/lang/useOperator.ci:96: referenced as `u8B`
	test/lang/useOperator.ci:95: referenced as `u8B`
	test/lang/useOperator.ci:94: referenced as `u8B`
	test/lang/useOperator.ci:93: referenced as `u8B`
	test/lang/useOperator.ci:92: referenced as `u8B`
	test/lang/useOperator.ci:91: referenced as `u8B`
	test/lang/useOperator.ci:88: referenced as `u8B`
	test/lang/useOperator.ci:87: referenced as `u8B`
	test/lang/useOperator.ci:86: referenced as `u8B`
	test/lang/useOperator.ci:85: referenced as `u8B`
	test/lang/useOperator.ci:84: referenced as `u8B`
	test/lang/useOperator.ci:83: referenced as `u8B`
	test/lang/useOperator.ci:82: referenced as `u8B`
	test/lang/useOperator.ci:81: referenced as `u8B`
	test/lang/useOperator.ci:80: referenced as `u8B`
	test/lang/useOperator.ci:79: referenced as `u8B`
	test/lang/useOperator.ci:78: referenced as `u8B`
	test/lang/useOperator.ci:77: defined as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052548>
.name: 'u8Pls'
.file: 'test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
	test/lang/useOperator.ci:78: defined as `u8Pls`
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052550>
.name: 'u8Neg'
.file: 'test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
	test/lang/useOperator.ci:79: defined as `u8Neg`
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052558>
.name: 'u8Cmt'
.file: 'test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
	test/lang/useOperator.ci:80: defined as `u8Cmt`
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052560>
.name: 'u8Add'
.file: 'test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
	test/lang/useOperator.ci:81: defined as `u8Add`
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052568>
.name: 'u8Sub'
.file: 'test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
	test/lang/useOperator.ci:82: defined as `u8Sub`
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052570>
.name: 'u8Mul'
.file: 'test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
	test/lang/useOperator.ci:83: defined as `u8Mul`
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052578>
.name: 'u8Div'
.file: 'test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
	test/lang/useOperator.ci:84: defined as `u8Div`
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052580>
.name: 'u8Mod'
.file: 'test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
	test/lang/useOperator.ci:85: defined as `u8Mod`
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052588>
.name: 'u8And'
.file: 'test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
	test/lang/useOperator.ci:86: defined as `u8And`
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052590>
.name: 'u8Ior'
.file: 'test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
	test/lang/useOperator.ci:87: defined as `u8Ior`
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@052598>
.name: 'u8Xor'
.file: 'test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
	test/lang/useOperator.ci:88: defined as `u8Xor`
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0525a0>
.name: 'u8Shl'
.file: 'test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
	test/lang/useOperator.ci:89: defined as `u8Shl`
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@0525a8>
.name: 'u8Shr'
.file: 'test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
	test/lang/useOperator.ci:90: defined as `u8Shr`
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525b0>
.name: 'u8Not'
.file: 'test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
	test/lang/useOperator.ci:91: defined as `u8Not`
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525b8>
.name: 'u8Ceq'
.file: 'test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
	test/lang/useOperator.ci:92: defined as `u8Ceq`
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525c0>
.name: 'u8Cne'
.file: 'test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
	test/lang/useOperator.ci:93: defined as `u8Cne`
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525c8>
.name: 'u8Clt'
.file: 'test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
	test/lang/useOperator.ci:94: defined as `u8Clt`
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525d0>
.name: 'u8Cle'
.file: 'test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
	test/lang/useOperator.ci:95: defined as `u8Cle`
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525d8>
.name: 'u8Cgt'
.file: 'test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
	test/lang/useOperator.ci:96: defined as `u8Cgt`
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0525e0>
.name: 'u8Cge'
.file: 'test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
	test/lang/useOperator.ci:97: defined as `u8Cge`
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0525e8>
.name: 'i16A'
.file: 'test/lang/useOperator.ci:99'
.value: a
.usages:
	test/lang/useOperator.ci:120: referenced as `i16A`
	test/lang/useOperator.ci:119: referenced as `i16A`
	test/lang/useOperator.ci:118: referenced as `i16A`
	test/lang/useOperator.ci:117: referenced as `i16A`
	test/lang/useOperator.ci:116: referenced as `i16A`
	test/lang/useOperator.ci:115: referenced as `i16A`
	test/lang/useOperator.ci:113: referenced as `i16A`
	test/lang/useOperator.ci:112: referenced as `i16A`
	test/lang/useOperator.ci:111: referenced as `i16A`
	test/lang/useOperator.ci:110: referenced as `i16A`
	test/lang/useOperator.ci:109: referenced as `i16A`
	test/lang/useOperator.ci:108: referenced as `i16A`
	test/lang/useOperator.ci:107: referenced as `i16A`
	test/lang/useOperator.ci:106: referenced as `i16A`
	test/lang/useOperator.ci:105: referenced as `i16A`
	test/lang/useOperator.ci:104: referenced as `i16A`
	test/lang/useOperator.ci:99: defined as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0525f0>
.name: 'i16B'
.file: 'test/lang/useOperator.ci:100'
.value: b
.usages:
	test/lang/useOperator.ci:120: referenced as `i16B`
	test/lang/useOperator.ci:119: referenced as `i16B`
	test/lang/useOperator.ci:118: referenced as `i16B`
	test/lang/useOperator.ci:117: referenced as `i16B`
	test/lang/useOperator.ci:116: referenced as `i16B`
	test/lang/useOperator.ci:115: referenced as `i16B`
	test/lang/useOperator.ci:114: referenced as `i16B`
	test/lang/useOperator.ci:111: referenced as `i16B`
	test/lang/useOperator.ci:110: referenced as `i16B`
	test/lang/useOperator.ci:109: referenced as `i16B`
	test/lang/useOperator.ci:108: referenced as `i16B`
	test/lang/useOperator.ci:107: referenced as `i16B`
	test/lang/useOperator.ci:106: referenced as `i16B`
	test/lang/useOperator.ci:105: referenced as `i16B`
	test/lang/useOperator.ci:104: referenced as `i16B`
	test/lang/useOperator.ci:103: referenced as `i16B`
	test/lang/useOperator.ci:102: referenced as `i16B`
	test/lang/useOperator.ci:101: referenced as `i16B`
	test/lang/useOperator.ci:100: defined as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@0525f8>
.name: 'i16Pls'
.file: 'test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
	test/lang/useOperator.ci:101: defined as `i16Pls`
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052600>
.name: 'i16Neg'
.file: 'test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
	test/lang/useOperator.ci:102: defined as `i16Neg`
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052608>
.name: 'i16Cmt'
.file: 'test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
	test/lang/useOperator.ci:103: defined as `i16Cmt`
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052610>
.name: 'i16Add'
.file: 'test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
	test/lang/useOperator.ci:104: defined as `i16Add`
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052618>
.name: 'i16Sub'
.file: 'test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
	test/lang/useOperator.ci:105: defined as `i16Sub`
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052620>
.name: 'i16Mul'
.file: 'test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
	test/lang/useOperator.ci:106: defined as `i16Mul`
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052628>
.name: 'i16Div'
.file: 'test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
	test/lang/useOperator.ci:107: defined as `i16Div`
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052630>
.name: 'i16Mod'
.file: 'test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
	test/lang/useOperator.ci:108: defined as `i16Mod`
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052638>
.name: 'i16And'
.file: 'test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
	test/lang/useOperator.ci:109: defined as `i16And`
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052640>
.name: 'i16Ior'
.file: 'test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
	test/lang/useOperator.ci:110: defined as `i16Ior`
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052648>
.name: 'i16Xor'
.file: 'test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
	test/lang/useOperator.ci:111: defined as `i16Xor`
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052650>
.name: 'i16Shl'
.file: 'test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
	test/lang/useOperator.ci:112: defined as `i16Shl`
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@052658>
.name: 'i16Shr'
.file: 'test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
	test/lang/useOperator.ci:113: defined as `i16Shr`
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052660>
.name: 'i16Not'
.file: 'test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
	test/lang/useOperator.ci:114: defined as `i16Not`
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052668>
.name: 'i16Ceq'
.file: 'test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
	test/lang/useOperator.ci:115: defined as `i16Ceq`
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052670>
.name: 'i16Cne'
.file: 'test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
	test/lang/useOperator.ci:116: defined as `i16Cne`
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052678>
.name: 'i16Clt'
.file: 'test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
	test/lang/useOperator.ci:117: defined as `i16Clt`
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052680>
.name: 'i16Cle'
.file: 'test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
	test/lang/useOperator.ci:118: defined as `i16Cle`
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052688>
.name: 'i16Cgt'
.file: 'test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
	test/lang/useOperator.ci:119: defined as `i16Cgt`
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052690>
.name: 'i16Cge'
.file: 'test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
	test/lang/useOperator.ci:120: defined as `i16Cge`
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052698>
.name: 'u16A'
.file: 'test/lang/useOperator.ci:122'
.value: a
.usages:
	test/lang/useOperator.ci:143: referenced as `u16A`
	test/lang/useOperator.ci:142: referenced as `u16A`
	test/lang/useOperator.ci:141: referenced as `u16A`
	test/lang/useOperator.ci:140: referenced as `u16A`
	test/lang/useOperator.ci:139: referenced as `u16A`
	test/lang/useOperator.ci:138: referenced as `u16A`
	test/lang/useOperator.ci:136: referenced as `u16A`
	test/lang/useOperator.ci:135: referenced as `u16A`
	test/lang/useOperator.ci:134: referenced as `u16A`
	test/lang/useOperator.ci:133: referenced as `u16A`
	test/lang/useOperator.ci:132: referenced as `u16A`
	test/lang/useOperator.ci:131: referenced as `u16A`
	test/lang/useOperator.ci:130: referenced as `u16A`
	test/lang/useOperator.ci:129: referenced as `u16A`
	test/lang/useOperator.ci:128: referenced as `u16A`
	test/lang/useOperator.ci:127: referenced as `u16A`
	test/lang/useOperator.ci:122: defined as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526a0>
.name: 'u16B'
.file: 'test/lang/useOperator.ci:123'
.value: b
.usages:
	test/lang/useOperator.ci:143: referenced as `u16B`
	test/lang/useOperator.ci:142: referenced as `u16B`
	test/lang/useOperator.ci:141: referenced as `u16B`
	test/lang/useOperator.ci:140: referenced as `u16B`
	test/lang/useOperator.ci:139: referenced as `u16B`
	test/lang/useOperator.ci:138: referenced as `u16B`
	test/lang/useOperator.ci:137: referenced as `u16B`
	test/lang/useOperator.ci:134: referenced as `u16B`
	test/lang/useOperator.ci:133: referenced as `u16B`
	test/lang/useOperator.ci:132: referenced as `u16B`
	test/lang/useOperator.ci:131: referenced as `u16B`
	test/lang/useOperator.ci:130: referenced as `u16B`
	test/lang/useOperator.ci:129: referenced as `u16B`
	test/lang/useOperator.ci:128: referenced as `u16B`
	test/lang/useOperator.ci:127: referenced as `u16B`
	test/lang/useOperator.ci:126: referenced as `u16B`
	test/lang/useOperator.ci:125: referenced as `u16B`
	test/lang/useOperator.ci:124: referenced as `u16B`
	test/lang/useOperator.ci:123: defined as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526a8>
.name: 'u16Pls'
.file: 'test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
	test/lang/useOperator.ci:124: defined as `u16Pls`
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526b0>
.name: 'u16Neg'
.file: 'test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
	test/lang/useOperator.ci:125: defined as `u16Neg`
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526b8>
.name: 'u16Cmt'
.file: 'test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
	test/lang/useOperator.ci:126: defined as `u16Cmt`
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526c0>
.name: 'u16Add'
.file: 'test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
	test/lang/useOperator.ci:127: defined as `u16Add`
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526c8>
.name: 'u16Sub'
.file: 'test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
	test/lang/useOperator.ci:128: defined as `u16Sub`
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526d0>
.name: 'u16Mul'
.file: 'test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
	test/lang/useOperator.ci:129: defined as `u16Mul`
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526d8>
.name: 'u16Div'
.file: 'test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
	test/lang/useOperator.ci:130: defined as `u16Div`
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526e0>
.name: 'u16Mod'
.file: 'test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
	test/lang/useOperator.ci:131: defined as `u16Mod`
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526e8>
.name: 'u16And'
.file: 'test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
	test/lang/useOperator.ci:132: defined as `u16And`
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526f0>
.name: 'u16Ior'
.file: 'test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
	test/lang/useOperator.ci:133: defined as `u16Ior`
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0526f8>
.name: 'u16Xor'
.file: 'test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
	test/lang/useOperator.ci:134: defined as `u16Xor`
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052700>
.name: 'u16Shl'
.file: 'test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
	test/lang/useOperator.ci:135: defined as `u16Shl`
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@052708>
.name: 'u16Shr'
.file: 'test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
	test/lang/useOperator.ci:136: defined as `u16Shr`
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052710>
.name: 'u16Not'
.file: 'test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
	test/lang/useOperator.ci:137: defined as `u16Not`
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052718>
.name: 'u16Ceq'
.file: 'test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
	test/lang/useOperator.ci:138: defined as `u16Ceq`
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052720>
.name: 'u16Cne'
.file: 'test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
	test/lang/useOperator.ci:139: defined as `u16Cne`
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052728>
.name: 'u16Clt'
.file: 'test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
	test/lang/useOperator.ci:140: defined as `u16Clt`
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052730>
.name: 'u16Cle'
.file: 'test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
	test/lang/useOperator.ci:141: defined as `u16Cle`
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052738>
.name: 'u16Cgt'
.file: 'test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
	test/lang/useOperator.ci:142: defined as `u16Cgt`
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052740>
.name: 'u16Cge'
.file: 'test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
	test/lang/useOperator.ci:143: defined as `u16Cge`
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052748>
.name: 'i32A'
.file: 'test/lang/useOperator.ci:145'
.value: a
.usages:
	test/lang/useOperator.ci:166: referenced as `i32A`
	test/lang/useOperator.ci:165: referenced as `i32A`
	test/lang/useOperator.ci:164: referenced as `i32A`
	test/lang/useOperator.ci:163: referenced as `i32A`
	test/lang/useOperator.ci:162: referenced as `i32A`
	test/lang/useOperator.ci:161: referenced as `i32A`
	test/lang/useOperator.ci:159: referenced as `i32A`
	test/lang/useOperator.ci:158: referenced as `i32A`
	test/lang/useOperator.ci:157: referenced as `i32A`
	test/lang/useOperator.ci:156: referenced as `i32A`
	test/lang/useOperator.ci:155: referenced as `i32A`
	test/lang/useOperator.ci:154: referenced as `i32A`
	test/lang/useOperator.ci:153: referenced as `i32A`
	test/lang/useOperator.ci:152: referenced as `i32A`
	test/lang/useOperator.ci:151: referenced as `i32A`
	test/lang/useOperator.ci:150: referenced as `i32A`
	test/lang/useOperator.ci:145: defined as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052750>
.name: 'i32B'
.file: 'test/lang/useOperator.ci:146'
.value: b
.usages:
	test/lang/useOperator.ci:166: referenced as `i32B`
	test/lang/useOperator.ci:165: referenced as `i32B`
	test/lang/useOperator.ci:164: referenced as `i32B`
	test/lang/useOperator.ci:163: referenced as `i32B`
	test/lang/useOperator.ci:162: referenced as `i32B`
	test/lang/useOperator.ci:161: referenced as `i32B`
	test/lang/useOperator.ci:160: referenced as `i32B`
	test/lang/useOperator.ci:157: referenced as `i32B`
	test/lang/useOperator.ci:156: referenced as `i32B`
	test/lang/useOperator.ci:155: referenced as `i32B`
	test/lang/useOperator.ci:154: referenced as `i32B`
	test/lang/useOperator.ci:153: referenced as `i32B`
	test/lang/useOperator.ci:152: referenced as `i32B`
	test/lang/useOperator.ci:151: referenced as `i32B`
	test/lang/useOperator.ci:150: referenced as `i32B`
	test/lang/useOperator.ci:149: referenced as `i32B`
	test/lang/useOperator.ci:148: referenced as `i32B`
	test/lang/useOperator.ci:147: referenced as `i32B`
	test/lang/useOperator.ci:146: defined as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052758>
.name: 'i32Pls'
.file: 'test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
	test/lang/useOperator.ci:147: defined as `i32Pls`
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052760>
.name: 'i32Neg'
.file: 'test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
	test/lang/useOperator.ci:148: defined as `i32Neg`
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052768>
.name: 'i32Cmt'
.file: 'test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
	test/lang/useOperator.ci:149: defined as `i32Cmt`
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052770>
.name: 'i32Add'
.file: 'test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
	test/lang/useOperator.ci:150: defined as `i32Add`
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052778>
.name: 'i32Sub'
.file: 'test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
	test/lang/useOperator.ci:151: defined as `i32Sub`
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052780>
.name: 'i32Mul'
.file: 'test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
	test/lang/useOperator.ci:152: defined as `i32Mul`
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052788>
.name: 'i32Div'
.file: 'test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
	test/lang/useOperator.ci:153: defined as `i32Div`
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052790>
.name: 'i32Mod'
.file: 'test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
	test/lang/useOperator.ci:154: defined as `i32Mod`
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052798>
.name: 'i32And'
.file: 'test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
	test/lang/useOperator.ci:155: defined as `i32And`
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0527a0>
.name: 'i32Ior'
.file: 'test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
	test/lang/useOperator.ci:156: defined as `i32Ior`
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0527a8>
.name: 'i32Xor'
.file: 'test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
	test/lang/useOperator.ci:157: defined as `i32Xor`
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0527b0>
.name: 'i32Shl'
.file: 'test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
	test/lang/useOperator.ci:158: defined as `i32Shl`
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0527b8>
.name: 'i32Shr'
.file: 'test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
	test/lang/useOperator.ci:159: defined as `i32Shr`
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527c0>
.name: 'i32Not'
.file: 'test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
	test/lang/useOperator.ci:160: defined as `i32Not`
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527c8>
.name: 'i32Ceq'
.file: 'test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
	test/lang/useOperator.ci:161: defined as `i32Ceq`
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527d0>
.name: 'i32Cne'
.file: 'test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
	test/lang/useOperator.ci:162: defined as `i32Cne`
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527d8>
.name: 'i32Clt'
.file: 'test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
	test/lang/useOperator.ci:163: defined as `i32Clt`
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527e0>
.name: 'i32Cle'
.file: 'test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
	test/lang/useOperator.ci:164: defined as `i32Cle`
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527e8>
.name: 'i32Cgt'
.file: 'test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
	test/lang/useOperator.ci:165: defined as `i32Cgt`
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0527f0>
.name: 'i32Cge'
.file: 'test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
	test/lang/useOperator.ci:166: defined as `i32Cge`
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0527f8>
.name: 'u32A'
.file: 'test/lang/useOperator.ci:168'
.value: a
.usages:
	test/lang/useOperator.ci:189: referenced as `u32A`
	test/lang/useOperator.ci:188: referenced as `u32A`
	test/lang/useOperator.ci:187: referenced as `u32A`
	test/lang/useOperator.ci:186: referenced as `u32A`
	test/lang/useOperator.ci:185: referenced as `u32A`
	test/lang/useOperator.ci:184: referenced as `u32A`
	test/lang/useOperator.ci:182: referenced as `u32A`
	test/lang/useOperator.ci:181: referenced as `u32A`
	test/lang/useOperator.ci:180: referenced as `u32A`
	test/lang/useOperator.ci:179: referenced as `u32A`
	test/lang/useOperator.ci:178: referenced as `u32A`
	test/lang/useOperator.ci:177: referenced as `u32A`
	test/lang/useOperator.ci:176: referenced as `u32A`
	test/lang/useOperator.ci:175: referenced as `u32A`
	test/lang/useOperator.ci:174: referenced as `u32A`
	test/lang/useOperator.ci:173: referenced as `u32A`
	test/lang/useOperator.ci:168: defined as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052800>
.name: 'u32B'
.file: 'test/lang/useOperator.ci:169'
.value: b
.usages:
	test/lang/useOperator.ci:189: referenced as `u32B`
	test/lang/useOperator.ci:188: referenced as `u32B`
	test/lang/useOperator.ci:187: referenced as `u32B`
	test/lang/useOperator.ci:186: referenced as `u32B`
	test/lang/useOperator.ci:185: referenced as `u32B`
	test/lang/useOperator.ci:184: referenced as `u32B`
	test/lang/useOperator.ci:183: referenced as `u32B`
	test/lang/useOperator.ci:180: referenced as `u32B`
	test/lang/useOperator.ci:179: referenced as `u32B`
	test/lang/useOperator.ci:178: referenced as `u32B`
	test/lang/useOperator.ci:177: referenced as `u32B`
	test/lang/useOperator.ci:176: referenced as `u32B`
	test/lang/useOperator.ci:175: referenced as `u32B`
	test/lang/useOperator.ci:174: referenced as `u32B`
	test/lang/useOperator.ci:173: referenced as `u32B`
	test/lang/useOperator.ci:172: referenced as `u32B`
	test/lang/useOperator.ci:171: referenced as `u32B`
	test/lang/useOperator.ci:170: referenced as `u32B`
	test/lang/useOperator.ci:169: defined as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052808>
.name: 'u32Pls'
.file: 'test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
	test/lang/useOperator.ci:170: defined as `u32Pls`
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052810>
.name: 'u32Neg'
.file: 'test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
	test/lang/useOperator.ci:171: defined as `u32Neg`
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052818>
.name: 'u32Cmt'
.file: 'test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
	test/lang/useOperator.ci:172: defined as `u32Cmt`
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052820>
.name: 'u32Add'
.file: 'test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
	test/lang/useOperator.ci:173: defined as `u32Add`
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052828>
.name: 'u32Sub'
.file: 'test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
	test/lang/useOperator.ci:174: defined as `u32Sub`
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052830>
.name: 'u32Mul'
.file: 'test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
	test/lang/useOperator.ci:175: defined as `u32Mul`
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052838>
.name: 'u32Div'
.file: 'test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
	test/lang/useOperator.ci:176: defined as `u32Div`
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052840>
.name: 'u32Mod'
.file: 'test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
	test/lang/useOperator.ci:177: defined as `u32Mod`
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052848>
.name: 'u32And'
.file: 'test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
	test/lang/useOperator.ci:178: defined as `u32And`
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052850>
.name: 'u32Ior'
.file: 'test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
	test/lang/useOperator.ci:179: defined as `u32Ior`
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052858>
.name: 'u32Xor'
.file: 'test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
	test/lang/useOperator.ci:180: defined as `u32Xor`
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052860>
.name: 'u32Shl'
.file: 'test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
	test/lang/useOperator.ci:181: defined as `u32Shl`
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@052868>
.name: 'u32Shr'
.file: 'test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
	test/lang/useOperator.ci:182: defined as `u32Shr`
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052870>
.name: 'u32Not'
.file: 'test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
	test/lang/useOperator.ci:183: defined as `u32Not`
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052878>
.name: 'u32Ceq'
.file: 'test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
	test/lang/useOperator.ci:184: defined as `u32Ceq`
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052880>
.name: 'u32Cne'
.file: 'test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
	test/lang/useOperator.ci:185: defined as `u32Cne`
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052888>
.name: 'u32Clt'
.file: 'test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
	test/lang/useOperator.ci:186: defined as `u32Clt`
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052890>
.name: 'u32Cle'
.file: 'test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
	test/lang/useOperator.ci:187: defined as `u32Cle`
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052898>
.name: 'u32Cgt'
.file: 'test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
	test/lang/useOperator.ci:188: defined as `u32Cgt`
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0528a0>
.name: 'u32Cge'
.file: 'test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
	test/lang/useOperator.ci:189: defined as `u32Cge`
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528a8>
.name: 'i64A'
.file: 'test/lang/useOperator.ci:191'
.value: a
.usages:
	test/lang/useOperator.ci:212: referenced as `i64A`
	test/lang/useOperator.ci:211: referenced as `i64A`
	test/lang/useOperator.ci:210: referenced as `i64A`
	test/lang/useOperator.ci:209: referenced as `i64A`
	test/lang/useOperator.ci:208: referenced as `i64A`
	test/lang/useOperator.ci:207: referenced as `i64A`
	test/lang/useOperator.ci:205: referenced as `i64A`
	test/lang/useOperator.ci:204: referenced as `i64A`
	test/lang/useOperator.ci:203: referenced as `i64A`
	test/lang/useOperator.ci:202: referenced as `i64A`
	test/lang/useOperator.ci:201: referenced as `i64A`
	test/lang/useOperator.ci:200: referenced as `i64A`
	test/lang/useOperator.ci:199: referenced as `i64A`
	test/lang/useOperator.ci:198: referenced as `i64A`
	test/lang/useOperator.ci:197: referenced as `i64A`
	test/lang/useOperator.ci:196: referenced as `i64A`
	test/lang/useOperator.ci:191: defined as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528b0>
.name: 'i64B'
.file: 'test/lang/useOperator.ci:192'
.value: b
.usages:
	test/lang/useOperator.ci:212: referenced as `i64B`
	test/lang/useOperator.ci:211: referenced as `i64B`
	test/lang/useOperator.ci:210: referenced as `i64B`
	test/lang/useOperator.ci:209: referenced as `i64B`
	test/lang/useOperator.ci:208: referenced as `i64B`
	test/lang/useOperator.ci:207: referenced as `i64B`
	test/lang/useOperator.ci:206: referenced as `i64B`
	test/lang/useOperator.ci:203: referenced as `i64B`
	test/lang/useOperator.ci:202: referenced as `i64B`
	test/lang/useOperator.ci:201: referenced as `i64B`
	test/lang/useOperator.ci:200: referenced as `i64B`
	test/lang/useOperator.ci:199: referenced as `i64B`
	test/lang/useOperator.ci:198: referenced as `i64B`
	test/lang/useOperator.ci:197: referenced as `i64B`
	test/lang/useOperator.ci:196: referenced as `i64B`
	test/lang/useOperator.ci:195: referenced as `i64B`
	test/lang/useOperator.ci:194: referenced as `i64B`
	test/lang/useOperator.ci:193: referenced as `i64B`
	test/lang/useOperator.ci:192: defined as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528b8>
.name: 'i64Pls'
.file: 'test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
	test/lang/useOperator.ci:193: defined as `i64Pls`
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528c0>
.name: 'i64Neg'
.file: 'test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
	test/lang/useOperator.ci:194: defined as `i64Neg`
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528c8>
.name: 'i64Cmt'
.file: 'test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
	test/lang/useOperator.ci:195: defined as `i64Cmt`
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528d0>
.name: 'i64Add'
.file: 'test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
	test/lang/useOperator.ci:196: defined as `i64Add`
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528d8>
.name: 'i64Sub'
.file: 'test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
	test/lang/useOperator.ci:197: defined as `i64Sub`
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528e0>
.name: 'i64Mul'
.file: 'test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
	test/lang/useOperator.ci:198: defined as `i64Mul`
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528e8>
.name: 'i64Div'
.file: 'test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
	test/lang/useOperator.ci:199: defined as `i64Div`
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528f0>
.name: 'i64Mod'
.file: 'test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
	test/lang/useOperator.ci:200: defined as `i64Mod`
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0528f8>
.name: 'i64And'
.file: 'test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
	test/lang/useOperator.ci:201: defined as `i64And`
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052900>
.name: 'i64Ior'
.file: 'test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
	test/lang/useOperator.ci:202: defined as `i64Ior`
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052908>
.name: 'i64Xor'
.file: 'test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
	test/lang/useOperator.ci:203: defined as `i64Xor`
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052910>
.name: 'i64Shl'
.file: 'test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
	test/lang/useOperator.ci:204: defined as `i64Shl`
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@052918>
.name: 'i64Shr'
.file: 'test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
	test/lang/useOperator.ci:205: defined as `i64Shr`
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052920>
.name: 'i64Not'
.file: 'test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
	test/lang/useOperator.ci:206: defined as `i64Not`
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052928>
.name: 'i64Ceq'
.file: 'test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
	test/lang/useOperator.ci:207: defined as `i64Ceq`
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052930>
.name: 'i64Cne'
.file: 'test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
	test/lang/useOperator.ci:208: defined as `i64Cne`
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052938>
.name: 'i64Clt'
.file: 'test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
	test/lang/useOperator.ci:209: defined as `i64Clt`
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052940>
.name: 'i64Cle'
.file: 'test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
	test/lang/useOperator.ci:210: defined as `i64Cle`
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052948>
.name: 'i64Cgt'
.file: 'test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
	test/lang/useOperator.ci:211: defined as `i64Cgt`
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052950>
.name: 'i64Cge'
.file: 'test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
	test/lang/useOperator.ci:212: defined as `i64Cge`
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052958>
.name: 'u64A'
.file: 'test/lang/useOperator.ci:214'
.value: a
.usages:
	test/lang/useOperator.ci:235: referenced as `u64A`
	test/lang/useOperator.ci:234: referenced as `u64A`
	test/lang/useOperator.ci:233: referenced as `u64A`
	test/lang/useOperator.ci:232: referenced as `u64A`
	test/lang/useOperator.ci:231: referenced as `u64A`
	test/lang/useOperator.ci:230: referenced as `u64A`
	test/lang/useOperator.ci:228: referenced as `u64A`
	test/lang/useOperator.ci:227: referenced as `u64A`
	test/lang/useOperator.ci:226: referenced as `u64A`
	test/lang/useOperator.ci:225: referenced as `u64A`
	test/lang/useOperator.ci:224: referenced as `u64A`
	test/lang/useOperator.ci:223: referenced as `u64A`
	test/lang/useOperator.ci:222: referenced as `u64A`
	test/lang/useOperator.ci:221: referenced as `u64A`
	test/lang/useOperator.ci:220: referenced as `u64A`
	test/lang/useOperator.ci:219: referenced as `u64A`
	test/lang/useOperator.ci:214: defined as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052960>
.name: 'u64B'
.file: 'test/lang/useOperator.ci:215'
.value: b
.usages:
	test/lang/useOperator.ci:235: referenced as `u64B`
	test/lang/useOperator.ci:234: referenced as `u64B`
	test/lang/useOperator.ci:233: referenced as `u64B`
	test/lang/useOperator.ci:232: referenced as `u64B`
	test/lang/useOperator.ci:231: referenced as `u64B`
	test/lang/useOperator.ci:230: referenced as `u64B`
	test/lang/useOperator.ci:229: referenced as `u64B`
	test/lang/useOperator.ci:226: referenced as `u64B`
	test/lang/useOperator.ci:225: referenced as `u64B`
	test/lang/useOperator.ci:224: referenced as `u64B`
	test/lang/useOperator.ci:223: referenced as `u64B`
	test/lang/useOperator.ci:222: referenced as `u64B`
	test/lang/useOperator.ci:221: referenced as `u64B`
	test/lang/useOperator.ci:220: referenced as `u64B`
	test/lang/useOperator.ci:219: referenced as `u64B`
	test/lang/useOperator.ci:218: referenced as `u64B`
	test/lang/useOperator.ci:217: referenced as `u64B`
	test/lang/useOperator.ci:216: referenced as `u64B`
	test/lang/useOperator.ci:215: defined as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052968>
.name: 'u64Pls'
.file: 'test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
	test/lang/useOperator.ci:216: defined as `u64Pls`
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052970>
.name: 'u64Neg'
.file: 'test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
	test/lang/useOperator.ci:217: defined as `u64Neg`
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052978>
.name: 'u64Cmt'
.file: 'test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
	test/lang/useOperator.ci:218: defined as `u64Cmt`
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052980>
.name: 'u64Add'
.file: 'test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
	test/lang/useOperator.ci:219: defined as `u64Add`
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052988>
.name: 'u64Sub'
.file: 'test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
	test/lang/useOperator.ci:220: defined as `u64Sub`
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052990>
.name: 'u64Mul'
.file: 'test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
	test/lang/useOperator.ci:221: defined as `u64Mul`
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@052998>
.name: 'u64Div'
.file: 'test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
	test/lang/useOperator.ci:222: defined as `u64Div`
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529a0>
.name: 'u64Mod'
.file: 'test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
	test/lang/useOperator.ci:223: defined as `u64Mod`
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529a8>
.name: 'u64And'
.file: 'test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
	test/lang/useOperator.ci:224: defined as `u64And`
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529b0>
.name: 'u64Ior'
.file: 'test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
	test/lang/useOperator.ci:225: defined as `u64Ior`
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529b8>
.name: 'u64Xor'
.file: 'test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
	test/lang/useOperator.ci:226: defined as `u64Xor`
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529c0>
.name: 'u64Shl'
.file: 'test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
	test/lang/useOperator.ci:227: defined as `u64Shl`
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0529c8>
.name: 'u64Shr'
.file: 'test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
	test/lang/useOperator.ci:228: defined as `u64Shr`
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529d0>
.name: 'u64Not'
.file: 'test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
	test/lang/useOperator.ci:229: defined as `u64Not`
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529d8>
.name: 'u64Ceq'
.file: 'test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
	test/lang/useOperator.ci:230: defined as `u64Ceq`
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529e0>
.name: 'u64Cne'
.file: 'test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
	test/lang/useOperator.ci:231: defined as `u64Cne`
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529e8>
.name: 'u64Clt'
.file: 'test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
	test/lang/useOperator.ci:232: defined as `u64Clt`
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529f0>
.name: 'u64Cle'
.file: 'test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
	test/lang/useOperator.ci:233: defined as `u64Cle`
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0529f8>
.name: 'u64Cgt'
.file: 'test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
	test/lang/useOperator.ci:234: defined as `u64Cgt`
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a00>
.name: 'u64Cge'
.file: 'test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
	test/lang/useOperator.ci:235: defined as `u64Cge`
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a08>
.name: 'f32A'
.file: 'test/lang/useOperator.ci:237'
.value: a
.usages:
	test/lang/useOperator.ci:258: referenced as `f32A`
	test/lang/useOperator.ci:257: referenced as `f32A`
	test/lang/useOperator.ci:256: referenced as `f32A`
	test/lang/useOperator.ci:255: referenced as `f32A`
	test/lang/useOperator.ci:254: referenced as `f32A`
	test/lang/useOperator.ci:253: referenced as `f32A`
	test/lang/useOperator.ci:246: referenced as `f32A`
	test/lang/useOperator.ci:245: referenced as `f32A`
	test/lang/useOperator.ci:244: referenced as `f32A`
	test/lang/useOperator.ci:243: referenced as `f32A`
	test/lang/useOperator.ci:242: referenced as `f32A`
	test/lang/useOperator.ci:237: defined as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a10>
.name: 'f32B'
.file: 'test/lang/useOperator.ci:238'
.value: b
.usages:
	test/lang/useOperator.ci:258: referenced as `f32B`
	test/lang/useOperator.ci:257: referenced as `f32B`
	test/lang/useOperator.ci:256: referenced as `f32B`
	test/lang/useOperator.ci:255: referenced as `f32B`
	test/lang/useOperator.ci:254: referenced as `f32B`
	test/lang/useOperator.ci:253: referenced as `f32B`
	test/lang/useOperator.ci:252: referenced as `f32B`
	test/lang/useOperator.ci:246: referenced as `f32B`
	test/lang/useOperator.ci:245: referenced as `f32B`
	test/lang/useOperator.ci:244: referenced as `f32B`
	test/lang/useOperator.ci:243: referenced as `f32B`
	test/lang/useOperator.ci:242: referenced as `f32B`
	test/lang/useOperator.ci:240: referenced as `f32B`
	test/lang/useOperator.ci:239: referenced as `f32B`
	test/lang/useOperator.ci:238: defined as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a18>
.name: 'f32Pls'
.file: 'test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
	test/lang/useOperator.ci:239: defined as `f32Pls`
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a20>
.name: 'f32Neg'
.file: 'test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
	test/lang/useOperator.ci:240: defined as `f32Neg`
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a28>
.name: 'f32Add'
.file: 'test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
	test/lang/useOperator.ci:242: defined as `f32Add`
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a30>
.name: 'f32Sub'
.file: 'test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
	test/lang/useOperator.ci:243: defined as `f32Sub`
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a38>
.name: 'f32Mul'
.file: 'test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
	test/lang/useOperator.ci:244: defined as `f32Mul`
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a40>
.name: 'f32Div'
.file: 'test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
	test/lang/useOperator.ci:245: defined as `f32Div`
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052a48>
.name: 'f32Mod'
.file: 'test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
	test/lang/useOperator.ci:246: defined as `f32Mod`
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a50>
.name: 'f32Not'
.file: 'test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
	test/lang/useOperator.ci:252: defined as `f32Not`
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a58>
.name: 'f32Ceq'
.file: 'test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
	test/lang/useOperator.ci:253: defined as `f32Ceq`
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a60>
.name: 'f32Cne'
.file: 'test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
	test/lang/useOperator.ci:254: defined as `f32Cne`
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a68>
.name: 'f32Clt'
.file: 'test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
	test/lang/useOperator.ci:255: defined as `f32Clt`
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a70>
.name: 'f32Cle'
.file: 'test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
	test/lang/useOperator.ci:256: defined as `f32Cle`
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a78>
.name: 'f32Cgt'
.file: 'test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
	test/lang/useOperator.ci:257: defined as `f32Cgt`
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052a80>
.name: 'f32Cge'
.file: 'test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
	test/lang/useOperator.ci:258: defined as `f32Cge`
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052a88>
.name: 'f64A'
.file: 'test/lang/useOperator.ci:260'
.value: a
.usages:
	test/lang/useOperator.ci:281: referenced as `f64A`
	test/lang/useOperator.ci:280: referenced as `f64A`
	test/lang/useOperator.ci:279: referenced as `f64A`
	test/lang/useOperator.ci:278: referenced as `f64A`
	test/lang/useOperator.ci:277: referenced as `f64A`
	test/lang/useOperator.ci:276: referenced as `f64A`
	test/lang/useOperator.ci:269: referenced as `f64A`
	test/lang/useOperator.ci:268: referenced as `f64A`
	test/lang/useOperator.ci:267: referenced as `f64A`
	test/lang/useOperator.ci:266: referenced as `f64A`
	test/lang/useOperator.ci:265: referenced as `f64A`
	test/lang/useOperator.ci:260: defined as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052a90>
.name: 'f64B'
.file: 'test/lang/useOperator.ci:261'
.value: b
.usages:
	test/lang/useOperator.ci:281: referenced as `f64B`
	test/lang/useOperator.ci:280: referenced as `f64B`
	test/lang/useOperator.ci:279: referenced as `f64B`
	test/lang/useOperator.ci:278: referenced as `f64B`
	test/lang/useOperator.ci:277: referenced as `f64B`
	test/lang/useOperator.ci:276: referenced as `f64B`
	test/lang/useOperator.ci:275: referenced as `f64B`
	test/lang/useOperator.ci:269: referenced as `f64B`
	test/lang/useOperator.ci:268: referenced as `f64B`
	test/lang/useOperator.ci:267: referenced as `f64B`
	test/lang/useOperator.ci:266: referenced as `f64B`
	test/lang/useOperator.ci:265: referenced as `f64B`
	test/lang/useOperator.ci:263: referenced as `f64B`
	test/lang/useOperator.ci:262: referenced as `f64B`
	test/lang/useOperator.ci:261: defined as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052a98>
.name: 'f64Pls'
.file: 'test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
	test/lang/useOperator.ci:262: defined as `f64Pls`
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052aa0>
.name: 'f64Neg'
.file: 'test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
	test/lang/useOperator.ci:263: defined as `f64Neg`
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052aa8>
.name: 'f64Add'
.file: 'test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
	test/lang/useOperator.ci:265: defined as `f64Add`
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ab0>
.name: 'f64Sub'
.file: 'test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
	test/lang/useOperator.ci:266: defined as `f64Sub`
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ab8>
.name: 'f64Mul'
.file: 'test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
	test/lang/useOperator.ci:267: defined as `f64Mul`
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ac0>
.name: 'f64Div'
.file: 'test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
	test/lang/useOperator.ci:268: defined as `f64Div`
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ac8>
.name: 'f64Mod'
.file: 'test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
	test/lang/useOperator.ci:269: defined as `f64Mod`
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052ad0>
.name: 'f64Not'
.file: 'test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
	test/lang/useOperator.ci:275: defined as `f64Not`
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052ad8>
.name: 'f64Ceq'
.file: 'test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
	test/lang/useOperator.ci:276: defined as `f64Ceq`
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052ae0>
.name: 'f64Cne'
.file: 'test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
	test/lang/useOperator.ci:277: defined as `f64Cne`
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052ae8>
.name: 'f64Clt'
.file: 'test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
	test/lang/useOperator.ci:278: defined as `f64Clt`
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052af0>
.name: 'f64Cle'
.file: 'test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
	test/lang/useOperator.ci:279: defined as `f64Cle`
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052af8>
.name: 'f64Cgt'
.file: 'test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
	test/lang/useOperator.ci:280: defined as `f64Cgt`
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052b00>
.name: 'f64Cge'
.file: 'test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
	test/lang/useOperator.ci:281: defined as `f64Cge`
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@052b08>
.name: 'ptrA'
.file: 'test/lang/useOperator.ci:283'
.value: null
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrA`
	test/lang/useOperator.ci:299: referenced as `ptrA`
	test/lang/useOperator.ci:283: defined as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@052b10>
.name: 'ptrB'
.file: 'test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	test/lang/useOperator.ci:300: referenced as `ptrB`
	test/lang/useOperator.ci:299: referenced as `ptrB`
	test/lang/useOperator.ci:284: defined as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052b18>
.name: 'ptrCeq'
.file: 'test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
	test/lang/useOperator.ci:299: defined as `ptrCeq`
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052b20>
.name: 'ptrCne'
.file: 'test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
	test/lang/useOperator.ci:300: defined as `ptrCne`
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052b28>
.name: 't'
.file: 'test/lang/statementIf.ci:26'
.value: 0
.usages:
	test/lang/statementIf.ci:69: referenced as `t`
	test/lang/statementIf.ci:66: referenced as `t`
	test/lang/statementIf.ci:65: referenced as `t`
	test/lang/statementIf.ci:63: referenced as `t`
	test/lang/statementIf.ci:62: referenced as `t`
	test/lang/statementIf.ci:60: referenced as `t`
	test/lang/statementIf.ci:59: referenced as `t`
	test/lang/statementIf.ci:57: referenced as `t`
	test/lang/statementIf.ci:56: referenced as `t`
	test/lang/statementIf.ci:54: referenced as `t`
	test/lang/statementIf.ci:53: referenced as `t`
	test/lang/statementIf.ci:51: referenced as `t`
	test/lang/statementIf.ci:50: referenced as `t`
	test/lang/statementIf.ci:47: referenced as `t`
	test/lang/statementIf.ci:44: referenced as `t`
	test/lang/statementIf.ci:43: referenced as `t`
	test/lang/statementIf.ci:40: referenced as `t`
	test/lang/statementIf.ci:37: referenced as `t`
	test/lang/statementIf.ci:36: referenced as `t`
	test/lang/statementIf.ci:33: referenced as `t`
	test/lang/statementIf.ci:32: referenced as `t`
	test/lang/statementIf.ci:29: referenced as `t`
	test/lang/statementIf.ci:28: referenced as `t`
	test/lang/statementIf.ci:26: defined as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@052b30>
.name: 'forIdx'
.file: 'test/lang/statementFor.ci:12'
.usages:
	test/lang/statementFor.ci:14: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:13: referenced as `forIdx`
	test/lang/statementFor.ci:12: defined as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b38>
.name: 'testMathFloor_1'
.file: 'test/stdc/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
	test/stdc/test.math.ci:3: defined as `testMathFloor_1`
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b40>
.name: 'testMathFloor_2'
.file: 'test/stdc/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
	test/stdc/test.math.ci:4: defined as `testMathFloor_2`
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b48>
.name: 'testMathFloor_3'
.file: 'test/stdc/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
	test/stdc/test.math.ci:5: defined as `testMathFloor_3`
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b50>
.name: 'testMathFloor_4'
.file: 'test/stdc/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
	test/stdc/test.math.ci:6: defined as `testMathFloor_4`
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b58>
.name: 'testMathFloor_5'
.file: 'test/stdc/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
	test/stdc/test.math.ci:7: defined as `testMathFloor_5`
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b60>
.name: 'testMathFloor_6'
.file: 'test/stdc/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
	test/stdc/test.math.ci:8: defined as `testMathFloor_6`
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b68>
.name: 'testMathSign_1F'
.file: 'test/stdc/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:10: defined as `testMathSign_1F`
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b70>
.name: 'testMathSign_2F'
.file: 'test/stdc/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:11: defined as `testMathSign_2F`
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b78>
.name: 'testMathSign_3F'
.file: 'test/stdc/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:12: defined as `testMathSign_3F`
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b80>
.name: 'testMathSign_1f'
.file: 'test/stdc/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
	test/stdc/test.math.ci:13: defined as `testMathSign_1f`
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b88>
.name: 'testMathSign_2f'
.file: 'test/stdc/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
	test/stdc/test.math.ci:14: defined as `testMathSign_2f`
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b90>
.name: 'testMathSign_3f'
.file: 'test/stdc/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:15: defined as `testMathSign_3f`
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052b98>
.name: 'testMathAbs_1F'
.file: 'test/stdc/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:17: defined as `testMathAbs_1F`
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ba0>
.name: 'testMathAbs_2F'
.file: 'test/stdc/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:18: defined as `testMathAbs_2F`
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ba8>
.name: 'testMathAbs_3F'
.file: 'test/stdc/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
	test/stdc/test.math.ci:19: defined as `testMathAbs_3F`
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bb0>
.name: 'testMathAbs_1f'
.file: 'test/stdc/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
	test/stdc/test.math.ci:20: defined as `testMathAbs_1f`
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bb8>
.name: 'testMathAbs_2f'
.file: 'test/stdc/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
	test/stdc/test.math.ci:21: defined as `testMathAbs_2f`
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bc0>
.name: 'testMathAbs_3f'
.file: 'test/stdc/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
	test/stdc/test.math.ci:22: defined as `testMathAbs_3f`
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bc8>
.name: 'testMathMin_1f'
.file: 'test/stdc/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:24: defined as `testMathMin_1f`
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bd0>
.name: 'testMathMax_2f'
.file: 'test/stdc/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:25: defined as `testMathMax_2f`
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bd8>
.name: 'testMathMin_1F'
.file: 'test/stdc/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:26: defined as `testMathMin_1F`
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052be0>
.name: 'testMathMax_2F'
.file: 'test/stdc/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
	test/stdc/test.math.ci:27: defined as `testMathMax_2F`
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052be8>
.name: 'testMathClamp_1f'
.file: 'test/stdc/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:29: defined as `testMathClamp_1f`
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bf0>
.name: 'testMathClamp_1F'
.file: 'test/stdc/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:30: defined as `testMathClamp_1F`
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052bf8>
.name: 'testMathLerp_1f'
.file: 'test/stdc/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:32: defined as `testMathLerp_1f`
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c00>
.name: 'testMathLerp_1F'
.file: 'test/stdc/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
	test/stdc/test.math.ci:33: defined as `testMathLerp_1F`
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c08>
.name: 'testMathSmooth_1f'
.file: 'test/stdc/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:35: defined as `testMathSmooth_1f`
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c10>
.name: 'testMathSmooth_1F'
.file: 'test/stdc/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:36: defined as `testMathSmooth_1F`
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c18>
.name: 'testMathMin_nan'
.file: 'test/stdc/test.math.ci:38'
.value: Math.min()
.usages:
	test/stdc/test.math.ci:38: defined as `testMathMin_nan`
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c20>
.name: 'testMathMin_1'
.file: 'test/stdc/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:39: defined as `testMathMin_1`
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c28>
.name: 'testMathMax_nan'
.file: 'test/stdc/test.math.ci:40'
.value: Math.max()
.usages:
	test/stdc/test.math.ci:40: defined as `testMathMax_nan`
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c30>
.name: 'testMathMax_9'
.file: 'test/stdc/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
	test/stdc/test.math.ci:41: defined as `testMathMax_9`
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c38>
.name: 'testMathSum_0'
.file: 'test/stdc/test.math.ci:43'
.value: Math.sum()
.usages:
	test/stdc/test.math.ci:43: defined as `testMathSum_0`
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c40>
.name: 'testMathSum_1'
.file: 'test/stdc/test.math.ci:44'
.value: Math.sum(1)
.usages:
	test/stdc/test.math.ci:44: defined as `testMathSum_1`
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c48>
.name: 'testMathSum_3'
.file: 'test/stdc/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
	test/stdc/test.math.ci:45: defined as `testMathSum_3`
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c50>
.name: 'testMathSum_55'
.file: 'test/stdc/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
	test/stdc/test.math.ci:46: defined as `testMathSum_55`
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c58>
.name: 'testMathEval_x'
.file: 'test/stdc/test.math.ci:48'
.value: 10
.usages:
	test/stdc/test.math.ci:55: referenced as `testMathEval_x`
	test/stdc/test.math.ci:54: referenced as `testMathEval_x`
	test/stdc/test.math.ci:53: referenced as `testMathEval_x`
	test/stdc/test.math.ci:52: referenced as `testMathEval_x`
	test/stdc/test.math.ci:51: referenced as `testMathEval_x`
	test/stdc/test.math.ci:50: referenced as `testMathEval_x`
	test/stdc/test.math.ci:49: referenced as `testMathEval_x`
	test/stdc/test.math.ci:48: defined as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c60>
.name: 'testMathEval_0'
.file: 'test/stdc/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
	test/stdc/test.math.ci:49: defined as `testMathEval_0`
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c68>
.name: 'testMathEval_1'
.file: 'test/stdc/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
	test/stdc/test.math.ci:50: defined as `testMathEval_1`
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c70>
.name: 'testMathEval_2'
.file: 'test/stdc/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:51: defined as `testMathEval_2`
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c78>
.name: 'testMathEval_3'
.file: 'test/stdc/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:52: defined as `testMathEval_3`
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c80>
.name: 'testMathEval_4'
.file: 'test/stdc/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:53: defined as `testMathEval_4`
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c88>
.name: 'testMathEval_5'
.file: 'test/stdc/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:54: defined as `testMathEval_5`
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c90>
.name: 'testMathEval_6'
.file: 'test/stdc/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
	test/stdc/test.math.ci:55: defined as `testMathEval_6`
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052c98>
.name: 'testMathSin_f64'
.file: 'test/stdc/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:57: defined as `testMathSin_f64`
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ca0>
.name: 'testMathCos_f64'
.file: 'test/stdc/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:58: defined as `testMathCos_f64`
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ca8>
.name: 'testMathTan_f64'
.file: 'test/stdc/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
	test/stdc/test.math.ci:59: defined as `testMathTan_f64`
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cb0>
.name: 'testMathSinh_f64'
.file: 'test/stdc/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:60: defined as `testMathSinh_f64`
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cb8>
.name: 'testMathCosh_f64'
.file: 'test/stdc/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
	test/stdc/test.math.ci:61: defined as `testMathCosh_f64`
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cc0>
.name: 'testMathAsin_f64'
.file: 'test/stdc/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
	test/stdc/test.math.ci:63: defined as `testMathAsin_f64`
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cc8>
.name: 'testMathAcos_f64'
.file: 'test/stdc/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
	test/stdc/test.math.ci:64: defined as `testMathAcos_f64`
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052cd0>
.name: 'testMathCmp_f32'
.file: 'test/stdc/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:67: defined as `testMathCmp_f32`
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@052cd8>
.name: 'testMathCmp_f64'
.file: 'test/stdc/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
	test/stdc/test.math.ci:68: defined as `testMathCmp_f64`
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ce0>
.name: 'testMathAbsMod_f64_0a'
.file: 'test/stdc/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:70: defined as `testMathAbsMod_f64_0a`
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052ce8>
.name: 'testMathAbsMod_f64_0b'
.file: 'test/stdc/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:71: defined as `testMathAbsMod_f64_0b`
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cf0>
.name: 'testMathAbsMod_f64_0c'
.file: 'test/stdc/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:72: defined as `testMathAbsMod_f64_0c`
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052cf8>
.name: 'testMathAbsMod_f64_9a'
.file: 'test/stdc/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:74: defined as `testMathAbsMod_f64_9a`
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d00>
.name: 'testMathAbsMod_f64_9b'
.file: 'test/stdc/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:75: defined as `testMathAbsMod_f64_9b`
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d08>
.name: 'testMathAbsMod_f64_9c'
.file: 'test/stdc/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:76: defined as `testMathAbsMod_f64_9c`
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d10>
.name: 'testMathAbsMod_f64_9d'
.file: 'test/stdc/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:77: defined as `testMathAbsMod_f64_9d`
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d18>
.name: 'testMathAbsMod_f64_8a'
.file: 'test/stdc/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:79: defined as `testMathAbsMod_f64_8a`
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d20>
.name: 'testMathAbsMod_f64_8b'
.file: 'test/stdc/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:80: defined as `testMathAbsMod_f64_8b`
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d28>
.name: 'testMathAbsMod_f64_8c'
.file: 'test/stdc/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:81: defined as `testMathAbsMod_f64_8c`
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@052d30>
.name: 'testMathAbsMod_f64_8d'
.file: 'test/stdc/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:82: defined as `testMathAbsMod_f64_8d`
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d38>
.name: 'testMathAbsMod_f32_0a'
.file: 'test/stdc/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:84: defined as `testMathAbsMod_f32_0a`
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d40>
.name: 'testMathAbsMod_f32_0b'
.file: 'test/stdc/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:85: defined as `testMathAbsMod_f32_0b`
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d48>
.name: 'testMathAbsMod_f32_0c'
.file: 'test/stdc/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:86: defined as `testMathAbsMod_f32_0c`
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d50>
.name: 'testMathAbsMod_f32_9a'
.file: 'test/stdc/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:88: defined as `testMathAbsMod_f32_9a`
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d58>
.name: 'testMathAbsMod_f32_9b'
.file: 'test/stdc/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:89: defined as `testMathAbsMod_f32_9b`
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d60>
.name: 'testMathAbsMod_f32_9c'
.file: 'test/stdc/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:90: defined as `testMathAbsMod_f32_9c`
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d68>
.name: 'testMathAbsMod_f32_9d'
.file: 'test/stdc/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:91: defined as `testMathAbsMod_f32_9d`
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d70>
.name: 'testMathAbsMod_f32_8a'
.file: 'test/stdc/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:93: defined as `testMathAbsMod_f32_8a`
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d78>
.name: 'testMathAbsMod_f32_8b'
.file: 'test/stdc/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
	test/stdc/test.math.ci:94: defined as `testMathAbsMod_f32_8b`
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d80>
.name: 'testMathAbsMod_f32_8c'
.file: 'test/stdc/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:95: defined as `testMathAbsMod_f32_8c`
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@052d88>
.name: 'testMathAbsMod_f32_8d'
.file: 'test/stdc/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
	test/stdc/test.math.ci:96: defined as `testMathAbsMod_f32_8d`
}
.main: function {
.kind: static function
.base: `function`
.size: 14636
.offset: <@052d8c>
.name: '.main'
.print: '.main'
.field typename: typename (size: 152, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b0>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000150>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@0001f0>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@000290>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000330>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@0003d0>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@000470>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000510>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005b0>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@000650>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@0006f0>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@000790>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000830>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@0008d0>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@000970>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a10>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000ab8>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000d38>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000dd8>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005900>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@006f10>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@0077f0>, cast: static const inline)
.field System: typename (size: 0, offs: <@008460>, cast: static const typename(void))
.field true: bool (size: 1, offs: <@000000>, cast: static const val)
.field false: bool (size: 1, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 32, offs: <@010108>, cast: static const typename(val))
.field assertEq: function (size: 94, offs: <@050748>, cast: static const function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@011380>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01a0a0>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@050f68>, cast: static const function)
.field Complex: function (size: 7, offs: <@050f70>, cast: static const function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@050f78>, cast: static const function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@050ff8>, cast: static const function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@051018>, cast: static const function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@051080>, cast: static const function)
.field indexOf: function (size: 50, offs: <@0510a8>, cast: static const function)
.field lastIndexOf: function (size: 50, offs: <@0510e0>, cast: static const function)
.field startsWith: function (size: 73, offs: <@051118>, cast: static const function)
.field endsWith: function (size: 126, offs: <@051168>, cast: static const function)
.field compare: function (size: 63, offs: <@0511e8>, cast: static const function)
.field ignCaseCmp: function (size: 36, offs: <@051270>, cast: static const function)
.field caseCmp: function (size: 14, offs: <@051298>, cast: static const function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@022ac8>, cast: static const typename(val))
.field append: function (size: 84, offs: <@0512a8>, cast: static const function)
.field append: function (size: 657, offs: <@051310>, cast: static const function)
.field append: function (size: 23, offs: <@0515a8>, cast: static const function)
.field append: function (size: 49, offs: <@0515c0>, cast: static const function)
.field append: function (size: 25, offs: <@051608>, cast: static const function)
.field vec2d: typename (size: 16, offs: <@024c58>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@051628>, cast: static const function)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@025c10>, cast: static const typename(val))
.field vec4f: function (size: 13, offs: <@051630>, cast: static const function)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field len: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@028ff0>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@051640>, cast: static const function)
.field mat4f: function (size: 21, offs: <@051678>, cast: static const function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 417, offs: <@051690>, cast: static const function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@051838>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@051840>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@051848>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@051850>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@051858>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@051860>, cast: static variable(i32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@051868>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@051870>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@051878>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@051880>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@051888>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@051890>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@051898>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@0518a0>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@0518a8>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@0518b0>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@0518b8>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@0518c0>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@0518c8>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@0518d0>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@0518d8>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@0518e0>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@0518e8>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@0518f0>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@0518f8>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@051900>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@051908>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@051910>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@051918>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@051920>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@051928>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@051930>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@051938>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@051940>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@051948>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@051950>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@051958>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@051960>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@051968>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@051970>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@051978>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@051980>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@051988>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@051990>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@051998>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@0519a0>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@0519a8>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@0519b0>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@0519b8>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@0519c0>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@0519c8>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@0519d0>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@0519d8>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@0519e0>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@0519e8>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@0519f0>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@0519f8>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@051a00>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@051a08>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@051a10>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@051a18>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@051a20>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@031518>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@031648>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@051a28>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@051a30>, cast: static variable(val))
.field value: int64 (size: 8, offs: <@051a38>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@051a40>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@051a48>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@051a50>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@051a58>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@051a60>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@051a68>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@051a70>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@051a78>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@051a80>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@051a88>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@051a90>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@051a98>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@051aa0>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@051aa8>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@051ab0>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@051ab8>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@051ac0>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@051ac8>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@051ad0>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@051ad8>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@051ae0>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@051ae8>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@051af0>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@051af8>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@051b00>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@051b08>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@051b10>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@051b18>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@051b20>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@051b28>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@051b30>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@051b38>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@051b40>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@051b48>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@051b50>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@051b58>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@051b60>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@051b68>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@051b70>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@051b78>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@051b80>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@051b88>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@051b90>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@051b98>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@051ba0>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@051ba8>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@051bb0>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@051bb8>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@051bc0>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@051bc8>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@051bd0>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@051bd8>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@051be0>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@051be8>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@051bf0>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@051bf8>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@051c00>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@051c08>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@051c10>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@051c18>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@051c20>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@051c28>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@051c30>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@051c38>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@051c40>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@051c48>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@051c50>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@051c58>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@051c60>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@051c68>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@051c70>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@051c78>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@051c80>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@051c88>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@051c90>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@051c98>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@051ca0>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@051ca8>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@051cb0>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@051cb8>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@051cc0>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@051cc8>, cast: static const function)
.field funAdd: function (size: 8, offs: <@051cd0>, cast: static const function)
.field funAddResult: int32 (size: 4, offs: <@051cd8>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@051ce0>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@051ce8>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@051cf0>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@051cf8>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@051d00>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@051d08>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@051d10>, cast: static const function)
.field fib: function (size: 54, offs: <@051d18>, cast: static const function)
.field fibonacci_13: uint32 (size: 4, offs: <@051d50>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@051d58>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@051d60>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@051d68>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@051d70>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@051d78>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@051d80>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@051d88>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@051d90>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@051d98>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@051da0>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@051da8>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@051db0>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@051db8>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@051dc0>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@051dc8>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@051dd0>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@051dd8>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@051de0>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@0374b0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@0375e0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@051de8>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@051df0>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@051df8>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@051e00>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@051e08>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@051e10>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@051e18>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@051e20>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@051e28>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@051e30>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@051e38>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@051e40>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@051e48>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@051e50>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@051e58>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@051e60>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@051e68>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@051e70>, cast: static variable(i32))
.field pi64: float64 (size: 8, offs: <@051e78>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@051e80>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@051e88>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@051e90>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@051e98>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@051ea0>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@051ea8>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@051eb0>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@051eb8>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@051ec0>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@051ec8>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@051ed0>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@051ed8>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@051ee0>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@051ee8>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@051ef0>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@051ef8>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@051f00>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@051f08>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@051f10>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@051f18>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@051f20>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@051f28>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@051f30>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@051f38>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@051f40>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@051f48>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@051f50>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@051f58>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@051f60>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@051f68>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@051f70>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@051f78>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@051f80>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@051f88>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@051f90>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@051f98>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@051fa0>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@051fa8>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@051fb0>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@051fb8>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@051fc0>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@051fc8>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@051fd0>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@051fd8>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@051fe0>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@051fe8>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@051ff0>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@051ff8>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@052000>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@052008>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@052010>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@052018>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@052020>, cast: static const function)
.field stackOverflow: function (size: 24, offs: <@052028>, cast: static const function)
.field divisionByZero: function (size: 12, offs: <@052040>, cast: static const function)
.field abortExecution: function (size: 68, offs: <@052050>, cast: static const function)
.field invalidMemoryAccess: function (size: 13, offs: <@052098>, cast: static const function)
.field invalidInstruction: function (size: 2, offs: <@0520a8>, cast: static const function)
.field tryExecErr0: int32 (size: 4, offs: <@0520b0>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@0520b8>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@0520c0>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@0520c8>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@0520d0>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@0520d8>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@0520e0>, cast: static variable(i32))
.field arrFixedNoInit: int64[7] (size: 56, offs: <@0520e8>, cast: static variable(val))
.field arrArrayNoInit: int64[*] (size: 4, offs: <@052120>, cast: static variable(ref))
.field arrSliceNoInit: int64[] (size: 8, offs: <@052128>, cast: static variable(arr))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@052130>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@052138>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@052140>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@052148>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@052150>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@052158>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@052160>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@052168>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@052170>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@052178>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@052180>, cast: static const function)
.field nthFixed: function (size: 12, offs: <@052188>, cast: static const function)
.field nthArray: function (size: 12, offs: <@052198>, cast: static const function)
.field nthSlice: function (size: 12, offs: <@0521a8>, cast: static const function)
.field RecordMemberTest: typename (size: 32, offs: <@03e9f8>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@0521e8>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@03f8d0>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@052288>, cast: static const function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@0522b0>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@0522c0>, cast: static const function)
.field virtualMethod: function (size: 63, offs: <@052308>, cast: static const function)
.field rgbF32: typename (size: 16, offs: <@041050>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@0412b0>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@041510>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@0416d8>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@052348>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@052350>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@052358>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@052360>, cast: static variable(val))
.field blue: color (size: 4, offs: <@052368>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@041b78>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@041fa0>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@0423c8>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@0427f0>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@042c18>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@043040>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@052370>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@052378>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@052380>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@052388>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@052390>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@052398>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@0523a0>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@0523a8>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@0523b0>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@0523b8>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@0523c0>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@0523c8>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@0523d0>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@0523d8>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@0523e0>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@0523e8>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@0523f0>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@0523f8>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@052400>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@052408>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@052410>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@052418>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@052420>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@052428>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@052430>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@052438>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@052440>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@052448>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@052450>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@052458>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@052460>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@052468>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@052470>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@052478>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@052480>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@052488>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@052490>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@052498>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@0524a0>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@0524a8>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@0524b0>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@0524b8>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@0524c0>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@0524c8>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@0524d0>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@0524d8>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@0524e0>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@0524e8>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@0524f0>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@0524f8>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@052500>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@052508>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@052510>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@052518>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@052520>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@052528>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@052530>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@052538>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@052540>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@052548>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@052550>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@052558>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@052560>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@052568>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@052570>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@052578>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@052580>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@052588>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@052590>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@052598>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@0525a0>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@0525a8>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@0525b0>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@0525b8>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@0525c0>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@0525c8>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@0525d0>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@0525d8>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@0525e0>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@0525e8>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@0525f0>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@0525f8>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@052600>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@052608>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@052610>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@052618>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@052620>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@052628>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@052630>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@052638>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@052640>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@052648>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@052650>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@052658>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@052660>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@052668>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@052670>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@052678>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@052680>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@052688>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@052690>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@052698>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@0526a0>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@0526a8>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@0526b0>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@0526b8>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@0526c0>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@0526c8>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@0526d0>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@0526d8>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@0526e0>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@0526e8>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@0526f0>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@0526f8>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@052700>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@052708>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@052710>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@052718>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@052720>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@052728>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@052730>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@052738>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@052740>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@052748>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@052750>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@052758>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@052760>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@052768>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@052770>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@052778>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@052780>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@052788>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@052790>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@052798>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@0527a0>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@0527a8>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@0527b0>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@0527b8>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@0527c0>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@0527c8>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@0527d0>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@0527d8>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@0527e0>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@0527e8>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@0527f0>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@0527f8>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@052800>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@052808>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@052810>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@052818>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@052820>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@052828>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@052830>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@052838>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@052840>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@052848>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@052850>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@052858>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@052860>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@052868>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@052870>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@052878>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@052880>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@052888>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@052890>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@052898>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@0528a0>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@0528a8>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@0528b0>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@0528b8>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@0528c0>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@0528c8>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@0528d0>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@0528d8>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@0528e0>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@0528e8>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@0528f0>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@0528f8>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@052900>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@052908>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@052910>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@052918>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@052920>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@052928>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@052930>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@052938>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@052940>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@052948>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@052950>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@052958>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@052960>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@052968>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@052970>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@052978>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@052980>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@052988>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@052990>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@052998>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@0529a0>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@0529a8>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@0529b0>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@0529b8>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@0529c0>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@0529c8>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@0529d0>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@0529d8>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@0529e0>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@0529e8>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@0529f0>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@0529f8>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@052a00>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@052a08>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@052a10>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@052a18>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@052a20>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@052a28>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@052a30>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@052a38>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@052a40>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@052a48>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@052a50>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@052a58>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@052a60>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@052a68>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@052a70>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@052a78>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@052a80>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@052a88>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@052a90>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@052a98>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@052aa0>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@052aa8>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@052ab0>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@052ab8>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@052ac0>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@052ac8>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@052ad0>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@052ad8>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@052ae0>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@052ae8>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@052af0>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@052af8>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@052b00>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@052b08>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@052b10>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@052b18>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@052b20>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@052b28>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@052b30>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@052b38>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@052b40>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@052b48>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@052b50>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@052b58>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@052b60>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@052b68>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@052b70>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@052b78>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@052b80>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@052b88>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@052b90>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@052b98>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@052ba0>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@052ba8>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@052bb0>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@052bb8>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@052bc0>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@052bc8>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@052bd0>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@052bd8>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@052be0>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@052be8>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@052bf0>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@052bf8>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@052c00>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@052c08>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@052c10>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@052c18>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@052c20>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@052c28>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@052c30>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@052c38>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@052c40>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@052c48>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@052c50>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@052c58>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@052c60>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@052c68>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@052c70>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@052c78>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@052c80>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@052c88>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@052c90>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@052c98>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@052ca0>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@052ca8>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@052cb0>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@052cb8>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@052cc0>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@052cc8>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@052cd0>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@052cd8>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@052ce0>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@052ce8>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@052cf0>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@052cf8>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@052d00>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@052d08>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@052d10>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@052d18>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@052d20>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@052d28>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@052d30>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@052d38>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@052d40>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@052d48>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@052d50>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@052d58>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@052d60>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@052d68>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@052d70>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@052d78>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@052d80>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@052d88>, cast: static variable(f32))
.field .main: function (size: 14636, offs: <@052d8c>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static if (bool(typename(raise) == function)) {
			static verbose(message: char[*], inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(message: char[*], inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(message: char[*], inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(message: char[*], inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(message: char[*], inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(message: char[*], inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const argument: variant := null;
				const message: char[*] := null;
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.message := (message));
					void(details.argument := (null));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), intPart)));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(void(x, result));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static const abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static const abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static const absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static const absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static const min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static const max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static const min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static const sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static const eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float32(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else {
					if (bool(eps < (float64(a - b)))) {
						return int32(.result := int32(+1));
					}
				}
				return int32(.result := 0);
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, e)));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), f));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, e));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else {
					if (bool(i == 1)) {
						float64(x := float64((1) - x));
						bool(complement := true);
					}
					else {
						if (bool(i == 2)) {
							bool(negate := bool(!negate));
							bool(complement := true);
						}
						else {
							if (bool(i == 3)) {
								float64(x := float64((1) - x));
								bool(negate := bool(!negate));
							}
						}
					}
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static const cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static const asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static const Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(void(float64(-a.re), float64(-a.im)));
		static add(a: Complex, b: Complex): Complex := Complex(void(float64(a.re + b.re), float64(a.im + b.im)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(void(float64(a.re - b.re), float64(a.im - b.im)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(void(float64(float64(a.re * b.re) - float64(a.im * b.im)), float64(float64(a.re * b.im) + float64(a.im * b.re))));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static const div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static const inv(a: Complex): Complex := {
			d: float64 := (float64(float64(a.re * a.re) + float64(a.im * a.im)));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const length(str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(str: char[*], with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(str: char[*], with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(str: char[*], with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static contains(str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const radix: int32 := 10;
			const padChr: char := 0;
			const padLen: int32 := 0;
			const precision: int32 := 0;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint32(value := uint32(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint32(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			return int32(.result := append(void(void(void(void(output, pos), 0), value), format)));
		};
		static const append(output: char[], pos: int32, value: int32, format: FormatFlags): int32 := {
			sign: int32 := 0;
			if (bool(value < 0)) {
				int32(sign := ('-'));
				int32(value := int32(-value));
			}
			return int32(.result := append(void(void(void(void(output, pos), sign), value), format)));
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				void(format.radix := 10);
				void(format.padChr := (0));
				void(format.padLen := 0);
				void(format.precision := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
		static if (bool((null) == null)) {
			static const vec2d: struct {
				data: float64[2];
				<?>: <?>;
				x: float64 := x: float64;
				y: float64 := y: float64;
			};
			static const vec2d(x: float64, y: float64): vec2d := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
			};
			static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
			static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		}
		static if (bool((null) == null)) {
			static const vec4f: struct {
				data: float32[4];
				<?>: <?>;
				x: float32 := x: float32;
				y: float32 := y: float32;
				z: float32 := z: float32;
				w: float32 := w: float32;
			};
			static const vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 0.000000));
			static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
			static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
			static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
			static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
			static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
			static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
			static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
			static min(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), min.p4f)));
			static max(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), max.p4f)));
			static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp3)));
			static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dph)));
			static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(rhs), struct(lhs)), p4x.dp4)));
			static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
			static len(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
			static normalize(const v: vec4f): vec4f := div(void(v, vec4f(len(v))));
			static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		}
		static if (bool((null) == null)) {
			static const mat4f: struct {
				m: float32[4][4];
				data: float32[16];
				v: vec4f[4];
				<?>: <?>;
				x: vec4f := x: vec4f;
				y: vec4f := y: vec4f;
				z: vec4f := z: vec4f;
				w: vec4f := w: vec4f;
			};
			static const mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
				return void(.result := {
			void(.result.x.x := xx);
			void(.result.x.y := xy);
			void(.result.x.z := xz);
			void(.result.x.w := xw);
			void(.result.y.x := yx);
			void(.result.y.y := yy);
			void(.result.y.z := yz);
			void(.result.y.w := yw);
			void(.result.z.x := zx);
			void(.result.z.y := zy);
			void(.result.z.z := zz);
			void(.result.z.w := zw);
			void(.result.w.x := wx);
			void(.result.w.y := wy);
			void(.result.w.z := wz);
			void(.result.w.w := ww);
		});
			};
			static const mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
				return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
			};
			static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
			static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
			static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
			static const mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
				transposed: mat4f := {
					void(transposed.x.x := rhs.x.x);
					void(transposed.x.y := rhs.y.x);
					void(transposed.x.z := rhs.z.x);
					void(transposed.x.w := rhs.w.x);
					void(transposed.y.x := rhs.x.y);
					void(transposed.y.y := rhs.y.y);
					void(transposed.y.z := rhs.z.y);
					void(transposed.y.w := rhs.w.y);
					void(transposed.z.x := rhs.x.z);
					void(transposed.z.y := rhs.y.z);
					void(transposed.z.z := rhs.z.z);
					void(transposed.z.w := rhs.w.z);
					void(transposed.w.x := rhs.x.w);
					void(transposed.w.y := rhs.y.w);
					void(transposed.w.z := rhs.z.w);
					void(transposed.w.w := rhs.w.w);
				};
				return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
			};
		}
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static const funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static const fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedNoInit: int64[7];
		static arrArrayNoInit: int64[*];
		static arrSliceNoInit: int64[];
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			int64(arrFixedNoInit[i] := (int32(42 + i)));
		}
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedNoInit;
		static arrSliceInitFixed: int64[] := arrFixedNoInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7];
		pointer.copy(void(void(strFixed, pointer("string")), 7));
		debug(void("string as variant", strFixed));
		debug(void("string to variant", variant(strFixed)));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		debug(void("string to variant", variant(strArray)));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		debug(void("string to variant", variant(strSlice)));
		assert(bool(arrSliceNoInit.length >= (0)));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedNoInit[0] == (42)));
		static const lenSlice(values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedNoInit.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
		assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedNoInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static const staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static const virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			static const forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static const globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static const staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static const virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				if (bool(t == 1)) {
					raise(void(void(void(raise.debug, 10), "t == 1"), t));
				}
				else {
					if (bool(t == 2)) {
						raise(void(void(void(raise.debug, 10), "t == 2"), t));
					}
					else {
						if (bool(t == 3)) {
							raise(void(void(void(raise.debug, 10), "t == 3"), t));
						}
						else {
							if (bool(t == 4)) {
								raise(void(void(void(raise.debug, 10), "t == 4"), t));
							}
							else {
								if (bool(t == 5)) {
									raise(void(void(void(raise.debug, 10), "t == 5"), t));
								}
								else {
									raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
								}
							}
						}
					}
				}
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14636 bytes: <@052d8c> - <@0566b8>)
	lib/std/string.ci:144: (14 bytes: <@052d8c> - <@052d9a>): static const whiteSpace: char[] := " \t\n\r"
	<.main @052d8c>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @052d91>    : 1f e1 f5 01 00             load.ref <@01f5e1> ;" \t\n\r"
	<.main+10 @052d96>   : 2d 00 13 05                store.m64 <@051300> ;append.whiteSpace
	lib/std/string.ci:145: (14 bytes: <@052d9a> - <@052da8>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @052d9a>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @052d9f>   : 1f f2 f5 01 00             load.ref <@01f5f2> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @052da4>   : 2d 08 13 05                store.m64 <@051308> ;append.radixDigits
	lib/std/string.ci:223: (26 bytes: <@052da8> - <@052dc2>): static const format: FormatFlags := {...}
	<.main+28 @052da8>   : 1c 0a 00 00 00             load.c32 10
	<.main+33 @052dad>   : 2e f8 15 05                store.m32 <@0515f8> ;append.format
	:: (7 bytes: <@052db1> - <@052db8>): void(format.padChr := (0))
	<.main+37 @052db1>   : 19                         load.z32
	<.main+38 @052db2>   : 1f fc 15 05 00             load.ref <@0515fc> ;append.format+4
	<.main+43 @052db7>   : 25                         store.i8
	:: (5 bytes: <@052db8> - <@052dbd>): void(format.padLen := 0)
	<.main+44 @052db8>   : 19                         load.z32
	<.main+45 @052db9>   : 2e 00 16 05                store.m32 <@051600> ;append.format+8
	:: (5 bytes: <@052dbd> - <@052dc2>): void(format.precision := 0)
	<.main+49 @052dbd>   : 19                         load.z32
	<.main+50 @052dbe>   : 2e 04 16 05                store.m32 <@051604> ;append.format+12
	test/lang/emit.ci:3: (5 bytes: <@052dc2> - <@052dc7>): static emitldz32: int32 := emit(load.z32)
	<.main+54 @052dc2>   : 19                         load.z32
	<.main+55 @052dc3>   : 2e 38 18 05                store.m32 <@051838> ;emitldz32
	test/lang/emit.ci:4: (5 bytes: <@052dc7> - <@052dcc>): static emitldz64: int64 := emit(load.z64)
	<.main+59 @052dc7>   : 1a                         load.z64
	<.main+60 @052dc8>   : 2d 40 18 05                store.m64 <@051840> ;emitldz64
	test/lang/emit.ci:6: (9 bytes: <@052dcc> - <@052dd5>): static emitA: int32 := 42
	<.main+64 @052dcc>   : 1c 2a 00 00 00             load.c32 42
	<.main+69 @052dd1>   : 2e 48 18 05                store.m32 <@051848> ;emitA
	test/lang/emit.ci:7: (9 bytes: <@052dd5> - <@052dde>): static emitB: int32 := 96
	<.main+73 @052dd5>   : 1c 60 00 00 00             load.c32 96
	<.main+78 @052dda>   : 2e 50 18 05                store.m32 <@051850> ;emitB
	test/lang/emit.ci:9: (13 bytes: <@052dde> - <@052deb>): static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32))
	<.main+82 @052dde>   : 2a 48 18 05                load.m32 <@051848> ;emitA
	<.main+86 @052de2>   : 2a 50 18 05                load.m32 <@051850> ;emitB
	<.main+90 @052de6>   : 51                         add.i32
	<.main+91 @052de7>   : 2e 58 18 05                store.m32 <@051858> ;emitAddI32
	test/lang/emit.ci:10: (15 bytes: <@052deb> - <@052dfa>): static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32))
	<.main+95 @052deb>   : 1c 0a 00 00 00             load.c32 10
	<.main+100 @052df0>  : 1c 05 00 00 00             load.c32 5
	<.main+105 @052df5>  : 54                         div.i32
	<.main+106 @052df6>  : 2e 60 18 05                store.m32 <@051860> ;emitDivI32
	test/lang/emit.ci:17: (9 bytes: <@052dfa> - <@052e03>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+110 @052dfa>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+115 @052dff>  : 2e 68 18 05                store.m32 <@051868> ;emitFloatAsInt1
	test/lang/emit.ci:18: (10 bytes: <@052e03> - <@052e0d>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+119 @052e03>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+124 @052e08>  : 5b                         i32.2i64
	<.main+125 @052e09>  : 2d 70 18 05                store.m64 <@051870> ;emitFloatAsInt2
	test/lang/emit.ci:19: (14 bytes: <@052e0d> - <@052e1b>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+129 @052e0d>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+138 @052e16>  : 6a                         i64.2i32
	<.main+139 @052e17>  : 2e 78 18 05                store.m32 <@051878> ;emitFloatAsInt3
	test/lang/emit.ci:20: (13 bytes: <@052e1b> - <@052e28>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+143 @052e1b>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+152 @052e24>  : 2d 80 18 05                store.m64 <@051880> ;emitFloatAsInt4
	test/lang/emit.ci:23: (14 bytes: <@052e28> - <@052e36>): static emitSlice: char[] := emit(void(int32(3), pointer("string")))
	<.main+156 @052e28>  : 1c 03 00 00 00             load.c32 3
	<.main+161 @052e2d>  : 1f 54 b7 02 00             load.ref <@02b754> ;"string"
	<.main+166 @052e32>  : 2d 88 18 05                store.m64 <@051888> ;emitSlice
	test/lang/inlineMacros.ci:10: (9 bytes: <@052e36> - <@052e3f>): static i3: int32 := 3
	<.main+170 @052e36>  : 1c 03 00 00 00             load.c32 3
	<.main+175 @052e3b>  : 2e 90 18 05                store.m32 <@051890> ;i3
	test/lang/inlineMacros.ci:11: (9 bytes: <@052e3f> - <@052e48>): static i6: int32 := 6
	<.main+179 @052e3f>  : 1c 06 00 00 00             load.c32 6
	<.main+184 @052e44>  : 2e 98 18 05                store.m32 <@051898> ;i6
	test/lang/inlineMacros.ci:12: (9 bytes: <@052e48> - <@052e51>): static i2: int32 := 2
	<.main+188 @052e48>  : 1c 02 00 00 00             load.c32 2
	<.main+193 @052e4d>  : 2e a0 18 05                store.m32 <@0518a0> ;i2
	test/lang/inlineMacros.ci:13: (9 bytes: <@052e51> - <@052e5a>): static i8: int32 := 8
	<.main+197 @052e51>  : 1c 08 00 00 00             load.c32 8
	<.main+202 @052e56>  : 2e a8 18 05                store.m32 <@0518a8> ;i8
	test/lang/inlineMacros.ci:15: (5 bytes: <@052e5a> - <@052e5f>): static zeroVal: int32 := zero(void(3, 6))
	<.main+206 @052e5a>  : 19                         load.z32
	<.main+207 @052e5b>  : 2e b0 18 05                store.m32 <@0518b0> ;zeroVal
	test/lang/inlineMacros.ci:16: (5 bytes: <@052e5f> - <@052e64>): static zeroVar: int32 := zero(void(i3, i6))
	<.main+211 @052e5f>  : 19                         load.z32
	<.main+212 @052e60>  : 2e b8 18 05                store.m32 <@0518b8> ;zeroVar
	test/lang/inlineMacros.ci:17: (5 bytes: <@052e64> - <@052e69>): static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)))
	<.main+216 @052e64>  : 19                         load.z32
	<.main+217 @052e65>  : 2e c0 18 05                store.m32 <@0518c0> ;zeroXpr
	test/lang/inlineMacros.ci:19: (9 bytes: <@052e69> - <@052e72>): static lastVal: int32 := last(void(3, 6))
	<.main+221 @052e69>  : 1c 06 00 00 00             load.c32 6
	<.main+226 @052e6e>  : 2e c8 18 05                store.m32 <@0518c8> ;lastVal
	test/lang/inlineMacros.ci:20: (8 bytes: <@052e72> - <@052e7a>): static lastVar: int32 := last(void(i3, i6))
	<.main+230 @052e72>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+234 @052e76>  : 2e d0 18 05                store.m32 <@0518d0> ;lastVar
	test/lang/inlineMacros.ci:21: (16 bytes: <@052e7a> - <@052e8a>): static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+238 @052e7a>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+242 @052e7e>  : 0c 01 00 00                inc.i32(+1)
	<.main+246 @052e82>  : 0c ff ff ff                inc.i32(-1)
	<.main+250 @052e86>  : 2e d8 18 05                store.m32 <@0518d8> ;lastXpr
	test/lang/inlineMacros.ci:23: (13 bytes: <@052e8a> - <@052e97>): static sum2Val: int32 := sum(void(3, 6))
	<.main+254 @052e8a>  : 1c 03 00 00 00             load.c32 3
	<.main+259 @052e8f>  : 0c 06 00 00                inc.i32(+6)
	<.main+263 @052e93>  : 2e e0 18 05                store.m32 <@0518e0> ;sum2Val
	test/lang/inlineMacros.ci:24: (13 bytes: <@052e97> - <@052ea4>): static sum2Var: int32 := sum(void(i3, i6))
	<.main+267 @052e97>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+271 @052e9b>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+275 @052e9f>  : 51                         add.i32
	<.main+276 @052ea0>  : 2e e8 18 05                store.m32 <@0518e8> ;sum2Var
	test/lang/inlineMacros.ci:25: (25 bytes: <@052ea4> - <@052ebd>): static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
	<.main+280 @052ea4>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+284 @052ea8>  : 0c 01 00 00                inc.i32(+1)
	<.main+288 @052eac>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+292 @052eb0>  : 0c 01 00 00                inc.i32(+1)
	<.main+296 @052eb4>  : 51                         add.i32
	<.main+297 @052eb5>  : 0c fe ff ff                inc.i32(-2)
	<.main+301 @052eb9>  : 2e f0 18 05                store.m32 <@0518f0> ;sum2Xpr
	test/lang/inlineMacros.ci:27: (28 bytes: <@052ebd> - <@052ed9>): static any2Val: int32 := any(void(3, 6))
	<.main+305 @052ebd>  : 1c 03 00 00 00             load.c32 3
	<.main+310 @052ec2>  : 10 00                      dup.x32 sp(0)
	<.main+312 @052ec4>  : 06 0a 00 00                jz <.main+322 @052ece>
	<.main+316 @052ec8>  : 10 00                      dup.x32 sp(0)
	<.main+318 @052eca>  : 04 09 00 00                jmp <.main+327 @052ed3>
	<.main+322 @052ece>  : 1c 06 00 00 00             load.c32 6
	<.main+327 @052ed3>  : 13 01                      set.x32 sp(1)
	<.main+329 @052ed5>  : 2e f8 18 05                store.m32 <@0518f8> ;any2Val
	test/lang/inlineMacros.ci:28: (26 bytes: <@052ed9> - <@052ef3>): static any2Var: int32 := any(void(i3, i6))
	<.main+333 @052ed9>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+337 @052edd>  : 10 00                      dup.x32 sp(0)
	<.main+339 @052edf>  : 06 0a 00 00                jz <.main+349 @052ee9>
	<.main+343 @052ee3>  : 10 00                      dup.x32 sp(0)
	<.main+345 @052ee5>  : 04 08 00 00                jmp <.main+353 @052eed>
	<.main+349 @052ee9>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+353 @052eed>  : 13 01                      set.x32 sp(1)
	<.main+355 @052eef>  : 2e 00 19 05                store.m32 <@051900> ;any2Var
	test/lang/inlineMacros.ci:29: (38 bytes: <@052ef3> - <@052f19>): static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+359 @052ef3>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+363 @052ef7>  : 0c 01 00 00                inc.i32(+1)
	<.main+367 @052efb>  : 10 00                      dup.x32 sp(0)
	<.main+369 @052efd>  : 06 0a 00 00                jz <.main+379 @052f07>
	<.main+373 @052f01>  : 10 00                      dup.x32 sp(0)
	<.main+375 @052f03>  : 04 0c 00 00                jmp <.main+387 @052f0f>
	<.main+379 @052f07>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+383 @052f0b>  : 0c 01 00 00                inc.i32(+1)
	<.main+387 @052f0f>  : 13 01                      set.x32 sp(1)
	<.main+389 @052f11>  : 0c ff ff ff                inc.i32(-1)
	<.main+393 @052f15>  : 2e 08 19 05                store.m32 <@051908> ;any2Xpr
	test/lang/inlineMacros.ci:31: (37 bytes: <@052f19> - <@052f3e>): static min2Val: int32 := min(void(3, 6))
	<.main+397 @052f19>  : 1c 03 00 00 00             load.c32 3
	<.main+402 @052f1e>  : 1c 06 00 00 00             load.c32 6
	<.main+407 @052f23>  : 10 01                      dup.x32 sp(1)
	<.main+409 @052f25>  : 10 01                      dup.x32 sp(1)
	<.main+411 @052f27>  : 58                         clt.i32
	<.main+412 @052f28>  : 06 0a 00 00                jz <.main+422 @052f32>
	<.main+416 @052f2c>  : 10 01                      dup.x32 sp(1)
	<.main+418 @052f2e>  : 04 06 00 00                jmp <.main+424 @052f34>
	<.main+422 @052f32>  : 10 00                      dup.x32 sp(0)
	<.main+424 @052f34>  : 13 02                      set.x32 sp(2)
	<.main+426 @052f36>  : 09 fc ff ff                inc.sp(-4)
	<.main+430 @052f3a>  : 2e 10 19 05                store.m32 <@051910> ;min2Val
	test/lang/inlineMacros.ci:32: (35 bytes: <@052f3e> - <@052f61>): static min2Var: int32 := min(void(i3, i6))
	<.main+434 @052f3e>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+438 @052f42>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+442 @052f46>  : 10 01                      dup.x32 sp(1)
	<.main+444 @052f48>  : 10 01                      dup.x32 sp(1)
	<.main+446 @052f4a>  : 58                         clt.i32
	<.main+447 @052f4b>  : 06 0a 00 00                jz <.main+457 @052f55>
	<.main+451 @052f4f>  : 10 01                      dup.x32 sp(1)
	<.main+453 @052f51>  : 04 06 00 00                jmp <.main+459 @052f57>
	<.main+457 @052f55>  : 10 00                      dup.x32 sp(0)
	<.main+459 @052f57>  : 13 02                      set.x32 sp(2)
	<.main+461 @052f59>  : 09 fc ff ff                inc.sp(-4)
	<.main+465 @052f5d>  : 2e 18 19 05                store.m32 <@051918> ;min2Var
	test/lang/inlineMacros.ci:33: (47 bytes: <@052f61> - <@052f90>): static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+469 @052f61>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+473 @052f65>  : 0c 01 00 00                inc.i32(+1)
	<.main+477 @052f69>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+481 @052f6d>  : 0c 01 00 00                inc.i32(+1)
	<.main+485 @052f71>  : 10 01                      dup.x32 sp(1)
	<.main+487 @052f73>  : 10 01                      dup.x32 sp(1)
	<.main+489 @052f75>  : 58                         clt.i32
	<.main+490 @052f76>  : 06 0a 00 00                jz <.main+500 @052f80>
	<.main+494 @052f7a>  : 10 01                      dup.x32 sp(1)
	<.main+496 @052f7c>  : 04 06 00 00                jmp <.main+502 @052f82>
	<.main+500 @052f80>  : 10 00                      dup.x32 sp(0)
	<.main+502 @052f82>  : 13 02                      set.x32 sp(2)
	<.main+504 @052f84>  : 09 fc ff ff                inc.sp(-4)
	<.main+508 @052f88>  : 0c ff ff ff                inc.i32(-1)
	<.main+512 @052f8c>  : 2e 20 19 05                store.m32 <@051920> ;min2Xpr
	test/lang/inlineMacros.ci:35: (37 bytes: <@052f90> - <@052fb5>): static max2Val: int32 := max(void(3, 6))
	<.main+516 @052f90>  : 1c 03 00 00 00             load.c32 3
	<.main+521 @052f95>  : 1c 06 00 00 00             load.c32 6
	<.main+526 @052f9a>  : 10 01                      dup.x32 sp(1)
	<.main+528 @052f9c>  : 10 01                      dup.x32 sp(1)
	<.main+530 @052f9e>  : 59                         cgt.i32
	<.main+531 @052f9f>  : 06 0a 00 00                jz <.main+541 @052fa9>
	<.main+535 @052fa3>  : 10 01                      dup.x32 sp(1)
	<.main+537 @052fa5>  : 04 06 00 00                jmp <.main+543 @052fab>
	<.main+541 @052fa9>  : 10 00                      dup.x32 sp(0)
	<.main+543 @052fab>  : 13 02                      set.x32 sp(2)
	<.main+545 @052fad>  : 09 fc ff ff                inc.sp(-4)
	<.main+549 @052fb1>  : 2e 28 19 05                store.m32 <@051928> ;max2Val
	test/lang/inlineMacros.ci:36: (35 bytes: <@052fb5> - <@052fd8>): static max2Var: int32 := max(void(i3, i6))
	<.main+553 @052fb5>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+557 @052fb9>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+561 @052fbd>  : 10 01                      dup.x32 sp(1)
	<.main+563 @052fbf>  : 10 01                      dup.x32 sp(1)
	<.main+565 @052fc1>  : 59                         cgt.i32
	<.main+566 @052fc2>  : 06 0a 00 00                jz <.main+576 @052fcc>
	<.main+570 @052fc6>  : 10 01                      dup.x32 sp(1)
	<.main+572 @052fc8>  : 04 06 00 00                jmp <.main+578 @052fce>
	<.main+576 @052fcc>  : 10 00                      dup.x32 sp(0)
	<.main+578 @052fce>  : 13 02                      set.x32 sp(2)
	<.main+580 @052fd0>  : 09 fc ff ff                inc.sp(-4)
	<.main+584 @052fd4>  : 2e 30 19 05                store.m32 <@051930> ;max2Var
	test/lang/inlineMacros.ci:37: (47 bytes: <@052fd8> - <@053007>): static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
	<.main+588 @052fd8>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+592 @052fdc>  : 0c 01 00 00                inc.i32(+1)
	<.main+596 @052fe0>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+600 @052fe4>  : 0c 01 00 00                inc.i32(+1)
	<.main+604 @052fe8>  : 10 01                      dup.x32 sp(1)
	<.main+606 @052fea>  : 10 01                      dup.x32 sp(1)
	<.main+608 @052fec>  : 59                         cgt.i32
	<.main+609 @052fed>  : 06 0a 00 00                jz <.main+619 @052ff7>
	<.main+613 @052ff1>  : 10 01                      dup.x32 sp(1)
	<.main+615 @052ff3>  : 04 06 00 00                jmp <.main+621 @052ff9>
	<.main+619 @052ff7>  : 10 00                      dup.x32 sp(0)
	<.main+621 @052ff9>  : 13 02                      set.x32 sp(2)
	<.main+623 @052ffb>  : 09 fc ff ff                inc.sp(-4)
	<.main+627 @052fff>  : 0c ff ff ff                inc.i32(-1)
	<.main+631 @053003>  : 2e 38 19 05                store.m32 <@051938> ;max2Xpr
	test/lang/inlineMacros.ci:41: (25 bytes: <@053007> - <@053020>): static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8))
	<.main+635 @053007>  : 1c 03 00 00 00             load.c32 3
	<.main+640 @05300c>  : 1c 06 00 00 00             load.c32 6
	<.main+645 @053011>  : 1c 02 00 00 00             load.c32 2
	<.main+650 @053016>  : 0c 08 00 00                inc.i32(+8)
	<.main+654 @05301a>  : 51                         add.i32
	<.main+655 @05301b>  : 51                         add.i32
	<.main+656 @05301c>  : 2e 40 19 05                store.m32 <@051940> ;sumRlVal
	test/lang/inlineMacros.ci:42: (21 bytes: <@053020> - <@053035>): static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8))
	<.main+660 @053020>  : 1c 03 00 00 00             load.c32 3
	<.main+665 @053025>  : 0c 06 00 00                inc.i32(+6)
	<.main+669 @053029>  : 0c 02 00 00                inc.i32(+2)
	<.main+673 @05302d>  : 0c 08 00 00                inc.i32(+8)
	<.main+677 @053031>  : 2e 48 19 05                store.m32 <@051948> ;sumLrVal
	test/lang/inlineMacros.ci:43: (23 bytes: <@053035> - <@05304c>): static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8))
	<.main+681 @053035>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+685 @053039>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+689 @05303d>  : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+693 @053041>  : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+697 @053045>  : 51                         add.i32
	<.main+698 @053046>  : 51                         add.i32
	<.main+699 @053047>  : 51                         add.i32
	<.main+700 @053048>  : 2e 50 19 05                store.m32 <@051950> ;sumRlVar
	test/lang/inlineMacros.ci:44: (23 bytes: <@05304c> - <@053063>): static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8))
	<.main+704 @05304c>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+708 @053050>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+712 @053054>  : 51                         add.i32
	<.main+713 @053055>  : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+717 @053059>  : 51                         add.i32
	<.main+718 @05305a>  : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+722 @05305e>  : 51                         add.i32
	<.main+723 @05305f>  : 2e 58 19 05                store.m32 <@051958> ;sumLrVar
	test/lang/inlineMacros.ci:45: (43 bytes: <@053063> - <@05308e>): static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+727 @053063>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+731 @053067>  : 0c 01 00 00                inc.i32(+1)
	<.main+735 @05306b>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+739 @05306f>  : 0c 01 00 00                inc.i32(+1)
	<.main+743 @053073>  : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+747 @053077>  : 0c 01 00 00                inc.i32(+1)
	<.main+751 @05307b>  : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+755 @05307f>  : 0c 01 00 00                inc.i32(+1)
	<.main+759 @053083>  : 51                         add.i32
	<.main+760 @053084>  : 51                         add.i32
	<.main+761 @053085>  : 51                         add.i32
	<.main+762 @053086>  : 0c fc ff ff                inc.i32(-4)
	<.main+766 @05308a>  : 2e 60 19 05                store.m32 <@051960> ;sumRlXpr
	test/lang/inlineMacros.ci:46: (43 bytes: <@05308e> - <@0530b9>): static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
	<.main+770 @05308e>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+774 @053092>  : 0c 01 00 00                inc.i32(+1)
	<.main+778 @053096>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+782 @05309a>  : 0c 01 00 00                inc.i32(+1)
	<.main+786 @05309e>  : 51                         add.i32
	<.main+787 @05309f>  : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+791 @0530a3>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @0530a7>  : 51                         add.i32
	<.main+796 @0530a8>  : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+800 @0530ac>  : 0c 01 00 00                inc.i32(+1)
	<.main+804 @0530b0>  : 51                         add.i32
	<.main+805 @0530b1>  : 0c fc ff ff                inc.i32(-4)
	<.main+809 @0530b5>  : 2e 68 19 05                store.m32 <@051968> ;sumLrXpr
	test/lang/inlineMacros.ci:50: (66 bytes: <@0530b9> - <@0530fb>): static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8))
	<.main+813 @0530b9>  : 1c 03 00 00 00             load.c32 3
	<.main+818 @0530be>  : 10 00                      dup.x32 sp(0)
	<.main+820 @0530c0>  : 06 0a 00 00                jz <.main+830 @0530ca>
	<.main+824 @0530c4>  : 10 00                      dup.x32 sp(0)
	<.main+826 @0530c6>  : 04 2f 00 00                jmp <.main+873 @0530f5>
	<.main+830 @0530ca>  : 1c 06 00 00 00             load.c32 6
	<.main+835 @0530cf>  : 10 00                      dup.x32 sp(0)
	<.main+837 @0530d1>  : 06 0a 00 00                jz <.main+847 @0530db>
	<.main+841 @0530d5>  : 10 00                      dup.x32 sp(0)
	<.main+843 @0530d7>  : 04 1c 00 00                jmp <.main+871 @0530f3>
	<.main+847 @0530db>  : 1c 02 00 00 00             load.c32 2
	<.main+852 @0530e0>  : 10 00                      dup.x32 sp(0)
	<.main+854 @0530e2>  : 06 0a 00 00                jz <.main+864 @0530ec>
	<.main+858 @0530e6>  : 10 00                      dup.x32 sp(0)
	<.main+860 @0530e8>  : 04 09 00 00                jmp <.main+869 @0530f1>
	<.main+864 @0530ec>  : 1c 08 00 00 00             load.c32 8
	<.main+869 @0530f1>  : 13 01                      set.x32 sp(1)
	<.main+871 @0530f3>  : 13 01                      set.x32 sp(1)
	<.main+873 @0530f5>  : 13 01                      set.x32 sp(1)
	<.main+875 @0530f7>  : 2e 70 19 05                store.m32 <@051970> ;anyRlVal
	test/lang/inlineMacros.ci:51: (66 bytes: <@0530fb> - <@05313d>): static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8))
	<.main+879 @0530fb>  : 1c 03 00 00 00             load.c32 3
	<.main+884 @053100>  : 10 00                      dup.x32 sp(0)
	<.main+886 @053102>  : 06 0a 00 00                jz <.main+896 @05310c>
	<.main+890 @053106>  : 10 00                      dup.x32 sp(0)
	<.main+892 @053108>  : 04 09 00 00                jmp <.main+901 @053111>
	<.main+896 @05310c>  : 1c 06 00 00 00             load.c32 6
	<.main+901 @053111>  : 13 01                      set.x32 sp(1)
	<.main+903 @053113>  : 10 00                      dup.x32 sp(0)
	<.main+905 @053115>  : 06 0a 00 00                jz <.main+915 @05311f>
	<.main+909 @053119>  : 10 00                      dup.x32 sp(0)
	<.main+911 @05311b>  : 04 09 00 00                jmp <.main+920 @053124>
	<.main+915 @05311f>  : 1c 02 00 00 00             load.c32 2
	<.main+920 @053124>  : 13 01                      set.x32 sp(1)
	<.main+922 @053126>  : 10 00                      dup.x32 sp(0)
	<.main+924 @053128>  : 06 0a 00 00                jz <.main+934 @053132>
	<.main+928 @05312c>  : 10 00                      dup.x32 sp(0)
	<.main+930 @05312e>  : 04 09 00 00                jmp <.main+939 @053137>
	<.main+934 @053132>  : 1c 08 00 00 00             load.c32 8
	<.main+939 @053137>  : 13 01                      set.x32 sp(1)
	<.main+941 @053139>  : 2e 78 19 05                store.m32 <@051978> ;anyLrVal
	test/lang/inlineMacros.ci:52: (62 bytes: <@05313d> - <@05317b>): static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8))
	<.main+945 @05313d>  : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+949 @053141>  : 10 00                      dup.x32 sp(0)
	<.main+951 @053143>  : 06 0a 00 00                jz <.main+961 @05314d>
	<.main+955 @053147>  : 10 00                      dup.x32 sp(0)
	<.main+957 @053149>  : 04 2c 00 00                jmp <.main+1001 @053175>
	<.main+961 @05314d>  : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+965 @053151>  : 10 00                      dup.x32 sp(0)
	<.main+967 @053153>  : 06 0a 00 00                jz <.main+977 @05315d>
	<.main+971 @053157>  : 10 00                      dup.x32 sp(0)
	<.main+973 @053159>  : 04 1a 00 00                jmp <.main+999 @053173>
	<.main+977 @05315d>  : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+981 @053161>  : 10 00                      dup.x32 sp(0)
	<.main+983 @053163>  : 06 0a 00 00                jz <.main+993 @05316d>
	<.main+987 @053167>  : 10 00                      dup.x32 sp(0)
	<.main+989 @053169>  : 04 08 00 00                jmp <.main+997 @053171>
	<.main+993 @05316d>  : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+997 @053171>  : 13 01                      set.x32 sp(1)
	<.main+999 @053173>  : 13 01                      set.x32 sp(1)
	<.main+1001 @053175> : 13 01                      set.x32 sp(1)
	<.main+1003 @053177> : 2e 80 19 05                store.m32 <@051980> ;anyRlVar
	test/lang/inlineMacros.ci:53: (62 bytes: <@05317b> - <@0531b9>): static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8))
	<.main+1007 @05317b> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1011 @05317f> : 10 00                      dup.x32 sp(0)
	<.main+1013 @053181> : 06 0a 00 00                jz <.main+1023 @05318b>
	<.main+1017 @053185> : 10 00                      dup.x32 sp(0)
	<.main+1019 @053187> : 04 08 00 00                jmp <.main+1027 @05318f>
	<.main+1023 @05318b> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1027 @05318f> : 13 01                      set.x32 sp(1)
	<.main+1029 @053191> : 10 00                      dup.x32 sp(0)
	<.main+1031 @053193> : 06 0a 00 00                jz <.main+1041 @05319d>
	<.main+1035 @053197> : 10 00                      dup.x32 sp(0)
	<.main+1037 @053199> : 04 08 00 00                jmp <.main+1045 @0531a1>
	<.main+1041 @05319d> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1045 @0531a1> : 13 01                      set.x32 sp(1)
	<.main+1047 @0531a3> : 10 00                      dup.x32 sp(0)
	<.main+1049 @0531a5> : 06 0a 00 00                jz <.main+1059 @0531af>
	<.main+1053 @0531a9> : 10 00                      dup.x32 sp(0)
	<.main+1055 @0531ab> : 04 08 00 00                jmp <.main+1063 @0531b3>
	<.main+1059 @0531af> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1063 @0531b3> : 13 01                      set.x32 sp(1)
	<.main+1065 @0531b5> : 2e 88 19 05                store.m32 <@051988> ;anyLrVar
	test/lang/inlineMacros.ci:54: (82 bytes: <@0531b9> - <@05320b>): static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1069 @0531b9> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1073 @0531bd> : 0c 01 00 00                inc.i32(+1)
	<.main+1077 @0531c1> : 10 00                      dup.x32 sp(0)
	<.main+1079 @0531c3> : 06 0a 00 00                jz <.main+1089 @0531cd>
	<.main+1083 @0531c7> : 10 00                      dup.x32 sp(0)
	<.main+1085 @0531c9> : 04 38 00 00                jmp <.main+1141 @053201>
	<.main+1089 @0531cd> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1093 @0531d1> : 0c 01 00 00                inc.i32(+1)
	<.main+1097 @0531d5> : 10 00                      dup.x32 sp(0)
	<.main+1099 @0531d7> : 06 0a 00 00                jz <.main+1109 @0531e1>
	<.main+1103 @0531db> : 10 00                      dup.x32 sp(0)
	<.main+1105 @0531dd> : 04 22 00 00                jmp <.main+1139 @0531ff>
	<.main+1109 @0531e1> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1113 @0531e5> : 0c 01 00 00                inc.i32(+1)
	<.main+1117 @0531e9> : 10 00                      dup.x32 sp(0)
	<.main+1119 @0531eb> : 06 0a 00 00                jz <.main+1129 @0531f5>
	<.main+1123 @0531ef> : 10 00                      dup.x32 sp(0)
	<.main+1125 @0531f1> : 04 0c 00 00                jmp <.main+1137 @0531fd>
	<.main+1129 @0531f5> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1133 @0531f9> : 0c 01 00 00                inc.i32(+1)
	<.main+1137 @0531fd> : 13 01                      set.x32 sp(1)
	<.main+1139 @0531ff> : 13 01                      set.x32 sp(1)
	<.main+1141 @053201> : 13 01                      set.x32 sp(1)
	<.main+1143 @053203> : 0c ff ff ff                inc.i32(-1)
	<.main+1147 @053207> : 2e 90 19 05                store.m32 <@051990> ;anyRlXpr
	test/lang/inlineMacros.ci:55: (82 bytes: <@05320b> - <@05325d>): static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1151 @05320b> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1155 @05320f> : 0c 01 00 00                inc.i32(+1)
	<.main+1159 @053213> : 10 00                      dup.x32 sp(0)
	<.main+1161 @053215> : 06 0a 00 00                jz <.main+1171 @05321f>
	<.main+1165 @053219> : 10 00                      dup.x32 sp(0)
	<.main+1167 @05321b> : 04 0c 00 00                jmp <.main+1179 @053227>
	<.main+1171 @05321f> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1175 @053223> : 0c 01 00 00                inc.i32(+1)
	<.main+1179 @053227> : 13 01                      set.x32 sp(1)
	<.main+1181 @053229> : 10 00                      dup.x32 sp(0)
	<.main+1183 @05322b> : 06 0a 00 00                jz <.main+1193 @053235>
	<.main+1187 @05322f> : 10 00                      dup.x32 sp(0)
	<.main+1189 @053231> : 04 0c 00 00                jmp <.main+1201 @05323d>
	<.main+1193 @053235> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1197 @053239> : 0c 01 00 00                inc.i32(+1)
	<.main+1201 @05323d> : 13 01                      set.x32 sp(1)
	<.main+1203 @05323f> : 10 00                      dup.x32 sp(0)
	<.main+1205 @053241> : 06 0a 00 00                jz <.main+1215 @05324b>
	<.main+1209 @053245> : 10 00                      dup.x32 sp(0)
	<.main+1211 @053247> : 04 0c 00 00                jmp <.main+1223 @053253>
	<.main+1215 @05324b> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1219 @05324f> : 0c 01 00 00                inc.i32(+1)
	<.main+1223 @053253> : 13 01                      set.x32 sp(1)
	<.main+1225 @053255> : 0c ff ff ff                inc.i32(-1)
	<.main+1229 @053259> : 2e 98 19 05                store.m32 <@051998> ;anyLrXpr
	test/lang/inlineMacros.ci:59: (93 bytes: <@05325d> - <@0532ba>): static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8))
	<.main+1233 @05325d> : 1c 03 00 00 00             load.c32 3
	<.main+1238 @053262> : 1c 06 00 00 00             load.c32 6
	<.main+1243 @053267> : 1c 02 00 00 00             load.c32 2
	<.main+1248 @05326c> : 1c 08 00 00 00             load.c32 8
	<.main+1253 @053271> : 10 01                      dup.x32 sp(1)
	<.main+1255 @053273> : 10 01                      dup.x32 sp(1)
	<.main+1257 @053275> : 58                         clt.i32
	<.main+1258 @053276> : 06 0a 00 00                jz <.main+1268 @053280>
	<.main+1262 @05327a> : 10 01                      dup.x32 sp(1)
	<.main+1264 @05327c> : 04 06 00 00                jmp <.main+1270 @053282>
	<.main+1268 @053280> : 10 00                      dup.x32 sp(0)
	<.main+1270 @053282> : 13 02                      set.x32 sp(2)
	<.main+1272 @053284> : 09 fc ff ff                inc.sp(-4)
	<.main+1276 @053288> : 10 01                      dup.x32 sp(1)
	<.main+1278 @05328a> : 10 01                      dup.x32 sp(1)
	<.main+1280 @05328c> : 58                         clt.i32
	<.main+1281 @05328d> : 06 0a 00 00                jz <.main+1291 @053297>
	<.main+1285 @053291> : 10 01                      dup.x32 sp(1)
	<.main+1287 @053293> : 04 06 00 00                jmp <.main+1293 @053299>
	<.main+1291 @053297> : 10 00                      dup.x32 sp(0)
	<.main+1293 @053299> : 13 02                      set.x32 sp(2)
	<.main+1295 @05329b> : 09 fc ff ff                inc.sp(-4)
	<.main+1299 @05329f> : 10 01                      dup.x32 sp(1)
	<.main+1301 @0532a1> : 10 01                      dup.x32 sp(1)
	<.main+1303 @0532a3> : 58                         clt.i32
	<.main+1304 @0532a4> : 06 0a 00 00                jz <.main+1314 @0532ae>
	<.main+1308 @0532a8> : 10 01                      dup.x32 sp(1)
	<.main+1310 @0532aa> : 04 06 00 00                jmp <.main+1316 @0532b0>
	<.main+1314 @0532ae> : 10 00                      dup.x32 sp(0)
	<.main+1316 @0532b0> : 13 02                      set.x32 sp(2)
	<.main+1318 @0532b2> : 09 fc ff ff                inc.sp(-4)
	<.main+1322 @0532b6> : 2e a0 19 05                store.m32 <@0519a0> ;minRlVal
	test/lang/inlineMacros.ci:60: (93 bytes: <@0532ba> - <@053317>): static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8))
	<.main+1326 @0532ba> : 1c 03 00 00 00             load.c32 3
	<.main+1331 @0532bf> : 1c 06 00 00 00             load.c32 6
	<.main+1336 @0532c4> : 10 01                      dup.x32 sp(1)
	<.main+1338 @0532c6> : 10 01                      dup.x32 sp(1)
	<.main+1340 @0532c8> : 58                         clt.i32
	<.main+1341 @0532c9> : 06 0a 00 00                jz <.main+1351 @0532d3>
	<.main+1345 @0532cd> : 10 01                      dup.x32 sp(1)
	<.main+1347 @0532cf> : 04 06 00 00                jmp <.main+1353 @0532d5>
	<.main+1351 @0532d3> : 10 00                      dup.x32 sp(0)
	<.main+1353 @0532d5> : 13 02                      set.x32 sp(2)
	<.main+1355 @0532d7> : 09 fc ff ff                inc.sp(-4)
	<.main+1359 @0532db> : 1c 02 00 00 00             load.c32 2
	<.main+1364 @0532e0> : 10 01                      dup.x32 sp(1)
	<.main+1366 @0532e2> : 10 01                      dup.x32 sp(1)
	<.main+1368 @0532e4> : 58                         clt.i32
	<.main+1369 @0532e5> : 06 0a 00 00                jz <.main+1379 @0532ef>
	<.main+1373 @0532e9> : 10 01                      dup.x32 sp(1)
	<.main+1375 @0532eb> : 04 06 00 00                jmp <.main+1381 @0532f1>
	<.main+1379 @0532ef> : 10 00                      dup.x32 sp(0)
	<.main+1381 @0532f1> : 13 02                      set.x32 sp(2)
	<.main+1383 @0532f3> : 09 fc ff ff                inc.sp(-4)
	<.main+1387 @0532f7> : 1c 08 00 00 00             load.c32 8
	<.main+1392 @0532fc> : 10 01                      dup.x32 sp(1)
	<.main+1394 @0532fe> : 10 01                      dup.x32 sp(1)
	<.main+1396 @053300> : 58                         clt.i32
	<.main+1397 @053301> : 06 0a 00 00                jz <.main+1407 @05330b>
	<.main+1401 @053305> : 10 01                      dup.x32 sp(1)
	<.main+1403 @053307> : 04 06 00 00                jmp <.main+1409 @05330d>
	<.main+1407 @05330b> : 10 00                      dup.x32 sp(0)
	<.main+1409 @05330d> : 13 02                      set.x32 sp(2)
	<.main+1411 @05330f> : 09 fc ff ff                inc.sp(-4)
	<.main+1415 @053313> : 2e a8 19 05                store.m32 <@0519a8> ;minLrVal
	test/lang/inlineMacros.ci:61: (89 bytes: <@053317> - <@053370>): static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8))
	<.main+1419 @053317> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1423 @05331b> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1427 @05331f> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1431 @053323> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1435 @053327> : 10 01                      dup.x32 sp(1)
	<.main+1437 @053329> : 10 01                      dup.x32 sp(1)
	<.main+1439 @05332b> : 58                         clt.i32
	<.main+1440 @05332c> : 06 0a 00 00                jz <.main+1450 @053336>
	<.main+1444 @053330> : 10 01                      dup.x32 sp(1)
	<.main+1446 @053332> : 04 06 00 00                jmp <.main+1452 @053338>
	<.main+1450 @053336> : 10 00                      dup.x32 sp(0)
	<.main+1452 @053338> : 13 02                      set.x32 sp(2)
	<.main+1454 @05333a> : 09 fc ff ff                inc.sp(-4)
	<.main+1458 @05333e> : 10 01                      dup.x32 sp(1)
	<.main+1460 @053340> : 10 01                      dup.x32 sp(1)
	<.main+1462 @053342> : 58                         clt.i32
	<.main+1463 @053343> : 06 0a 00 00                jz <.main+1473 @05334d>
	<.main+1467 @053347> : 10 01                      dup.x32 sp(1)
	<.main+1469 @053349> : 04 06 00 00                jmp <.main+1475 @05334f>
	<.main+1473 @05334d> : 10 00                      dup.x32 sp(0)
	<.main+1475 @05334f> : 13 02                      set.x32 sp(2)
	<.main+1477 @053351> : 09 fc ff ff                inc.sp(-4)
	<.main+1481 @053355> : 10 01                      dup.x32 sp(1)
	<.main+1483 @053357> : 10 01                      dup.x32 sp(1)
	<.main+1485 @053359> : 58                         clt.i32
	<.main+1486 @05335a> : 06 0a 00 00                jz <.main+1496 @053364>
	<.main+1490 @05335e> : 10 01                      dup.x32 sp(1)
	<.main+1492 @053360> : 04 06 00 00                jmp <.main+1498 @053366>
	<.main+1496 @053364> : 10 00                      dup.x32 sp(0)
	<.main+1498 @053366> : 13 02                      set.x32 sp(2)
	<.main+1500 @053368> : 09 fc ff ff                inc.sp(-4)
	<.main+1504 @05336c> : 2e b0 19 05                store.m32 <@0519b0> ;minRlVar
	test/lang/inlineMacros.ci:62: (89 bytes: <@053370> - <@0533c9>): static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8))
	<.main+1508 @053370> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1512 @053374> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1516 @053378> : 10 01                      dup.x32 sp(1)
	<.main+1518 @05337a> : 10 01                      dup.x32 sp(1)
	<.main+1520 @05337c> : 58                         clt.i32
	<.main+1521 @05337d> : 06 0a 00 00                jz <.main+1531 @053387>
	<.main+1525 @053381> : 10 01                      dup.x32 sp(1)
	<.main+1527 @053383> : 04 06 00 00                jmp <.main+1533 @053389>
	<.main+1531 @053387> : 10 00                      dup.x32 sp(0)
	<.main+1533 @053389> : 13 02                      set.x32 sp(2)
	<.main+1535 @05338b> : 09 fc ff ff                inc.sp(-4)
	<.main+1539 @05338f> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1543 @053393> : 10 01                      dup.x32 sp(1)
	<.main+1545 @053395> : 10 01                      dup.x32 sp(1)
	<.main+1547 @053397> : 58                         clt.i32
	<.main+1548 @053398> : 06 0a 00 00                jz <.main+1558 @0533a2>
	<.main+1552 @05339c> : 10 01                      dup.x32 sp(1)
	<.main+1554 @05339e> : 04 06 00 00                jmp <.main+1560 @0533a4>
	<.main+1558 @0533a2> : 10 00                      dup.x32 sp(0)
	<.main+1560 @0533a4> : 13 02                      set.x32 sp(2)
	<.main+1562 @0533a6> : 09 fc ff ff                inc.sp(-4)
	<.main+1566 @0533aa> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1570 @0533ae> : 10 01                      dup.x32 sp(1)
	<.main+1572 @0533b0> : 10 01                      dup.x32 sp(1)
	<.main+1574 @0533b2> : 58                         clt.i32
	<.main+1575 @0533b3> : 06 0a 00 00                jz <.main+1585 @0533bd>
	<.main+1579 @0533b7> : 10 01                      dup.x32 sp(1)
	<.main+1581 @0533b9> : 04 06 00 00                jmp <.main+1587 @0533bf>
	<.main+1585 @0533bd> : 10 00                      dup.x32 sp(0)
	<.main+1587 @0533bf> : 13 02                      set.x32 sp(2)
	<.main+1589 @0533c1> : 09 fc ff ff                inc.sp(-4)
	<.main+1593 @0533c5> : 2e b8 19 05                store.m32 <@0519b8> ;minLrVar
	test/lang/inlineMacros.ci:63: (109 bytes: <@0533c9> - <@053436>): static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1597 @0533c9> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1601 @0533cd> : 0c 01 00 00                inc.i32(+1)
	<.main+1605 @0533d1> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1609 @0533d5> : 0c 01 00 00                inc.i32(+1)
	<.main+1613 @0533d9> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1617 @0533dd> : 0c 01 00 00                inc.i32(+1)
	<.main+1621 @0533e1> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1625 @0533e5> : 0c 01 00 00                inc.i32(+1)
	<.main+1629 @0533e9> : 10 01                      dup.x32 sp(1)
	<.main+1631 @0533eb> : 10 01                      dup.x32 sp(1)
	<.main+1633 @0533ed> : 58                         clt.i32
	<.main+1634 @0533ee> : 06 0a 00 00                jz <.main+1644 @0533f8>
	<.main+1638 @0533f2> : 10 01                      dup.x32 sp(1)
	<.main+1640 @0533f4> : 04 06 00 00                jmp <.main+1646 @0533fa>
	<.main+1644 @0533f8> : 10 00                      dup.x32 sp(0)
	<.main+1646 @0533fa> : 13 02                      set.x32 sp(2)
	<.main+1648 @0533fc> : 09 fc ff ff                inc.sp(-4)
	<.main+1652 @053400> : 10 01                      dup.x32 sp(1)
	<.main+1654 @053402> : 10 01                      dup.x32 sp(1)
	<.main+1656 @053404> : 58                         clt.i32
	<.main+1657 @053405> : 06 0a 00 00                jz <.main+1667 @05340f>
	<.main+1661 @053409> : 10 01                      dup.x32 sp(1)
	<.main+1663 @05340b> : 04 06 00 00                jmp <.main+1669 @053411>
	<.main+1667 @05340f> : 10 00                      dup.x32 sp(0)
	<.main+1669 @053411> : 13 02                      set.x32 sp(2)
	<.main+1671 @053413> : 09 fc ff ff                inc.sp(-4)
	<.main+1675 @053417> : 10 01                      dup.x32 sp(1)
	<.main+1677 @053419> : 10 01                      dup.x32 sp(1)
	<.main+1679 @05341b> : 58                         clt.i32
	<.main+1680 @05341c> : 06 0a 00 00                jz <.main+1690 @053426>
	<.main+1684 @053420> : 10 01                      dup.x32 sp(1)
	<.main+1686 @053422> : 04 06 00 00                jmp <.main+1692 @053428>
	<.main+1690 @053426> : 10 00                      dup.x32 sp(0)
	<.main+1692 @053428> : 13 02                      set.x32 sp(2)
	<.main+1694 @05342a> : 09 fc ff ff                inc.sp(-4)
	<.main+1698 @05342e> : 0c ff ff ff                inc.i32(-1)
	<.main+1702 @053432> : 2e c0 19 05                store.m32 <@0519c0> ;minRlXpr
	test/lang/inlineMacros.ci:64: (109 bytes: <@053436> - <@0534a3>): static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+1706 @053436> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+1710 @05343a> : 0c 01 00 00                inc.i32(+1)
	<.main+1714 @05343e> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+1718 @053442> : 0c 01 00 00                inc.i32(+1)
	<.main+1722 @053446> : 10 01                      dup.x32 sp(1)
	<.main+1724 @053448> : 10 01                      dup.x32 sp(1)
	<.main+1726 @05344a> : 58                         clt.i32
	<.main+1727 @05344b> : 06 0a 00 00                jz <.main+1737 @053455>
	<.main+1731 @05344f> : 10 01                      dup.x32 sp(1)
	<.main+1733 @053451> : 04 06 00 00                jmp <.main+1739 @053457>
	<.main+1737 @053455> : 10 00                      dup.x32 sp(0)
	<.main+1739 @053457> : 13 02                      set.x32 sp(2)
	<.main+1741 @053459> : 09 fc ff ff                inc.sp(-4)
	<.main+1745 @05345d> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+1749 @053461> : 0c 01 00 00                inc.i32(+1)
	<.main+1753 @053465> : 10 01                      dup.x32 sp(1)
	<.main+1755 @053467> : 10 01                      dup.x32 sp(1)
	<.main+1757 @053469> : 58                         clt.i32
	<.main+1758 @05346a> : 06 0a 00 00                jz <.main+1768 @053474>
	<.main+1762 @05346e> : 10 01                      dup.x32 sp(1)
	<.main+1764 @053470> : 04 06 00 00                jmp <.main+1770 @053476>
	<.main+1768 @053474> : 10 00                      dup.x32 sp(0)
	<.main+1770 @053476> : 13 02                      set.x32 sp(2)
	<.main+1772 @053478> : 09 fc ff ff                inc.sp(-4)
	<.main+1776 @05347c> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+1780 @053480> : 0c 01 00 00                inc.i32(+1)
	<.main+1784 @053484> : 10 01                      dup.x32 sp(1)
	<.main+1786 @053486> : 10 01                      dup.x32 sp(1)
	<.main+1788 @053488> : 58                         clt.i32
	<.main+1789 @053489> : 06 0a 00 00                jz <.main+1799 @053493>
	<.main+1793 @05348d> : 10 01                      dup.x32 sp(1)
	<.main+1795 @05348f> : 04 06 00 00                jmp <.main+1801 @053495>
	<.main+1799 @053493> : 10 00                      dup.x32 sp(0)
	<.main+1801 @053495> : 13 02                      set.x32 sp(2)
	<.main+1803 @053497> : 09 fc ff ff                inc.sp(-4)
	<.main+1807 @05349b> : 0c ff ff ff                inc.i32(-1)
	<.main+1811 @05349f> : 2e c8 19 05                store.m32 <@0519c8> ;minLrXpr
	test/lang/inlineMacros.ci:68: (93 bytes: <@0534a3> - <@053500>): static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8))
	<.main+1815 @0534a3> : 1c 03 00 00 00             load.c32 3
	<.main+1820 @0534a8> : 1c 06 00 00 00             load.c32 6
	<.main+1825 @0534ad> : 1c 02 00 00 00             load.c32 2
	<.main+1830 @0534b2> : 1c 08 00 00 00             load.c32 8
	<.main+1835 @0534b7> : 10 01                      dup.x32 sp(1)
	<.main+1837 @0534b9> : 10 01                      dup.x32 sp(1)
	<.main+1839 @0534bb> : 59                         cgt.i32
	<.main+1840 @0534bc> : 06 0a 00 00                jz <.main+1850 @0534c6>
	<.main+1844 @0534c0> : 10 01                      dup.x32 sp(1)
	<.main+1846 @0534c2> : 04 06 00 00                jmp <.main+1852 @0534c8>
	<.main+1850 @0534c6> : 10 00                      dup.x32 sp(0)
	<.main+1852 @0534c8> : 13 02                      set.x32 sp(2)
	<.main+1854 @0534ca> : 09 fc ff ff                inc.sp(-4)
	<.main+1858 @0534ce> : 10 01                      dup.x32 sp(1)
	<.main+1860 @0534d0> : 10 01                      dup.x32 sp(1)
	<.main+1862 @0534d2> : 59                         cgt.i32
	<.main+1863 @0534d3> : 06 0a 00 00                jz <.main+1873 @0534dd>
	<.main+1867 @0534d7> : 10 01                      dup.x32 sp(1)
	<.main+1869 @0534d9> : 04 06 00 00                jmp <.main+1875 @0534df>
	<.main+1873 @0534dd> : 10 00                      dup.x32 sp(0)
	<.main+1875 @0534df> : 13 02                      set.x32 sp(2)
	<.main+1877 @0534e1> : 09 fc ff ff                inc.sp(-4)
	<.main+1881 @0534e5> : 10 01                      dup.x32 sp(1)
	<.main+1883 @0534e7> : 10 01                      dup.x32 sp(1)
	<.main+1885 @0534e9> : 59                         cgt.i32
	<.main+1886 @0534ea> : 06 0a 00 00                jz <.main+1896 @0534f4>
	<.main+1890 @0534ee> : 10 01                      dup.x32 sp(1)
	<.main+1892 @0534f0> : 04 06 00 00                jmp <.main+1898 @0534f6>
	<.main+1896 @0534f4> : 10 00                      dup.x32 sp(0)
	<.main+1898 @0534f6> : 13 02                      set.x32 sp(2)
	<.main+1900 @0534f8> : 09 fc ff ff                inc.sp(-4)
	<.main+1904 @0534fc> : 2e d0 19 05                store.m32 <@0519d0> ;maxRlVal
	test/lang/inlineMacros.ci:69: (93 bytes: <@053500> - <@05355d>): static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8))
	<.main+1908 @053500> : 1c 03 00 00 00             load.c32 3
	<.main+1913 @053505> : 1c 06 00 00 00             load.c32 6
	<.main+1918 @05350a> : 10 01                      dup.x32 sp(1)
	<.main+1920 @05350c> : 10 01                      dup.x32 sp(1)
	<.main+1922 @05350e> : 59                         cgt.i32
	<.main+1923 @05350f> : 06 0a 00 00                jz <.main+1933 @053519>
	<.main+1927 @053513> : 10 01                      dup.x32 sp(1)
	<.main+1929 @053515> : 04 06 00 00                jmp <.main+1935 @05351b>
	<.main+1933 @053519> : 10 00                      dup.x32 sp(0)
	<.main+1935 @05351b> : 13 02                      set.x32 sp(2)
	<.main+1937 @05351d> : 09 fc ff ff                inc.sp(-4)
	<.main+1941 @053521> : 1c 02 00 00 00             load.c32 2
	<.main+1946 @053526> : 10 01                      dup.x32 sp(1)
	<.main+1948 @053528> : 10 01                      dup.x32 sp(1)
	<.main+1950 @05352a> : 59                         cgt.i32
	<.main+1951 @05352b> : 06 0a 00 00                jz <.main+1961 @053535>
	<.main+1955 @05352f> : 10 01                      dup.x32 sp(1)
	<.main+1957 @053531> : 04 06 00 00                jmp <.main+1963 @053537>
	<.main+1961 @053535> : 10 00                      dup.x32 sp(0)
	<.main+1963 @053537> : 13 02                      set.x32 sp(2)
	<.main+1965 @053539> : 09 fc ff ff                inc.sp(-4)
	<.main+1969 @05353d> : 1c 08 00 00 00             load.c32 8
	<.main+1974 @053542> : 10 01                      dup.x32 sp(1)
	<.main+1976 @053544> : 10 01                      dup.x32 sp(1)
	<.main+1978 @053546> : 59                         cgt.i32
	<.main+1979 @053547> : 06 0a 00 00                jz <.main+1989 @053551>
	<.main+1983 @05354b> : 10 01                      dup.x32 sp(1)
	<.main+1985 @05354d> : 04 06 00 00                jmp <.main+1991 @053553>
	<.main+1989 @053551> : 10 00                      dup.x32 sp(0)
	<.main+1991 @053553> : 13 02                      set.x32 sp(2)
	<.main+1993 @053555> : 09 fc ff ff                inc.sp(-4)
	<.main+1997 @053559> : 2e d8 19 05                store.m32 <@0519d8> ;maxLrVal
	test/lang/inlineMacros.ci:70: (89 bytes: <@05355d> - <@0535b6>): static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8))
	<.main+2001 @05355d> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+2005 @053561> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+2009 @053565> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+2013 @053569> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+2017 @05356d> : 10 01                      dup.x32 sp(1)
	<.main+2019 @05356f> : 10 01                      dup.x32 sp(1)
	<.main+2021 @053571> : 59                         cgt.i32
	<.main+2022 @053572> : 06 0a 00 00                jz <.main+2032 @05357c>
	<.main+2026 @053576> : 10 01                      dup.x32 sp(1)
	<.main+2028 @053578> : 04 06 00 00                jmp <.main+2034 @05357e>
	<.main+2032 @05357c> : 10 00                      dup.x32 sp(0)
	<.main+2034 @05357e> : 13 02                      set.x32 sp(2)
	<.main+2036 @053580> : 09 fc ff ff                inc.sp(-4)
	<.main+2040 @053584> : 10 01                      dup.x32 sp(1)
	<.main+2042 @053586> : 10 01                      dup.x32 sp(1)
	<.main+2044 @053588> : 59                         cgt.i32
	<.main+2045 @053589> : 06 0a 00 00                jz <.main+2055 @053593>
	<.main+2049 @05358d> : 10 01                      dup.x32 sp(1)
	<.main+2051 @05358f> : 04 06 00 00                jmp <.main+2057 @053595>
	<.main+2055 @053593> : 10 00                      dup.x32 sp(0)
	<.main+2057 @053595> : 13 02                      set.x32 sp(2)
	<.main+2059 @053597> : 09 fc ff ff                inc.sp(-4)
	<.main+2063 @05359b> : 10 01                      dup.x32 sp(1)
	<.main+2065 @05359d> : 10 01                      dup.x32 sp(1)
	<.main+2067 @05359f> : 59                         cgt.i32
	<.main+2068 @0535a0> : 06 0a 00 00                jz <.main+2078 @0535aa>
	<.main+2072 @0535a4> : 10 01                      dup.x32 sp(1)
	<.main+2074 @0535a6> : 04 06 00 00                jmp <.main+2080 @0535ac>
	<.main+2078 @0535aa> : 10 00                      dup.x32 sp(0)
	<.main+2080 @0535ac> : 13 02                      set.x32 sp(2)
	<.main+2082 @0535ae> : 09 fc ff ff                inc.sp(-4)
	<.main+2086 @0535b2> : 2e e0 19 05                store.m32 <@0519e0> ;maxRlVar
	test/lang/inlineMacros.ci:71: (89 bytes: <@0535b6> - <@05360f>): static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8))
	<.main+2090 @0535b6> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+2094 @0535ba> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+2098 @0535be> : 10 01                      dup.x32 sp(1)
	<.main+2100 @0535c0> : 10 01                      dup.x32 sp(1)
	<.main+2102 @0535c2> : 59                         cgt.i32
	<.main+2103 @0535c3> : 06 0a 00 00                jz <.main+2113 @0535cd>
	<.main+2107 @0535c7> : 10 01                      dup.x32 sp(1)
	<.main+2109 @0535c9> : 04 06 00 00                jmp <.main+2115 @0535cf>
	<.main+2113 @0535cd> : 10 00                      dup.x32 sp(0)
	<.main+2115 @0535cf> : 13 02                      set.x32 sp(2)
	<.main+2117 @0535d1> : 09 fc ff ff                inc.sp(-4)
	<.main+2121 @0535d5> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+2125 @0535d9> : 10 01                      dup.x32 sp(1)
	<.main+2127 @0535db> : 10 01                      dup.x32 sp(1)
	<.main+2129 @0535dd> : 59                         cgt.i32
	<.main+2130 @0535de> : 06 0a 00 00                jz <.main+2140 @0535e8>
	<.main+2134 @0535e2> : 10 01                      dup.x32 sp(1)
	<.main+2136 @0535e4> : 04 06 00 00                jmp <.main+2142 @0535ea>
	<.main+2140 @0535e8> : 10 00                      dup.x32 sp(0)
	<.main+2142 @0535ea> : 13 02                      set.x32 sp(2)
	<.main+2144 @0535ec> : 09 fc ff ff                inc.sp(-4)
	<.main+2148 @0535f0> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+2152 @0535f4> : 10 01                      dup.x32 sp(1)
	<.main+2154 @0535f6> : 10 01                      dup.x32 sp(1)
	<.main+2156 @0535f8> : 59                         cgt.i32
	<.main+2157 @0535f9> : 06 0a 00 00                jz <.main+2167 @053603>
	<.main+2161 @0535fd> : 10 01                      dup.x32 sp(1)
	<.main+2163 @0535ff> : 04 06 00 00                jmp <.main+2169 @053605>
	<.main+2167 @053603> : 10 00                      dup.x32 sp(0)
	<.main+2169 @053605> : 13 02                      set.x32 sp(2)
	<.main+2171 @053607> : 09 fc ff ff                inc.sp(-4)
	<.main+2175 @05360b> : 2e e8 19 05                store.m32 <@0519e8> ;maxLrVar
	test/lang/inlineMacros.ci:72: (109 bytes: <@05360f> - <@05367c>): static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2179 @05360f> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+2183 @053613> : 0c 01 00 00                inc.i32(+1)
	<.main+2187 @053617> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+2191 @05361b> : 0c 01 00 00                inc.i32(+1)
	<.main+2195 @05361f> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+2199 @053623> : 0c 01 00 00                inc.i32(+1)
	<.main+2203 @053627> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+2207 @05362b> : 0c 01 00 00                inc.i32(+1)
	<.main+2211 @05362f> : 10 01                      dup.x32 sp(1)
	<.main+2213 @053631> : 10 01                      dup.x32 sp(1)
	<.main+2215 @053633> : 59                         cgt.i32
	<.main+2216 @053634> : 06 0a 00 00                jz <.main+2226 @05363e>
	<.main+2220 @053638> : 10 01                      dup.x32 sp(1)
	<.main+2222 @05363a> : 04 06 00 00                jmp <.main+2228 @053640>
	<.main+2226 @05363e> : 10 00                      dup.x32 sp(0)
	<.main+2228 @053640> : 13 02                      set.x32 sp(2)
	<.main+2230 @053642> : 09 fc ff ff                inc.sp(-4)
	<.main+2234 @053646> : 10 01                      dup.x32 sp(1)
	<.main+2236 @053648> : 10 01                      dup.x32 sp(1)
	<.main+2238 @05364a> : 59                         cgt.i32
	<.main+2239 @05364b> : 06 0a 00 00                jz <.main+2249 @053655>
	<.main+2243 @05364f> : 10 01                      dup.x32 sp(1)
	<.main+2245 @053651> : 04 06 00 00                jmp <.main+2251 @053657>
	<.main+2249 @053655> : 10 00                      dup.x32 sp(0)
	<.main+2251 @053657> : 13 02                      set.x32 sp(2)
	<.main+2253 @053659> : 09 fc ff ff                inc.sp(-4)
	<.main+2257 @05365d> : 10 01                      dup.x32 sp(1)
	<.main+2259 @05365f> : 10 01                      dup.x32 sp(1)
	<.main+2261 @053661> : 59                         cgt.i32
	<.main+2262 @053662> : 06 0a 00 00                jz <.main+2272 @05366c>
	<.main+2266 @053666> : 10 01                      dup.x32 sp(1)
	<.main+2268 @053668> : 04 06 00 00                jmp <.main+2274 @05366e>
	<.main+2272 @05366c> : 10 00                      dup.x32 sp(0)
	<.main+2274 @05366e> : 13 02                      set.x32 sp(2)
	<.main+2276 @053670> : 09 fc ff ff                inc.sp(-4)
	<.main+2280 @053674> : 0c ff ff ff                inc.i32(-1)
	<.main+2284 @053678> : 2e f0 19 05                store.m32 <@0519f0> ;maxRlXpr
	test/lang/inlineMacros.ci:73: (109 bytes: <@05367c> - <@0536e9>): static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
	<.main+2288 @05367c> : 2a 90 18 05                load.m32 <@051890> ;i3
	<.main+2292 @053680> : 0c 01 00 00                inc.i32(+1)
	<.main+2296 @053684> : 2a 98 18 05                load.m32 <@051898> ;i6
	<.main+2300 @053688> : 0c 01 00 00                inc.i32(+1)
	<.main+2304 @05368c> : 10 01                      dup.x32 sp(1)
	<.main+2306 @05368e> : 10 01                      dup.x32 sp(1)
	<.main+2308 @053690> : 59                         cgt.i32
	<.main+2309 @053691> : 06 0a 00 00                jz <.main+2319 @05369b>
	<.main+2313 @053695> : 10 01                      dup.x32 sp(1)
	<.main+2315 @053697> : 04 06 00 00                jmp <.main+2321 @05369d>
	<.main+2319 @05369b> : 10 00                      dup.x32 sp(0)
	<.main+2321 @05369d> : 13 02                      set.x32 sp(2)
	<.main+2323 @05369f> : 09 fc ff ff                inc.sp(-4)
	<.main+2327 @0536a3> : 2a a0 18 05                load.m32 <@0518a0> ;i2
	<.main+2331 @0536a7> : 0c 01 00 00                inc.i32(+1)
	<.main+2335 @0536ab> : 10 01                      dup.x32 sp(1)
	<.main+2337 @0536ad> : 10 01                      dup.x32 sp(1)
	<.main+2339 @0536af> : 59                         cgt.i32
	<.main+2340 @0536b0> : 06 0a 00 00                jz <.main+2350 @0536ba>
	<.main+2344 @0536b4> : 10 01                      dup.x32 sp(1)
	<.main+2346 @0536b6> : 04 06 00 00                jmp <.main+2352 @0536bc>
	<.main+2350 @0536ba> : 10 00                      dup.x32 sp(0)
	<.main+2352 @0536bc> : 13 02                      set.x32 sp(2)
	<.main+2354 @0536be> : 09 fc ff ff                inc.sp(-4)
	<.main+2358 @0536c2> : 2a a8 18 05                load.m32 <@0518a8> ;i8
	<.main+2362 @0536c6> : 0c 01 00 00                inc.i32(+1)
	<.main+2366 @0536ca> : 10 01                      dup.x32 sp(1)
	<.main+2368 @0536cc> : 10 01                      dup.x32 sp(1)
	<.main+2370 @0536ce> : 59                         cgt.i32
	<.main+2371 @0536cf> : 06 0a 00 00                jz <.main+2381 @0536d9>
	<.main+2375 @0536d3> : 10 01                      dup.x32 sp(1)
	<.main+2377 @0536d5> : 04 06 00 00                jmp <.main+2383 @0536db>
	<.main+2381 @0536d9> : 10 00                      dup.x32 sp(0)
	<.main+2383 @0536db> : 13 02                      set.x32 sp(2)
	<.main+2385 @0536dd> : 09 fc ff ff                inc.sp(-4)
	<.main+2389 @0536e1> : 0c ff ff ff                inc.i32(-1)
	<.main+2393 @0536e5> : 2e f8 19 05                store.m32 <@0519f8> ;maxLrXpr
	test/lang/overload.inline.ci:9: (9 bytes: <@0536e9> - <@0536f2>): static overload1: float32 := overload
	<.main+2397 @0536e9> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2402 @0536ee> : 2e 00 1a 05                store.m32 <@051a00> ;overload1
	test/lang/overload.inline.ci:10: (9 bytes: <@0536f2> - <@0536fb>): static overload2: float32 := overload()
	<.main+2406 @0536f2> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2411 @0536f7> : 2e 08 1a 05                store.m32 <@051a08> ;overload2
	test/lang/overload.inline.ci:11: (9 bytes: <@0536fb> - <@053704>): static overload3: float32 := overload(0)
	<.main+2415 @0536fb> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2420 @053700> : 2e 10 1a 05                store.m32 <@051a10> ;overload3
	test/lang/overload.inline.ci:12: (9 bytes: <@053704> - <@05370d>): static overload4: float32 := overload(0.000000)
	<.main+2424 @053704> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2429 @053709> : 2e 18 1a 05                store.m32 <@051a18> ;overload4
	test/lang/overload.inline.ci:13: (9 bytes: <@05370d> - <@053716>): static overload5: float32 := overload(void(0, 0))
	<.main+2433 @05370d> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2438 @053712> : 2e 20 1a 05                store.m32 <@051a20> ;overload5
	test/lang/overload.inline.ci:28: (13 bytes: <@053716> - <@053723>): static boilC: Celsius := Celsius(100.000000)
	<.main+2442 @053716> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2451 @05371f> : 2d 28 1a 05                store.m64 <@051a28> ;boilC
	test/lang/overload.inline.ci:29: (28 bytes: <@053723> - <@05373f>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2455 @053723> : 2b 28 1a 05                load.m64 <@051a28> ;boilC
	<.main+2459 @053727> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2468 @053730> : 83                         mul.f64
	<.main+2469 @053731> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2478 @05373a> : 81                         add.f64
	<.main+2479 @05373b> : 2d 30 1a 05                store.m64 <@051a30> ;boilF
	test/lang/initByRef.ci:7: (13 bytes: <@05373f> - <@05374c>): static value: int64 := 42
	<.main+2483 @05373f> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+2492 @053748> : 2d 38 1a 05                store.m64 <@051a38> ;value
	test/lang/initByRef.ci:8: (9 bytes: <@05374c> - <@053755>): static valueRef: int64 := value
	<.main+2496 @05374c> : 1f 38 1a 05 00             load.ref <@051a38> ;value
	<.main+2501 @053751> : 2e 40 1a 05                store.m32 <@051a40> ;valueRef
	test/lang/initByRef.ci:9: (9 bytes: <@053755> - <@05375e>): static valuePtr: pointer := value
	<.main+2505 @053755> : 1f 38 1a 05 00             load.ref <@051a38> ;value
	<.main+2510 @05375a> : 2e 48 1a 05                store.m32 <@051a48> ;valuePtr
	test/lang/initByRef.ci:10: (14 bytes: <@05375e> - <@05376c>): static valueVar: variant := value
	<.main+2514 @05375e> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2519 @053763> : 1f 38 1a 05 00             load.ref <@051a38> ;value
	<.main+2524 @053768> : 2d 50 1a 05                store.m64 <@051a50> ;valueVar
	test/lang/initByRef.ci:12: (9 bytes: <@05376c> - <@053775>): static fromRef: int64 := valueRef
	<.main+2528 @05376c> : 2a 40 1a 05                load.m32 <@051a40> ;valueRef
	<.main+2532 @053770> : 23                         load.i64
	<.main+2533 @053771> : 2d 58 1a 05                store.m64 <@051a58> ;fromRef
	test/lang/initByRef.ci:13: (8 bytes: <@053775> - <@05377d>): static fromPtr: int64 := valuePtr
	<.main+2537 @053775> : 2a 48 1a 05                load.m32 <@051a48> ;valuePtr
	<.main+2541 @053779> : 2e 60 1a 05                store.m32 <@051a60> ;fromPtr
	test/lang/initByRef.ci:14: (8 bytes: <@05377d> - <@053785>): static fromVar: int64 := valueVar
	<.main+2545 @05377d> : 2a 50 1a 05                load.m32 <@051a50> ;valueVar
	<.main+2549 @053781> : 2e 68 1a 05                store.m32 <@051a68> ;fromVar
	test/lang/initByRef.ci:16: (9 bytes: <@053785> - <@05378e>): static nullRef: int64 := null
	<.main+2553 @053785> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2558 @05378a> : 2e 70 1a 05                store.m32 <@051a70> ;nullRef
	test/lang/initByRef.ci:17: (9 bytes: <@05378e> - <@053797>): static nullPtr: pointer := null
	<.main+2562 @05378e> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2567 @053793> : 2e 78 1a 05                store.m32 <@051a78> ;nullPtr
	test/lang/initByRef.ci:18: (14 bytes: <@053797> - <@0537a5>): static nullVar: variant := null
	<.main+2571 @053797> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2576 @05379c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2581 @0537a1> : 2d 80 1a 05                store.m64 <@051a80> ;nullVar
	test/lang/initByRef.ci:19: (9 bytes: <@0537a5> - <@0537ae>): static nullTyp: typename := null
	<.main+2585 @0537a5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2590 @0537aa> : 2e 88 1a 05                store.m32 <@051a88> ;nullTyp
	test/lang/initByRef.ci:20: (9 bytes: <@0537ae> - <@0537b7>): static nullFun: function := null
	<.main+2594 @0537ae> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2599 @0537b3> : 2e 90 1a 05                store.m32 <@051a90> ;nullFun
	test/lang/initByRef.ci:21: (9 bytes: <@0537b7> - <@0537c0>): static nullObj: object := null
	<.main+2603 @0537b7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+2608 @0537bc> : 2e 98 1a 05                store.m32 <@051a98> ;nullObj
	test/lang/initByRef.ci:23: (9 bytes: <@0537c0> - <@0537c9>): static typePtr: pointer := int64
	<.main+2612 @0537c0> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2617 @0537c5> : 2e a0 1a 05                store.m32 <@051aa0> ;typePtr
	test/lang/initByRef.ci:24: (14 bytes: <@0537c9> - <@0537d7>): static typeVar: variant := int64
	<.main+2621 @0537c9> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2626 @0537ce> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2631 @0537d3> : 2d a8 1a 05                store.m64 <@051aa8> ;typeVar
	test/lang/initByRef.ci:25: (9 bytes: <@0537d7> - <@0537e0>): static typeTyp: typename := int64
	<.main+2635 @0537d7> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2640 @0537dc> : 2e b0 1a 05                store.m32 <@051ab0> ;typeTyp
	test/lang/initByRef.ci:27: (8 bytes: <@0537e0> - <@0537e8>): static local: int64 := value
	<.main+2644 @0537e0> : 2b 38 1a 05                load.m64 <@051a38> ;value
	<.main+2648 @0537e4> : 2d b8 1a 05                store.m64 <@051ab8> ;local
	test/lang/initByRef.ci:28: (8 bytes: <@0537e8> - <@0537f0>): static copyVal: int64 := local
	<.main+2652 @0537e8> : 2b b8 1a 05                load.m64 <@051ab8> ;local
	<.main+2656 @0537ec> : 2d c0 1a 05                store.m64 <@051ac0> ;copyVal
	test/lang/initByRef.ci:29: (8 bytes: <@0537f0> - <@0537f8>): static copyRef: int64 := valueRef
	<.main+2660 @0537f0> : 2a 40 1a 05                load.m32 <@051a40> ;valueRef
	<.main+2664 @0537f4> : 2e c8 1a 05                store.m32 <@051ac8> ;copyRef
	test/lang/initByRef.ci:30: (8 bytes: <@0537f8> - <@053800>): static copyPtr: pointer := valuePtr
	<.main+2668 @0537f8> : 2a 48 1a 05                load.m32 <@051a48> ;valuePtr
	<.main+2672 @0537fc> : 2e d0 1a 05                store.m32 <@051ad0> ;copyPtr
	test/lang/initByRef.ci:31: (8 bytes: <@053800> - <@053808>): static copyVar: variant := valueVar
	<.main+2676 @053800> : 2b 50 1a 05                load.m64 <@051a50> ;valueVar
	<.main+2680 @053804> : 2d d8 1a 05                store.m64 <@051ad8> ;copyVar
	test/lang/initByRef.ci:32: (8 bytes: <@053808> - <@053810>): static copyTyp: typename := typeTyp
	<.main+2684 @053808> : 2a b0 1a 05                load.m32 <@051ab0> ;typeTyp
	<.main+2688 @05380c> : 2e e0 1a 05                store.m32 <@051ae0> ;copyTyp
	test/lang/initByRef.ci:35: (9 bytes: <@053810> - <@053819>): static ptrVoid: pointer := void
	<.main+2692 @053810> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2697 @053815> : 2e e8 1a 05                store.m32 <@051ae8> ;ptrVoid
	test/lang/initByRef.ci:36: (9 bytes: <@053819> - <@053822>): static ptrBool: pointer := bool
	<.main+2701 @053819> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2706 @05381e> : 2e f0 1a 05                store.m32 <@051af0> ;ptrBool
	test/lang/initByRef.ci:37: (9 bytes: <@053822> - <@05382b>): static ptrChar: pointer := char
	<.main+2710 @053822> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2715 @053827> : 2e f8 1a 05                store.m32 <@051af8> ;ptrChar
	test/lang/initByRef.ci:38: (9 bytes: <@05382b> - <@053834>): static ptrInt8: pointer := int8
	<.main+2719 @05382b> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2724 @053830> : 2e 00 1b 05                store.m32 <@051b00> ;ptrInt8
	test/lang/initByRef.ci:39: (9 bytes: <@053834> - <@05383d>): static ptrInt16: pointer := int16
	<.main+2728 @053834> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2733 @053839> : 2e 08 1b 05                store.m32 <@051b08> ;ptrInt16
	test/lang/initByRef.ci:40: (9 bytes: <@05383d> - <@053846>): static ptrInt32: pointer := int32
	<.main+2737 @05383d> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2742 @053842> : 2e 10 1b 05                store.m32 <@051b10> ;ptrInt32
	test/lang/initByRef.ci:41: (9 bytes: <@053846> - <@05384f>): static ptrInt64: pointer := int64
	<.main+2746 @053846> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2751 @05384b> : 2e 18 1b 05                store.m32 <@051b18> ;ptrInt64
	test/lang/initByRef.ci:42: (9 bytes: <@05384f> - <@053858>): static ptrUint8: pointer := uint8
	<.main+2755 @05384f> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2760 @053854> : 2e 20 1b 05                store.m32 <@051b20> ;ptrUint8
	test/lang/initByRef.ci:43: (9 bytes: <@053858> - <@053861>): static ptrUint16: pointer := uint16
	<.main+2764 @053858> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2769 @05385d> : 2e 28 1b 05                store.m32 <@051b28> ;ptrUint16
	test/lang/initByRef.ci:44: (9 bytes: <@053861> - <@05386a>): static ptrUint32: pointer := uint32
	<.main+2773 @053861> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2778 @053866> : 2e 30 1b 05                store.m32 <@051b30> ;ptrUint32
	test/lang/initByRef.ci:45: (9 bytes: <@05386a> - <@053873>): static ptrUint64: pointer := uint64
	<.main+2782 @05386a> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+2787 @05386f> : 2e 38 1b 05                store.m32 <@051b38> ;ptrUint64
	test/lang/initByRef.ci:46: (9 bytes: <@053873> - <@05387c>): static ptrFloat32: pointer := float32
	<.main+2791 @053873> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+2796 @053878> : 2e 40 1b 05                store.m32 <@051b40> ;ptrFloat32
	test/lang/initByRef.ci:47: (9 bytes: <@05387c> - <@053885>): static ptrFloat64: pointer := float64
	<.main+2800 @05387c> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+2805 @053881> : 2e 48 1b 05                store.m32 <@051b48> ;ptrFloat64
	test/lang/initByRef.ci:48: (9 bytes: <@053885> - <@05388e>): static ptrTypename: pointer := typename
	<.main+2809 @053885> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2814 @05388a> : 2e 50 1b 05                store.m32 <@051b50> ;ptrTypename
	test/lang/initByRef.ci:49: (9 bytes: <@05388e> - <@053897>): static ptrFunction: pointer := function
	<.main+2818 @05388e> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+2823 @053893> : 2e 58 1b 05                store.m32 <@051b58> ;ptrFunction
	test/lang/initByRef.ci:50: (9 bytes: <@053897> - <@0538a0>): static ptrPointer: pointer := pointer
	<.main+2827 @053897> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+2832 @05389c> : 2e 60 1b 05                store.m32 <@051b60> ;ptrPointer
	test/lang/initByRef.ci:51: (9 bytes: <@0538a0> - <@0538a9>): static ptrVariant: pointer := variant
	<.main+2836 @0538a0> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+2841 @0538a5> : 2e 68 1b 05                store.m32 <@051b68> ;ptrVariant
	test/lang/initByRef.ci:52: (9 bytes: <@0538a9> - <@0538b2>): static ptrObject: pointer := object
	<.main+2845 @0538a9> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+2850 @0538ae> : 2e 70 1b 05                store.m32 <@051b70> ;ptrObject
	test/lang/initByRef.ci:55: (14 bytes: <@0538b2> - <@0538c0>): static varVoid: variant := void
	<.main+2854 @0538b2> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2859 @0538b7> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+2864 @0538bc> : 2d 78 1b 05                store.m64 <@051b78> ;varVoid
	test/lang/initByRef.ci:56: (14 bytes: <@0538c0> - <@0538ce>): static varBool: variant := bool
	<.main+2868 @0538c0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2873 @0538c5> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+2878 @0538ca> : 2d 80 1b 05                store.m64 <@051b80> ;varBool
	test/lang/initByRef.ci:57: (14 bytes: <@0538ce> - <@0538dc>): static varChar: variant := char
	<.main+2882 @0538ce> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2887 @0538d3> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+2892 @0538d8> : 2d 88 1b 05                store.m64 <@051b88> ;varChar
	test/lang/initByRef.ci:58: (14 bytes: <@0538dc> - <@0538ea>): static varInt8: variant := int8
	<.main+2896 @0538dc> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2901 @0538e1> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+2906 @0538e6> : 2d 90 1b 05                store.m64 <@051b90> ;varInt8
	test/lang/initByRef.ci:59: (14 bytes: <@0538ea> - <@0538f8>): static varInt16: variant := int16
	<.main+2910 @0538ea> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2915 @0538ef> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+2920 @0538f4> : 2d 98 1b 05                store.m64 <@051b98> ;varInt16
	test/lang/initByRef.ci:60: (14 bytes: <@0538f8> - <@053906>): static varInt32: variant := int32
	<.main+2924 @0538f8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2929 @0538fd> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+2934 @053902> : 2d a0 1b 05                store.m64 <@051ba0> ;varInt32
	test/lang/initByRef.ci:61: (14 bytes: <@053906> - <@053914>): static varInt64: variant := int64
	<.main+2938 @053906> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2943 @05390b> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+2948 @053910> : 2d a8 1b 05                store.m64 <@051ba8> ;varInt64
	test/lang/initByRef.ci:62: (14 bytes: <@053914> - <@053922>): static varUint8: variant := uint8
	<.main+2952 @053914> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2957 @053919> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+2962 @05391e> : 2d b0 1b 05                store.m64 <@051bb0> ;varUint8
	test/lang/initByRef.ci:63: (14 bytes: <@053922> - <@053930>): static varUint16: variant := uint16
	<.main+2966 @053922> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2971 @053927> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+2976 @05392c> : 2d b8 1b 05                store.m64 <@051bb8> ;varUint16
	test/lang/initByRef.ci:64: (14 bytes: <@053930> - <@05393e>): static varUint32: variant := uint32
	<.main+2980 @053930> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2985 @053935> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+2990 @05393a> : 2d c0 1b 05                store.m64 <@051bc0> ;varUint32
	test/lang/initByRef.ci:65: (14 bytes: <@05393e> - <@05394c>): static varUint64: variant := uint64
	<.main+2994 @05393e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+2999 @053943> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3004 @053948> : 2d c8 1b 05                store.m64 <@051bc8> ;varUint64
	test/lang/initByRef.ci:66: (14 bytes: <@05394c> - <@05395a>): static varFloat32: variant := float32
	<.main+3008 @05394c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3013 @053951> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3018 @053956> : 2d d0 1b 05                store.m64 <@051bd0> ;varFloat32
	test/lang/initByRef.ci:67: (14 bytes: <@05395a> - <@053968>): static varFloat64: variant := float64
	<.main+3022 @05395a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3027 @05395f> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3032 @053964> : 2d d8 1b 05                store.m64 <@051bd8> ;varFloat64
	test/lang/initByRef.ci:68: (14 bytes: <@053968> - <@053976>): static varTypename: variant := typename
	<.main+3036 @053968> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3041 @05396d> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3046 @053972> : 2d e0 1b 05                store.m64 <@051be0> ;varTypename
	test/lang/initByRef.ci:69: (14 bytes: <@053976> - <@053984>): static varFunction: variant := function
	<.main+3050 @053976> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3055 @05397b> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3060 @053980> : 2d e8 1b 05                store.m64 <@051be8> ;varFunction
	test/lang/initByRef.ci:70: (14 bytes: <@053984> - <@053992>): static varPointer: variant := pointer
	<.main+3064 @053984> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3069 @053989> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3074 @05398e> : 2d f0 1b 05                store.m64 <@051bf0> ;varPointer
	test/lang/initByRef.ci:71: (14 bytes: <@053992> - <@0539a0>): static varVariant: variant := variant
	<.main+3078 @053992> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3083 @053997> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3088 @05399c> : 2d f8 1b 05                store.m64 <@051bf8> ;varVariant
	test/lang/initByRef.ci:72: (14 bytes: <@0539a0> - <@0539ae>): static varObject: variant := object
	<.main+3092 @0539a0> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3097 @0539a5> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3102 @0539aa> : 2d 00 1c 05                store.m64 <@051c00> ;varObject
	test/lang/initByRef.ci:75: (9 bytes: <@0539ae> - <@0539b7>): static typVoid: typename := void
	<.main+3106 @0539ae> : 1f b0 00 00 00             load.ref <@0000b0> ;void
	<.main+3111 @0539b3> : 2e 08 1c 05                store.m32 <@051c08> ;typVoid
	test/lang/initByRef.ci:76: (9 bytes: <@0539b7> - <@0539c0>): static typBool: typename := bool
	<.main+3115 @0539b7> : 1f 50 01 00 00             load.ref <@000150> ;bool
	<.main+3120 @0539bc> : 2e 10 1c 05                store.m32 <@051c10> ;typBool
	test/lang/initByRef.ci:77: (9 bytes: <@0539c0> - <@0539c9>): static typChar: typename := char
	<.main+3124 @0539c0> : 1f f0 01 00 00             load.ref <@0001f0> ;char
	<.main+3129 @0539c5> : 2e 18 1c 05                store.m32 <@051c18> ;typChar
	test/lang/initByRef.ci:78: (9 bytes: <@0539c9> - <@0539d2>): static typInt8: typename := int8
	<.main+3133 @0539c9> : 1f 90 02 00 00             load.ref <@000290> ;int8
	<.main+3138 @0539ce> : 2e 20 1c 05                store.m32 <@051c20> ;typInt8
	test/lang/initByRef.ci:79: (9 bytes: <@0539d2> - <@0539db>): static typInt16: typename := int16
	<.main+3142 @0539d2> : 1f 30 03 00 00             load.ref <@000330> ;int16
	<.main+3147 @0539d7> : 2e 28 1c 05                store.m32 <@051c28> ;typInt16
	test/lang/initByRef.ci:80: (9 bytes: <@0539db> - <@0539e4>): static typInt32: typename := int32
	<.main+3151 @0539db> : 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+3156 @0539e0> : 2e 30 1c 05                store.m32 <@051c30> ;typInt32
	test/lang/initByRef.ci:81: (9 bytes: <@0539e4> - <@0539ed>): static typInt64: typename := int64
	<.main+3160 @0539e4> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3165 @0539e9> : 2e 38 1c 05                store.m32 <@051c38> ;typInt64
	test/lang/initByRef.ci:82: (9 bytes: <@0539ed> - <@0539f6>): static typUint8: typename := uint8
	<.main+3169 @0539ed> : 1f 10 05 00 00             load.ref <@000510> ;uint8
	<.main+3174 @0539f2> : 2e 40 1c 05                store.m32 <@051c40> ;typUint8
	test/lang/initByRef.ci:83: (9 bytes: <@0539f6> - <@0539ff>): static typUint16: typename := uint16
	<.main+3178 @0539f6> : 1f b0 05 00 00             load.ref <@0005b0> ;uint16
	<.main+3183 @0539fb> : 2e 48 1c 05                store.m32 <@051c48> ;typUint16
	test/lang/initByRef.ci:84: (9 bytes: <@0539ff> - <@053a08>): static typUint32: typename := uint32
	<.main+3187 @0539ff> : 1f 50 06 00 00             load.ref <@000650> ;uint32
	<.main+3192 @053a04> : 2e 50 1c 05                store.m32 <@051c50> ;typUint32
	test/lang/initByRef.ci:85: (9 bytes: <@053a08> - <@053a11>): static typUint64: typename := uint64
	<.main+3196 @053a08> : 1f f0 06 00 00             load.ref <@0006f0> ;uint64
	<.main+3201 @053a0d> : 2e 58 1c 05                store.m32 <@051c58> ;typUint64
	test/lang/initByRef.ci:86: (9 bytes: <@053a11> - <@053a1a>): static typFloat32: typename := float32
	<.main+3205 @053a11> : 1f 90 07 00 00             load.ref <@000790> ;float32
	<.main+3210 @053a16> : 2e 60 1c 05                store.m32 <@051c60> ;typFloat32
	test/lang/initByRef.ci:87: (9 bytes: <@053a1a> - <@053a23>): static typFloat64: typename := float64
	<.main+3214 @053a1a> : 1f 30 08 00 00             load.ref <@000830> ;float64
	<.main+3219 @053a1f> : 2e 68 1c 05                store.m32 <@051c68> ;typFloat64
	test/lang/initByRef.ci:88: (9 bytes: <@053a23> - <@053a2c>): static typTypename: typename := typename
	<.main+3223 @053a23> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3228 @053a28> : 2e 70 1c 05                store.m32 <@051c70> ;typTypename
	test/lang/initByRef.ci:89: (9 bytes: <@053a2c> - <@053a35>): static typFunction: typename := function
	<.main+3232 @053a2c> : 1f 10 0a 00 00             load.ref <@000a10> ;function
	<.main+3237 @053a31> : 2e 78 1c 05                store.m32 <@051c78> ;typFunction
	test/lang/initByRef.ci:90: (9 bytes: <@053a35> - <@053a3e>): static typPointer: typename := pointer
	<.main+3241 @053a35> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3246 @053a3a> : 2e 80 1c 05                store.m32 <@051c80> ;typPointer
	test/lang/initByRef.ci:91: (9 bytes: <@053a3e> - <@053a47>): static typVariant: typename := variant
	<.main+3250 @053a3e> : 1f 70 09 00 00             load.ref <@000970> ;variant
	<.main+3255 @053a43> : 2e 88 1c 05                store.m32 <@051c88> ;typVariant
	test/lang/initByRef.ci:92: (9 bytes: <@053a47> - <@053a50>): static typObject: typename := object
	<.main+3259 @053a47> : 1f b8 0a 00 00             load.ref <@000ab8> ;object
	<.main+3264 @053a4c> : 2e 90 1c 05                store.m32 <@051c90> ;typObject
	test/lang/initByRef.ci:95: (9 bytes: <@053a50> - <@053a59>): static valueOfPtr: pointer := pointer(value)
	<.main+3268 @053a50> : 1f 38 1a 05 00             load.ref <@051a38> ;value
	<.main+3273 @053a55> : 2e 98 1c 05                store.m32 <@051c98> ;valueOfPtr
	test/lang/initByRef.ci:96: (14 bytes: <@053a59> - <@053a67>): static valueOfVar: variant := variant(value)
	<.main+3277 @053a59> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3282 @053a5e> : 1f 38 1a 05 00             load.ref <@051a38> ;value
	<.main+3287 @053a63> : 2d a0 1c 05                store.m64 <@051ca0> ;valueOfVar
	test/lang/initByRef.ci:97: (9 bytes: <@053a67> - <@053a70>): static valueOfTyp: typename := typename(value)
	<.main+3291 @053a67> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3296 @053a6c> : 2e a8 1c 05                store.m32 <@051ca8> ;valueOfTyp
	test/lang/initByRef.ci:99: (9 bytes: <@053a70> - <@053a79>): static typeOfValue: typename := typename(value)
	<.main+3300 @053a70> : 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+3305 @053a75> : 2e b0 1c 05                store.m32 <@051cb0> ;typeOfValue
	test/lang/initByRef.ci:105: (13 bytes: <@053a79> - <@053a86>): static copyPtrFloat64: variant := ptrFloat64
	<.main+3309 @053a79> : 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+3314 @053a7e> : 2a 48 1b 05                load.m32 <@051b48> ;ptrFloat64
	<.main+3318 @053a82> : 2d b8 1c 05                store.m64 <@051cb8> ;copyPtrFloat64
	test/lang/initByRef.ci:108: (8 bytes: <@053a86> - <@053a8e>): static copyVarFloat64: pointer := varFloat64
	<.main+3322 @053a86> : 2a d8 1b 05                load.m32 <@051bd8> ;varFloat64
	<.main+3326 @053a8a> : 2e c0 1c 05                store.m32 <@051cc0> ;copyVarFloat64
	test/lang/function.ci:12: (25 bytes: <@053a8e> - <@053aa7>): static funAddResult: int32 := funAdd(void(2, 7))
	<.main+3330 @053a8e> : 19                         load.z32
	<.main+3331 @053a8f> : 1c 02 00 00 00             load.c32 2
	<.main+3336 @053a94> : 1c 07 00 00 00             load.c32 7
	<.main+3341 @053a99> : 1f d0 1c 05 00             load.ref <@051cd0> ;funAdd(x: int32, y: int32): int32
	<.main+3346 @053a9e> : 02                         call
	<.main+3347 @053a9f> : 09 f8 ff ff                inc.sp(-8)
	<.main+3351 @053aa3> : 2e d8 1c 05                store.m32 <@051cd8> ;funAddResult
	test/lang/function.ci:15: (9 bytes: <@053aa7> - <@053ab0>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+3355 @053aa7> : 1f d0 1c 05 00             load.ref <@051cd0> ;funAdd(x: int32, y: int32): int32
	<.main+3360 @053aac> : 2e e0 1c 05                store.m32 <@051ce0> ;funAddRef(x: int32, y: int32): int32
	test/lang/function.ci:18: (24 bytes: <@053ab0> - <@053ac8>): static funAddRefResult: int32 := funAddRef(void(2, 8))
	<.main+3364 @053ab0> : 19                         load.z32
	<.main+3365 @053ab1> : 1c 02 00 00 00             load.c32 2
	<.main+3370 @053ab6> : 1c 08 00 00 00             load.c32 8
	<.main+3375 @053abb> : 2a e0 1c 05                load.m32 <@051ce0> ;funAddRef(x: int32, y: int32): int32
	<.main+3379 @053abf> : 02                         call
	<.main+3380 @053ac0> : 09 f8 ff ff                inc.sp(-8)
	<.main+3384 @053ac4> : 2e e8 1c 05                store.m32 <@051ce8> ;funAddRefResult
	test/lang/function.ci:21: (9 bytes: <@053ac8> - <@053ad1>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+3388 @053ac8> : 1f 10 1d 05 00             load.ref <@051d10> ;funMul(x: int32, y: int32): int32
	<.main+3393 @053acd> : 2e f0 1c 05                store.m32 <@051cf0> ;funMul(x: int32, y: int32): int32
	test/lang/function.ci:24: (24 bytes: <@053ad1> - <@053ae9>): static funMulResult: int32 := funMul(void(2, 6))
	<.main+3397 @053ad1> : 19                         load.z32
	<.main+3398 @053ad2> : 1c 02 00 00 00             load.c32 2
	<.main+3403 @053ad7> : 1c 06 00 00 00             load.c32 6
	<.main+3408 @053adc> : 2a f0 1c 05                load.m32 <@051cf0> ;funMul(x: int32, y: int32): int32
	<.main+3412 @053ae0> : 02                         call
	<.main+3413 @053ae1> : 09 f8 ff ff                inc.sp(-8)
	<.main+3417 @053ae5> : 2e f8 1c 05                store.m32 <@051cf8> ;funMulResult
	test/lang/function.ci:27: (8 bytes: <@053ae9> - <@053af1>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+3421 @053ae9> : 2a f0 1c 05                load.m32 <@051cf0> ;funMul(x: int32, y: int32): int32
	<.main+3425 @053aed> : 2e 00 1d 05                store.m32 <@051d00> ;funMulRef(x: int32, y: int32): int32
	test/lang/function.ci:30: (24 bytes: <@053af1> - <@053b09>): static funMulRefResult: int32 := funMulRef(void(2, 7))
	<.main+3429 @053af1> : 19                         load.z32
	<.main+3430 @053af2> : 1c 02 00 00 00             load.c32 2
	<.main+3435 @053af7> : 1c 07 00 00 00             load.c32 7
	<.main+3440 @053afc> : 2a 00 1d 05                load.m32 <@051d00> ;funMulRef(x: int32, y: int32): int32
	<.main+3444 @053b00> : 02                         call
	<.main+3445 @053b01> : 09 f8 ff ff                inc.sp(-8)
	<.main+3449 @053b05> : 2e 08 1d 05                store.m32 <@051d08> ;funMulRefResult
	test/lang/function.ci:46: (20 bytes: <@053b09> - <@053b1d>): static fibonacci_13: uint32 := fib(13)
	<.main+3453 @053b09> : 19                         load.z32
	<.main+3454 @053b0a> : 1c 0d 00 00 00             load.c32 13
	<.main+3459 @053b0f> : 1f 18 1d 05 00             load.ref <@051d18> ;fib(n: uint32): uint32
	<.main+3464 @053b14> : 02                         call
	<.main+3465 @053b15> : 09 fc ff ff                inc.sp(-4)
	<.main+3469 @053b19> : 2e 50 1d 05                store.m32 <@051d50> ;fibonacci_13
	test/lang/reflect.ci:3: (8 bytes: <@053b1d> - <@053b25>): static sizeofVoid: int32 := sizeof(void)
	<.main+3473 @053b1d> : 2a d0 00 00                load.m32 <@0000d0>
	<.main+3477 @053b21> : 2e 58 1d 05                store.m32 <@051d58> ;sizeofVoid
	test/lang/reflect.ci:4: (8 bytes: <@053b25> - <@053b2d>): static sizeofBool: int32 := sizeof(bool)
	<.main+3481 @053b25> : 2a 70 01 00                load.m32 <@000170>
	<.main+3485 @053b29> : 2e 60 1d 05                store.m32 <@051d60> ;sizeofBool
	test/lang/reflect.ci:5: (8 bytes: <@053b2d> - <@053b35>): static sizeofChar: int32 := sizeof(char)
	<.main+3489 @053b2d> : 2a 10 02 00                load.m32 <@000210>
	<.main+3493 @053b31> : 2e 68 1d 05                store.m32 <@051d68> ;sizeofChar
	test/lang/reflect.ci:6: (8 bytes: <@053b35> - <@053b3d>): static sizeofInt8: int32 := sizeof(int8)
	<.main+3497 @053b35> : 2a b0 02 00                load.m32 <@0002b0>
	<.main+3501 @053b39> : 2e 70 1d 05                store.m32 <@051d70> ;sizeofInt8
	test/lang/reflect.ci:7: (8 bytes: <@053b3d> - <@053b45>): static sizeofInt16: int32 := sizeof(int16)
	<.main+3505 @053b3d> : 2a 50 03 00                load.m32 <@000350>
	<.main+3509 @053b41> : 2e 78 1d 05                store.m32 <@051d78> ;sizeofInt16
	test/lang/reflect.ci:8: (8 bytes: <@053b45> - <@053b4d>): static sizeofInt32: int32 := sizeof(int32)
	<.main+3513 @053b45> : 2a f0 03 00                load.m32 <@0003f0>
	<.main+3517 @053b49> : 2e 80 1d 05                store.m32 <@051d80> ;sizeofInt32
	test/lang/reflect.ci:9: (8 bytes: <@053b4d> - <@053b55>): static sizeofInt64: int32 := sizeof(int64)
	<.main+3521 @053b4d> : 2a 90 04 00                load.m32 <@000490>
	<.main+3525 @053b51> : 2e 88 1d 05                store.m32 <@051d88> ;sizeofInt64
	test/lang/reflect.ci:10: (8 bytes: <@053b55> - <@053b5d>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+3529 @053b55> : 2a 30 05 00                load.m32 <@000530>
	<.main+3533 @053b59> : 2e 90 1d 05                store.m32 <@051d90> ;sizeofUint8
	test/lang/reflect.ci:11: (8 bytes: <@053b5d> - <@053b65>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+3537 @053b5d> : 2a d0 05 00                load.m32 <@0005d0>
	<.main+3541 @053b61> : 2e 98 1d 05                store.m32 <@051d98> ;sizeofUint16
	test/lang/reflect.ci:12: (8 bytes: <@053b65> - <@053b6d>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+3545 @053b65> : 2a 70 06 00                load.m32 <@000670>
	<.main+3549 @053b69> : 2e a0 1d 05                store.m32 <@051da0> ;sizeofUint32
	test/lang/reflect.ci:13: (8 bytes: <@053b6d> - <@053b75>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+3553 @053b6d> : 2a 10 07 00                load.m32 <@000710>
	<.main+3557 @053b71> : 2e a8 1d 05                store.m32 <@051da8> ;sizeofUint64
	test/lang/reflect.ci:14: (8 bytes: <@053b75> - <@053b7d>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+3561 @053b75> : 2a b0 07 00                load.m32 <@0007b0>
	<.main+3565 @053b79> : 2e b0 1d 05                store.m32 <@051db0> ;sizeofFloat32
	test/lang/reflect.ci:15: (8 bytes: <@053b7d> - <@053b85>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+3569 @053b7d> : 2a 50 08 00                load.m32 <@000850>
	<.main+3573 @053b81> : 2e b8 1d 05                store.m32 <@051db8> ;sizeofFloat64
	test/lang/reflect.ci:16: (8 bytes: <@053b85> - <@053b8d>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+3577 @053b85> : 2a f0 08 00                load.m32 <@0008f0>
	<.main+3581 @053b89> : 2e c0 1d 05                store.m32 <@051dc0> ;sizeofPointer
	test/lang/reflect.ci:17: (8 bytes: <@053b8d> - <@053b95>): static sizeofVariant: int32 := sizeof(variant)
	<.main+3585 @053b8d> : 2a 90 09 00                load.m32 <@000990>
	<.main+3589 @053b91> : 2e c8 1d 05                store.m32 <@051dc8> ;sizeofVariant
	test/lang/reflect.ci:18: (8 bytes: <@053b95> - <@053b9d>): static sizeofTypename: int32 := sizeof(typename)
	<.main+3593 @053b95> : 2a 28 00 00                load.m32 <@000028> ;typename+32
	<.main+3597 @053b99> : 2e d0 1d 05                store.m32 <@051dd0> ;sizeofTypename
	test/lang/reflect.ci:19: (8 bytes: <@053b9d> - <@053ba5>): static sizeofFunction: int32 := sizeof(function)
	<.main+3601 @053b9d> : 2a 30 0a 00                load.m32 <@000a30>
	<.main+3605 @053ba1> : 2e d8 1d 05                store.m32 <@051dd8> ;sizeofFunction
	test/lang/reflect.ci:20: (8 bytes: <@053ba5> - <@053bad>): static sizeofObject: int32 := sizeof(object)
	<.main+3609 @053ba5> : 2a d8 0a 00                load.m32 <@000ad8>
	<.main+3613 @053ba9> : 2e e0 1d 05                store.m32 <@051de0> ;sizeofObject
	test/lang/reflect.ci:30: (9 bytes: <@053bad> - <@053bb6>): static typeofRecord: typename := RecordSizeofExt
	<.main+3617 @053bad> : 1f e0 75 03 00             load.ref <@0375e0> ;RecordSizeofExt
	<.main+3622 @053bb2> : 2e e8 1d 05                store.m32 <@051de8> ;typeofRecord
	test/lang/reflect.ci:31: (12 bytes: <@053bb6> - <@053bc2>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+3626 @053bb6> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3630 @053bba> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3634 @053bbe> : 2e f0 1d 05                store.m32 <@051df0> ;nameOfRecord
	test/lang/reflect.ci:32: (13 bytes: <@053bc2> - <@053bcf>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+3638 @053bc2> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3642 @053bc6> : 0c 28 00 00                inc.i32(+40)
	<.main+3646 @053bca> : 22                         load.i32
	<.main+3647 @053bcb> : 2e f8 1d 05                store.m32 <@051df8> ;offsetOfRecord
	test/lang/reflect.ci:33: (13 bytes: <@053bcf> - <@053bdc>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+3651 @053bcf> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3655 @053bd3> : 0c 20 00 00                inc.i32(+32)
	<.main+3659 @053bd7> : 22                         load.i32
	<.main+3660 @053bd8> : 2e 00 1e 05                store.m32 <@051e00> ;sizeOfRecord
	test/lang/reflect.ci:34: (12 bytes: <@053bdc> - <@053be8>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+3664 @053bdc> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3668 @053be0> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3672 @053be4> : 2e 08 1e 05                store.m32 <@051e08> ;fileOfRecord
	test/lang/reflect.ci:35: (12 bytes: <@053be8> - <@053bf4>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+3676 @053be8> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3680 @053bec> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3684 @053bf0> : 2e 10 1e 05                store.m32 <@051e10> ;lineOfRecord
	test/lang/reflect.ci:37: (12 bytes: <@053bf4> - <@053c00>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+3688 @053bf4> : 2a e8 1d 05                load.m32 <@051de8> ;typeofRecord
	<.main+3692 @053bf8> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3696 @053bfc> : 2e 18 1e 05                store.m32 <@051e18> ;typeofBase
	test/lang/reflect.ci:38: (12 bytes: <@053c00> - <@053c0c>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+3700 @053c00> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3704 @053c04> : 01 06 00 00                nfc(6) ;typename.name(type: typename): .cstr
	<.main+3708 @053c08> : 2e 20 1e 05                store.m32 <@051e20> ;nameOfBase
	test/lang/reflect.ci:39: (13 bytes: <@053c0c> - <@053c19>): static offsetOfBase: int32 := typeofBase.offset
	<.main+3712 @053c0c> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3716 @053c10> : 0c 28 00 00                inc.i32(+40)
	<.main+3720 @053c14> : 22                         load.i32
	<.main+3721 @053c15> : 2e 28 1e 05                store.m32 <@051e28> ;offsetOfBase
	test/lang/reflect.ci:40: (13 bytes: <@053c19> - <@053c26>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+3725 @053c19> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3729 @053c1d> : 0c 20 00 00                inc.i32(+32)
	<.main+3733 @053c21> : 22                         load.i32
	<.main+3734 @053c22> : 2e 30 1e 05                store.m32 <@051e30> ;sizeOfBase
	test/lang/reflect.ci:41: (12 bytes: <@053c26> - <@053c32>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+3738 @053c26> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3742 @053c2a> : 01 04 00 00                nfc(4) ;typename.file(type: typename): .cstr
	<.main+3746 @053c2e> : 2e 38 1e 05                store.m32 <@051e38> ;fileOfBase
	test/lang/reflect.ci:42: (12 bytes: <@053c32> - <@053c3e>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+3750 @053c32> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3754 @053c36> : 01 05 00 00                nfc(5) ;typename.line(type: typename): int32
	<.main+3758 @053c3a> : 2e 40 1e 05                store.m32 <@051e40> ;lineOfBase
	test/lang/reflect.ci:44: (12 bytes: <@053c3e> - <@053c4a>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+3762 @053c3e> : 2a 18 1e 05                load.m32 <@051e18> ;typeofBase
	<.main+3766 @053c42> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3770 @053c46> : 2e 48 1e 05                store.m32 <@051e48> ;typeofBase1
	test/lang/reflect.ci:45: (13 bytes: <@053c4a> - <@053c57>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+3774 @053c4a> : 2a 48 1e 05                load.m32 <@051e48> ;typeofBase1
	<.main+3778 @053c4e> : 0c 28 00 00                inc.i32(+40)
	<.main+3782 @053c52> : 22                         load.i32
	<.main+3783 @053c53> : 2e 50 1e 05                store.m32 <@051e50> ;offsetOfBase1
	test/lang/reflect.ci:46: (13 bytes: <@053c57> - <@053c64>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+3787 @053c57> : 2a 48 1e 05                load.m32 <@051e48> ;typeofBase1
	<.main+3791 @053c5b> : 0c 20 00 00                inc.i32(+32)
	<.main+3795 @053c5f> : 22                         load.i32
	<.main+3796 @053c60> : 2e 58 1e 05                store.m32 <@051e58> ;sizeOfBase1
	test/lang/reflect.ci:48: (12 bytes: <@053c64> - <@053c70>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+3800 @053c64> : 2a 48 1e 05                load.m32 <@051e48> ;typeofBase1
	<.main+3804 @053c68> : 01 03 00 00                nfc(3) ;typename.base(type: typename): typename
	<.main+3808 @053c6c> : 2e 60 1e 05                store.m32 <@051e60> ;typeofBase2
	test/lang/reflect.ci:49: (13 bytes: <@053c70> - <@053c7d>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+3812 @053c70> : 2a 60 1e 05                load.m32 <@051e60> ;typeofBase2
	<.main+3816 @053c74> : 0c 28 00 00                inc.i32(+40)
	<.main+3820 @053c78> : 22                         load.i32
	<.main+3821 @053c79> : 2e 68 1e 05                store.m32 <@051e68> ;offsetOfBase2
	test/lang/reflect.ci:50: (13 bytes: <@053c7d> - <@053c8a>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+3825 @053c7d> : 2a 60 1e 05                load.m32 <@051e60> ;typeofBase2
	<.main+3829 @053c81> : 0c 20 00 00                inc.i32(+32)
	<.main+3833 @053c85> : 22                         load.i32
	<.main+3834 @053c86> : 2e 70 1e 05                store.m32 <@051e70> ;sizeOfBase2
	test/stdc/number.ci:3: (13 bytes: <@053c8a> - <@053c97>): static pi64: float64 := 3.141593
	<.main+3838 @053c8a> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+3847 @053c93> : 2d 78 1e 05                store.m64 <@051e78> ;pi64
	test/stdc/number.ci:4: (13 bytes: <@053c97> - <@053ca4>): static e64: float64 := 2.718282
	<.main+3851 @053c97> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+3860 @053ca0> : 2d 80 1e 05                store.m64 <@051e80> ;e64
	test/stdc/number.ci:6: (9 bytes: <@053ca4> - <@053cad>): static pi32: float32 := pi64
	<.main+3864 @053ca4> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+3868 @053ca8> : 8c                         f64.2f32
	<.main+3869 @053ca9> : 2e 88 1e 05                store.m32 <@051e88> ;pi32
	test/stdc/number.ci:7: (9 bytes: <@053cad> - <@053cb6>): static e32: float32 := e64
	<.main+3873 @053cad> : 2b 80 1e 05                load.m64 <@051e80> ;e64
	<.main+3877 @053cb1> : 8c                         f64.2f32
	<.main+3878 @053cb2> : 2e 90 1e 05                store.m32 <@051e90> ;e32
	test/stdc/number.ci:14: (11 bytes: <@053cb6> - <@053cc1>): static r_comp: int32 := int32(14 << 3)
	<.main+3882 @053cb6> : 1c 0e 00 00 00             load.c32 14
	<.main+3887 @053cbb> : 3f 43                      b32.shl 0x003
	<.main+3889 @053cbd> : 2e 98 1e 05                store.m32 <@051e98> ;r_comp
	test/stdc/number.ci:15: (11 bytes: <@053cc1> - <@053ccc>): static g_comp: int32 := int32(63 << 2)
	<.main+3893 @053cc1> : 1c 3f 00 00 00             load.c32 63
	<.main+3898 @053cc6> : 3f 42                      b32.shl 0x002
	<.main+3900 @053cc8> : 2e a0 1e 05                store.m32 <@051ea0> ;g_comp
	test/stdc/number.ci:16: (11 bytes: <@053ccc> - <@053cd7>): static b_comp: int32 := int32(31 << 3)
	<.main+3904 @053ccc> : 1c 1f 00 00 00             load.c32 31
	<.main+3909 @053cd1> : 3f 43                      b32.shl 0x003
	<.main+3911 @053cd3> : 2e a8 1e 05                store.m32 <@051ea8> ;b_comp
	test/stdc/number.ci:18: (38 bytes: <@053cd7> - <@053cfd>): static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp))
	<.main+3915 @053cd7> : 2a 98 1e 05                load.m32 <@051e98> ;r_comp
	<.main+3919 @053cdb> : 3f 48                      b32.shl 0x008
	<.main+3921 @053cdd> : 1c 00 f8 00 00             load.c32 63488
	<.main+3926 @053ce2> : 31                         and.b32
	<.main+3927 @053ce3> : 2a a0 1e 05                load.m32 <@051ea0> ;g_comp
	<.main+3931 @053ce7> : 3f 43                      b32.shl 0x003
	<.main+3933 @053ce9> : 1c e0 07 00 00             load.c32 2016
	<.main+3938 @053cee> : 31                         and.b32
	<.main+3939 @053cef> : 32                         or.b32
	<.main+3940 @053cf0> : 2a a8 1e 05                load.m32 <@051ea8> ;b_comp
	<.main+3944 @053cf4> : 3f c3                      b32.sar 0x003
	<.main+3946 @053cf6> : 3f 05                      b32.and 0x01f
	<.main+3948 @053cf8> : 32                         or.b32
	<.main+3949 @053cf9> : 2e b0 1e 05                store.m32 <@051eb0> ;r5g6b5
	test/stdc/number.ci:19: (36 bytes: <@053cfd> - <@053d21>): static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp))
	<.main+3953 @053cfd> : 2a 98 1e 05                load.m32 <@051e98> ;r_comp
	<.main+3957 @053d01> : 3f 50                      b32.shl 0x010
	<.main+3959 @053d03> : 1c 00 00 ff 00             load.c32 16711680
	<.main+3964 @053d08> : 31                         and.b32
	<.main+3965 @053d09> : 2a a0 1e 05                load.m32 <@051ea0> ;g_comp
	<.main+3969 @053d0d> : 3f 48                      b32.shl 0x008
	<.main+3971 @053d0f> : 1c 00 ff 00 00             load.c32 65280
	<.main+3976 @053d14> : 31                         and.b32
	<.main+3977 @053d15> : 32                         or.b32
	<.main+3978 @053d16> : 2a a8 1e 05                load.m32 <@051ea8> ;b_comp
	<.main+3982 @053d1a> : 3f 08                      b32.and 0x0ff
	<.main+3984 @053d1c> : 32                         or.b32
	<.main+3985 @053d1d> : 2e b8 1e 05                store.m32 <@051eb8> ;r8g8b8
	test/stdc/number.ci:21: (22 bytes: <@053d21> - <@053d37>): static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5))
	<.main+3989 @053d21> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+3993 @053d25> : 1c 0b 00 00 00             load.c32 11
	<.main+3998 @053d2a> : 1c 05 00 00 00             load.c32 5
	<.main+4003 @053d2f> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4007 @053d33> : 2e c0 1e 05                store.m32 <@051ec0> ;zxtR5
	test/stdc/number.ci:22: (22 bytes: <@053d37> - <@053d4d>): static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6))
	<.main+4011 @053d37> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4015 @053d3b> : 1c 05 00 00 00             load.c32 5
	<.main+4020 @053d40> : 1c 06 00 00 00             load.c32 6
	<.main+4025 @053d45> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4029 @053d49> : 2e c8 1e 05                store.m32 <@051ec8> ;zxtG6
	test/stdc/number.ci:23: (18 bytes: <@053d4d> - <@053d5f>): static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4033 @053d4d> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4037 @053d51> : 19                         load.z32
	<.main+4038 @053d52> : 1c 05 00 00 00             load.c32 5
	<.main+4043 @053d57> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4047 @053d5b> : 2e d0 1e 05                store.m32 <@051ed0> ;zxtB5
	test/stdc/number.ci:25: (22 bytes: <@053d5f> - <@053d75>): static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5))
	<.main+4051 @053d5f> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4055 @053d63> : 1c 0b 00 00 00             load.c32 11
	<.main+4060 @053d68> : 1c 05 00 00 00             load.c32 5
	<.main+4065 @053d6d> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4069 @053d71> : 2e d8 1e 05                store.m32 <@051ed8> ;sxtR5
	test/stdc/number.ci:26: (22 bytes: <@053d75> - <@053d8b>): static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6))
	<.main+4073 @053d75> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4077 @053d79> : 1c 05 00 00 00             load.c32 5
	<.main+4082 @053d7e> : 1c 06 00 00 00             load.c32 6
	<.main+4087 @053d83> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4091 @053d87> : 2e e0 1e 05                store.m32 <@051ee0> ;sxtG6
	test/stdc/number.ci:27: (18 bytes: <@053d8b> - <@053d9d>): static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4095 @053d8b> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4099 @053d8f> : 19                         load.z32
	<.main+4100 @053d90> : 1c 05 00 00 00             load.c32 5
	<.main+4105 @053d95> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4109 @053d99> : 2e e8 1e 05                store.m32 <@051ee8> ;sxtB5
	test/stdc/number.ci:29: (22 bytes: <@053d9d> - <@053db3>): static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8))
	<.main+4113 @053d9d> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4117 @053da1> : 1c 10 00 00 00             load.c32 16
	<.main+4122 @053da6> : 1c 08 00 00 00             load.c32 8
	<.main+4127 @053dab> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4131 @053daf> : 2e f0 1e 05                store.m32 <@051ef0> ;zxtR8
	test/stdc/number.ci:30: (22 bytes: <@053db3> - <@053dc9>): static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8))
	<.main+4135 @053db3> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4139 @053db7> : 1c 08 00 00 00             load.c32 8
	<.main+4144 @053dbc> : 1c 08 00 00 00             load.c32 8
	<.main+4149 @053dc1> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4153 @053dc5> : 2e f8 1e 05                store.m32 <@051ef8> ;zxtG8
	test/stdc/number.ci:31: (18 bytes: <@053dc9> - <@053ddb>): static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8))
	<.main+4157 @053dc9> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4161 @053dcd> : 19                         load.z32
	<.main+4162 @053dce> : 1c 08 00 00 00             load.c32 8
	<.main+4167 @053dd3> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4171 @053dd7> : 2e 00 1f 05                store.m32 <@051f00> ;zxtB8
	test/stdc/number.ci:33: (22 bytes: <@053ddb> - <@053df1>): static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8))
	<.main+4175 @053ddb> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4179 @053ddf> : 1c 10 00 00 00             load.c32 16
	<.main+4184 @053de4> : 1c 08 00 00 00             load.c32 8
	<.main+4189 @053de9> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4193 @053ded> : 2e 08 1f 05                store.m32 <@051f08> ;sxtR8
	test/stdc/number.ci:34: (22 bytes: <@053df1> - <@053e07>): static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8))
	<.main+4197 @053df1> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4201 @053df5> : 1c 08 00 00 00             load.c32 8
	<.main+4206 @053dfa> : 1c 08 00 00 00             load.c32 8
	<.main+4211 @053dff> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4215 @053e03> : 2e 10 1f 05                store.m32 <@051f10> ;sxtG8
	test/stdc/number.ci:35: (18 bytes: <@053e07> - <@053e19>): static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8))
	<.main+4219 @053e07> : 2a b8 1e 05                load.m32 <@051eb8> ;r8g8b8
	<.main+4223 @053e0b> : 19                         load.z32
	<.main+4224 @053e0c> : 1c 08 00 00 00             load.c32 8
	<.main+4229 @053e11> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4233 @053e15> : 2e 18 1f 05                store.m32 <@051f18> ;sxtB8
	test/stdc/number.ci:37: (22 bytes: <@053e19> - <@053e2f>): static testSin_f64: float64 := float64.sin(float64(pi64 / (2)))
	<.main+4237 @053e19> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4241 @053e1d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4250 @053e26> : 84                         div.f64
	<.main+4251 @053e27> : 01 26 00 00                nfc(38) ;float64.sin(x: float64): float64
	<.main+4255 @053e2b> : 2d 20 1f 05                store.m64 <@051f20> ;testSin_f64
	test/stdc/number.ci:38: (22 bytes: <@053e2f> - <@053e45>): static testCos_f64: float64 := float64.cos(float64(pi64 / (2)))
	<.main+4259 @053e2f> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4263 @053e33> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+4272 @053e3c> : 84                         div.f64
	<.main+4273 @053e3d> : 01 27 00 00                nfc(39) ;float64.cos(x: float64): float64
	<.main+4277 @053e41> : 2d 28 1f 05                store.m64 <@051f28> ;testCos_f64
	test/stdc/number.ci:39: (22 bytes: <@053e45> - <@053e5b>): static testTan_f64: float64 := float64.tan(float64(pi64 / (4)))
	<.main+4281 @053e45> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4285 @053e49> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+4294 @053e52> : 84                         div.f64
	<.main+4295 @053e53> : 01 28 00 00                nfc(40) ;float64.tan(x: float64): float64
	<.main+4299 @053e57> : 2d 30 1f 05                store.m64 <@051f30> ;testTan_f64
	test/stdc/number.ci:40: (22 bytes: <@053e5b> - <@053e71>): static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64))
	<.main+4303 @053e5b> : 2b 80 1e 05                load.m64 <@051e80> ;e64
	<.main+4307 @053e5f> : 2b 80 1e 05                load.m64 <@051e80> ;e64
	<.main+4311 @053e63> : 83                         mul.f64
	<.main+4312 @053e64> : 2b 80 1e 05                load.m64 <@051e80> ;e64
	<.main+4316 @053e68> : 83                         mul.f64
	<.main+4317 @053e69> : 01 29 00 00                nfc(41) ;float64.log(x: float64): float64
	<.main+4321 @053e6d> : 2d 38 1f 05                store.m64 <@051f38> ;testLog_f64
	test/stdc/number.ci:41: (17 bytes: <@053e71> - <@053e82>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+4325 @053e71> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4334 @053e7a> : 01 2a 00 00                nfc(42) ;float64.exp(x: float64): float64
	<.main+4338 @053e7e> : 2d 40 1f 05                store.m64 <@051f40> ;testExp_f64
	test/stdc/number.ci:42: (26 bytes: <@053e82> - <@053e9c>): static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000))
	<.main+4342 @053e82> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4346 @053e86> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4350 @053e8a> : 83                         mul.f64
	<.main+4351 @053e8b> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+4360 @053e94> : 01 2b 00 00                nfc(43) ;float64.pow(x: float64, y: float64): float64
	<.main+4364 @053e98> : 2d 48 1f 05                store.m64 <@051f48> ;testPow_f64
	test/stdc/number.ci:43: (17 bytes: <@053e9c> - <@053ead>): static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64))
	<.main+4368 @053e9c> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4372 @053ea0> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4376 @053ea4> : 83                         mul.f64
	<.main+4377 @053ea5> : 01 2c 00 00                nfc(44) ;float64.sqrt(x: float64): float64
	<.main+4381 @053ea9> : 2d 50 1f 05                store.m64 <@051f50> ;testSqrt_f64
	test/stdc/number.ci:44: (21 bytes: <@053ead> - <@053ec2>): static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000))
	<.main+4385 @053ead> : 2b 78 1e 05                load.m64 <@051e78> ;pi64
	<.main+4389 @053eb1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+4398 @053eba> : 01 2d 00 00                nfc(45) ;float64.atan2(x: float64, y: float64): float64
	<.main+4402 @053ebe> : 2d 58 1f 05                store.m64 <@051f58> ;testAtan_f64
	test/stdc/number.ci:46: (18 bytes: <@053ec2> - <@053ed4>): static testSin_f32: float32 := float32.sin(float32(pi32 / (2)))
	<.main+4406 @053ec2> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4410 @053ec6> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4415 @053ecb> : 74                         div.f32
	<.main+4416 @053ecc> : 01 1e 00 00                nfc(30) ;float32.sin(x: float32): float32
	<.main+4420 @053ed0> : 2e 60 1f 05                store.m32 <@051f60> ;testSin_f32
	test/stdc/number.ci:47: (18 bytes: <@053ed4> - <@053ee6>): static testCos_f32: float32 := float32.cos(float32(pi32 / (2)))
	<.main+4424 @053ed4> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4428 @053ed8> : 7f 00 00 00 40             load.f32 2.000000
	<.main+4433 @053edd> : 74                         div.f32
	<.main+4434 @053ede> : 01 1f 00 00                nfc(31) ;float32.cos(x: float32): float32
	<.main+4438 @053ee2> : 2e 68 1f 05                store.m32 <@051f68> ;testCos_f32
	test/stdc/number.ci:48: (18 bytes: <@053ee6> - <@053ef8>): static testTan_f32: float32 := float32.tan(float32(pi32 / (4)))
	<.main+4442 @053ee6> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4446 @053eea> : 7f 00 00 80 40             load.f32 4.000000
	<.main+4451 @053eef> : 74                         div.f32
	<.main+4452 @053ef0> : 01 20 00 00                nfc(32) ;float32.tan(x: float32): float32
	<.main+4456 @053ef4> : 2e 70 1f 05                store.m32 <@051f70> ;testTan_f32
	test/stdc/number.ci:49: (22 bytes: <@053ef8> - <@053f0e>): static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32))
	<.main+4460 @053ef8> : 2a 90 1e 05                load.m32 <@051e90> ;e32
	<.main+4464 @053efc> : 2a 90 1e 05                load.m32 <@051e90> ;e32
	<.main+4468 @053f00> : 73                         mul.f32
	<.main+4469 @053f01> : 2a 90 1e 05                load.m32 <@051e90> ;e32
	<.main+4473 @053f05> : 73                         mul.f32
	<.main+4474 @053f06> : 01 21 00 00                nfc(33) ;float32.log(x: float32): float32
	<.main+4478 @053f0a> : 2e 78 1f 05                store.m32 <@051f78> ;testLog_f32
	test/stdc/number.ci:50: (13 bytes: <@053f0e> - <@053f1b>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+4482 @053f0e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4487 @053f13> : 01 22 00 00                nfc(34) ;float32.exp(x: float32): float32
	<.main+4491 @053f17> : 2e 80 1f 05                store.m32 <@051f80> ;testExp_f32
	test/stdc/number.ci:51: (22 bytes: <@053f1b> - <@053f31>): static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000))
	<.main+4495 @053f1b> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4499 @053f1f> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4503 @053f23> : 73                         mul.f32
	<.main+4504 @053f24> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+4509 @053f29> : 01 23 00 00                nfc(35) ;float32.pow(x: float32, y: float32): float32
	<.main+4513 @053f2d> : 2e 88 1f 05                store.m32 <@051f88> ;testPow_f32
	test/stdc/number.ci:52: (17 bytes: <@053f31> - <@053f42>): static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32))
	<.main+4517 @053f31> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4521 @053f35> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4525 @053f39> : 73                         mul.f32
	<.main+4526 @053f3a> : 01 24 00 00                nfc(36) ;float32.sqrt(x: float32): float32
	<.main+4530 @053f3e> : 2e 90 1f 05                store.m32 <@051f90> ;testSqrt_f32
	test/stdc/number.ci:53: (17 bytes: <@053f42> - <@053f53>): static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000))
	<.main+4534 @053f42> : 2a 88 1e 05                load.m32 <@051e88> ;pi32
	<.main+4538 @053f46> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+4543 @053f4b> : 01 25 00 00                nfc(37) ;float32.atan2(x: float32, y: float32): float32
	<.main+4547 @053f4f> : 2e 98 1f 05                store.m32 <@051f98> ;testAtan_f32
	test/stdc/number.ci:55: (12 bytes: <@053f53> - <@053f5f>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+4551 @053f53> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4555 @053f57> : 01 16 00 00                nfc(22) ;uint32.pop(value: int32): int32
	<.main+4559 @053f5b> : 2e a0 1f 05                store.m32 <@051fa0> ;testPopulation_u32
	test/stdc/number.ci:56: (12 bytes: <@053f5f> - <@053f6b>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+4563 @053f5f> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4567 @053f63> : 01 17 00 00                nfc(23) ;uint32.swap(value: int32): int32
	<.main+4571 @053f67> : 2e a8 1f 05                store.m32 <@051fa8> ;testSwapBits_u32
	test/stdc/number.ci:57: (12 bytes: <@053f6b> - <@053f77>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+4575 @053f6b> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4579 @053f6f> : 01 18 00 00                nfc(24) ;uint32.bsr(value: int32): int32
	<.main+4583 @053f73> : 2e b0 1f 05                store.m32 <@051fb0> ;testBitScanReverse_u32
	test/stdc/number.ci:58: (12 bytes: <@053f77> - <@053f83>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+4587 @053f77> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4591 @053f7b> : 01 19 00 00                nfc(25) ;uint32.bsf(value: int32): int32
	<.main+4595 @053f7f> : 2e b8 1f 05                store.m32 <@051fb8> ;testBitScanForward_u32
	test/stdc/number.ci:59: (12 bytes: <@053f83> - <@053f8f>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+4599 @053f83> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4603 @053f87> : 01 1a 00 00                nfc(26) ;uint32.hib(value: int32): int32
	<.main+4607 @053f8b> : 2e c0 1f 05                store.m32 <@051fc0> ;testHighBit_u32
	test/stdc/number.ci:60: (12 bytes: <@053f8f> - <@053f9b>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+4611 @053f8f> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4615 @053f93> : 01 1b 00 00                nfc(27) ;uint32.lob(value: int32): int32
	<.main+4619 @053f97> : 2e c8 1f 05                store.m32 <@051fc8> ;testLowBit_u32
	test/stdc/number.ci:62: (18 bytes: <@053f9b> - <@053fad>): static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5))
	<.main+4623 @053f9b> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4627 @053f9f> : 19                         load.z32
	<.main+4628 @053fa0> : 1c 05 00 00 00             load.c32 5
	<.main+4633 @053fa5> : 01 14 00 00                nfc(20) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+4637 @053fa9> : 2e d0 1f 05                store.m32 <@051fd0> ;testZeroExtend_u32
	test/stdc/number.ci:63: (18 bytes: <@053fad> - <@053fbf>): static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5))
	<.main+4641 @053fad> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4645 @053fb1> : 19                         load.z32
	<.main+4646 @053fb2> : 1c 05 00 00 00             load.c32 5
	<.main+4651 @053fb7> : 01 15 00 00                nfc(21) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+4655 @053fbb> : 2e d8 1f 05                store.m32 <@051fd8> ;testSignExtend_u32
	test/stdc/number.ci:65: (20 bytes: <@053fbf> - <@053fd3>): static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5))
	<.main+4659 @053fbf> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4663 @053fc3> : 5b                         i32.2i64
	<.main+4664 @053fc4> : 19                         load.z32
	<.main+4665 @053fc5> : 1c 05 00 00 00             load.c32 5
	<.main+4670 @053fca> : 01 1c 00 00                nfc(28) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+4674 @053fce> : 6a                         i64.2i32
	<.main+4675 @053fcf> : 2e e0 1f 05                store.m32 <@051fe0> ;testZeroExtend_u64
	test/stdc/number.ci:66: (20 bytes: <@053fd3> - <@053fe7>): static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5))
	<.main+4679 @053fd3> : 2a b0 1e 05                load.m32 <@051eb0> ;r5g6b5
	<.main+4683 @053fd7> : 5b                         i32.2i64
	<.main+4684 @053fd8> : 19                         load.z32
	<.main+4685 @053fd9> : 1c 05 00 00 00             load.c32 5
	<.main+4690 @053fde> : 01 1d 00 00                nfc(29) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+4694 @053fe2> : 6a                         i64.2i32
	<.main+4695 @053fe3> : 2e e8 1f 05                store.m32 <@051fe8> ;testSignExtend_u64
	test/stdc/memory.ci:7: (18 bytes: <@053fe7> - <@053ff9>): static p1: pointer := malloc(1024)
	<.main+4699 @053fe7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4704 @053fec> : 1c 00 04 00 00             load.c32 1024
	<.main+4709 @053ff1> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4713 @053ff5> : 2e f0 1f 05                store.m32 <@051ff0> ;p1
	test/stdc/memory.ci:8: (18 bytes: <@053ff9> - <@05400b>): static p2: pointer := malloc(80)
	<.main+4717 @053ff9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4722 @053ffe> : 1c 50 00 00 00             load.c32 80
	<.main+4727 @054003> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4731 @054007> : 2e f8 1f 05                store.m32 <@051ff8> ;p2
	test/stdc/memory.ci:9: (18 bytes: <@05400b> - <@05401d>): static p3: pointer := malloc(160)
	<.main+4735 @05400b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4740 @054010> : 1c a0 00 00 00             load.c32 160
	<.main+4745 @054015> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4749 @054019> : 2e 00 20 05                store.m32 <@052000> ;p3
	test/stdc/memory.ci:10: (18 bytes: <@05401d> - <@05402f>): static p4: pointer := malloc(820)
	<.main+4753 @05401d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4758 @054022> : 1c 34 03 00 00             load.c32 820
	<.main+4763 @054027> : 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+4767 @05402b> : 2e 08 20 05                store.m32 <@052008> ;p4
	test/stdc/memory.ci:23: (13 bytes: <@05402f> - <@05403c>): static val1: int64 := 42
	<.main+4771 @05402f> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+4780 @054038> : 2d 10 20 05                store.m64 <@052010> ;val1
	test/stdc/memory.ci:24: (13 bytes: <@05403c> - <@054049>): static val2: int64 := 96
	<.main+4784 @05403c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+4793 @054045> : 2d 18 20 05                store.m64 <@052018> ;val2
	test/stdc/tryExec.ci:46: (18 bytes: <@054049> - <@05405b>): static tryExecErr0: int32 := tryExec(void(null, noError))
	<.main+4797 @054049> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4802 @05404e> : 1f 20 20 05 00             load.ref <@052020> ;noError(ptr: pointer): void
	<.main+4807 @054053> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4811 @054057> : 2e b0 20 05                store.m32 <@0520b0> ;tryExecErr0
	test/stdc/tryExec.ci:47: (18 bytes: <@05405b> - <@05406d>): static tryExecErr1: int32 := tryExec(void(null, null))
	<.main+4815 @05405b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4820 @054060> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4825 @054065> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4829 @054069> : 2e b8 20 05                store.m32 <@0520b8> ;tryExecErr1
	test/stdc/tryExec.ci:48: (18 bytes: <@05406d> - <@05407f>): static tryExecErr2: int32 := tryExec(void(null, stackOverflow))
	<.main+4833 @05406d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4838 @054072> : 1f 28 20 05 00             load.ref <@052028> ;stackOverflow(ptr: pointer): void
	<.main+4843 @054077> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4847 @05407b> : 2e c0 20 05                store.m32 <@0520c0> ;tryExecErr2
	test/stdc/tryExec.ci:49: (18 bytes: <@05407f> - <@054091>): static tryExecErr3: int32 := tryExec(void(null, divisionByZero))
	<.main+4851 @05407f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4856 @054084> : 1f 40 20 05 00             load.ref <@052040> ;divisionByZero(args: pointer): void
	<.main+4861 @054089> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4865 @05408d> : 2e c8 20 05                store.m32 <@0520c8> ;tryExecErr3
	test/stdc/tryExec.ci:50: (18 bytes: <@054091> - <@0540a3>): static tryExecErr4: int32 := tryExec(void(null, invalidInstruction))
	<.main+4869 @054091> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4874 @054096> : 1f a8 20 05 00             load.ref <@0520a8> ;invalidInstruction(args: pointer): void
	<.main+4879 @05409b> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4883 @05409f> : 2e d0 20 05                store.m32 <@0520d0> ;tryExecErr4
	test/stdc/tryExec.ci:51: (18 bytes: <@0540a3> - <@0540b5>): static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess))
	<.main+4887 @0540a3> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4892 @0540a8> : 1f 98 20 05 00             load.ref <@052098> ;invalidMemoryAccess(args: pointer): void
	<.main+4897 @0540ad> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4901 @0540b1> : 2e d8 20 05                store.m32 <@0520d8> ;tryExecErr5
	test/stdc/tryExec.ci:52: (18 bytes: <@0540b5> - <@0540c7>): static tryExecErr6: int32 := tryExec(void(null, abortExecution))
	<.main+4905 @0540b5> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4910 @0540ba> : 1f 50 20 05 00             load.ref <@052050> ;abortExecution(args: pointer): void
	<.main+4915 @0540bf> : 01 08 00 00                nfc(8) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+4919 @0540c3> : 2e e0 20 05                store.m32 <@0520e0> ;tryExecErr6
	test/lang/array.ci:59: (9 bytes: <@0540c7> - <@0540d0>): static arrArrayInitNull: int64[*] := null
	<.main+4923 @0540c7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4928 @0540cc> : 2e 30 21 05                store.m32 <@052130> ;arrArrayInitNull
	test/lang/array.ci:60: (10 bytes: <@0540d0> - <@0540da>): static arrSliceInitNull: int64[] := null
	<.main+4932 @0540d0> : 19                         load.z32
	<.main+4933 @0540d1> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+4938 @0540d6> : 2d 38 21 05                store.m64 <@052138> ;arrSliceInitNull
	test/lang/array.ci:63: (9 bytes: <@0540da> - <@0540e3>): static arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+4942 @0540da> : 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+4947 @0540df> : 2e 40 21 05                store.m32 <@052140> ;arrArrayInitFixed
	test/lang/array.ci:64: (14 bytes: <@0540e3> - <@0540f1>): static arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+4951 @0540e3> : 1c 07 00 00 00             load.c32 7
	<.main+4956 @0540e8> : 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+4961 @0540ed> : 2d 48 21 05                store.m64 <@052148> ;arrSliceInitFixed
	test/lang/array.ci:67: (8 bytes: <@0540f1> - <@0540f9>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+4965 @0540f1> : 2a 48 21 05                load.m32 <@052148> ;arrSliceInitFixed
	<.main+4969 @0540f5> : 2e 50 21 05                store.m32 <@052150> ;arrArrayInitSlice
	test/lang/array.ci:68: (8 bytes: <@0540f9> - <@054101>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+4973 @0540f9> : 2b 48 21 05                load.m64 <@052148> ;arrSliceInitFixed
	<.main+4977 @0540fd> : 2d 58 21 05                store.m64 <@052158> ;arrSliceInitSlice
	test/lang/array.ci:71: (8 bytes: <@054101> - <@054109>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+4981 @054101> : 2a 40 21 05                load.m32 <@052140> ;arrArrayInitFixed
	<.main+4985 @054105> : 2e 60 21 05                store.m32 <@052160> ;arrArrayInitPtr
	test/lang/array.ci:86: (9 bytes: <@054109> - <@054112>): static strArray: char[*] := "string"
	<.main+4989 @054109> : 1f 54 b7 02 00             load.ref <@02b754> ;"string"
	<.main+4994 @05410e> : 2e 70 21 05                store.m32 <@052170> ;strArray
	test/lang/array.ci:90: (14 bytes: <@054112> - <@054120>): static strSlice: char[] := "string"
	<.main+4998 @054112> : 1c 06 00 00 00             load.c32 6
	<.main+5003 @054117> : 1f 54 b7 02 00             load.ref <@02b754> ;"string"
	<.main+5008 @05411c> : 2d 78 21 05                store.m64 <@052178> ;strSlice
	test/lang/member.ci:35: (5 bytes: <@054120> - <@054125>): static global: int32
	<.main+5012 @054120> : 19                         load.z32
	<.main+5013 @054121> : 2e b8 21 05                store.m32 <@0521b8> ;RecordMemberTest.global
	test/lang/member.ci:38: (9 bytes: <@054125> - <@05412e>): static globalInit: int32 := 1
	<.main+5017 @054125> : 1c 01 00 00 00             load.c32 1
	<.main+5022 @05412a> : 2e c0 21 05                store.m32 <@0521c0> ;RecordMemberTest.globalInit
	test/lang/member.ci:41: (9 bytes: <@05412e> - <@054137>): static const globalConstant: int32 := 2
	<.main+5026 @05412e> : 1c 02 00 00 00             load.c32 2
	<.main+5031 @054133> : 2e c8 21 05                store.m32 <@0521c8> ;RecordMemberTest.globalConstant
	test/lang/member.ci:47: (18 bytes: <@054137> - <@054149>): static globalRecInit: Inner := {...}
	<.main+5035 @054137> : 1c 04 00 00 00             load.c32 4
	<.main+5040 @05413c> : 2e d8 21 05                store.m32 <@0521d8> ;RecordMemberTest.globalRecInit
	test/lang/member.ci:47: (9 bytes: <@054140> - <@054149>): void(globalRecInit.constant := 5);
	<.main+5044 @054140> : 1c 05 00 00 00             load.c32 5
	<.main+5049 @054145> : 2e dc 21 05                store.m32 <@0521dc> ;RecordMemberTest.globalRecInit+4
	test/lang/member.ci:50: (18 bytes: <@054149> - <@05415b>): static const globalConstantRec: Inner := {...}
	<.main+5053 @054149> : 1c 06 00 00 00             load.c32 6
	<.main+5058 @05414e> : 2e e0 21 05                store.m32 <@0521e0> ;RecordMemberTest.globalConstantRec
	test/lang/member.ci:50: (9 bytes: <@054152> - <@05415b>): void(globalConstantRec.constant := 7);
	<.main+5062 @054152> : 1c 07 00 00 00             load.c32 7
	<.main+5067 @054157> : 2e e4 21 05                store.m32 <@0521e4> ;RecordMemberTest.globalConstantRec+4
	test/lang/member.ci:53: (72 bytes: <@05415b> - <@0541a3>): static recordMemberTest: RecordMemberTest := {...}
	<.main+5071 @05415b> : 1c 0a 00 00 00             load.c32 10
	<.main+5076 @054160> : 2e e8 21 05                store.m32 <@0521e8> ;recordMemberTest
	test/lang/member.ci:55: (9 bytes: <@054164> - <@05416d>): void(recordMemberTest.constant := 11);
	<.main+5080 @054164> : 1c 0b 00 00 00             load.c32 11
	<.main+5085 @054169> : 2e ec 21 05                store.m32 <@0521ec> ;recordMemberTest+4
	test/lang/member.ci:56: (9 bytes: <@05416d> - <@054176>): void(recordMemberTest.memberInit := 12);
	<.main+5089 @05416d> : 1c 0c 00 00 00             load.c32 12
	<.main+5094 @054172> : 2e f0 21 05                store.m32 <@0521f0> ;recordMemberTest+8
	test/lang/member.ci:57: (9 bytes: <@054176> - <@05417f>): void(recordMemberTest.constantInit := 13);
	<.main+5098 @054176> : 1c 0d 00 00 00             load.c32 13
	<.main+5103 @05417b> : 2e f4 21 05                store.m32 <@0521f4> ;recordMemberTest+12
	test/lang/member.ci:60: (9 bytes: <@05417f> - <@054188>): void(recordMemberTest.memberRec.member := 14);
	<.main+5107 @05417f> : 1c 0e 00 00 00             load.c32 14
	<.main+5112 @054184> : 2e f8 21 05                store.m32 <@0521f8> ;recordMemberTest+16
	test/lang/member.ci:61: (9 bytes: <@054188> - <@054191>): void(recordMemberTest.memberRec.constant := 15);
	<.main+5116 @054188> : 1c 0f 00 00 00             load.c32 15
	<.main+5121 @05418d> : 2e fc 21 05                store.m32 <@0521fc> ;recordMemberTest+20
	test/lang/member.ci:65: (9 bytes: <@054191> - <@05419a>): void(recordMemberTest.constantRec.member := 16);
	<.main+5125 @054191> : 1c 10 00 00 00             load.c32 16
	<.main+5130 @054196> : 2e 00 22 05                store.m32 <@052200> ;recordMemberTest+24
	test/lang/member.ci:66: (9 bytes: <@05419a> - <@0541a3>): void(recordMemberTest.constantRec.constant := 17);
	<.main+5134 @05419a> : 1c 11 00 00 00             load.c32 17
	<.main+5139 @05419f> : 2e 04 22 05                store.m32 <@052204> ;recordMemberTest+28
	test/lang/method.ci:18: (9 bytes: <@0541a3> - <@0541ac>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5143 @0541a3> : 1f 60 22 05 00             load.ref <@052260> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5148 @0541a8> : 2e 30 22 05                store.m32 <@052230> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	test/lang/method.ci:62: (26 bytes: <@0541ac> - <@0541c6>): static recordMethodTest: RecordMethodTest := {...}
	<.main+5152 @0541ac> : 1f 88 22 05 00             load.ref <@052288> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5157 @0541b1> : 2e b0 22 05                store.m32 <@0522b0> ;recordMethodTest
	:: (8 bytes: <@0541b5> - <@0541bd>): void(recordMethodTest.delegateMethod := forwardMethod)
	<.main+5161 @0541b5> : 2a 30 22 05                load.m32 <@052230> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5165 @0541b9> : 2e b4 22 05                store.m32 <@0522b4> ;recordMethodTest+4
	:: (9 bytes: <@0541bd> - <@0541c6>): void(recordMethodTest.virtualMethod := virtualMethod)
	<.main+5169 @0541bd> : 1f 38 22 05 00             load.ref <@052238> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5174 @0541c2> : 2e b8 22 05                store.m32 <@0522b8> ;recordMethodTest+8
	test/lang/recUnion.ci:26: (21 bytes: <@0541c6> - <@0541db>): static black: rgbU8 := {...}
	<.main+5178 @0541c6> : 19                         load.z32
	<.main+5179 @0541c7> : 1f 4a 23 05 00             load.ref <@05234a> ;black+2
	<.main+5184 @0541cc> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@0541cd> - <@0541d4>): void(black.g := (0));
	<.main+5185 @0541cd> : 19                         load.z32
	<.main+5186 @0541ce> : 1f 49 23 05 00             load.ref <@052349> ;black+1
	<.main+5191 @0541d3> : 25                         store.i8
	test/lang/recUnion.ci:26: (7 bytes: <@0541d4> - <@0541db>): void(black.b := (0));
	<.main+5192 @0541d4> : 19                         load.z32
	<.main+5193 @0541d5> : 1f 48 23 05 00             load.ref <@052348> ;black
	<.main+5198 @0541da> : 25                         store.i8
	test/lang/recUnion.ci:27: (25 bytes: <@0541db> - <@0541f4>): static green: rgbU8 := {...}
	<.main+5199 @0541db> : 19                         load.z32
	<.main+5200 @0541dc> : 1f 52 23 05 00             load.ref <@052352> ;green+2
	<.main+5205 @0541e1> : 25                         store.i8
	test/lang/recUnion.ci:27: (11 bytes: <@0541e2> - <@0541ed>): void(green.g := (255));
	<.main+5206 @0541e2> : 1c ff 00 00 00             load.c32 255
	<.main+5211 @0541e7> : 1f 51 23 05 00             load.ref <@052351> ;green+1
	<.main+5216 @0541ec> : 25                         store.i8
	test/lang/recUnion.ci:27: (7 bytes: <@0541ed> - <@0541f4>): void(green.b := (0));
	<.main+5217 @0541ed> : 19                         load.z32
	<.main+5218 @0541ee> : 1f 50 23 05 00             load.ref <@052350> ;green
	<.main+5223 @0541f3> : 25                         store.i8
	test/lang/recUnion.ci:28: (33 bytes: <@0541f4> - <@054215>): static white: rgbU8 := {...}
	<.main+5224 @0541f4> : 1c ff 00 00 00             load.c32 255
	<.main+5229 @0541f9> : 1f 5a 23 05 00             load.ref <@05235a> ;white+2
	<.main+5234 @0541fe> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@0541ff> - <@05420a>): void(white.g := (255));
	<.main+5235 @0541ff> : 1c ff 00 00 00             load.c32 255
	<.main+5240 @054204> : 1f 59 23 05 00             load.ref <@052359> ;white+1
	<.main+5245 @054209> : 25                         store.i8
	test/lang/recUnion.ci:28: (11 bytes: <@05420a> - <@054215>): void(white.b := (255));
	<.main+5246 @05420a> : 1c ff 00 00 00             load.c32 255
	<.main+5251 @05420f> : 1f 58 23 05 00             load.ref <@052358> ;white
	<.main+5256 @054214> : 25                         store.i8
	test/lang/recUnion.ci:30: (9 bytes: <@054215> - <@05421e>): static cyan: color := {...}
	<.main+5257 @054215> : 1c ff ff 00 00             load.c32 65535
	<.main+5262 @05421a> : 2e 60 23 05                store.m32 <@052360> ;cyan
	test/lang/recUnion.ci:31: (25 bytes: <@05421e> - <@054237>): static blue: color := {...}
	<.main+5266 @05421e> : 19                         load.z32
	<.main+5267 @05421f> : 1f 6a 23 05 00             load.ref <@05236a> ;blue+2
	<.main+5272 @054224> : 25                         store.i8
	test/lang/recUnion.ci:31: (7 bytes: <@054225> - <@05422c>): void(blue.rgb.g := (0));
	<.main+5273 @054225> : 19                         load.z32
	<.main+5274 @054226> : 1f 69 23 05 00             load.ref <@052369> ;blue+1
	<.main+5279 @05422b> : 25                         store.i8
	test/lang/recUnion.ci:31: (11 bytes: <@05422c> - <@054237>): void(blue.rgb.b := (255));
	<.main+5280 @05422c> : 1c ff 00 00 00             load.c32 255
	<.main+5285 @054231> : 1f 68 23 05 00             load.ref <@052368> ;blue
	<.main+5290 @054236> : 25                         store.i8
	test/lang/useOperator.ci:5: (9 bytes: <@054237> - <@054240>): static shift: int32 := 2
	<.main+5291 @054237> : 1c 02 00 00 00             load.c32 2
	<.main+5296 @05423c> : 2e 70 23 05                store.m32 <@052370> ;shift
	test/lang/useOperator.ci:7: (11 bytes: <@054240> - <@05424b>): static boolA: bool := true
	<.main+5300 @054240> : 1c 01 00 00 00             load.c32 1
	<.main+5305 @054245> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5310 @05424a> : 25                         store.i8
	test/lang/useOperator.ci:8: (11 bytes: <@05424b> - <@054256>): static boolB: bool := bool(!false)
	<.main+5311 @05424b> : 1c 01 00 00 00             load.c32 1
	<.main+5316 @054250> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5321 @054255> : 25                         store.i8
	test/lang/useOperator.ci:17: (19 bytes: <@054256> - <@054269>): static boolAnd: bool := bool(boolA & boolB)
	<.main+5322 @054256> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5327 @05425b> : 20                         load.i8
	<.main+5328 @05425c> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5333 @054261> : 20                         load.i8
	<.main+5334 @054262> : 31                         and.b32
	<.main+5335 @054263> : 1f 88 23 05 00             load.ref <@052388> ;boolAnd
	<.main+5340 @054268> : 25                         store.i8
	test/lang/useOperator.ci:18: (19 bytes: <@054269> - <@05427c>): static boolIor: bool := bool(boolA | boolB)
	<.main+5341 @054269> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5346 @05426e> : 20                         load.i8
	<.main+5347 @05426f> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5352 @054274> : 20                         load.i8
	<.main+5353 @054275> : 32                         or.b32
	<.main+5354 @054276> : 1f 90 23 05 00             load.ref <@052390> ;boolIor
	<.main+5359 @05427b> : 25                         store.i8
	test/lang/useOperator.ci:19: (19 bytes: <@05427c> - <@05428f>): static boolXor: bool := bool(boolA ^ boolB)
	<.main+5360 @05427c> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5365 @054281> : 20                         load.i8
	<.main+5366 @054282> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5371 @054287> : 20                         load.i8
	<.main+5372 @054288> : 36                         xor.b32
	<.main+5373 @054289> : 1f 98 23 05 00             load.ref <@052398> ;boolXor
	<.main+5378 @05428e> : 25                         store.i8
	test/lang/useOperator.ci:22: (13 bytes: <@05428f> - <@05429c>): static boolNot: bool := bool(!boolB)
	<.main+5379 @05428f> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5384 @054294> : 20                         load.i8
	<.main+5385 @054295> : 0b                         not.b32
	<.main+5386 @054296> : 1f a0 23 05 00             load.ref <@0523a0> ;boolNot
	<.main+5391 @05429b> : 25                         store.i8
	test/lang/useOperator.ci:23: (19 bytes: <@05429c> - <@0542af>): static boolCeq: bool := bool(boolA == boolB)
	<.main+5392 @05429c> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5397 @0542a1> : 20                         load.i8
	<.main+5398 @0542a2> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5403 @0542a7> : 20                         load.i8
	<.main+5404 @0542a8> : 57                         ceq.i32
	<.main+5405 @0542a9> : 1f a8 23 05 00             load.ref <@0523a8> ;boolCeq
	<.main+5410 @0542ae> : 25                         store.i8
	test/lang/useOperator.ci:24: (20 bytes: <@0542af> - <@0542c3>): static boolCne: bool := bool(boolA != boolB)
	<.main+5411 @0542af> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5416 @0542b4> : 20                         load.i8
	<.main+5417 @0542b5> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5422 @0542ba> : 20                         load.i8
	<.main+5423 @0542bb> : 57                         ceq.i32
	<.main+5424 @0542bc> : 0b                         not.b32
	<.main+5425 @0542bd> : 1f b0 23 05 00             load.ref <@0523b0> ;boolCne
	<.main+5430 @0542c2> : 25                         store.i8
	test/lang/useOperator.ci:25: (19 bytes: <@0542c3> - <@0542d6>): static boolClt: bool := bool(boolA < boolB)
	<.main+5431 @0542c3> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5436 @0542c8> : 20                         load.i8
	<.main+5437 @0542c9> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5442 @0542ce> : 20                         load.i8
	<.main+5443 @0542cf> : 58                         clt.i32
	<.main+5444 @0542d0> : 1f b8 23 05 00             load.ref <@0523b8> ;boolClt
	<.main+5449 @0542d5> : 25                         store.i8
	test/lang/useOperator.ci:26: (20 bytes: <@0542d6> - <@0542ea>): static boolCle: bool := bool(boolA <= boolB)
	<.main+5450 @0542d6> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5455 @0542db> : 20                         load.i8
	<.main+5456 @0542dc> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5461 @0542e1> : 20                         load.i8
	<.main+5462 @0542e2> : 59                         cgt.i32
	<.main+5463 @0542e3> : 0b                         not.b32
	<.main+5464 @0542e4> : 1f c0 23 05 00             load.ref <@0523c0> ;boolCle
	<.main+5469 @0542e9> : 25                         store.i8
	test/lang/useOperator.ci:27: (19 bytes: <@0542ea> - <@0542fd>): static boolCgt: bool := bool(boolA > boolB)
	<.main+5470 @0542ea> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5475 @0542ef> : 20                         load.i8
	<.main+5476 @0542f0> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5481 @0542f5> : 20                         load.i8
	<.main+5482 @0542f6> : 59                         cgt.i32
	<.main+5483 @0542f7> : 1f c8 23 05 00             load.ref <@0523c8> ;boolCgt
	<.main+5488 @0542fc> : 25                         store.i8
	test/lang/useOperator.ci:28: (20 bytes: <@0542fd> - <@054311>): static boolCge: bool := bool(boolA >= boolB)
	<.main+5489 @0542fd> : 1f 78 23 05 00             load.ref <@052378> ;boolA
	<.main+5494 @054302> : 20                         load.i8
	<.main+5495 @054303> : 1f 80 23 05 00             load.ref <@052380> ;boolB
	<.main+5500 @054308> : 20                         load.i8
	<.main+5501 @054309> : 58                         clt.i32
	<.main+5502 @05430a> : 0b                         not.b32
	<.main+5503 @05430b> : 1f d0 23 05 00             load.ref <@0523d0> ;boolCge
	<.main+5508 @054310> : 25                         store.i8
	test/lang/useOperator.ci:30: (11 bytes: <@054311> - <@05431c>): static chrA: char := 'a'
	<.main+5509 @054311> : 1c 61 00 00 00             load.c32 97
	<.main+5514 @054316> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5519 @05431b> : 25                         store.i8
	test/lang/useOperator.ci:31: (11 bytes: <@05431c> - <@054327>): static chrB: char := 'b'
	<.main+5520 @05431c> : 1c 62 00 00 00             load.c32 98
	<.main+5525 @054321> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5530 @054326> : 25                         store.i8
	test/lang/useOperator.ci:32: (12 bytes: <@054327> - <@054333>): static chrPls: char := char(+chrB)
	<.main+5531 @054327> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5536 @05432c> : 20                         load.i8
	<.main+5537 @05432d> : 1f e8 23 05 00             load.ref <@0523e8> ;chrPls
	<.main+5542 @054332> : 25                         store.i8
	test/lang/useOperator.ci:33: (13 bytes: <@054333> - <@054340>): static chrNeg: char := char(-chrB)
	<.main+5543 @054333> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5548 @054338> : 20                         load.i8
	<.main+5549 @054339> : 50                         neg.i32
	<.main+5550 @05433a> : 1f f0 23 05 00             load.ref <@0523f0> ;chrNeg
	<.main+5555 @05433f> : 25                         store.i8
	test/lang/useOperator.ci:34: (13 bytes: <@054340> - <@05434d>): static chrCmt: char := char(~chrB)
	<.main+5556 @054340> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5561 @054345> : 20                         load.i8
	<.main+5562 @054346> : 30                         cmt.b32
	<.main+5563 @054347> : 1f f8 23 05 00             load.ref <@0523f8> ;chrCmt
	<.main+5568 @05434c> : 25                         store.i8
	test/lang/useOperator.ci:35: (19 bytes: <@05434d> - <@054360>): static chrAdd: char := char(chrA + chrB)
	<.main+5569 @05434d> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5574 @054352> : 20                         load.i8
	<.main+5575 @054353> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5580 @054358> : 20                         load.i8
	<.main+5581 @054359> : 51                         add.i32
	<.main+5582 @05435a> : 1f 00 24 05 00             load.ref <@052400> ;chrAdd
	<.main+5587 @05435f> : 25                         store.i8
	test/lang/useOperator.ci:36: (19 bytes: <@054360> - <@054373>): static chrSub: char := char(chrA - chrB)
	<.main+5588 @054360> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5593 @054365> : 20                         load.i8
	<.main+5594 @054366> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5599 @05436b> : 20                         load.i8
	<.main+5600 @05436c> : 52                         sub.i32
	<.main+5601 @05436d> : 1f 08 24 05 00             load.ref <@052408> ;chrSub
	<.main+5606 @054372> : 25                         store.i8
	test/lang/useOperator.ci:37: (19 bytes: <@054373> - <@054386>): static chrMul: char := char(chrA * chrB)
	<.main+5607 @054373> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5612 @054378> : 20                         load.i8
	<.main+5613 @054379> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5618 @05437e> : 20                         load.i8
	<.main+5619 @05437f> : 53                         mul.i32
	<.main+5620 @054380> : 1f 10 24 05 00             load.ref <@052410> ;chrMul
	<.main+5625 @054385> : 25                         store.i8
	test/lang/useOperator.ci:38: (19 bytes: <@054386> - <@054399>): static chrDiv: char := char(chrA / chrB)
	<.main+5626 @054386> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5631 @05438b> : 20                         load.i8
	<.main+5632 @05438c> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5637 @054391> : 20                         load.i8
	<.main+5638 @054392> : 54                         div.i32
	<.main+5639 @054393> : 1f 18 24 05 00             load.ref <@052418> ;chrDiv
	<.main+5644 @054398> : 25                         store.i8
	test/lang/useOperator.ci:39: (19 bytes: <@054399> - <@0543ac>): static chrMod: char := char(chrA % chrB)
	<.main+5645 @054399> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5650 @05439e> : 20                         load.i8
	<.main+5651 @05439f> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5656 @0543a4> : 20                         load.i8
	<.main+5657 @0543a5> : 55                         mod.i32
	<.main+5658 @0543a6> : 1f 20 24 05 00             load.ref <@052420> ;chrMod
	<.main+5663 @0543ab> : 25                         store.i8
	test/lang/useOperator.ci:40: (19 bytes: <@0543ac> - <@0543bf>): static chrAnd: char := char(chrA & chrB)
	<.main+5664 @0543ac> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5669 @0543b1> : 20                         load.i8
	<.main+5670 @0543b2> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5675 @0543b7> : 20                         load.i8
	<.main+5676 @0543b8> : 31                         and.b32
	<.main+5677 @0543b9> : 1f 28 24 05 00             load.ref <@052428> ;chrAnd
	<.main+5682 @0543be> : 25                         store.i8
	test/lang/useOperator.ci:41: (19 bytes: <@0543bf> - <@0543d2>): static chrIor: char := char(chrA | chrB)
	<.main+5683 @0543bf> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5688 @0543c4> : 20                         load.i8
	<.main+5689 @0543c5> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5694 @0543ca> : 20                         load.i8
	<.main+5695 @0543cb> : 32                         or.b32
	<.main+5696 @0543cc> : 1f 30 24 05 00             load.ref <@052430> ;chrIor
	<.main+5701 @0543d1> : 25                         store.i8
	test/lang/useOperator.ci:42: (19 bytes: <@0543d2> - <@0543e5>): static chrXor: char := char(chrA ^ chrB)
	<.main+5702 @0543d2> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5707 @0543d7> : 20                         load.i8
	<.main+5708 @0543d8> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5713 @0543dd> : 20                         load.i8
	<.main+5714 @0543de> : 36                         xor.b32
	<.main+5715 @0543df> : 1f 38 24 05 00             load.ref <@052438> ;chrXor
	<.main+5720 @0543e4> : 25                         store.i8
	test/lang/useOperator.ci:43: (17 bytes: <@0543e5> - <@0543f6>): static chrShl: char := int32((chrA) << shift)
	<.main+5721 @0543e5> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5726 @0543ea> : 20                         load.i8
	<.main+5727 @0543eb> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+5731 @0543ef> : 3a                         shl.b32
	<.main+5732 @0543f0> : 1f 40 24 05 00             load.ref <@052440> ;chrShl
	<.main+5737 @0543f5> : 25                         store.i8
	test/lang/useOperator.ci:44: (17 bytes: <@0543f6> - <@054407>): static chrShr: char := int32((chrA) >> shift)
	<.main+5738 @0543f6> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5743 @0543fb> : 20                         load.i8
	<.main+5744 @0543fc> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+5748 @054400> : 3c                         sar.b32
	<.main+5749 @054401> : 1f 48 24 05 00             load.ref <@052448> ;chrShr
	<.main+5754 @054406> : 25                         store.i8
	test/lang/useOperator.ci:45: (14 bytes: <@054407> - <@054415>): static chrNot: bool := bool(!(chrB))
	<.main+5755 @054407> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5760 @05440c> : 20                         load.i8
	<.main+5761 @05440d> : 5a                         i32.2bool
	<.main+5762 @05440e> : 0b                         not.b32
	<.main+5763 @05440f> : 1f 50 24 05 00             load.ref <@052450> ;chrNot
	<.main+5768 @054414> : 25                         store.i8
	test/lang/useOperator.ci:46: (19 bytes: <@054415> - <@054428>): static chrCeq: bool := bool(chrA == chrB)
	<.main+5769 @054415> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5774 @05441a> : 20                         load.i8
	<.main+5775 @05441b> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5780 @054420> : 20                         load.i8
	<.main+5781 @054421> : 57                         ceq.i32
	<.main+5782 @054422> : 1f 58 24 05 00             load.ref <@052458> ;chrCeq
	<.main+5787 @054427> : 25                         store.i8
	test/lang/useOperator.ci:47: (20 bytes: <@054428> - <@05443c>): static chrCne: bool := bool(chrA != chrB)
	<.main+5788 @054428> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5793 @05442d> : 20                         load.i8
	<.main+5794 @05442e> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5799 @054433> : 20                         load.i8
	<.main+5800 @054434> : 57                         ceq.i32
	<.main+5801 @054435> : 0b                         not.b32
	<.main+5802 @054436> : 1f 60 24 05 00             load.ref <@052460> ;chrCne
	<.main+5807 @05443b> : 25                         store.i8
	test/lang/useOperator.ci:48: (19 bytes: <@05443c> - <@05444f>): static chrClt: bool := bool(chrA < chrB)
	<.main+5808 @05443c> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5813 @054441> : 20                         load.i8
	<.main+5814 @054442> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5819 @054447> : 20                         load.i8
	<.main+5820 @054448> : 58                         clt.i32
	<.main+5821 @054449> : 1f 68 24 05 00             load.ref <@052468> ;chrClt
	<.main+5826 @05444e> : 25                         store.i8
	test/lang/useOperator.ci:49: (20 bytes: <@05444f> - <@054463>): static chrCle: bool := bool(chrA <= chrB)
	<.main+5827 @05444f> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5832 @054454> : 20                         load.i8
	<.main+5833 @054455> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5838 @05445a> : 20                         load.i8
	<.main+5839 @05445b> : 59                         cgt.i32
	<.main+5840 @05445c> : 0b                         not.b32
	<.main+5841 @05445d> : 1f 70 24 05 00             load.ref <@052470> ;chrCle
	<.main+5846 @054462> : 25                         store.i8
	test/lang/useOperator.ci:50: (19 bytes: <@054463> - <@054476>): static chrCgt: bool := bool(chrA > chrB)
	<.main+5847 @054463> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5852 @054468> : 20                         load.i8
	<.main+5853 @054469> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5858 @05446e> : 20                         load.i8
	<.main+5859 @05446f> : 59                         cgt.i32
	<.main+5860 @054470> : 1f 78 24 05 00             load.ref <@052478> ;chrCgt
	<.main+5865 @054475> : 25                         store.i8
	test/lang/useOperator.ci:51: (20 bytes: <@054476> - <@05448a>): static chrCge: bool := bool(chrA >= chrB)
	<.main+5866 @054476> : 1f d8 23 05 00             load.ref <@0523d8> ;chrA
	<.main+5871 @05447b> : 20                         load.i8
	<.main+5872 @05447c> : 1f e0 23 05 00             load.ref <@0523e0> ;chrB
	<.main+5877 @054481> : 20                         load.i8
	<.main+5878 @054482> : 58                         clt.i32
	<.main+5879 @054483> : 0b                         not.b32
	<.main+5880 @054484> : 1f 80 24 05 00             load.ref <@052480> ;chrCge
	<.main+5885 @054489> : 25                         store.i8
	test/lang/useOperator.ci:53: (11 bytes: <@05448a> - <@054495>): static i8A: int8 := a
	<.main+5886 @05448a> : 1c 60 00 00 00             load.c32 96
	<.main+5891 @05448f> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+5896 @054494> : 25                         store.i8
	test/lang/useOperator.ci:54: (11 bytes: <@054495> - <@0544a0>): static i8B: int8 := b
	<.main+5897 @054495> : 1c 2a 00 00 00             load.c32 42
	<.main+5902 @05449a> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5907 @05449f> : 25                         store.i8
	test/lang/useOperator.ci:55: (12 bytes: <@0544a0> - <@0544ac>): static i8Pls: int8 := int8(+i8B)
	<.main+5908 @0544a0> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5913 @0544a5> : 20                         load.i8
	<.main+5914 @0544a6> : 1f 98 24 05 00             load.ref <@052498> ;i8Pls
	<.main+5919 @0544ab> : 25                         store.i8
	test/lang/useOperator.ci:56: (13 bytes: <@0544ac> - <@0544b9>): static i8Neg: int8 := int8(-i8B)
	<.main+5920 @0544ac> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5925 @0544b1> : 20                         load.i8
	<.main+5926 @0544b2> : 50                         neg.i32
	<.main+5927 @0544b3> : 1f a0 24 05 00             load.ref <@0524a0> ;i8Neg
	<.main+5932 @0544b8> : 25                         store.i8
	test/lang/useOperator.ci:57: (13 bytes: <@0544b9> - <@0544c6>): static i8Cmt: int8 := int8(~i8B)
	<.main+5933 @0544b9> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5938 @0544be> : 20                         load.i8
	<.main+5939 @0544bf> : 30                         cmt.b32
	<.main+5940 @0544c0> : 1f a8 24 05 00             load.ref <@0524a8> ;i8Cmt
	<.main+5945 @0544c5> : 25                         store.i8
	test/lang/useOperator.ci:58: (19 bytes: <@0544c6> - <@0544d9>): static i8Add: int8 := int8(i8A + i8B)
	<.main+5946 @0544c6> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+5951 @0544cb> : 20                         load.i8
	<.main+5952 @0544cc> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5957 @0544d1> : 20                         load.i8
	<.main+5958 @0544d2> : 51                         add.i32
	<.main+5959 @0544d3> : 1f b0 24 05 00             load.ref <@0524b0> ;i8Add
	<.main+5964 @0544d8> : 25                         store.i8
	test/lang/useOperator.ci:59: (19 bytes: <@0544d9> - <@0544ec>): static i8Sub: int8 := int8(i8A - i8B)
	<.main+5965 @0544d9> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+5970 @0544de> : 20                         load.i8
	<.main+5971 @0544df> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5976 @0544e4> : 20                         load.i8
	<.main+5977 @0544e5> : 52                         sub.i32
	<.main+5978 @0544e6> : 1f b8 24 05 00             load.ref <@0524b8> ;i8Sub
	<.main+5983 @0544eb> : 25                         store.i8
	test/lang/useOperator.ci:60: (19 bytes: <@0544ec> - <@0544ff>): static i8Mul: int8 := int8(i8A * i8B)
	<.main+5984 @0544ec> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+5989 @0544f1> : 20                         load.i8
	<.main+5990 @0544f2> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+5995 @0544f7> : 20                         load.i8
	<.main+5996 @0544f8> : 53                         mul.i32
	<.main+5997 @0544f9> : 1f c0 24 05 00             load.ref <@0524c0> ;i8Mul
	<.main+6002 @0544fe> : 25                         store.i8
	test/lang/useOperator.ci:61: (19 bytes: <@0544ff> - <@054512>): static i8Div: int8 := int8(i8A / i8B)
	<.main+6003 @0544ff> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6008 @054504> : 20                         load.i8
	<.main+6009 @054505> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6014 @05450a> : 20                         load.i8
	<.main+6015 @05450b> : 54                         div.i32
	<.main+6016 @05450c> : 1f c8 24 05 00             load.ref <@0524c8> ;i8Div
	<.main+6021 @054511> : 25                         store.i8
	test/lang/useOperator.ci:62: (19 bytes: <@054512> - <@054525>): static i8Mod: int8 := int8(i8A % i8B)
	<.main+6022 @054512> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6027 @054517> : 20                         load.i8
	<.main+6028 @054518> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6033 @05451d> : 20                         load.i8
	<.main+6034 @05451e> : 55                         mod.i32
	<.main+6035 @05451f> : 1f d0 24 05 00             load.ref <@0524d0> ;i8Mod
	<.main+6040 @054524> : 25                         store.i8
	test/lang/useOperator.ci:63: (19 bytes: <@054525> - <@054538>): static i8And: int8 := int8(i8A & i8B)
	<.main+6041 @054525> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6046 @05452a> : 20                         load.i8
	<.main+6047 @05452b> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6052 @054530> : 20                         load.i8
	<.main+6053 @054531> : 31                         and.b32
	<.main+6054 @054532> : 1f d8 24 05 00             load.ref <@0524d8> ;i8And
	<.main+6059 @054537> : 25                         store.i8
	test/lang/useOperator.ci:64: (19 bytes: <@054538> - <@05454b>): static i8Ior: int8 := int8(i8A | i8B)
	<.main+6060 @054538> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6065 @05453d> : 20                         load.i8
	<.main+6066 @05453e> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6071 @054543> : 20                         load.i8
	<.main+6072 @054544> : 32                         or.b32
	<.main+6073 @054545> : 1f e0 24 05 00             load.ref <@0524e0> ;i8Ior
	<.main+6078 @05454a> : 25                         store.i8
	test/lang/useOperator.ci:65: (19 bytes: <@05454b> - <@05455e>): static i8Xor: int8 := int8(i8A ^ i8B)
	<.main+6079 @05454b> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6084 @054550> : 20                         load.i8
	<.main+6085 @054551> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6090 @054556> : 20                         load.i8
	<.main+6091 @054557> : 36                         xor.b32
	<.main+6092 @054558> : 1f e8 24 05 00             load.ref <@0524e8> ;i8Xor
	<.main+6097 @05455d> : 25                         store.i8
	test/lang/useOperator.ci:66: (17 bytes: <@05455e> - <@05456f>): static i8Shl: int8 := int32((i8A) << shift)
	<.main+6098 @05455e> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6103 @054563> : 20                         load.i8
	<.main+6104 @054564> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6108 @054568> : 3a                         shl.b32
	<.main+6109 @054569> : 1f f0 24 05 00             load.ref <@0524f0> ;i8Shl
	<.main+6114 @05456e> : 25                         store.i8
	test/lang/useOperator.ci:67: (17 bytes: <@05456f> - <@054580>): static i8Shr: int8 := int32((i8A) >> shift)
	<.main+6115 @05456f> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6120 @054574> : 20                         load.i8
	<.main+6121 @054575> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6125 @054579> : 3c                         sar.b32
	<.main+6126 @05457a> : 1f f8 24 05 00             load.ref <@0524f8> ;i8Shr
	<.main+6131 @05457f> : 25                         store.i8
	test/lang/useOperator.ci:68: (14 bytes: <@054580> - <@05458e>): static i8Not: bool := bool(!(i8B))
	<.main+6132 @054580> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6137 @054585> : 20                         load.i8
	<.main+6138 @054586> : 5a                         i32.2bool
	<.main+6139 @054587> : 0b                         not.b32
	<.main+6140 @054588> : 1f 00 25 05 00             load.ref <@052500> ;i8Not
	<.main+6145 @05458d> : 25                         store.i8
	test/lang/useOperator.ci:69: (19 bytes: <@05458e> - <@0545a1>): static i8Ceq: bool := bool(i8A == i8B)
	<.main+6146 @05458e> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6151 @054593> : 20                         load.i8
	<.main+6152 @054594> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6157 @054599> : 20                         load.i8
	<.main+6158 @05459a> : 57                         ceq.i32
	<.main+6159 @05459b> : 1f 08 25 05 00             load.ref <@052508> ;i8Ceq
	<.main+6164 @0545a0> : 25                         store.i8
	test/lang/useOperator.ci:70: (20 bytes: <@0545a1> - <@0545b5>): static i8Cne: bool := bool(i8A != i8B)
	<.main+6165 @0545a1> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6170 @0545a6> : 20                         load.i8
	<.main+6171 @0545a7> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6176 @0545ac> : 20                         load.i8
	<.main+6177 @0545ad> : 57                         ceq.i32
	<.main+6178 @0545ae> : 0b                         not.b32
	<.main+6179 @0545af> : 1f 10 25 05 00             load.ref <@052510> ;i8Cne
	<.main+6184 @0545b4> : 25                         store.i8
	test/lang/useOperator.ci:71: (19 bytes: <@0545b5> - <@0545c8>): static i8Clt: bool := bool(i8A < i8B)
	<.main+6185 @0545b5> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6190 @0545ba> : 20                         load.i8
	<.main+6191 @0545bb> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6196 @0545c0> : 20                         load.i8
	<.main+6197 @0545c1> : 58                         clt.i32
	<.main+6198 @0545c2> : 1f 18 25 05 00             load.ref <@052518> ;i8Clt
	<.main+6203 @0545c7> : 25                         store.i8
	test/lang/useOperator.ci:72: (20 bytes: <@0545c8> - <@0545dc>): static i8Cle: bool := bool(i8A <= i8B)
	<.main+6204 @0545c8> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6209 @0545cd> : 20                         load.i8
	<.main+6210 @0545ce> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6215 @0545d3> : 20                         load.i8
	<.main+6216 @0545d4> : 59                         cgt.i32
	<.main+6217 @0545d5> : 0b                         not.b32
	<.main+6218 @0545d6> : 1f 20 25 05 00             load.ref <@052520> ;i8Cle
	<.main+6223 @0545db> : 25                         store.i8
	test/lang/useOperator.ci:73: (19 bytes: <@0545dc> - <@0545ef>): static i8Cgt: bool := bool(i8A > i8B)
	<.main+6224 @0545dc> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6229 @0545e1> : 20                         load.i8
	<.main+6230 @0545e2> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6235 @0545e7> : 20                         load.i8
	<.main+6236 @0545e8> : 59                         cgt.i32
	<.main+6237 @0545e9> : 1f 28 25 05 00             load.ref <@052528> ;i8Cgt
	<.main+6242 @0545ee> : 25                         store.i8
	test/lang/useOperator.ci:74: (20 bytes: <@0545ef> - <@054603>): static i8Cge: bool := bool(i8A >= i8B)
	<.main+6243 @0545ef> : 1f 88 24 05 00             load.ref <@052488> ;i8A
	<.main+6248 @0545f4> : 20                         load.i8
	<.main+6249 @0545f5> : 1f 90 24 05 00             load.ref <@052490> ;i8B
	<.main+6254 @0545fa> : 20                         load.i8
	<.main+6255 @0545fb> : 58                         clt.i32
	<.main+6256 @0545fc> : 0b                         not.b32
	<.main+6257 @0545fd> : 1f 30 25 05 00             load.ref <@052530> ;i8Cge
	<.main+6262 @054602> : 25                         store.i8
	test/lang/useOperator.ci:76: (11 bytes: <@054603> - <@05460e>): static u8A: uint8 := a
	<.main+6263 @054603> : 1c 60 00 00 00             load.c32 96
	<.main+6268 @054608> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6273 @05460d> : 25                         store.i8
	test/lang/useOperator.ci:77: (11 bytes: <@05460e> - <@054619>): static u8B: uint8 := b
	<.main+6274 @05460e> : 1c 2a 00 00 00             load.c32 42
	<.main+6279 @054613> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6284 @054618> : 25                         store.i8
	test/lang/useOperator.ci:78: (12 bytes: <@054619> - <@054625>): static u8Pls: uint8 := uint8(+u8B)
	<.main+6285 @054619> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6290 @05461e> : 20                         load.i8
	<.main+6291 @05461f> : 1f 48 25 05 00             load.ref <@052548> ;u8Pls
	<.main+6296 @054624> : 25                         store.i8
	test/lang/useOperator.ci:79: (13 bytes: <@054625> - <@054632>): static u8Neg: uint8 := uint8(-u8B)
	<.main+6297 @054625> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6302 @05462a> : 20                         load.i8
	<.main+6303 @05462b> : 50                         neg.i32
	<.main+6304 @05462c> : 1f 50 25 05 00             load.ref <@052550> ;u8Neg
	<.main+6309 @054631> : 25                         store.i8
	test/lang/useOperator.ci:80: (13 bytes: <@054632> - <@05463f>): static u8Cmt: uint8 := uint8(~u8B)
	<.main+6310 @054632> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6315 @054637> : 20                         load.i8
	<.main+6316 @054638> : 30                         cmt.b32
	<.main+6317 @054639> : 1f 58 25 05 00             load.ref <@052558> ;u8Cmt
	<.main+6322 @05463e> : 25                         store.i8
	test/lang/useOperator.ci:81: (19 bytes: <@05463f> - <@054652>): static u8Add: uint8 := uint8(u8A + u8B)
	<.main+6323 @05463f> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6328 @054644> : 20                         load.i8
	<.main+6329 @054645> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6334 @05464a> : 20                         load.i8
	<.main+6335 @05464b> : 51                         add.i32
	<.main+6336 @05464c> : 1f 60 25 05 00             load.ref <@052560> ;u8Add
	<.main+6341 @054651> : 25                         store.i8
	test/lang/useOperator.ci:82: (19 bytes: <@054652> - <@054665>): static u8Sub: uint8 := uint8(u8A - u8B)
	<.main+6342 @054652> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6347 @054657> : 20                         load.i8
	<.main+6348 @054658> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6353 @05465d> : 20                         load.i8
	<.main+6354 @05465e> : 52                         sub.i32
	<.main+6355 @05465f> : 1f 68 25 05 00             load.ref <@052568> ;u8Sub
	<.main+6360 @054664> : 25                         store.i8
	test/lang/useOperator.ci:83: (19 bytes: <@054665> - <@054678>): static u8Mul: uint8 := uint8(u8A * u8B)
	<.main+6361 @054665> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6366 @05466a> : 20                         load.i8
	<.main+6367 @05466b> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6372 @054670> : 20                         load.i8
	<.main+6373 @054671> : 33                         mul.u32
	<.main+6374 @054672> : 1f 70 25 05 00             load.ref <@052570> ;u8Mul
	<.main+6379 @054677> : 25                         store.i8
	test/lang/useOperator.ci:84: (19 bytes: <@054678> - <@05468b>): static u8Div: uint8 := uint8(u8A / u8B)
	<.main+6380 @054678> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6385 @05467d> : 20                         load.i8
	<.main+6386 @05467e> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6391 @054683> : 20                         load.i8
	<.main+6392 @054684> : 34                         div.u32
	<.main+6393 @054685> : 1f 78 25 05 00             load.ref <@052578> ;u8Div
	<.main+6398 @05468a> : 25                         store.i8
	test/lang/useOperator.ci:85: (19 bytes: <@05468b> - <@05469e>): static u8Mod: uint8 := uint8(u8A % u8B)
	<.main+6399 @05468b> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6404 @054690> : 20                         load.i8
	<.main+6405 @054691> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6410 @054696> : 20                         load.i8
	<.main+6411 @054697> : 35                         mod.u32
	<.main+6412 @054698> : 1f 80 25 05 00             load.ref <@052580> ;u8Mod
	<.main+6417 @05469d> : 25                         store.i8
	test/lang/useOperator.ci:86: (19 bytes: <@05469e> - <@0546b1>): static u8And: uint8 := uint8(u8A & u8B)
	<.main+6418 @05469e> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6423 @0546a3> : 20                         load.i8
	<.main+6424 @0546a4> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6429 @0546a9> : 20                         load.i8
	<.main+6430 @0546aa> : 31                         and.b32
	<.main+6431 @0546ab> : 1f 88 25 05 00             load.ref <@052588> ;u8And
	<.main+6436 @0546b0> : 25                         store.i8
	test/lang/useOperator.ci:87: (19 bytes: <@0546b1> - <@0546c4>): static u8Ior: uint8 := uint8(u8A | u8B)
	<.main+6437 @0546b1> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6442 @0546b6> : 20                         load.i8
	<.main+6443 @0546b7> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6448 @0546bc> : 20                         load.i8
	<.main+6449 @0546bd> : 32                         or.b32
	<.main+6450 @0546be> : 1f 90 25 05 00             load.ref <@052590> ;u8Ior
	<.main+6455 @0546c3> : 25                         store.i8
	test/lang/useOperator.ci:88: (19 bytes: <@0546c4> - <@0546d7>): static u8Xor: uint8 := uint8(u8A ^ u8B)
	<.main+6456 @0546c4> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6461 @0546c9> : 20                         load.i8
	<.main+6462 @0546ca> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6467 @0546cf> : 20                         load.i8
	<.main+6468 @0546d0> : 36                         xor.b32
	<.main+6469 @0546d1> : 1f 98 25 05 00             load.ref <@052598> ;u8Xor
	<.main+6474 @0546d6> : 25                         store.i8
	test/lang/useOperator.ci:89: (17 bytes: <@0546d7> - <@0546e8>): static u8Shl: uint8 := int32((u8A) << shift)
	<.main+6475 @0546d7> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6480 @0546dc> : 20                         load.i8
	<.main+6481 @0546dd> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6485 @0546e1> : 3a                         shl.b32
	<.main+6486 @0546e2> : 1f a0 25 05 00             load.ref <@0525a0> ;u8Shl
	<.main+6491 @0546e7> : 25                         store.i8
	test/lang/useOperator.ci:90: (17 bytes: <@0546e8> - <@0546f9>): static u8Shr: uint8 := int32((u8A) >> shift)
	<.main+6492 @0546e8> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6497 @0546ed> : 20                         load.i8
	<.main+6498 @0546ee> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6502 @0546f2> : 3c                         sar.b32
	<.main+6503 @0546f3> : 1f a8 25 05 00             load.ref <@0525a8> ;u8Shr
	<.main+6508 @0546f8> : 25                         store.i8
	test/lang/useOperator.ci:91: (14 bytes: <@0546f9> - <@054707>): static u8Not: bool := bool(!(u8B))
	<.main+6509 @0546f9> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6514 @0546fe> : 20                         load.i8
	<.main+6515 @0546ff> : 5a                         i32.2bool
	<.main+6516 @054700> : 0b                         not.b32
	<.main+6517 @054701> : 1f b0 25 05 00             load.ref <@0525b0> ;u8Not
	<.main+6522 @054706> : 25                         store.i8
	test/lang/useOperator.ci:92: (19 bytes: <@054707> - <@05471a>): static u8Ceq: bool := bool(u8A == u8B)
	<.main+6523 @054707> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6528 @05470c> : 20                         load.i8
	<.main+6529 @05470d> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6534 @054712> : 20                         load.i8
	<.main+6535 @054713> : 57                         ceq.i32
	<.main+6536 @054714> : 1f b8 25 05 00             load.ref <@0525b8> ;u8Ceq
	<.main+6541 @054719> : 25                         store.i8
	test/lang/useOperator.ci:93: (20 bytes: <@05471a> - <@05472e>): static u8Cne: bool := bool(u8A != u8B)
	<.main+6542 @05471a> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6547 @05471f> : 20                         load.i8
	<.main+6548 @054720> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6553 @054725> : 20                         load.i8
	<.main+6554 @054726> : 57                         ceq.i32
	<.main+6555 @054727> : 0b                         not.b32
	<.main+6556 @054728> : 1f c0 25 05 00             load.ref <@0525c0> ;u8Cne
	<.main+6561 @05472d> : 25                         store.i8
	test/lang/useOperator.ci:94: (19 bytes: <@05472e> - <@054741>): static u8Clt: bool := bool(u8A < u8B)
	<.main+6562 @05472e> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6567 @054733> : 20                         load.i8
	<.main+6568 @054734> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6573 @054739> : 20                         load.i8
	<.main+6574 @05473a> : 38                         clt.u32
	<.main+6575 @05473b> : 1f c8 25 05 00             load.ref <@0525c8> ;u8Clt
	<.main+6580 @054740> : 25                         store.i8
	test/lang/useOperator.ci:95: (20 bytes: <@054741> - <@054755>): static u8Cle: bool := bool(u8A <= u8B)
	<.main+6581 @054741> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6586 @054746> : 20                         load.i8
	<.main+6587 @054747> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6592 @05474c> : 20                         load.i8
	<.main+6593 @05474d> : 39                         cgt.u32
	<.main+6594 @05474e> : 0b                         not.b32
	<.main+6595 @05474f> : 1f d0 25 05 00             load.ref <@0525d0> ;u8Cle
	<.main+6600 @054754> : 25                         store.i8
	test/lang/useOperator.ci:96: (19 bytes: <@054755> - <@054768>): static u8Cgt: bool := bool(u8A > u8B)
	<.main+6601 @054755> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6606 @05475a> : 20                         load.i8
	<.main+6607 @05475b> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6612 @054760> : 20                         load.i8
	<.main+6613 @054761> : 39                         cgt.u32
	<.main+6614 @054762> : 1f d8 25 05 00             load.ref <@0525d8> ;u8Cgt
	<.main+6619 @054767> : 25                         store.i8
	test/lang/useOperator.ci:97: (20 bytes: <@054768> - <@05477c>): static u8Cge: bool := bool(u8A >= u8B)
	<.main+6620 @054768> : 1f 38 25 05 00             load.ref <@052538> ;u8A
	<.main+6625 @05476d> : 20                         load.i8
	<.main+6626 @05476e> : 1f 40 25 05 00             load.ref <@052540> ;u8B
	<.main+6631 @054773> : 20                         load.i8
	<.main+6632 @054774> : 38                         clt.u32
	<.main+6633 @054775> : 0b                         not.b32
	<.main+6634 @054776> : 1f e0 25 05 00             load.ref <@0525e0> ;u8Cge
	<.main+6639 @05477b> : 25                         store.i8
	test/lang/useOperator.ci:99: (11 bytes: <@05477c> - <@054787>): static i16A: int16 := a
	<.main+6640 @05477c> : 1c 60 00 00 00             load.c32 96
	<.main+6645 @054781> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6650 @054786> : 26                         store.i16
	test/lang/useOperator.ci:100: (11 bytes: <@054787> - <@054792>): static i16B: int16 := b
	<.main+6651 @054787> : 1c 2a 00 00 00             load.c32 42
	<.main+6656 @05478c> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6661 @054791> : 26                         store.i16
	test/lang/useOperator.ci:101: (12 bytes: <@054792> - <@05479e>): static i16Pls: int16 := int16(+i16B)
	<.main+6662 @054792> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6667 @054797> : 21                         load.i16
	<.main+6668 @054798> : 1f f8 25 05 00             load.ref <@0525f8> ;i16Pls
	<.main+6673 @05479d> : 26                         store.i16
	test/lang/useOperator.ci:102: (13 bytes: <@05479e> - <@0547ab>): static i16Neg: int16 := int16(-i16B)
	<.main+6674 @05479e> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6679 @0547a3> : 21                         load.i16
	<.main+6680 @0547a4> : 50                         neg.i32
	<.main+6681 @0547a5> : 1f 00 26 05 00             load.ref <@052600> ;i16Neg
	<.main+6686 @0547aa> : 26                         store.i16
	test/lang/useOperator.ci:103: (13 bytes: <@0547ab> - <@0547b8>): static i16Cmt: int16 := int16(~i16B)
	<.main+6687 @0547ab> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6692 @0547b0> : 21                         load.i16
	<.main+6693 @0547b1> : 30                         cmt.b32
	<.main+6694 @0547b2> : 1f 08 26 05 00             load.ref <@052608> ;i16Cmt
	<.main+6699 @0547b7> : 26                         store.i16
	test/lang/useOperator.ci:104: (19 bytes: <@0547b8> - <@0547cb>): static i16Add: int16 := int16(i16A + i16B)
	<.main+6700 @0547b8> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6705 @0547bd> : 21                         load.i16
	<.main+6706 @0547be> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6711 @0547c3> : 21                         load.i16
	<.main+6712 @0547c4> : 51                         add.i32
	<.main+6713 @0547c5> : 1f 10 26 05 00             load.ref <@052610> ;i16Add
	<.main+6718 @0547ca> : 26                         store.i16
	test/lang/useOperator.ci:105: (19 bytes: <@0547cb> - <@0547de>): static i16Sub: int16 := int16(i16A - i16B)
	<.main+6719 @0547cb> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6724 @0547d0> : 21                         load.i16
	<.main+6725 @0547d1> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6730 @0547d6> : 21                         load.i16
	<.main+6731 @0547d7> : 52                         sub.i32
	<.main+6732 @0547d8> : 1f 18 26 05 00             load.ref <@052618> ;i16Sub
	<.main+6737 @0547dd> : 26                         store.i16
	test/lang/useOperator.ci:106: (19 bytes: <@0547de> - <@0547f1>): static i16Mul: int16 := int16(i16A * i16B)
	<.main+6738 @0547de> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6743 @0547e3> : 21                         load.i16
	<.main+6744 @0547e4> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6749 @0547e9> : 21                         load.i16
	<.main+6750 @0547ea> : 53                         mul.i32
	<.main+6751 @0547eb> : 1f 20 26 05 00             load.ref <@052620> ;i16Mul
	<.main+6756 @0547f0> : 26                         store.i16
	test/lang/useOperator.ci:107: (19 bytes: <@0547f1> - <@054804>): static i16Div: int16 := int16(i16A / i16B)
	<.main+6757 @0547f1> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6762 @0547f6> : 21                         load.i16
	<.main+6763 @0547f7> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6768 @0547fc> : 21                         load.i16
	<.main+6769 @0547fd> : 54                         div.i32
	<.main+6770 @0547fe> : 1f 28 26 05 00             load.ref <@052628> ;i16Div
	<.main+6775 @054803> : 26                         store.i16
	test/lang/useOperator.ci:108: (19 bytes: <@054804> - <@054817>): static i16Mod: int16 := int16(i16A % i16B)
	<.main+6776 @054804> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6781 @054809> : 21                         load.i16
	<.main+6782 @05480a> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6787 @05480f> : 21                         load.i16
	<.main+6788 @054810> : 55                         mod.i32
	<.main+6789 @054811> : 1f 30 26 05 00             load.ref <@052630> ;i16Mod
	<.main+6794 @054816> : 26                         store.i16
	test/lang/useOperator.ci:109: (19 bytes: <@054817> - <@05482a>): static i16And: int16 := int16(i16A & i16B)
	<.main+6795 @054817> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6800 @05481c> : 21                         load.i16
	<.main+6801 @05481d> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6806 @054822> : 21                         load.i16
	<.main+6807 @054823> : 31                         and.b32
	<.main+6808 @054824> : 1f 38 26 05 00             load.ref <@052638> ;i16And
	<.main+6813 @054829> : 26                         store.i16
	test/lang/useOperator.ci:110: (19 bytes: <@05482a> - <@05483d>): static i16Ior: int16 := int16(i16A | i16B)
	<.main+6814 @05482a> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6819 @05482f> : 21                         load.i16
	<.main+6820 @054830> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6825 @054835> : 21                         load.i16
	<.main+6826 @054836> : 32                         or.b32
	<.main+6827 @054837> : 1f 40 26 05 00             load.ref <@052640> ;i16Ior
	<.main+6832 @05483c> : 26                         store.i16
	test/lang/useOperator.ci:111: (19 bytes: <@05483d> - <@054850>): static i16Xor: int16 := int16(i16A ^ i16B)
	<.main+6833 @05483d> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6838 @054842> : 21                         load.i16
	<.main+6839 @054843> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6844 @054848> : 21                         load.i16
	<.main+6845 @054849> : 36                         xor.b32
	<.main+6846 @05484a> : 1f 48 26 05 00             load.ref <@052648> ;i16Xor
	<.main+6851 @05484f> : 26                         store.i16
	test/lang/useOperator.ci:112: (17 bytes: <@054850> - <@054861>): static i16Shl: int16 := int32((i16A) << shift)
	<.main+6852 @054850> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6857 @054855> : 21                         load.i16
	<.main+6858 @054856> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6862 @05485a> : 3a                         shl.b32
	<.main+6863 @05485b> : 1f 50 26 05 00             load.ref <@052650> ;i16Shl
	<.main+6868 @054860> : 26                         store.i16
	test/lang/useOperator.ci:113: (17 bytes: <@054861> - <@054872>): static i16Shr: int16 := int32((i16A) >> shift)
	<.main+6869 @054861> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6874 @054866> : 21                         load.i16
	<.main+6875 @054867> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+6879 @05486b> : 3c                         sar.b32
	<.main+6880 @05486c> : 1f 58 26 05 00             load.ref <@052658> ;i16Shr
	<.main+6885 @054871> : 26                         store.i16
	test/lang/useOperator.ci:114: (14 bytes: <@054872> - <@054880>): static i16Not: bool := bool(!(i16B))
	<.main+6886 @054872> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6891 @054877> : 21                         load.i16
	<.main+6892 @054878> : 5a                         i32.2bool
	<.main+6893 @054879> : 0b                         not.b32
	<.main+6894 @05487a> : 1f 60 26 05 00             load.ref <@052660> ;i16Not
	<.main+6899 @05487f> : 25                         store.i8
	test/lang/useOperator.ci:115: (19 bytes: <@054880> - <@054893>): static i16Ceq: bool := bool(i16A == i16B)
	<.main+6900 @054880> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6905 @054885> : 21                         load.i16
	<.main+6906 @054886> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6911 @05488b> : 21                         load.i16
	<.main+6912 @05488c> : 57                         ceq.i32
	<.main+6913 @05488d> : 1f 68 26 05 00             load.ref <@052668> ;i16Ceq
	<.main+6918 @054892> : 25                         store.i8
	test/lang/useOperator.ci:116: (20 bytes: <@054893> - <@0548a7>): static i16Cne: bool := bool(i16A != i16B)
	<.main+6919 @054893> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6924 @054898> : 21                         load.i16
	<.main+6925 @054899> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6930 @05489e> : 21                         load.i16
	<.main+6931 @05489f> : 57                         ceq.i32
	<.main+6932 @0548a0> : 0b                         not.b32
	<.main+6933 @0548a1> : 1f 70 26 05 00             load.ref <@052670> ;i16Cne
	<.main+6938 @0548a6> : 25                         store.i8
	test/lang/useOperator.ci:117: (19 bytes: <@0548a7> - <@0548ba>): static i16Clt: bool := bool(i16A < i16B)
	<.main+6939 @0548a7> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6944 @0548ac> : 21                         load.i16
	<.main+6945 @0548ad> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6950 @0548b2> : 21                         load.i16
	<.main+6951 @0548b3> : 58                         clt.i32
	<.main+6952 @0548b4> : 1f 78 26 05 00             load.ref <@052678> ;i16Clt
	<.main+6957 @0548b9> : 25                         store.i8
	test/lang/useOperator.ci:118: (20 bytes: <@0548ba> - <@0548ce>): static i16Cle: bool := bool(i16A <= i16B)
	<.main+6958 @0548ba> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6963 @0548bf> : 21                         load.i16
	<.main+6964 @0548c0> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6969 @0548c5> : 21                         load.i16
	<.main+6970 @0548c6> : 59                         cgt.i32
	<.main+6971 @0548c7> : 0b                         not.b32
	<.main+6972 @0548c8> : 1f 80 26 05 00             load.ref <@052680> ;i16Cle
	<.main+6977 @0548cd> : 25                         store.i8
	test/lang/useOperator.ci:119: (19 bytes: <@0548ce> - <@0548e1>): static i16Cgt: bool := bool(i16A > i16B)
	<.main+6978 @0548ce> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+6983 @0548d3> : 21                         load.i16
	<.main+6984 @0548d4> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+6989 @0548d9> : 21                         load.i16
	<.main+6990 @0548da> : 59                         cgt.i32
	<.main+6991 @0548db> : 1f 88 26 05 00             load.ref <@052688> ;i16Cgt
	<.main+6996 @0548e0> : 25                         store.i8
	test/lang/useOperator.ci:120: (20 bytes: <@0548e1> - <@0548f5>): static i16Cge: bool := bool(i16A >= i16B)
	<.main+6997 @0548e1> : 1f e8 25 05 00             load.ref <@0525e8> ;i16A
	<.main+7002 @0548e6> : 21                         load.i16
	<.main+7003 @0548e7> : 1f f0 25 05 00             load.ref <@0525f0> ;i16B
	<.main+7008 @0548ec> : 21                         load.i16
	<.main+7009 @0548ed> : 58                         clt.i32
	<.main+7010 @0548ee> : 0b                         not.b32
	<.main+7011 @0548ef> : 1f 90 26 05 00             load.ref <@052690> ;i16Cge
	<.main+7016 @0548f4> : 25                         store.i8
	test/lang/useOperator.ci:122: (11 bytes: <@0548f5> - <@054900>): static u16A: uint16 := a
	<.main+7017 @0548f5> : 1c 60 00 00 00             load.c32 96
	<.main+7022 @0548fa> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7027 @0548ff> : 26                         store.i16
	test/lang/useOperator.ci:123: (11 bytes: <@054900> - <@05490b>): static u16B: uint16 := b
	<.main+7028 @054900> : 1c 2a 00 00 00             load.c32 42
	<.main+7033 @054905> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7038 @05490a> : 26                         store.i16
	test/lang/useOperator.ci:124: (12 bytes: <@05490b> - <@054917>): static u16Pls: uint16 := uint16(+u16B)
	<.main+7039 @05490b> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7044 @054910> : 21                         load.i16
	<.main+7045 @054911> : 1f a8 26 05 00             load.ref <@0526a8> ;u16Pls
	<.main+7050 @054916> : 26                         store.i16
	test/lang/useOperator.ci:125: (13 bytes: <@054917> - <@054924>): static u16Neg: uint16 := uint16(-u16B)
	<.main+7051 @054917> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7056 @05491c> : 21                         load.i16
	<.main+7057 @05491d> : 50                         neg.i32
	<.main+7058 @05491e> : 1f b0 26 05 00             load.ref <@0526b0> ;u16Neg
	<.main+7063 @054923> : 26                         store.i16
	test/lang/useOperator.ci:126: (13 bytes: <@054924> - <@054931>): static u16Cmt: uint16 := uint16(~u16B)
	<.main+7064 @054924> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7069 @054929> : 21                         load.i16
	<.main+7070 @05492a> : 30                         cmt.b32
	<.main+7071 @05492b> : 1f b8 26 05 00             load.ref <@0526b8> ;u16Cmt
	<.main+7076 @054930> : 26                         store.i16
	test/lang/useOperator.ci:127: (19 bytes: <@054931> - <@054944>): static u16Add: uint16 := uint16(u16A + u16B)
	<.main+7077 @054931> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7082 @054936> : 21                         load.i16
	<.main+7083 @054937> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7088 @05493c> : 21                         load.i16
	<.main+7089 @05493d> : 51                         add.i32
	<.main+7090 @05493e> : 1f c0 26 05 00             load.ref <@0526c0> ;u16Add
	<.main+7095 @054943> : 26                         store.i16
	test/lang/useOperator.ci:128: (19 bytes: <@054944> - <@054957>): static u16Sub: uint16 := uint16(u16A - u16B)
	<.main+7096 @054944> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7101 @054949> : 21                         load.i16
	<.main+7102 @05494a> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7107 @05494f> : 21                         load.i16
	<.main+7108 @054950> : 52                         sub.i32
	<.main+7109 @054951> : 1f c8 26 05 00             load.ref <@0526c8> ;u16Sub
	<.main+7114 @054956> : 26                         store.i16
	test/lang/useOperator.ci:129: (19 bytes: <@054957> - <@05496a>): static u16Mul: uint16 := uint16(u16A * u16B)
	<.main+7115 @054957> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7120 @05495c> : 21                         load.i16
	<.main+7121 @05495d> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7126 @054962> : 21                         load.i16
	<.main+7127 @054963> : 33                         mul.u32
	<.main+7128 @054964> : 1f d0 26 05 00             load.ref <@0526d0> ;u16Mul
	<.main+7133 @054969> : 26                         store.i16
	test/lang/useOperator.ci:130: (19 bytes: <@05496a> - <@05497d>): static u16Div: uint16 := uint16(u16A / u16B)
	<.main+7134 @05496a> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7139 @05496f> : 21                         load.i16
	<.main+7140 @054970> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7145 @054975> : 21                         load.i16
	<.main+7146 @054976> : 34                         div.u32
	<.main+7147 @054977> : 1f d8 26 05 00             load.ref <@0526d8> ;u16Div
	<.main+7152 @05497c> : 26                         store.i16
	test/lang/useOperator.ci:131: (19 bytes: <@05497d> - <@054990>): static u16Mod: uint16 := uint16(u16A % u16B)
	<.main+7153 @05497d> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7158 @054982> : 21                         load.i16
	<.main+7159 @054983> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7164 @054988> : 21                         load.i16
	<.main+7165 @054989> : 35                         mod.u32
	<.main+7166 @05498a> : 1f e0 26 05 00             load.ref <@0526e0> ;u16Mod
	<.main+7171 @05498f> : 26                         store.i16
	test/lang/useOperator.ci:132: (19 bytes: <@054990> - <@0549a3>): static u16And: uint16 := uint16(u16A & u16B)
	<.main+7172 @054990> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7177 @054995> : 21                         load.i16
	<.main+7178 @054996> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7183 @05499b> : 21                         load.i16
	<.main+7184 @05499c> : 31                         and.b32
	<.main+7185 @05499d> : 1f e8 26 05 00             load.ref <@0526e8> ;u16And
	<.main+7190 @0549a2> : 26                         store.i16
	test/lang/useOperator.ci:133: (19 bytes: <@0549a3> - <@0549b6>): static u16Ior: uint16 := uint16(u16A | u16B)
	<.main+7191 @0549a3> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7196 @0549a8> : 21                         load.i16
	<.main+7197 @0549a9> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7202 @0549ae> : 21                         load.i16
	<.main+7203 @0549af> : 32                         or.b32
	<.main+7204 @0549b0> : 1f f0 26 05 00             load.ref <@0526f0> ;u16Ior
	<.main+7209 @0549b5> : 26                         store.i16
	test/lang/useOperator.ci:134: (19 bytes: <@0549b6> - <@0549c9>): static u16Xor: uint16 := uint16(u16A ^ u16B)
	<.main+7210 @0549b6> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7215 @0549bb> : 21                         load.i16
	<.main+7216 @0549bc> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7221 @0549c1> : 21                         load.i16
	<.main+7222 @0549c2> : 36                         xor.b32
	<.main+7223 @0549c3> : 1f f8 26 05 00             load.ref <@0526f8> ;u16Xor
	<.main+7228 @0549c8> : 26                         store.i16
	test/lang/useOperator.ci:135: (17 bytes: <@0549c9> - <@0549da>): static u16Shl: uint16 := int32((u16A) << shift)
	<.main+7229 @0549c9> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7234 @0549ce> : 21                         load.i16
	<.main+7235 @0549cf> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7239 @0549d3> : 3a                         shl.b32
	<.main+7240 @0549d4> : 1f 00 27 05 00             load.ref <@052700> ;u16Shl
	<.main+7245 @0549d9> : 26                         store.i16
	test/lang/useOperator.ci:136: (17 bytes: <@0549da> - <@0549eb>): static u16Shr: uint16 := int32((u16A) >> shift)
	<.main+7246 @0549da> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7251 @0549df> : 21                         load.i16
	<.main+7252 @0549e0> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7256 @0549e4> : 3c                         sar.b32
	<.main+7257 @0549e5> : 1f 08 27 05 00             load.ref <@052708> ;u16Shr
	<.main+7262 @0549ea> : 26                         store.i16
	test/lang/useOperator.ci:137: (14 bytes: <@0549eb> - <@0549f9>): static u16Not: bool := bool(!(u16B))
	<.main+7263 @0549eb> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7268 @0549f0> : 21                         load.i16
	<.main+7269 @0549f1> : 5a                         i32.2bool
	<.main+7270 @0549f2> : 0b                         not.b32
	<.main+7271 @0549f3> : 1f 10 27 05 00             load.ref <@052710> ;u16Not
	<.main+7276 @0549f8> : 25                         store.i8
	test/lang/useOperator.ci:138: (19 bytes: <@0549f9> - <@054a0c>): static u16Ceq: bool := bool(u16A == u16B)
	<.main+7277 @0549f9> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7282 @0549fe> : 21                         load.i16
	<.main+7283 @0549ff> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7288 @054a04> : 21                         load.i16
	<.main+7289 @054a05> : 57                         ceq.i32
	<.main+7290 @054a06> : 1f 18 27 05 00             load.ref <@052718> ;u16Ceq
	<.main+7295 @054a0b> : 25                         store.i8
	test/lang/useOperator.ci:139: (20 bytes: <@054a0c> - <@054a20>): static u16Cne: bool := bool(u16A != u16B)
	<.main+7296 @054a0c> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7301 @054a11> : 21                         load.i16
	<.main+7302 @054a12> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7307 @054a17> : 21                         load.i16
	<.main+7308 @054a18> : 57                         ceq.i32
	<.main+7309 @054a19> : 0b                         not.b32
	<.main+7310 @054a1a> : 1f 20 27 05 00             load.ref <@052720> ;u16Cne
	<.main+7315 @054a1f> : 25                         store.i8
	test/lang/useOperator.ci:140: (19 bytes: <@054a20> - <@054a33>): static u16Clt: bool := bool(u16A < u16B)
	<.main+7316 @054a20> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7321 @054a25> : 21                         load.i16
	<.main+7322 @054a26> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7327 @054a2b> : 21                         load.i16
	<.main+7328 @054a2c> : 38                         clt.u32
	<.main+7329 @054a2d> : 1f 28 27 05 00             load.ref <@052728> ;u16Clt
	<.main+7334 @054a32> : 25                         store.i8
	test/lang/useOperator.ci:141: (20 bytes: <@054a33> - <@054a47>): static u16Cle: bool := bool(u16A <= u16B)
	<.main+7335 @054a33> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7340 @054a38> : 21                         load.i16
	<.main+7341 @054a39> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7346 @054a3e> : 21                         load.i16
	<.main+7347 @054a3f> : 39                         cgt.u32
	<.main+7348 @054a40> : 0b                         not.b32
	<.main+7349 @054a41> : 1f 30 27 05 00             load.ref <@052730> ;u16Cle
	<.main+7354 @054a46> : 25                         store.i8
	test/lang/useOperator.ci:142: (19 bytes: <@054a47> - <@054a5a>): static u16Cgt: bool := bool(u16A > u16B)
	<.main+7355 @054a47> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7360 @054a4c> : 21                         load.i16
	<.main+7361 @054a4d> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7366 @054a52> : 21                         load.i16
	<.main+7367 @054a53> : 39                         cgt.u32
	<.main+7368 @054a54> : 1f 38 27 05 00             load.ref <@052738> ;u16Cgt
	<.main+7373 @054a59> : 25                         store.i8
	test/lang/useOperator.ci:143: (20 bytes: <@054a5a> - <@054a6e>): static u16Cge: bool := bool(u16A >= u16B)
	<.main+7374 @054a5a> : 1f 98 26 05 00             load.ref <@052698> ;u16A
	<.main+7379 @054a5f> : 21                         load.i16
	<.main+7380 @054a60> : 1f a0 26 05 00             load.ref <@0526a0> ;u16B
	<.main+7385 @054a65> : 21                         load.i16
	<.main+7386 @054a66> : 38                         clt.u32
	<.main+7387 @054a67> : 0b                         not.b32
	<.main+7388 @054a68> : 1f 40 27 05 00             load.ref <@052740> ;u16Cge
	<.main+7393 @054a6d> : 25                         store.i8
	test/lang/useOperator.ci:145: (9 bytes: <@054a6e> - <@054a77>): static i32A: int32 := a
	<.main+7394 @054a6e> : 1c 60 00 00 00             load.c32 96
	<.main+7399 @054a73> : 2e 48 27 05                store.m32 <@052748> ;i32A
	test/lang/useOperator.ci:146: (9 bytes: <@054a77> - <@054a80>): static i32B: int32 := b
	<.main+7403 @054a77> : 1c 2a 00 00 00             load.c32 42
	<.main+7408 @054a7c> : 2e 50 27 05                store.m32 <@052750> ;i32B
	test/lang/useOperator.ci:147: (8 bytes: <@054a80> - <@054a88>): static i32Pls: int32 := int32(+i32B)
	<.main+7412 @054a80> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7416 @054a84> : 2e 58 27 05                store.m32 <@052758> ;i32Pls
	test/lang/useOperator.ci:148: (9 bytes: <@054a88> - <@054a91>): static i32Neg: int32 := int32(-i32B)
	<.main+7420 @054a88> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7424 @054a8c> : 50                         neg.i32
	<.main+7425 @054a8d> : 2e 60 27 05                store.m32 <@052760> ;i32Neg
	test/lang/useOperator.ci:149: (9 bytes: <@054a91> - <@054a9a>): static i32Cmt: int32 := int32(~i32B)
	<.main+7429 @054a91> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7433 @054a95> : 30                         cmt.b32
	<.main+7434 @054a96> : 2e 68 27 05                store.m32 <@052768> ;i32Cmt
	test/lang/useOperator.ci:150: (13 bytes: <@054a9a> - <@054aa7>): static i32Add: int32 := int32(i32A + i32B)
	<.main+7438 @054a9a> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7442 @054a9e> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7446 @054aa2> : 51                         add.i32
	<.main+7447 @054aa3> : 2e 70 27 05                store.m32 <@052770> ;i32Add
	test/lang/useOperator.ci:151: (13 bytes: <@054aa7> - <@054ab4>): static i32Sub: int32 := int32(i32A - i32B)
	<.main+7451 @054aa7> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7455 @054aab> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7459 @054aaf> : 52                         sub.i32
	<.main+7460 @054ab0> : 2e 78 27 05                store.m32 <@052778> ;i32Sub
	test/lang/useOperator.ci:152: (13 bytes: <@054ab4> - <@054ac1>): static i32Mul: int32 := int32(i32A * i32B)
	<.main+7464 @054ab4> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7468 @054ab8> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7472 @054abc> : 53                         mul.i32
	<.main+7473 @054abd> : 2e 80 27 05                store.m32 <@052780> ;i32Mul
	test/lang/useOperator.ci:153: (13 bytes: <@054ac1> - <@054ace>): static i32Div: int32 := int32(i32A / i32B)
	<.main+7477 @054ac1> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7481 @054ac5> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7485 @054ac9> : 54                         div.i32
	<.main+7486 @054aca> : 2e 88 27 05                store.m32 <@052788> ;i32Div
	test/lang/useOperator.ci:154: (13 bytes: <@054ace> - <@054adb>): static i32Mod: int32 := int32(i32A % i32B)
	<.main+7490 @054ace> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7494 @054ad2> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7498 @054ad6> : 55                         mod.i32
	<.main+7499 @054ad7> : 2e 90 27 05                store.m32 <@052790> ;i32Mod
	test/lang/useOperator.ci:155: (13 bytes: <@054adb> - <@054ae8>): static i32And: int32 := int32(i32A & i32B)
	<.main+7503 @054adb> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7507 @054adf> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7511 @054ae3> : 31                         and.b32
	<.main+7512 @054ae4> : 2e 98 27 05                store.m32 <@052798> ;i32And
	test/lang/useOperator.ci:156: (13 bytes: <@054ae8> - <@054af5>): static i32Ior: int32 := int32(i32A | i32B)
	<.main+7516 @054ae8> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7520 @054aec> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7524 @054af0> : 32                         or.b32
	<.main+7525 @054af1> : 2e a0 27 05                store.m32 <@0527a0> ;i32Ior
	test/lang/useOperator.ci:157: (13 bytes: <@054af5> - <@054b02>): static i32Xor: int32 := int32(i32A ^ i32B)
	<.main+7529 @054af5> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7533 @054af9> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7537 @054afd> : 36                         xor.b32
	<.main+7538 @054afe> : 2e a8 27 05                store.m32 <@0527a8> ;i32Xor
	test/lang/useOperator.ci:158: (13 bytes: <@054b02> - <@054b0f>): static i32Shl: int32 := int32(i32A << shift)
	<.main+7542 @054b02> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7546 @054b06> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7550 @054b0a> : 3a                         shl.b32
	<.main+7551 @054b0b> : 2e b0 27 05                store.m32 <@0527b0> ;i32Shl
	test/lang/useOperator.ci:159: (13 bytes: <@054b0f> - <@054b1c>): static i32Shr: int32 := int32(i32A >> shift)
	<.main+7555 @054b0f> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7559 @054b13> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7563 @054b17> : 3c                         sar.b32
	<.main+7564 @054b18> : 2e b8 27 05                store.m32 <@0527b8> ;i32Shr
	test/lang/useOperator.ci:160: (12 bytes: <@054b1c> - <@054b28>): static i32Not: bool := bool(!(i32B))
	<.main+7568 @054b1c> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7572 @054b20> : 5a                         i32.2bool
	<.main+7573 @054b21> : 0b                         not.b32
	<.main+7574 @054b22> : 1f c0 27 05 00             load.ref <@0527c0> ;i32Not
	<.main+7579 @054b27> : 25                         store.i8
	test/lang/useOperator.ci:161: (15 bytes: <@054b28> - <@054b37>): static i32Ceq: bool := bool(i32A == i32B)
	<.main+7580 @054b28> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7584 @054b2c> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7588 @054b30> : 57                         ceq.i32
	<.main+7589 @054b31> : 1f c8 27 05 00             load.ref <@0527c8> ;i32Ceq
	<.main+7594 @054b36> : 25                         store.i8
	test/lang/useOperator.ci:162: (16 bytes: <@054b37> - <@054b47>): static i32Cne: bool := bool(i32A != i32B)
	<.main+7595 @054b37> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7599 @054b3b> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7603 @054b3f> : 57                         ceq.i32
	<.main+7604 @054b40> : 0b                         not.b32
	<.main+7605 @054b41> : 1f d0 27 05 00             load.ref <@0527d0> ;i32Cne
	<.main+7610 @054b46> : 25                         store.i8
	test/lang/useOperator.ci:163: (15 bytes: <@054b47> - <@054b56>): static i32Clt: bool := bool(i32A < i32B)
	<.main+7611 @054b47> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7615 @054b4b> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7619 @054b4f> : 58                         clt.i32
	<.main+7620 @054b50> : 1f d8 27 05 00             load.ref <@0527d8> ;i32Clt
	<.main+7625 @054b55> : 25                         store.i8
	test/lang/useOperator.ci:164: (16 bytes: <@054b56> - <@054b66>): static i32Cle: bool := bool(i32A <= i32B)
	<.main+7626 @054b56> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7630 @054b5a> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7634 @054b5e> : 59                         cgt.i32
	<.main+7635 @054b5f> : 0b                         not.b32
	<.main+7636 @054b60> : 1f e0 27 05 00             load.ref <@0527e0> ;i32Cle
	<.main+7641 @054b65> : 25                         store.i8
	test/lang/useOperator.ci:165: (15 bytes: <@054b66> - <@054b75>): static i32Cgt: bool := bool(i32A > i32B)
	<.main+7642 @054b66> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7646 @054b6a> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7650 @054b6e> : 59                         cgt.i32
	<.main+7651 @054b6f> : 1f e8 27 05 00             load.ref <@0527e8> ;i32Cgt
	<.main+7656 @054b74> : 25                         store.i8
	test/lang/useOperator.ci:166: (16 bytes: <@054b75> - <@054b85>): static i32Cge: bool := bool(i32A >= i32B)
	<.main+7657 @054b75> : 2a 48 27 05                load.m32 <@052748> ;i32A
	<.main+7661 @054b79> : 2a 50 27 05                load.m32 <@052750> ;i32B
	<.main+7665 @054b7d> : 58                         clt.i32
	<.main+7666 @054b7e> : 0b                         not.b32
	<.main+7667 @054b7f> : 1f f0 27 05 00             load.ref <@0527f0> ;i32Cge
	<.main+7672 @054b84> : 25                         store.i8
	test/lang/useOperator.ci:168: (9 bytes: <@054b85> - <@054b8e>): static u32A: uint32 := a
	<.main+7673 @054b85> : 1c 60 00 00 00             load.c32 96
	<.main+7678 @054b8a> : 2e f8 27 05                store.m32 <@0527f8> ;u32A
	test/lang/useOperator.ci:169: (9 bytes: <@054b8e> - <@054b97>): static u32B: uint32 := b
	<.main+7682 @054b8e> : 1c 2a 00 00 00             load.c32 42
	<.main+7687 @054b93> : 2e 00 28 05                store.m32 <@052800> ;u32B
	test/lang/useOperator.ci:170: (8 bytes: <@054b97> - <@054b9f>): static u32Pls: uint32 := uint32(+u32B)
	<.main+7691 @054b97> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7695 @054b9b> : 2e 08 28 05                store.m32 <@052808> ;u32Pls
	test/lang/useOperator.ci:171: (9 bytes: <@054b9f> - <@054ba8>): static u32Neg: uint32 := uint32(-u32B)
	<.main+7699 @054b9f> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7703 @054ba3> : 50                         neg.i32
	<.main+7704 @054ba4> : 2e 10 28 05                store.m32 <@052810> ;u32Neg
	test/lang/useOperator.ci:172: (9 bytes: <@054ba8> - <@054bb1>): static u32Cmt: uint32 := uint32(~u32B)
	<.main+7708 @054ba8> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7712 @054bac> : 30                         cmt.b32
	<.main+7713 @054bad> : 2e 18 28 05                store.m32 <@052818> ;u32Cmt
	test/lang/useOperator.ci:173: (13 bytes: <@054bb1> - <@054bbe>): static u32Add: uint32 := uint32(u32A + u32B)
	<.main+7717 @054bb1> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7721 @054bb5> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7725 @054bb9> : 51                         add.i32
	<.main+7726 @054bba> : 2e 20 28 05                store.m32 <@052820> ;u32Add
	test/lang/useOperator.ci:174: (13 bytes: <@054bbe> - <@054bcb>): static u32Sub: uint32 := uint32(u32A - u32B)
	<.main+7730 @054bbe> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7734 @054bc2> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7738 @054bc6> : 52                         sub.i32
	<.main+7739 @054bc7> : 2e 28 28 05                store.m32 <@052828> ;u32Sub
	test/lang/useOperator.ci:175: (13 bytes: <@054bcb> - <@054bd8>): static u32Mul: uint32 := uint32(u32A * u32B)
	<.main+7743 @054bcb> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7747 @054bcf> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7751 @054bd3> : 33                         mul.u32
	<.main+7752 @054bd4> : 2e 30 28 05                store.m32 <@052830> ;u32Mul
	test/lang/useOperator.ci:176: (13 bytes: <@054bd8> - <@054be5>): static u32Div: uint32 := uint32(u32A / u32B)
	<.main+7756 @054bd8> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7760 @054bdc> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7764 @054be0> : 34                         div.u32
	<.main+7765 @054be1> : 2e 38 28 05                store.m32 <@052838> ;u32Div
	test/lang/useOperator.ci:177: (13 bytes: <@054be5> - <@054bf2>): static u32Mod: uint32 := uint32(u32A % u32B)
	<.main+7769 @054be5> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7773 @054be9> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7777 @054bed> : 35                         mod.u32
	<.main+7778 @054bee> : 2e 40 28 05                store.m32 <@052840> ;u32Mod
	test/lang/useOperator.ci:178: (13 bytes: <@054bf2> - <@054bff>): static u32And: uint32 := uint32(u32A & u32B)
	<.main+7782 @054bf2> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7786 @054bf6> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7790 @054bfa> : 31                         and.b32
	<.main+7791 @054bfb> : 2e 48 28 05                store.m32 <@052848> ;u32And
	test/lang/useOperator.ci:179: (13 bytes: <@054bff> - <@054c0c>): static u32Ior: uint32 := uint32(u32A | u32B)
	<.main+7795 @054bff> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7799 @054c03> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7803 @054c07> : 32                         or.b32
	<.main+7804 @054c08> : 2e 50 28 05                store.m32 <@052850> ;u32Ior
	test/lang/useOperator.ci:180: (13 bytes: <@054c0c> - <@054c19>): static u32Xor: uint32 := uint32(u32A ^ u32B)
	<.main+7808 @054c0c> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7812 @054c10> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7816 @054c14> : 36                         xor.b32
	<.main+7817 @054c15> : 2e 58 28 05                store.m32 <@052858> ;u32Xor
	test/lang/useOperator.ci:181: (13 bytes: <@054c19> - <@054c26>): static u32Shl: uint32 := uint32(u32A << shift)
	<.main+7821 @054c19> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7825 @054c1d> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7829 @054c21> : 3a                         shl.b32
	<.main+7830 @054c22> : 2e 60 28 05                store.m32 <@052860> ;u32Shl
	test/lang/useOperator.ci:182: (13 bytes: <@054c26> - <@054c33>): static u32Shr: uint32 := uint32(u32A >> shift)
	<.main+7834 @054c26> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7838 @054c2a> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+7842 @054c2e> : 3b                         shr.b32
	<.main+7843 @054c2f> : 2e 68 28 05                store.m32 <@052868> ;u32Shr
	test/lang/useOperator.ci:183: (12 bytes: <@054c33> - <@054c3f>): static u32Not: bool := bool(!(u32B))
	<.main+7847 @054c33> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7851 @054c37> : 5a                         i32.2bool
	<.main+7852 @054c38> : 0b                         not.b32
	<.main+7853 @054c39> : 1f 70 28 05 00             load.ref <@052870> ;u32Not
	<.main+7858 @054c3e> : 25                         store.i8
	test/lang/useOperator.ci:184: (15 bytes: <@054c3f> - <@054c4e>): static u32Ceq: bool := bool(u32A == u32B)
	<.main+7859 @054c3f> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7863 @054c43> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7867 @054c47> : 57                         ceq.i32
	<.main+7868 @054c48> : 1f 78 28 05 00             load.ref <@052878> ;u32Ceq
	<.main+7873 @054c4d> : 25                         store.i8
	test/lang/useOperator.ci:185: (16 bytes: <@054c4e> - <@054c5e>): static u32Cne: bool := bool(u32A != u32B)
	<.main+7874 @054c4e> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7878 @054c52> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7882 @054c56> : 57                         ceq.i32
	<.main+7883 @054c57> : 0b                         not.b32
	<.main+7884 @054c58> : 1f 80 28 05 00             load.ref <@052880> ;u32Cne
	<.main+7889 @054c5d> : 25                         store.i8
	test/lang/useOperator.ci:186: (15 bytes: <@054c5e> - <@054c6d>): static u32Clt: bool := bool(u32A < u32B)
	<.main+7890 @054c5e> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7894 @054c62> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7898 @054c66> : 38                         clt.u32
	<.main+7899 @054c67> : 1f 88 28 05 00             load.ref <@052888> ;u32Clt
	<.main+7904 @054c6c> : 25                         store.i8
	test/lang/useOperator.ci:187: (16 bytes: <@054c6d> - <@054c7d>): static u32Cle: bool := bool(u32A <= u32B)
	<.main+7905 @054c6d> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7909 @054c71> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7913 @054c75> : 39                         cgt.u32
	<.main+7914 @054c76> : 0b                         not.b32
	<.main+7915 @054c77> : 1f 90 28 05 00             load.ref <@052890> ;u32Cle
	<.main+7920 @054c7c> : 25                         store.i8
	test/lang/useOperator.ci:188: (15 bytes: <@054c7d> - <@054c8c>): static u32Cgt: bool := bool(u32A > u32B)
	<.main+7921 @054c7d> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7925 @054c81> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7929 @054c85> : 39                         cgt.u32
	<.main+7930 @054c86> : 1f 98 28 05 00             load.ref <@052898> ;u32Cgt
	<.main+7935 @054c8b> : 25                         store.i8
	test/lang/useOperator.ci:189: (16 bytes: <@054c8c> - <@054c9c>): static u32Cge: bool := bool(u32A >= u32B)
	<.main+7936 @054c8c> : 2a f8 27 05                load.m32 <@0527f8> ;u32A
	<.main+7940 @054c90> : 2a 00 28 05                load.m32 <@052800> ;u32B
	<.main+7944 @054c94> : 38                         clt.u32
	<.main+7945 @054c95> : 0b                         not.b32
	<.main+7946 @054c96> : 1f a0 28 05 00             load.ref <@0528a0> ;u32Cge
	<.main+7951 @054c9b> : 25                         store.i8
	test/lang/useOperator.ci:191: (13 bytes: <@054c9c> - <@054ca9>): static i64A: int64 := a
	<.main+7952 @054c9c> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+7961 @054ca5> : 2d a8 28 05                store.m64 <@0528a8> ;i64A
	test/lang/useOperator.ci:192: (13 bytes: <@054ca9> - <@054cb6>): static i64B: int64 := b
	<.main+7965 @054ca9> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+7974 @054cb2> : 2d b0 28 05                store.m64 <@0528b0> ;i64B
	test/lang/useOperator.ci:193: (8 bytes: <@054cb6> - <@054cbe>): static i64Pls: int64 := int64(+i64B)
	<.main+7978 @054cb6> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+7982 @054cba> : 2d b8 28 05                store.m64 <@0528b8> ;i64Pls
	test/lang/useOperator.ci:194: (9 bytes: <@054cbe> - <@054cc7>): static i64Neg: int64 := int64(-i64B)
	<.main+7986 @054cbe> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+7990 @054cc2> : 60                         neg.i64
	<.main+7991 @054cc3> : 2d c0 28 05                store.m64 <@0528c0> ;i64Neg
	test/lang/useOperator.ci:195: (9 bytes: <@054cc7> - <@054cd0>): static i64Cmt: int64 := int64(~i64B)
	<.main+7995 @054cc7> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+7999 @054ccb> : 40                         cmt.b64
	<.main+8000 @054ccc> : 2d c8 28 05                store.m64 <@0528c8> ;i64Cmt
	test/lang/useOperator.ci:196: (13 bytes: <@054cd0> - <@054cdd>): static i64Add: int64 := int64(i64A + i64B)
	<.main+8004 @054cd0> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8008 @054cd4> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8012 @054cd8> : 61                         add.i64
	<.main+8013 @054cd9> : 2d d0 28 05                store.m64 <@0528d0> ;i64Add
	test/lang/useOperator.ci:197: (13 bytes: <@054cdd> - <@054cea>): static i64Sub: int64 := int64(i64A - i64B)
	<.main+8017 @054cdd> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8021 @054ce1> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8025 @054ce5> : 62                         sub.i64
	<.main+8026 @054ce6> : 2d d8 28 05                store.m64 <@0528d8> ;i64Sub
	test/lang/useOperator.ci:198: (13 bytes: <@054cea> - <@054cf7>): static i64Mul: int64 := int64(i64A * i64B)
	<.main+8030 @054cea> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8034 @054cee> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8038 @054cf2> : 63                         mul.i64
	<.main+8039 @054cf3> : 2d e0 28 05                store.m64 <@0528e0> ;i64Mul
	test/lang/useOperator.ci:199: (13 bytes: <@054cf7> - <@054d04>): static i64Div: int64 := int64(i64A / i64B)
	<.main+8043 @054cf7> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8047 @054cfb> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8051 @054cff> : 64                         div.i64
	<.main+8052 @054d00> : 2d e8 28 05                store.m64 <@0528e8> ;i64Div
	test/lang/useOperator.ci:200: (13 bytes: <@054d04> - <@054d11>): static i64Mod: int64 := int64(i64A % i64B)
	<.main+8056 @054d04> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8060 @054d08> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8064 @054d0c> : 65                         mod.i64
	<.main+8065 @054d0d> : 2d f0 28 05                store.m64 <@0528f0> ;i64Mod
	test/lang/useOperator.ci:201: (13 bytes: <@054d11> - <@054d1e>): static i64And: int64 := int64(i64A & i64B)
	<.main+8069 @054d11> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8073 @054d15> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8077 @054d19> : 41                         and.b64
	<.main+8078 @054d1a> : 2d f8 28 05                store.m64 <@0528f8> ;i64And
	test/lang/useOperator.ci:202: (13 bytes: <@054d1e> - <@054d2b>): static i64Ior: int64 := int64(i64A | i64B)
	<.main+8082 @054d1e> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8086 @054d22> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8090 @054d26> : 42                         or.b64
	<.main+8091 @054d27> : 2d 00 29 05                store.m64 <@052900> ;i64Ior
	test/lang/useOperator.ci:203: (13 bytes: <@054d2b> - <@054d38>): static i64Xor: int64 := int64(i64A ^ i64B)
	<.main+8095 @054d2b> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8099 @054d2f> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8103 @054d33> : 46                         xor.b64
	<.main+8104 @054d34> : 2d 08 29 05                store.m64 <@052908> ;i64Xor
	test/lang/useOperator.ci:204: (13 bytes: <@054d38> - <@054d45>): static i64Shl: int64 := int64(i64A << shift)
	<.main+8108 @054d38> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8112 @054d3c> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+8116 @054d40> : 4a                         shl.b64
	<.main+8117 @054d41> : 2d 10 29 05                store.m64 <@052910> ;i64Shl
	test/lang/useOperator.ci:205: (13 bytes: <@054d45> - <@054d52>): static i64Shr: int64 := int64(i64A >> shift)
	<.main+8121 @054d45> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8125 @054d49> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+8129 @054d4d> : 4c                         sar.b64
	<.main+8130 @054d4e> : 2d 18 29 05                store.m64 <@052918> ;i64Shr
	test/lang/useOperator.ci:206: (12 bytes: <@054d52> - <@054d5e>): static i64Not: bool := bool(!(i64B))
	<.main+8134 @054d52> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8138 @054d56> : 6b                         i64.2bool
	<.main+8139 @054d57> : 0b                         not.b32
	<.main+8140 @054d58> : 1f 20 29 05 00             load.ref <@052920> ;i64Not
	<.main+8145 @054d5d> : 25                         store.i8
	test/lang/useOperator.ci:207: (15 bytes: <@054d5e> - <@054d6d>): static i64Ceq: bool := bool(i64A == i64B)
	<.main+8146 @054d5e> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8150 @054d62> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8154 @054d66> : 67                         ceq.i64
	<.main+8155 @054d67> : 1f 28 29 05 00             load.ref <@052928> ;i64Ceq
	<.main+8160 @054d6c> : 25                         store.i8
	test/lang/useOperator.ci:208: (16 bytes: <@054d6d> - <@054d7d>): static i64Cne: bool := bool(i64A != i64B)
	<.main+8161 @054d6d> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8165 @054d71> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8169 @054d75> : 67                         ceq.i64
	<.main+8170 @054d76> : 0b                         not.b32
	<.main+8171 @054d77> : 1f 30 29 05 00             load.ref <@052930> ;i64Cne
	<.main+8176 @054d7c> : 25                         store.i8
	test/lang/useOperator.ci:209: (15 bytes: <@054d7d> - <@054d8c>): static i64Clt: bool := bool(i64A < i64B)
	<.main+8177 @054d7d> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8181 @054d81> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8185 @054d85> : 68                         clt.i64
	<.main+8186 @054d86> : 1f 38 29 05 00             load.ref <@052938> ;i64Clt
	<.main+8191 @054d8b> : 25                         store.i8
	test/lang/useOperator.ci:210: (16 bytes: <@054d8c> - <@054d9c>): static i64Cle: bool := bool(i64A <= i64B)
	<.main+8192 @054d8c> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8196 @054d90> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8200 @054d94> : 69                         cgt.i64
	<.main+8201 @054d95> : 0b                         not.b32
	<.main+8202 @054d96> : 1f 40 29 05 00             load.ref <@052940> ;i64Cle
	<.main+8207 @054d9b> : 25                         store.i8
	test/lang/useOperator.ci:211: (15 bytes: <@054d9c> - <@054dab>): static i64Cgt: bool := bool(i64A > i64B)
	<.main+8208 @054d9c> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8212 @054da0> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8216 @054da4> : 69                         cgt.i64
	<.main+8217 @054da5> : 1f 48 29 05 00             load.ref <@052948> ;i64Cgt
	<.main+8222 @054daa> : 25                         store.i8
	test/lang/useOperator.ci:212: (16 bytes: <@054dab> - <@054dbb>): static i64Cge: bool := bool(i64A >= i64B)
	<.main+8223 @054dab> : 2b a8 28 05                load.m64 <@0528a8> ;i64A
	<.main+8227 @054daf> : 2b b0 28 05                load.m64 <@0528b0> ;i64B
	<.main+8231 @054db3> : 68                         clt.i64
	<.main+8232 @054db4> : 0b                         not.b32
	<.main+8233 @054db5> : 1f 50 29 05 00             load.ref <@052950> ;i64Cge
	<.main+8238 @054dba> : 25                         store.i8
	test/lang/useOperator.ci:214: (13 bytes: <@054dbb> - <@054dc8>): static u64A: uint64 := a
	<.main+8239 @054dbb> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8248 @054dc4> : 2d 58 29 05                store.m64 <@052958> ;u64A
	test/lang/useOperator.ci:215: (13 bytes: <@054dc8> - <@054dd5>): static u64B: uint64 := b
	<.main+8252 @054dc8> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8261 @054dd1> : 2d 60 29 05                store.m64 <@052960> ;u64B
	test/lang/useOperator.ci:216: (8 bytes: <@054dd5> - <@054ddd>): static u64Pls: uint64 := uint64(+u64B)
	<.main+8265 @054dd5> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8269 @054dd9> : 2d 68 29 05                store.m64 <@052968> ;u64Pls
	test/lang/useOperator.ci:217: (9 bytes: <@054ddd> - <@054de6>): static u64Neg: uint64 := uint64(-u64B)
	<.main+8273 @054ddd> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8277 @054de1> : 60                         neg.i64
	<.main+8278 @054de2> : 2d 70 29 05                store.m64 <@052970> ;u64Neg
	test/lang/useOperator.ci:218: (9 bytes: <@054de6> - <@054def>): static u64Cmt: uint64 := uint64(~u64B)
	<.main+8282 @054de6> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8286 @054dea> : 40                         cmt.b64
	<.main+8287 @054deb> : 2d 78 29 05                store.m64 <@052978> ;u64Cmt
	test/lang/useOperator.ci:219: (13 bytes: <@054def> - <@054dfc>): static u64Add: uint64 := uint64(u64A + u64B)
	<.main+8291 @054def> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8295 @054df3> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8299 @054df7> : 61                         add.i64
	<.main+8300 @054df8> : 2d 80 29 05                store.m64 <@052980> ;u64Add
	test/lang/useOperator.ci:220: (13 bytes: <@054dfc> - <@054e09>): static u64Sub: uint64 := uint64(u64A - u64B)
	<.main+8304 @054dfc> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8308 @054e00> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8312 @054e04> : 62                         sub.i64
	<.main+8313 @054e05> : 2d 88 29 05                store.m64 <@052988> ;u64Sub
	test/lang/useOperator.ci:221: (13 bytes: <@054e09> - <@054e16>): static u64Mul: uint64 := uint64(u64A * u64B)
	<.main+8317 @054e09> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8321 @054e0d> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8325 @054e11> : 43                         mul.u64
	<.main+8326 @054e12> : 2d 90 29 05                store.m64 <@052990> ;u64Mul
	test/lang/useOperator.ci:222: (13 bytes: <@054e16> - <@054e23>): static u64Div: uint64 := uint64(u64A / u64B)
	<.main+8330 @054e16> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8334 @054e1a> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8338 @054e1e> : 44                         div.u64
	<.main+8339 @054e1f> : 2d 98 29 05                store.m64 <@052998> ;u64Div
	test/lang/useOperator.ci:223: (13 bytes: <@054e23> - <@054e30>): static u64Mod: uint64 := uint64(u64A % u64B)
	<.main+8343 @054e23> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8347 @054e27> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8351 @054e2b> : 45                         mod.u64
	<.main+8352 @054e2c> : 2d a0 29 05                store.m64 <@0529a0> ;u64Mod
	test/lang/useOperator.ci:224: (13 bytes: <@054e30> - <@054e3d>): static u64And: uint64 := uint64(u64A & u64B)
	<.main+8356 @054e30> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8360 @054e34> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8364 @054e38> : 41                         and.b64
	<.main+8365 @054e39> : 2d a8 29 05                store.m64 <@0529a8> ;u64And
	test/lang/useOperator.ci:225: (13 bytes: <@054e3d> - <@054e4a>): static u64Ior: uint64 := uint64(u64A | u64B)
	<.main+8369 @054e3d> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8373 @054e41> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8377 @054e45> : 42                         or.b64
	<.main+8378 @054e46> : 2d b0 29 05                store.m64 <@0529b0> ;u64Ior
	test/lang/useOperator.ci:226: (13 bytes: <@054e4a> - <@054e57>): static u64Xor: uint64 := uint64(u64A ^ u64B)
	<.main+8382 @054e4a> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8386 @054e4e> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8390 @054e52> : 46                         xor.b64
	<.main+8391 @054e53> : 2d b8 29 05                store.m64 <@0529b8> ;u64Xor
	test/lang/useOperator.ci:227: (13 bytes: <@054e57> - <@054e64>): static u64Shl: uint64 := uint64(u64A << shift)
	<.main+8395 @054e57> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8399 @054e5b> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+8403 @054e5f> : 4a                         shl.b64
	<.main+8404 @054e60> : 2d c0 29 05                store.m64 <@0529c0> ;u64Shl
	test/lang/useOperator.ci:228: (13 bytes: <@054e64> - <@054e71>): static u64Shr: uint64 := uint64(u64A >> shift)
	<.main+8408 @054e64> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8412 @054e68> : 2a 70 23 05                load.m32 <@052370> ;shift
	<.main+8416 @054e6c> : 4b                         shr.b64
	<.main+8417 @054e6d> : 2d c8 29 05                store.m64 <@0529c8> ;u64Shr
	test/lang/useOperator.ci:229: (12 bytes: <@054e71> - <@054e7d>): static u64Not: bool := bool(!(u64B))
	<.main+8421 @054e71> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8425 @054e75> : 6b                         i64.2bool
	<.main+8426 @054e76> : 0b                         not.b32
	<.main+8427 @054e77> : 1f d0 29 05 00             load.ref <@0529d0> ;u64Not
	<.main+8432 @054e7c> : 25                         store.i8
	test/lang/useOperator.ci:230: (15 bytes: <@054e7d> - <@054e8c>): static u64Ceq: bool := bool(u64A == u64B)
	<.main+8433 @054e7d> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8437 @054e81> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8441 @054e85> : 67                         ceq.i64
	<.main+8442 @054e86> : 1f d8 29 05 00             load.ref <@0529d8> ;u64Ceq
	<.main+8447 @054e8b> : 25                         store.i8
	test/lang/useOperator.ci:231: (16 bytes: <@054e8c> - <@054e9c>): static u64Cne: bool := bool(u64A != u64B)
	<.main+8448 @054e8c> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8452 @054e90> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8456 @054e94> : 67                         ceq.i64
	<.main+8457 @054e95> : 0b                         not.b32
	<.main+8458 @054e96> : 1f e0 29 05 00             load.ref <@0529e0> ;u64Cne
	<.main+8463 @054e9b> : 25                         store.i8
	test/lang/useOperator.ci:232: (15 bytes: <@054e9c> - <@054eab>): static u64Clt: bool := bool(u64A < u64B)
	<.main+8464 @054e9c> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8468 @054ea0> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8472 @054ea4> : 48                         clt.u64
	<.main+8473 @054ea5> : 1f e8 29 05 00             load.ref <@0529e8> ;u64Clt
	<.main+8478 @054eaa> : 25                         store.i8
	test/lang/useOperator.ci:233: (16 bytes: <@054eab> - <@054ebb>): static u64Cle: bool := bool(u64A <= u64B)
	<.main+8479 @054eab> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8483 @054eaf> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8487 @054eb3> : 49                         cgt.u64
	<.main+8488 @054eb4> : 0b                         not.b32
	<.main+8489 @054eb5> : 1f f0 29 05 00             load.ref <@0529f0> ;u64Cle
	<.main+8494 @054eba> : 25                         store.i8
	test/lang/useOperator.ci:234: (15 bytes: <@054ebb> - <@054eca>): static u64Cgt: bool := bool(u64A > u64B)
	<.main+8495 @054ebb> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8499 @054ebf> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8503 @054ec3> : 49                         cgt.u64
	<.main+8504 @054ec4> : 1f f8 29 05 00             load.ref <@0529f8> ;u64Cgt
	<.main+8509 @054ec9> : 25                         store.i8
	test/lang/useOperator.ci:235: (16 bytes: <@054eca> - <@054eda>): static u64Cge: bool := bool(u64A >= u64B)
	<.main+8510 @054eca> : 2b 58 29 05                load.m64 <@052958> ;u64A
	<.main+8514 @054ece> : 2b 60 29 05                load.m64 <@052960> ;u64B
	<.main+8518 @054ed2> : 48                         clt.u64
	<.main+8519 @054ed3> : 0b                         not.b32
	<.main+8520 @054ed4> : 1f 00 2a 05 00             load.ref <@052a00> ;u64Cge
	<.main+8525 @054ed9> : 25                         store.i8
	test/lang/useOperator.ci:237: (9 bytes: <@054eda> - <@054ee3>): static f32A: float32 := a
	<.main+8526 @054eda> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8531 @054edf> : 2e 08 2a 05                store.m32 <@052a08> ;f32A
	test/lang/useOperator.ci:238: (9 bytes: <@054ee3> - <@054eec>): static f32B: float32 := b
	<.main+8535 @054ee3> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8540 @054ee8> : 2e 10 2a 05                store.m32 <@052a10> ;f32B
	test/lang/useOperator.ci:239: (8 bytes: <@054eec> - <@054ef4>): static f32Pls: float32 := float32(+f32B)
	<.main+8544 @054eec> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8548 @054ef0> : 2e 18 2a 05                store.m32 <@052a18> ;f32Pls
	test/lang/useOperator.ci:240: (9 bytes: <@054ef4> - <@054efd>): static f32Neg: float32 := float32(-f32B)
	<.main+8552 @054ef4> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8556 @054ef8> : 70                         neg.f32
	<.main+8557 @054ef9> : 2e 20 2a 05                store.m32 <@052a20> ;f32Neg
	test/lang/useOperator.ci:242: (13 bytes: <@054efd> - <@054f0a>): static f32Add: float32 := float32(f32A + f32B)
	<.main+8561 @054efd> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8565 @054f01> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8569 @054f05> : 71                         add.f32
	<.main+8570 @054f06> : 2e 28 2a 05                store.m32 <@052a28> ;f32Add
	test/lang/useOperator.ci:243: (13 bytes: <@054f0a> - <@054f17>): static f32Sub: float32 := float32(f32A - f32B)
	<.main+8574 @054f0a> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8578 @054f0e> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8582 @054f12> : 72                         sub.f32
	<.main+8583 @054f13> : 2e 30 2a 05                store.m32 <@052a30> ;f32Sub
	test/lang/useOperator.ci:244: (13 bytes: <@054f17> - <@054f24>): static f32Mul: float32 := float32(f32A * f32B)
	<.main+8587 @054f17> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8591 @054f1b> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8595 @054f1f> : 73                         mul.f32
	<.main+8596 @054f20> : 2e 38 2a 05                store.m32 <@052a38> ;f32Mul
	test/lang/useOperator.ci:245: (13 bytes: <@054f24> - <@054f31>): static f32Div: float32 := float32(f32A / f32B)
	<.main+8600 @054f24> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8604 @054f28> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8608 @054f2c> : 74                         div.f32
	<.main+8609 @054f2d> : 2e 40 2a 05                store.m32 <@052a40> ;f32Div
	test/lang/useOperator.ci:246: (13 bytes: <@054f31> - <@054f3e>): static f32Mod: float32 := float32(f32A % f32B)
	<.main+8613 @054f31> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8617 @054f35> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8621 @054f39> : 75                         mod.f32
	<.main+8622 @054f3a> : 2e 48 2a 05                store.m32 <@052a48> ;f32Mod
	test/lang/useOperator.ci:252: (12 bytes: <@054f3e> - <@054f4a>): static f32Not: bool := bool(!(f32B))
	<.main+8626 @054f3e> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8630 @054f42> : 7c                         f32.2bool
	<.main+8631 @054f43> : 0b                         not.b32
	<.main+8632 @054f44> : 1f 50 2a 05 00             load.ref <@052a50> ;f32Not
	<.main+8637 @054f49> : 25                         store.i8
	test/lang/useOperator.ci:253: (15 bytes: <@054f4a> - <@054f59>): static f32Ceq: bool := bool(f32A == f32B)
	<.main+8638 @054f4a> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8642 @054f4e> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8646 @054f52> : 77                         ceq.f32
	<.main+8647 @054f53> : 1f 58 2a 05 00             load.ref <@052a58> ;f32Ceq
	<.main+8652 @054f58> : 25                         store.i8
	test/lang/useOperator.ci:254: (16 bytes: <@054f59> - <@054f69>): static f32Cne: bool := bool(f32A != f32B)
	<.main+8653 @054f59> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8657 @054f5d> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8661 @054f61> : 77                         ceq.f32
	<.main+8662 @054f62> : 0b                         not.b32
	<.main+8663 @054f63> : 1f 60 2a 05 00             load.ref <@052a60> ;f32Cne
	<.main+8668 @054f68> : 25                         store.i8
	test/lang/useOperator.ci:255: (15 bytes: <@054f69> - <@054f78>): static f32Clt: bool := bool(f32A < f32B)
	<.main+8669 @054f69> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8673 @054f6d> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8677 @054f71> : 78                         clt.f32
	<.main+8678 @054f72> : 1f 68 2a 05 00             load.ref <@052a68> ;f32Clt
	<.main+8683 @054f77> : 25                         store.i8
	test/lang/useOperator.ci:256: (16 bytes: <@054f78> - <@054f88>): static f32Cle: bool := bool(f32A <= f32B)
	<.main+8684 @054f78> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8688 @054f7c> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8692 @054f80> : 79                         cgt.f32
	<.main+8693 @054f81> : 0b                         not.b32
	<.main+8694 @054f82> : 1f 70 2a 05 00             load.ref <@052a70> ;f32Cle
	<.main+8699 @054f87> : 25                         store.i8
	test/lang/useOperator.ci:257: (15 bytes: <@054f88> - <@054f97>): static f32Cgt: bool := bool(f32A > f32B)
	<.main+8700 @054f88> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8704 @054f8c> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8708 @054f90> : 79                         cgt.f32
	<.main+8709 @054f91> : 1f 78 2a 05 00             load.ref <@052a78> ;f32Cgt
	<.main+8714 @054f96> : 25                         store.i8
	test/lang/useOperator.ci:258: (16 bytes: <@054f97> - <@054fa7>): static f32Cge: bool := bool(f32A >= f32B)
	<.main+8715 @054f97> : 2a 08 2a 05                load.m32 <@052a08> ;f32A
	<.main+8719 @054f9b> : 2a 10 2a 05                load.m32 <@052a10> ;f32B
	<.main+8723 @054f9f> : 78                         clt.f32
	<.main+8724 @054fa0> : 0b                         not.b32
	<.main+8725 @054fa1> : 1f 80 2a 05 00             load.ref <@052a80> ;f32Cge
	<.main+8730 @054fa6> : 25                         store.i8
	test/lang/useOperator.ci:260: (13 bytes: <@054fa7> - <@054fb4>): static f64A: float64 := a
	<.main+8731 @054fa7> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+8740 @054fb0> : 2d 88 2a 05                store.m64 <@052a88> ;f64A
	test/lang/useOperator.ci:261: (13 bytes: <@054fb4> - <@054fc1>): static f64B: float64 := b
	<.main+8744 @054fb4> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+8753 @054fbd> : 2d 90 2a 05                store.m64 <@052a90> ;f64B
	test/lang/useOperator.ci:262: (8 bytes: <@054fc1> - <@054fc9>): static f64Pls: float64 := float64(+f64B)
	<.main+8757 @054fc1> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8761 @054fc5> : 2d 98 2a 05                store.m64 <@052a98> ;f64Pls
	test/lang/useOperator.ci:263: (9 bytes: <@054fc9> - <@054fd2>): static f64Neg: float64 := float64(-f64B)
	<.main+8765 @054fc9> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8769 @054fcd> : 80                         neg.f64
	<.main+8770 @054fce> : 2d a0 2a 05                store.m64 <@052aa0> ;f64Neg
	test/lang/useOperator.ci:265: (13 bytes: <@054fd2> - <@054fdf>): static f64Add: float64 := float64(f64A + f64B)
	<.main+8774 @054fd2> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8778 @054fd6> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8782 @054fda> : 81                         add.f64
	<.main+8783 @054fdb> : 2d a8 2a 05                store.m64 <@052aa8> ;f64Add
	test/lang/useOperator.ci:266: (13 bytes: <@054fdf> - <@054fec>): static f64Sub: float64 := float64(f64A - f64B)
	<.main+8787 @054fdf> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8791 @054fe3> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8795 @054fe7> : 82                         sub.f64
	<.main+8796 @054fe8> : 2d b0 2a 05                store.m64 <@052ab0> ;f64Sub
	test/lang/useOperator.ci:267: (13 bytes: <@054fec> - <@054ff9>): static f64Mul: float64 := float64(f64A * f64B)
	<.main+8800 @054fec> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8804 @054ff0> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8808 @054ff4> : 83                         mul.f64
	<.main+8809 @054ff5> : 2d b8 2a 05                store.m64 <@052ab8> ;f64Mul
	test/lang/useOperator.ci:268: (13 bytes: <@054ff9> - <@055006>): static f64Div: float64 := float64(f64A / f64B)
	<.main+8813 @054ff9> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8817 @054ffd> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8821 @055001> : 84                         div.f64
	<.main+8822 @055002> : 2d c0 2a 05                store.m64 <@052ac0> ;f64Div
	test/lang/useOperator.ci:269: (13 bytes: <@055006> - <@055013>): static f64Mod: float64 := float64(f64A % f64B)
	<.main+8826 @055006> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8830 @05500a> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8834 @05500e> : 85                         mod.f64
	<.main+8835 @05500f> : 2d c8 2a 05                store.m64 <@052ac8> ;f64Mod
	test/lang/useOperator.ci:275: (12 bytes: <@055013> - <@05501f>): static f64Not: bool := bool(!(f64B))
	<.main+8839 @055013> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8843 @055017> : 8d                         f64.2bool
	<.main+8844 @055018> : 0b                         not.b32
	<.main+8845 @055019> : 1f d0 2a 05 00             load.ref <@052ad0> ;f64Not
	<.main+8850 @05501e> : 25                         store.i8
	test/lang/useOperator.ci:276: (15 bytes: <@05501f> - <@05502e>): static f64Ceq: bool := bool(f64A == f64B)
	<.main+8851 @05501f> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8855 @055023> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8859 @055027> : 87                         ceq.f64
	<.main+8860 @055028> : 1f d8 2a 05 00             load.ref <@052ad8> ;f64Ceq
	<.main+8865 @05502d> : 25                         store.i8
	test/lang/useOperator.ci:277: (16 bytes: <@05502e> - <@05503e>): static f64Cne: bool := bool(f64A != f64B)
	<.main+8866 @05502e> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8870 @055032> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8874 @055036> : 87                         ceq.f64
	<.main+8875 @055037> : 0b                         not.b32
	<.main+8876 @055038> : 1f e0 2a 05 00             load.ref <@052ae0> ;f64Cne
	<.main+8881 @05503d> : 25                         store.i8
	test/lang/useOperator.ci:278: (15 bytes: <@05503e> - <@05504d>): static f64Clt: bool := bool(f64A < f64B)
	<.main+8882 @05503e> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8886 @055042> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8890 @055046> : 88                         clt.f64
	<.main+8891 @055047> : 1f e8 2a 05 00             load.ref <@052ae8> ;f64Clt
	<.main+8896 @05504c> : 25                         store.i8
	test/lang/useOperator.ci:279: (16 bytes: <@05504d> - <@05505d>): static f64Cle: bool := bool(f64A <= f64B)
	<.main+8897 @05504d> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8901 @055051> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8905 @055055> : 89                         cgt.f64
	<.main+8906 @055056> : 0b                         not.b32
	<.main+8907 @055057> : 1f f0 2a 05 00             load.ref <@052af0> ;f64Cle
	<.main+8912 @05505c> : 25                         store.i8
	test/lang/useOperator.ci:280: (15 bytes: <@05505d> - <@05506c>): static f64Cgt: bool := bool(f64A > f64B)
	<.main+8913 @05505d> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8917 @055061> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8921 @055065> : 89                         cgt.f64
	<.main+8922 @055066> : 1f f8 2a 05 00             load.ref <@052af8> ;f64Cgt
	<.main+8927 @05506b> : 25                         store.i8
	test/lang/useOperator.ci:281: (16 bytes: <@05506c> - <@05507c>): static f64Cge: bool := bool(f64A >= f64B)
	<.main+8928 @05506c> : 2b 88 2a 05                load.m64 <@052a88> ;f64A
	<.main+8932 @055070> : 2b 90 2a 05                load.m64 <@052a90> ;f64B
	<.main+8936 @055074> : 88                         clt.f64
	<.main+8937 @055075> : 0b                         not.b32
	<.main+8938 @055076> : 1f 00 2b 05 00             load.ref <@052b00> ;f64Cge
	<.main+8943 @05507b> : 25                         store.i8
	test/lang/useOperator.ci:283: (9 bytes: <@05507c> - <@055085>): static ptrA: pointer := null
	<.main+8944 @05507c> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+8949 @055081> : 2e 08 2b 05                store.m32 <@052b08> ;ptrA
	test/lang/useOperator.ci:284: (9 bytes: <@055085> - <@05508e>): static ptrB: pointer := pointer(shift)
	<.main+8953 @055085> : 1f 70 23 05 00             load.ref <@052370> ;shift
	<.main+8958 @05508a> : 2e 10 2b 05                store.m32 <@052b10> ;ptrB
	test/lang/useOperator.ci:299: (15 bytes: <@05508e> - <@05509d>): static ptrCeq: bool := bool(ptrA == ptrB)
	<.main+8962 @05508e> : 2a 08 2b 05                load.m32 <@052b08> ;ptrA
	<.main+8966 @055092> : 2a 10 2b 05                load.m32 <@052b10> ;ptrB
	<.main+8970 @055096> : 57                         ceq.i32
	<.main+8971 @055097> : 1f 18 2b 05 00             load.ref <@052b18> ;ptrCeq
	<.main+8976 @05509c> : 25                         store.i8
	test/lang/useOperator.ci:300: (16 bytes: <@05509d> - <@0550ad>): static ptrCne: bool := bool(ptrA != ptrB)
	<.main+8977 @05509d> : 2a 08 2b 05                load.m32 <@052b08> ;ptrA
	<.main+8981 @0550a1> : 2a 10 2b 05                load.m32 <@052b10> ;ptrB
	<.main+8985 @0550a5> : 57                         ceq.i32
	<.main+8986 @0550a6> : 0b                         not.b32
	<.main+8987 @0550a7> : 1f 20 2b 05 00             load.ref <@052b20> ;ptrCne
	<.main+8992 @0550ac> : 25                         store.i8
	test/lang/statementIf.ci:26: (5 bytes: <@0550ad> - <@0550b2>): static t: int32 := 0
	<.main+8993 @0550ad> : 19                         load.z32
	<.main+8994 @0550ae> : 2e 28 2b 05                store.m32 <@052b28> ;t
	test/lang/statementFor.ci:12: (5 bytes: <@0550b2> - <@0550b7>): static forIdx: int32
	<.main+8998 @0550b2> : 19                         load.z32
	<.main+8999 @0550b3> : 2e 30 2b 05                store.m32 <@052b30> ;forIdx
	test/stdc/test.math.ci:3: (24 bytes: <@0550b7> - <@0550cf>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9003 @0550b7> : 1a                         load.z64
	<.main+9004 @0550b8> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9013 @0550c1> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9018 @0550c6> : 02                         call
	<.main+9019 @0550c7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9023 @0550cb> : 2d 38 2b 05                store.m64 <@052b38> ;testMathFloor_1
	test/stdc/test.math.ci:4: (24 bytes: <@0550cf> - <@0550e7>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9027 @0550cf> : 1a                         load.z64
	<.main+9028 @0550d0> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9037 @0550d9> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9042 @0550de> : 02                         call
	<.main+9043 @0550df> : 09 f8 ff ff                inc.sp(-8)
	<.main+9047 @0550e3> : 2d 40 2b 05                store.m64 <@052b40> ;testMathFloor_2
	test/stdc/test.math.ci:5: (24 bytes: <@0550e7> - <@0550ff>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9051 @0550e7> : 1a                         load.z64
	<.main+9052 @0550e8> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9061 @0550f1> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9066 @0550f6> : 02                         call
	<.main+9067 @0550f7> : 09 f8 ff ff                inc.sp(-8)
	<.main+9071 @0550fb> : 2d 48 2b 05                store.m64 <@052b48> ;testMathFloor_3
	test/stdc/test.math.ci:6: (24 bytes: <@0550ff> - <@055117>): static testMathFloor_4: float64 := Math.floor(float64(-3.200000))
	<.main+9075 @0550ff> : 1a                         load.z64
	<.main+9076 @055100> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9085 @055109> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9090 @05510e> : 02                         call
	<.main+9091 @05510f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9095 @055113> : 2d 50 2b 05                store.m64 <@052b50> ;testMathFloor_4
	test/stdc/test.math.ci:7: (24 bytes: <@055117> - <@05512f>): static testMathFloor_5: float64 := Math.floor(float64(-3.500000))
	<.main+9099 @055117> : 1a                         load.z64
	<.main+9100 @055118> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9109 @055121> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9114 @055126> : 02                         call
	<.main+9115 @055127> : 09 f8 ff ff                inc.sp(-8)
	<.main+9119 @05512b> : 2d 58 2b 05                store.m64 <@052b58> ;testMathFloor_5
	test/stdc/test.math.ci:8: (24 bytes: <@05512f> - <@055147>): static testMathFloor_6: float64 := Math.floor(float64(-3.600000))
	<.main+9123 @05512f> : 1a                         load.z64
	<.main+9124 @055130> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9133 @055139> : 1f 00 08 05 00             load.ref <@050800> ;Math.floor(x: float64): float64
	<.main+9138 @05513e> : 02                         call
	<.main+9139 @05513f> : 09 f8 ff ff                inc.sp(-8)
	<.main+9143 @055143> : 2d 60 2b 05                store.m64 <@052b60> ;testMathFloor_6
	test/stdc/test.math.ci:10: (29 bytes: <@055147> - <@055164>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9147 @055147> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9156 @055150> : 11 00                      dup.x64 sp(0)
	<.main+9158 @055152> : 1a                         load.z64
	<.main+9159 @055153> : 89                         cgt.f64
	<.main+9160 @055154> : 11 01                      dup.x64 sp(1)
	<.main+9162 @055156> : 1a                         load.z64
	<.main+9163 @055157> : 88                         clt.f64
	<.main+9164 @055158> : 52                         sub.i32
	<.main+9165 @055159> : 13 02                      set.x32 sp(2)
	<.main+9167 @05515b> : 09 fc ff ff                inc.sp(-4)
	<.main+9171 @05515f> : 5d                         i32.2f64
	<.main+9172 @055160> : 2d 68 2b 05                store.m64 <@052b68> ;testMathSign_1F
	test/stdc/test.math.ci:11: (21 bytes: <@055164> - <@055179>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9176 @055164> : 1a                         load.z64
	<.main+9177 @055165> : 11 00                      dup.x64 sp(0)
	<.main+9179 @055167> : 1a                         load.z64
	<.main+9180 @055168> : 89                         cgt.f64
	<.main+9181 @055169> : 11 01                      dup.x64 sp(1)
	<.main+9183 @05516b> : 1a                         load.z64
	<.main+9184 @05516c> : 88                         clt.f64
	<.main+9185 @05516d> : 52                         sub.i32
	<.main+9186 @05516e> : 13 02                      set.x32 sp(2)
	<.main+9188 @055170> : 09 fc ff ff                inc.sp(-4)
	<.main+9192 @055174> : 5d                         i32.2f64
	<.main+9193 @055175> : 2d 70 2b 05                store.m64 <@052b70> ;testMathSign_2F
	test/stdc/test.math.ci:12: (29 bytes: <@055179> - <@055196>): static testMathSign_3F: float64 := Math.sign(float64(-0.900000))
	<.main+9197 @055179> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9206 @055182> : 11 00                      dup.x64 sp(0)
	<.main+9208 @055184> : 1a                         load.z64
	<.main+9209 @055185> : 89                         cgt.f64
	<.main+9210 @055186> : 11 01                      dup.x64 sp(1)
	<.main+9212 @055188> : 1a                         load.z64
	<.main+9213 @055189> : 88                         clt.f64
	<.main+9214 @05518a> : 52                         sub.i32
	<.main+9215 @05518b> : 13 02                      set.x32 sp(2)
	<.main+9217 @05518d> : 09 fc ff ff                inc.sp(-4)
	<.main+9221 @055191> : 5d                         i32.2f64
	<.main+9222 @055192> : 2d 78 2b 05                store.m64 <@052b78> ;testMathSign_3F
	test/stdc/test.math.ci:13: (21 bytes: <@055196> - <@0551ab>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9226 @055196> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9231 @05519b> : 10 00                      dup.x32 sp(0)
	<.main+9233 @05519d> : 19                         load.z32
	<.main+9234 @05519e> : 79                         cgt.f32
	<.main+9235 @05519f> : 10 01                      dup.x32 sp(1)
	<.main+9237 @0551a1> : 19                         load.z32
	<.main+9238 @0551a2> : 78                         clt.f32
	<.main+9239 @0551a3> : 52                         sub.i32
	<.main+9240 @0551a4> : 13 01                      set.x32 sp(1)
	<.main+9242 @0551a6> : 5d                         i32.2f64
	<.main+9243 @0551a7> : 2d 80 2b 05                store.m64 <@052b80> ;testMathSign_1f
	test/stdc/test.math.ci:14: (17 bytes: <@0551ab> - <@0551bc>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9247 @0551ab> : 19                         load.z32
	<.main+9248 @0551ac> : 10 00                      dup.x32 sp(0)
	<.main+9250 @0551ae> : 19                         load.z32
	<.main+9251 @0551af> : 79                         cgt.f32
	<.main+9252 @0551b0> : 10 01                      dup.x32 sp(1)
	<.main+9254 @0551b2> : 19                         load.z32
	<.main+9255 @0551b3> : 78                         clt.f32
	<.main+9256 @0551b4> : 52                         sub.i32
	<.main+9257 @0551b5> : 13 01                      set.x32 sp(1)
	<.main+9259 @0551b7> : 5d                         i32.2f64
	<.main+9260 @0551b8> : 2d 88 2b 05                store.m64 <@052b88> ;testMathSign_2f
	test/stdc/test.math.ci:15: (21 bytes: <@0551bc> - <@0551d1>): static testMathSign_3f: float64 := Math.sign(float32(-0.900000))
	<.main+9264 @0551bc> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9269 @0551c1> : 10 00                      dup.x32 sp(0)
	<.main+9271 @0551c3> : 19                         load.z32
	<.main+9272 @0551c4> : 79                         cgt.f32
	<.main+9273 @0551c5> : 10 01                      dup.x32 sp(1)
	<.main+9275 @0551c7> : 19                         load.z32
	<.main+9276 @0551c8> : 78                         clt.f32
	<.main+9277 @0551c9> : 52                         sub.i32
	<.main+9278 @0551ca> : 13 01                      set.x32 sp(1)
	<.main+9280 @0551cc> : 5d                         i32.2f64
	<.main+9281 @0551cd> : 2d 90 2b 05                store.m64 <@052b90> ;testMathSign_3f
	test/stdc/test.math.ci:17: (24 bytes: <@0551d1> - <@0551e9>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9285 @0551d1> : 1a                         load.z64
	<.main+9286 @0551d2> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9295 @0551db> : 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<.main+9300 @0551e0> : 02                         call
	<.main+9301 @0551e1> : 09 f8 ff ff                inc.sp(-8)
	<.main+9305 @0551e5> : 2d 98 2b 05                store.m64 <@052b98> ;testMathAbs_1F
	test/stdc/test.math.ci:18: (15 bytes: <@0551e9> - <@0551f8>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9309 @0551e9> : 1b                         load.z128
	<.main+9310 @0551ea> : 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<.main+9315 @0551ef> : 02                         call
	<.main+9316 @0551f0> : 09 f8 ff ff                inc.sp(-8)
	<.main+9320 @0551f4> : 2d a0 2b 05                store.m64 <@052ba0> ;testMathAbs_2F
	test/stdc/test.math.ci:19: (24 bytes: <@0551f8> - <@055210>): static testMathAbs_3F: float64 := Math.abs(float64(-0.900000))
	<.main+9324 @0551f8> : 1a                         load.z64
	<.main+9325 @0551f9> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9334 @055202> : 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<.main+9339 @055207> : 02                         call
	<.main+9340 @055208> : 09 f8 ff ff                inc.sp(-8)
	<.main+9344 @05520c> : 2d a8 2b 05                store.m64 <@052ba8> ;testMathAbs_3F
	test/stdc/test.math.ci:20: (21 bytes: <@055210> - <@055225>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9348 @055210> : 19                         load.z32
	<.main+9349 @055211> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9354 @055216> : 1f 18 08 05 00             load.ref <@050818> ;Math.abs(x: float32): float32
	<.main+9359 @05521b> : 02                         call
	<.main+9360 @05521c> : 09 fc ff ff                inc.sp(-4)
	<.main+9364 @055220> : 7d                         f32.2f64
	<.main+9365 @055221> : 2d b0 2b 05                store.m64 <@052bb0> ;testMathAbs_1f
	test/stdc/test.math.ci:21: (17 bytes: <@055225> - <@055236>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9369 @055225> : 19                         load.z32
	<.main+9370 @055226> : 19                         load.z32
	<.main+9371 @055227> : 1f 18 08 05 00             load.ref <@050818> ;Math.abs(x: float32): float32
	<.main+9376 @05522c> : 02                         call
	<.main+9377 @05522d> : 09 fc ff ff                inc.sp(-4)
	<.main+9381 @055231> : 7d                         f32.2f64
	<.main+9382 @055232> : 2d b8 2b 05                store.m64 <@052bb8> ;testMathAbs_2f
	test/stdc/test.math.ci:22: (21 bytes: <@055236> - <@05524b>): static testMathAbs_3f: float64 := Math.abs(float32(-0.900000))
	<.main+9386 @055236> : 19                         load.z32
	<.main+9387 @055237> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9392 @05523c> : 1f 18 08 05 00             load.ref <@050818> ;Math.abs(x: float32): float32
	<.main+9397 @055241> : 02                         call
	<.main+9398 @055242> : 09 fc ff ff                inc.sp(-4)
	<.main+9402 @055246> : 7d                         f32.2f64
	<.main+9403 @055247> : 2d c0 2b 05                store.m64 <@052bc0> ;testMathAbs_3f
	test/stdc/test.math.ci:24: (26 bytes: <@05524b> - <@055265>): static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9407 @05524b> : 19                         load.z32
	<.main+9408 @05524c> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9413 @055251> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9418 @055256> : 1f 88 08 05 00             load.ref <@050888> ;Math.min(a: float32, b: float32): float32
	<.main+9423 @05525b> : 02                         call
	<.main+9424 @05525c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9428 @055260> : 7d                         f32.2f64
	<.main+9429 @055261> : 2d c8 2b 05                store.m64 <@052bc8> ;testMathMin_1f
	test/stdc/test.math.ci:25: (26 bytes: <@055265> - <@05527f>): static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9433 @055265> : 19                         load.z32
	<.main+9434 @055266> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9439 @05526b> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9444 @055270> : 1f b8 08 05 00             load.ref <@0508b8> ;Math.max(a: float32, b: float32): float32
	<.main+9449 @055275> : 02                         call
	<.main+9450 @055276> : 09 f8 ff ff                inc.sp(-8)
	<.main+9454 @05527a> : 7d                         f32.2f64
	<.main+9455 @05527b> : 2d d0 2b 05                store.m64 <@052bd0> ;testMathMax_2f
	test/stdc/test.math.ci:26: (33 bytes: <@05527f> - <@0552a0>): static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000))
	<.main+9459 @05527f> : 1a                         load.z64
	<.main+9460 @055280> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9469 @055289> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9478 @055292> : 1f a0 08 05 00             load.ref <@0508a0> ;Math.min(a: float64, b: float64): float64
	<.main+9483 @055297> : 02                         call
	<.main+9484 @055298> : 09 f0 ff ff                inc.sp(-16)
	<.main+9488 @05529c> : 2d d8 2b 05                store.m64 <@052bd8> ;testMathMin_1F
	test/stdc/test.math.ci:27: (33 bytes: <@0552a0> - <@0552c1>): static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000))
	<.main+9492 @0552a0> : 1a                         load.z64
	<.main+9493 @0552a1> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9502 @0552aa> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9511 @0552b3> : 1f d0 08 05 00             load.ref <@0508d0> ;Math.max(a: float64, b: float64): float64
	<.main+9516 @0552b8> : 02                         call
	<.main+9517 @0552b9> : 09 f0 ff ff                inc.sp(-16)
	<.main+9521 @0552bd> : 2d e0 2b 05                store.m64 <@052be0> ;testMathMax_2F
	test/stdc/test.math.ci:29: (27 bytes: <@0552c1> - <@0552dc>): static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9525 @0552c1> : 19                         load.z32
	<.main+9526 @0552c2> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9531 @0552c7> : 19                         load.z32
	<.main+9532 @0552c8> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9537 @0552cd> : 1f e8 08 05 00             load.ref <@0508e8> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9542 @0552d2> : 02                         call
	<.main+9543 @0552d3> : 09 f4 ff ff                inc.sp(-12)
	<.main+9547 @0552d7> : 7d                         f32.2f64
	<.main+9548 @0552d8> : 2d e8 2b 05                store.m64 <@052be8> ;testMathClamp_1f
	test/stdc/test.math.ci:30: (34 bytes: <@0552dc> - <@0552fe>): static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000))
	<.main+9552 @0552dc> : 1a                         load.z64
	<.main+9553 @0552dd> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9562 @0552e6> : 1a                         load.z64
	<.main+9563 @0552e7> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9572 @0552f0> : 1f 08 09 05 00             load.ref <@050908> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9577 @0552f5> : 02                         call
	<.main+9578 @0552f6> : 09 e8 ff ff                inc.sp(-24)
	<.main+9582 @0552fa> : 2d f0 2b 05                store.m64 <@052bf0> ;testMathClamp_1F
	test/stdc/test.math.ci:32: (25 bytes: <@0552fe> - <@055317>): static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9586 @0552fe> : 19                         load.z32
	<.main+9587 @0552ff> : 10 00                      dup.x32 sp(0)
	<.main+9589 @055301> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9594 @055306> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9599 @05530b> : 10 03                      dup.x32 sp(3)
	<.main+9601 @05530d> : 72                         sub.f32
	<.main+9602 @05530e> : 73                         mul.f32
	<.main+9603 @05530f> : 71                         add.f32
	<.main+9604 @055310> : 13 01                      set.x32 sp(1)
	<.main+9606 @055312> : 7d                         f32.2f64
	<.main+9607 @055313> : 2d f8 2b 05                store.m64 <@052bf8> ;testMathLerp_1f
	test/stdc/test.math.ci:33: (32 bytes: <@055317> - <@055337>): static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000))
	<.main+9611 @055317> : 1a                         load.z64
	<.main+9612 @055318> : 11 00                      dup.x64 sp(0)
	<.main+9614 @05531a> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9623 @055323> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9632 @05532c> : 11 06                      dup.x64 sp(6)
	<.main+9634 @05532e> : 82                         sub.f64
	<.main+9635 @05532f> : 83                         mul.f64
	<.main+9636 @055330> : 81                         add.f64
	<.main+9637 @055331> : 14 02                      set.x64 sp(2)
	<.main+9639 @055333> : 2d 00 2c 05                store.m64 <@052c00> ;testMathLerp_1F
	test/stdc/test.math.ci:35: (64 bytes: <@055337> - <@055377>): static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9643 @055337> : 19                         load.z32
	<.main+9644 @055338> : 19                         load.z32
	<.main+9645 @055339> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9650 @05533e> : 10 02                      dup.x32 sp(2)
	<.main+9652 @055340> : 72                         sub.f32
	<.main+9653 @055341> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9658 @055346> : 10 03                      dup.x32 sp(3)
	<.main+9660 @055348> : 72                         sub.f32
	<.main+9661 @055349> : 74                         div.f32
	<.main+9662 @05534a> : 19                         load.z32
	<.main+9663 @05534b> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9668 @055350> : 1f e8 08 05 00             load.ref <@0508e8> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9673 @055355> : 02                         call
	<.main+9674 @055356> : 09 f4 ff ff                inc.sp(-12)
	<.main+9678 @05535a> : 10 00                      dup.x32 sp(0)
	<.main+9680 @05535c> : 10 01                      dup.x32 sp(1)
	<.main+9682 @05535e> : 73                         mul.f32
	<.main+9683 @05535f> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9688 @055364> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9693 @055369> : 10 03                      dup.x32 sp(3)
	<.main+9695 @05536b> : 73                         mul.f32
	<.main+9696 @05536c> : 72                         sub.f32
	<.main+9697 @05536d> : 73                         mul.f32
	<.main+9698 @05536e> : 13 01                      set.x32 sp(1)
	<.main+9700 @055370> : 13 01                      set.x32 sp(1)
	<.main+9702 @055372> : 7d                         f32.2f64
	<.main+9703 @055373> : 2d 08 2c 05                store.m64 <@052c08> ;testMathSmooth_1f
	test/stdc/test.math.ci:36: (82 bytes: <@055377> - <@0553c9>): static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000))
	<.main+9707 @055377> : 1b                         load.z128
	<.main+9708 @055378> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9717 @055381> : 11 04                      dup.x64 sp(4)
	<.main+9719 @055383> : 82                         sub.f64
	<.main+9720 @055384> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9729 @05538d> : 11 06                      dup.x64 sp(6)
	<.main+9731 @05538f> : 82                         sub.f64
	<.main+9732 @055390> : 84                         div.f64
	<.main+9733 @055391> : 1a                         load.z64
	<.main+9734 @055392> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9743 @05539b> : 1f 08 09 05 00             load.ref <@050908> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9748 @0553a0> : 02                         call
	<.main+9749 @0553a1> : 09 e8 ff ff                inc.sp(-24)
	<.main+9753 @0553a5> : 11 00                      dup.x64 sp(0)
	<.main+9755 @0553a7> : 11 02                      dup.x64 sp(2)
	<.main+9757 @0553a9> : 83                         mul.f64
	<.main+9758 @0553aa> : 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+9767 @0553b3> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9776 @0553bc> : 11 06                      dup.x64 sp(6)
	<.main+9778 @0553be> : 83                         mul.f64
	<.main+9779 @0553bf> : 82                         sub.f64
	<.main+9780 @0553c0> : 83                         mul.f64
	<.main+9781 @0553c1> : 14 02                      set.x64 sp(2)
	<.main+9783 @0553c3> : 14 02                      set.x64 sp(2)
	<.main+9785 @0553c5> : 2d 10 2c 05                store.m64 <@052c10> ;testMathSmooth_1F
	test/stdc/test.math.ci:38: (25 bytes: <@0553c9> - <@0553e2>): static testMathMin_nan: float64 := Math.min()
	<.main+9789 @0553c9> : 19                         load.z32
	<.main+9790 @0553ca> : 0a 04 00 00                load.sp(+4)
	<.main+9794 @0553ce> : 1a                         load.z64
	<.main+9795 @0553cf> : 11 02                      dup.x64 sp(2)
	<.main+9797 @0553d1> : 1f 28 09 05 00             load.ref <@050928> ;Math.min(data: float64[]): float64
	<.main+9802 @0553d6> : 02                         call
	<.main+9803 @0553d7> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9806 @0553da> : 09 f0 ff ff                inc.sp(-16)
	<.main+9810 @0553de> : 2d 18 2c 05                store.m64 <@052c18> ;testMathMin_nan
	test/stdc/test.math.ci:39: (110 bytes: <@0553e2> - <@055450>): static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9814 @0553e2> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9823 @0553eb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9832 @0553f4> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9841 @0553fd> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9850 @055406> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9859 @05540f> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+9868 @055418> : 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+9877 @055421> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9886 @05542a> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9895 @055433> : 1c 09 00 00 00             load.c32 9
	<.main+9900 @055438> : 0a 04 00 00                load.sp(+4)
	<.main+9904 @05543c> : 1a                         load.z64
	<.main+9905 @05543d> : 11 02                      dup.x64 sp(2)
	<.main+9907 @05543f> : 1f 28 09 05 00             load.ref <@050928> ;Math.min(data: float64[]): float64
	<.main+9912 @055444> : 02                         call
	<.main+9913 @055445> : 17 16 02                   mov.x64 sp(22, 2)
	<.main+9916 @055448> : 09 a8 ff ff                inc.sp(-88)
	<.main+9920 @05544c> : 2d 20 2c 05                store.m64 <@052c20> ;testMathMin_1
	test/stdc/test.math.ci:40: (25 bytes: <@055450> - <@055469>): static testMathMax_nan: float64 := Math.max()
	<.main+9924 @055450> : 19                         load.z32
	<.main+9925 @055451> : 0a 04 00 00                load.sp(+4)
	<.main+9929 @055455> : 1a                         load.z64
	<.main+9930 @055456> : 11 02                      dup.x64 sp(2)
	<.main+9932 @055458> : 1f 78 09 05 00             load.ref <@050978> ;Math.max(data: float64[]): float64
	<.main+9937 @05545d> : 02                         call
	<.main+9938 @05545e> : 17 04 02                   mov.x64 sp(4, 2)
	<.main+9941 @055461> : 09 f0 ff ff                inc.sp(-16)
	<.main+9945 @055465> : 2d 28 2c 05                store.m64 <@052c28> ;testMathMax_nan
	test/stdc/test.math.ci:41: (110 bytes: <@055469> - <@0554d7>): static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
	<.main+9949 @055469> : 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+9958 @055472> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9967 @05547b> : 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+9976 @055484> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9985 @05548d> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9994 @055496> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10003 @05549f>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10012 @0554a8>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10021 @0554b1>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10030 @0554ba>: 1c 09 00 00 00             load.c32 9
	<.main+10035 @0554bf>: 0a 04 00 00                load.sp(+4)
	<.main+10039 @0554c3>: 1a                         load.z64
	<.main+10040 @0554c4>: 11 02                      dup.x64 sp(2)
	<.main+10042 @0554c6>: 1f 78 09 05 00             load.ref <@050978> ;Math.max(data: float64[]): float64
	<.main+10047 @0554cb>: 02                         call
	<.main+10048 @0554cc>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10051 @0554cf>: 09 a8 ff ff                inc.sp(-88)
	<.main+10055 @0554d3>: 2d 30 2c 05                store.m64 <@052c30> ;testMathMax_9
	test/stdc/test.math.ci:43: (25 bytes: <@0554d7> - <@0554f0>): static testMathSum_0: float64 := Math.sum()
	<.main+10059 @0554d7>: 19                         load.z32
	<.main+10060 @0554d8>: 0a 04 00 00                load.sp(+4)
	<.main+10064 @0554dc>: 1a                         load.z64
	<.main+10065 @0554dd>: 11 02                      dup.x64 sp(2)
	<.main+10067 @0554df>: 1f c8 09 05 00             load.ref <@0509c8> ;Math.sum(data: float64[]): float64
	<.main+10072 @0554e4>: 02                         call
	<.main+10073 @0554e5>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10076 @0554e8>: 09 f0 ff ff                inc.sp(-16)
	<.main+10080 @0554ec>: 2d 38 2c 05                store.m64 <@052c38> ;testMathSum_0
	test/stdc/test.math.ci:44: (38 bytes: <@0554f0> - <@055516>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10084 @0554f0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10093 @0554f9>: 1c 01 00 00 00             load.c32 1
	<.main+10098 @0554fe>: 0a 04 00 00                load.sp(+4)
	<.main+10102 @055502>: 1a                         load.z64
	<.main+10103 @055503>: 11 02                      dup.x64 sp(2)
	<.main+10105 @055505>: 1f c8 09 05 00             load.ref <@0509c8> ;Math.sum(data: float64[]): float64
	<.main+10110 @05550a>: 02                         call
	<.main+10111 @05550b>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10114 @05550e>: 09 e8 ff ff                inc.sp(-24)
	<.main+10118 @055512>: 2d 40 2c 05                store.m64 <@052c40> ;testMathSum_1
	test/stdc/test.math.ci:45: (47 bytes: <@055516> - <@055545>): static testMathSum_3: float64 := Math.sum(void(1, 2))
	<.main+10122 @055516>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10131 @05551f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10140 @055528>: 1c 02 00 00 00             load.c32 2
	<.main+10145 @05552d>: 0a 04 00 00                load.sp(+4)
	<.main+10149 @055531>: 1a                         load.z64
	<.main+10150 @055532>: 11 02                      dup.x64 sp(2)
	<.main+10152 @055534>: 1f c8 09 05 00             load.ref <@0509c8> ;Math.sum(data: float64[]): float64
	<.main+10157 @055539>: 02                         call
	<.main+10158 @05553a>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10161 @05553d>: 09 e0 ff ff                inc.sp(-32)
	<.main+10165 @055541>: 2d 48 2c 05                store.m64 <@052c48> ;testMathSum_3
	test/stdc/test.math.ci:46: (119 bytes: <@055545> - <@0555bc>): static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
	<.main+10169 @055545>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10178 @05554e>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10187 @055557>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10196 @055560>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10205 @055569>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10214 @055572>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10223 @05557b>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10232 @055584>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10241 @05558d>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10250 @055596>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10259 @05559f>: 1c 0a 00 00 00             load.c32 10
	<.main+10264 @0555a4>: 0a 04 00 00                load.sp(+4)
	<.main+10268 @0555a8>: 1a                         load.z64
	<.main+10269 @0555a9>: 11 02                      dup.x64 sp(2)
	<.main+10271 @0555ab>: 1f c8 09 05 00             load.ref <@0509c8> ;Math.sum(data: float64[]): float64
	<.main+10276 @0555b0>: 02                         call
	<.main+10277 @0555b1>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10280 @0555b4>: 09 a0 ff ff                inc.sp(-96)
	<.main+10284 @0555b8>: 2d 50 2c 05                store.m64 <@052c50> ;testMathSum_55
	test/stdc/test.math.ci:48: (13 bytes: <@0555bc> - <@0555c9>): static testMathEval_x: float64 := 10
	<.main+10288 @0555bc>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10297 @0555c5>: 2d 58 2c 05                store.m64 <@052c58> ;testMathEval_x
	test/stdc/test.math.ci:49: (29 bytes: <@0555c9> - <@0555e6>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10301 @0555c9>: 19                         load.z32
	<.main+10302 @0555ca>: 0a 04 00 00                load.sp(+4)
	<.main+10306 @0555ce>: 1a                         load.z64
	<.main+10307 @0555cf>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10311 @0555d3>: 11 04                      dup.x64 sp(4)
	<.main+10313 @0555d5>: 1f f0 09 05 00             load.ref <@0509f0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10318 @0555da>: 02                         call
	<.main+10319 @0555db>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10322 @0555de>: 09 e8 ff ff                inc.sp(-24)
	<.main+10326 @0555e2>: 2d 60 2c 05                store.m64 <@052c60> ;testMathEval_0
	test/stdc/test.math.ci:50: (13 bytes: <@0555e6> - <@0555f3>): static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000))
	<.main+10330 @0555e6>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10339 @0555ef>: 2d 68 2c 05                store.m64 <@052c68> ;testMathEval_1
	test/stdc/test.math.ci:51: (28 bytes: <@0555f3> - <@05560f>): static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
	<.main+10343 @0555f3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10352 @0555fc>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10356 @055600>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10365 @055609>: 83                         mul.f64
	<.main+10366 @05560a>: 81                         add.f64
	<.main+10367 @05560b>: 2d 70 2c 05                store.m64 <@052c70> ;testMathEval_2
	test/stdc/test.math.ci:52: (45 bytes: <@05560f> - <@05563c>): static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
	<.main+10371 @05560f>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10375 @055613>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10384 @05561c>: 11 02                      dup.x64 sp(2)
	<.main+10386 @05561e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10395 @055627>: 11 06                      dup.x64 sp(6)
	<.main+10397 @055629>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10406 @055632>: 83                         mul.f64
	<.main+10407 @055633>: 81                         add.f64
	<.main+10408 @055634>: 83                         mul.f64
	<.main+10409 @055635>: 81                         add.f64
	<.main+10410 @055636>: 14 02                      set.x64 sp(2)
	<.main+10412 @055638>: 2d 78 2c 05                store.m64 <@052c78> ;testMathEval_3
	test/stdc/test.math.ci:53: (62 bytes: <@05563c> - <@05567a>): static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10416 @05563c>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10420 @055640>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10429 @055649>: 11 02                      dup.x64 sp(2)
	<.main+10431 @05564b>: 11 04                      dup.x64 sp(4)
	<.main+10433 @05564d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10442 @055656>: 11 02                      dup.x64 sp(2)
	<.main+10444 @055658>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10453 @055661>: 11 06                      dup.x64 sp(6)
	<.main+10455 @055663>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10464 @05566c>: 83                         mul.f64
	<.main+10465 @05566d>: 81                         add.f64
	<.main+10466 @05566e>: 83                         mul.f64
	<.main+10467 @05566f>: 81                         add.f64
	<.main+10468 @055670>: 14 02                      set.x64 sp(2)
	<.main+10470 @055672>: 83                         mul.f64
	<.main+10471 @055673>: 81                         add.f64
	<.main+10472 @055674>: 14 02                      set.x64 sp(2)
	<.main+10474 @055676>: 2d 80 2c 05                store.m64 <@052c80> ;testMathEval_4
	test/stdc/test.math.ci:54: (78 bytes: <@05567a> - <@0556c8>): static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10478 @05567a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10487 @055683>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10496 @05568c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10505 @055695>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10514 @05569e>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10523 @0556a7>: 1c 05 00 00 00             load.c32 5
	<.main+10528 @0556ac>: 0a 04 00 00                load.sp(+4)
	<.main+10532 @0556b0>: 1a                         load.z64
	<.main+10533 @0556b1>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10537 @0556b5>: 11 04                      dup.x64 sp(4)
	<.main+10539 @0556b7>: 1f f0 09 05 00             load.ref <@0509f0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10544 @0556bc>: 02                         call
	<.main+10545 @0556bd>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10548 @0556c0>: 09 c0 ff ff                inc.sp(-64)
	<.main+10552 @0556c4>: 2d 88 2c 05                store.m64 <@052c88> ;testMathEval_5
	test/stdc/test.math.ci:55: (87 bytes: <@0556c8> - <@05571f>): static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
	<.main+10556 @0556c8>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10565 @0556d1>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10574 @0556da>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10583 @0556e3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10592 @0556ec>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10601 @0556f5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10610 @0556fe>: 1c 06 00 00 00             load.c32 6
	<.main+10615 @055703>: 0a 04 00 00                load.sp(+4)
	<.main+10619 @055707>: 1a                         load.z64
	<.main+10620 @055708>: 2b 58 2c 05                load.m64 <@052c58> ;testMathEval_x
	<.main+10624 @05570c>: 11 04                      dup.x64 sp(4)
	<.main+10626 @05570e>: 1f f0 09 05 00             load.ref <@0509f0> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10631 @055713>: 02                         call
	<.main+10632 @055714>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10635 @055717>: 09 b8 ff ff                inc.sp(-72)
	<.main+10639 @05571b>: 2d 90 2c 05                store.m64 <@052c90> ;testMathEval_6
	test/stdc/test.math.ci:57: (35 bytes: <@05571f> - <@055742>): static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)))
	<.main+10643 @05571f>: 1a                         load.z64
	<.main+10644 @055720>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10653 @055729>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10662 @055732>: 84                         div.f64
	<.main+10663 @055733>: 19                         load.z32
	<.main+10664 @055734>: 1f a0 0a 05 00             load.ref <@050aa0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10669 @055739>: 02                         call
	<.main+10670 @05573a>: 09 f4 ff ff                inc.sp(-12)
	<.main+10674 @05573e>: 2d 98 2c 05                store.m64 <@052c98> ;testMathSin_f64
	test/stdc/test.math.ci:58: (49 bytes: <@055742> - <@055773>): static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)))
	<.main+10678 @055742>: 1b                         load.z128
	<.main+10679 @055743>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10688 @05574c>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10697 @055755>: 84                         div.f64
	<.main+10698 @055756>: 1f 30 08 05 00             load.ref <@050830> ;Math.abs(x: float64): float64
	<.main+10703 @05575b>: 02                         call
	<.main+10704 @05575c>: 09 f8 ff ff                inc.sp(-8)
	<.main+10708 @055760>: 1c 01 00 00 00             load.c32 1
	<.main+10713 @055765>: 1f a0 0a 05 00             load.ref <@050aa0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10718 @05576a>: 02                         call
	<.main+10719 @05576b>: 09 f4 ff ff                inc.sp(-12)
	<.main+10723 @05576f>: 2d a0 2c 05                store.m64 <@052ca0> ;testMathCos_f64
	test/stdc/test.math.ci:59: (34 bytes: <@055773> - <@055795>): static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)))
	<.main+10727 @055773>: 1a                         load.z64
	<.main+10728 @055774>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10737 @05577d>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10746 @055786>: 84                         div.f64
	<.main+10747 @055787>: 1f f0 0b 05 00             load.ref <@050bf0> ;Math.tan(arg: float64): float64
	<.main+10752 @05578c>: 02                         call
	<.main+10753 @05578d>: 09 f8 ff ff                inc.sp(-8)
	<.main+10757 @055791>: 2d a8 2c 05                store.m64 <@052ca8> ;testMathTan_f64
	test/stdc/test.math.ci:60: (34 bytes: <@055795> - <@0557b7>): static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)))
	<.main+10761 @055795>: 1a                         load.z64
	<.main+10762 @055796>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10771 @05579f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10780 @0557a8>: 84                         div.f64
	<.main+10781 @0557a9>: 1f 70 0d 05 00             load.ref <@050d70> ;Math.sinh(x: float64): float64
	<.main+10786 @0557ae>: 02                         call
	<.main+10787 @0557af>: 09 f8 ff ff                inc.sp(-8)
	<.main+10791 @0557b3>: 2d b0 2c 05                store.m64 <@052cb0> ;testMathSinh_f64
	test/stdc/test.math.ci:61: (34 bytes: <@0557b7> - <@0557d9>): static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)))
	<.main+10795 @0557b7>: 1a                         load.z64
	<.main+10796 @0557b8>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10805 @0557c1>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10814 @0557ca>: 84                         div.f64
	<.main+10815 @0557cb>: 1f 68 0e 05 00             load.ref <@050e68> ;Math.cosh(x: float64): float64
	<.main+10820 @0557d0>: 02                         call
	<.main+10821 @0557d1>: 09 f8 ff ff                inc.sp(-8)
	<.main+10825 @0557d5>: 2d b8 2c 05                store.m64 <@052cb8> ;testMathCosh_f64
	test/stdc/test.math.ci:63: (24 bytes: <@0557d9> - <@0557f1>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+10829 @0557d9>: 1a                         load.z64
	<.main+10830 @0557da>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10839 @0557e3>: 1f b8 0e 05 00             load.ref <@050eb8> ;Math.asin(x: float64): float64
	<.main+10844 @0557e8>: 02                         call
	<.main+10845 @0557e9>: 09 f8 ff ff                inc.sp(-8)
	<.main+10849 @0557ed>: 2d c0 2c 05                store.m64 <@052cc0> ;testMathAsin_f64
	test/stdc/test.math.ci:64: (44 bytes: <@0557f1> - <@05581d>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+10853 @0557f1>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10862 @0557fa>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10871 @055803>: 84                         div.f64
	<.main+10872 @055804>: 1a                         load.z64
	<.main+10873 @055805>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+10882 @05580e>: 1f b8 0e 05 00             load.ref <@050eb8> ;Math.asin(x: float64): float64
	<.main+10887 @055813>: 02                         call
	<.main+10888 @055814>: 09 f8 ff ff                inc.sp(-8)
	<.main+10892 @055818>: 82                         sub.f64
	<.main+10893 @055819>: 2d c8 2c 05                store.m64 <@052cc8> ;testMathAcos_f64
	test/stdc/test.math.ci:67: (34 bytes: <@05581d> - <@05583f>): static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10897 @05581d>: 19                         load.z32
	<.main+10898 @05581e>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10903 @055823>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+10908 @055828>: 7f ac c5 27 37             load.f32 0.000010
	<.main+10913 @05582d>: 1f 20 0a 05 00             load.ref <@050a20> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+10918 @055832>: 02                         call
	<.main+10919 @055833>: 09 f4 ff ff                inc.sp(-12)
	<.main+10923 @055837>: 19                         load.z32
	<.main+10924 @055838>: 57                         ceq.i32
	<.main+10925 @055839>: 1f d0 2c 05 00             load.ref <@052cd0> ;testMathCmp_f32
	<.main+10930 @05583e>: 25                         store.i8
	test/stdc/test.math.ci:68: (46 bytes: <@05583f> - <@05586d>): static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
	<.main+10931 @05583f>: 19                         load.z32
	<.main+10932 @055840>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10941 @055849>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+10950 @055852>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+10959 @05585b>: 1f 60 0a 05 00             load.ref <@050a60> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+10964 @055860>: 02                         call
	<.main+10965 @055861>: 09 e8 ff ff                inc.sp(-24)
	<.main+10969 @055865>: 19                         load.z32
	<.main+10970 @055866>: 57                         ceq.i32
	<.main+10971 @055867>: 1f d8 2c 05 00             load.ref <@052cd8> ;testMathCmp_f64
	<.main+10976 @05586c>: 25                         store.i8
	test/stdc/test.math.ci:70: (33 bytes: <@05586d> - <@05588e>): static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000))
	<.main+10977 @05586d>: 1a                         load.z64
	<.main+10978 @05586e>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10987 @055877>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10996 @055880>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11001 @055885>: 02                         call
	<.main+11002 @055886>: 09 f0 ff ff                inc.sp(-16)
	<.main+11006 @05588a>: 2d e0 2c 05                store.m64 <@052ce0> ;testMathAbsMod_f64_0a
	test/stdc/test.math.ci:71: (24 bytes: <@05588e> - <@0558a6>): static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000))
	<.main+11010 @05588e>: 1b                         load.z128
	<.main+11011 @05588f>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11020 @055898>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11025 @05589d>: 02                         call
	<.main+11026 @05589e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11030 @0558a2>: 2d e8 2c 05                store.m64 <@052ce8> ;testMathAbsMod_f64_0b
	test/stdc/test.math.ci:72: (33 bytes: <@0558a6> - <@0558c7>): static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000))
	<.main+11034 @0558a6>: 1a                         load.z64
	<.main+11035 @0558a7>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11044 @0558b0>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11053 @0558b9>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11058 @0558be>: 02                         call
	<.main+11059 @0558bf>: 09 f0 ff ff                inc.sp(-16)
	<.main+11063 @0558c3>: 2d f0 2c 05                store.m64 <@052cf0> ;testMathAbsMod_f64_0c
	test/stdc/test.math.ci:74: (33 bytes: <@0558c7> - <@0558e8>): static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000))
	<.main+11067 @0558c7>: 1a                         load.z64
	<.main+11068 @0558c8>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11077 @0558d1>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11086 @0558da>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11091 @0558df>: 02                         call
	<.main+11092 @0558e0>: 09 f0 ff ff                inc.sp(-16)
	<.main+11096 @0558e4>: 2d f8 2c 05                store.m64 <@052cf8> ;testMathAbsMod_f64_9a
	test/stdc/test.math.ci:75: (33 bytes: <@0558e8> - <@055909>): static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000))
	<.main+11100 @0558e8>: 1a                         load.z64
	<.main+11101 @0558e9>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11110 @0558f2>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11119 @0558fb>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11124 @055900>: 02                         call
	<.main+11125 @055901>: 09 f0 ff ff                inc.sp(-16)
	<.main+11129 @055905>: 2d 00 2d 05                store.m64 <@052d00> ;testMathAbsMod_f64_9b
	test/stdc/test.math.ci:76: (33 bytes: <@055909> - <@05592a>): static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000))
	<.main+11133 @055909>: 1a                         load.z64
	<.main+11134 @05590a>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11143 @055913>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11152 @05591c>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11157 @055921>: 02                         call
	<.main+11158 @055922>: 09 f0 ff ff                inc.sp(-16)
	<.main+11162 @055926>: 2d 08 2d 05                store.m64 <@052d08> ;testMathAbsMod_f64_9c
	test/stdc/test.math.ci:77: (33 bytes: <@05592a> - <@05594b>): static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000))
	<.main+11166 @05592a>: 1a                         load.z64
	<.main+11167 @05592b>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11176 @055934>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11185 @05593d>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11190 @055942>: 02                         call
	<.main+11191 @055943>: 09 f0 ff ff                inc.sp(-16)
	<.main+11195 @055947>: 2d 10 2d 05                store.m64 <@052d10> ;testMathAbsMod_f64_9d
	test/stdc/test.math.ci:79: (33 bytes: <@05594b> - <@05596c>): static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000))
	<.main+11199 @05594b>: 1a                         load.z64
	<.main+11200 @05594c>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11209 @055955>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11218 @05595e>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11223 @055963>: 02                         call
	<.main+11224 @055964>: 09 f0 ff ff                inc.sp(-16)
	<.main+11228 @055968>: 2d 18 2d 05                store.m64 <@052d18> ;testMathAbsMod_f64_8a
	test/stdc/test.math.ci:80: (33 bytes: <@05596c> - <@05598d>): static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000))
	<.main+11232 @05596c>: 1a                         load.z64
	<.main+11233 @05596d>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11242 @055976>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11251 @05597f>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11256 @055984>: 02                         call
	<.main+11257 @055985>: 09 f0 ff ff                inc.sp(-16)
	<.main+11261 @055989>: 2d 20 2d 05                store.m64 <@052d20> ;testMathAbsMod_f64_8b
	test/stdc/test.math.ci:81: (33 bytes: <@05598d> - <@0559ae>): static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000))
	<.main+11265 @05598d>: 1a                         load.z64
	<.main+11266 @05598e>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11275 @055997>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11284 @0559a0>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11289 @0559a5>: 02                         call
	<.main+11290 @0559a6>: 09 f0 ff ff                inc.sp(-16)
	<.main+11294 @0559aa>: 2d 28 2d 05                store.m64 <@052d28> ;testMathAbsMod_f64_8c
	test/stdc/test.math.ci:82: (33 bytes: <@0559ae> - <@0559cf>): static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000))
	<.main+11298 @0559ae>: 1a                         load.z64
	<.main+11299 @0559af>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11308 @0559b8>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11317 @0559c1>: 1f 68 08 05 00             load.ref <@050868> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11322 @0559c6>: 02                         call
	<.main+11323 @0559c7>: 09 f0 ff ff                inc.sp(-16)
	<.main+11327 @0559cb>: 2d 30 2d 05                store.m64 <@052d30> ;testMathAbsMod_f64_8d
	test/stdc/test.math.ci:84: (25 bytes: <@0559cf> - <@0559e8>): static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000))
	<.main+11331 @0559cf>: 19                         load.z32
	<.main+11332 @0559d0>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11337 @0559d5>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11342 @0559da>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11347 @0559df>: 02                         call
	<.main+11348 @0559e0>: 09 f8 ff ff                inc.sp(-8)
	<.main+11352 @0559e4>: 2e 38 2d 05                store.m32 <@052d38> ;testMathAbsMod_f32_0a
	test/stdc/test.math.ci:85: (21 bytes: <@0559e8> - <@0559fd>): static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000))
	<.main+11356 @0559e8>: 19                         load.z32
	<.main+11357 @0559e9>: 19                         load.z32
	<.main+11358 @0559ea>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11363 @0559ef>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11368 @0559f4>: 02                         call
	<.main+11369 @0559f5>: 09 f8 ff ff                inc.sp(-8)
	<.main+11373 @0559f9>: 2e 40 2d 05                store.m32 <@052d40> ;testMathAbsMod_f32_0b
	test/stdc/test.math.ci:86: (25 bytes: <@0559fd> - <@055a16>): static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000))
	<.main+11377 @0559fd>: 19                         load.z32
	<.main+11378 @0559fe>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11383 @055a03>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11388 @055a08>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11393 @055a0d>: 02                         call
	<.main+11394 @055a0e>: 09 f8 ff ff                inc.sp(-8)
	<.main+11398 @055a12>: 2e 48 2d 05                store.m32 <@052d48> ;testMathAbsMod_f32_0c
	test/stdc/test.math.ci:88: (25 bytes: <@055a16> - <@055a2f>): static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000))
	<.main+11402 @055a16>: 19                         load.z32
	<.main+11403 @055a17>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11408 @055a1c>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11413 @055a21>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11418 @055a26>: 02                         call
	<.main+11419 @055a27>: 09 f8 ff ff                inc.sp(-8)
	<.main+11423 @055a2b>: 2e 50 2d 05                store.m32 <@052d50> ;testMathAbsMod_f32_9a
	test/stdc/test.math.ci:89: (25 bytes: <@055a2f> - <@055a48>): static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000))
	<.main+11427 @055a2f>: 19                         load.z32
	<.main+11428 @055a30>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11433 @055a35>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11438 @055a3a>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11443 @055a3f>: 02                         call
	<.main+11444 @055a40>: 09 f8 ff ff                inc.sp(-8)
	<.main+11448 @055a44>: 2e 58 2d 05                store.m32 <@052d58> ;testMathAbsMod_f32_9b
	test/stdc/test.math.ci:90: (25 bytes: <@055a48> - <@055a61>): static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000))
	<.main+11452 @055a48>: 19                         load.z32
	<.main+11453 @055a49>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11458 @055a4e>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11463 @055a53>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11468 @055a58>: 02                         call
	<.main+11469 @055a59>: 09 f8 ff ff                inc.sp(-8)
	<.main+11473 @055a5d>: 2e 60 2d 05                store.m32 <@052d60> ;testMathAbsMod_f32_9c
	test/stdc/test.math.ci:91: (25 bytes: <@055a61> - <@055a7a>): static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000))
	<.main+11477 @055a61>: 19                         load.z32
	<.main+11478 @055a62>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11483 @055a67>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11488 @055a6c>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11493 @055a71>: 02                         call
	<.main+11494 @055a72>: 09 f8 ff ff                inc.sp(-8)
	<.main+11498 @055a76>: 2e 68 2d 05                store.m32 <@052d68> ;testMathAbsMod_f32_9d
	test/stdc/test.math.ci:93: (25 bytes: <@055a7a> - <@055a93>): static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000))
	<.main+11502 @055a7a>: 19                         load.z32
	<.main+11503 @055a7b>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11508 @055a80>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11513 @055a85>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11518 @055a8a>: 02                         call
	<.main+11519 @055a8b>: 09 f8 ff ff                inc.sp(-8)
	<.main+11523 @055a8f>: 2e 70 2d 05                store.m32 <@052d70> ;testMathAbsMod_f32_8a
	test/stdc/test.math.ci:94: (25 bytes: <@055a93> - <@055aac>): static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000))
	<.main+11527 @055a93>: 19                         load.z32
	<.main+11528 @055a94>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11533 @055a99>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11538 @055a9e>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11543 @055aa3>: 02                         call
	<.main+11544 @055aa4>: 09 f8 ff ff                inc.sp(-8)
	<.main+11548 @055aa8>: 2e 78 2d 05                store.m32 <@052d78> ;testMathAbsMod_f32_8b
	test/stdc/test.math.ci:95: (25 bytes: <@055aac> - <@055ac5>): static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000))
	<.main+11552 @055aac>: 19                         load.z32
	<.main+11553 @055aad>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11558 @055ab2>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11563 @055ab7>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11568 @055abc>: 02                         call
	<.main+11569 @055abd>: 09 f8 ff ff                inc.sp(-8)
	<.main+11573 @055ac1>: 2e 80 2d 05                store.m32 <@052d80> ;testMathAbsMod_f32_8c
	test/stdc/test.math.ci:96: (25 bytes: <@055ac5> - <@055ade>): static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000))
	<.main+11577 @055ac5>: 19                         load.z32
	<.main+11578 @055ac6>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11583 @055acb>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11588 @055ad0>: 1f 48 08 05 00             load.ref <@050848> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11593 @055ad5>: 02                         call
	<.main+11594 @055ad6>: 09 f8 ff ff                inc.sp(-8)
	<.main+11598 @055ada>: 2e 88 2d 05                store.m32 <@052d88> ;testMathAbsMod_f32_8d
	test/stdc/memory.ci:13: (18 bytes: <@055ade> - <@055af0>): pointer.fill(void(void(p1, 0), 1024));
	<.main+11602 @055ade>: 2a f0 1f 05                load.m32 <@051ff0> ;p1
	<.main+11606 @055ae2>: 19                         load.z32
	<.main+11607 @055ae3>: 1c 00 04 00 00             load.c32 1024
	<.main+11612 @055ae8>: 01 0a 00 00                nfc(10) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11616 @055aec>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:14: (21 bytes: <@055af0> - <@055b05>): pointer.copy(void(void(p1, p3), 160));
	<.main+11620 @055af0>: 2a f0 1f 05                load.m32 <@051ff0> ;p1
	<.main+11624 @055af4>: 2a 00 20 05                load.m32 <@052000> ;p3
	<.main+11628 @055af8>: 1c a0 00 00 00             load.c32 160
	<.main+11633 @055afd>: 01 0b 00 00                nfc(11) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11637 @055b01>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:17: (13 bytes: <@055b05> - <@055b12>): free(p1);
	<.main+11641 @055b05>: 2a f0 1f 05                load.m32 <@051ff0> ;p1
	<.main+11645 @055b09>: 19                         load.z32
	<.main+11646 @055b0a>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11650 @055b0e>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:18: (13 bytes: <@055b12> - <@055b1f>): free(p2);
	<.main+11654 @055b12>: 2a f8 1f 05                load.m32 <@051ff8> ;p2
	<.main+11658 @055b16>: 19                         load.z32
	<.main+11659 @055b17>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11663 @055b1b>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:19: (13 bytes: <@055b1f> - <@055b2c>): free(p3);
	<.main+11667 @055b1f>: 2a 00 20 05                load.m32 <@052000> ;p3
	<.main+11671 @055b23>: 19                         load.z32
	<.main+11672 @055b24>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11676 @055b28>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:20: (13 bytes: <@055b2c> - <@055b39>): free(p4);
	<.main+11680 @055b2c>: 2a 08 20 05                load.m32 <@052008> ;p4
	<.main+11684 @055b30>: 19                         load.z32
	<.main+11685 @055b31>: 01 09 00 00                nfc(9) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11689 @055b35>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:26: (35 bytes: <@055b39> - <@055b5c>): debug(void("val1", val1));
	<.main+11693 @055b39>: 1f 98 a8 03 00             load.ref <@03a898> ;"test/stdc/memory.ci"
	<.main+11698 @055b3e>: 1c 1a 00 00 00             load.c32 26
	<.main+11703 @055b43>: 1c 0e 00 00 00             load.c32 14
	<.main+11708 @055b48>: 19                         load.z32
	<.main+11709 @055b49>: 1f c0 a8 03 00             load.ref <@03a8c0> ;"val1"
	<.main+11714 @055b4e>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11719 @055b53>: 1f 10 20 05 00             load.ref <@052010> ;val1
	<.main+11724 @055b58>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:27: (35 bytes: <@055b5c> - <@055b7f>): debug(void("val2", val2));
	<.main+11728 @055b5c>: 1f 98 a8 03 00             load.ref <@03a898> ;"test/stdc/memory.ci"
	<.main+11733 @055b61>: 1c 1b 00 00 00             load.c32 27
	<.main+11738 @055b66>: 1c 0e 00 00 00             load.c32 14
	<.main+11743 @055b6b>: 19                         load.z32
	<.main+11744 @055b6c>: 1f c5 a8 03 00             load.ref <@03a8c5> ;"val2"
	<.main+11749 @055b71>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11754 @055b76>: 1f 18 20 05 00             load.ref <@052018> ;val2
	<.main+11759 @055b7b>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:29: (22 bytes: <@055b7f> - <@055b95>): pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
	<.main+11763 @055b7f>: 1f 18 20 05 00             load.ref <@052018> ;val2
	<.main+11768 @055b84>: 1f 10 20 05 00             load.ref <@052010> ;val1
	<.main+11773 @055b89>: 2a 90 04 00                load.m32 <@000490>
	<.main+11777 @055b8d>: 01 0c 00 00                nfc(12) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+11781 @055b91>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:30: (18 bytes: <@055b95> - <@055ba7>): pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
	<.main+11785 @055b95>: 1f 10 20 05 00             load.ref <@052010> ;val1
	<.main+11790 @055b9a>: 19                         load.z32
	<.main+11791 @055b9b>: 2a 90 04 00                load.m32 <@000490>
	<.main+11795 @055b9f>: 01 0a 00 00                nfc(10) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+11799 @055ba3>: 09 fc ff ff                inc.sp(-4)
	test/stdc/memory.ci:32: (35 bytes: <@055ba7> - <@055bca>): debug(void("val1", val1));
	<.main+11803 @055ba7>: 1f 98 a8 03 00             load.ref <@03a898> ;"test/stdc/memory.ci"
	<.main+11808 @055bac>: 1c 20 00 00 00             load.c32 32
	<.main+11813 @055bb1>: 1c 0e 00 00 00             load.c32 14
	<.main+11818 @055bb6>: 19                         load.z32
	<.main+11819 @055bb7>: 1f c0 a8 03 00             load.ref <@03a8c0> ;"val1"
	<.main+11824 @055bbc>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11829 @055bc1>: 1f 10 20 05 00             load.ref <@052010> ;val1
	<.main+11834 @055bc6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc/memory.ci:33: (35 bytes: <@055bca> - <@055bed>): debug(void("val2", val2));
	<.main+11838 @055bca>: 1f 98 a8 03 00             load.ref <@03a898> ;"test/stdc/memory.ci"
	<.main+11843 @055bcf>: 1c 21 00 00 00             load.c32 33
	<.main+11848 @055bd4>: 1c 0e 00 00 00             load.c32 14
	<.main+11853 @055bd9>: 19                         load.z32
	<.main+11854 @055bda>: 1f c5 a8 03 00             load.ref <@03a8c5> ;"val2"
	<.main+11859 @055bdf>: 1f 70 04 00 00             load.ref <@000470> ;int64
	<.main+11864 @055be4>: 1f 18 20 05 00             load.ref <@052018> ;val2
	<.main+11869 @055be9>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:54: (46 bytes: <@055bed> - <@055c1b>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+11873 @055bed>: 19                         load.z32
	<.main+11874 @055bee>: 04 1d 00 00                jmp <.main+11903 @055c0b>
	test/lang/array.ci:55: (21 bytes: <@055bf2> - <@055c07>): int64(arrFixedNoInit[i] := (int32(42 + i)));
	<.main+11878 @055bf2>: 1c 2a 00 00 00             load.c32 42
	<.main+11883 @055bf7>: 10 01                      dup.x32 sp(1)
	<.main+11885 @055bf9>: 51                         add.i32
	<.main+11886 @055bfa>: 5b                         i32.2i64
	<.main+11887 @055bfb>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+11892 @055c00>: 10 03                      dup.x32 sp(3)
	<.main+11894 @055c02>: 0d 08 00 00                mad.u32 8
	<.main+11898 @055c06>: 28                         store.i64
	test/lang/array.ci:54: (4 bytes: <@055c07> - <@055c0b>): int32(i := int32(i + 1))
	<.main+11899 @055c07>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:54: (12 bytes: <@055c0b> - <@055c17>): bool(i < arrFixedNoInit.length)
	<.main+11903 @055c0b>: 10 00                      dup.x32 sp(0)
	<.main+11905 @055c0d>: 1c 07 00 00 00             load.c32 7
	<.main+11910 @055c12>: 58                         clt.i32
	<.main+11911 @055c13>: 05 df ff ff                jnz <.main+11878 @055bf2>
	<.main+11915 @055c17>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:82: (23 bytes: <@055c1b> - <@055c32>): pointer.copy(void(void(strFixed, pointer("string")), 7));
	<.main+11919 @055c1b>: 1f 68 21 05 00             load.ref <@052168> ;strFixed
	<.main+11924 @055c20>: 1f 54 b7 02 00             load.ref <@02b754> ;"string"
	<.main+11929 @055c25>: 1c 07 00 00 00             load.c32 7
	<.main+11934 @055c2a>: 01 0b 00 00                nfc(11) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11938 @055c2e>: 09 fc ff ff                inc.sp(-4)
	test/lang/array.ci:83: (35 bytes: <@055c32> - <@055c55>): debug(void("string as variant", strFixed));
	<.main+11942 @055c32>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+11947 @055c37>: 1c 53 00 00 00             load.c32 83
	<.main+11952 @055c3c>: 1c 0e 00 00 00             load.c32 14
	<.main+11957 @055c41>: 19                         load.z32
	<.main+11958 @055c42>: 1f eb c9 03 00             load.ref <@03c9eb> ;"string as variant"
	<.main+11963 @055c47>: 1f f8 d7 03 00             load.ref <@03d7f8>
	<.main+11968 @055c4c>: 1f 68 21 05 00             load.ref <@052168> ;strFixed
	<.main+11973 @055c51>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:84: (35 bytes: <@055c55> - <@055c78>): debug(void("string to variant", variant(strFixed)));
	<.main+11977 @055c55>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+11982 @055c5a>: 1c 54 00 00 00             load.c32 84
	<.main+11987 @055c5f>: 1c 0e 00 00 00             load.c32 14
	<.main+11992 @055c64>: 19                         load.z32
	<.main+11993 @055c65>: 1f fd c9 03 00             load.ref <@03c9fd> ;"string to variant"
	<.main+11998 @055c6a>: 1f f8 d7 03 00             load.ref <@03d7f8>
	<.main+12003 @055c6f>: 1f 68 21 05 00             load.ref <@052168> ;strFixed
	<.main+12008 @055c74>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:87: (34 bytes: <@055c78> - <@055c9a>): debug(void("string as variant", strArray));
	<.main+12012 @055c78>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12017 @055c7d>: 1c 57 00 00 00             load.c32 87
	<.main+12022 @055c82>: 1c 0e 00 00 00             load.c32 14
	<.main+12027 @055c87>: 19                         load.z32
	<.main+12028 @055c88>: 1f eb c9 03 00             load.ref <@03c9eb> ;"string as variant"
	<.main+12033 @055c8d>: 1f c0 d9 03 00             load.ref <@03d9c0>
	<.main+12038 @055c92>: 2a 70 21 05                load.m32 <@052170> ;strArray
	<.main+12042 @055c96>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:88: (34 bytes: <@055c9a> - <@055cbc>): debug(void("string to variant", variant(strArray)));
	<.main+12046 @055c9a>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12051 @055c9f>: 1c 58 00 00 00             load.c32 88
	<.main+12056 @055ca4>: 1c 0e 00 00 00             load.c32 14
	<.main+12061 @055ca9>: 19                         load.z32
	<.main+12062 @055caa>: 1f fd c9 03 00             load.ref <@03c9fd> ;"string to variant"
	<.main+12067 @055caf>: 1f c0 d9 03 00             load.ref <@03d9c0>
	<.main+12072 @055cb4>: 2a 70 21 05                load.m32 <@052170> ;strArray
	<.main+12076 @055cb8>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:91: (34 bytes: <@055cbc> - <@055cde>): debug(void("string as variant", strSlice));
	<.main+12080 @055cbc>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12085 @055cc1>: 1c 5b 00 00 00             load.c32 91
	<.main+12090 @055cc6>: 1c 0e 00 00 00             load.c32 14
	<.main+12095 @055ccb>: 19                         load.z32
	<.main+12096 @055ccc>: 1f eb c9 03 00             load.ref <@03c9eb> ;"string as variant"
	<.main+12101 @055cd1>: 1f f0 da 03 00             load.ref <@03daf0>
	<.main+12106 @055cd6>: 2a 78 21 05                load.m32 <@052178> ;strSlice
	<.main+12110 @055cda>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:92: (34 bytes: <@055cde> - <@055d00>): debug(void("string to variant", variant(strSlice)));
	<.main+12114 @055cde>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12119 @055ce3>: 1c 5c 00 00 00             load.c32 92
	<.main+12124 @055ce8>: 1c 0e 00 00 00             load.c32 14
	<.main+12129 @055ced>: 19                         load.z32
	<.main+12130 @055cee>: 1f fd c9 03 00             load.ref <@03c9fd> ;"string to variant"
	<.main+12135 @055cf3>: 1f f0 da 03 00             load.ref <@03daf0>
	<.main+12140 @055cf8>: 2a 78 21 05                load.m32 <@052178> ;strSlice
	<.main+12144 @055cfc>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:98: (53 bytes: <@055d00> - <@055d35>): assert(bool(arrSliceNoInit.length >= (0)));
	<.main+12148 @055d00>: 2a 2c 21 05                load.m32 <@05212c> ;arrSliceNoInit+4
	<.main+12152 @055d04>: 19                         load.z32
	<.main+12153 @055d05>: 38                         clt.u32
	<.main+12154 @055d06>: 05 08 00 00                jnz <.main+12162 @055d0e>
	<.main+12158 @055d0a>: 04 2b 00 00                jmp <.main+12201 @055d35>
	<.main+12162 @055d0e>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12167 @055d13>: 1c 62 00 00 00             load.c32 98
	<.main+12172 @055d18>: 1c fe ff ff ff             load.c32 -2
	<.main+12177 @055d1d>: 1c 80 00 00 00             load.c32 128
	<.main+12182 @055d22>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12187 @055d27>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12192 @055d2c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12197 @055d31>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:99: (53 bytes: <@055d35> - <@055d6a>): assert(bool(arrSliceInitNull.length == (0)));
	<.main+12201 @055d35>: 2a 3c 21 05                load.m32 <@05213c> ;arrSliceInitNull+4
	<.main+12205 @055d39>: 19                         load.z32
	<.main+12206 @055d3a>: 57                         ceq.i32
	<.main+12207 @055d3b>: 06 08 00 00                jz <.main+12215 @055d43>
	<.main+12211 @055d3f>: 04 2b 00 00                jmp <.main+12254 @055d6a>
	<.main+12215 @055d43>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12220 @055d48>: 1c 63 00 00 00             load.c32 99
	<.main+12225 @055d4d>: 1c fe ff ff ff             load.c32 -2
	<.main+12230 @055d52>: 1c 80 00 00 00             load.c32 128
	<.main+12235 @055d57>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12240 @055d5c>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12245 @055d61>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12250 @055d66>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:101: (61 bytes: <@055d6a> - <@055da7>): assert(bool(arrFixedNoInit[0] == (42)));
	<.main+12254 @055d6a>: 2b e8 20 05                load.m64 <@0520e8> ;arrFixedNoInit
	<.main+12258 @055d6e>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12267 @055d77>: 67                         ceq.i64
	<.main+12268 @055d78>: 06 08 00 00                jz <.main+12276 @055d80>
	<.main+12272 @055d7c>: 04 2b 00 00                jmp <.main+12315 @055da7>
	<.main+12276 @055d80>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12281 @055d85>: 1c 65 00 00 00             load.c32 101
	<.main+12286 @055d8a>: 1c fe ff ff ff             load.c32 -2
	<.main+12291 @055d8f>: 1c 80 00 00 00             load.c32 128
	<.main+12296 @055d94>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12301 @055d99>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12306 @055d9e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12311 @055da3>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:108: (25 bytes: <@055da7> - <@055dc0>): assertEq(void(7, arrFixedNoInit.length));
	<.main+12315 @055da7>: 1c 07 00 00 00             load.c32 7
	<.main+12320 @055dac>: 1c 07 00 00 00             load.c32 7
	<.main+12325 @055db1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12330 @055db6>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12335 @055dbb>: 02                         call
	<.main+12336 @055dbc>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:109: (24 bytes: <@055dc0> - <@055dd8>): assertEq(void(arrFixedNoInit.length, arrSliceInitFixed.length));
	<.main+12340 @055dc0>: 1c 07 00 00 00             load.c32 7
	<.main+12345 @055dc5>: 2a 4c 21 05                load.m32 <@05214c> ;arrSliceInitFixed+4
	<.main+12349 @055dc9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12354 @055dce>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12359 @055dd3>: 02                         call
	<.main+12360 @055dd4>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:110: (24 bytes: <@055dd8> - <@055df0>): assertEq(void(arrFixedNoInit.length, arrSliceInitSlice.length));
	<.main+12364 @055dd8>: 1c 07 00 00 00             load.c32 7
	<.main+12369 @055ddd>: 2a 5c 21 05                load.m32 <@05215c> ;arrSliceInitSlice+4
	<.main+12373 @055de1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12378 @055de6>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12383 @055deb>: 02                         call
	<.main+12384 @055dec>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:112: (32 bytes: <@055df0> - <@055e10>): assertEq(void(0, lenSlice(null)));
	<.main+12388 @055df0>: 19                         load.z32
	<.main+12389 @055df1>: 1a                         load.z64
	<.main+12390 @055df2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12395 @055df7>: 1f 80 21 05 00             load.ref <@052180> ;lenSlice(values: int64[]): int32
	<.main+12400 @055dfc>: 02                         call
	<.main+12401 @055dfd>: 09 f8 ff ff                inc.sp(-8)
	<.main+12405 @055e01>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12410 @055e06>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12415 @055e0b>: 02                         call
	<.main+12416 @055e0c>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:113: (31 bytes: <@055e10> - <@055e2f>): assertEq(void(0, lenSlice(arrSliceInitNull)));
	<.main+12420 @055e10>: 19                         load.z32
	<.main+12421 @055e11>: 19                         load.z32
	<.main+12422 @055e12>: 2b 38 21 05                load.m64 <@052138> ;arrSliceInitNull
	<.main+12426 @055e16>: 1f 80 21 05 00             load.ref <@052180> ;lenSlice(values: int64[]): int32
	<.main+12431 @055e1b>: 02                         call
	<.main+12432 @055e1c>: 09 f8 ff ff                inc.sp(-8)
	<.main+12436 @055e20>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12441 @055e25>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12446 @055e2a>: 02                         call
	<.main+12447 @055e2b>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:114: (41 bytes: <@055e2f> - <@055e58>): assertEq(void(arrFixedNoInit.length, lenSlice(arrFixedNoInit)));
	<.main+12451 @055e2f>: 1c 07 00 00 00             load.c32 7
	<.main+12456 @055e34>: 19                         load.z32
	<.main+12457 @055e35>: 1c 07 00 00 00             load.c32 7
	<.main+12462 @055e3a>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+12467 @055e3f>: 1f 80 21 05 00             load.ref <@052180> ;lenSlice(values: int64[]): int32
	<.main+12472 @055e44>: 02                         call
	<.main+12473 @055e45>: 09 f8 ff ff                inc.sp(-8)
	<.main+12477 @055e49>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12482 @055e4e>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12487 @055e53>: 02                         call
	<.main+12488 @055e54>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:115: (35 bytes: <@055e58> - <@055e7b>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitFixed)));
	<.main+12492 @055e58>: 1c 07 00 00 00             load.c32 7
	<.main+12497 @055e5d>: 19                         load.z32
	<.main+12498 @055e5e>: 2b 48 21 05                load.m64 <@052148> ;arrSliceInitFixed
	<.main+12502 @055e62>: 1f 80 21 05 00             load.ref <@052180> ;lenSlice(values: int64[]): int32
	<.main+12507 @055e67>: 02                         call
	<.main+12508 @055e68>: 09 f8 ff ff                inc.sp(-8)
	<.main+12512 @055e6c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12517 @055e71>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12522 @055e76>: 02                         call
	<.main+12523 @055e77>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:116: (35 bytes: <@055e7b> - <@055e9e>): assertEq(void(arrFixedNoInit.length, lenSlice(arrSliceInitSlice)));
	<.main+12527 @055e7b>: 1c 07 00 00 00             load.c32 7
	<.main+12532 @055e80>: 19                         load.z32
	<.main+12533 @055e81>: 2b 58 21 05                load.m64 <@052158> ;arrSliceInitSlice
	<.main+12537 @055e85>: 1f 80 21 05 00             load.ref <@052180> ;lenSlice(values: int64[]): int32
	<.main+12542 @055e8a>: 02                         call
	<.main+12543 @055e8b>: 09 f8 ff ff                inc.sp(-8)
	<.main+12547 @055e8f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12552 @055e94>: 1f 48 07 05 00             load.ref <@050748> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12557 @055e99>: 02                         call
	<.main+12558 @055e9a>: 09 f4 ff ff                inc.sp(-12)
	test/lang/array.ci:118: (827 bytes: <@055e9e> - <@0561d9>): for (i: int32 := 0; bool(i < arrFixedNoInit.length); int32(i := int32(i + 1)))
	<.main+12562 @055e9e>: 19                         load.z32
	<.main+12563 @055e9f>: 04 2a 03 00                jmp <.main+13373 @0561c9>
	test/lang/array.ci:119: (9 bytes: <@055ea3> - <@055eac>): expected: int64 := int32(42 + i)
	<.main+12567 @055ea3>: 1c 2a 00 00 00             load.c32 42
	<.main+12572 @055ea8>: 10 01                      dup.x32 sp(1)
	<.main+12574 @055eaa>: 51                         add.i32
	<.main+12575 @055eab>: 5b                         i32.2i64
	test/lang/array.ci:120: (62 bytes: <@055eac> - <@055eea>): assert(bool(expected == arrFixedNoInit[i]));
	<.main+12576 @055eac>: 11 00                      dup.x64 sp(0)
	<.main+12578 @055eae>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+12583 @055eb3>: 10 05                      dup.x32 sp(5)
	<.main+12585 @055eb5>: 0d 08 00 00                mad.u32 8
	<.main+12589 @055eb9>: 23                         load.i64
	<.main+12590 @055eba>: 67                         ceq.i64
	<.main+12591 @055ebb>: 06 08 00 00                jz <.main+12599 @055ec3>
	<.main+12595 @055ebf>: 04 2b 00 00                jmp <.main+12638 @055eea>
	<.main+12599 @055ec3>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12604 @055ec8>: 1c 78 00 00 00             load.c32 120
	<.main+12609 @055ecd>: 1c fe ff ff ff             load.c32 -2
	<.main+12614 @055ed2>: 1c 80 00 00 00             load.c32 128
	<.main+12619 @055ed7>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12624 @055edc>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12629 @055ee1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12634 @055ee6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:121: (61 bytes: <@055eea> - <@055f27>): assert(bool(expected == arrArrayInitFixed[i]));
	<.main+12638 @055eea>: 11 00                      dup.x64 sp(0)
	<.main+12640 @055eec>: 2a 40 21 05                load.m32 <@052140> ;arrArrayInitFixed
	<.main+12644 @055ef0>: 10 05                      dup.x32 sp(5)
	<.main+12646 @055ef2>: 0d 08 00 00                mad.u32 8
	<.main+12650 @055ef6>: 23                         load.i64
	<.main+12651 @055ef7>: 67                         ceq.i64
	<.main+12652 @055ef8>: 06 08 00 00                jz <.main+12660 @055f00>
	<.main+12656 @055efc>: 04 2b 00 00                jmp <.main+12699 @055f27>
	<.main+12660 @055f00>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12665 @055f05>: 1c 79 00 00 00             load.c32 121
	<.main+12670 @055f0a>: 1c fe ff ff ff             load.c32 -2
	<.main+12675 @055f0f>: 1c 80 00 00 00             load.c32 128
	<.main+12680 @055f14>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12685 @055f19>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12690 @055f1e>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12695 @055f23>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:122: (61 bytes: <@055f27> - <@055f64>): assert(bool(expected == arrSliceInitFixed[i]));
	<.main+12699 @055f27>: 11 00                      dup.x64 sp(0)
	<.main+12701 @055f29>: 2a 48 21 05                load.m32 <@052148> ;arrSliceInitFixed
	<.main+12705 @055f2d>: 10 05                      dup.x32 sp(5)
	<.main+12707 @055f2f>: 0d 08 00 00                mad.u32 8
	<.main+12711 @055f33>: 23                         load.i64
	<.main+12712 @055f34>: 67                         ceq.i64
	<.main+12713 @055f35>: 06 08 00 00                jz <.main+12721 @055f3d>
	<.main+12717 @055f39>: 04 2b 00 00                jmp <.main+12760 @055f64>
	<.main+12721 @055f3d>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12726 @055f42>: 1c 7a 00 00 00             load.c32 122
	<.main+12731 @055f47>: 1c fe ff ff ff             load.c32 -2
	<.main+12736 @055f4c>: 1c 80 00 00 00             load.c32 128
	<.main+12741 @055f51>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12746 @055f56>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12751 @055f5b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12756 @055f60>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:124: (68 bytes: <@055f64> - <@055fa8>): assert(bool(expected == nthFixed(void(i, arrFixedNoInit))));
	<.main+12760 @055f64>: 11 00                      dup.x64 sp(0)
	<.main+12762 @055f66>: 1a                         load.z64
	<.main+12763 @055f67>: 10 06                      dup.x32 sp(6)
	<.main+12765 @055f69>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+12770 @055f6e>: 1f 88 21 05 00             load.ref <@052188> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12775 @055f73>: 02                         call
	<.main+12776 @055f74>: 09 f8 ff ff                inc.sp(-8)
	<.main+12780 @055f78>: 67                         ceq.i64
	<.main+12781 @055f79>: 06 08 00 00                jz <.main+12789 @055f81>
	<.main+12785 @055f7d>: 04 2b 00 00                jmp <.main+12828 @055fa8>
	<.main+12789 @055f81>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12794 @055f86>: 1c 7c 00 00 00             load.c32 124
	<.main+12799 @055f8b>: 1c fe ff ff ff             load.c32 -2
	<.main+12804 @055f90>: 1c 80 00 00 00             load.c32 128
	<.main+12809 @055f95>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12814 @055f9a>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12819 @055f9f>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12824 @055fa4>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:125: (67 bytes: <@055fa8> - <@055feb>): assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
	<.main+12828 @055fa8>: 11 00                      dup.x64 sp(0)
	<.main+12830 @055faa>: 1a                         load.z64
	<.main+12831 @055fab>: 10 06                      dup.x32 sp(6)
	<.main+12833 @055fad>: 2a 40 21 05                load.m32 <@052140> ;arrArrayInitFixed
	<.main+12837 @055fb1>: 1f 88 21 05 00             load.ref <@052188> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12842 @055fb6>: 02                         call
	<.main+12843 @055fb7>: 09 f8 ff ff                inc.sp(-8)
	<.main+12847 @055fbb>: 67                         ceq.i64
	<.main+12848 @055fbc>: 06 08 00 00                jz <.main+12856 @055fc4>
	<.main+12852 @055fc0>: 04 2b 00 00                jmp <.main+12895 @055feb>
	<.main+12856 @055fc4>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12861 @055fc9>: 1c 7d 00 00 00             load.c32 125
	<.main+12866 @055fce>: 1c fe ff ff ff             load.c32 -2
	<.main+12871 @055fd3>: 1c 80 00 00 00             load.c32 128
	<.main+12876 @055fd8>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12881 @055fdd>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12886 @055fe2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12891 @055fe7>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:126: (67 bytes: <@055feb> - <@05602e>): assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
	<.main+12895 @055feb>: 11 00                      dup.x64 sp(0)
	<.main+12897 @055fed>: 1a                         load.z64
	<.main+12898 @055fee>: 10 06                      dup.x32 sp(6)
	<.main+12900 @055ff0>: 2a 48 21 05                load.m32 <@052148> ;arrSliceInitFixed
	<.main+12904 @055ff4>: 1f 88 21 05 00             load.ref <@052188> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+12909 @055ff9>: 02                         call
	<.main+12910 @055ffa>: 09 f8 ff ff                inc.sp(-8)
	<.main+12914 @055ffe>: 67                         ceq.i64
	<.main+12915 @055fff>: 06 08 00 00                jz <.main+12923 @056007>
	<.main+12919 @056003>: 04 2b 00 00                jmp <.main+12962 @05602e>
	<.main+12923 @056007>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12928 @05600c>: 1c 7e 00 00 00             load.c32 126
	<.main+12933 @056011>: 1c fe ff ff ff             load.c32 -2
	<.main+12938 @056016>: 1c 80 00 00 00             load.c32 128
	<.main+12943 @05601b>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+12948 @056020>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+12953 @056025>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12958 @05602a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:128: (68 bytes: <@05602e> - <@056072>): assert(bool(expected == nthArray(void(i, arrFixedNoInit))));
	<.main+12962 @05602e>: 11 00                      dup.x64 sp(0)
	<.main+12964 @056030>: 1a                         load.z64
	<.main+12965 @056031>: 10 06                      dup.x32 sp(6)
	<.main+12967 @056033>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+12972 @056038>: 1f 98 21 05 00             load.ref <@052198> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+12977 @05603d>: 02                         call
	<.main+12978 @05603e>: 09 f8 ff ff                inc.sp(-8)
	<.main+12982 @056042>: 67                         ceq.i64
	<.main+12983 @056043>: 06 08 00 00                jz <.main+12991 @05604b>
	<.main+12987 @056047>: 04 2b 00 00                jmp <.main+13030 @056072>
	<.main+12991 @05604b>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+12996 @056050>: 1c 80 00 00 00             load.c32 128
	<.main+13001 @056055>: 1c fe ff ff ff             load.c32 -2
	<.main+13006 @05605a>: 1c 80 00 00 00             load.c32 128
	<.main+13011 @05605f>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13016 @056064>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13021 @056069>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13026 @05606e>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:129: (67 bytes: <@056072> - <@0560b5>): assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
	<.main+13030 @056072>: 11 00                      dup.x64 sp(0)
	<.main+13032 @056074>: 1a                         load.z64
	<.main+13033 @056075>: 10 06                      dup.x32 sp(6)
	<.main+13035 @056077>: 2a 40 21 05                load.m32 <@052140> ;arrArrayInitFixed
	<.main+13039 @05607b>: 1f 98 21 05 00             load.ref <@052198> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13044 @056080>: 02                         call
	<.main+13045 @056081>: 09 f8 ff ff                inc.sp(-8)
	<.main+13049 @056085>: 67                         ceq.i64
	<.main+13050 @056086>: 06 08 00 00                jz <.main+13058 @05608e>
	<.main+13054 @05608a>: 04 2b 00 00                jmp <.main+13097 @0560b5>
	<.main+13058 @05608e>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+13063 @056093>: 1c 81 00 00 00             load.c32 129
	<.main+13068 @056098>: 1c fe ff ff ff             load.c32 -2
	<.main+13073 @05609d>: 1c 80 00 00 00             load.c32 128
	<.main+13078 @0560a2>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13083 @0560a7>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13088 @0560ac>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13093 @0560b1>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:130: (67 bytes: <@0560b5> - <@0560f8>): assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
	<.main+13097 @0560b5>: 11 00                      dup.x64 sp(0)
	<.main+13099 @0560b7>: 1a                         load.z64
	<.main+13100 @0560b8>: 10 06                      dup.x32 sp(6)
	<.main+13102 @0560ba>: 2a 48 21 05                load.m32 <@052148> ;arrSliceInitFixed
	<.main+13106 @0560be>: 1f 98 21 05 00             load.ref <@052198> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13111 @0560c3>: 02                         call
	<.main+13112 @0560c4>: 09 f8 ff ff                inc.sp(-8)
	<.main+13116 @0560c8>: 67                         ceq.i64
	<.main+13117 @0560c9>: 06 08 00 00                jz <.main+13125 @0560d1>
	<.main+13121 @0560cd>: 04 2b 00 00                jmp <.main+13164 @0560f8>
	<.main+13125 @0560d1>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+13130 @0560d6>: 1c 82 00 00 00             load.c32 130
	<.main+13135 @0560db>: 1c fe ff ff ff             load.c32 -2
	<.main+13140 @0560e0>: 1c 80 00 00 00             load.c32 128
	<.main+13145 @0560e5>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13150 @0560ea>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13155 @0560ef>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13160 @0560f4>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:132: (73 bytes: <@0560f8> - <@056141>): assert(bool(expected == nthSlice(void(i, arrFixedNoInit))));
	<.main+13164 @0560f8>: 11 00                      dup.x64 sp(0)
	<.main+13166 @0560fa>: 1a                         load.z64
	<.main+13167 @0560fb>: 10 06                      dup.x32 sp(6)
	<.main+13169 @0560fd>: 1c 07 00 00 00             load.c32 7
	<.main+13174 @056102>: 1f e8 20 05 00             load.ref <@0520e8> ;arrFixedNoInit
	<.main+13179 @056107>: 1f a8 21 05 00             load.ref <@0521a8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13184 @05610c>: 02                         call
	<.main+13185 @05610d>: 09 f4 ff ff                inc.sp(-12)
	<.main+13189 @056111>: 67                         ceq.i64
	<.main+13190 @056112>: 06 08 00 00                jz <.main+13198 @05611a>
	<.main+13194 @056116>: 04 2b 00 00                jmp <.main+13237 @056141>
	<.main+13198 @05611a>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+13203 @05611f>: 1c 84 00 00 00             load.c32 132
	<.main+13208 @056124>: 1c fe ff ff ff             load.c32 -2
	<.main+13213 @056129>: 1c 80 00 00 00             load.c32 128
	<.main+13218 @05612e>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13223 @056133>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13228 @056138>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13233 @05613d>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:134: (67 bytes: <@056141> - <@056184>): assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
	<.main+13237 @056141>: 11 00                      dup.x64 sp(0)
	<.main+13239 @056143>: 1a                         load.z64
	<.main+13240 @056144>: 10 06                      dup.x32 sp(6)
	<.main+13242 @056146>: 2b 48 21 05                load.m64 <@052148> ;arrSliceInitFixed
	<.main+13246 @05614a>: 1f a8 21 05 00             load.ref <@0521a8> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13251 @05614f>: 02                         call
	<.main+13252 @056150>: 09 f4 ff ff                inc.sp(-12)
	<.main+13256 @056154>: 67                         ceq.i64
	<.main+13257 @056155>: 06 08 00 00                jz <.main+13265 @05615d>
	<.main+13261 @056159>: 04 2b 00 00                jmp <.main+13304 @056184>
	<.main+13265 @05615d>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+13270 @056162>: 1c 86 00 00 00             load.c32 134
	<.main+13275 @056167>: 1c fe ff ff ff             load.c32 -2
	<.main+13280 @05616c>: 1c 80 00 00 00             load.c32 128
	<.main+13285 @056171>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13290 @056176>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13295 @05617b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13300 @056180>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/array.ci:136: (61 bytes: <@056184> - <@0561c1>): assert(bool(expected == arrSliceInitSlice[i]));
	<.main+13304 @056184>: 11 00                      dup.x64 sp(0)
	<.main+13306 @056186>: 2a 58 21 05                load.m32 <@052158> ;arrSliceInitSlice
	<.main+13310 @05618a>: 10 05                      dup.x32 sp(5)
	<.main+13312 @05618c>: 0d 08 00 00                mad.u32 8
	<.main+13316 @056190>: 23                         load.i64
	<.main+13317 @056191>: 67                         ceq.i64
	<.main+13318 @056192>: 06 08 00 00                jz <.main+13326 @05619a>
	<.main+13322 @056196>: 04 2b 00 00                jmp <.main+13365 @0561c1>
	<.main+13326 @05619a>: 1f 28 c9 03 00             load.ref <@03c928> ;"test/lang/array.ci"
	<.main+13331 @05619f>: 1c 88 00 00 00             load.c32 136
	<.main+13336 @0561a4>: 1c fe ff ff ff             load.c32 -2
	<.main+13341 @0561a9>: 1c 80 00 00 00             load.c32 128
	<.main+13346 @0561ae>: 1f 86 cd 00 00             load.ref <@00cd86> ;"assertion failed!"
	<.main+13351 @0561b3>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13356 @0561b8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13361 @0561bd>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13365 @0561c1>: 09 f8 ff ff                inc.sp(-8)
	test/lang/array.ci:118: (4 bytes: <@0561c5> - <@0561c9>): int32(i := int32(i + 1))
	<.main+13369 @0561c5>: 0c 01 00 00                inc.i32(+1)
	test/lang/array.ci:118: (12 bytes: <@0561c9> - <@0561d5>): bool(i < arrFixedNoInit.length)
	<.main+13373 @0561c9>: 10 00                      dup.x32 sp(0)
	<.main+13375 @0561cb>: 1c 07 00 00 00             load.c32 7
	<.main+13380 @0561d0>: 58                         clt.i32
	<.main+13381 @0561d1>: 05 d2 fc ff                jnz <.main+12567 @055ea3>
	<.main+13385 @0561d5>: 09 fc ff ff                inc.sp(-4)
	test/lang/method.ci:78: (21 bytes: <@0561d9> - <@0561ee>): recordMethodTest.staticMethod(void(recordMethodTest, 1));
	<.main+13389 @0561d9>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13393 @0561dd>: 1c 01 00 00 00             load.c32 1
	<.main+13398 @0561e2>: 13 04                      set.x32 sp(4)
	<.main+13400 @0561e4>: 1f 08 22 05 00             load.ref <@052208> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13405 @0561e9>: 02                         call
	<.main+13406 @0561ea>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:79: (20 bytes: <@0561ee> - <@056202>): recordMethodTest.virtualMethod(void(recordMethodTest, 1));
	<.main+13410 @0561ee>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13414 @0561f2>: 1c 01 00 00 00             load.c32 1
	<.main+13419 @0561f7>: 13 04                      set.x32 sp(4)
	<.main+13421 @0561f9>: 2a b8 22 05                load.m32 <@0522b8> ;recordMethodTest+8
	<.main+13425 @0561fd>: 02                         call
	<.main+13426 @0561fe>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:97: (19 bytes: <@056202> - <@056215>): staticMethod(void(recordMethodTest, 2));
	<.main+13430 @056202>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13434 @056206>: 1c 02 00 00 00             load.c32 2
	<.main+13439 @05620b>: 1f c0 22 05 00             load.ref <@0522c0> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13444 @056210>: 02                         call
	<.main+13445 @056211>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:98: (19 bytes: <@056215> - <@056228>): virtualMethod(void(recordMethodTest, 2));
	<.main+13449 @056215>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13453 @056219>: 1c 02 00 00 00             load.c32 2
	<.main+13458 @05621e>: 1f 08 23 05 00             load.ref <@052308> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13463 @056223>: 02                         call
	<.main+13464 @056224>: 09 ec ff ff                inc.sp(-20)
	test/lang/method.ci:101: (21 bytes: <@056228> - <@05623d>): RecordMethodTest.staticMethod(void(recordMethodTest, 3));
	<.main+13468 @056228>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13472 @05622c>: 1c 03 00 00 00             load.c32 3
	<.main+13477 @056231>: 13 04                      set.x32 sp(4)
	<.main+13479 @056233>: 1f 08 22 05 00             load.ref <@052208> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+13484 @056238>: 02                         call
	<.main+13485 @056239>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:102: (21 bytes: <@05623d> - <@056252>): RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13489 @05623d>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13493 @056241>: 1c 03 00 00 00             load.c32 3
	<.main+13498 @056246>: 13 04                      set.x32 sp(4)
	<.main+13500 @056248>: 1f 38 22 05 00             load.ref <@052238> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+13505 @05624d>: 02                         call
	<.main+13506 @05624e>: 09 f0 ff ff                inc.sp(-16)
	test/lang/method.ci:103: (20 bytes: <@056252> - <@056266>): recordMethodTest.virtualMethod(void(recordMethodTest, 3));
	<.main+13510 @056252>: 2c b0 22 05                load.m128 <@0522b0> ;recordMethodTest
	<.main+13514 @056256>: 1c 03 00 00 00             load.c32 3
	<.main+13519 @05625b>: 13 04                      set.x32 sp(4)
	<.main+13521 @05625d>: 2a b8 22 05                load.m32 <@0522b8> ;recordMethodTest+8
	<.main+13525 @056261>: 02                         call
	<.main+13526 @056262>: 09 f0 ff ff                inc.sp(-16)
	test/lang/statementIf.ci:4: (39 bytes: <@056266> - <@05628d>): raise(void(void(void(raise.debug, 1), "0 == 0"), null));
	<.main+13530 @056266>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13535 @05626b>: 1c 04 00 00 00             load.c32 4
	<.main+13540 @056270>: 1c 0e 00 00 00             load.c32 14
	<.main+13545 @056275>: 1c 01 00 00 00             load.c32 1
	<.main+13550 @05627a>: 1f e1 ce 04 00             load.ref <@04cee1> ;"0 == 0"
	<.main+13555 @05627f>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13560 @056284>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13565 @056289>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:12: (39 bytes: <@05628d> - <@0562b4>): raise(void(void(void(raise.debug, 3), "0 == 0"), null));
	<.main+13569 @05628d>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13574 @056292>: 1c 0c 00 00 00             load.c32 12
	<.main+13579 @056297>: 1c 0e 00 00 00             load.c32 14
	<.main+13584 @05629c>: 1c 03 00 00 00             load.c32 3
	<.main+13589 @0562a1>: 1f e1 ce 04 00             load.ref <@04cee1> ;"0 == 0"
	<.main+13594 @0562a6>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13599 @0562ab>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13604 @0562b0>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:22: (39 bytes: <@0562b4> - <@0562db>): raise(void(void(void(raise.debug, 6), "0 == 0"), null));
	<.main+13608 @0562b4>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13613 @0562b9>: 1c 16 00 00 00             load.c32 22
	<.main+13618 @0562be>: 1c 0e 00 00 00             load.c32 14
	<.main+13623 @0562c3>: 1c 06 00 00 00             load.c32 6
	<.main+13628 @0562c8>: 1f e1 ce 04 00             load.ref <@04cee1> ;"0 == 0"
	<.main+13633 @0562cd>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+13638 @0562d2>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13643 @0562d7>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:28: (49 bytes: <@0562db> - <@05630c>): if (bool(t == 0))
	<.main+13647 @0562db>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13651 @0562df>: 19                         load.z32
	<.main+13652 @0562e0>: 57                         ceq.i32
	<.main+13653 @0562e1>: 06 2b 00 00                jz <.main+13696 @05630c>
	test/lang/statementIf.ci:29: (39 bytes: <@0562e5> - <@05630c>): raise(void(void(void(raise.debug, 7), "t == 0"), t));
	<.main+13657 @0562e5>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13662 @0562ea>: 1c 1d 00 00 00             load.c32 29
	<.main+13667 @0562ef>: 1c 0e 00 00 00             load.c32 14
	<.main+13672 @0562f4>: 1c 07 00 00 00             load.c32 7
	<.main+13677 @0562f9>: 1f ef ce 04 00             load.ref <@04ceef> ;"t == 0"
	<.main+13682 @0562fe>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13687 @056303>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13692 @056308>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:32: (49 bytes: <@05630c> - <@05633d>): if (bool(t != 0))
	<.main+13696 @05630c>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13700 @056310>: 19                         load.z32
	<.main+13701 @056311>: 57                         ceq.i32
	<.main+13702 @056312>: 05 2b 00 00                jnz <.main+13745 @05633d>
	test/lang/statementIf.ci:33: (39 bytes: <@056316> - <@05633d>): raise(void(void(void(raise.debug, 8), "t != 0"), t));
	<.main+13706 @056316>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13711 @05631b>: 1c 21 00 00 00             load.c32 33
	<.main+13716 @056320>: 1c 0e 00 00 00             load.c32 14
	<.main+13721 @056325>: 1c 08 00 00 00             load.c32 8
	<.main+13726 @05632a>: 1f f6 ce 04 00             load.ref <@04cef6> ;"t != 0"
	<.main+13731 @05632f>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13736 @056334>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13741 @056339>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:36: (92 bytes: <@05633d> - <@056399>): if (bool(t == 0))
	<.main+13745 @05633d>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13749 @056341>: 19                         load.z32
	<.main+13750 @056342>: 57                         ceq.i32
	<.main+13751 @056343>: 06 2f 00 00                jz <.main+13798 @056372>
	test/lang/statementIf.ci:37: (39 bytes: <@056347> - <@05636e>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13755 @056347>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13760 @05634c>: 1c 25 00 00 00             load.c32 37
	<.main+13765 @056351>: 1c 0e 00 00 00             load.c32 14
	<.main+13770 @056356>: 1c 09 00 00 00             load.c32 9
	<.main+13775 @05635b>: 1f ef ce 04 00             load.ref <@04ceef> ;"t == 0"
	<.main+13780 @056360>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13785 @056365>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13790 @05636a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13794 @05636e>: 04 2b 00 00                jmp <.main+13837 @056399>
	test/lang/statementIf.ci:40: (39 bytes: <@056372> - <@056399>): raise(void(void(void(raise.debug, 10), "t != 0"), t));
	<.main+13798 @056372>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13803 @056377>: 1c 28 00 00 00             load.c32 40
	<.main+13808 @05637c>: 1c 0e 00 00 00             load.c32 14
	<.main+13813 @056381>: 1c 0a 00 00 00             load.c32 10
	<.main+13818 @056386>: 1f f6 ce 04 00             load.ref <@04cef6> ;"t != 0"
	<.main+13823 @05638b>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13828 @056390>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13833 @056395>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:43: (92 bytes: <@056399> - <@0563f5>): if (bool(t != 0))
	<.main+13837 @056399>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13841 @05639d>: 19                         load.z32
	<.main+13842 @05639e>: 57                         ceq.i32
	<.main+13843 @05639f>: 05 2f 00 00                jnz <.main+13890 @0563ce>
	test/lang/statementIf.ci:44: (39 bytes: <@0563a3> - <@0563ca>): raise(void(void(void(raise.debug, 11), "t != 0"), t));
	<.main+13847 @0563a3>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13852 @0563a8>: 1c 2c 00 00 00             load.c32 44
	<.main+13857 @0563ad>: 1c 0e 00 00 00             load.c32 14
	<.main+13862 @0563b2>: 1c 0b 00 00 00             load.c32 11
	<.main+13867 @0563b7>: 1f f6 ce 04 00             load.ref <@04cef6> ;"t != 0"
	<.main+13872 @0563bc>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13877 @0563c1>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13882 @0563c6>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13886 @0563ca>: 04 2b 00 00                jmp <.main+13929 @0563f5>
	test/lang/statementIf.ci:47: (39 bytes: <@0563ce> - <@0563f5>): raise(void(void(void(raise.debug, 12), "t == 0"), t));
	<.main+13890 @0563ce>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13895 @0563d3>: 1c 2f 00 00 00             load.c32 47
	<.main+13900 @0563d8>: 1c 0e 00 00 00             load.c32 14
	<.main+13905 @0563dd>: 1c 0c 00 00 00             load.c32 12
	<.main+13910 @0563e2>: 1f ef ce 04 00             load.ref <@04ceef> ;"t == 0"
	<.main+13915 @0563e7>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13920 @0563ec>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13925 @0563f1>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementIf.ci:50: (377 bytes: <@0563f5> - <@05656e>): if (bool(t == 0))
	<.main+13929 @0563f5>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13933 @0563f9>: 19                         load.z32
	<.main+13934 @0563fa>: 57                         ceq.i32
	<.main+13935 @0563fb>: 06 2f 00 00                jz <.main+13982 @05642a>
	test/lang/statementIf.ci:51: (39 bytes: <@0563ff> - <@056426>): raise(void(void(void(raise.debug, 9), "t == 0"), t));
	<.main+13939 @0563ff>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+13944 @056404>: 1c 33 00 00 00             load.c32 51
	<.main+13949 @056409>: 1c 0e 00 00 00             load.c32 14
	<.main+13954 @05640e>: 1c 09 00 00 00             load.c32 9
	<.main+13959 @056413>: 1f ef ce 04 00             load.ref <@04ceef> ;"t == 0"
	<.main+13964 @056418>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+13969 @05641d>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+13974 @056422>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13978 @056426>: 04 48 01 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:53: (324 bytes: <@05642a> - <@05656e>): if (bool(t == 1))
	<.main+13982 @05642a>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+13986 @05642e>: 1c 01 00 00 00             load.c32 1
	<.main+13991 @056433>: 57                         ceq.i32
	<.main+13992 @056434>: 06 2f 00 00                jz <.main+14039 @056463>
	test/lang/statementIf.ci:54: (39 bytes: <@056438> - <@05645f>): raise(void(void(void(raise.debug, 10), "t == 1"), t));
	<.main+13996 @056438>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14001 @05643d>: 1c 36 00 00 00             load.c32 54
	<.main+14006 @056442>: 1c 0e 00 00 00             load.c32 14
	<.main+14011 @056447>: 1c 0a 00 00 00             load.c32 10
	<.main+14016 @05644c>: 1f fd ce 04 00             load.ref <@04cefd> ;"t == 1"
	<.main+14021 @056451>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14026 @056456>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14031 @05645b>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14035 @05645f>: 04 0f 01 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:56: (267 bytes: <@056463> - <@05656e>): if (bool(t == 2))
	<.main+14039 @056463>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+14043 @056467>: 1c 02 00 00 00             load.c32 2
	<.main+14048 @05646c>: 57                         ceq.i32
	<.main+14049 @05646d>: 06 2f 00 00                jz <.main+14096 @05649c>
	test/lang/statementIf.ci:57: (39 bytes: <@056471> - <@056498>): raise(void(void(void(raise.debug, 10), "t == 2"), t));
	<.main+14053 @056471>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14058 @056476>: 1c 39 00 00 00             load.c32 57
	<.main+14063 @05647b>: 1c 0e 00 00 00             load.c32 14
	<.main+14068 @056480>: 1c 0a 00 00 00             load.c32 10
	<.main+14073 @056485>: 1f 04 cf 04 00             load.ref <@04cf04> ;"t == 2"
	<.main+14078 @05648a>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14083 @05648f>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14088 @056494>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14092 @056498>: 04 d6 00 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:59: (210 bytes: <@05649c> - <@05656e>): if (bool(t == 3))
	<.main+14096 @05649c>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+14100 @0564a0>: 1c 03 00 00 00             load.c32 3
	<.main+14105 @0564a5>: 57                         ceq.i32
	<.main+14106 @0564a6>: 06 2f 00 00                jz <.main+14153 @0564d5>
	test/lang/statementIf.ci:60: (39 bytes: <@0564aa> - <@0564d1>): raise(void(void(void(raise.debug, 10), "t == 3"), t));
	<.main+14110 @0564aa>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14115 @0564af>: 1c 3c 00 00 00             load.c32 60
	<.main+14120 @0564b4>: 1c 0e 00 00 00             load.c32 14
	<.main+14125 @0564b9>: 1c 0a 00 00 00             load.c32 10
	<.main+14130 @0564be>: 1f 0b cf 04 00             load.ref <@04cf0b> ;"t == 3"
	<.main+14135 @0564c3>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14140 @0564c8>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14145 @0564cd>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14149 @0564d1>: 04 9d 00 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:62: (153 bytes: <@0564d5> - <@05656e>): if (bool(t == 4))
	<.main+14153 @0564d5>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+14157 @0564d9>: 1c 04 00 00 00             load.c32 4
	<.main+14162 @0564de>: 57                         ceq.i32
	<.main+14163 @0564df>: 06 2f 00 00                jz <.main+14210 @05650e>
	test/lang/statementIf.ci:63: (39 bytes: <@0564e3> - <@05650a>): raise(void(void(void(raise.debug, 10), "t == 4"), t));
	<.main+14167 @0564e3>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14172 @0564e8>: 1c 3f 00 00 00             load.c32 63
	<.main+14177 @0564ed>: 1c 0e 00 00 00             load.c32 14
	<.main+14182 @0564f2>: 1c 0a 00 00 00             load.c32 10
	<.main+14187 @0564f7>: 1f 12 cf 04 00             load.ref <@04cf12> ;"t == 4"
	<.main+14192 @0564fc>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14197 @056501>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14202 @056506>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14206 @05650a>: 04 64 00 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:65: (96 bytes: <@05650e> - <@05656e>): if (bool(t == 5))
	<.main+14210 @05650e>: 2a 28 2b 05                load.m32 <@052b28> ;t
	<.main+14214 @056512>: 1c 05 00 00 00             load.c32 5
	<.main+14219 @056517>: 57                         ceq.i32
	<.main+14220 @056518>: 06 2f 00 00                jz <.main+14267 @056547>
	test/lang/statementIf.ci:66: (39 bytes: <@05651c> - <@056543>): raise(void(void(void(raise.debug, 10), "t == 5"), t));
	<.main+14224 @05651c>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14229 @056521>: 1c 42 00 00 00             load.c32 66
	<.main+14234 @056526>: 1c 0e 00 00 00             load.c32 14
	<.main+14239 @05652b>: 1c 0a 00 00 00             load.c32 10
	<.main+14244 @056530>: 1f 19 cf 04 00             load.ref <@04cf19> ;"t == 5"
	<.main+14249 @056535>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14254 @05653a>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14259 @05653f>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14263 @056543>: 04 2b 00 00                jmp <.main+14306 @05656e>
	test/lang/statementIf.ci:69: (39 bytes: <@056547> - <@05656e>): raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
	<.main+14267 @056547>: 1f c8 ce 04 00             load.ref <@04cec8> ;"test/lang/statementIf.ci"
	<.main+14272 @05654c>: 1c 45 00 00 00             load.c32 69
	<.main+14277 @056551>: 1c 0e 00 00 00             load.c32 14
	<.main+14282 @056556>: 1c 0a 00 00 00             load.c32 10
	<.main+14287 @05655b>: 1f 20 cf 04 00             load.ref <@04cf20> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14292 @056560>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14297 @056565>: 1f 28 2b 05 00             load.ref <@052b28> ;t
	<.main+14302 @05656a>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:3: (47 bytes: <@05656e> - <@05659d>): for ( ; ; )
	<.main+14306 @05656e>: 04 2b 00 00                jmp <.main+14349 @056599>
	test/lang/statementFor.ci:4: (35 bytes: <@056572> - <@056595>): debug("for ( ; ; )");
	<.main+14310 @056572>: 1f 08 d0 04 00             load.ref <@04d008> ;"test/lang/statementFor.ci"
	<.main+14315 @056577>: 1c 04 00 00 00             load.c32 4
	<.main+14320 @05657c>: 1c 0e 00 00 00             load.c32 14
	<.main+14325 @056581>: 19                         load.z32
	<.main+14326 @056582>: 1f 22 d0 04 00             load.ref <@04d022> ;"for ( ; ; )"
	<.main+14331 @056587>: 1f d0 08 00 00             load.ref <@0008d0> ;pointer
	<.main+14336 @05658c>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14341 @056591>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:5: (4 bytes: <@056595> - <@056599>): break;
	<.main+14345 @056595>: 04 08 00 00                jmp <.main+14353 @05659d>
	:: (4 bytes: <@056599> - <@05659d>)
	<.main+14349 @056599>: 04 d9 ff ff                jmp <.main+14310 @056572>
	test/lang/statementFor.ci:8: (59 bytes: <@05659d> - <@0565d8>): for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1)))
	<.main+14353 @05659d>: 19                         load.z32
	<.main+14354 @05659e>: 04 2a 00 00                jmp <.main+14396 @0565c8>
	test/lang/statementFor.ci:9: (34 bytes: <@0565a2> - <@0565c4>): debug(void("for (int i = 0; i < 2; i += 1)", i));
	<.main+14358 @0565a2>: 1f 08 d0 04 00             load.ref <@04d008> ;"test/lang/statementFor.ci"
	<.main+14363 @0565a7>: 1c 09 00 00 00             load.c32 9
	<.main+14368 @0565ac>: 1c 0e 00 00 00             load.c32 14
	<.main+14373 @0565b1>: 19                         load.z32
	<.main+14374 @0565b2>: 1f 2e d0 04 00             load.ref <@04d02e> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14379 @0565b7>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14384 @0565bc>: 0a 18 00 00                load.sp(+24)
	<.main+14388 @0565c0>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:8: (4 bytes: <@0565c4> - <@0565c8>): int32(i := int32(i + 1))
	<.main+14392 @0565c4>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:8: (12 bytes: <@0565c8> - <@0565d4>): bool(i < 2)
	<.main+14396 @0565c8>: 10 00                      dup.x32 sp(0)
	<.main+14398 @0565ca>: 1c 02 00 00 00             load.c32 2
	<.main+14403 @0565cf>: 58                         clt.i32
	<.main+14404 @0565d0>: 05 d2 ff ff                jnz <.main+14358 @0565a2>
	<.main+14408 @0565d4>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:13: (70 bytes: <@0565d8> - <@05661e>): for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1)))
	<.main+14412 @0565d8>: 19                         load.z32
	<.main+14413 @0565d9>: 2e 30 2b 05                store.m32 <@052b30> ;forIdx
	<.main+14417 @0565dd>: 04 33 00 00                jmp <.main+14468 @056610>
	test/lang/statementFor.ci:14: (35 bytes: <@0565e1> - <@056604>): debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
	<.main+14421 @0565e1>: 1f 08 d0 04 00             load.ref <@04d008> ;"test/lang/statementFor.ci"
	<.main+14426 @0565e6>: 1c 0e 00 00 00             load.c32 14
	<.main+14431 @0565eb>: 1c 0e 00 00 00             load.c32 14
	<.main+14436 @0565f0>: 19                         load.z32
	<.main+14437 @0565f1>: 1f 54 d0 04 00             load.ref <@04d054> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14442 @0565f6>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14447 @0565fb>: 1f 30 2b 05 00             load.ref <@052b30> ;forIdx
	<.main+14452 @056600>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:13: (12 bytes: <@056604> - <@056610>): int32(forIdx := int32(forIdx + 1))
	<.main+14456 @056604>: 2a 30 2b 05                load.m32 <@052b30> ;forIdx
	<.main+14460 @056608>: 0c 01 00 00                inc.i32(+1)
	<.main+14464 @05660c>: 2e 30 2b 05                store.m32 <@052b30> ;forIdx
	test/lang/statementFor.ci:13: (14 bytes: <@056610> - <@05661e>): bool(forIdx < 2)
	<.main+14468 @056610>: 2a 30 2b 05                load.m32 <@052b30> ;forIdx
	<.main+14472 @056614>: 1c 02 00 00 00             load.c32 2
	<.main+14477 @056619>: 58                         clt.i32
	<.main+14478 @05661a>: 05 c7 ff ff                jnz <.main+14421 @0565e1>
	test/lang/statementFor.ci:17: (75 bytes: <@05661e> - <@056669>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14482 @05661e>: 19                         load.z32
	<.main+14483 @05661f>: 04 3a 00 00                jmp <.main+14541 @056659>
	test/lang/statementFor.ci:18: (16 bytes: <@056623> - <@056633>): if (bool(i < 2))
	<.main+14487 @056623>: 10 00                      dup.x32 sp(0)
	<.main+14489 @056625>: 1c 02 00 00 00             load.c32 2
	<.main+14494 @05662a>: 58                         clt.i32
	<.main+14495 @05662b>: 06 08 00 00                jz <.main+14503 @056633>
	test/lang/statementFor.ci:19: (4 bytes: <@05662f> - <@056633>): continue;
	<.main+14499 @05662f>: 04 26 00 00                jmp <.main+14537 @056655>
	test/lang/statementFor.ci:21: (34 bytes: <@056633> - <@056655>): debug(void("for with continue", i));
	<.main+14503 @056633>: 1f 08 d0 04 00             load.ref <@04d008> ;"test/lang/statementFor.ci"
	<.main+14508 @056638>: 1c 15 00 00 00             load.c32 21
	<.main+14513 @05663d>: 1c 0e 00 00 00             load.c32 14
	<.main+14518 @056642>: 19                         load.z32
	<.main+14519 @056643>: 1f 7e d0 04 00             load.ref <@04d07e> ;"for with continue"
	<.main+14524 @056648>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14529 @05664d>: 0a 18 00 00                load.sp(+24)
	<.main+14533 @056651>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:17: (4 bytes: <@056655> - <@056659>): int32(i := int32(i + 1))
	<.main+14537 @056655>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:17: (12 bytes: <@056659> - <@056665>): bool(i < 7)
	<.main+14541 @056659>: 10 00                      dup.x32 sp(0)
	<.main+14543 @05665b>: 1c 07 00 00 00             load.c32 7
	<.main+14548 @056660>: 58                         clt.i32
	<.main+14549 @056661>: 05 c2 ff ff                jnz <.main+14487 @056623>
	<.main+14553 @056665>: 09 fc ff ff                inc.sp(-4)
	test/lang/statementFor.ci:24: (75 bytes: <@056669> - <@0566b4>): for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1)))
	<.main+14557 @056669>: 19                         load.z32
	<.main+14558 @05666a>: 04 3a 00 00                jmp <.main+14616 @0566a4>
	test/lang/statementFor.ci:25: (16 bytes: <@05666e> - <@05667e>): if (bool(i > 2))
	<.main+14562 @05666e>: 10 00                      dup.x32 sp(0)
	<.main+14564 @056670>: 1c 02 00 00 00             load.c32 2
	<.main+14569 @056675>: 59                         cgt.i32
	<.main+14570 @056676>: 06 08 00 00                jz <.main+14578 @05667e>
	test/lang/statementFor.ci:26: (4 bytes: <@05667a> - <@05667e>): break;
	<.main+14574 @05667a>: 04 36 00 00                jmp <.main+14628 @0566b0>
	test/lang/statementFor.ci:28: (34 bytes: <@05667e> - <@0566a0>): debug(void("for with break", i));
	<.main+14578 @05667e>: 1f 08 d0 04 00             load.ref <@04d008> ;"test/lang/statementFor.ci"
	<.main+14583 @056683>: 1c 1c 00 00 00             load.c32 28
	<.main+14588 @056688>: 1c 0e 00 00 00             load.c32 14
	<.main+14593 @05668d>: 19                         load.z32
	<.main+14594 @05668e>: 1f 90 d0 04 00             load.ref <@04d090> ;"for with break"
	<.main+14599 @056693>: 1f d0 03 00 00             load.ref <@0003d0> ;int32
	<.main+14604 @056698>: 0a 18 00 00                load.sp(+24)
	<.main+14608 @05669c>: 01 07 00 00                nfc(7) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang/statementFor.ci:24: (4 bytes: <@0566a0> - <@0566a4>): int32(i := int32(i + 1))
	<.main+14612 @0566a0>: 0c 01 00 00                inc.i32(+1)
	test/lang/statementFor.ci:24: (12 bytes: <@0566a4> - <@0566b0>): bool(i < 7)
	<.main+14616 @0566a4>: 10 00                      dup.x32 sp(0)
	<.main+14618 @0566a6>: 1c 07 00 00 00             load.c32 7
	<.main+14623 @0566ab>: 58                         clt.i32
	<.main+14624 @0566ac>: 05 c2 ff ff                jnz <.main+14562 @05666e>
	<.main+14628 @0566b0>: 09 fc ff ff                inc.sp(-4)
	<.main+14632 @0566b4>: 01 00 00 00                nfc(0) ;halt(): void
.usages:
}

---------- Execute: byte-code
[ 152.56] > .main
[ 152.84]  > funAdd(x: int32, y: int32): int32
[ 152.86]  < return
[ 152.87]  > funAdd(x: int32, y: int32): int32
[ 152.87]  < return
[ 152.88]  > funMul(x: int32, y: int32): int32
[ 152.89]  < return
[ 152.90]  > funMul(x: int32, y: int32): int32
[ 152.91]  < return
[ 152.91]  > fib(n: uint32): uint32
[ 152.92]   > fib(n: uint32): uint32
[ 152.93]    > fib(n: uint32): uint32
[ 152.94]     > fib(n: uint32): uint32
[ 152.95]      > fib(n: uint32): uint32
[ 152.96]       > fib(n: uint32): uint32
[ 152.97]        > fib(n: uint32): uint32
[ 152.98]         > fib(n: uint32): uint32
[ 152.99]          > fib(n: uint32): uint32
[ 152.99]           > fib(n: uint32): uint32
[ 153.00]            > fib(n: uint32): uint32
[ 153.01]             > fib(n: uint32): uint32
[ 153.02]              > fib(n: uint32): uint32
[ 153.03]              < return
[ 153.03]              > fib(n: uint32): uint32
[ 153.04]              < return
[ 153.04]             < return
[ 153.05]             > fib(n: uint32): uint32
[ 153.06]             < return
[ 153.06]            < return
[ 153.07]            > fib(n: uint32): uint32
[ 153.08]             > fib(n: uint32): uint32
[ 153.08]             < return
[ 153.09]             > fib(n: uint32): uint32
[ 153.10]             < return
[ 153.10]            < return
[ 153.11]           < return
[ 153.11]           > fib(n: uint32): uint32
[ 153.12]            > fib(n: uint32): uint32
[ 153.13]             > fib(n: uint32): uint32
[ 153.14]             < return
[ 153.14]             > fib(n: uint32): uint32
[ 153.15]             < return
[ 153.15]            < return
[ 153.16]            > fib(n: uint32): uint32
[ 153.17]            < return
[ 153.17]           < return
[ 153.18]          < return
[ 153.18]          > fib(n: uint32): uint32
[ 153.19]           > fib(n: uint32): uint32
[ 153.20]            > fib(n: uint32): uint32
[ 153.21]             > fib(n: uint32): uint32
[ 153.22]             < return
[ 153.22]             > fib(n: uint32): uint32
[ 153.23]             < return
[ 153.24]            < return
[ 153.24]            > fib(n: uint32): uint32
[ 153.25]            < return
[ 153.25]           < return
[ 153.26]           > fib(n: uint32): uint32
[ 153.27]            > fib(n: uint32): uint32
[ 153.27]            < return
[ 153.28]            > fib(n: uint32): uint32
[ 153.29]            < return
[ 153.29]           < return
[ 153.30]          < return
[ 153.30]         < return
[ 153.31]         > fib(n: uint32): uint32
[ 153.31]          > fib(n: uint32): uint32
[ 153.32]           > fib(n: uint32): uint32
[ 153.33]            > fib(n: uint32): uint32
[ 153.34]             > fib(n: uint32): uint32
[ 153.35]             < return
[ 153.35]             > fib(n: uint32): uint32
[ 153.36]             < return
[ 153.37]            < return
[ 153.37]            > fib(n: uint32): uint32
[ 153.38]            < return
[ 153.38]           < return
[ 153.39]           > fib(n: uint32): uint32
[ 153.40]            > fib(n: uint32): uint32
[ 153.40]            < return
[ 153.41]            > fib(n: uint32): uint32
[ 153.42]            < return
[ 153.43]           < return
[ 153.43]          < return
[ 153.43]          > fib(n: uint32): uint32
[ 153.44]           > fib(n: uint32): uint32
[ 153.45]            > fib(n: uint32): uint32
[ 153.46]            < return
[ 153.47]            > fib(n: uint32): uint32
[ 153.47]            < return
[ 153.48]           < return
[ 153.48]           > fib(n: uint32): uint32
[ 153.49]           < return
[ 153.50]          < return
[ 153.50]         < return
[ 153.50]        < return
[ 153.51]        > fib(n: uint32): uint32
[ 153.52]         > fib(n: uint32): uint32
[ 153.53]          > fib(n: uint32): uint32
[ 153.53]           > fib(n: uint32): uint32
[ 153.54]            > fib(n: uint32): uint32
[ 153.55]             > fib(n: uint32): uint32
[ 153.56]             < return
[ 153.56]             > fib(n: uint32): uint32
[ 153.57]             < return
[ 153.58]            < return
[ 153.58]            > fib(n: uint32): uint32
[ 153.59]            < return
[ 153.59]           < return
[ 153.60]           > fib(n: uint32): uint32
[ 153.61]            > fib(n: uint32): uint32
[ 153.62]            < return
[ 153.62]            > fib(n: uint32): uint32
[ 153.63]            < return
[ 153.63]           < return
[ 153.64]          < return
[ 153.64]          > fib(n: uint32): uint32
[ 153.65]           > fib(n: uint32): uint32
[ 153.66]            > fib(n: uint32): uint32
[ 153.67]            < return
[ 153.68]            > fib(n: uint32): uint32
[ 153.69]            < return
[ 153.69]           < return
[ 153.70]           > fib(n: uint32): uint32
[ 153.71]           < return
[ 153.71]          < return
[ 153.71]         < return
[ 153.72]         > fib(n: uint32): uint32
[ 153.73]          > fib(n: uint32): uint32
[ 153.74]           > fib(n: uint32): uint32
[ 153.75]            > fib(n: uint32): uint32
[ 153.75]            < return
[ 153.76]            > fib(n: uint32): uint32
[ 153.77]            < return
[ 153.77]           < return
[ 153.78]           > fib(n: uint32): uint32
[ 153.78]           < return
[ 153.79]          < return
[ 153.79]          > fib(n: uint32): uint32
[ 153.80]           > fib(n: uint32): uint32
[ 153.81]           < return
[ 153.81]           > fib(n: uint32): uint32
[ 153.82]           < return
[ 153.83]          < return
[ 153.83]         < return
[ 153.84]        < return
[ 153.84]       < return
[ 153.84]       > fib(n: uint32): uint32
[ 153.85]        > fib(n: uint32): uint32
[ 153.86]         > fib(n: uint32): uint32
[ 153.87]          > fib(n: uint32): uint32
[ 153.88]           > fib(n: uint32): uint32
[ 153.89]            > fib(n: uint32): uint32
[ 153.90]             > fib(n: uint32): uint32
[ 153.91]             < return
[ 153.91]             > fib(n: uint32): uint32
[ 153.92]             < return
[ 153.92]            < return
[ 153.93]            > fib(n: uint32): uint32
[ 153.94]            < return
[ 153.94]           < return
[ 153.94]           > fib(n: uint32): uint32
[ 153.95]            > fib(n: uint32): uint32
[ 153.96]            < return
[ 153.97]            > fib(n: uint32): uint32
[ 153.97]            < return
[ 153.98]           < return
[ 153.98]          < return
[ 153.99]          > fib(n: uint32): uint32
[ 154.00]           > fib(n: uint32): uint32
[ 154.00]            > fib(n: uint32): uint32
[ 154.01]            < return
[ 154.02]            > fib(n: uint32): uint32
[ 154.03]            < return
[ 154.03]           < return
[ 154.04]           > fib(n: uint32): uint32
[ 154.05]           < return
[ 154.05]          < return
[ 154.06]         < return
[ 154.06]         > fib(n: uint32): uint32
[ 154.07]          > fib(n: uint32): uint32
[ 154.08]           > fib(n: uint32): uint32
[ 154.09]            > fib(n: uint32): uint32
[ 154.10]            < return
[ 154.10]            > fib(n: uint32): uint32
[ 154.11]            < return
[ 154.12]           < return
[ 154.12]           > fib(n: uint32): uint32
[ 154.13]           < return
[ 154.13]          < return
[ 154.14]          > fib(n: uint32): uint32
[ 154.15]           > fib(n: uint32): uint32
[ 154.15]           < return
[ 154.16]           > fib(n: uint32): uint32
[ 154.17]           < return
[ 154.17]          < return
[ 154.18]         < return
[ 154.18]        < return
[ 154.18]        > fib(n: uint32): uint32
[ 154.19]         > fib(n: uint32): uint32
[ 154.20]          > fib(n: uint32): uint32
[ 154.21]           > fib(n: uint32): uint32
[ 154.22]            > fib(n: uint32): uint32
[ 154.23]            < return
[ 154.23]            > fib(n: uint32): uint32
[ 154.24]            < return
[ 154.24]           < return
[ 154.25]           > fib(n: uint32): uint32
[ 154.26]           < return
[ 154.26]          < return
[ 154.27]          > fib(n: uint32): uint32
[ 154.28]           > fib(n: uint32): uint32
[ 154.29]           < return
[ 154.29]           > fib(n: uint32): uint32
[ 154.30]           < return
[ 154.30]          < return
[ 154.31]         < return
[ 154.31]         > fib(n: uint32): uint32
[ 154.32]          > fib(n: uint32): uint32
[ 154.33]           > fib(n: uint32): uint32
[ 154.34]           < return
[ 154.34]           > fib(n: uint32): uint32
[ 154.35]           < return
[ 154.36]          < return
[ 154.36]          > fib(n: uint32): uint32
[ 154.37]          < return
[ 154.37]         < return
[ 154.38]        < return
[ 154.38]       < return
[ 154.39]      < return
[ 154.39]      > fib(n: uint32): uint32
[ 154.40]       > fib(n: uint32): uint32
[ 154.41]        > fib(n: uint32): uint32
[ 154.42]         > fib(n: uint32): uint32
[ 154.43]          > fib(n: uint32): uint32
[ 154.44]           > fib(n: uint32): uint32
[ 154.45]            > fib(n: uint32): uint32
[ 154.45]             > fib(n: uint32): uint32
[ 154.46]             < return
[ 154.47]             > fib(n: uint32): uint32
[ 154.47]             < return
[ 154.48]            < return
[ 154.48]            > fib(n: uint32): uint32
[ 154.49]            < return
[ 154.50]           < return
[ 154.50]           > fib(n: uint32): uint32
[ 154.51]            > fib(n: uint32): uint32
[ 154.52]            < return
[ 154.53]            > fib(n: uint32): uint32
[ 154.53]            < return
[ 154.54]           < return
[ 154.54]          < return
[ 154.55]          > fib(n: uint32): uint32
[ 154.56]           > fib(n: uint32): uint32
[ 154.57]            > fib(n: uint32): uint32
[ 154.57]            < return
[ 154.58]            > fib(n: uint32): uint32
[ 154.59]            < return
[ 154.59]           < return
[ 154.60]           > fib(n: uint32): uint32
[ 154.60]           < return
[ 154.61]          < return
[ 154.61]         < return
[ 154.62]         > fib(n: uint32): uint32
[ 154.63]          > fib(n: uint32): uint32
[ 154.63]           > fib(n: uint32): uint32
[ 154.64]            > fib(n: uint32): uint32
[ 154.65]            < return
[ 154.66]            > fib(n: uint32): uint32
[ 154.66]            < return
[ 154.67]           < return
[ 154.67]           > fib(n: uint32): uint32
[ 154.68]           < return
[ 154.69]          < return
[ 154.69]          > fib(n: uint32): uint32
[ 154.70]           > fib(n: uint32): uint32
[ 154.71]           < return
[ 154.71]           > fib(n: uint32): uint32
[ 154.72]           < return
[ 154.72]          < return
[ 154.73]         < return
[ 154.73]        < return
[ 154.74]        > fib(n: uint32): uint32
[ 154.75]         > fib(n: uint32): uint32
[ 154.75]          > fib(n: uint32): uint32
[ 154.76]           > fib(n: uint32): uint32
[ 154.77]            > fib(n: uint32): uint32
[ 154.78]            < return
[ 154.78]            > fib(n: uint32): uint32
[ 154.79]            < return
[ 154.80]           < return
[ 154.80]           > fib(n: uint32): uint32
[ 154.81]           < return
[ 154.81]          < return
[ 154.82]          > fib(n: uint32): uint32
[ 154.83]           > fib(n: uint32): uint32
[ 154.84]           < return
[ 154.84]           > fib(n: uint32): uint32
[ 154.85]           < return
[ 154.85]          < return
[ 154.86]         < return
[ 154.86]         > fib(n: uint32): uint32
[ 154.87]          > fib(n: uint32): uint32
[ 154.88]           > fib(n: uint32): uint32
[ 154.89]           < return
[ 154.90]           > fib(n: uint32): uint32
[ 154.90]           < return
[ 154.91]          < return
[ 154.91]          > fib(n: uint32): uint32
[ 154.92]          < return
[ 154.93]         < return
[ 154.93]        < return
[ 154.93]       < return
[ 154.94]       > fib(n: uint32): uint32
[ 154.95]        > fib(n: uint32): uint32
[ 154.96]         > fib(n: uint32): uint32
[ 154.96]          > fib(n: uint32): uint32
[ 154.97]           > fib(n: uint32): uint32
[ 154.98]            > fib(n: uint32): uint32
[ 154.99]            < return
[ 155.00]            > fib(n: uint32): uint32
[ 155.00]            < return
[ 155.01]           < return
[ 155.01]           > fib(n: uint32): uint32
[ 155.02]           < return
[ 155.02]          < return
[ 155.03]          > fib(n: uint32): uint32
[ 155.04]           > fib(n: uint32): uint32
[ 155.04]           < return
[ 155.05]           > fib(n: uint32): uint32
[ 155.06]           < return
[ 155.06]          < return
[ 155.07]         < return
[ 155.07]         > fib(n: uint32): uint32
[ 155.08]          > fib(n: uint32): uint32
[ 155.09]           > fib(n: uint32): uint32
[ 155.10]           < return
[ 155.11]           > fib(n: uint32): uint32
[ 155.11]           < return
[ 155.12]          < return
[ 155.12]          > fib(n: uint32): uint32
[ 155.13]          < return
[ 155.14]         < return
[ 155.14]        < return
[ 155.15]        > fib(n: uint32): uint32
[ 155.16]         > fib(n: uint32): uint32
[ 155.16]          > fib(n: uint32): uint32
[ 155.17]           > fib(n: uint32): uint32
[ 155.18]           < return
[ 155.19]           > fib(n: uint32): uint32
[ 155.19]           < return
[ 155.20]          < return
[ 155.20]          > fib(n: uint32): uint32
[ 155.21]          < return
[ 155.22]         < return
[ 155.22]         > fib(n: uint32): uint32
[ 155.23]          > fib(n: uint32): uint32
[ 155.24]          < return
[ 155.24]          > fib(n: uint32): uint32
[ 155.25]          < return
[ 155.25]         < return
[ 155.26]        < return
[ 155.26]       < return
[ 155.27]      < return
[ 155.27]     < return
[ 155.28]     > fib(n: uint32): uint32
[ 155.28]      > fib(n: uint32): uint32
[ 155.29]       > fib(n: uint32): uint32
[ 155.30]        > fib(n: uint32): uint32
[ 155.31]         > fib(n: uint32): uint32
[ 155.32]          > fib(n: uint32): uint32
[ 155.33]           > fib(n: uint32): uint32
[ 155.34]            > fib(n: uint32): uint32
[ 155.35]             > fib(n: uint32): uint32
[ 155.36]             < return
[ 155.36]             > fib(n: uint32): uint32
[ 155.37]             < return
[ 155.37]            < return
[ 155.38]            > fib(n: uint32): uint32
[ 155.39]            < return
[ 155.39]           < return
[ 155.40]           > fib(n: uint32): uint32
[ 155.41]            > fib(n: uint32): uint32
[ 155.41]            < return
[ 155.42]            > fib(n: uint32): uint32
[ 155.43]            < return
[ 155.43]           < return
[ 155.44]          < return
[ 155.44]          > fib(n: uint32): uint32
[ 155.45]           > fib(n: uint32): uint32
[ 155.46]            > fib(n: uint32): uint32
[ 155.46]            < return
[ 155.47]            > fib(n: uint32): uint32
[ 155.48]            < return
[ 155.48]           < return
[ 155.49]           > fib(n: uint32): uint32
[ 155.49]           < return
[ 155.50]          < return
[ 155.50]         < return
[ 155.51]         > fib(n: uint32): uint32
[ 155.52]          > fib(n: uint32): uint32
[ 155.53]           > fib(n: uint32): uint32
[ 155.53]            > fib(n: uint32): uint32
[ 155.54]            < return
[ 155.55]            > fib(n: uint32): uint32
[ 155.55]            < return
[ 155.56]           < return
[ 155.56]           > fib(n: uint32): uint32
[ 155.57]           < return
[ 155.58]          < return
[ 155.58]          > fib(n: uint32): uint32
[ 155.59]           > fib(n: uint32): uint32
[ 155.60]           < return
[ 155.60]           > fib(n: uint32): uint32
[ 155.61]           < return
[ 155.61]          < return
[ 155.62]         < return
[ 155.62]        < return
[ 155.63]        > fib(n: uint32): uint32
[ 155.64]         > fib(n: uint32): uint32
[ 155.65]          > fib(n: uint32): uint32
[ 155.65]           > fib(n: uint32): uint32
[ 155.66]            > fib(n: uint32): uint32
[ 155.67]            < return
[ 155.68]            > fib(n: uint32): uint32
[ 155.68]            < return
[ 155.69]           < return
[ 155.69]           > fib(n: uint32): uint32
[ 155.70]           < return
[ 155.71]          < return
[ 155.71]          > fib(n: uint32): uint32
[ 155.72]           > fib(n: uint32): uint32
[ 155.73]           < return
[ 155.74]           > fib(n: uint32): uint32
[ 155.74]           < return
[ 155.75]          < return
[ 155.75]         < return
[ 155.76]         > fib(n: uint32): uint32
[ 155.76]          > fib(n: uint32): uint32
[ 155.77]           > fib(n: uint32): uint32
[ 155.78]           < return
[ 155.79]           > fib(n: uint32): uint32
[ 155.79]           < return
[ 155.80]          < return
[ 155.80]          > fib(n: uint32): uint32
[ 155.81]          < return
[ 155.82]         < return
[ 155.82]        < return
[ 155.82]       < return
[ 155.83]       > fib(n: uint32): uint32
[ 155.84]        > fib(n: uint32): uint32
[ 155.85]         > fib(n: uint32): uint32
[ 155.85]          > fib(n: uint32): uint32
[ 155.86]           > fib(n: uint32): uint32
[ 155.87]            > fib(n: uint32): uint32
[ 155.88]            < return
[ 155.89]            > fib(n: uint32): uint32
[ 155.90]            < return
[ 155.90]           < return
[ 155.91]           > fib(n: uint32): uint32
[ 155.92]           < return
[ 155.92]          < return
[ 155.93]          > fib(n: uint32): uint32
[ 155.94]           > fib(n: uint32): uint32
[ 155.94]           < return
[ 155.95]           > fib(n: uint32): uint32
[ 155.96]           < return
[ 155.96]          < return
[ 155.97]         < return
[ 155.97]         > fib(n: uint32): uint32
[ 155.98]          > fib(n: uint32): uint32
[ 155.99]           > fib(n: uint32): uint32
[ 156.00]           < return
[ 156.00]           > fib(n: uint32): uint32
[ 156.01]           < return
[ 156.01]          < return
[ 156.02]          > fib(n: uint32): uint32
[ 156.03]          < return
[ 156.03]         < return
[ 156.03]        < return
[ 156.04]        > fib(n: uint32): uint32
[ 156.05]         > fib(n: uint32): uint32
[ 156.06]          > fib(n: uint32): uint32
[ 156.06]           > fib(n: uint32): uint32
[ 156.07]           < return
[ 156.08]           > fib(n: uint32): uint32
[ 156.09]           < return
[ 156.09]          < return
[ 156.10]          > fib(n: uint32): uint32
[ 156.11]          < return
[ 156.11]         < return
[ 156.12]         > fib(n: uint32): uint32
[ 156.13]          > fib(n: uint32): uint32
[ 156.13]          < return
[ 156.14]          > fib(n: uint32): uint32
[ 156.15]          < return
[ 156.15]         < return
[ 156.16]        < return
[ 156.16]       < return
[ 156.17]      < return
[ 156.18]      > fib(n: uint32): uint32
[ 156.19]       > fib(n: uint32): uint32
[ 156.19]        > fib(n: uint32): uint32
[ 156.20]         > fib(n: uint32): uint32
[ 156.21]          > fib(n: uint32): uint32
[ 156.22]           > fib(n: uint32): uint32
[ 156.23]            > fib(n: uint32): uint32
[ 156.24]            < return
[ 156.24]            > fib(n: uint32): uint32
[ 156.25]            < return
[ 156.25]           < return
[ 156.26]           > fib(n: uint32): uint32
[ 156.27]           < return
[ 156.27]          < return
[ 156.28]          > fib(n: uint32): uint32
[ 156.28]           > fib(n: uint32): uint32
[ 156.29]           < return
[ 156.30]           > fib(n: uint32): uint32
[ 156.31]           < return
[ 156.31]          < return
[ 156.31]         < return
[ 156.32]         > fib(n: uint32): uint32
[ 156.33]          > fib(n: uint32): uint32
[ 156.34]           > fib(n: uint32): uint32
[ 156.34]           < return
[ 156.35]           > fib(n: uint32): uint32
[ 156.36]           < return
[ 156.36]          < return
[ 156.37]          > fib(n: uint32): uint32
[ 156.38]          < return
[ 156.38]         < return
[ 156.38]        < return
[ 156.39]        > fib(n: uint32): uint32
[ 156.40]         > fib(n: uint32): uint32
[ 156.41]          > fib(n: uint32): uint32
[ 156.41]           > fib(n: uint32): uint32
[ 156.42]           < return
[ 156.43]           > fib(n: uint32): uint32
[ 156.44]           < return
[ 156.44]          < return
[ 156.44]          > fib(n: uint32): uint32
[ 156.45]          < return
[ 156.46]         < return
[ 156.46]         > fib(n: uint32): uint32
[ 156.47]          > fib(n: uint32): uint32
[ 156.48]          < return
[ 156.48]          > fib(n: uint32): uint32
[ 156.49]          < return
[ 156.50]         < return
[ 156.50]        < return
[ 156.50]       < return
[ 156.51]       > fib(n: uint32): uint32
[ 156.52]        > fib(n: uint32): uint32
[ 156.53]         > fib(n: uint32): uint32
[ 156.54]          > fib(n: uint32): uint32
[ 156.55]           > fib(n: uint32): uint32
[ 156.56]           < return
[ 156.56]           > fib(n: uint32): uint32
[ 156.57]           < return
[ 156.57]          < return
[ 156.58]          > fib(n: uint32): uint32
[ 156.59]          < return
[ 156.59]         < return
[ 156.59]         > fib(n: uint32): uint32
[ 156.60]          > fib(n: uint32): uint32
[ 156.61]          < return
[ 156.62]          > fib(n: uint32): uint32
[ 156.62]          < return
[ 156.63]         < return
[ 156.63]        < return
[ 156.64]        > fib(n: uint32): uint32
[ 156.65]         > fib(n: uint32): uint32
[ 156.66]          > fib(n: uint32): uint32
[ 156.66]          < return
[ 156.67]          > fib(n: uint32): uint32
[ 156.68]          < return
[ 156.68]         < return
[ 156.69]         > fib(n: uint32): uint32
[ 156.69]         < return
[ 156.70]        < return
[ 156.70]       < return
[ 156.71]      < return
[ 156.71]     < return
[ 156.72]    < return
[ 156.72]    > fib(n: uint32): uint32
[ 156.73]     > fib(n: uint32): uint32
[ 156.74]      > fib(n: uint32): uint32
[ 156.75]       > fib(n: uint32): uint32
[ 156.76]        > fib(n: uint32): uint32
[ 156.77]         > fib(n: uint32): uint32
[ 156.78]          > fib(n: uint32): uint32
[ 156.79]           > fib(n: uint32): uint32
[ 156.80]            > fib(n: uint32): uint32
[ 156.81]             > fib(n: uint32): uint32
[ 156.81]             < return
[ 156.82]             > fib(n: uint32): uint32
[ 156.83]             < return
[ 156.83]            < return
[ 156.84]            > fib(n: uint32): uint32
[ 156.84]            < return
[ 156.85]           < return
[ 156.85]           > fib(n: uint32): uint32
[ 156.86]            > fib(n: uint32): uint32
[ 156.87]            < return
[ 156.87]            > fib(n: uint32): uint32
[ 156.88]            < return
[ 156.89]           < return
[ 156.89]          < return
[ 156.90]          > fib(n: uint32): uint32
[ 156.90]           > fib(n: uint32): uint32
[ 156.91]            > fib(n: uint32): uint32
[ 156.92]            < return
[ 156.93]            > fib(n: uint32): uint32
[ 156.93]            < return
[ 156.94]           < return
[ 156.94]           > fib(n: uint32): uint32
[ 156.95]           < return
[ 156.96]          < return
[ 156.96]         < return
[ 156.96]         > fib(n: uint32): uint32
[ 156.97]          > fib(n: uint32): uint32
[ 156.98]           > fib(n: uint32): uint32
[ 156.99]            > fib(n: uint32): uint32
[ 157.00]            < return
[ 157.01]            > fib(n: uint32): uint32
[ 157.01]            < return
[ 157.02]           < return
[ 157.03]           > fib(n: uint32): uint32
[ 157.03]           < return
[ 157.04]          < return
[ 157.04]          > fib(n: uint32): uint32
[ 157.05]           > fib(n: uint32): uint32
[ 157.06]           < return
[ 157.06]           > fib(n: uint32): uint32
[ 157.07]           < return
[ 157.07]          < return
[ 157.08]         < return
[ 157.08]        < return
[ 157.09]        > fib(n: uint32): uint32
[ 157.10]         > fib(n: uint32): uint32
[ 157.11]          > fib(n: uint32): uint32
[ 157.12]           > fib(n: uint32): uint32
[ 157.12]            > fib(n: uint32): uint32
[ 157.13]            < return
[ 157.14]            > fib(n: uint32): uint32
[ 157.15]            < return
[ 157.15]           < return
[ 157.16]           > fib(n: uint32): uint32
[ 157.16]           < return
[ 157.17]          < return
[ 157.17]          > fib(n: uint32): uint32
[ 157.18]           > fib(n: uint32): uint32
[ 157.19]           < return
[ 157.19]           > fib(n: uint32): uint32
[ 157.20]           < return
[ 157.21]          < return
[ 157.21]         < return
[ 157.22]         > fib(n: uint32): uint32
[ 157.22]          > fib(n: uint32): uint32
[ 157.23]           > fib(n: uint32): uint32
[ 157.24]           < return
[ 157.25]           > fib(n: uint32): uint32
[ 157.25]           < return
[ 157.26]          < return
[ 157.26]          > fib(n: uint32): uint32
[ 157.27]          < return
[ 157.28]         < return
[ 157.28]        < return
[ 157.28]       < return
[ 157.29]       > fib(n: uint32): uint32
[ 157.30]        > fib(n: uint32): uint32
[ 157.31]         > fib(n: uint32): uint32
[ 157.31]          > fib(n: uint32): uint32
[ 157.32]           > fib(n: uint32): uint32
[ 157.33]            > fib(n: uint32): uint32
[ 157.34]            < return
[ 157.35]            > fib(n: uint32): uint32
[ 157.36]            < return
[ 157.36]           < return
[ 157.37]           > fib(n: uint32): uint32
[ 157.37]           < return
[ 157.38]          < return
[ 157.38]          > fib(n: uint32): uint32
[ 157.39]           > fib(n: uint32): uint32
[ 157.40]           < return
[ 157.41]           > fib(n: uint32): uint32
[ 157.41]           < return
[ 157.42]          < return
[ 157.42]         < return
[ 157.43]         > fib(n: uint32): uint32
[ 157.44]          > fib(n: uint32): uint32
[ 157.45]           > fib(n: uint32): uint32
[ 157.45]           < return
[ 157.46]           > fib(n: uint32): uint32
[ 157.47]           < return
[ 157.47]          < return
[ 157.48]          > fib(n: uint32): uint32
[ 157.48]          < return
[ 157.49]         < return
[ 157.49]        < return
[ 157.50]        > fib(n: uint32): uint32
[ 157.51]         > fib(n: uint32): uint32
[ 157.51]          > fib(n: uint32): uint32
[ 157.52]           > fib(n: uint32): uint32
[ 157.53]           < return
[ 157.54]           > fib(n: uint32): uint32
[ 157.54]           < return
[ 157.55]          < return
[ 157.56]          > fib(n: uint32): uint32
[ 157.57]          < return
[ 157.57]         < return
[ 157.58]         > fib(n: uint32): uint32
[ 157.58]          > fib(n: uint32): uint32
[ 157.59]          < return
[ 157.60]          > fib(n: uint32): uint32
[ 157.60]          < return
[ 157.61]         < return
[ 157.61]        < return
[ 157.62]       < return
[ 157.62]      < return
[ 157.63]      > fib(n: uint32): uint32
[ 157.64]       > fib(n: uint32): uint32
[ 157.65]        > fib(n: uint32): uint32
[ 157.65]         > fib(n: uint32): uint32
[ 157.66]          > fib(n: uint32): uint32
[ 157.67]           > fib(n: uint32): uint32
[ 157.68]            > fib(n: uint32): uint32
[ 157.69]            < return
[ 157.69]            > fib(n: uint32): uint32
[ 157.70]            < return
[ 157.70]           < return
[ 157.71]           > fib(n: uint32): uint32
[ 157.72]           < return
[ 157.72]          < return
[ 157.73]          > fib(n: uint32): uint32
[ 157.73]           > fib(n: uint32): uint32
[ 157.74]           < return
[ 157.75]           > fib(n: uint32): uint32
[ 157.75]           < return
[ 157.76]          < return
[ 157.76]         < return
[ 157.77]         > fib(n: uint32): uint32
[ 157.78]          > fib(n: uint32): uint32
[ 157.79]           > fib(n: uint32): uint32
[ 157.79]           < return
[ 157.80]           > fib(n: uint32): uint32
[ 157.81]           < return
[ 157.81]          < return
[ 157.82]          > fib(n: uint32): uint32
[ 157.83]          < return
[ 157.83]         < return
[ 157.84]        < return
[ 157.84]        > fib(n: uint32): uint32
[ 157.85]         > fib(n: uint32): uint32
[ 157.86]          > fib(n: uint32): uint32
[ 157.87]           > fib(n: uint32): uint32
[ 157.88]           < return
[ 157.88]           > fib(n: uint32): uint32
[ 157.89]           < return
[ 157.89]          < return
[ 157.90]          > fib(n: uint32): uint32
[ 157.91]          < return
[ 157.91]         < return
[ 157.91]         > fib(n: uint32): uint32
[ 157.92]          > fib(n: uint32): uint32
[ 157.93]          < return
[ 157.94]          > fib(n: uint32): uint32
[ 157.94]          < return
[ 157.95]         < return
[ 157.95]        < return
[ 157.96]       < return
[ 157.96]       > fib(n: uint32): uint32
[ 157.97]        > fib(n: uint32): uint32
[ 157.98]         > fib(n: uint32): uint32
[ 157.99]          > fib(n: uint32): uint32
[ 158.00]           > fib(n: uint32): uint32
[ 158.00]           < return
[ 158.01]           > fib(n: uint32): uint32
[ 158.02]           < return
[ 158.03]          < return
[ 158.03]          > fib(n: uint32): uint32
[ 158.04]          < return
[ 158.04]         < return
[ 158.05]         > fib(n: uint32): uint32
[ 158.06]          > fib(n: uint32): uint32
[ 158.06]          < return
[ 158.07]          > fib(n: uint32): uint32
[ 158.08]          < return
[ 158.08]         < return
[ 158.09]        < return
[ 158.09]        > fib(n: uint32): uint32
[ 158.10]         > fib(n: uint32): uint32
[ 158.11]          > fib(n: uint32): uint32
[ 158.12]          < return
[ 158.12]          > fib(n: uint32): uint32
[ 158.13]          < return
[ 158.14]         < return
[ 158.14]         > fib(n: uint32): uint32
[ 158.15]         < return
[ 158.15]        < return
[ 158.16]       < return
[ 158.16]      < return
[ 158.17]     < return
[ 158.17]     > fib(n: uint32): uint32
[ 158.19]      > fib(n: uint32): uint32
[ 158.19]       > fib(n: uint32): uint32
[ 158.20]        > fib(n: uint32): uint32
[ 158.21]         > fib(n: uint32): uint32
[ 158.22]          > fib(n: uint32): uint32
[ 158.23]           > fib(n: uint32): uint32
[ 158.24]            > fib(n: uint32): uint32
[ 158.25]            < return
[ 158.25]            > fib(n: uint32): uint32
[ 158.26]            < return
[ 158.26]           < return
[ 158.27]           > fib(n: uint32): uint32
[ 158.28]           < return
[ 158.28]          < return
[ 158.28]          > fib(n: uint32): uint32
[ 158.29]           > fib(n: uint32): uint32
[ 158.30]           < return
[ 158.31]           > fib(n: uint32): uint32
[ 158.31]           < return
[ 158.32]          < return
[ 158.32]         < return
[ 158.33]         > fib(n: uint32): uint32
[ 158.34]          > fib(n: uint32): uint32
[ 158.35]           > fib(n: uint32): uint32
[ 158.35]           < return
[ 158.36]           > fib(n: uint32): uint32
[ 158.37]           < return
[ 158.37]          < return
[ 158.38]          > fib(n: uint32): uint32
[ 158.39]          < return
[ 158.39]         < return
[ 158.40]        < return
[ 158.40]        > fib(n: uint32): uint32
[ 158.41]         > fib(n: uint32): uint32
[ 158.42]          > fib(n: uint32): uint32
[ 158.43]           > fib(n: uint32): uint32
[ 158.44]           < return
[ 158.44]           > fib(n: uint32): uint32
[ 158.45]           < return
[ 158.45]          < return
[ 158.46]          > fib(n: uint32): uint32
[ 158.47]          < return
[ 158.47]         < return
[ 158.47]         > fib(n: uint32): uint32
[ 158.48]          > fib(n: uint32): uint32
[ 158.49]          < return
[ 158.50]          > fib(n: uint32): uint32
[ 158.50]          < return
[ 158.51]         < return
[ 158.51]        < return
[ 158.52]       < return
[ 158.52]       > fib(n: uint32): uint32
[ 158.53]        > fib(n: uint32): uint32
[ 158.54]         > fib(n: uint32): uint32
[ 158.55]          > fib(n: uint32): uint32
[ 158.56]           > fib(n: uint32): uint32
[ 158.56]           < return
[ 158.57]           > fib(n: uint32): uint32
[ 158.58]           < return
[ 158.58]          < return
[ 158.59]          > fib(n: uint32): uint32
[ 158.59]          < return
[ 158.60]         < return
[ 158.60]         > fib(n: uint32): uint32
[ 158.61]          > fib(n: uint32): uint32
[ 158.62]          < return
[ 158.63]          > fib(n: uint32): uint32
[ 158.63]          < return
[ 158.64]         < return
[ 158.64]        < return
[ 158.65]        > fib(n: uint32): uint32
[ 158.66]         > fib(n: uint32): uint32
[ 158.67]          > fib(n: uint32): uint32
[ 158.68]          < return
[ 158.68]          > fib(n: uint32): uint32
[ 158.69]          < return
[ 158.69]         < return
[ 158.70]         > fib(n: uint32): uint32
[ 158.71]         < return
[ 158.71]        < return
[ 158.72]       < return
[ 158.72]      < return
[ 158.73]      > fib(n: uint32): uint32
[ 158.73]       > fib(n: uint32): uint32
[ 158.74]        > fib(n: uint32): uint32
[ 158.75]         > fib(n: uint32): uint32
[ 158.76]          > fib(n: uint32): uint32
[ 158.77]           > fib(n: uint32): uint32
[ 158.78]           < return
[ 158.78]           > fib(n: uint32): uint32
[ 158.79]           < return
[ 158.79]          < return
[ 158.80]          > fib(n: uint32): uint32
[ 158.81]          < return
[ 158.81]         < return
[ 158.82]         > fib(n: uint32): uint32
[ 158.82]          > fib(n: uint32): uint32
[ 158.83]          < return
[ 158.84]          > fib(n: uint32): uint32
[ 158.85]          < return
[ 158.85]         < return
[ 158.85]        < return
[ 158.86]        > fib(n: uint32): uint32
[ 158.87]         > fib(n: uint32): uint32
[ 158.88]          > fib(n: uint32): uint32
[ 158.88]          < return
[ 158.89]          > fib(n: uint32): uint32
[ 158.90]          < return
[ 158.90]         < return
[ 158.91]         > fib(n: uint32): uint32
[ 158.92]         < return
[ 158.92]        < return
[ 158.93]       < return
[ 158.93]       > fib(n: uint32): uint32
[ 158.94]        > fib(n: uint32): uint32
[ 158.95]         > fib(n: uint32): uint32
[ 158.96]          > fib(n: uint32): uint32
[ 158.96]          < return
[ 158.97]          > fib(n: uint32): uint32
[ 158.98]          < return
[ 158.98]         < return
[ 158.99]         > fib(n: uint32): uint32
[ 158.99]         < return
[ 159.00]        < return
[ 159.01]        > fib(n: uint32): uint32
[ 159.02]         > fib(n: uint32): uint32
[ 159.03]         < return
[ 159.03]         > fib(n: uint32): uint32
[ 159.04]         < return
[ 159.04]        < return
[ 159.05]       < return
[ 159.05]      < return
[ 159.06]     < return
[ 159.06]    < return
[ 159.06]   < return
[ 159.07]   > fib(n: uint32): uint32
[ 159.08]    > fib(n: uint32): uint32
[ 159.09]     > fib(n: uint32): uint32
[ 159.09]      > fib(n: uint32): uint32
[ 159.10]       > fib(n: uint32): uint32
[ 159.11]        > fib(n: uint32): uint32
[ 159.12]         > fib(n: uint32): uint32
[ 159.13]          > fib(n: uint32): uint32
[ 159.14]           > fib(n: uint32): uint32
[ 159.15]            > fib(n: uint32): uint32
[ 159.16]             > fib(n: uint32): uint32
[ 159.16]             < return
[ 159.17]             > fib(n: uint32): uint32
[ 159.18]             < return
[ 159.18]            < return
[ 159.19]            > fib(n: uint32): uint32
[ 159.19]            < return
[ 159.20]           < return
[ 159.20]           > fib(n: uint32): uint32
[ 159.21]            > fib(n: uint32): uint32
[ 159.22]            < return
[ 159.23]            > fib(n: uint32): uint32
[ 159.24]            < return
[ 159.24]           < return
[ 159.25]          < return
[ 159.25]          > fib(n: uint32): uint32
[ 159.26]           > fib(n: uint32): uint32
[ 159.27]            > fib(n: uint32): uint32
[ 159.28]            < return
[ 159.28]            > fib(n: uint32): uint32
[ 159.29]            < return
[ 159.29]           < return
[ 159.30]           > fib(n: uint32): uint32
[ 159.31]           < return
[ 159.31]          < return
[ 159.31]         < return
[ 159.32]         > fib(n: uint32): uint32
[ 159.33]          > fib(n: uint32): uint32
[ 159.34]           > fib(n: uint32): uint32
[ 159.34]            > fib(n: uint32): uint32
[ 159.35]            < return
[ 159.36]            > fib(n: uint32): uint32
[ 159.37]            < return
[ 159.37]           < return
[ 159.38]           > fib(n: uint32): uint32
[ 159.38]           < return
[ 159.39]          < return
[ 159.39]          > fib(n: uint32): uint32
[ 159.40]           > fib(n: uint32): uint32
[ 159.41]           < return
[ 159.41]           > fib(n: uint32): uint32
[ 159.42]           < return
[ 159.43]          < return
[ 159.43]         < return
[ 159.44]        < return
[ 159.44]        > fib(n: uint32): uint32
[ 159.45]         > fib(n: uint32): uint32
[ 159.46]          > fib(n: uint32): uint32
[ 159.47]           > fib(n: uint32): uint32
[ 159.48]            > fib(n: uint32): uint32
[ 159.49]            < return
[ 159.49]            > fib(n: uint32): uint32
[ 159.50]            < return
[ 159.50]           < return
[ 159.51]           > fib(n: uint32): uint32
[ 159.51]           < return
[ 159.52]          < return
[ 159.53]          > fib(n: uint32): uint32
[ 159.53]           > fib(n: uint32): uint32
[ 159.54]           < return
[ 159.55]           > fib(n: uint32): uint32
[ 159.55]           < return
[ 159.56]          < return
[ 159.56]         < return
[ 159.57]         > fib(n: uint32): uint32
[ 159.58]          > fib(n: uint32): uint32
[ 159.59]           > fib(n: uint32): uint32
[ 159.59]           < return
[ 159.60]           > fib(n: uint32): uint32
[ 159.60]           < return
[ 159.61]          < return
[ 159.61]          > fib(n: uint32): uint32
[ 159.62]          < return
[ 159.63]         < return
[ 159.63]        < return
[ 159.64]       < return
[ 159.64]       > fib(n: uint32): uint32
[ 159.65]        > fib(n: uint32): uint32
[ 159.66]         > fib(n: uint32): uint32
[ 159.67]          > fib(n: uint32): uint32
[ 159.68]           > fib(n: uint32): uint32
[ 159.69]            > fib(n: uint32): uint32
[ 159.69]            < return
[ 159.70]            > fib(n: uint32): uint32
[ 159.71]            < return
[ 159.71]           < return
[ 159.72]           > fib(n: uint32): uint32
[ 159.72]           < return
[ 159.73]          < return
[ 159.73]          > fib(n: uint32): uint32
[ 159.74]           > fib(n: uint32): uint32
[ 159.75]           < return
[ 159.75]           > fib(n: uint32): uint32
[ 159.76]           < return
[ 159.77]          < return
[ 159.77]         < return
[ 159.78]         > fib(n: uint32): uint32
[ 159.78]          > fib(n: uint32): uint32
[ 159.79]           > fib(n: uint32): uint32
[ 159.80]           < return
[ 159.81]           > fib(n: uint32): uint32
[ 159.81]           < return
[ 159.82]          < return
[ 159.82]          > fib(n: uint32): uint32
[ 159.84]          < return
[ 159.84]         < return
[ 159.84]        < return
[ 159.85]        > fib(n: uint32): uint32
[ 159.86]         > fib(n: uint32): uint32
[ 159.87]          > fib(n: uint32): uint32
[ 159.88]           > fib(n: uint32): uint32
[ 159.88]           < return
[ 159.89]           > fib(n: uint32): uint32
[ 159.90]           < return
[ 159.90]          < return
[ 159.91]          > fib(n: uint32): uint32
[ 159.91]          < return
[ 159.92]         < return
[ 159.92]         > fib(n: uint32): uint32
[ 159.93]          > fib(n: uint32): uint32
[ 159.94]          < return
[ 159.94]          > fib(n: uint32): uint32
[ 159.95]          < return
[ 159.96]         < return
[ 159.96]        < return
[ 159.97]       < return
[ 159.97]      < return
[ 159.97]      > fib(n: uint32): uint32
[ 159.98]       > fib(n: uint32): uint32
[ 159.99]        > fib(n: uint32): uint32
[ 160.00]         > fib(n: uint32): uint32
[ 160.01]          > fib(n: uint32): uint32
[ 160.02]           > fib(n: uint32): uint32
[ 160.03]            > fib(n: uint32): uint32
[ 160.04]            < return
[ 160.04]            > fib(n: uint32): uint32
[ 160.05]            < return
[ 160.06]           < return
[ 160.06]           > fib(n: uint32): uint32
[ 160.07]           < return
[ 160.07]          < return
[ 160.08]          > fib(n: uint32): uint32
[ 160.09]           > fib(n: uint32): uint32
[ 160.09]           < return
[ 160.10]           > fib(n: uint32): uint32
[ 160.11]           < return
[ 160.11]          < return
[ 160.12]         < return
[ 160.12]         > fib(n: uint32): uint32
[ 160.13]          > fib(n: uint32): uint32
[ 160.14]           > fib(n: uint32): uint32
[ 160.15]           < return
[ 160.15]           > fib(n: uint32): uint32
[ 160.16]           < return
[ 160.16]          < return
[ 160.17]          > fib(n: uint32): uint32
[ 160.18]          < return
[ 160.18]         < return
[ 160.19]        < return
[ 160.19]        > fib(n: uint32): uint32
[ 160.20]         > fib(n: uint32): uint32
[ 160.21]          > fib(n: uint32): uint32
[ 160.22]           > fib(n: uint32): uint32
[ 160.22]           < return
[ 160.23]           > fib(n: uint32): uint32
[ 160.24]           < return
[ 160.24]          < return
[ 160.25]          > fib(n: uint32): uint32
[ 160.25]          < return
[ 160.26]         < return
[ 160.26]         > fib(n: uint32): uint32
[ 160.27]          > fib(n: uint32): uint32
[ 160.28]          < return
[ 160.29]          > fib(n: uint32): uint32
[ 160.29]          < return
[ 160.30]         < return
[ 160.31]        < return
[ 160.31]       < return
[ 160.31]       > fib(n: uint32): uint32
[ 160.32]        > fib(n: uint32): uint32
[ 160.33]         > fib(n: uint32): uint32
[ 160.34]          > fib(n: uint32): uint32
[ 160.35]           > fib(n: uint32): uint32
[ 160.36]           < return
[ 160.36]           > fib(n: uint32): uint32
[ 160.37]           < return
[ 160.38]          < return
[ 160.38]          > fib(n: uint32): uint32
[ 160.39]          < return
[ 160.39]         < return
[ 160.40]         > fib(n: uint32): uint32
[ 160.41]          > fib(n: uint32): uint32
[ 160.42]          < return
[ 160.42]          > fib(n: uint32): uint32
[ 160.43]          < return
[ 160.43]         < return
[ 160.44]        < return
[ 160.44]        > fib(n: uint32): uint32
[ 160.45]         > fib(n: uint32): uint32
[ 160.46]          > fib(n: uint32): uint32
[ 160.47]          < return
[ 160.47]          > fib(n: uint32): uint32
[ 160.48]          < return
[ 160.49]         < return
[ 160.49]         > fib(n: uint32): uint32
[ 160.50]         < return
[ 160.50]        < return
[ 160.51]       < return
[ 160.51]      < return
[ 160.51]     < return
[ 160.52]     > fib(n: uint32): uint32
[ 160.53]      > fib(n: uint32): uint32
[ 160.54]       > fib(n: uint32): uint32
[ 160.55]        > fib(n: uint32): uint32
[ 160.56]         > fib(n: uint32): uint32
[ 160.56]          > fib(n: uint32): uint32
[ 160.57]           > fib(n: uint32): uint32
[ 160.58]            > fib(n: uint32): uint32
[ 160.59]            < return
[ 160.59]            > fib(n: uint32): uint32
[ 160.60]            < return
[ 160.61]           < return
[ 160.61]           > fib(n: uint32): uint32
[ 160.62]           < return
[ 160.62]          < return
[ 160.63]          > fib(n: uint32): uint32
[ 160.64]           > fib(n: uint32): uint32
[ 160.64]           < return
[ 160.65]           > fib(n: uint32): uint32
[ 160.66]           < return
[ 160.67]          < return
[ 160.67]         < return
[ 160.68]         > fib(n: uint32): uint32
[ 160.68]          > fib(n: uint32): uint32
[ 160.69]           > fib(n: uint32): uint32
[ 160.70]           < return
[ 160.71]           > fib(n: uint32): uint32
[ 160.71]           < return
[ 160.72]          < return
[ 160.72]          > fib(n: uint32): uint32
[ 160.73]          < return
[ 160.74]         < return
[ 160.74]        < return
[ 160.74]        > fib(n: uint32): uint32
[ 160.75]         > fib(n: uint32): uint32
[ 160.76]          > fib(n: uint32): uint32
[ 160.77]           > fib(n: uint32): uint32
[ 160.78]           < return
[ 160.78]           > fib(n: uint32): uint32
[ 160.79]           < return
[ 160.79]          < return
[ 160.80]          > fib(n: uint32): uint32
[ 160.81]          < return
[ 160.81]         < return
[ 160.82]         > fib(n: uint32): uint32
[ 160.82]          > fib(n: uint32): uint32
[ 160.83]          < return
[ 160.84]          > fib(n: uint32): uint32
[ 160.85]          < return
[ 160.85]         < return
[ 160.85]        < return
[ 160.86]       < return
[ 160.87]       > fib(n: uint32): uint32
[ 160.88]        > fib(n: uint32): uint32
[ 160.89]         > fib(n: uint32): uint32
[ 160.89]          > fib(n: uint32): uint32
[ 160.90]           > fib(n: uint32): uint32
[ 160.91]           < return
[ 160.92]           > fib(n: uint32): uint32
[ 160.92]           < return
[ 160.93]          < return
[ 160.93]          > fib(n: uint32): uint32
[ 160.94]          < return
[ 160.95]         < return
[ 160.95]         > fib(n: uint32): uint32
[ 160.96]          > fib(n: uint32): uint32
[ 160.97]          < return
[ 160.97]          > fib(n: uint32): uint32
[ 160.98]          < return
[ 160.98]         < return
[ 160.99]        < return
[ 160.99]        > fib(n: uint32): uint32
[ 161.00]         > fib(n: uint32): uint32
[ 161.01]          > fib(n: uint32): uint32
[ 161.02]          < return
[ 161.02]          > fib(n: uint32): uint32
[ 161.03]          < return
[ 161.04]         < return
[ 161.04]         > fib(n: uint32): uint32
[ 161.05]         < return
[ 161.05]        < return
[ 161.06]       < return
[ 161.06]      < return
[ 161.07]      > fib(n: uint32): uint32
[ 161.07]       > fib(n: uint32): uint32
[ 161.08]        > fib(n: uint32): uint32
[ 161.09]         > fib(n: uint32): uint32
[ 161.10]          > fib(n: uint32): uint32
[ 161.11]           > fib(n: uint32): uint32
[ 161.12]           < return
[ 161.12]           > fib(n: uint32): uint32
[ 161.13]           < return
[ 161.14]          < return
[ 161.15]          > fib(n: uint32): uint32
[ 161.15]          < return
[ 161.16]         < return
[ 161.16]         > fib(n: uint32): uint32
[ 161.17]          > fib(n: uint32): uint32
[ 161.18]          < return
[ 161.19]          > fib(n: uint32): uint32
[ 161.19]          < return
[ 161.20]         < return
[ 161.20]        < return
[ 161.21]        > fib(n: uint32): uint32
[ 161.22]         > fib(n: uint32): uint32
[ 161.22]          > fib(n: uint32): uint32
[ 161.23]          < return
[ 161.24]          > fib(n: uint32): uint32
[ 161.25]          < return
[ 161.25]         < return
[ 161.25]         > fib(n: uint32): uint32
[ 161.26]         < return
[ 161.27]        < return
[ 161.27]       < return
[ 161.28]       > fib(n: uint32): uint32
[ 161.28]        > fib(n: uint32): uint32
[ 161.29]         > fib(n: uint32): uint32
[ 161.30]          > fib(n: uint32): uint32
[ 161.31]          < return
[ 161.31]          > fib(n: uint32): uint32
[ 161.32]          < return
[ 161.33]         < return
[ 161.33]         > fib(n: uint32): uint32
[ 161.34]         < return
[ 161.34]        < return
[ 161.35]        > fib(n: uint32): uint32
[ 161.36]         > fib(n: uint32): uint32
[ 161.37]         < return
[ 161.37]         > fib(n: uint32): uint32
[ 161.38]         < return
[ 161.38]        < return
[ 161.39]       < return
[ 161.39]      < return
[ 161.40]     < return
[ 161.40]    < return
[ 161.41]    > fib(n: uint32): uint32
[ 161.41]     > fib(n: uint32): uint32
[ 161.42]      > fib(n: uint32): uint32
[ 161.43]       > fib(n: uint32): uint32
[ 161.44]        > fib(n: uint32): uint32
[ 161.45]         > fib(n: uint32): uint32
[ 161.46]          > fib(n: uint32): uint32
[ 161.47]           > fib(n: uint32): uint32
[ 161.47]            > fib(n: uint32): uint32
[ 161.48]            < return
[ 161.49]            > fib(n: uint32): uint32
[ 161.50]            < return
[ 161.50]           < return
[ 161.51]           > fib(n: uint32): uint32
[ 161.52]           < return
[ 161.52]          < return
[ 161.53]          > fib(n: uint32): uint32
[ 161.53]           > fib(n: uint32): uint32
[ 161.54]           < return
[ 161.55]           > fib(n: uint32): uint32
[ 161.56]           < return
[ 161.56]          < return
[ 161.56]         < return
[ 161.57]         > fib(n: uint32): uint32
[ 161.58]          > fib(n: uint32): uint32
[ 161.59]           > fib(n: uint32): uint32
[ 161.59]           < return
[ 161.60]           > fib(n: uint32): uint32
[ 161.61]           < return
[ 161.61]          < return
[ 161.62]          > fib(n: uint32): uint32
[ 161.62]          < return
[ 161.63]         < return
[ 161.63]        < return
[ 161.64]        > fib(n: uint32): uint32
[ 161.65]         > fib(n: uint32): uint32
[ 161.66]          > fib(n: uint32): uint32
[ 161.66]           > fib(n: uint32): uint32
[ 161.67]           < return
[ 161.68]           > fib(n: uint32): uint32
[ 161.68]           < return
[ 161.69]          < return
[ 161.69]          > fib(n: uint32): uint32
[ 161.70]          < return
[ 161.71]         < return
[ 161.71]         > fib(n: uint32): uint32
[ 161.72]          > fib(n: uint32): uint32
[ 161.73]          < return
[ 161.74]          > fib(n: uint32): uint32
[ 161.75]          < return
[ 161.75]         < return
[ 161.75]        < return
[ 161.76]       < return
[ 161.76]       > fib(n: uint32): uint32
[ 161.77]        > fib(n: uint32): uint32
[ 161.78]         > fib(n: uint32): uint32
[ 161.79]          > fib(n: uint32): uint32
[ 161.80]           > fib(n: uint32): uint32
[ 161.81]           < return
[ 161.81]           > fib(n: uint32): uint32
[ 161.82]           < return
[ 161.82]          < return
[ 161.83]          > fib(n: uint32): uint32
[ 161.84]          < return
[ 161.84]         < return
[ 161.84]         > fib(n: uint32): uint32
[ 161.85]          > fib(n: uint32): uint32
[ 161.86]          < return
[ 161.87]          > fib(n: uint32): uint32
[ 161.88]          < return
[ 161.88]         < return
[ 161.88]        < return
[ 161.89]        > fib(n: uint32): uint32
[ 161.90]         > fib(n: uint32): uint32
[ 161.91]          > fib(n: uint32): uint32
[ 161.91]          < return
[ 161.92]          > fib(n: uint32): uint32
[ 161.93]          < return
[ 161.93]         < return
[ 161.94]         > fib(n: uint32): uint32
[ 161.95]         < return
[ 161.95]        < return
[ 161.96]       < return
[ 161.96]      < return
[ 161.96]      > fib(n: uint32): uint32
[ 161.97]       > fib(n: uint32): uint32
[ 161.98]        > fib(n: uint32): uint32
[ 161.99]         > fib(n: uint32): uint32
[ 162.00]          > fib(n: uint32): uint32
[ 162.01]           > fib(n: uint32): uint32
[ 162.02]           < return
[ 162.03]           > fib(n: uint32): uint32
[ 162.03]           < return
[ 162.04]          < return
[ 162.04]          > fib(n: uint32): uint32
[ 162.05]          < return
[ 162.06]         < return
[ 162.06]         > fib(n: uint32): uint32
[ 162.07]          > fib(n: uint32): uint32
[ 162.08]          < return
[ 162.08]          > fib(n: uint32): uint32
[ 162.09]          < return
[ 162.10]         < return
[ 162.10]        < return
[ 162.10]        > fib(n: uint32): uint32
[ 162.11]         > fib(n: uint32): uint32
[ 162.12]          > fib(n: uint32): uint32
[ 162.13]          < return
[ 162.13]          > fib(n: uint32): uint32
[ 162.14]          < return
[ 162.15]         < return
[ 162.15]         > fib(n: uint32): uint32
[ 162.16]         < return
[ 162.16]        < return
[ 162.17]       < return
[ 162.17]       > fib(n: uint32): uint32
[ 162.18]        > fib(n: uint32): uint32
[ 162.19]         > fib(n: uint32): uint32
[ 162.20]          > fib(n: uint32): uint32
[ 162.21]          < return
[ 162.21]          > fib(n: uint32): uint32
[ 162.22]          < return
[ 162.23]         < return
[ 162.23]         > fib(n: uint32): uint32
[ 162.24]         < return
[ 162.24]        < return
[ 162.25]        > fib(n: uint32): uint32
[ 162.26]         > fib(n: uint32): uint32
[ 162.26]         < return
[ 162.27]         > fib(n: uint32): uint32
[ 162.28]         < return
[ 162.28]        < return
[ 162.29]       < return
[ 162.29]      < return
[ 162.29]     < return
[ 162.30]     > fib(n: uint32): uint32
[ 162.31]      > fib(n: uint32): uint32
[ 162.32]       > fib(n: uint32): uint32
[ 162.33]        > fib(n: uint32): uint32
[ 162.33]         > fib(n: uint32): uint32
[ 162.34]          > fib(n: uint32): uint32
[ 162.35]           > fib(n: uint32): uint32
[ 162.36]           < return
[ 162.37]           > fib(n: uint32): uint32
[ 162.37]           < return
[ 162.38]          < return
[ 162.38]          > fib(n: uint32): uint32
[ 162.39]          < return
[ 162.40]         < return
[ 162.40]         > fib(n: uint32): uint32
[ 162.41]          > fib(n: uint32): uint32
[ 162.42]          < return
[ 162.43]          > fib(n: uint32): uint32
[ 162.43]          < return
[ 162.44]         < return
[ 162.44]        < return
[ 162.45]        > fib(n: uint32): uint32
[ 162.46]         > fib(n: uint32): uint32
[ 162.46]          > fib(n: uint32): uint32
[ 162.47]          < return
[ 162.48]          > fib(n: uint32): uint32
[ 162.48]          < return
[ 162.49]         < return
[ 162.49]         > fib(n: uint32): uint32
[ 162.50]         < return
[ 162.51]        < return
[ 162.51]       < return
[ 162.51]       > fib(n: uint32): uint32
[ 162.52]        > fib(n: uint32): uint32
[ 162.53]         > fib(n: uint32): uint32
[ 162.54]          > fib(n: uint32): uint32
[ 162.55]          < return
[ 162.55]          > fib(n: uint32): uint32
[ 162.56]          < return
[ 162.57]         < return
[ 162.57]         > fib(n: uint32): uint32
[ 162.58]         < return
[ 162.58]        < return
[ 162.59]        > fib(n: uint32): uint32
[ 162.60]         > fib(n: uint32): uint32
[ 162.61]         < return
[ 162.61]         > fib(n: uint32): uint32
[ 162.62]         < return
[ 162.62]        < return
[ 162.63]       < return
[ 162.63]      < return
[ 162.64]      > fib(n: uint32): uint32
[ 162.65]       > fib(n: uint32): uint32
[ 162.66]        > fib(n: uint32): uint32
[ 162.66]         > fib(n: uint32): uint32
[ 162.67]          > fib(n: uint32): uint32
[ 162.68]          < return
[ 162.69]          > fib(n: uint32): uint32
[ 162.69]          < return
[ 162.70]         < return
[ 162.71]         > fib(n: uint32): uint32
[ 162.71]         < return
[ 162.72]        < return
[ 162.72]        > fib(n: uint32): uint32
[ 162.73]         > fib(n: uint32): uint32
[ 162.74]         < return
[ 162.74]         > fib(n: uint32): uint32
[ 162.75]         < return
[ 162.76]        < return
[ 162.76]       < return
[ 162.77]       > fib(n: uint32): uint32
[ 162.78]        > fib(n: uint32): uint32
[ 162.78]         > fib(n: uint32): uint32
[ 162.79]         < return
[ 162.80]         > fib(n: uint32): uint32
[ 162.80]         < return
[ 162.81]        < return
[ 162.81]        > fib(n: uint32): uint32
[ 162.82]        < return
[ 162.83]       < return
[ 162.83]      < return
[ 162.83]     < return
[ 162.84]    < return
[ 162.84]   < return
[ 162.85]  < return
[ 162.87]  > typename.name(type: typename): .cstr
[ 162.89]  < return
[ 162.90]  > typename.file(type: typename): .cstr
[ 162.91]  < return
[ 162.91]  > typename.line(type: typename): int32
[ 162.93]  < return
[ 162.93]  > typename.base(type: typename): typename
[ 162.94]  < return
[ 162.95]  > typename.name(type: typename): .cstr
[ 162.96]  < return
[ 162.97]  > typename.file(type: typename): .cstr
[ 162.98]  < return
[ 162.98]  > typename.line(type: typename): int32
[ 163.00]  < return
[ 163.00]  > typename.base(type: typename): typename
[ 163.01]  < return
[ 163.02]  > typename.base(type: typename): typename
[ 163.03]  < return
[ 163.06]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.07]  < return
[ 163.08]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.09]  < return
[ 163.09]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.10]  < return
[ 163.11]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.12]  < return
[ 163.12]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.13]  < return
[ 163.14]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.15]  < return
[ 163.15]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.16]  < return
[ 163.17]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.18]  < return
[ 163.18]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.19]  < return
[ 163.20]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.21]  < return
[ 163.21]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.22]  < return
[ 163.23]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.24]  < return
[ 163.25]  > float64.sin(x: float64): float64
[ 163.27]  < return
[ 163.28]  > float64.cos(x: float64): float64
[ 163.29]  < return
[ 163.29]  > float64.tan(x: float64): float64
[ 163.30]  < return
[ 163.31]  > float64.log(x: float64): float64
[ 163.32]  < return
[ 163.32]  > float64.exp(x: float64): float64
[ 163.33]  < return
[ 163.34]  > float64.pow(x: float64, y: float64): float64
[ 163.35]  < return
[ 163.36]  > float64.sqrt(x: float64): float64
[ 163.37]  < return
[ 163.37]  > float64.atan2(x: float64, y: float64): float64
[ 163.38]  < return
[ 163.39]  > float32.sin(x: float32): float32
[ 163.40]  < return
[ 163.41]  > float32.cos(x: float32): float32
[ 163.42]  < return
[ 163.42]  > float32.tan(x: float32): float32
[ 163.43]  < return
[ 163.44]  > float32.log(x: float32): float32
[ 163.45]  < return
[ 163.46]  > float32.exp(x: float32): float32
[ 163.47]  < return
[ 163.47]  > float32.pow(x: float32, y: float32): float32
[ 163.49]  < return
[ 163.49]  > float32.sqrt(x: float32): float32
[ 163.50]  < return
[ 163.51]  > float32.atan2(x: float32, y: float32): float32
[ 163.52]  < return
[ 163.52]  > uint32.pop(value: int32): int32
[ 163.53]  < return
[ 163.54]  > uint32.swap(value: int32): int32
[ 163.55]  < return
[ 163.55]  > uint32.bsr(value: int32): int32
[ 163.56]  < return
[ 163.57]  > uint32.bsf(value: int32): int32
[ 163.57]  < return
[ 163.58]  > uint32.hib(value: int32): int32
[ 163.59]  < return
[ 163.59]  > uint32.lob(value: int32): int32
[ 163.60]  < return
[ 163.61]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 163.62]  < return
[ 163.63]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 163.64]  < return
[ 163.65]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 163.65]  < return
[ 163.66]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 163.67]  < return
[ 163.68]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 163.69]  < return
[ 163.69]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 163.70]  < return
[ 163.71]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 163.72]  < return
[ 163.73]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 163.74]  < return
[ 163.75]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 163.75]   > noError(ptr: pointer): void
[ 163.76]   < return
[ 163.77]   > halt(): void
[ 163.77]   < return
[ 163.78]  < return
[ 163.78]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 163.79]  < return
[ 163.80]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 163.81]   > stackOverflow(ptr: pointer): void
[ 163.81]    > stackOverflow(ptr: pointer): void
[ 163.82]     > stackOverflow(ptr: pointer): void
[ 163.83]      > stackOverflow(ptr: pointer): void
[ 163.84]       > stackOverflow(ptr: pointer): void
[ 163.85]        > stackOverflow(ptr: pointer): void
[ 163.86]         > stackOverflow(ptr: pointer): void
[ 163.86]          > stackOverflow(ptr: pointer): void
[ 163.87]           > stackOverflow(ptr: pointer): void
[ 163.88]            > stackOverflow(ptr: pointer): void
[ 163.89]             > stackOverflow(ptr: pointer): void
[ 163.90]              > stackOverflow(ptr: pointer): void
[ 163.90]               > stackOverflow(ptr: pointer): void
[ 163.91]                > stackOverflow(ptr: pointer): void
[ 163.92]                 > stackOverflow(ptr: pointer): void
[ 163.93]                  > stackOverflow(ptr: pointer): void
[ 163.94]                   > stackOverflow(ptr: pointer): void
[ 163.94]                    > stackOverflow(ptr: pointer): void
[ 163.95]                     > stackOverflow(ptr: pointer): void
[ 163.96]                      > stackOverflow(ptr: pointer): void
[ 163.97]                       > stackOverflow(ptr: pointer): void
[ 163.98]                        > stackOverflow(ptr: pointer): void
[ 163.99]                         > stackOverflow(ptr: pointer): void
[ 163.99]                          > stackOverflow(ptr: pointer): void
[ 164.00]                           > stackOverflow(ptr: pointer): void
[ 164.01]                            > stackOverflow(ptr: pointer): void
[ 164.02]                             > stackOverflow(ptr: pointer): void
[ 164.03]                              > stackOverflow(ptr: pointer): void
[ 164.03]                               > stackOverflow(ptr: pointer): void
[ 164.04]                                > stackOverflow(ptr: pointer): void
[ 164.05]                                 > stackOverflow(ptr: pointer): void
[ 164.06]                                  > stackOverflow(ptr: pointer): void
[ 164.07]                                   > stackOverflow(ptr: pointer): void
[ 164.07]                                    > stackOverflow(ptr: pointer): void
[ 164.08]                                     > stackOverflow(ptr: pointer): void
[ 164.09]                                      > stackOverflow(ptr: pointer): void
[ 164.10]                                       > stackOverflow(ptr: pointer): void
[ 164.11]                                        > stackOverflow(ptr: pointer): void
[ 164.12]                                         > stackOverflow(ptr: pointer): void
[ 164.13]                                          > stackOverflow(ptr: pointer): void
[ 164.14]                                           > stackOverflow(ptr: pointer): void
[ 164.14]                                            > stackOverflow(ptr: pointer): void
[ 164.15]                                             > stackOverflow(ptr: pointer): void
[ 164.16]                                              > stackOverflow(ptr: pointer): void
[ 164.17]                                               > stackOverflow(ptr: pointer): void
[ 164.18]                                                > stackOverflow(ptr: pointer): void
[ 164.19]                                                 > stackOverflow(ptr: pointer): void
[ 164.19]                                                  > stackOverflow(ptr: pointer): void
[ 164.20]                                                   > stackOverflow(ptr: pointer): void
[ 164.21]                                                    > stackOverflow(ptr: pointer): void
[ 164.22]                                                     > stackOverflow(ptr: pointer): void
[ 164.23]                                                      > stackOverflow(ptr: pointer): void
[ 164.24]                                                       > stackOverflow(ptr: pointer): void
[ 164.24]                                                        > stackOverflow(ptr: pointer): void
[ 164.25]                                                         > stackOverflow(ptr: pointer): void
[ 164.26]                                                          > stackOverflow(ptr: pointer): void
[ 164.27]                                                           > stackOverflow(ptr: pointer): void
[ 164.28]                                                            > stackOverflow(ptr: pointer): void
[ 164.28]                                                             > stackOverflow(ptr: pointer): void
[ 164.29]                                                              > stackOverflow(ptr: pointer): void
[ 164.30]                                                               > stackOverflow(ptr: pointer): void
[ 164.31]                                                                > stackOverflow(ptr: pointer): void
[ 164.32]                                                                 > stackOverflow(ptr: pointer): void
[ 164.33]                                                                  > stackOverflow(ptr: pointer): void
[ 164.34]                                                                  < return
[ 164.34]                                                                 < return
[ 164.34]                                                                < return
[ 164.35]                                                               < return
[ 164.35]                                                              < return
[ 164.36]                                                             < return
[ 164.36]                                                            < return
[ 164.37]                                                           < return
[ 164.37]                                                          < return
[ 164.37]                                                         < return
[ 164.38]                                                        < return
[ 164.38]                                                       < return
[ 164.38]                                                      < return
[ 164.39]                                                     < return
[ 164.39]                                                    < return
[ 164.40]                                                   < return
[ 164.40]                                                  < return
[ 164.41]                                                 < return
[ 164.41]                                                < return
[ 164.41]                                               < return
[ 164.42]                                              < return
[ 164.42]                                             < return
[ 164.42]                                            < return
[ 164.43]                                           < return
[ 164.43]                                          < return
[ 164.44]                                         < return
[ 164.44]                                        < return
[ 164.44]                                       < return
[ 164.45]                                      < return
[ 164.45]                                     < return
[ 164.46]                                    < return
[ 164.46]                                   < return
[ 164.47]                                  < return
[ 164.47]                                 < return
[ 164.47]                                < return
[ 164.48]                               < return
[ 164.48]                              < return
[ 164.49]                             < return
[ 164.49]                            < return
[ 164.49]                           < return
[ 164.50]                          < return
[ 164.50]                         < return
[ 164.50]                        < return
[ 164.51]                       < return
[ 164.51]                      < return
[ 164.52]                     < return
[ 164.52]                    < return
[ 164.53]                   < return
[ 164.53]                  < return
[ 164.53]                 < return
[ 164.54]                < return
[ 164.54]               < return
[ 164.54]              < return
[ 164.55]             < return
[ 164.55]            < return
[ 164.56]           < return
[ 164.56]          < return
[ 164.56]         < return
[ 164.57]        < return
[ 164.58]       < return
[ 164.58]      < return
[ 164.58]     < return
[ 164.59]    < return
[ 164.59]   < return
[ 164.60]  < return
[ 164.60]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 164.61]   > divisionByZero(args: pointer): void
[ 164.62]   < return
[ 164.62]  < return
[ 164.63]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 164.63]   > invalidInstruction(args: pointer): void
[ 164.64]   < return
[ 164.65]  < return
[ 164.65]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 164.66]   > invalidMemoryAccess(args: pointer): void
[ 164.67]   < return
[ 164.67]  < return
[ 164.68]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 164.69]   > abortExecution(args: pointer): void
[ 164.70]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/tryExec.ci:34: fatal: fatal error: NotEquals({
	message: "assertion failed",
	expected: 97,
	returned: 77
})
	native.code:: abortExecution(args: null)
	test/stdc/tryExec.ci:52: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 164.75]    < return
[ 164.76]   < return
[ 164.76]  < return
[ 165.56]  > Math.floor(x: float64): float64
[ 165.57]   > Math.modf(x: float64, intPart: float64): float64
[ 165.57]   < return
[ 165.58]  < return
[ 165.58]  > Math.floor(x: float64): float64
[ 165.59]   > Math.modf(x: float64, intPart: float64): float64
[ 165.59]   < return
[ 165.60]  < return
[ 165.60]  > Math.floor(x: float64): float64
[ 165.61]   > Math.modf(x: float64, intPart: float64): float64
[ 165.61]   < return
[ 165.62]  < return
[ 165.63]  > Math.floor(x: float64): float64
[ 165.63]   > Math.modf(x: float64, intPart: float64): float64
[ 165.63]    > Math.modf(x: float64, intPart: float64): float64
[ 165.64]    < return
[ 165.64]   < return
[ 165.65]  < return
[ 165.66]  > Math.floor(x: float64): float64
[ 165.66]   > Math.modf(x: float64, intPart: float64): float64
[ 165.66]    > Math.modf(x: float64, intPart: float64): float64
[ 165.67]    < return
[ 165.67]   < return
[ 165.68]  < return
[ 165.68]  > Math.floor(x: float64): float64
[ 165.69]   > Math.modf(x: float64, intPart: float64): float64
[ 165.69]    > Math.modf(x: float64, intPart: float64): float64
[ 165.70]    < return
[ 165.70]   < return
[ 165.70]  < return
[ 165.76]  > Math.abs(x: float64): float64
[ 165.76]  < return
[ 165.77]  > Math.abs(x: float64): float64
[ 165.78]  < return
[ 165.78]  > Math.abs(x: float64): float64
[ 165.79]  < return
[ 165.80]  > Math.abs(x: float32): float32
[ 165.81]  < return
[ 165.82]  > Math.abs(x: float32): float32
[ 165.82]  < return
[ 165.83]  > Math.abs(x: float32): float32
[ 165.83]  < return
[ 165.84]  > Math.min(a: float32, b: float32): float32
[ 165.85]  < return
[ 165.86]  > Math.max(a: float32, b: float32): float32
[ 165.86]  < return
[ 165.87]  > Math.min(a: float64, b: float64): float64
[ 165.88]  < return
[ 165.89]  > Math.max(a: float64, b: float64): float64
[ 165.89]  < return
[ 165.90]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 165.91]  < return
[ 165.92]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 165.92]  < return
[ 165.95]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 165.96]  < return
[ 165.98]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 165.99]  < return
[ 166.00]  > Math.min(data: float64[]): float64
[ 166.01]  < return
[ 166.03]  > Math.min(data: float64[]): float64
[ 166.05]  < return
[ 166.06]  > Math.max(data: float64[]): float64
[ 166.07]  < return
[ 166.08]  > Math.max(data: float64[]): float64
[ 166.10]  < return
[ 166.11]  > Math.sum(data: float64[]): float64
[ 166.12]  < return
[ 166.13]  > Math.sum(data: float64[]): float64
[ 166.14]  < return
[ 166.15]  > Math.sum(data: float64[]): float64
[ 166.16]  < return
[ 166.18]  > Math.sum(data: float64[]): float64
[ 166.20]  < return
[ 166.21]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 166.22]  < return
[ 166.26]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 166.27]  < return
[ 166.29]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 166.31]  < return
[ 166.32]  > Math.sinCos(arg: float64, quad: int32): float64
[ 166.33]  < return
[ 166.34]  > Math.abs(x: float64): float64
[ 166.35]  < return
[ 166.35]  > Math.sinCos(arg: float64, quad: int32): float64
[ 166.37]  < return
[ 166.38]  > Math.tan(arg: float64): float64
[ 166.38]   > Math.modf(x: float64, intPart: float64): float64
[ 166.39]   < return
[ 166.40]  < return
[ 166.41]  > Math.sinh(x: float64): float64
[ 166.42]   > float64.exp(x: float64): float64
[ 166.43]   < return
[ 166.43]   > float64.exp(x: float64): float64
[ 166.44]   < return
[ 166.45]  < return
[ 166.46]  > Math.cosh(x: float64): float64
[ 166.46]   > float64.exp(x: float64): float64
[ 166.47]   < return
[ 166.47]   > float64.exp(x: float64): float64
[ 166.48]   < return
[ 166.49]  < return
[ 166.50]  > Math.asin(x: float64): float64
[ 166.50]   > float64.sqrt(x: float64): float64
[ 166.51]   < return
[ 166.51]   > float64.atan2(x: float64, y: float64): float64
[ 166.52]   < return
[ 166.53]  < return
[ 166.54]  > Math.asin(x: float64): float64
[ 166.55]   > float64.sqrt(x: float64): float64
[ 166.56]   < return
[ 166.56]   > float64.atan2(x: float64, y: float64): float64
[ 166.57]   < return
[ 166.57]  < return
[ 166.58]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 166.59]  < return
[ 166.60]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 166.61]  < return
[ 166.62]  > Math.absMod(val: float64, mod: float64): float64
[ 166.62]  < return
[ 166.63]  > Math.absMod(val: float64, mod: float64): float64
[ 166.64]  < return
[ 166.65]  > Math.absMod(val: float64, mod: float64): float64
[ 166.65]  < return
[ 166.66]  > Math.absMod(val: float64, mod: float64): float64
[ 166.67]  < return
[ 166.68]  > Math.absMod(val: float64, mod: float64): float64
[ 166.68]  < return
[ 166.69]  > Math.absMod(val: float64, mod: float64): float64
[ 166.70]  < return
[ 166.71]  > Math.absMod(val: float64, mod: float64): float64
[ 166.71]  < return
[ 166.72]  > Math.absMod(val: float64, mod: float64): float64
[ 166.73]  < return
[ 166.74]  > Math.absMod(val: float64, mod: float64): float64
[ 166.74]  < return
[ 166.75]  > Math.absMod(val: float64, mod: float64): float64
[ 166.75]  < return
[ 166.76]  > Math.absMod(val: float64, mod: float64): float64
[ 166.77]  < return
[ 166.78]  > Math.absMod(val: float32, mod: float32): float32
[ 166.78]  < return
[ 166.79]  > Math.absMod(val: float32, mod: float32): float32
[ 166.80]  < return
[ 166.81]  > Math.absMod(val: float32, mod: float32): float32
[ 166.81]  < return
[ 166.82]  > Math.absMod(val: float32, mod: float32): float32
[ 166.83]  < return
[ 166.84]  > Math.absMod(val: float32, mod: float32): float32
[ 166.84]  < return
[ 166.85]  > Math.absMod(val: float32, mod: float32): float32
[ 166.85]  < return
[ 166.86]  > Math.absMod(val: float32, mod: float32): float32
[ 166.87]  < return
[ 166.88]  > Math.absMod(val: float32, mod: float32): float32
[ 166.89]  < return
[ 166.90]  > Math.absMod(val: float32, mod: float32): float32
[ 166.90]  < return
[ 166.91]  > Math.absMod(val: float32, mod: float32): float32
[ 166.92]  < return
[ 166.93]  > Math.absMod(val: float32, mod: float32): float32
[ 166.93]  < return
[ 166.94]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 166.95]  < return
[ 166.96]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 166.97]  < return
[ 166.98]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 166.99]  < return
[ 167.00]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 167.01]  < return
[ 167.01]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 167.02]  < return
[ 167.03]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 167.04]  < return
[ 167.05]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:26: debug: val1: int64(42)
[ 167.07]  < return
[ 167.08]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:27: debug: val2: int64(96)
[ 167.09]  < return
[ 167.10]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 167.11]  < return
[ 167.12]  > pointer.fill(dst: pointer, value: int32, size: int32): pointer
[ 167.12]  < return
[ 167.14]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:32: debug: val1: int64(0)
[ 167.15]  < return
[ 167.16]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/stdc/memory.ci:33: debug: val2: int64(42)
[ 167.18]  < return
[ 167.26]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 167.27]  < return
[ 167.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 167.32]  < return
[ 167.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 167.37]  < return
[ 167.38]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:87: debug: string as variant: char[*]("string")
[ 167.39]  < return
[ 167.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:88: debug: string to variant: char[*]("string")
[ 167.42]  < return
[ 167.43]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:91: debug: string as variant: char[]([0] {})
[ 167.44]  < return
[ 167.45]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/array.ci:92: debug: string to variant: char[]([0] {})
[ 167.47]  < return
[ 167.49]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.49]  < return
[ 167.50]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.51]  < return
[ 167.52]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.53]  < return
[ 167.53]  > lenSlice(values: int64[]): int32
[ 167.54]  < return
[ 167.55]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.56]  < return
[ 167.56]  > lenSlice(values: int64[]): int32
[ 167.57]  < return
[ 167.58]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.59]  < return
[ 167.60]  > lenSlice(values: int64[]): int32
[ 167.60]  < return
[ 167.61]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.62]  < return
[ 167.63]  > lenSlice(values: int64[]): int32
[ 167.63]  < return
[ 167.64]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.65]  < return
[ 167.66]  > lenSlice(values: int64[]): int32
[ 167.67]  < return
[ 167.68]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 167.68]  < return
[ 167.71]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.72]  < return
[ 167.74]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.75]  < return
[ 167.76]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.77]  < return
[ 167.79]  > nthArray(idx: int32, values: int64[*]): int64
[ 167.80]  < return
[ 167.81]  > nthArray(idx: int32, values: int64[*]): int64
[ 167.82]  < return
[ 167.83]  > nthArray(idx: int32, values: int64[*]): int64
[ 167.84]  < return
[ 167.85]  > nthSlice(idx: int32, values: int64[]): int64
[ 167.86]  < return
[ 167.88]  > nthSlice(idx: int32, values: int64[]): int64
[ 167.89]  < return
[ 167.93]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.94]  < return
[ 167.95]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.96]  < return
[ 167.97]  > nthFixed(idx: int32, values: int64[7]): int64
[ 167.98]  < return
[ 168.00]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.01]  < return
[ 168.02]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.03]  < return
[ 168.04]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.06]  < return
[ 168.07]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.08]  < return
[ 168.09]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.10]  < return
[ 168.14]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.15]  < return
[ 168.16]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.18]  < return
[ 168.19]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.20]  < return
[ 168.21]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.22]  < return
[ 168.23]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.24]  < return
[ 168.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.26]  < return
[ 168.28]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.29]  < return
[ 168.30]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.31]  < return
[ 168.35]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.36]  < return
[ 168.38]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.39]  < return
[ 168.40]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.41]  < return
[ 168.42]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.44]  < return
[ 168.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.46]  < return
[ 168.47]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.48]  < return
[ 168.49]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.50]  < return
[ 168.51]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.52]  < return
[ 168.57]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.58]  < return
[ 168.59]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.60]  < return
[ 168.62]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.63]  < return
[ 168.64]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.65]  < return
[ 168.66]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.67]  < return
[ 168.68]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.69]  < return
[ 168.71]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.72]  < return
[ 168.73]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.74]  < return
[ 168.78]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.79]  < return
[ 168.80]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.81]  < return
[ 168.83]  > nthFixed(idx: int32, values: int64[7]): int64
[ 168.84]  < return
[ 168.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.86]  < return
[ 168.87]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.88]  < return
[ 168.90]  > nthArray(idx: int32, values: int64[*]): int64
[ 168.91]  < return
[ 168.92]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.93]  < return
[ 168.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 168.95]  < return
[ 168.99]  > nthFixed(idx: int32, values: int64[7]): int64
[ 169.00]  < return
[ 169.02]  > nthFixed(idx: int32, values: int64[7]): int64
[ 169.03]  < return
[ 169.04]  > nthFixed(idx: int32, values: int64[7]): int64
[ 169.05]  < return
[ 169.06]  > nthArray(idx: int32, values: int64[*]): int64
[ 169.07]  < return
[ 169.09]  > nthArray(idx: int32, values: int64[*]): int64
[ 169.09]  < return
[ 169.11]  > nthArray(idx: int32, values: int64[*]): int64
[ 169.12]  < return
[ 169.13]  > nthSlice(idx: int32, values: int64[]): int64
[ 169.14]  < return
[ 169.15]  > nthSlice(idx: int32, values: int64[]): int64
[ 169.16]  < return
[ 169.19]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 169.19]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(1)
	test/lang/method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 169.25]   < return
[ 169.26]  < return
[ 169.27]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 169.28]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(1)
	test/lang/method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 169.33]   < return
[ 169.33]  < return
[ 169.34]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 169.35]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:85: debug: extension.staticMethod
[ 169.36]   < return
[ 169.37]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 169.38]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(2)
	test/lang/method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:97: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 169.47]    < return
[ 169.47]   < return
[ 169.48]  < return
[ 169.49]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 169.50]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:91: debug: extension.virtualMethod
[ 169.51]   < return
[ 169.51]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 169.52]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(2)
	test/lang/method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	test/lang/method.ci:98: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	native.code:: .main
[ 169.61]    < return
[ 169.62]   < return
[ 169.62]  < return
[ 169.63]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 169.64]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:11: debug: staticMethod: int32(3)
	test/lang/method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 169.69]   < return
[ 169.70]  < return
[ 169.71]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 169.72]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 169.77]   < return
[ 169.78]  < return
[ 169.79]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 169.80]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/method.ci:41: debug: virtualMethod: int32(3)
	test/lang/method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 169.85]   < return
[ 169.85]  < return
[ 169.87]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:4: debug: 0 == 0
	... 1 more
[ 169.88]  < return
[ 169.89]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:12: debug: 0 == 0
	native.code:: .main
[ 169.90]  < return
[ 169.91]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:22: debug: 0 == 0
	native.code:: .main
[ 169.92]  < return
[ 169.94]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 169.95]  < return
[ 169.97]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 169.98]  < return
[ 170.00]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 170.02]  < return
[ 170.03]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 170.05]  < return
[ 170.06]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:4: debug: for ( ; ; )
[ 170.07]  < return
[ 170.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 170.10]  < return
[ 170.12]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 170.13]  < return
[ 170.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 170.16]  < return
[ 170.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 170.19]  < return
[ 170.24]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(2)
[ 170.25]  < return
[ 170.27]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(3)
[ 170.28]  < return
[ 170.30]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(4)
[ 170.31]  < return
[ 170.33]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(5)
[ 170.35]  < return
[ 170.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:21: debug: for with continue: int32(6)
[ 170.38]  < return
[ 170.41]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(0)
[ 170.42]  < return
[ 170.44]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(1)
[ 170.45]  < return
[ 170.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
test/lang/statementFor.ci:28: debug: for with break: int32(2)
[ 170.48]  < return
[ 170.50]  > halt(): void
[ 170.50]  < return
[ 170.51] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:59: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:75: assertEq: function(<assertEq>)
lib/std/math.ci:22: Math.modf: function(<Math.modf>)
lib/std/math.ci:47: Math.floor: function(<Math.floor>)
lib/std/math.ci:77: Math.abs: function(<Math.abs>)
lib/std/math.ci:85: Math.abs: function(<Math.abs>)
lib/std/math.ci:93: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:101: Math.absMod: function(<Math.absMod>)
lib/std/math.ci:115: Math.min: function(<Math.min>)
lib/std/math.ci:123: Math.min: function(<Math.min>)
lib/std/math.ci:137: Math.max: function(<Math.max>)
lib/std/math.ci:145: Math.max: function(<Math.max>)
lib/std/math.ci:159: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:170: Math.clamp: function(<Math.clamp>)
lib/std/math.ci:201: Math.min: function(<Math.min>)
lib/std/math.ci:215: Math.max: function(<Math.max>)
lib/std/math.ci:229: Math.sum: function(<Math.sum>)
lib/std/math.ci:256: Math.eval: function(<Math.eval>)
lib/std/math.ci:265: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:280: Math.cmp: function(<Math.cmp>)
lib/std/math.ci:295: Math.sinCos: function(<Math.sinCos>)
lib/std/math.ci:352: Math.tan: function(<Math.tan>)
lib/std/math.ci:409: Math.sinh: function(<Math.sinh>)
lib/std/math.ci:448: Math.cosh: function(<Math.cosh>)
lib/std/math.ci:463: Math.asin: function(<Math.asin>)
lib/std/math.ci:2: Math: typename(<Math>)
lib/std/math.Complex.ci:2: Complex: typename(<Complex>)
lib/std/math.Complex.ci:24: Complex: function(<Complex>)
lib/std/math.Complex.ci:31: Complex: function(<Complex>)
lib/std/math.Complex.ci:83: div: function(<div>)
lib/std/math.Complex.ci:114: inv: function(<inv>)
lib/std/math.Complex.ci:132: pow: function(<pow>)
lib/std/string.ci:4: length: function(<length>)
lib/std/string.ci:15: indexOf: function(<indexOf>)
lib/std/string.ci:25: lastIndexOf: function(<lastIndexOf>)
lib/std/string.ci:36: startsWith: function(<startsWith>)
lib/std/string.ci:46: endsWith: function(<endsWith>)
lib/std/string.ci:61: compare: function(<compare>)
lib/std/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
lib/std/string.ci:88: caseCmp: function(<caseCmp>)
lib/std/string.ci:111: FormatFlags: typename(<FormatFlags>)
lib/std/string.ci:126: append: function(<append>)
lib/std/string.ci:143: append: function(<append>)
lib/std/string.ci:207: append: function(<append>)
lib/std/string.ci:212: append: function(<append>)
lib/std/string.ci:222: append: function(<append>)
lib/vec/vec2d.ci:4: vec2d: typename(<vec2d>)
lib/vec/vec2d.ci:16: vec2d: function(<vec2d>)
lib/vec/vec4f.ci:4: vec4f: typename(<vec4f>)
lib/vec/vec4f.ci:28: vec4f: function(<vec4f>)
lib/vec/mat4f.ci:4: mat4f: typename(<mat4f>)
lib/vec/mat4f.ci:27: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:40: mat4f: function(<mat4f>)
lib/vec/mat4f.ci:52: mul: function(<mul>)
test/lang/emit.ci:3: emitldz32: int32(0)
test/lang/emit.ci:4: emitldz64: int64(0)
test/lang/emit.ci:6: emitA: int32(42)
test/lang/emit.ci:7: emitB: int32(96)
test/lang/emit.ci:9: emitAddI32: int32(138)
test/lang/emit.ci:10: emitDivI32: int32(2)
test/lang/emit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang/emit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang/emit.ci:19: emitFloatAsInt3: int32(0)
test/lang/emit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang/emit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang/inlineMacros.ci:10: i3: int32(3)
test/lang/inlineMacros.ci:11: i6: int32(6)
test/lang/inlineMacros.ci:12: i2: int32(2)
test/lang/inlineMacros.ci:13: i8: int32(8)
test/lang/inlineMacros.ci:15: zeroVal: int32(0)
test/lang/inlineMacros.ci:16: zeroVar: int32(0)
test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
test/lang/inlineMacros.ci:19: lastVal: int32(6)
test/lang/inlineMacros.ci:20: lastVar: int32(6)
test/lang/inlineMacros.ci:21: lastXpr: int32(6)
test/lang/inlineMacros.ci:23: sum2Val: int32(9)
test/lang/inlineMacros.ci:24: sum2Var: int32(9)
test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
test/lang/inlineMacros.ci:27: any2Val: int32(3)
test/lang/inlineMacros.ci:28: any2Var: int32(3)
test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
test/lang/inlineMacros.ci:31: min2Val: int32(3)
test/lang/inlineMacros.ci:32: min2Var: int32(3)
test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
test/lang/inlineMacros.ci:35: max2Val: int32(6)
test/lang/inlineMacros.ci:36: max2Var: int32(6)
test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
test/lang/inlineMacros.ci:59: minRlVal: int32(2)
test/lang/inlineMacros.ci:60: minLrVal: int32(2)
test/lang/inlineMacros.ci:61: minRlVar: int32(2)
test/lang/inlineMacros.ci:62: minLrVar: int32(2)
test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
test/lang/overload.inline.ci:9: overload1: float32(1.000000)
test/lang/overload.inline.ci:10: overload2: float32(2.000000)
test/lang/overload.inline.ci:11: overload3: float32(3.000000)
test/lang/overload.inline.ci:12: overload4: float32(4.000000)
test/lang/overload.inline.ci:13: overload5: float32(5.000000)
test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: 100.000000
})
test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: 212.000000
})
test/lang/initByRef.ci:7: value: int64(42)
test/lang/initByRef.ci:8: valueRef: int64(42)
test/lang/initByRef.ci:9: valuePtr: pointer(<value>)
test/lang/initByRef.ci:10: valueVar: variant(int64: 42)
test/lang/initByRef.ci:12: fromRef: int64(42)
test/lang/initByRef.ci:13: fromPtr: int64(42)
test/lang/initByRef.ci:14: fromVar: int64(42)
test/lang/initByRef.ci:16: nullRef: int64(null)
test/lang/initByRef.ci:17: nullPtr: pointer(null)
test/lang/initByRef.ci:18: nullVar: variant(null)
test/lang/initByRef.ci:19: nullTyp: typename(null)
test/lang/initByRef.ci:20: nullFun: function(null)
test/lang/initByRef.ci:21: nullObj: object(null)
test/lang/initByRef.ci:23: typePtr: pointer(<int64>)
test/lang/initByRef.ci:24: typeVar: variant(typename: <int64>)
test/lang/initByRef.ci:25: typeTyp: typename(<int64>)
test/lang/initByRef.ci:27: local: int64(42)
test/lang/initByRef.ci:28: copyVal: int64(42)
test/lang/initByRef.ci:29: copyRef: int64(42)
test/lang/initByRef.ci:30: copyPtr: pointer(<value>)
test/lang/initByRef.ci:31: copyVar: variant(int64: 42)
test/lang/initByRef.ci:32: copyTyp: typename(<int64>)
test/lang/initByRef.ci:35: ptrVoid: pointer(<void>)
test/lang/initByRef.ci:36: ptrBool: pointer(<bool>)
test/lang/initByRef.ci:37: ptrChar: pointer(<char>)
test/lang/initByRef.ci:38: ptrInt8: pointer(<int8>)
test/lang/initByRef.ci:39: ptrInt16: pointer(<int16>)
test/lang/initByRef.ci:40: ptrInt32: pointer(<int32>)
test/lang/initByRef.ci:41: ptrInt64: pointer(<int64>)
test/lang/initByRef.ci:42: ptrUint8: pointer(<uint8>)
test/lang/initByRef.ci:43: ptrUint16: pointer(<uint16>)
test/lang/initByRef.ci:44: ptrUint32: pointer(<uint32>)
test/lang/initByRef.ci:45: ptrUint64: pointer(<uint64>)
test/lang/initByRef.ci:46: ptrFloat32: pointer(<float32>)
test/lang/initByRef.ci:47: ptrFloat64: pointer(<float64>)
test/lang/initByRef.ci:48: ptrTypename: pointer(<typename>)
test/lang/initByRef.ci:49: ptrFunction: pointer(<function>)
test/lang/initByRef.ci:50: ptrPointer: pointer(<pointer>)
test/lang/initByRef.ci:51: ptrVariant: pointer(<variant>)
test/lang/initByRef.ci:52: ptrObject: pointer(<object>)
test/lang/initByRef.ci:55: varVoid: variant(typename: <void>)
test/lang/initByRef.ci:56: varBool: variant(typename: <bool>)
test/lang/initByRef.ci:57: varChar: variant(typename: <char>)
test/lang/initByRef.ci:58: varInt8: variant(typename: <int8>)
test/lang/initByRef.ci:59: varInt16: variant(typename: <int16>)
test/lang/initByRef.ci:60: varInt32: variant(typename: <int32>)
test/lang/initByRef.ci:61: varInt64: variant(typename: <int64>)
test/lang/initByRef.ci:62: varUint8: variant(typename: <uint8>)
test/lang/initByRef.ci:63: varUint16: variant(typename: <uint16>)
test/lang/initByRef.ci:64: varUint32: variant(typename: <uint32>)
test/lang/initByRef.ci:65: varUint64: variant(typename: <uint64>)
test/lang/initByRef.ci:66: varFloat32: variant(typename: <float32>)
test/lang/initByRef.ci:67: varFloat64: variant(typename: <float64>)
test/lang/initByRef.ci:68: varTypename: variant(typename: <typename>)
test/lang/initByRef.ci:69: varFunction: variant(typename: <function>)
test/lang/initByRef.ci:70: varPointer: variant(typename: <pointer>)
test/lang/initByRef.ci:71: varVariant: variant(typename: <variant>)
test/lang/initByRef.ci:72: varObject: variant(typename: <object>)
test/lang/initByRef.ci:75: typVoid: typename(<void>)
test/lang/initByRef.ci:76: typBool: typename(<bool>)
test/lang/initByRef.ci:77: typChar: typename(<char>)
test/lang/initByRef.ci:78: typInt8: typename(<int8>)
test/lang/initByRef.ci:79: typInt16: typename(<int16>)
test/lang/initByRef.ci:80: typInt32: typename(<int32>)
test/lang/initByRef.ci:81: typInt64: typename(<int64>)
test/lang/initByRef.ci:82: typUint8: typename(<uint8>)
test/lang/initByRef.ci:83: typUint16: typename(<uint16>)
test/lang/initByRef.ci:84: typUint32: typename(<uint32>)
test/lang/initByRef.ci:85: typUint64: typename(<uint64>)
test/lang/initByRef.ci:86: typFloat32: typename(<float32>)
test/lang/initByRef.ci:87: typFloat64: typename(<float64>)
test/lang/initByRef.ci:88: typTypename: typename(<typename>)
test/lang/initByRef.ci:89: typFunction: typename(<function>)
test/lang/initByRef.ci:90: typPointer: typename(<pointer>)
test/lang/initByRef.ci:91: typVariant: typename(<variant>)
test/lang/initByRef.ci:92: typObject: typename(<object>)
test/lang/initByRef.ci:95: valueOfPtr: pointer(<value>)
test/lang/initByRef.ci:96: valueOfVar: variant(int64: 42)
test/lang/initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang/initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang/initByRef.ci:105: copyPtrFloat64: variant(pointer: <float64>)
test/lang/initByRef.ci:108: copyVarFloat64: pointer(<float64>)
test/lang/function.ci:4: empty: function(<empty>)
test/lang/function.ci:7: funAdd: function(<funAdd>)
test/lang/function.ci:12: funAddResult: int32(9)
test/lang/function.ci:15: funAddRef: function(<funAdd>)
test/lang/function.ci:18: funAddRefResult: int32(10)
test/lang/function.ci:21: funMul: function(<funMul>)
test/lang/function.ci:24: funMulResult: int32(12)
test/lang/function.ci:27: funMulRef: function(<funMul>)
test/lang/function.ci:30: funMulRefResult: int32(14)
test/lang/function.ci:33: funMul: function(<funMul>)
test/lang/function.ci:38: fib: function(<fib>)
test/lang/function.ci:46: fibonacci_13: uint32(233)
test/lang/reflect.ci:3: sizeofVoid: int32(0)
test/lang/reflect.ci:4: sizeofBool: int32(1)
test/lang/reflect.ci:5: sizeofChar: int32(1)
test/lang/reflect.ci:6: sizeofInt8: int32(1)
test/lang/reflect.ci:7: sizeofInt16: int32(2)
test/lang/reflect.ci:8: sizeofInt32: int32(4)
test/lang/reflect.ci:9: sizeofInt64: int32(8)
test/lang/reflect.ci:10: sizeofUint8: int32(1)
test/lang/reflect.ci:11: sizeofUint16: int32(2)
test/lang/reflect.ci:12: sizeofUint32: int32(4)
test/lang/reflect.ci:13: sizeofUint64: int32(8)
test/lang/reflect.ci:14: sizeofFloat32: int32(4)
test/lang/reflect.ci:15: sizeofFloat64: int32(8)
test/lang/reflect.ci:16: sizeofPointer: int32(4)
test/lang/reflect.ci:17: sizeofVariant: int32(8)
test/lang/reflect.ci:18: sizeofTypename: int32(152)
test/lang/reflect.ci:19: sizeofFunction: int32(4)
test/lang/reflect.ci:20: sizeofObject: int32(4)
test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang/reflect.ci:32: offsetOfRecord: int32(226784)
test/lang/reflect.ci:33: sizeOfRecord: int32(16)
test/lang/reflect.ci:34: fileOfRecord: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:35: lineOfRecord: int32(26)
test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang/reflect.ci:39: offsetOfBase: int32(226480)
test/lang/reflect.ci:40: sizeOfBase: int32(12)
test/lang/reflect.ci:41: fileOfBase: char[*]("test/lang/reflect.ci")
test/lang/reflect.ci:42: lineOfBase: int32(22)
test/lang/reflect.ci:44: typeofBase1: typename(<object>)
test/lang/reflect.ci:45: offsetOfBase1: int32(2744)
test/lang/reflect.ci:46: sizeOfBase1: int32(4)
test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
test/lang/reflect.ci:49: offsetOfBase2: int32(8)
test/lang/reflect.ci:50: sizeOfBase2: int32(152)
test/stdc/number.ci:3: pi64: float64(3.141593)
test/stdc/number.ci:4: e64: float64(2.718282)
test/stdc/number.ci:6: pi32: float32(3.141593)
test/stdc/number.ci:7: e32: float32(2.718282)
test/stdc/number.ci:14: r_comp: int32(112)
test/stdc/number.ci:15: g_comp: int32(252)
test/stdc/number.ci:16: b_comp: int32(248)
test/stdc/number.ci:18: r5g6b5: int32(30719)
test/stdc/number.ci:19: r8g8b8: int32(7404792)
test/stdc/number.ci:21: zxtR5: int32(14)
test/stdc/number.ci:22: zxtG6: int32(63)
test/stdc/number.ci:23: zxtB5: int32(31)
test/stdc/number.ci:25: sxtR5: int32(14)
test/stdc/number.ci:26: sxtG6: int32(-1)
test/stdc/number.ci:27: sxtB5: int32(-1)
test/stdc/number.ci:29: zxtR8: int32(112)
test/stdc/number.ci:30: zxtG8: int32(252)
test/stdc/number.ci:31: zxtB8: int32(248)
test/stdc/number.ci:33: sxtR8: int32(112)
test/stdc/number.ci:34: sxtG8: int32(-4)
test/stdc/number.ci:35: sxtB8: int32(-8)
test/stdc/number.ci:37: testSin_f64: float64(1.000000)
test/stdc/number.ci:38: testCos_f64: float64(0.000000)
test/stdc/number.ci:39: testTan_f64: float64(1.000000)
test/stdc/number.ci:40: testLog_f64: float64(3.000000)
test/stdc/number.ci:41: testExp_f64: float64(2.718282)
test/stdc/number.ci:42: testPow_f64: float64(3.141593)
test/stdc/number.ci:43: testSqrt_f64: float64(3.141593)
test/stdc/number.ci:44: testAtan_f64: float64(1.262627)
test/stdc/number.ci:46: testSin_f32: float32(1.000000)
test/stdc/number.ci:47: testCos_f32: float32(-0.000000)
test/stdc/number.ci:48: testTan_f32: float32(1.000000)
test/stdc/number.ci:49: testLog_f32: float32(3.000000)
test/stdc/number.ci:50: testExp_f32: float32(2.718282)
test/stdc/number.ci:51: testPow_f32: float32(3.141593)
test/stdc/number.ci:52: testSqrt_f32: float32(3.141593)
test/stdc/number.ci:53: testAtan_f32: float32(1.262627)
test/stdc/number.ci:55: testPopulation_u32: int32(14)
test/stdc/number.ci:56: testSwapBits_u32: uint32(4293787648)
test/stdc/number.ci:57: testBitScanReverse_u32: int32(14)
test/stdc/number.ci:58: testBitScanForward_u32: int32(0)
test/stdc/number.ci:59: testHighBit_u32: int32(16384)
test/stdc/number.ci:60: testLowBit_u32: int32(1)
test/stdc/number.ci:62: testZeroExtend_u32: int32(31)
test/stdc/number.ci:63: testSignExtend_u32: int32(-1)
test/stdc/number.ci:65: testZeroExtend_u64: int32(31)
test/stdc/number.ci:66: testSignExtend_u64: int32(-1)
test/stdc/memory.ci:7: p1: pointer(<?>)
test/stdc/memory.ci:8: p2: pointer(<?>)
test/stdc/memory.ci:9: p3: pointer(<?>)
test/stdc/memory.ci:10: p4: pointer(<?>)
test/stdc/memory.ci:23: val1: int64(0)
test/stdc/memory.ci:24: val2: int64(42)
test/stdc/tryExec.ci:11: noError: function(<noError>)
test/stdc/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
test/stdc/tryExec.ci:19: divisionByZero: function(<divisionByZero>)
test/stdc/tryExec.ci:23: abortExecution: function(<abortExecution>)
test/stdc/tryExec.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess>)
test/stdc/tryExec.ci:42: invalidInstruction: function(<invalidInstruction>)
test/stdc/tryExec.ci:46: tryExecErr0: int32(0)
test/stdc/tryExec.ci:47: tryExecErr1: int32(1)
test/stdc/tryExec.ci:48: tryExecErr2: int32(2)
test/stdc/tryExec.ci:49: tryExecErr3: int32(3)
test/stdc/tryExec.ci:50: tryExecErr4: int32(4)
test/stdc/tryExec.ci:51: tryExecErr5: int32(5)
test/stdc/tryExec.ci:52: tryExecErr6: int32(6)
test/lang/array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:50: arrArrayNoInit: int64[*](null)
test/lang/array.ci:51: arrSliceNoInit: int64[](null)
test/lang/array.ci:59: arrArrayInitNull: int64[*](null)
test/lang/array.ci:60: arrSliceInitNull: int64[](null)
test/lang/array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang/array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang/array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang/array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang/array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang/array.ci:86: strArray: char[*]("string")
test/lang/array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang/array.ci:103: lenSlice: function(<lenSlice>)
test/lang/array.ci:104: nthFixed: function(<nthFixed>)
test/lang/array.ci:105: nthArray: function(<nthArray>)
test/lang/array.ci:106: nthSlice: function(<nthSlice>)
test/lang/member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang/member.ci:35: RecordMemberTest.global: int32(0)
test/lang/member.ci:38: RecordMemberTest.globalInit: int32(1)
test/lang/member.ci:41: RecordMemberTest.globalConstant: int32(2)
test/lang/member.ci:44: RecordMemberTest.globalRec: Inner({
	member: 0,
	constant: 0
})
test/lang/member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: 4,
	constant: 5
})
test/lang/member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: 6,
	constant: 7
})
test/lang/member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang/member.ci:53: recordMemberTest: RecordMemberTest({
	member: 10,
	constant: 11,
	memberInit: 12,
	constantInit: 13,
	memberRec: {
		member: 14,
		constant: 15
	},
	constantRec: {
		member: 16,
		constant: 17
	}
})
test/lang/method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
test/lang/method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
test/lang/method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
test/lang/method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
test/lang/method.ci:57: globalFunction: function(<globalFunction>)
test/lang/method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: <globalFunction>,
	delegateMethod: <RecordMethodTest.forwardMethod>,
	virtualMethod: <RecordMethodTest.virtualMethod>
})
test/lang/method.ci:84: staticMethod: function(<staticMethod>)
test/lang/method.ci:90: virtualMethod: function(<virtualMethod>)
test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang/recUnion.ci:16: color: typename(<color>)
test/lang/recUnion.ci:22: Color: typename(<Color>)
test/lang/recUnion.ci:26: black: rgbU8({
	b: 0,
	g: 0,
	r: 0
})
test/lang/recUnion.ci:27: green: rgbU8({
	b: 0,
	g: 255,
	r: 0
})
test/lang/recUnion.ci:28: white: rgbU8({
	b: 255,
	g: 255,
	r: 255
})
test/lang/recUnion.ci:30: cyan: color({
	col: 65535,
	rgb: {
		b: 255,
		g: 255,
		r: 0
	}
})
test/lang/recUnion.ci:31: blue: color({
	col: 255,
	rgb: {
		b: 255,
		g: 0,
		r: 0
	}
})
test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang/useOperator.ci:5: shift: int32(2)
test/lang/useOperator.ci:7: boolA: bool(1)
test/lang/useOperator.ci:8: boolB: bool(1)
test/lang/useOperator.ci:17: boolAnd: bool(1)
test/lang/useOperator.ci:18: boolIor: bool(1)
test/lang/useOperator.ci:19: boolXor: bool(0)
test/lang/useOperator.ci:22: boolNot: bool(0)
test/lang/useOperator.ci:23: boolCeq: bool(1)
test/lang/useOperator.ci:24: boolCne: bool(0)
test/lang/useOperator.ci:25: boolClt: bool(0)
test/lang/useOperator.ci:26: boolCle: bool(1)
test/lang/useOperator.ci:27: boolCgt: bool(0)
test/lang/useOperator.ci:28: boolCge: bool(1)
test/lang/useOperator.ci:30: chrA: char('a')
test/lang/useOperator.ci:31: chrB: char('b')
test/lang/useOperator.ci:32: chrPls: char('b')
test/lang/useOperator.ci:33: chrNeg: char('')
test/lang/useOperator.ci:34: chrCmt: char('')
test/lang/useOperator.ci:35: chrAdd: char('')
test/lang/useOperator.ci:36: chrSub: char('')
test/lang/useOperator.ci:37: chrMul: char('\"')
test/lang/useOperator.ci:38: chrDiv: char('')
test/lang/useOperator.ci:39: chrMod: char('a')
test/lang/useOperator.ci:40: chrAnd: char('`')
test/lang/useOperator.ci:41: chrIor: char('c')
test/lang/useOperator.ci:42: chrXor: char('')
test/lang/useOperator.ci:43: chrShl: char('')
test/lang/useOperator.ci:44: chrShr: char('')
test/lang/useOperator.ci:45: chrNot: bool(0)
test/lang/useOperator.ci:46: chrCeq: bool(0)
test/lang/useOperator.ci:47: chrCne: bool(1)
test/lang/useOperator.ci:48: chrClt: bool(1)
test/lang/useOperator.ci:49: chrCle: bool(1)
test/lang/useOperator.ci:50: chrCgt: bool(0)
test/lang/useOperator.ci:51: chrCge: bool(0)
test/lang/useOperator.ci:53: i8A: int8(96)
test/lang/useOperator.ci:54: i8B: int8(42)
test/lang/useOperator.ci:55: i8Pls: int8(42)
test/lang/useOperator.ci:56: i8Neg: int8(-42)
test/lang/useOperator.ci:57: i8Cmt: int8(-43)
test/lang/useOperator.ci:58: i8Add: int8(-118)
test/lang/useOperator.ci:59: i8Sub: int8(54)
test/lang/useOperator.ci:60: i8Mul: int8(-64)
test/lang/useOperator.ci:61: i8Div: int8(2)
test/lang/useOperator.ci:62: i8Mod: int8(12)
test/lang/useOperator.ci:63: i8And: int8(32)
test/lang/useOperator.ci:64: i8Ior: int8(106)
test/lang/useOperator.ci:65: i8Xor: int8(74)
test/lang/useOperator.ci:66: i8Shl: int8(-128)
test/lang/useOperator.ci:67: i8Shr: int8(24)
test/lang/useOperator.ci:68: i8Not: bool(0)
test/lang/useOperator.ci:69: i8Ceq: bool(0)
test/lang/useOperator.ci:70: i8Cne: bool(1)
test/lang/useOperator.ci:71: i8Clt: bool(0)
test/lang/useOperator.ci:72: i8Cle: bool(0)
test/lang/useOperator.ci:73: i8Cgt: bool(1)
test/lang/useOperator.ci:74: i8Cge: bool(1)
test/lang/useOperator.ci:76: u8A: uint8(96)
test/lang/useOperator.ci:77: u8B: uint8(42)
test/lang/useOperator.ci:78: u8Pls: uint8(42)
test/lang/useOperator.ci:79: u8Neg: uint8(214)
test/lang/useOperator.ci:80: u8Cmt: uint8(213)
test/lang/useOperator.ci:81: u8Add: uint8(138)
test/lang/useOperator.ci:82: u8Sub: uint8(54)
test/lang/useOperator.ci:83: u8Mul: uint8(192)
test/lang/useOperator.ci:84: u8Div: uint8(2)
test/lang/useOperator.ci:85: u8Mod: uint8(12)
test/lang/useOperator.ci:86: u8And: uint8(32)
test/lang/useOperator.ci:87: u8Ior: uint8(106)
test/lang/useOperator.ci:88: u8Xor: uint8(74)
test/lang/useOperator.ci:89: u8Shl: uint8(128)
test/lang/useOperator.ci:90: u8Shr: uint8(24)
test/lang/useOperator.ci:91: u8Not: bool(0)
test/lang/useOperator.ci:92: u8Ceq: bool(0)
test/lang/useOperator.ci:93: u8Cne: bool(1)
test/lang/useOperator.ci:94: u8Clt: bool(0)
test/lang/useOperator.ci:95: u8Cle: bool(0)
test/lang/useOperator.ci:96: u8Cgt: bool(1)
test/lang/useOperator.ci:97: u8Cge: bool(1)
test/lang/useOperator.ci:99: i16A: int16(96)
test/lang/useOperator.ci:100: i16B: int16(42)
test/lang/useOperator.ci:101: i16Pls: int16(42)
test/lang/useOperator.ci:102: i16Neg: int16(-42)
test/lang/useOperator.ci:103: i16Cmt: int16(-43)
test/lang/useOperator.ci:104: i16Add: int16(138)
test/lang/useOperator.ci:105: i16Sub: int16(54)
test/lang/useOperator.ci:106: i16Mul: int16(4032)
test/lang/useOperator.ci:107: i16Div: int16(2)
test/lang/useOperator.ci:108: i16Mod: int16(12)
test/lang/useOperator.ci:109: i16And: int16(32)
test/lang/useOperator.ci:110: i16Ior: int16(106)
test/lang/useOperator.ci:111: i16Xor: int16(74)
test/lang/useOperator.ci:112: i16Shl: int16(384)
test/lang/useOperator.ci:113: i16Shr: int16(24)
test/lang/useOperator.ci:114: i16Not: bool(0)
test/lang/useOperator.ci:115: i16Ceq: bool(0)
test/lang/useOperator.ci:116: i16Cne: bool(1)
test/lang/useOperator.ci:117: i16Clt: bool(0)
test/lang/useOperator.ci:118: i16Cle: bool(0)
test/lang/useOperator.ci:119: i16Cgt: bool(1)
test/lang/useOperator.ci:120: i16Cge: bool(1)
test/lang/useOperator.ci:122: u16A: uint16(96)
test/lang/useOperator.ci:123: u16B: uint16(42)
test/lang/useOperator.ci:124: u16Pls: uint16(42)
test/lang/useOperator.ci:125: u16Neg: uint16(65494)
test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
test/lang/useOperator.ci:127: u16Add: uint16(138)
test/lang/useOperator.ci:128: u16Sub: uint16(54)
test/lang/useOperator.ci:129: u16Mul: uint16(4032)
test/lang/useOperator.ci:130: u16Div: uint16(2)
test/lang/useOperator.ci:131: u16Mod: uint16(12)
test/lang/useOperator.ci:132: u16And: uint16(32)
test/lang/useOperator.ci:133: u16Ior: uint16(106)
test/lang/useOperator.ci:134: u16Xor: uint16(74)
test/lang/useOperator.ci:135: u16Shl: uint16(384)
test/lang/useOperator.ci:136: u16Shr: uint16(24)
test/lang/useOperator.ci:137: u16Not: bool(0)
test/lang/useOperator.ci:138: u16Ceq: bool(0)
test/lang/useOperator.ci:139: u16Cne: bool(1)
test/lang/useOperator.ci:140: u16Clt: bool(0)
test/lang/useOperator.ci:141: u16Cle: bool(0)
test/lang/useOperator.ci:142: u16Cgt: bool(1)
test/lang/useOperator.ci:143: u16Cge: bool(1)
test/lang/useOperator.ci:145: i32A: int32(96)
test/lang/useOperator.ci:146: i32B: int32(42)
test/lang/useOperator.ci:147: i32Pls: int32(42)
test/lang/useOperator.ci:148: i32Neg: int32(-42)
test/lang/useOperator.ci:149: i32Cmt: int32(-43)
test/lang/useOperator.ci:150: i32Add: int32(138)
test/lang/useOperator.ci:151: i32Sub: int32(54)
test/lang/useOperator.ci:152: i32Mul: int32(4032)
test/lang/useOperator.ci:153: i32Div: int32(2)
test/lang/useOperator.ci:154: i32Mod: int32(12)
test/lang/useOperator.ci:155: i32And: int32(32)
test/lang/useOperator.ci:156: i32Ior: int32(106)
test/lang/useOperator.ci:157: i32Xor: int32(74)
test/lang/useOperator.ci:158: i32Shl: int32(384)
test/lang/useOperator.ci:159: i32Shr: int32(24)
test/lang/useOperator.ci:160: i32Not: bool(0)
test/lang/useOperator.ci:161: i32Ceq: bool(0)
test/lang/useOperator.ci:162: i32Cne: bool(1)
test/lang/useOperator.ci:163: i32Clt: bool(0)
test/lang/useOperator.ci:164: i32Cle: bool(0)
test/lang/useOperator.ci:165: i32Cgt: bool(1)
test/lang/useOperator.ci:166: i32Cge: bool(1)
test/lang/useOperator.ci:168: u32A: uint32(96)
test/lang/useOperator.ci:169: u32B: uint32(42)
test/lang/useOperator.ci:170: u32Pls: uint32(42)
test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang/useOperator.ci:173: u32Add: uint32(138)
test/lang/useOperator.ci:174: u32Sub: uint32(54)
test/lang/useOperator.ci:175: u32Mul: uint32(4032)
test/lang/useOperator.ci:176: u32Div: uint32(2)
test/lang/useOperator.ci:177: u32Mod: uint32(12)
test/lang/useOperator.ci:178: u32And: uint32(32)
test/lang/useOperator.ci:179: u32Ior: uint32(106)
test/lang/useOperator.ci:180: u32Xor: uint32(74)
test/lang/useOperator.ci:181: u32Shl: uint32(384)
test/lang/useOperator.ci:182: u32Shr: uint32(24)
test/lang/useOperator.ci:183: u32Not: bool(0)
test/lang/useOperator.ci:184: u32Ceq: bool(0)
test/lang/useOperator.ci:185: u32Cne: bool(1)
test/lang/useOperator.ci:186: u32Clt: bool(0)
test/lang/useOperator.ci:187: u32Cle: bool(0)
test/lang/useOperator.ci:188: u32Cgt: bool(1)
test/lang/useOperator.ci:189: u32Cge: bool(1)
test/lang/useOperator.ci:191: i64A: int64(96)
test/lang/useOperator.ci:192: i64B: int64(42)
test/lang/useOperator.ci:193: i64Pls: int64(42)
test/lang/useOperator.ci:194: i64Neg: int64(-42)
test/lang/useOperator.ci:195: i64Cmt: int64(-43)
test/lang/useOperator.ci:196: i64Add: int64(138)
test/lang/useOperator.ci:197: i64Sub: int64(54)
test/lang/useOperator.ci:198: i64Mul: int64(4032)
test/lang/useOperator.ci:199: i64Div: int64(2)
test/lang/useOperator.ci:200: i64Mod: int64(12)
test/lang/useOperator.ci:201: i64And: int64(32)
test/lang/useOperator.ci:202: i64Ior: int64(106)
test/lang/useOperator.ci:203: i64Xor: int64(74)
test/lang/useOperator.ci:204: i64Shl: int64(384)
test/lang/useOperator.ci:205: i64Shr: int64(24)
test/lang/useOperator.ci:206: i64Not: bool(0)
test/lang/useOperator.ci:207: i64Ceq: bool(0)
test/lang/useOperator.ci:208: i64Cne: bool(1)
test/lang/useOperator.ci:209: i64Clt: bool(0)
test/lang/useOperator.ci:210: i64Cle: bool(0)
test/lang/useOperator.ci:211: i64Cgt: bool(1)
test/lang/useOperator.ci:212: i64Cge: bool(1)
test/lang/useOperator.ci:214: u64A: uint64(96)
test/lang/useOperator.ci:215: u64B: uint64(42)
test/lang/useOperator.ci:216: u64Pls: uint64(42)
test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang/useOperator.ci:219: u64Add: uint64(138)
test/lang/useOperator.ci:220: u64Sub: uint64(54)
test/lang/useOperator.ci:221: u64Mul: uint64(4032)
test/lang/useOperator.ci:222: u64Div: uint64(2)
test/lang/useOperator.ci:223: u64Mod: uint64(12)
test/lang/useOperator.ci:224: u64And: uint64(32)
test/lang/useOperator.ci:225: u64Ior: uint64(106)
test/lang/useOperator.ci:226: u64Xor: uint64(74)
test/lang/useOperator.ci:227: u64Shl: uint64(384)
test/lang/useOperator.ci:228: u64Shr: uint64(24)
test/lang/useOperator.ci:229: u64Not: bool(0)
test/lang/useOperator.ci:230: u64Ceq: bool(0)
test/lang/useOperator.ci:231: u64Cne: bool(1)
test/lang/useOperator.ci:232: u64Clt: bool(0)
test/lang/useOperator.ci:233: u64Cle: bool(0)
test/lang/useOperator.ci:234: u64Cgt: bool(1)
test/lang/useOperator.ci:235: u64Cge: bool(1)
test/lang/useOperator.ci:237: f32A: float32(96.300003)
test/lang/useOperator.ci:238: f32B: float32(42.139999)
test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang/useOperator.ci:242: f32Add: float32(138.440002)
test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang/useOperator.ci:245: f32Div: float32(2.285240)
test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
test/lang/useOperator.ci:252: f32Not: bool(0)
test/lang/useOperator.ci:253: f32Ceq: bool(0)
test/lang/useOperator.ci:254: f32Cne: bool(1)
test/lang/useOperator.ci:255: f32Clt: bool(0)
test/lang/useOperator.ci:256: f32Cle: bool(0)
test/lang/useOperator.ci:257: f32Cgt: bool(1)
test/lang/useOperator.ci:258: f32Cge: bool(1)
test/lang/useOperator.ci:260: f64A: float64(96.300000)
test/lang/useOperator.ci:261: f64B: float64(42.140000)
test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang/useOperator.ci:265: f64Add: float64(138.440000)
test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang/useOperator.ci:268: f64Div: float64(2.285240)
test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
test/lang/useOperator.ci:275: f64Not: bool(0)
test/lang/useOperator.ci:276: f64Ceq: bool(0)
test/lang/useOperator.ci:277: f64Cne: bool(1)
test/lang/useOperator.ci:278: f64Clt: bool(0)
test/lang/useOperator.ci:279: f64Cle: bool(0)
test/lang/useOperator.ci:280: f64Cgt: bool(1)
test/lang/useOperator.ci:281: f64Cge: bool(1)
test/lang/useOperator.ci:283: ptrA: pointer(null)
test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
test/lang/useOperator.ci:299: ptrCeq: bool(0)
test/lang/useOperator.ci:300: ptrCne: bool(1)
test/lang/statementIf.ci:26: t: int32(0)
test/lang/statementFor.ci:12: forIdx: int32(2)
test/stdc/test.math.ci:3: testMathFloor_1: float64(3.000000)
test/stdc/test.math.ci:4: testMathFloor_2: float64(3.000000)
test/stdc/test.math.ci:5: testMathFloor_3: float64(3.000000)
test/stdc/test.math.ci:6: testMathFloor_4: float64(-3.000000)
test/stdc/test.math.ci:7: testMathFloor_5: float64(-3.000000)
test/stdc/test.math.ci:8: testMathFloor_6: float64(-3.000000)
test/stdc/test.math.ci:10: testMathSign_1F: float64(1.000000)
test/stdc/test.math.ci:11: testMathSign_2F: float64(0.000000)
test/stdc/test.math.ci:12: testMathSign_3F: float64(-1.000000)
test/stdc/test.math.ci:13: testMathSign_1f: float64(1.000000)
test/stdc/test.math.ci:14: testMathSign_2f: float64(0.000000)
test/stdc/test.math.ci:15: testMathSign_3f: float64(-1.000000)
test/stdc/test.math.ci:17: testMathAbs_1F: float64(0.200000)
test/stdc/test.math.ci:18: testMathAbs_2F: float64(0.000000)
test/stdc/test.math.ci:19: testMathAbs_3F: float64(0.900000)
test/stdc/test.math.ci:20: testMathAbs_1f: float64(0.200000)
test/stdc/test.math.ci:21: testMathAbs_2f: float64(0.000000)
test/stdc/test.math.ci:22: testMathAbs_3f: float64(0.900000)
test/stdc/test.math.ci:24: testMathMin_1f: float64(1.000000)
test/stdc/test.math.ci:25: testMathMax_2f: float64(2.000000)
test/stdc/test.math.ci:26: testMathMin_1F: float64(1.000000)
test/stdc/test.math.ci:27: testMathMax_2F: float64(2.000000)
test/stdc/test.math.ci:29: testMathClamp_1f: float64(1.000000)
test/stdc/test.math.ci:30: testMathClamp_1F: float64(1.000000)
test/stdc/test.math.ci:32: testMathLerp_1f: float64(1.000000)
test/stdc/test.math.ci:33: testMathLerp_1F: float64(1.000000)
test/stdc/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
test/stdc/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
test/stdc/test.math.ci:38: testMathMin_nan: float64(-nan)
test/stdc/test.math.ci:39: testMathMin_1: float64(1.000000)
test/stdc/test.math.ci:40: testMathMax_nan: float64(-nan)
test/stdc/test.math.ci:41: testMathMax_9: float64(9.000000)
test/stdc/test.math.ci:43: testMathSum_0: float64(0.000000)
test/stdc/test.math.ci:44: testMathSum_1: float64(1.000000)
test/stdc/test.math.ci:45: testMathSum_3: float64(3.000000)
test/stdc/test.math.ci:46: testMathSum_55: float64(55.000000)
test/stdc/test.math.ci:48: testMathEval_x: float64(10.000000)
test/stdc/test.math.ci:49: testMathEval_0: float64(0.000000)
test/stdc/test.math.ci:50: testMathEval_1: float64(1.000000)
test/stdc/test.math.ci:51: testMathEval_2: float64(11.000000)
test/stdc/test.math.ci:52: testMathEval_3: float64(111.000000)
test/stdc/test.math.ci:53: testMathEval_4: float64(1111.000000)
test/stdc/test.math.ci:54: testMathEval_5: float64(11111.000000)
test/stdc/test.math.ci:55: testMathEval_6: float64(111111.000000)
test/stdc/test.math.ci:57: testMathSin_f64: float64(1.000000)
test/stdc/test.math.ci:58: testMathCos_f64: float64(-0.000000)
test/stdc/test.math.ci:59: testMathTan_f64: float64(1.000000)
test/stdc/test.math.ci:60: testMathSinh_f64: float64(2.301299)
test/stdc/test.math.ci:61: testMathCosh_f64: float64(2.509178)
test/stdc/test.math.ci:63: testMathAsin_f64: float64(0.201358)
test/stdc/test.math.ci:64: testMathAcos_f64: float64(1.369438)
test/stdc/test.math.ci:67: testMathCmp_f32: bool(1)
test/stdc/test.math.ci:68: testMathCmp_f64: bool(1)
test/stdc/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
test/stdc/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
test/stdc/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
test/stdc/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
test/stdc/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
test/stdc/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
test/stdc/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
test/stdc/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
test/stdc/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
test/stdc/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
test/stdc/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
test/stdc/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
test/stdc/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
test/stdc/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
test/stdc/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
test/stdc/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
test/stdc/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
test/stdc/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
test/stdc/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
test/stdc/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
test/stdc/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
test/stdc/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 353976(345.7 Kb)
memory[heap] @0566b8; size: 1218630(1.2 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 329544(321.8 Kb)
memory[code] @000000; size: 19269(18.8 Kb)
memory[data] @000000; size: 2674(2.6 Kb)

---------- heap memory:
memory[free] @0566c8; size: 1218592(1.2 Mb)

---------- Profile functions: 79/115, coverage: 68.70%
::[.005900, .005900): exec(2), time(0.009 ms): halt(): void
::[.005ba0, .005ba0): exec(0), time(0.000 ms): variant.is(var: variant, type: typename): bool
::[.005e38, .005e38): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006178, .006178): exec(3), time(0.029 ms): typename.base(type: typename): typename
::[.006378, .006378): exec(2), time(0.022 ms): typename.file(type: typename): .cstr
::[.006578, .006578): exec(2), time(0.022 ms): typename.line(type: typename): int32
::[.006778, .006778): exec(2), time(0.024 ms): typename.name(type: typename): .cstr
::[.006f10, .006f10): exec(40), time(0.990 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.0077f0, .0077f0): exec(7), time(0.981 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.007a90, .007a90): exec(8), time(0.078 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.007dc8, .007dc8): exec(2), time(0.020 ms): pointer.fill(dst: pointer, value: int32, size: int32): pointer
::[.008100, .008100): exec(2), time(0.020 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008430, .008430): exec(1), time(0.010 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0086d8, .0086d8): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0088e0, .0088e0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.008a48, .008a48): exec(0), time(0.000 ms): System.rand(): int32
::[.008bb0, .008bb0): exec(0), time(0.000 ms): System.time(): int32
::[.008d18, .008d18): exec(0), time(0.000 ms): System.clock(): int32
::[.008e80, .008e80): exec(0), time(0.000 ms): System.millis(): int64
::[.009080, .009080): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.0093b8, .0093b8): exec(7), time(0.064 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.0096e8, .0096e8): exec(7), time(0.062 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.0098e8, .0098e8): exec(1), time(0.009 ms): uint32.pop(value: int32): int32
::[.009ae8, .009ae8): exec(1), time(0.009 ms): uint32.swap(value: int32): int32
::[.009ce8, .009ce8): exec(1), time(0.009 ms): uint32.bsr(value: int32): int32
::[.009ee8, .009ee8): exec(1), time(0.009 ms): uint32.bsf(value: int32): int32
::[.00a0e8, .00a0e8): exec(1), time(0.009 ms): uint32.hib(value: int32): int32
::[.00a2e8, .00a2e8): exec(1), time(0.009 ms): uint32.lob(value: int32): int32
::[.00a610, .00a610): exec(1), time(0.009 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00a938, .00a938): exec(1), time(0.008 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00ab38, .00ab38): exec(1), time(0.009 ms): float32.sin(x: float32): float32
::[.00ad38, .00ad38): exec(1), time(0.009 ms): float32.cos(x: float32): float32
::[.00af38, .00af38): exec(1), time(0.010 ms): float32.tan(x: float32): float32
::[.00b138, .00b138): exec(1), time(0.009 ms): float32.log(x: float32): float32
::[.00b338, .00b338): exec(1), time(0.010 ms): float32.exp(x: float32): float32
::[.00b5d0, .00b5d0): exec(1), time(0.008 ms): float32.pow(x: float32, y: float32): float32
::[.00b7d0, .00b7d0): exec(1), time(0.009 ms): float32.sqrt(x: float32): float32
::[.00ba68, .00ba68): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00bc60, .00bc60): exec(1), time(0.022 ms): float64.sin(x: float64): float64
::[.00be58, .00be58): exec(1), time(0.011 ms): float64.cos(x: float64): float64
::[.00c050, .00c050): exec(1), time(0.009 ms): float64.tan(x: float64): float64
::[.00c248, .00c248): exec(1), time(0.009 ms): float64.log(x: float64): float64
::[.00c440, .00c440): exec(5), time(0.043 ms): float64.exp(x: float64): float64
::[.00c6d0, .00c6d0): exec(1), time(0.011 ms): float64.pow(x: float64, y: float64): float64
::[.00c8c8, .00c8c8): exec(3), time(0.026 ms): float64.sqrt(x: float64): float64
::[.00cb58, .00cb58): exec(3), time(0.028 ms): float64.atan2(x: float64, y: float64): float64
lib/stdlib.ci:75:[.050748, .0507a6): exec(8), time(0.055 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
lib/std/math.ci:22:[.0507a8, .0507fe): exec(10), time(0.058 ms): Math.modf(x: float64, intPart: float64): float64
lib/std/math.ci:47:[.050800, .050818): exec(6), time(0.108-0.053 ms): Math.floor(x: float64): float64
lib/std/math.ci:77:[.050818, .05082a): exec(3), time(0.018 ms): Math.abs(x: float32): float32
lib/std/math.ci:85:[.050830, .050842): exec(4), time(0.020 ms): Math.abs(x: float64): float64
lib/std/math.ci:93:[.050848, .050863): exec(11), time(0.061 ms): Math.absMod(val: float32, mod: float32): float32
lib/std/math.ci:101:[.050868, .050883): exec(11), time(0.059 ms): Math.absMod(val: float64, mod: float64): float64
lib/std/math.ci:115:[.050888, .050899): exec(1), time(0.006 ms): Math.min(a: float32, b: float32): float32
lib/std/math.ci:123:[.0508a0, .0508b1): exec(1), time(0.007 ms): Math.min(a: float64, b: float64): float64
lib/std/math.ci:137:[.0508b8, .0508c9): exec(1), time(0.005 ms): Math.max(a: float32, b: float32): float32
lib/std/math.ci:145:[.0508d0, .0508e1): exec(1), time(0.006 ms): Math.max(a: float64, b: float64): float64
lib/std/math.ci:159:[.0508e8, .050906): exec(2), time(0.012 ms): Math.clamp(t: float32, a: float32, b: float32): float32
lib/std/math.ci:170:[.050908, .050926): exec(2), time(0.012 ms): Math.clamp(t: float64, a: float64, b: float64): float64
lib/std/math.ci:201:[.050928, .050977): exec(2), time(0.026 ms): Math.min(data: float64[]): float64
lib/std/math.ci:215:[.050978, .0509c7): exec(2), time(0.025 ms): Math.max(data: float64[]): float64
lib/std/math.ci:229:[.0509c8, .0509f0): exec(4), time(0.047 ms): Math.sum(data: float64[]): float64
lib/std/math.ci:256:[.0509f0, .050a1f): exec(3), time(0.038 ms): Math.eval(x: float64, polynomial: float64[]): float64
lib/std/math.ci:265:[.050a20, .050a59): exec(1), time(0.007 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
lib/std/math.ci:280:[.050a60, .050a99): exec(1), time(0.007 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
lib/std/math.ci:295:[.050aa0, .050bef): exec(2), time(0.030 ms): Math.sinCos(arg: float64, quad: int32): float64
lib/std/math.ci:352:[.050bf0, .050d6a): exec(1), time(0.025-0.005 ms): Math.tan(arg: float64): float64
lib/std/math.ci:409:[.050d70, .050e61): exec(1), time(0.033-0.017 ms): Math.sinh(x: float64): float64
lib/std/math.ci:448:[.050e68, .050eb3): exec(1), time(0.031-0.017 ms): Math.cosh(x: float64): float64
lib/std/math.ci:463:[.050eb8, .050f65): exec(2), time(0.067-0.034 ms): Math.asin(x: float64): float64
lib/std/math.Complex.ci:24:[.050f68, .050f6f): exec(0), time(0.000 ms): Complex(re: float64): Complex
lib/std/math.Complex.ci:31:[.050f70, .050f77): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
lib/std/math.Complex.ci:83:[.050f78, .050ff3): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
lib/std/math.Complex.ci:114:[.050ff8, .051017): exec(0), time(0.000 ms): inv(a: Complex): Complex
lib/std/math.Complex.ci:132:[.051018, .05107c): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
lib/std/string.ci:4:[.051080, .0510a6): exec(0), time(0.000 ms): length(str: char[*]): int32
lib/std/string.ci:15:[.0510a8, .0510da): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
lib/std/string.ci:25:[.0510e0, .051112): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
lib/std/string.ci:36:[.051118, .051161): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:46:[.051168, .0511e6): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
lib/std/string.ci:61:[.0511e8, .051227): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
lib/std/string.ci:74:[.051228, .05126f): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
lib/std/string.ci:73:[.051270, .051294): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
lib/std/string.ci:88:[.051298, .0512a6): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
lib/std/string.ci:126:[.0512a8, .0512fc): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
lib/std/string.ci:143:[.051310, .0515a1): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
lib/std/string.ci:207:[.0515a8, .0515bf): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
lib/std/string.ci:212:[.0515c0, .0515f1): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
lib/std/string.ci:222:[.051608, .051621): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: uint32): int32
lib/vec/vec2d.ci:16:[.051628, .05162f): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
lib/vec/vec4f.ci:28:[.051630, .05163d): exec(0), time(0.000 ms): vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
lib/vec/mat4f.ci:27:[.051640, .051671): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
lib/vec/mat4f.ci:40:[.051678, .05168d): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
lib/vec/mat4f.ci:52:[.051690, .051831): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
test/lang/function.ci:4:[.051cc8, .051cc9): exec(0), time(0.000 ms): empty(): void
test/lang/function.ci:7:[.051cd0, .051cd8): exec(2), time(0.021 ms): funAdd(x: int32, y: int32): int32
test/lang/function.ci:33:[.051d10, .051d18): exec(2), time(0.016 ms): funMul(x: int32, y: int32): int32
test/lang/function.ci:38:[.051d18, .051d4e): exec(753), time(9.936 ms): fib(n: uint32): uint32
test/stdc/tryExec.ci:11:[.052020, .052021): exec(1), time(0.008 ms): noError(ptr: pointer): void
test/stdc/tryExec.ci:14:[.052028, .052040): exec(64-64), time(0.786 ms): stackOverflow(ptr: pointer): void
test/stdc/tryExec.ci:19:[.052040, .05204c): exec(1-1), time(0.008 ms): divisionByZero(args: pointer): void
test/stdc/tryExec.ci:23:[.052050, .052094): exec(1-1), time(0.074-0.057 ms): abortExecution(args: pointer): void
test/stdc/tryExec.ci:37:[.052098, .0520a5): exec(1-1), time(0.009 ms): invalidMemoryAccess(args: pointer): void
test/stdc/tryExec.ci:42:[.0520a8, .0520aa): exec(1-1), time(0.008 ms): invalidInstruction(args: pointer): void
test/lang/array.ci:103:[.052180, .052184): exec(5), time(0.048 ms): lenSlice(values: int64[]): int32
test/lang/array.ci:104:[.052188, .052194): exec(21), time(0.229 ms): nthFixed(idx: int32, values: int64[7]): int64
test/lang/array.ci:105:[.052198, .0521a4): exec(21), time(0.225 ms): nthArray(idx: int32, values: int64[*]): int64
test/lang/array.ci:106:[.0521a8, .0521b4): exec(14), time(0.148 ms): nthSlice(idx: int32, values: int64[]): int64
test/lang/method.ci:10:[.052208, .05222f): exec(3), time(0.251-0.206 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:40:[.052238, .05225f): exec(4), time(0.304-0.245 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:47:[.052260, .052287): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:57:[.052288, .0522af): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
test/lang/method.ci:84:[.0522c0, .052302): exec(1), time(0.138-0.114 ms): staticMethod(this: RecordMethodTest, x: int32): void
test/lang/method.ci:90:[.052308, .052347): exec(1), time(0.132-0.110 ms): virtualMethod(this: RecordMethodTest, x: int32): void
::[.052d8c, .0566b8): exec(1), time(17.943-13.989 ms): .main

---------- Profile statements: 875/1125, coverage: 77.78%
lib/stdlib.ci:77:[.050751, .050752) exec(8), time(0.025-0.025 ms): <assertEq+9>
lib/stdlib.ci:76:[.050748, .050752) exec(8-8), time(0.000 ms): <assertEq+0>
lib/stdlib.ci:80:[.050756, .050761) exec(0), time(0.000 ms): <assertEq+14>
lib/stdlib.ci:81:[.050761, .05076c) exec(0), time(0.000 ms): <assertEq+25>
lib/stdlib.ci:82:[.05076c, .05076f) exec(0), time(0.000 ms): <assertEq+36>
::[.05076f, .05077b) exec(0), time(0.000 ms): <assertEq+39>
lib/stdlib.ci:79:[.050752, .05077b) exec(0), time(0.000 ms): <assertEq+10>
lib/stdlib.ci:84:[.05077b, .0507a1) exec(0), time(0.000 ms): <assertEq+51>
lib/std/math.ci:25:[.0507c0, .0507d1) exec(3), time(0.024-0.024 ms): <modf+24>
lib/std/math.ci:26:[.0507d1, .0507d8) exec(3), time(0.001-0.001 ms): <modf+41>
lib/std/math.ci:27:[.0507d8, .0507db) exec(3), time(0.009-0.009 ms): <modf+48>
lib/std/math.ci:24:[.0507b8, .0507df) exec(3-3), time(0.000 ms): <modf+16>
lib/std/math.ci:29:[.0507df, .0507e3) exec(0), time(0.000 ms): <modf+55>
lib/std/math.ci:30:[.0507e3, .0507e7) exec(0), time(0.000 ms): <modf+59>
lib/std/math.ci:23:[.0507a8, .0507e7) exec(10-3), time(0.002-0.002 ms): <modf+0>
lib/std/math.ci:32:[.0507e7, .0507f3) exec(7), time(0.000 ms): <modf+63>
lib/std/math.ci:33:[.0507f3, .0507fb) exec(7), time(0.003-0.003 ms): <modf+75>
lib/std/math.ci:34:[.0507fb, .0507fe) exec(7), time(0.022-0.022 ms): <modf+83>
lib/std/math.ci:48:[.050800, .050801) exec(6), time(0.001-0.001 ms): <floor+0>
lib/std/math.ci:49:[.050801, .050815) exec(6), time(0.073-0.073 ms): <floor+1>
lib/std/math.ci:50:[.050815, .050818) exec(6), time(0.017-0.017 ms): <floor+21>
lib/std/math.ci:79:[.050820, .050826) exec(1), time(0.003-0.003 ms): <abs+8>
lib/std/math.ci:78:[.050818, .050826) exec(3-1), time(0.001-0.001 ms): <abs+0>
lib/std/math.ci:81:[.050826, .05082a) exec(2), time(0.008-0.008 ms): <abs+14>
lib/std/math.ci:87:[.050838, .05083e) exec(1), time(0.004-0.004 ms): <abs+8>
lib/std/math.ci:86:[.050830, .05083e) exec(4-1), time(0.001-0.001 ms): <abs+0>
lib/std/math.ci:89:[.05083e, .050842) exec(3), time(0.010-0.010 ms): <abs+14>
lib/std/math.ci:95:[.050857, .05085f) exec(4), time(0.015-0.015 ms): <absMod+15>
lib/std/math.ci:94:[.050848, .05085f) exec(11-4), time(0.003-0.003 ms): <absMod+0>
lib/std/math.ci:97:[.05085f, .050863) exec(7), time(0.021-0.021 ms): <absMod+23>
lib/std/math.ci:103:[.050877, .05087f) exec(4), time(0.014-0.014 ms): <absMod+15>
lib/std/math.ci:102:[.050868, .05087f) exec(11-4), time(0.004-0.004 ms): <absMod+0>
lib/std/math.ci:105:[.05087f, .050883) exec(7), time(0.024-0.024 ms): <absMod+23>
lib/std/math.ci:117:[.050891, .050895) exec(1), time(0.003-0.003 ms): <min+9>
lib/std/math.ci:116:[.050888, .050895) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:119:[.050895, .050899) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:125:[.0508a9, .0508ad) exec(1), time(0.004-0.004 ms): <min+9>
lib/std/math.ci:124:[.0508a0, .0508ad) exec(1-1), time(0.000 ms): <min+0>
lib/std/math.ci:127:[.0508ad, .0508b1) exec(0), time(0.000 ms): <min+13>
lib/std/math.ci:139:[.0508c1, .0508c5) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:138:[.0508b8, .0508c5) exec(1), time(0.001-0.001 ms): <max+0>
lib/std/math.ci:141:[.0508c5, .0508c9) exec(1), time(0.003-0.003 ms): <max+13>
lib/std/math.ci:147:[.0508d9, .0508dd) exec(0), time(0.000 ms): <max+9>
lib/std/math.ci:146:[.0508d0, .0508dd) exec(1), time(0.000 ms): <max+0>
lib/std/math.ci:149:[.0508dd, .0508e1) exec(1), time(0.003-0.003 ms): <max+13>
lib/std/math.ci:161:[.0508f1, .0508f5) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:160:[.0508e8, .0508f5) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:164:[.0508fe, .050902) exec(1), time(0.003-0.003 ms): <clamp+22>
lib/std/math.ci:163:[.0508f5, .050902) exec(2-1), time(0.000 ms): <clamp+13>
lib/std/math.ci:166:[.050902, .050906) exec(1), time(0.004-0.004 ms): <clamp+26>
lib/std/math.ci:172:[.050911, .050915) exec(0), time(0.000 ms): <clamp+9>
lib/std/math.ci:171:[.050908, .050915) exec(2), time(0.000 ms): <clamp+0>
lib/std/math.ci:175:[.05091e, .050922) exec(1), time(0.004-0.004 ms): <clamp+22>
lib/std/math.ci:174:[.050915, .050922) exec(2-1), time(0.001-0.001 ms): <clamp+13>
lib/std/math.ci:177:[.050922, .050926) exec(1), time(0.003-0.003 ms): <clamp+26>
lib/std/math.ci:203:[.050930, .05093c) exec(1), time(0.008-0.008 ms): <min+8>
lib/std/math.ci:202:[.050928, .05093c) exec(2-1), time(0.000 ms): <min+0>
lib/std/math.ci:205:[.05093c, .05093f) exec(1), time(0.001-0.001 ms): <min+20>
lib/std/math.ci:208:[.050958, .050963) exec(2), time(0.000 ms): <min+48>
lib/std/math.ci:207:[.050948, .050963) exec(8-2), time(0.002-0.002 ms): <min+32>
lib/std/math.ci:206:[.050963, .050967) exec(8), time(0.000 ms): <min+59>
lib/std/math.ci:206:[.050967, .050970) exec(9), time(0.002-0.002 ms): <min+63>
lib/std/math.ci:206:[.05093f, .050974) exec(1), time(0.001-0.001 ms): <min+23>
lib/std/math.ci:211:[.050974, .050977) exec(1), time(0.004-0.004 ms): <min+76>
lib/std/math.ci:217:[.050980, .05098c) exec(1), time(0.004-0.004 ms): <max+8>
lib/std/math.ci:216:[.050978, .05098c) exec(2-1), time(0.000 ms): <max+0>
lib/std/math.ci:219:[.05098c, .05098f) exec(1), time(0.000 ms): <max+20>
lib/std/math.ci:222:[.0509a8, .0509b3) exec(2), time(0.000 ms): <max+48>
lib/std/math.ci:221:[.050998, .0509b3) exec(8-2), time(0.003-0.003 ms): <max+32>
lib/std/math.ci:220:[.0509b3, .0509b7) exec(8), time(0.001-0.001 ms): <max+59>
lib/std/math.ci:220:[.0509b7, .0509c0) exec(9), time(0.001-0.001 ms): <max+63>
lib/std/math.ci:220:[.05098f, .0509c4) exec(1), time(0.000 ms): <max+23>
lib/std/math.ci:225:[.0509c4, .0509c7) exec(1), time(0.004-0.004 ms): <max+76>
lib/std/math.ci:230:[.0509c8, .0509c9) exec(4), time(0.001-0.001 ms): <sum+0>
lib/std/math.ci:232:[.0509ce, .0509dc) exec(13), time(0.006-0.006 ms): <sum+6>
lib/std/math.ci:231:[.0509dc, .0509e0) exec(13), time(0.001-0.001 ms): <sum+20>
lib/std/math.ci:231:[.0509e0, .0509e9) exec(17), time(0.006-0.006 ms): <sum+24>
lib/std/math.ci:231:[.0509c9, .0509ed) exec(4), time(0.002-0.002 ms): <sum+1>
lib/std/math.ci:234:[.0509ed, .0509f0) exec(4), time(0.013-0.013 ms): <sum+37>
lib/std/math.ci:257:[.0509f0, .0509f1) exec(3), time(0.000 ms): <eval+0>
lib/std/math.ci:259:[.0509fb, .050a0c) exec(11), time(0.006-0.006 ms): <eval+11>
lib/std/math.ci:258:[.050a0c, .050a10) exec(11), time(0.001-0.001 ms): <eval+28>
lib/std/math.ci:258:[.050a10, .050a18) exec(14), time(0.003-0.003 ms): <eval+32>
lib/std/math.ci:258:[.0509f1, .050a1c) exec(3), time(0.003-0.003 ms): <eval+1>
lib/std/math.ci:261:[.050a1c, .050a1f) exec(3), time(0.010-0.010 ms): <eval+44>
lib/std/math.ci:268:[.050a35, .050a3d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:267:[.050a29, .050a3d) exec(1), time(0.000 ms): <cmp+9>
lib/std/math.ci:273:[.050a4d, .050a55) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:272:[.050a41, .050a55) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:266:[.050a20, .050a55) exec(1), time(0.000 ms): <cmp+0>
lib/std/math.ci:276:[.050a55, .050a59) exec(1), time(0.003-0.003 ms): <cmp+53>
lib/std/math.ci:283:[.050a75, .050a7d) exec(0), time(0.000 ms): <cmp+21>
lib/std/math.ci:282:[.050a69, .050a7d) exec(1), time(0.000 ms): <cmp+9>
lib/std/math.ci:288:[.050a8d, .050a95) exec(0), time(0.000 ms): <cmp+45>
lib/std/math.ci:287:[.050a81, .050a95) exec(0), time(0.000 ms): <cmp+33>
lib/std/math.ci:281:[.050a60, .050a95) exec(1), time(0.000 ms): <cmp+0>
lib/std/math.ci:291:[.050a95, .050a99) exec(1), time(0.004-0.004 ms): <cmp+53>
lib/std/math.ci:309:[.050aa0, .050aa2) exec(2), time(0.000 ms): <sinCos+0>
lib/std/math.ci:311:[.050aaa, .050aab) exec(0), time(0.000 ms): <sinCos+10>
lib/std/math.ci:312:[.050aab, .050ab3) exec(0), time(0.000 ms): <sinCos+11>
lib/std/math.ci:310:[.050aa2, .050ab3) exec(2), time(0.000 ms): <sinCos+2>
lib/std/math.ci:315:[.050ab3, .050ab4) exec(2), time(0.000 ms): <sinCos+19>
lib/std/math.ci:316:[.050ab4, .050acc) exec(2), time(0.001-0.001 ms): <sinCos+20>
lib/std/math.ci:318:[.050adc, .050add) exec(0), time(0.000 ms): <sinCos+60>
lib/std/math.ci:319:[.050add, .050aef) exec(0), time(0.000 ms): <sinCos+61>
lib/std/math.ci:320:[.050aef, .050af3) exec(0), time(0.000 ms): <sinCos+79>
lib/std/math.ci:322:[.050af3, .050af4) exec(0), time(0.000 ms): <sinCos+83>
lib/std/math.ci:323:[.050af4, .050b12) exec(0), time(0.000 ms): <sinCos+84>
lib/std/math.ci:324:[.050b12, .050b24) exec(0), time(0.000 ms): <sinCos+114>
lib/std/math.ci:327:[.050b2c, .050b2f) exec(2), time(0.001-0.001 ms): <sinCos+140>
lib/std/math.ci:328:[.050b2f, .050b37) exec(2), time(0.001-0.001 ms): <sinCos+143>
lib/std/math.ci:329:[.050b37, .050b3e) exec(2), time(0.001-0.001 ms): <sinCos+151>
lib/std/math.ci:330:[.050b3e, .050b44) exec(2), time(0.001-0.001 ms): <sinCos+158>
lib/std/math.ci:317:[.050acc, .050b48) exec(2), time(0.001-0.001 ms): <sinCos+44>
lib/std/math.ci:333:[.050b50, .050b5e) exec(1), time(0.000 ms): <sinCos+176>
lib/std/math.ci:332:[.050b48, .050b5e) exec(2-1), time(0.000 ms): <sinCos+168>
lib/std/math.ci:336:[.050b6a, .050b6b) exec(1), time(0.000 ms): <sinCos+202>
lib/std/math.ci:335:[.050b5e, .050b6b) exec(2-1), time(0.000 ms): <sinCos+190>
lib/std/math.ci:339:[.050b6b, .050b70) exec(2), time(0.000 ms): <sinCos+203>
lib/std/math.ci:340:[.050b70, .050bb0) exec(2), time(0.004-0.004 ms): <sinCos+208>
lib/std/math.ci:341:[.050bb0, .050be3) exec(2), time(0.002-0.002 ms): <sinCos+272>
lib/std/math.ci:342:[.050be3, .050bef) exec(2), time(0.008-0.008 ms): <sinCos+323>
lib/std/math.ci:365:[.050bf0, .050bf1) exec(1), time(0.001-0.001 ms): <tan+0>
lib/std/math.ci:366:[.050bf1, .050bf2) exec(1), time(0.000 ms): <tan+1>
lib/std/math.ci:369:[.050bfa, .050bff) exec(0), time(0.000 ms): <tan+10>
lib/std/math.ci:370:[.050bff, .050c09) exec(0), time(0.000 ms): <tan+15>
lib/std/math.ci:368:[.050bf2, .050c09) exec(1), time(0.000 ms): <tan+2>
lib/std/math.ci:372:[.050c09, .050c21) exec(1), time(0.000 ms): <tan+25>
lib/std/math.ci:374:[.050c21, .050c22) exec(1), time(0.000 ms): <tan+49>
lib/std/math.ci:375:[.050c22, .050c32) exec(1), time(0.008-0.008 ms): <tan+50>
lib/std/math.ci:376:[.050c32, .050c3b) exec(1), time(0.000 ms): <tan+66>
lib/std/math.ci:380:[.050c4f, .050c5d) exec(1), time(0.001-0.001 ms): <tan+95>
lib/std/math.ci:381:[.050c5d, .050c67) exec(1), time(0.000 ms): <tan+109>
lib/std/math.ci:384:[.050c77, .050c82) exec(0), time(0.000 ms): <tan+135>
lib/std/math.ci:385:[.050c82, .050c8c) exec(0), time(0.000 ms): <tan+146>
lib/std/math.ci:388:[.050c9c, .050caa) exec(0), time(0.000 ms): <tan+172>
lib/std/math.ci:389:[.050caa, .050cb5) exec(0), time(0.000 ms): <tan+186>
lib/std/math.ci:387:[.050c90, .050cb5) exec(0), time(0.000 ms): <tan+160>
lib/std/math.ci:383:[.050c6b, .050cb5) exec(0), time(0.000 ms): <tan+123>
lib/std/math.ci:379:[.050c43, .050cb5) exec(1), time(0.000 ms): <tan+83>
lib/std/math.ci:378:[.050c3b, .050cb5) exec(1-1), time(0.000 ms): <tan+75>
lib/std/math.ci:392:[.050cb5, .050cba) exec(1), time(0.000 ms): <tan+197>
lib/std/math.ci:393:[.050cba, .050cfa) exec(1), time(0.002-0.002 ms): <tan+202>
lib/std/math.ci:394:[.050cfa, .050d21) exec(1), time(0.001-0.001 ms): <tan+266>
lib/std/math.ci:398:[.050d32, .050d42) exec(0), time(0.000 ms): <tan+322>
lib/std/math.ci:397:[.050d2a, .050d42) exec(1), time(0.001-0.001 ms): <tan+314>
lib/std/math.ci:400:[.050d42, .050d50) exec(1), time(0.000 ms): <tan+338>
lib/std/math.ci:396:[.050d21, .050d50) exec(1-1), time(0.000 ms): <tan+305>
lib/std/math.ci:403:[.050d59, .050d63) exec(0), time(0.000 ms): <tan+361>
lib/std/math.ci:402:[.050d50, .050d63) exec(1), time(0.000 ms): <tan+352>
lib/std/math.ci:405:[.050d63, .050d6a) exec(1), time(0.004-0.004 ms): <tan+371>
lib/std/math.ci:421:[.050d70, .050d71) exec(1), time(0.000 ms): <sinh+0>
lib/std/math.ci:423:[.050d79, .050d7e) exec(0), time(0.000 ms): <sinh+9>
lib/std/math.ci:424:[.050d7e, .050d88) exec(0), time(0.000 ms): <sinh+14>
lib/std/math.ci:422:[.050d71, .050d88) exec(1), time(0.001-0.001 ms): <sinh+1>
lib/std/math.ci:428:[.050d98, .050daf) exec(0), time(0.000 ms): <sinh+40>
lib/std/math.ci:427:[.050d88, .050daf) exec(1), time(0.000 ms): <sinh+24>
lib/std/math.ci:431:[.050daf, .050db0) exec(1), time(0.000 ms): <sinh+63>
lib/std/math.ci:433:[.050dc0, .050dda) exec(1), time(0.025-0.025 ms): <sinh+80>
lib/std/math.ci:436:[.050dde, .050de3) exec(0), time(0.000 ms): <sinh+110>
lib/std/math.ci:437:[.050de3, .050e18) exec(0), time(0.000 ms): <sinh+115>
lib/std/math.ci:438:[.050e18, .050e43) exec(0), time(0.000 ms): <sinh+168>
lib/std/math.ci:432:[.050db0, .050e47) exec(1), time(0.025-0.025 ms): <sinh+64>
lib/std/math.ci:442:[.050e50, .050e5a) exec(0), time(0.000 ms): <sinh+224>
lib/std/math.ci:441:[.050e47, .050e5a) exec(1), time(0.000 ms): <sinh+215>
lib/std/math.ci:444:[.050e5a, .050e61) exec(1), time(0.004-0.004 ms): <sinh+234>
lib/std/math.ci:450:[.050e70, .050e75) exec(0), time(0.000 ms): <cosh+8>
lib/std/math.ci:449:[.050e68, .050e75) exec(1), time(0.000 ms): <cosh+0>
lib/std/math.ci:453:[.050e85, .050e98) exec(0), time(0.000 ms): <cosh+29>
lib/std/math.ci:452:[.050e75, .050e98) exec(1), time(0.000 ms): <cosh+13>
lib/std/math.ci:455:[.050e98, .050eb3) exec(1), time(0.028-0.028 ms): <cosh+48>
lib/std/math.ci:466:[.050ec0, .050ec4) exec(0), time(0.000 ms): <asin+8>
lib/std/math.ci:464:[.050eb8, .050ec4) exec(2), time(0.001-0.001 ms): <asin+0>
lib/std/math.ci:469:[.050ec4, .050ec5) exec(2), time(0.000 ms): <asin+12>
lib/std/math.ci:471:[.050ecd, .050ed7) exec(0), time(0.000 ms): <asin+21>
lib/std/math.ci:472:[.050ed7, .050edc) exec(0), time(0.000 ms): <asin+31>
lib/std/math.ci:470:[.050ec5, .050edc) exec(2), time(0.001-0.001 ms): <asin+13>
lib/std/math.ci:477:[.050eec, .050efc) exec(0), time(0.000 ms): <asin+52>
lib/std/math.ci:475:[.050edc, .050efc) exec(2), time(0.001-0.001 ms): <asin+36>
lib/std/math.ci:480:[.050efc, .050f0f) exec(2), time(0.023-0.023 ms): <asin+68>
lib/std/math.ci:482:[.050f1f, .050f3d) exec(0), time(0.000 ms): <asin+103>
lib/std/math.ci:485:[.050f41, .050f4b) exec(2), time(0.025-0.025 ms): <asin+137>
lib/std/math.ci:481:[.050f0f, .050f4b) exec(2-2), time(0.000 ms): <asin+87>
lib/std/math.ci:489:[.050f54, .050f5e) exec(0), time(0.000 ms): <asin+156>
lib/std/math.ci:488:[.050f4b, .050f5e) exec(2), time(0.001-0.001 ms): <asin+147>
lib/std/math.ci:491:[.050f5e, .050f65) exec(2), time(0.007-0.007 ms): <asin+166>
::[.050f6b, .050f6e) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:25:[.050f68, .050f6f) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:34:[.050f73, .050f76) exec(0), time(0.000 ms): <Complex+3>
lib/std/math.Complex.ci:32:[.050f70, .050f77) exec(0), time(0.000 ms): <Complex+0>
lib/std/math.Complex.ci:88:[.050f97, .050f9c) exec(0), time(0.000 ms): <div+31>
lib/std/math.Complex.ci:89:[.050f9c, .050fa4) exec(0), time(0.000 ms): <div+36>
lib/std/math.Complex.ci:92:[.050fb1, .050fbe) exec(0), time(0.000 ms): <div+57>
lib/std/math.Complex.ci:90:[.050fa4, .050fc3) exec(0), time(0.000 ms): <div+44>
lib/std/math.Complex.ci:87:[.050f78, .050fc7) exec(0), time(0.000 ms): <div+0>
lib/std/math.Complex.ci:95:[.050fc7, .050fcc) exec(0), time(0.000 ms): <div+79>
lib/std/math.Complex.ci:96:[.050fcc, .050fd4) exec(0), time(0.000 ms): <div+84>
lib/std/math.Complex.ci:99:[.050fe1, .050fee) exec(0), time(0.000 ms): <div+105>
lib/std/math.Complex.ci:97:[.050fd4, .050ff3) exec(0), time(0.000 ms): <div+92>
lib/std/math.Complex.ci:115:[.050ff8, .051003) exec(0), time(0.000 ms): <inv+0>
lib/std/math.Complex.ci:118:[.05100a, .051012) exec(0), time(0.000 ms): <inv+18>
lib/std/math.Complex.ci:116:[.051003, .051017) exec(0), time(0.000 ms): <inv+11>
lib/std/math.Complex.ci:133:[.051018, .05102f) exec(0), time(0.000 ms): <pow+0>
lib/std/math.Complex.ci:134:[.05102f, .05103f) exec(0), time(0.000 ms): <pow+23>
lib/std/math.Complex.ci:135:[.05103f, .05104e) exec(0), time(0.000 ms): <pow+39>
lib/std/math.Complex.ci:136:[.05104e, .051061) exec(0), time(0.000 ms): <pow+54>
lib/std/math.Complex.ci:139:[.05106c, .051077) exec(0), time(0.000 ms): <pow+84>
lib/std/math.Complex.ci:137:[.051061, .05107c) exec(0), time(0.000 ms): <pow+73>
lib/std/string.ci:6:[.05108c, .051090) exec(0), time(0.000 ms): <length+12>
lib/std/string.ci:5:[.051080, .051090) exec(0), time(0.000 ms): <length+0>
lib/std/string.ci:8:[.051090, .051091) exec(0), time(0.000 ms): <length+16>
lib/std/string.ci:9:[.051095, .051099) exec(0), time(0.000 ms): <length+21>
lib/std/string.ci:9:[.051099, .0510a3) exec(0), time(0.000 ms): <length+25>
lib/std/string.ci:9:[.051091, .0510a3) exec(0), time(0.000 ms): <length+17>
lib/std/string.ci:11:[.0510a3, .0510a6) exec(0), time(0.000 ms): <length+35>
lib/std/string.ci:18:[.0510bd, .0510c0) exec(0), time(0.000 ms): <indexOf+21>
lib/std/string.ci:17:[.0510ad, .0510c0) exec(0), time(0.000 ms): <indexOf+5>
lib/std/string.ci:16:[.0510c0, .0510c4) exec(0), time(0.000 ms): <indexOf+24>
lib/std/string.ci:16:[.0510c4, .0510ce) exec(0), time(0.000 ms): <indexOf+28>
lib/std/string.ci:16:[.0510a8, .0510d2) exec(0), time(0.000 ms): <indexOf+0>
lib/std/string.ci:21:[.0510d2, .0510da) exec(0), time(0.000 ms): <indexOf+42>
lib/std/string.ci:26:[.0510e0, .0510e5) exec(0), time(0.000 ms): <lastIndexOf+0>
lib/std/string.ci:29:[.0510fa, .0510fd) exec(0), time(0.000 ms): <lastIndexOf+26>
lib/std/string.ci:28:[.0510ea, .0510fd) exec(0), time(0.000 ms): <lastIndexOf+10>
lib/std/string.ci:27:[.0510fd, .051101) exec(0), time(0.000 ms): <lastIndexOf+29>
lib/std/string.ci:27:[.051101, .05110b) exec(0), time(0.000 ms): <lastIndexOf+33>
lib/std/string.ci:27:[.0510e5, .05110f) exec(0), time(0.000 ms): <lastIndexOf+5>
lib/std/string.ci:32:[.05110f, .051112) exec(0), time(0.000 ms): <lastIndexOf+47>
lib/std/string.ci:39:[.051137, .051142) exec(0), time(0.000 ms): <startsWith+31>
lib/std/string.ci:38:[.05111d, .051142) exec(0), time(0.000 ms): <startsWith+5>
lib/std/string.ci:37:[.051142, .051146) exec(0), time(0.000 ms): <startsWith+42>
lib/std/string.ci:37:[.051146, .051152) exec(0), time(0.000 ms): <startsWith+46>
lib/std/string.ci:37:[.051118, .051156) exec(0), time(0.000 ms): <startsWith+0>
lib/std/string.ci:42:[.051156, .051161) exec(0), time(0.000 ms): <startsWith+62>
lib/std/string.ci:47:[.051168, .051175) exec(0), time(0.000 ms): <endsWith+0>
lib/std/string.ci:48:[.051175, .051182) exec(0), time(0.000 ms): <endsWith+13>
lib/std/string.ci:50:[.05118b, .051196) exec(0), time(0.000 ms): <endsWith+35>
lib/std/string.ci:49:[.051182, .051196) exec(0), time(0.000 ms): <endsWith+26>
lib/std/string.ci:54:[.0511bb, .0511c6) exec(0), time(0.000 ms): <endsWith+83>
lib/std/string.ci:53:[.05119b, .0511c6) exec(0), time(0.000 ms): <endsWith+51>
lib/std/string.ci:52:[.0511c6, .0511ca) exec(0), time(0.000 ms): <endsWith+94>
lib/std/string.ci:52:[.0511ca, .0511d3) exec(0), time(0.000 ms): <endsWith+98>
lib/std/string.ci:52:[.051196, .0511d7) exec(0), time(0.000 ms): <endsWith+46>
lib/std/string.ci:57:[.0511d7, .0511e6) exec(0), time(0.000 ms): <endsWith+111>
lib/std/string.ci:62:[.0511e8, .0511e9) exec(0), time(0.000 ms): <compare+0>
lib/std/string.ci:64:[.0511ee, .051204) exec(0), time(0.000 ms): <compare+6>
lib/std/string.ci:66:[.051210, .051214) exec(0), time(0.000 ms): <compare+40>
lib/std/string.ci:65:[.051204, .051214) exec(0), time(0.000 ms): <compare+28>
lib/std/string.ci:63:[.051214, .051218) exec(0), time(0.000 ms): <compare+44>
lib/std/string.ci:63:[.051218, .051220) exec(0), time(0.000 ms): <compare+48>
lib/std/string.ci:63:[.0511e9, .051224) exec(0), time(0.000 ms): <compare+1>
lib/std/string.ci:69:[.051224, .051227) exec(0), time(0.000 ms): <compare+60>
lib/std/string.ci:76:[.051237, .051242) exec(0), time(0.000 ms): <ignCase+15>
lib/std/string.ci:75:[.051228, .051242) exec(0), time(0.000 ms): <ignCase+0>
lib/std/string.ci:79:[.051251, .05125c) exec(0), time(0.000 ms): <ignCase+41>
lib/std/string.ci:78:[.051242, .05125c) exec(0), time(0.000 ms): <ignCase+26>
lib/std/string.ci:81:[.05125c, .05126f) exec(0), time(0.000 ms): <ignCase+52>
lib/std/string.ci:84:[.051270, .051294) exec(0), time(0.000 ms): <ignCaseCmp+0>
lib/std/string.ci:89:[.051298, .0512a6) exec(0), time(0.000 ms): <caseCmp+0>
lib/std/string.ci:129:[.0512b6, .0512ba) exec(0), time(0.000 ms): <append+14>
lib/std/string.ci:128:[.0512ad, .0512ba) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:131:[.0512ba, .0512c6) exec(0), time(0.000 ms): <append+18>
lib/std/string.ci:132:[.0512c6, .0512ce) exec(0), time(0.000 ms): <append+30>
lib/std/string.ci:127:[.0512ce, .0512d2) exec(0), time(0.000 ms): <append+38>
lib/std/string.ci:127:[.0512d2, .0512dc) exec(0), time(0.000 ms): <append+42>
lib/std/string.ci:127:[.0512a8, .0512e0) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:136:[.0512e9, .0512f1) exec(0), time(0.000 ms): <append+65>
lib/std/string.ci:135:[.0512e0, .0512f1) exec(0), time(0.000 ms): <append+56>
lib/std/string.ci:138:[.0512f1, .0512f8) exec(0), time(0.000 ms): <append+73>
lib/std/string.ci:139:[.0512f8, .0512fc) exec(0), time(0.000 ms): <append+80>
lib/std/string.ci:147:[.051310, .051311) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:148:[.051311, .051315) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:150:[.051315, .051318) exec(0), time(0.000 ms): <append+5>
lib/std/string.ci:151:[.051318, .05134e) exec(0), time(0.000 ms): <append+8>
lib/std/string.ci:152:[.05134e, .051383) exec(0), time(0.000 ms): <append+62>
lib/std/string.ci:156:[.051387, .0513a2) exec(0), time(0.000 ms): <append+119>
lib/std/string.ci:155:[.0513a2, .0513a9) exec(0), time(0.000 ms): <append+146>
lib/std/string.ci:155:[.0513a9, .0513b1) exec(0), time(0.000 ms): <append+153>
lib/std/string.ci:155:[.051383, .0513b1) exec(0), time(0.000 ms): <append+115>
lib/std/string.ci:159:[.0513b9, .0513ce) exec(0), time(0.000 ms): <append+169>
lib/std/string.ci:158:[.0513b1, .0513ce) exec(0), time(0.000 ms): <append+161>
lib/std/string.ci:162:[.0513ce, .0513d8) exec(0), time(0.000 ms): <append+190>
lib/std/string.ci:164:[.0513d8, .0513df) exec(0), time(0.000 ms): <append+200>
lib/std/string.ci:166:[.0513ea, .0513f4) exec(0), time(0.000 ms): <append+218>
lib/std/string.ci:165:[.0513df, .0513f4) exec(0), time(0.000 ms): <append+207>
lib/std/string.ci:171:[.0513ff, .051407) exec(0), time(0.000 ms): <append+239>
lib/std/string.ci:175:[.051425, .051459) exec(0), time(0.000 ms): <append+277>
lib/std/string.ci:176:[.051459, .051464) exec(0), time(0.000 ms): <append+329>
lib/std/string.ci:177:[.051464, .05146c) exec(0), time(0.000 ms): <append+340>
lib/std/string.ci:174:[.05146c, .051474) exec(0), time(0.000 ms): <append+348>
lib/std/string.ci:174:[.051474, .05147c) exec(0), time(0.000 ms): <append+356>
lib/std/string.ci:174:[.051421, .05147c) exec(0), time(0.000 ms): <append+273>
lib/std/string.ci:172:[.051407, .05147c) exec(0), time(0.000 ms): <append+247>
lib/std/string.ci:180:[.05147c, .0514b0) exec(0), time(0.000 ms): <append+364>
lib/std/string.ci:181:[.0514b0, .0514bb) exec(0), time(0.000 ms): <append+416>
lib/std/string.ci:182:[.0514bb, .0514c3) exec(0), time(0.000 ms): <append+427>
lib/std/string.ci:170:[.0513f4, .0514c3) exec(0), time(0.000 ms): <append+228>
lib/std/string.ci:187:[.0514c7, .0514fb) exec(0), time(0.000 ms): <append+439>
lib/std/string.ci:188:[.0514fb, .051506) exec(0), time(0.000 ms): <append+491>
lib/std/string.ci:189:[.051506, .05150e) exec(0), time(0.000 ms): <append+502>
lib/std/string.ci:186:[.05150e, .051516) exec(0), time(0.000 ms): <append+510>
lib/std/string.ci:186:[.051516, .05151e) exec(0), time(0.000 ms): <append+518>
lib/std/string.ci:186:[.0514c3, .05151e) exec(0), time(0.000 ms): <append+435>
lib/std/string.ci:194:[.051523, .051557) exec(0), time(0.000 ms): <append+531>
lib/std/string.ci:195:[.051557, .051568) exec(0), time(0.000 ms): <append+583>
lib/std/string.ci:196:[.051568, .051570) exec(0), time(0.000 ms): <append+600>
lib/std/string.ci:193:[.051570, .051574) exec(0), time(0.000 ms): <append+608>
lib/std/string.ci:193:[.051574, .05157d) exec(0), time(0.000 ms): <append+612>
lib/std/string.ci:193:[.05151e, .051581) exec(0), time(0.000 ms): <append+526>
lib/std/string.ci:200:[.05158a, .051592) exec(0), time(0.000 ms): <append+634>
lib/std/string.ci:199:[.051581, .051592) exec(0), time(0.000 ms): <append+625>
lib/std/string.ci:202:[.051592, .051599) exec(0), time(0.000 ms): <append+642>
lib/std/string.ci:203:[.051599, .0515a1) exec(0), time(0.000 ms): <append+649>
lib/std/string.ci:208:[.0515a8, .0515bf) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:213:[.0515c0, .0515c1) exec(0), time(0.000 ms): <append+0>
lib/std/string.ci:215:[.0515c9, .0515d0) exec(0), time(0.000 ms): <append+9>
lib/std/string.ci:216:[.0515d0, .0515d5) exec(0), time(0.000 ms): <append+16>
lib/std/string.ci:214:[.0515c1, .0515d5) exec(0), time(0.000 ms): <append+1>
lib/std/string.ci:218:[.0515d5, .0515f1) exec(0), time(0.000 ms): <append+21>
lib/std/string.ci:224:[.051608, .051621) exec(0), time(0.000 ms): <append+0>
lib/vec/vec2d.ci:19:[.05162b, .05162e) exec(0), time(0.000 ms): <vec2d+3>
lib/vec/vec2d.ci:17:[.051628, .05162f) exec(0), time(0.000 ms): <vec2d+0>
lib/vec/vec4f.ci:29:[.051633, .051636) exec(0), time(0.000 ms): <vec4f+3>
lib/vec/vec4f.ci:29:[.051636, .051639) exec(0), time(0.000 ms): <vec4f+6>
lib/vec/vec4f.ci:29:[.051639, .05163c) exec(0), time(0.000 ms): <vec4f+9>
lib/vec/vec4f.ci:29:[.051630, .05163d) exec(0), time(0.000 ms): <vec4f+0>
lib/vec/mat4f.ci:32:[.051643, .051646) exec(0), time(0.000 ms): <mat4f+3>
lib/vec/mat4f.ci:32:[.051646, .051649) exec(0), time(0.000 ms): <mat4f+6>
lib/vec/mat4f.ci:32:[.051649, .05164c) exec(0), time(0.000 ms): <mat4f+9>
lib/vec/mat4f.ci:33:[.05164c, .05164f) exec(0), time(0.000 ms): <mat4f+12>
lib/vec/mat4f.ci:33:[.05164f, .051652) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:33:[.051652, .051655) exec(0), time(0.000 ms): <mat4f+18>
lib/vec/mat4f.ci:33:[.051655, .051658) exec(0), time(0.000 ms): <mat4f+21>
lib/vec/mat4f.ci:34:[.051658, .05165b) exec(0), time(0.000 ms): <mat4f+24>
lib/vec/mat4f.ci:34:[.05165b, .05165e) exec(0), time(0.000 ms): <mat4f+27>
lib/vec/mat4f.ci:34:[.05165e, .051661) exec(0), time(0.000 ms): <mat4f+30>
lib/vec/mat4f.ci:34:[.051661, .051664) exec(0), time(0.000 ms): <mat4f+33>
lib/vec/mat4f.ci:35:[.051664, .051667) exec(0), time(0.000 ms): <mat4f+36>
lib/vec/mat4f.ci:35:[.051667, .05166a) exec(0), time(0.000 ms): <mat4f+39>
lib/vec/mat4f.ci:35:[.05166a, .05166d) exec(0), time(0.000 ms): <mat4f+42>
lib/vec/mat4f.ci:35:[.05166d, .051670) exec(0), time(0.000 ms): <mat4f+45>
lib/vec/mat4f.ci:31:[.051640, .051671) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:41:[.05167d, .051682) exec(0), time(0.000 ms): <mat4f+5>
lib/vec/mat4f.ci:41:[.051682, .051687) exec(0), time(0.000 ms): <mat4f+10>
lib/vec/mat4f.ci:41:[.051687, .05168c) exec(0), time(0.000 ms): <mat4f+15>
lib/vec/mat4f.ci:41:[.051678, .05168d) exec(0), time(0.000 ms): <mat4f+0>
lib/vec/mat4f.ci:54:[.051694, .051699) exec(0), time(0.000 ms): <mul+4>
lib/vec/mat4f.ci:54:[.051699, .0516a2) exec(0), time(0.000 ms): <mul+9>
lib/vec/mat4f.ci:54:[.0516a2, .0516ab) exec(0), time(0.000 ms): <mul+18>
lib/vec/mat4f.ci:54:[.0516ab, .0516b4) exec(0), time(0.000 ms): <mul+27>
lib/vec/mat4f.ci:55:[.0516b4, .0516bd) exec(0), time(0.000 ms): <mul+36>
lib/vec/mat4f.ci:55:[.0516bd, .0516c6) exec(0), time(0.000 ms): <mul+45>
lib/vec/mat4f.ci:55:[.0516c6, .0516cf) exec(0), time(0.000 ms): <mul+54>
lib/vec/mat4f.ci:55:[.0516cf, .0516d8) exec(0), time(0.000 ms): <mul+63>
lib/vec/mat4f.ci:56:[.0516d8, .0516e1) exec(0), time(0.000 ms): <mul+72>
lib/vec/mat4f.ci:56:[.0516e1, .0516ea) exec(0), time(0.000 ms): <mul+81>
lib/vec/mat4f.ci:56:[.0516ea, .0516f3) exec(0), time(0.000 ms): <mul+90>
lib/vec/mat4f.ci:56:[.0516f3, .0516fc) exec(0), time(0.000 ms): <mul+99>
lib/vec/mat4f.ci:57:[.0516fc, .051705) exec(0), time(0.000 ms): <mul+108>
lib/vec/mat4f.ci:57:[.051705, .05170e) exec(0), time(0.000 ms): <mul+117>
lib/vec/mat4f.ci:57:[.05170e, .051717) exec(0), time(0.000 ms): <mul+126>
lib/vec/mat4f.ci:57:[.051717, .051720) exec(0), time(0.000 ms): <mul+135>
lib/vec/mat4f.ci:53:[.051690, .051720) exec(0), time(0.000 ms): <mul+0>
lib/vec/mat4f.ci:61:[.051760, .0517a4) exec(0), time(0.000 ms): <mul+208>
lib/vec/mat4f.ci:62:[.0517a4, .0517e8) exec(0), time(0.000 ms): <mul+276>
lib/vec/mat4f.ci:63:[.0517e8, .05182c) exec(0), time(0.000 ms): <mul+344>
lib/vec/mat4f.ci:59:[.051720, .051831) exec(0), time(0.000 ms): <mul+144>
test/lang/function.ci:8:[.051cd0, .051cd8) exec(2), time(0.011-0.011 ms): <funAdd+0>
test/lang/function.ci:34:[.051d10, .051d18) exec(2), time(0.010-0.010 ms): <funMul+0>
test/lang/function.ci:40:[.051d24, .051d28) exec(377), time(1.513-1.513 ms): <fib+12>
test/lang/function.ci:39:[.051d18, .051d28) exec(753-377), time(0.387-0.387 ms): <fib+0>
test/lang/function.ci:42:[.051d28, .051d4e) exec(376-375), time(9.931-9.931 ms): <fib+16>
test/stdc/tryExec.ci:15:[.052028, .05202c) exec(64-1), time(0.019-0.019 ms): <stackOverflow+0>
test/stdc/tryExec.ci:16:[.05202c, .05203b) exec(63-63), time(0.000 ms): <stackOverflow+4>
test/stdc/tryExec.ci:20:[.052040, .052047) exec(1-1), time(0.000 ms): <divisionByZero+0>
test/stdc/tryExec.ci:30:[.052054, .05205b) exec(1), time(0.000 ms): <abortExecution+4>
test/stdc/tryExec.ci:31:[.05205b, .052062) exec(1), time(0.000 ms): <abortExecution+11>
test/stdc/tryExec.ci:32:[.052062, .052069) exec(1), time(0.001-0.001 ms): <abortExecution+18>
test/stdc/tryExec.ci:29:[.052050, .052069) exec(1-1), time(0.000 ms): <abortExecution+0>
test/stdc/tryExec.ci:34:[.052069, .05208f) exec(1-1), time(0.000 ms): <abortExecution+25>
test/stdc/tryExec.ci:38:[.052098, .05209d) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
test/stdc/tryExec.ci:39:[.05209d, .0520a0) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
test/stdc/tryExec.ci:43:[.0520a8, .0520aa) exec(1-1), time(0.000 ms): <invalidInstruction+0>
test/lang/array.ci:103:[.052180, .052184) exec(5), time(0.020-0.020 ms): <lenSlice+0>
test/lang/array.ci:104:[.052188, .052194) exec(21), time(0.118-0.118 ms): <nthFixed+0>
test/lang/array.ci:105:[.052198, .0521a4) exec(21), time(0.111-0.111 ms): <nthArray+0>
test/lang/array.ci:106:[.0521a8, .0521b4) exec(14), time(0.072-0.072 ms): <nthSlice+0>
test/lang/method.ci:11:[.052208, .05222e) exec(3), time(0.225-0.225 ms): <staticMethod+0>
test/lang/method.ci:41:[.052238, .05225e) exec(4), time(0.268-0.268 ms): <virtualMethod+0>
test/lang/method.ci:48:[.052260, .052286) exec(0), time(0.000 ms): <forwardMethod+0>
test/lang/method.ci:58:[.052288, .0522ae) exec(0), time(0.000 ms): <globalFunction+0>
test/lang/method.ci:85:[.0522c0, .0522e3) exec(1), time(0.015-0.015 ms): <staticMethod+0>
test/lang/method.ci:87:[.0522f1, .052301) exec(1), time(0.113-0.113 ms): <staticMethod+49>
test/lang/method.ci:86:[.0522e3, .052301) exec(1-1), time(0.000 ms): <staticMethod+35>
test/lang/method.ci:91:[.052308, .05232b) exec(1), time(0.016-0.016 ms): <virtualMethod+0>
test/lang/method.ci:93:[.052339, .052346) exec(1), time(0.106-0.106 ms): <virtualMethod+49>
test/lang/method.ci:92:[.05232b, .052346) exec(1-1), time(0.000 ms): <virtualMethod+35>
lib/std/string.ci:144:[.052d8c, .052d9a) exec(1), time(0.002-0.002 ms): <.main+0>
lib/std/string.ci:145:[.052d9a, .052da8) exec(1), time(0.001-0.001 ms): <.main+14>
::[.052db1, .052db8) exec(1), time(0.001-0.001 ms): <.main+37>
::[.052db8, .052dbd) exec(1), time(0.000 ms): <.main+44>
::[.052dbd, .052dc2) exec(1), time(0.001-0.001 ms): <.main+49>
lib/std/string.ci:223:[.052da8, .052dc2) exec(1-1), time(0.000 ms): <.main+28>
test/lang/emit.ci:3:[.052dc2, .052dc7) exec(1), time(0.001-0.001 ms): <.main+54>
test/lang/emit.ci:4:[.052dc7, .052dcc) exec(1), time(0.001-0.001 ms): <.main+59>
test/lang/emit.ci:6:[.052dcc, .052dd5) exec(1), time(0.001-0.001 ms): <.main+64>
test/lang/emit.ci:7:[.052dd5, .052dde) exec(1), time(0.001-0.001 ms): <.main+73>
test/lang/emit.ci:9:[.052dde, .052deb) exec(1), time(0.001-0.001 ms): <.main+82>
test/lang/emit.ci:10:[.052deb, .052dfa) exec(1), time(0.001-0.001 ms): <.main+95>
test/lang/emit.ci:17:[.052dfa, .052e03) exec(1), time(0.000 ms): <.main+110>
test/lang/emit.ci:18:[.052e03, .052e0d) exec(1), time(0.000 ms): <.main+119>
test/lang/emit.ci:19:[.052e0d, .052e1b) exec(1), time(0.001-0.001 ms): <.main+129>
test/lang/emit.ci:20:[.052e1b, .052e28) exec(1), time(0.001-0.001 ms): <.main+143>
test/lang/emit.ci:23:[.052e28, .052e36) exec(1), time(0.000 ms): <.main+156>
test/lang/inlineMacros.ci:10:[.052e36, .052e3f) exec(1), time(0.000 ms): <.main+170>
test/lang/inlineMacros.ci:11:[.052e3f, .052e48) exec(1), time(0.001-0.001 ms): <.main+179>
test/lang/inlineMacros.ci:12:[.052e48, .052e51) exec(1), time(0.001-0.001 ms): <.main+188>
test/lang/inlineMacros.ci:13:[.052e51, .052e5a) exec(1), time(0.001-0.001 ms): <.main+197>
test/lang/inlineMacros.ci:15:[.052e5a, .052e5f) exec(1), time(0.001-0.001 ms): <.main+206>
test/lang/inlineMacros.ci:16:[.052e5f, .052e64) exec(1), time(0.000 ms): <.main+211>
test/lang/inlineMacros.ci:17:[.052e64, .052e69) exec(1), time(0.000 ms): <.main+216>
test/lang/inlineMacros.ci:19:[.052e69, .052e72) exec(1), time(0.000 ms): <.main+221>
test/lang/inlineMacros.ci:20:[.052e72, .052e7a) exec(1), time(0.001-0.001 ms): <.main+230>
test/lang/inlineMacros.ci:21:[.052e7a, .052e8a) exec(1), time(0.001-0.001 ms): <.main+238>
test/lang/inlineMacros.ci:23:[.052e8a, .052e97) exec(1), time(0.000 ms): <.main+254>
test/lang/inlineMacros.ci:24:[.052e97, .052ea4) exec(1), time(0.000 ms): <.main+267>
test/lang/inlineMacros.ci:25:[.052ea4, .052ebd) exec(1), time(0.001-0.001 ms): <.main+280>
test/lang/inlineMacros.ci:27:[.052ebd, .052ed9) exec(1), time(0.002-0.002 ms): <.main+305>
test/lang/inlineMacros.ci:28:[.052ed9, .052ef3) exec(1), time(0.002-0.002 ms): <.main+333>
test/lang/inlineMacros.ci:29:[.052ef3, .052f19) exec(1), time(0.002-0.002 ms): <.main+359>
test/lang/inlineMacros.ci:31:[.052f19, .052f3e) exec(1), time(0.003-0.003 ms): <.main+397>
test/lang/inlineMacros.ci:32:[.052f3e, .052f61) exec(1), time(0.003-0.003 ms): <.main+434>
test/lang/inlineMacros.ci:33:[.052f61, .052f90) exec(1), time(0.004-0.004 ms): <.main+469>
test/lang/inlineMacros.ci:35:[.052f90, .052fb5) exec(1), time(0.002-0.002 ms): <.main+516>
test/lang/inlineMacros.ci:36:[.052fb5, .052fd8) exec(1), time(0.002-0.002 ms): <.main+553>
test/lang/inlineMacros.ci:37:[.052fd8, .053007) exec(1), time(0.003-0.003 ms): <.main+588>
test/lang/inlineMacros.ci:41:[.053007, .053020) exec(1), time(0.001-0.001 ms): <.main+635>
test/lang/inlineMacros.ci:42:[.053020, .053035) exec(1), time(0.001-0.001 ms): <.main+660>
test/lang/inlineMacros.ci:43:[.053035, .05304c) exec(1), time(0.002-0.002 ms): <.main+681>
test/lang/inlineMacros.ci:44:[.05304c, .053063) exec(1), time(0.001-0.001 ms): <.main+704>
test/lang/inlineMacros.ci:45:[.053063, .05308e) exec(1), time(0.003-0.003 ms): <.main+727>
test/lang/inlineMacros.ci:46:[.05308e, .0530b9) exec(1), time(0.003-0.003 ms): <.main+770>
test/lang/inlineMacros.ci:50:[.0530b9, .0530fb) exec(1), time(0.001-0.001 ms): <.main+813>
test/lang/inlineMacros.ci:51:[.0530fb, .05313d) exec(1), time(0.004-0.004 ms): <.main+879>
test/lang/inlineMacros.ci:52:[.05313d, .05317b) exec(1), time(0.002-0.002 ms): <.main+945>
test/lang/inlineMacros.ci:53:[.05317b, .0531b9) exec(1), time(0.004-0.004 ms): <.main+1007>
test/lang/inlineMacros.ci:54:[.0531b9, .05320b) exec(1), time(0.002-0.002 ms): <.main+1069>
test/lang/inlineMacros.ci:55:[.05320b, .05325d) exec(1), time(0.005-0.005 ms): <.main+1151>
test/lang/inlineMacros.ci:59:[.05325d, .0532ba) exec(1), time(0.007-0.007 ms): <.main+1233>
test/lang/inlineMacros.ci:60:[.0532ba, .053317) exec(1), time(0.007-0.007 ms): <.main+1326>
test/lang/inlineMacros.ci:61:[.053317, .053370) exec(1), time(0.006-0.006 ms): <.main+1419>
test/lang/inlineMacros.ci:62:[.053370, .0533c9) exec(1), time(0.006-0.006 ms): <.main+1508>
test/lang/inlineMacros.ci:63:[.0533c9, .053436) exec(1), time(0.008-0.008 ms): <.main+1597>
test/lang/inlineMacros.ci:64:[.053436, .0534a3) exec(1), time(0.012-0.012 ms): <.main+1706>
test/lang/inlineMacros.ci:68:[.0534a3, .053500) exec(1), time(0.008-0.008 ms): <.main+1815>
test/lang/inlineMacros.ci:69:[.053500, .05355d) exec(1), time(0.006-0.006 ms): <.main+1908>
test/lang/inlineMacros.ci:70:[.05355d, .0535b6) exec(1), time(0.006-0.006 ms): <.main+2001>
test/lang/inlineMacros.ci:71:[.0535b6, .05360f) exec(1), time(0.007-0.007 ms): <.main+2090>
test/lang/inlineMacros.ci:72:[.05360f, .05367c) exec(1), time(0.007-0.007 ms): <.main+2179>
test/lang/inlineMacros.ci:73:[.05367c, .0536e9) exec(1), time(0.007-0.007 ms): <.main+2288>
test/lang/overload.inline.ci:9:[.0536e9, .0536f2) exec(1), time(0.000 ms): <.main+2397>
test/lang/overload.inline.ci:10:[.0536f2, .0536fb) exec(1), time(0.000 ms): <.main+2406>
test/lang/overload.inline.ci:11:[.0536fb, .053704) exec(1), time(0.001-0.001 ms): <.main+2415>
test/lang/overload.inline.ci:12:[.053704, .05370d) exec(1), time(0.001-0.001 ms): <.main+2424>
test/lang/overload.inline.ci:13:[.05370d, .053716) exec(1), time(0.000 ms): <.main+2433>
test/lang/overload.inline.ci:28:[.053716, .053723) exec(1), time(0.000 ms): <.main+2442>
test/lang/overload.inline.ci:29:[.053723, .05373f) exec(1), time(0.001-0.001 ms): <.main+2455>
test/lang/initByRef.ci:7:[.05373f, .05374c) exec(1), time(0.000 ms): <.main+2483>
test/lang/initByRef.ci:8:[.05374c, .053755) exec(1), time(0.001-0.001 ms): <.main+2496>
test/lang/initByRef.ci:9:[.053755, .05375e) exec(1), time(0.001-0.001 ms): <.main+2505>
test/lang/initByRef.ci:10:[.05375e, .05376c) exec(1), time(0.001-0.001 ms): <.main+2514>
test/lang/initByRef.ci:12:[.05376c, .053775) exec(1), time(0.001-0.001 ms): <.main+2528>
test/lang/initByRef.ci:13:[.053775, .05377d) exec(1), time(0.001-0.001 ms): <.main+2537>
test/lang/initByRef.ci:14:[.05377d, .053785) exec(1), time(0.000 ms): <.main+2545>
test/lang/initByRef.ci:16:[.053785, .05378e) exec(1), time(0.000 ms): <.main+2553>
test/lang/initByRef.ci:17:[.05378e, .053797) exec(1), time(0.000 ms): <.main+2562>
test/lang/initByRef.ci:18:[.053797, .0537a5) exec(1), time(0.001-0.001 ms): <.main+2571>
test/lang/initByRef.ci:19:[.0537a5, .0537ae) exec(1), time(0.001-0.001 ms): <.main+2585>
test/lang/initByRef.ci:20:[.0537ae, .0537b7) exec(1), time(0.001-0.001 ms): <.main+2594>
test/lang/initByRef.ci:21:[.0537b7, .0537c0) exec(1), time(0.001-0.001 ms): <.main+2603>
test/lang/initByRef.ci:23:[.0537c0, .0537c9) exec(1), time(0.000 ms): <.main+2612>
test/lang/initByRef.ci:24:[.0537c9, .0537d7) exec(1), time(0.000 ms): <.main+2621>
test/lang/initByRef.ci:25:[.0537d7, .0537e0) exec(1), time(0.000 ms): <.main+2635>
test/lang/initByRef.ci:27:[.0537e0, .0537e8) exec(1), time(0.000 ms): <.main+2644>
test/lang/initByRef.ci:28:[.0537e8, .0537f0) exec(1), time(0.001-0.001 ms): <.main+2652>
test/lang/initByRef.ci:29:[.0537f0, .0537f8) exec(1), time(0.001-0.001 ms): <.main+2660>
test/lang/initByRef.ci:30:[.0537f8, .053800) exec(1), time(0.000 ms): <.main+2668>
test/lang/initByRef.ci:31:[.053800, .053808) exec(1), time(0.000 ms): <.main+2676>
test/lang/initByRef.ci:32:[.053808, .053810) exec(1), time(0.000 ms): <.main+2684>
test/lang/initByRef.ci:35:[.053810, .053819) exec(1), time(0.000 ms): <.main+2692>
test/lang/initByRef.ci:36:[.053819, .053822) exec(1), time(0.001-0.001 ms): <.main+2701>
test/lang/initByRef.ci:37:[.053822, .05382b) exec(1), time(0.001-0.001 ms): <.main+2710>
test/lang/initByRef.ci:38:[.05382b, .053834) exec(1), time(0.001-0.001 ms): <.main+2719>
test/lang/initByRef.ci:39:[.053834, .05383d) exec(1), time(0.000 ms): <.main+2728>
test/lang/initByRef.ci:40:[.05383d, .053846) exec(1), time(0.000 ms): <.main+2737>
test/lang/initByRef.ci:41:[.053846, .05384f) exec(1), time(0.000 ms): <.main+2746>
test/lang/initByRef.ci:42:[.05384f, .053858) exec(1), time(0.001-0.001 ms): <.main+2755>
test/lang/initByRef.ci:43:[.053858, .053861) exec(1), time(0.001-0.001 ms): <.main+2764>
test/lang/initByRef.ci:44:[.053861, .05386a) exec(1), time(0.001-0.001 ms): <.main+2773>
test/lang/initByRef.ci:45:[.05386a, .053873) exec(1), time(0.000 ms): <.main+2782>
test/lang/initByRef.ci:46:[.053873, .05387c) exec(1), time(0.000 ms): <.main+2791>
test/lang/initByRef.ci:47:[.05387c, .053885) exec(1), time(0.000 ms): <.main+2800>
test/lang/initByRef.ci:48:[.053885, .05388e) exec(1), time(0.001-0.001 ms): <.main+2809>
test/lang/initByRef.ci:49:[.05388e, .053897) exec(1), time(0.001-0.001 ms): <.main+2818>
test/lang/initByRef.ci:50:[.053897, .0538a0) exec(1), time(0.001-0.001 ms): <.main+2827>
test/lang/initByRef.ci:51:[.0538a0, .0538a9) exec(1), time(0.000 ms): <.main+2836>
test/lang/initByRef.ci:52:[.0538a9, .0538b2) exec(1), time(0.000 ms): <.main+2845>
test/lang/initByRef.ci:55:[.0538b2, .0538c0) exec(1), time(0.001-0.001 ms): <.main+2854>
test/lang/initByRef.ci:56:[.0538c0, .0538ce) exec(1), time(0.001-0.001 ms): <.main+2868>
test/lang/initByRef.ci:57:[.0538ce, .0538dc) exec(1), time(0.001-0.001 ms): <.main+2882>
test/lang/initByRef.ci:58:[.0538dc, .0538ea) exec(1), time(0.001-0.001 ms): <.main+2896>
test/lang/initByRef.ci:59:[.0538ea, .0538f8) exec(1), time(0.001-0.001 ms): <.main+2910>
test/lang/initByRef.ci:60:[.0538f8, .053906) exec(1), time(0.001-0.001 ms): <.main+2924>
test/lang/initByRef.ci:61:[.053906, .053914) exec(1), time(0.000 ms): <.main+2938>
test/lang/initByRef.ci:62:[.053914, .053922) exec(1), time(0.000 ms): <.main+2952>
test/lang/initByRef.ci:63:[.053922, .053930) exec(1), time(0.001-0.001 ms): <.main+2966>
test/lang/initByRef.ci:64:[.053930, .05393e) exec(1), time(0.001-0.001 ms): <.main+2980>
test/lang/initByRef.ci:65:[.05393e, .05394c) exec(1), time(0.001-0.001 ms): <.main+2994>
test/lang/initByRef.ci:66:[.05394c, .05395a) exec(1), time(0.001-0.001 ms): <.main+3008>
test/lang/initByRef.ci:67:[.05395a, .053968) exec(1), time(0.000 ms): <.main+3022>
test/lang/initByRef.ci:68:[.053968, .053976) exec(1), time(0.000 ms): <.main+3036>
test/lang/initByRef.ci:69:[.053976, .053984) exec(1), time(0.001-0.001 ms): <.main+3050>
test/lang/initByRef.ci:70:[.053984, .053992) exec(1), time(0.001-0.001 ms): <.main+3064>
test/lang/initByRef.ci:71:[.053992, .0539a0) exec(1), time(0.001-0.001 ms): <.main+3078>
test/lang/initByRef.ci:72:[.0539a0, .0539ae) exec(1), time(0.001-0.001 ms): <.main+3092>
test/lang/initByRef.ci:75:[.0539ae, .0539b7) exec(1), time(0.000 ms): <.main+3106>
test/lang/initByRef.ci:76:[.0539b7, .0539c0) exec(1), time(0.001-0.001 ms): <.main+3115>
test/lang/initByRef.ci:77:[.0539c0, .0539c9) exec(1), time(0.001-0.001 ms): <.main+3124>
test/lang/initByRef.ci:78:[.0539c9, .0539d2) exec(1), time(0.001-0.001 ms): <.main+3133>
test/lang/initByRef.ci:79:[.0539d2, .0539db) exec(1), time(0.001-0.001 ms): <.main+3142>
test/lang/initByRef.ci:80:[.0539db, .0539e4) exec(1), time(0.000 ms): <.main+3151>
test/lang/initByRef.ci:81:[.0539e4, .0539ed) exec(1), time(0.000 ms): <.main+3160>
test/lang/initByRef.ci:82:[.0539ed, .0539f6) exec(1), time(0.000 ms): <.main+3169>
test/lang/initByRef.ci:83:[.0539f6, .0539ff) exec(1), time(0.000 ms): <.main+3178>
test/lang/initByRef.ci:84:[.0539ff, .053a08) exec(1), time(0.000 ms): <.main+3187>
test/lang/initByRef.ci:85:[.053a08, .053a11) exec(1), time(0.001-0.001 ms): <.main+3196>
test/lang/initByRef.ci:86:[.053a11, .053a1a) exec(1), time(0.001-0.001 ms): <.main+3205>
test/lang/initByRef.ci:87:[.053a1a, .053a23) exec(1), time(0.001-0.001 ms): <.main+3214>
test/lang/initByRef.ci:88:[.053a23, .053a2c) exec(1), time(0.001-0.001 ms): <.main+3223>
test/lang/initByRef.ci:89:[.053a2c, .053a35) exec(1), time(0.000 ms): <.main+3232>
test/lang/initByRef.ci:90:[.053a35, .053a3e) exec(1), time(0.000 ms): <.main+3241>
test/lang/initByRef.ci:91:[.053a3e, .053a47) exec(1), time(0.000 ms): <.main+3250>
test/lang/initByRef.ci:92:[.053a47, .053a50) exec(1), time(0.000 ms): <.main+3259>
test/lang/initByRef.ci:95:[.053a50, .053a59) exec(1), time(0.000 ms): <.main+3268>
test/lang/initByRef.ci:96:[.053a59, .053a67) exec(1), time(0.000 ms): <.main+3277>
test/lang/initByRef.ci:97:[.053a67, .053a70) exec(1), time(0.000 ms): <.main+3291>
test/lang/initByRef.ci:99:[.053a70, .053a79) exec(1), time(0.000 ms): <.main+3300>
test/lang/initByRef.ci:105:[.053a79, .053a86) exec(1), time(0.000 ms): <.main+3309>
test/lang/initByRef.ci:108:[.053a86, .053a8e) exec(1), time(0.000 ms): <.main+3322>
test/lang/function.ci:12:[.053a8e, .053aa7) exec(1), time(0.019-0.019 ms): <.main+3330>
test/lang/function.ci:15:[.053aa7, .053ab0) exec(1), time(0.000 ms): <.main+3355>
test/lang/function.ci:18:[.053ab0, .053ac8) exec(1), time(0.014-0.014 ms): <.main+3364>
test/lang/function.ci:21:[.053ac8, .053ad1) exec(1), time(0.000 ms): <.main+3388>
test/lang/function.ci:24:[.053ad1, .053ae9) exec(1), time(0.014-0.014 ms): <.main+3397>
test/lang/function.ci:27:[.053ae9, .053af1) exec(1), time(0.001-0.001 ms): <.main+3421>
test/lang/function.ci:30:[.053af1, .053b09) exec(1), time(0.014-0.014 ms): <.main+3429>
test/lang/function.ci:46:[.053b09, .053b1d) exec(1), time(9.942-9.942 ms): <.main+3453>
test/lang/reflect.ci:3:[.053b1d, .053b25) exec(1), time(0.000 ms): <.main+3473>
test/lang/reflect.ci:4:[.053b25, .053b2d) exec(1), time(0.000 ms): <.main+3481>
test/lang/reflect.ci:5:[.053b2d, .053b35) exec(1), time(0.000 ms): <.main+3489>
test/lang/reflect.ci:6:[.053b35, .053b3d) exec(1), time(0.000 ms): <.main+3497>
test/lang/reflect.ci:7:[.053b3d, .053b45) exec(1), time(0.000 ms): <.main+3505>
test/lang/reflect.ci:8:[.053b45, .053b4d) exec(1), time(0.000 ms): <.main+3513>
test/lang/reflect.ci:9:[.053b4d, .053b55) exec(1), time(0.001-0.001 ms): <.main+3521>
test/lang/reflect.ci:10:[.053b55, .053b5d) exec(1), time(0.001-0.001 ms): <.main+3529>
test/lang/reflect.ci:11:[.053b5d, .053b65) exec(1), time(0.000 ms): <.main+3537>
test/lang/reflect.ci:12:[.053b65, .053b6d) exec(1), time(0.001-0.001 ms): <.main+3545>
test/lang/reflect.ci:13:[.053b6d, .053b75) exec(1), time(0.001-0.001 ms): <.main+3553>
test/lang/reflect.ci:14:[.053b75, .053b7d) exec(1), time(0.001-0.001 ms): <.main+3561>
test/lang/reflect.ci:15:[.053b7d, .053b85) exec(1), time(0.001-0.001 ms): <.main+3569>
test/lang/reflect.ci:16:[.053b85, .053b8d) exec(1), time(0.000 ms): <.main+3577>
test/lang/reflect.ci:17:[.053b8d, .053b95) exec(1), time(0.000 ms): <.main+3585>
test/lang/reflect.ci:18:[.053b95, .053b9d) exec(1), time(0.000 ms): <.main+3593>
test/lang/reflect.ci:19:[.053b9d, .053ba5) exec(1), time(0.000 ms): <.main+3601>
test/lang/reflect.ci:20:[.053ba5, .053bad) exec(1), time(0.000 ms): <.main+3609>
test/lang/reflect.ci:30:[.053bad, .053bb6) exec(1), time(0.001-0.001 ms): <.main+3617>
test/lang/reflect.ci:31:[.053bb6, .053bc2) exec(1), time(0.019-0.019 ms): <.main+3626>
test/lang/reflect.ci:32:[.053bc2, .053bcf) exec(1), time(0.002-0.002 ms): <.main+3638>
test/lang/reflect.ci:33:[.053bcf, .053bdc) exec(1), time(0.002-0.002 ms): <.main+3651>
test/lang/reflect.ci:34:[.053bdc, .053be8) exec(1), time(0.016-0.016 ms): <.main+3664>
test/lang/reflect.ci:35:[.053be8, .053bf4) exec(1), time(0.016-0.016 ms): <.main+3676>
test/lang/reflect.ci:37:[.053bf4, .053c00) exec(1), time(0.016-0.016 ms): <.main+3688>
test/lang/reflect.ci:38:[.053c00, .053c0c) exec(1), time(0.015-0.015 ms): <.main+3700>
test/lang/reflect.ci:39:[.053c0c, .053c19) exec(1), time(0.001-0.001 ms): <.main+3712>
test/lang/reflect.ci:40:[.053c19, .053c26) exec(1), time(0.001-0.001 ms): <.main+3725>
test/lang/reflect.ci:41:[.053c26, .053c32) exec(1), time(0.016-0.016 ms): <.main+3738>
test/lang/reflect.ci:42:[.053c32, .053c3e) exec(1), time(0.016-0.016 ms): <.main+3750>
test/lang/reflect.ci:44:[.053c3e, .053c4a) exec(1), time(0.016-0.016 ms): <.main+3762>
test/lang/reflect.ci:45:[.053c4a, .053c57) exec(1), time(0.002-0.002 ms): <.main+3774>
test/lang/reflect.ci:46:[.053c57, .053c64) exec(1), time(0.002-0.002 ms): <.main+3787>
test/lang/reflect.ci:48:[.053c64, .053c70) exec(1), time(0.014-0.014 ms): <.main+3800>
test/lang/reflect.ci:49:[.053c70, .053c7d) exec(1), time(0.002-0.002 ms): <.main+3812>
test/lang/reflect.ci:50:[.053c7d, .053c8a) exec(1), time(0.001-0.001 ms): <.main+3825>
test/stdc/number.ci:3:[.053c8a, .053c97) exec(1), time(0.001-0.001 ms): <.main+3838>
test/stdc/number.ci:4:[.053c97, .053ca4) exec(1), time(0.001-0.001 ms): <.main+3851>
test/stdc/number.ci:6:[.053ca4, .053cad) exec(1), time(0.001-0.001 ms): <.main+3864>
test/stdc/number.ci:7:[.053cad, .053cb6) exec(1), time(0.001-0.001 ms): <.main+3873>
test/stdc/number.ci:14:[.053cb6, .053cc1) exec(1), time(0.001-0.001 ms): <.main+3882>
test/stdc/number.ci:15:[.053cc1, .053ccc) exec(1), time(0.001-0.001 ms): <.main+3893>
test/stdc/number.ci:16:[.053ccc, .053cd7) exec(1), time(0.001-0.001 ms): <.main+3904>
test/stdc/number.ci:18:[.053cd7, .053cfd) exec(1), time(0.005-0.005 ms): <.main+3915>
test/stdc/number.ci:19:[.053cfd, .053d21) exec(1), time(0.005-0.005 ms): <.main+3953>
test/stdc/number.ci:21:[.053d21, .053d37) exec(1), time(0.016-0.016 ms): <.main+3989>
test/stdc/number.ci:22:[.053d37, .053d4d) exec(1), time(0.015-0.015 ms): <.main+4011>
test/stdc/number.ci:23:[.053d4d, .053d5f) exec(1), time(0.015-0.015 ms): <.main+4033>
test/stdc/number.ci:25:[.053d5f, .053d75) exec(1), time(0.015-0.015 ms): <.main+4051>
test/stdc/number.ci:26:[.053d75, .053d8b) exec(1), time(0.014-0.014 ms): <.main+4073>
test/stdc/number.ci:27:[.053d8b, .053d9d) exec(1), time(0.014-0.014 ms): <.main+4095>
test/stdc/number.ci:29:[.053d9d, .053db3) exec(1), time(0.015-0.015 ms): <.main+4113>
test/stdc/number.ci:30:[.053db3, .053dc9) exec(1), time(0.015-0.015 ms): <.main+4135>
test/stdc/number.ci:31:[.053dc9, .053ddb) exec(1), time(0.015-0.015 ms): <.main+4157>
test/stdc/number.ci:33:[.053ddb, .053df1) exec(1), time(0.015-0.015 ms): <.main+4175>
test/stdc/number.ci:34:[.053df1, .053e07) exec(1), time(0.014-0.014 ms): <.main+4197>
test/stdc/number.ci:35:[.053e07, .053e19) exec(1), time(0.016-0.016 ms): <.main+4219>
test/stdc/number.ci:37:[.053e19, .053e2f) exec(1), time(0.029-0.029 ms): <.main+4237>
test/stdc/number.ci:38:[.053e2f, .053e45) exec(1), time(0.017-0.017 ms): <.main+4259>
test/stdc/number.ci:39:[.053e45, .053e5b) exec(1), time(0.015-0.015 ms): <.main+4281>
test/stdc/number.ci:40:[.053e5b, .053e71) exec(1), time(0.016-0.016 ms): <.main+4303>
test/stdc/number.ci:41:[.053e71, .053e82) exec(1), time(0.015-0.015 ms): <.main+4325>
test/stdc/number.ci:42:[.053e82, .053e9c) exec(1), time(0.017-0.017 ms): <.main+4342>
test/stdc/number.ci:43:[.053e9c, .053ead) exec(1), time(0.015-0.015 ms): <.main+4368>
test/stdc/number.ci:44:[.053ead, .053ec2) exec(1), time(0.017-0.017 ms): <.main+4385>
test/stdc/number.ci:46:[.053ec2, .053ed4) exec(1), time(0.015-0.015 ms): <.main+4406>
test/stdc/number.ci:47:[.053ed4, .053ee6) exec(1), time(0.015-0.015 ms): <.main+4424>
test/stdc/number.ci:48:[.053ee6, .053ef8) exec(1), time(0.016-0.016 ms): <.main+4442>
test/stdc/number.ci:49:[.053ef8, .053f0e) exec(1), time(0.018-0.018 ms): <.main+4460>
test/stdc/number.ci:50:[.053f0e, .053f1b) exec(1), time(0.016-0.016 ms): <.main+4482>
test/stdc/number.ci:51:[.053f1b, .053f31) exec(1), time(0.015-0.015 ms): <.main+4495>
test/stdc/number.ci:52:[.053f31, .053f42) exec(1), time(0.014-0.014 ms): <.main+4517>
test/stdc/number.ci:53:[.053f42, .053f53) exec(1), time(0.016-0.016 ms): <.main+4534>
test/stdc/number.ci:55:[.053f53, .053f5f) exec(1), time(0.014-0.014 ms): <.main+4551>
test/stdc/number.ci:56:[.053f5f, .053f6b) exec(1), time(0.014-0.014 ms): <.main+4563>
test/stdc/number.ci:57:[.053f6b, .053f77) exec(1), time(0.014-0.014 ms): <.main+4575>
test/stdc/number.ci:58:[.053f77, .053f83) exec(1), time(0.013-0.013 ms): <.main+4587>
test/stdc/number.ci:59:[.053f83, .053f8f) exec(1), time(0.014-0.014 ms): <.main+4599>
test/stdc/number.ci:60:[.053f8f, .053f9b) exec(1), time(0.013-0.013 ms): <.main+4611>
test/stdc/number.ci:62:[.053f9b, .053fad) exec(1), time(0.017-0.017 ms): <.main+4623>
test/stdc/number.ci:63:[.053fad, .053fbf) exec(1), time(0.015-0.015 ms): <.main+4641>
test/stdc/number.ci:65:[.053fbf, .053fd3) exec(1), time(0.016-0.016 ms): <.main+4659>
test/stdc/number.ci:66:[.053fd3, .053fe7) exec(1), time(0.015-0.015 ms): <.main+4679>
test/stdc/memory.ci:7:[.053fe7, .053ff9) exec(1), time(0.015-0.015 ms): <.main+4699>
test/stdc/memory.ci:8:[.053ff9, .05400b) exec(1), time(0.015-0.015 ms): <.main+4717>
test/stdc/memory.ci:9:[.05400b, .05401d) exec(1), time(0.018-0.018 ms): <.main+4735>
test/stdc/memory.ci:10:[.05401d, .05402f) exec(1), time(0.016-0.016 ms): <.main+4753>
test/stdc/memory.ci:23:[.05402f, .05403c) exec(1), time(0.000 ms): <.main+4771>
test/stdc/memory.ci:24:[.05403c, .054049) exec(1), time(0.001-0.001 ms): <.main+4784>
test/stdc/tryExec.ci:46:[.054049, .05405b) exec(1), time(0.036-0.036 ms): <.main+4797>
test/stdc/tryExec.ci:47:[.05405b, .05406d) exec(1), time(0.016-0.016 ms): <.main+4815>
test/stdc/tryExec.ci:48:[.05406d, .05407f) exec(1), time(0.802-0.802 ms): <.main+4833>
test/stdc/tryExec.ci:49:[.05407f, .054091) exec(1), time(0.025-0.025 ms): <.main+4851>
test/stdc/tryExec.ci:50:[.054091, .0540a3) exec(1), time(0.025-0.025 ms): <.main+4869>
test/stdc/tryExec.ci:51:[.0540a3, .0540b5) exec(1), time(0.025-0.025 ms): <.main+4887>
test/stdc/tryExec.ci:52:[.0540b5, .0540c7) exec(1), time(0.089-0.089 ms): <.main+4905>
test/lang/array.ci:59:[.0540c7, .0540d0) exec(1), time(0.000 ms): <.main+4923>
test/lang/array.ci:60:[.0540d0, .0540da) exec(1), time(0.001-0.001 ms): <.main+4932>
test/lang/array.ci:63:[.0540da, .0540e3) exec(1), time(0.000 ms): <.main+4942>
test/lang/array.ci:64:[.0540e3, .0540f1) exec(1), time(0.001-0.001 ms): <.main+4951>
test/lang/array.ci:67:[.0540f1, .0540f9) exec(1), time(0.001-0.001 ms): <.main+4965>
test/lang/array.ci:68:[.0540f9, .054101) exec(1), time(0.000 ms): <.main+4973>
test/lang/array.ci:71:[.054101, .054109) exec(1), time(0.000 ms): <.main+4981>
test/lang/array.ci:86:[.054109, .054112) exec(1), time(0.001-0.001 ms): <.main+4989>
test/lang/array.ci:90:[.054112, .054120) exec(1), time(0.001-0.001 ms): <.main+4998>
test/lang/member.ci:35:[.054120, .054125) exec(1), time(0.001-0.001 ms): <.main+5012>
test/lang/member.ci:38:[.054125, .05412e) exec(1), time(0.001-0.001 ms): <.main+5017>
test/lang/member.ci:41:[.05412e, .054137) exec(1), time(0.001-0.001 ms): <.main+5026>
test/lang/member.ci:47:[.054140, .054149) exec(1), time(0.000 ms): <.main+5044>
test/lang/member.ci:47:[.054137, .054149) exec(1-1), time(0.000 ms): <.main+5035>
test/lang/member.ci:50:[.054152, .05415b) exec(1), time(0.001-0.001 ms): <.main+5062>
test/lang/member.ci:50:[.054149, .05415b) exec(1-1), time(0.000 ms): <.main+5053>
test/lang/member.ci:55:[.054164, .05416d) exec(1), time(0.001-0.001 ms): <.main+5080>
test/lang/member.ci:56:[.05416d, .054176) exec(1), time(0.001-0.001 ms): <.main+5089>
test/lang/member.ci:57:[.054176, .05417f) exec(1), time(0.000 ms): <.main+5098>
test/lang/member.ci:60:[.05417f, .054188) exec(1), time(0.000 ms): <.main+5107>
test/lang/member.ci:61:[.054188, .054191) exec(1), time(0.001-0.001 ms): <.main+5116>
test/lang/member.ci:65:[.054191, .05419a) exec(1), time(0.001-0.001 ms): <.main+5125>
test/lang/member.ci:66:[.05419a, .0541a3) exec(1), time(0.001-0.001 ms): <.main+5134>
test/lang/member.ci:53:[.05415b, .0541a3) exec(1-1), time(0.000 ms): <.main+5071>
test/lang/method.ci:18:[.0541a3, .0541ac) exec(1), time(0.000 ms): <.main+5143>
::[.0541b5, .0541bd) exec(1), time(0.001-0.001 ms): <.main+5161>
::[.0541bd, .0541c6) exec(1), time(0.001-0.001 ms): <.main+5169>
test/lang/method.ci:62:[.0541ac, .0541c6) exec(1-1), time(0.000 ms): <.main+5152>
test/lang/recUnion.ci:26:[.0541cd, .0541d4) exec(1), time(0.001-0.001 ms): <.main+5185>
test/lang/recUnion.ci:26:[.0541d4, .0541db) exec(1), time(0.001-0.001 ms): <.main+5192>
test/lang/recUnion.ci:26:[.0541c6, .0541db) exec(1-1), time(0.000 ms): <.main+5178>
test/lang/recUnion.ci:27:[.0541e2, .0541ed) exec(1), time(0.001-0.001 ms): <.main+5206>
test/lang/recUnion.ci:27:[.0541ed, .0541f4) exec(1), time(0.001-0.001 ms): <.main+5217>
test/lang/recUnion.ci:27:[.0541db, .0541f4) exec(1-1), time(0.000 ms): <.main+5199>
test/lang/recUnion.ci:28:[.0541ff, .05420a) exec(1), time(0.001-0.001 ms): <.main+5235>
test/lang/recUnion.ci:28:[.05420a, .054215) exec(1), time(0.001-0.001 ms): <.main+5246>
test/lang/recUnion.ci:28:[.0541f4, .054215) exec(1-1), time(0.000 ms): <.main+5224>
test/lang/recUnion.ci:30:[.054215, .05421e) exec(1), time(0.000 ms): <.main+5257>
test/lang/recUnion.ci:31:[.054225, .05422c) exec(1), time(0.001-0.001 ms): <.main+5273>
test/lang/recUnion.ci:31:[.05422c, .054237) exec(1), time(0.001-0.001 ms): <.main+5280>
test/lang/recUnion.ci:31:[.05421e, .054237) exec(1-1), time(0.000 ms): <.main+5266>
test/lang/useOperator.ci:5:[.054237, .054240) exec(1), time(0.000 ms): <.main+5291>
test/lang/useOperator.ci:7:[.054240, .05424b) exec(1), time(0.001-0.001 ms): <.main+5300>
test/lang/useOperator.ci:8:[.05424b, .054256) exec(1), time(0.001-0.001 ms): <.main+5311>
test/lang/useOperator.ci:17:[.054256, .054269) exec(1), time(0.003-0.003 ms): <.main+5322>
test/lang/useOperator.ci:18:[.054269, .05427c) exec(1), time(0.003-0.003 ms): <.main+5341>
test/lang/useOperator.ci:19:[.05427c, .05428f) exec(1), time(0.003-0.003 ms): <.main+5360>
test/lang/useOperator.ci:22:[.05428f, .05429c) exec(1), time(0.002-0.002 ms): <.main+5379>
test/lang/useOperator.ci:23:[.05429c, .0542af) exec(1), time(0.003-0.003 ms): <.main+5392>
test/lang/useOperator.ci:24:[.0542af, .0542c3) exec(1), time(0.003-0.003 ms): <.main+5411>
test/lang/useOperator.ci:25:[.0542c3, .0542d6) exec(1), time(0.003-0.003 ms): <.main+5431>
test/lang/useOperator.ci:26:[.0542d6, .0542ea) exec(1), time(0.004-0.004 ms): <.main+5450>
test/lang/useOperator.ci:27:[.0542ea, .0542fd) exec(1), time(0.003-0.003 ms): <.main+5470>
test/lang/useOperator.ci:28:[.0542fd, .054311) exec(1), time(0.004-0.004 ms): <.main+5489>
test/lang/useOperator.ci:30:[.054311, .05431c) exec(1), time(0.002-0.002 ms): <.main+5509>
test/lang/useOperator.ci:31:[.05431c, .054327) exec(1), time(0.001-0.001 ms): <.main+5520>
test/lang/useOperator.ci:32:[.054327, .054333) exec(1), time(0.002-0.002 ms): <.main+5531>
test/lang/useOperator.ci:33:[.054333, .054340) exec(1), time(0.002-0.002 ms): <.main+5543>
test/lang/useOperator.ci:34:[.054340, .05434d) exec(1), time(0.002-0.002 ms): <.main+5556>
test/lang/useOperator.ci:35:[.05434d, .054360) exec(1), time(0.003-0.003 ms): <.main+5569>
test/lang/useOperator.ci:36:[.054360, .054373) exec(1), time(0.003-0.003 ms): <.main+5588>
test/lang/useOperator.ci:37:[.054373, .054386) exec(1), time(0.003-0.003 ms): <.main+5607>
test/lang/useOperator.ci:38:[.054386, .054399) exec(1), time(0.003-0.003 ms): <.main+5626>
test/lang/useOperator.ci:39:[.054399, .0543ac) exec(1), time(0.003-0.003 ms): <.main+5645>
test/lang/useOperator.ci:40:[.0543ac, .0543bf) exec(1), time(0.003-0.003 ms): <.main+5664>
test/lang/useOperator.ci:41:[.0543bf, .0543d2) exec(1), time(0.003-0.003 ms): <.main+5683>
test/lang/useOperator.ci:42:[.0543d2, .0543e5) exec(1), time(0.003-0.003 ms): <.main+5702>
test/lang/useOperator.ci:43:[.0543e5, .0543f6) exec(1), time(0.003-0.003 ms): <.main+5721>
test/lang/useOperator.ci:44:[.0543f6, .054407) exec(1), time(0.002-0.002 ms): <.main+5738>
test/lang/useOperator.ci:45:[.054407, .054415) exec(1), time(0.003-0.003 ms): <.main+5755>
test/lang/useOperator.ci:46:[.054415, .054428) exec(1), time(0.003-0.003 ms): <.main+5769>
test/lang/useOperator.ci:47:[.054428, .05443c) exec(1), time(0.004-0.004 ms): <.main+5788>
test/lang/useOperator.ci:48:[.05443c, .05444f) exec(1), time(0.003-0.003 ms): <.main+5808>
test/lang/useOperator.ci:49:[.05444f, .054463) exec(1), time(0.004-0.004 ms): <.main+5827>
test/lang/useOperator.ci:50:[.054463, .054476) exec(1), time(0.003-0.003 ms): <.main+5847>
test/lang/useOperator.ci:51:[.054476, .05448a) exec(1), time(0.004-0.004 ms): <.main+5866>
test/lang/useOperator.ci:53:[.05448a, .054495) exec(1), time(0.001-0.001 ms): <.main+5886>
test/lang/useOperator.ci:54:[.054495, .0544a0) exec(1), time(0.001-0.001 ms): <.main+5897>
test/lang/useOperator.ci:55:[.0544a0, .0544ac) exec(1), time(0.002-0.002 ms): <.main+5908>
test/lang/useOperator.ci:56:[.0544ac, .0544b9) exec(1), time(0.003-0.003 ms): <.main+5920>
test/lang/useOperator.ci:57:[.0544b9, .0544c6) exec(1), time(0.003-0.003 ms): <.main+5933>
test/lang/useOperator.ci:58:[.0544c6, .0544d9) exec(1), time(0.004-0.004 ms): <.main+5946>
test/lang/useOperator.ci:59:[.0544d9, .0544ec) exec(1), time(0.002-0.002 ms): <.main+5965>
test/lang/useOperator.ci:60:[.0544ec, .0544ff) exec(1), time(0.003-0.003 ms): <.main+5984>
test/lang/useOperator.ci:61:[.0544ff, .054512) exec(1), time(0.003-0.003 ms): <.main+6003>
test/lang/useOperator.ci:62:[.054512, .054525) exec(1), time(0.002-0.002 ms): <.main+6022>
test/lang/useOperator.ci:63:[.054525, .054538) exec(1), time(0.003-0.003 ms): <.main+6041>
test/lang/useOperator.ci:64:[.054538, .05454b) exec(1), time(0.003-0.003 ms): <.main+6060>
test/lang/useOperator.ci:65:[.05454b, .05455e) exec(1), time(0.003-0.003 ms): <.main+6079>
test/lang/useOperator.ci:66:[.05455e, .05456f) exec(1), time(0.002-0.002 ms): <.main+6098>
test/lang/useOperator.ci:67:[.05456f, .054580) exec(1), time(0.002-0.002 ms): <.main+6115>
test/lang/useOperator.ci:68:[.054580, .05458e) exec(1), time(0.002-0.002 ms): <.main+6132>
test/lang/useOperator.ci:69:[.05458e, .0545a1) exec(1), time(0.003-0.003 ms): <.main+6146>
test/lang/useOperator.ci:70:[.0545a1, .0545b5) exec(1), time(0.003-0.003 ms): <.main+6165>
test/lang/useOperator.ci:71:[.0545b5, .0545c8) exec(1), time(0.002-0.002 ms): <.main+6185>
test/lang/useOperator.ci:72:[.0545c8, .0545dc) exec(1), time(0.003-0.003 ms): <.main+6204>
test/lang/useOperator.ci:73:[.0545dc, .0545ef) exec(1), time(0.002-0.002 ms): <.main+6224>
test/lang/useOperator.ci:74:[.0545ef, .054603) exec(1), time(0.003-0.003 ms): <.main+6243>
test/lang/useOperator.ci:76:[.054603, .05460e) exec(1), time(0.001-0.001 ms): <.main+6263>
test/lang/useOperator.ci:77:[.05460e, .054619) exec(1), time(0.001-0.001 ms): <.main+6274>
test/lang/useOperator.ci:78:[.054619, .054625) exec(1), time(0.002-0.002 ms): <.main+6285>
test/lang/useOperator.ci:79:[.054625, .054632) exec(1), time(0.002-0.002 ms): <.main+6297>
test/lang/useOperator.ci:80:[.054632, .05463f) exec(1), time(0.002-0.002 ms): <.main+6310>
test/lang/useOperator.ci:81:[.05463f, .054652) exec(1), time(0.003-0.003 ms): <.main+6323>
test/lang/useOperator.ci:82:[.054652, .054665) exec(1), time(0.003-0.003 ms): <.main+6342>
test/lang/useOperator.ci:83:[.054665, .054678) exec(1), time(0.003-0.003 ms): <.main+6361>
test/lang/useOperator.ci:84:[.054678, .05468b) exec(1), time(0.002-0.002 ms): <.main+6380>
test/lang/useOperator.ci:85:[.05468b, .05469e) exec(1), time(0.003-0.003 ms): <.main+6399>
test/lang/useOperator.ci:86:[.05469e, .0546b1) exec(1), time(0.003-0.003 ms): <.main+6418>
test/lang/useOperator.ci:87:[.0546b1, .0546c4) exec(1), time(0.003-0.003 ms): <.main+6437>
test/lang/useOperator.ci:88:[.0546c4, .0546d7) exec(1), time(0.003-0.003 ms): <.main+6456>
test/lang/useOperator.ci:89:[.0546d7, .0546e8) exec(1), time(0.002-0.002 ms): <.main+6475>
test/lang/useOperator.ci:90:[.0546e8, .0546f9) exec(1), time(0.002-0.002 ms): <.main+6492>
test/lang/useOperator.ci:91:[.0546f9, .054707) exec(1), time(0.002-0.002 ms): <.main+6509>
test/lang/useOperator.ci:92:[.054707, .05471a) exec(1), time(0.003-0.003 ms): <.main+6523>
test/lang/useOperator.ci:93:[.05471a, .05472e) exec(1), time(0.003-0.003 ms): <.main+6542>
test/lang/useOperator.ci:94:[.05472e, .054741) exec(1), time(0.003-0.003 ms): <.main+6562>
test/lang/useOperator.ci:95:[.054741, .054755) exec(1), time(0.003-0.003 ms): <.main+6581>
test/lang/useOperator.ci:96:[.054755, .054768) exec(1), time(0.003-0.003 ms): <.main+6601>
test/lang/useOperator.ci:97:[.054768, .05477c) exec(1), time(0.003-0.003 ms): <.main+6620>
test/lang/useOperator.ci:99:[.05477c, .054787) exec(1), time(0.001-0.001 ms): <.main+6640>
test/lang/useOperator.ci:100:[.054787, .054792) exec(1), time(0.002-0.002 ms): <.main+6651>
test/lang/useOperator.ci:101:[.054792, .05479e) exec(1), time(0.002-0.002 ms): <.main+6662>
test/lang/useOperator.ci:102:[.05479e, .0547ab) exec(1), time(0.002-0.002 ms): <.main+6674>
test/lang/useOperator.ci:103:[.0547ab, .0547b8) exec(1), time(0.002-0.002 ms): <.main+6687>
test/lang/useOperator.ci:104:[.0547b8, .0547cb) exec(1), time(0.003-0.003 ms): <.main+6700>
test/lang/useOperator.ci:105:[.0547cb, .0547de) exec(1), time(0.003-0.003 ms): <.main+6719>
test/lang/useOperator.ci:106:[.0547de, .0547f1) exec(1), time(0.002-0.002 ms): <.main+6738>
test/lang/useOperator.ci:107:[.0547f1, .054804) exec(1), time(0.003-0.003 ms): <.main+6757>
test/lang/useOperator.ci:108:[.054804, .054817) exec(1), time(0.002-0.002 ms): <.main+6776>
test/lang/useOperator.ci:109:[.054817, .05482a) exec(1), time(0.003-0.003 ms): <.main+6795>
test/lang/useOperator.ci:110:[.05482a, .05483d) exec(1), time(0.003-0.003 ms): <.main+6814>
test/lang/useOperator.ci:111:[.05483d, .054850) exec(1), time(0.003-0.003 ms): <.main+6833>
test/lang/useOperator.ci:112:[.054850, .054861) exec(1), time(0.002-0.002 ms): <.main+6852>
test/lang/useOperator.ci:113:[.054861, .054872) exec(1), time(0.002-0.002 ms): <.main+6869>
test/lang/useOperator.ci:114:[.054872, .054880) exec(1), time(0.002-0.002 ms): <.main+6886>
test/lang/useOperator.ci:115:[.054880, .054893) exec(1), time(0.003-0.003 ms): <.main+6900>
test/lang/useOperator.ci:116:[.054893, .0548a7) exec(1), time(0.004-0.004 ms): <.main+6919>
test/lang/useOperator.ci:117:[.0548a7, .0548ba) exec(1), time(0.002-0.002 ms): <.main+6939>
test/lang/useOperator.ci:118:[.0548ba, .0548ce) exec(1), time(0.003-0.003 ms): <.main+6958>
test/lang/useOperator.ci:119:[.0548ce, .0548e1) exec(1), time(0.003-0.003 ms): <.main+6978>
test/lang/useOperator.ci:120:[.0548e1, .0548f5) exec(1), time(0.004-0.004 ms): <.main+6997>
test/lang/useOperator.ci:122:[.0548f5, .054900) exec(1), time(0.002-0.002 ms): <.main+7017>
test/lang/useOperator.ci:123:[.054900, .05490b) exec(1), time(0.001-0.001 ms): <.main+7028>
test/lang/useOperator.ci:124:[.05490b, .054917) exec(1), time(0.001-0.001 ms): <.main+7039>
test/lang/useOperator.ci:125:[.054917, .054924) exec(1), time(0.003-0.003 ms): <.main+7051>
test/lang/useOperator.ci:126:[.054924, .054931) exec(1), time(0.003-0.003 ms): <.main+7064>
test/lang/useOperator.ci:127:[.054931, .054944) exec(1), time(0.005-0.005 ms): <.main+7077>
test/lang/useOperator.ci:128:[.054944, .054957) exec(1), time(0.003-0.003 ms): <.main+7096>
test/lang/useOperator.ci:129:[.054957, .05496a) exec(1), time(0.003-0.003 ms): <.main+7115>
test/lang/useOperator.ci:130:[.05496a, .05497d) exec(1), time(0.003-0.003 ms): <.main+7134>
test/lang/useOperator.ci:131:[.05497d, .054990) exec(1), time(0.003-0.003 ms): <.main+7153>
test/lang/useOperator.ci:132:[.054990, .0549a3) exec(1), time(0.003-0.003 ms): <.main+7172>
test/lang/useOperator.ci:133:[.0549a3, .0549b6) exec(1), time(0.003-0.003 ms): <.main+7191>
test/lang/useOperator.ci:134:[.0549b6, .0549c9) exec(1), time(0.003-0.003 ms): <.main+7210>
test/lang/useOperator.ci:135:[.0549c9, .0549da) exec(1), time(0.002-0.002 ms): <.main+7229>
test/lang/useOperator.ci:136:[.0549da, .0549eb) exec(1), time(0.003-0.003 ms): <.main+7246>
test/lang/useOperator.ci:137:[.0549eb, .0549f9) exec(1), time(0.003-0.003 ms): <.main+7263>
test/lang/useOperator.ci:138:[.0549f9, .054a0c) exec(1), time(0.003-0.003 ms): <.main+7277>
test/lang/useOperator.ci:139:[.054a0c, .054a20) exec(1), time(0.004-0.004 ms): <.main+7296>
test/lang/useOperator.ci:140:[.054a20, .054a33) exec(1), time(0.003-0.003 ms): <.main+7316>
test/lang/useOperator.ci:141:[.054a33, .054a47) exec(1), time(0.003-0.003 ms): <.main+7335>
test/lang/useOperator.ci:142:[.054a47, .054a5a) exec(1), time(0.003-0.003 ms): <.main+7355>
test/lang/useOperator.ci:143:[.054a5a, .054a6e) exec(1), time(0.004-0.004 ms): <.main+7374>
test/lang/useOperator.ci:145:[.054a6e, .054a77) exec(1), time(0.001-0.001 ms): <.main+7394>
test/lang/useOperator.ci:146:[.054a77, .054a80) exec(1), time(0.000 ms): <.main+7403>
test/lang/useOperator.ci:147:[.054a80, .054a88) exec(1), time(0.001-0.001 ms): <.main+7412>
test/lang/useOperator.ci:148:[.054a88, .054a91) exec(1), time(0.001-0.001 ms): <.main+7420>
test/lang/useOperator.ci:149:[.054a91, .054a9a) exec(1), time(0.001-0.001 ms): <.main+7429>
test/lang/useOperator.ci:150:[.054a9a, .054aa7) exec(1), time(0.002-0.002 ms): <.main+7438>
test/lang/useOperator.ci:151:[.054aa7, .054ab4) exec(1), time(0.002-0.002 ms): <.main+7451>
test/lang/useOperator.ci:152:[.054ab4, .054ac1) exec(1), time(0.001-0.001 ms): <.main+7464>
test/lang/useOperator.ci:153:[.054ac1, .054ace) exec(1), time(0.002-0.002 ms): <.main+7477>
test/lang/useOperator.ci:154:[.054ace, .054adb) exec(1), time(0.002-0.002 ms): <.main+7490>
test/lang/useOperator.ci:155:[.054adb, .054ae8) exec(1), time(0.002-0.002 ms): <.main+7503>
test/lang/useOperator.ci:156:[.054ae8, .054af5) exec(1), time(0.002-0.002 ms): <.main+7516>
test/lang/useOperator.ci:157:[.054af5, .054b02) exec(1), time(0.001-0.001 ms): <.main+7529>
test/lang/useOperator.ci:158:[.054b02, .054b0f) exec(1), time(0.002-0.002 ms): <.main+7542>
test/lang/useOperator.ci:159:[.054b0f, .054b1c) exec(1), time(0.002-0.002 ms): <.main+7555>
test/lang/useOperator.ci:160:[.054b1c, .054b28) exec(1), time(0.002-0.002 ms): <.main+7568>
test/lang/useOperator.ci:161:[.054b28, .054b37) exec(1), time(0.002-0.002 ms): <.main+7580>
test/lang/useOperator.ci:162:[.054b37, .054b47) exec(1), time(0.002-0.002 ms): <.main+7595>
test/lang/useOperator.ci:163:[.054b47, .054b56) exec(1), time(0.002-0.002 ms): <.main+7611>
test/lang/useOperator.ci:164:[.054b56, .054b66) exec(1), time(0.003-0.003 ms): <.main+7626>
test/lang/useOperator.ci:165:[.054b66, .054b75) exec(1), time(0.003-0.003 ms): <.main+7642>
test/lang/useOperator.ci:166:[.054b75, .054b85) exec(1), time(0.003-0.003 ms): <.main+7657>
test/lang/useOperator.ci:168:[.054b85, .054b8e) exec(1), time(0.001-0.001 ms): <.main+7673>
test/lang/useOperator.ci:169:[.054b8e, .054b97) exec(1), time(0.001-0.001 ms): <.main+7682>
test/lang/useOperator.ci:170:[.054b97, .054b9f) exec(1), time(0.000 ms): <.main+7691>
test/lang/useOperator.ci:171:[.054b9f, .054ba8) exec(1), time(0.001-0.001 ms): <.main+7699>
test/lang/useOperator.ci:172:[.054ba8, .054bb1) exec(1), time(0.001-0.001 ms): <.main+7708>
test/lang/useOperator.ci:173:[.054bb1, .054bbe) exec(1), time(0.002-0.002 ms): <.main+7717>
test/lang/useOperator.ci:174:[.054bbe, .054bcb) exec(1), time(0.002-0.002 ms): <.main+7730>
test/lang/useOperator.ci:175:[.054bcb, .054bd8) exec(1), time(0.001-0.001 ms): <.main+7743>
test/lang/useOperator.ci:176:[.054bd8, .054be5) exec(1), time(0.002-0.002 ms): <.main+7756>
test/lang/useOperator.ci:177:[.054be5, .054bf2) exec(1), time(0.001-0.001 ms): <.main+7769>
test/lang/useOperator.ci:178:[.054bf2, .054bff) exec(1), time(0.002-0.002 ms): <.main+7782>
test/lang/useOperator.ci:179:[.054bff, .054c0c) exec(1), time(0.002-0.002 ms): <.main+7795>
test/lang/useOperator.ci:180:[.054c0c, .054c19) exec(1), time(0.002-0.002 ms): <.main+7808>
test/lang/useOperator.ci:181:[.054c19, .054c26) exec(1), time(0.002-0.002 ms): <.main+7821>
test/lang/useOperator.ci:182:[.054c26, .054c33) exec(1), time(0.001-0.001 ms): <.main+7834>
test/lang/useOperator.ci:183:[.054c33, .054c3f) exec(1), time(0.003-0.003 ms): <.main+7847>
test/lang/useOperator.ci:184:[.054c3f, .054c4e) exec(1), time(0.003-0.003 ms): <.main+7859>
test/lang/useOperator.ci:185:[.054c4e, .054c5e) exec(1), time(0.003-0.003 ms): <.main+7874>
test/lang/useOperator.ci:186:[.054c5e, .054c6d) exec(1), time(0.002-0.002 ms): <.main+7890>
test/lang/useOperator.ci:187:[.054c6d, .054c7d) exec(1), time(0.003-0.003 ms): <.main+7905>
test/lang/useOperator.ci:188:[.054c7d, .054c8c) exec(1), time(0.003-0.003 ms): <.main+7921>
test/lang/useOperator.ci:189:[.054c8c, .054c9c) exec(1), time(0.003-0.003 ms): <.main+7936>
test/lang/useOperator.ci:191:[.054c9c, .054ca9) exec(1), time(0.000 ms): <.main+7952>
test/lang/useOperator.ci:192:[.054ca9, .054cb6) exec(1), time(0.001-0.001 ms): <.main+7965>
test/lang/useOperator.ci:193:[.054cb6, .054cbe) exec(1), time(0.000 ms): <.main+7978>
test/lang/useOperator.ci:194:[.054cbe, .054cc7) exec(1), time(0.001-0.001 ms): <.main+7986>
test/lang/useOperator.ci:195:[.054cc7, .054cd0) exec(1), time(0.001-0.001 ms): <.main+7995>
test/lang/useOperator.ci:196:[.054cd0, .054cdd) exec(1), time(0.002-0.002 ms): <.main+8004>
test/lang/useOperator.ci:197:[.054cdd, .054cea) exec(1), time(0.002-0.002 ms): <.main+8017>
test/lang/useOperator.ci:198:[.054cea, .054cf7) exec(1), time(0.002-0.002 ms): <.main+8030>
test/lang/useOperator.ci:199:[.054cf7, .054d04) exec(1), time(0.002-0.002 ms): <.main+8043>
test/lang/useOperator.ci:200:[.054d04, .054d11) exec(1), time(0.002-0.002 ms): <.main+8056>
test/lang/useOperator.ci:201:[.054d11, .054d1e) exec(1), time(0.002-0.002 ms): <.main+8069>
test/lang/useOperator.ci:202:[.054d1e, .054d2b) exec(1), time(0.002-0.002 ms): <.main+8082>
test/lang/useOperator.ci:203:[.054d2b, .054d38) exec(1), time(0.002-0.002 ms): <.main+8095>
test/lang/useOperator.ci:204:[.054d38, .054d45) exec(1), time(0.002-0.002 ms): <.main+8108>
test/lang/useOperator.ci:205:[.054d45, .054d52) exec(1), time(0.001-0.001 ms): <.main+8121>
test/lang/useOperator.ci:206:[.054d52, .054d5e) exec(1), time(0.002-0.002 ms): <.main+8134>
test/lang/useOperator.ci:207:[.054d5e, .054d6d) exec(1), time(0.002-0.002 ms): <.main+8146>
test/lang/useOperator.ci:208:[.054d6d, .054d7d) exec(1), time(0.003-0.003 ms): <.main+8161>
test/lang/useOperator.ci:209:[.054d7d, .054d8c) exec(1), time(0.002-0.002 ms): <.main+8177>
test/lang/useOperator.ci:210:[.054d8c, .054d9c) exec(1), time(0.003-0.003 ms): <.main+8192>
test/lang/useOperator.ci:211:[.054d9c, .054dab) exec(1), time(0.002-0.002 ms): <.main+8208>
test/lang/useOperator.ci:212:[.054dab, .054dbb) exec(1), time(0.003-0.003 ms): <.main+8223>
test/lang/useOperator.ci:214:[.054dbb, .054dc8) exec(1), time(0.001-0.001 ms): <.main+8239>
test/lang/useOperator.ci:215:[.054dc8, .054dd5) exec(1), time(0.000 ms): <.main+8252>
test/lang/useOperator.ci:216:[.054dd5, .054ddd) exec(1), time(0.001-0.001 ms): <.main+8265>
test/lang/useOperator.ci:217:[.054ddd, .054de6) exec(1), time(0.001-0.001 ms): <.main+8273>
test/lang/useOperator.ci:218:[.054de6, .054def) exec(1), time(0.001-0.001 ms): <.main+8282>
test/lang/useOperator.ci:219:[.054def, .054dfc) exec(1), time(0.002-0.002 ms): <.main+8291>
test/lang/useOperator.ci:220:[.054dfc, .054e09) exec(1), time(0.002-0.002 ms): <.main+8304>
test/lang/useOperator.ci:221:[.054e09, .054e16) exec(1), time(0.002-0.002 ms): <.main+8317>
test/lang/useOperator.ci:222:[.054e16, .054e23) exec(1), time(0.002-0.002 ms): <.main+8330>
test/lang/useOperator.ci:223:[.054e23, .054e30) exec(1), time(0.002-0.002 ms): <.main+8343>
test/lang/useOperator.ci:224:[.054e30, .054e3d) exec(1), time(0.003-0.003 ms): <.main+8356>
test/lang/useOperator.ci:225:[.054e3d, .054e4a) exec(1), time(0.003-0.003 ms): <.main+8369>
test/lang/useOperator.ci:226:[.054e4a, .054e57) exec(1), time(0.002-0.002 ms): <.main+8382>
test/lang/useOperator.ci:227:[.054e57, .054e64) exec(1), time(0.001-0.001 ms): <.main+8395>
test/lang/useOperator.ci:228:[.054e64, .054e71) exec(1), time(0.002-0.002 ms): <.main+8408>
test/lang/useOperator.ci:229:[.054e71, .054e7d) exec(1), time(0.002-0.002 ms): <.main+8421>
test/lang/useOperator.ci:230:[.054e7d, .054e8c) exec(1), time(0.002-0.002 ms): <.main+8433>
test/lang/useOperator.ci:231:[.054e8c, .054e9c) exec(1), time(0.003-0.003 ms): <.main+8448>
test/lang/useOperator.ci:232:[.054e9c, .054eab) exec(1), time(0.002-0.002 ms): <.main+8464>
test/lang/useOperator.ci:233:[.054eab, .054ebb) exec(1), time(0.003-0.003 ms): <.main+8479>
test/lang/useOperator.ci:234:[.054ebb, .054eca) exec(1), time(0.002-0.002 ms): <.main+8495>
test/lang/useOperator.ci:235:[.054eca, .054eda) exec(1), time(0.003-0.003 ms): <.main+8510>
test/lang/useOperator.ci:237:[.054eda, .054ee3) exec(1), time(0.000 ms): <.main+8526>
test/lang/useOperator.ci:238:[.054ee3, .054eec) exec(1), time(0.001-0.001 ms): <.main+8535>
test/lang/useOperator.ci:239:[.054eec, .054ef4) exec(1), time(0.000 ms): <.main+8544>
test/lang/useOperator.ci:240:[.054ef4, .054efd) exec(1), time(0.001-0.001 ms): <.main+8552>
test/lang/useOperator.ci:242:[.054efd, .054f0a) exec(1), time(0.002-0.002 ms): <.main+8561>
test/lang/useOperator.ci:243:[.054f0a, .054f17) exec(1), time(0.002-0.002 ms): <.main+8574>
test/lang/useOperator.ci:244:[.054f17, .054f24) exec(1), time(0.002-0.002 ms): <.main+8587>
test/lang/useOperator.ci:245:[.054f24, .054f31) exec(1), time(0.002-0.002 ms): <.main+8600>
test/lang/useOperator.ci:246:[.054f31, .054f3e) exec(1), time(0.002-0.002 ms): <.main+8613>
test/lang/useOperator.ci:252:[.054f3e, .054f4a) exec(1), time(0.003-0.003 ms): <.main+8626>
test/lang/useOperator.ci:253:[.054f4a, .054f59) exec(1), time(0.002-0.002 ms): <.main+8638>
test/lang/useOperator.ci:254:[.054f59, .054f69) exec(1), time(0.003-0.003 ms): <.main+8653>
test/lang/useOperator.ci:255:[.054f69, .054f78) exec(1), time(0.002-0.002 ms): <.main+8669>
test/lang/useOperator.ci:256:[.054f78, .054f88) exec(1), time(0.003-0.003 ms): <.main+8684>
test/lang/useOperator.ci:257:[.054f88, .054f97) exec(1), time(0.002-0.002 ms): <.main+8700>
test/lang/useOperator.ci:258:[.054f97, .054fa7) exec(1), time(0.003-0.003 ms): <.main+8715>
test/lang/useOperator.ci:260:[.054fa7, .054fb4) exec(1), time(0.000 ms): <.main+8731>
test/lang/useOperator.ci:261:[.054fb4, .054fc1) exec(1), time(0.001-0.001 ms): <.main+8744>
test/lang/useOperator.ci:262:[.054fc1, .054fc9) exec(1), time(0.000 ms): <.main+8757>
test/lang/useOperator.ci:263:[.054fc9, .054fd2) exec(1), time(0.001-0.001 ms): <.main+8765>
test/lang/useOperator.ci:265:[.054fd2, .054fdf) exec(1), time(0.002-0.002 ms): <.main+8774>
test/lang/useOperator.ci:266:[.054fdf, .054fec) exec(1), time(0.002-0.002 ms): <.main+8787>
test/lang/useOperator.ci:267:[.054fec, .054ff9) exec(1), time(0.002-0.002 ms): <.main+8800>
test/lang/useOperator.ci:268:[.054ff9, .055006) exec(1), time(0.002-0.002 ms): <.main+8813>
test/lang/useOperator.ci:269:[.055006, .055013) exec(1), time(0.002-0.002 ms): <.main+8826>
test/lang/useOperator.ci:275:[.055013, .05501f) exec(1), time(0.002-0.002 ms): <.main+8839>
test/lang/useOperator.ci:276:[.05501f, .05502e) exec(1), time(0.002-0.002 ms): <.main+8851>
test/lang/useOperator.ci:277:[.05502e, .05503e) exec(1), time(0.003-0.003 ms): <.main+8866>
test/lang/useOperator.ci:278:[.05503e, .05504d) exec(1), time(0.002-0.002 ms): <.main+8882>
test/lang/useOperator.ci:279:[.05504d, .05505d) exec(1), time(0.003-0.003 ms): <.main+8897>
test/lang/useOperator.ci:280:[.05505d, .05506c) exec(1), time(0.003-0.003 ms): <.main+8913>
test/lang/useOperator.ci:281:[.05506c, .05507c) exec(1), time(0.003-0.003 ms): <.main+8928>
test/lang/useOperator.ci:283:[.05507c, .055085) exec(1), time(0.001-0.001 ms): <.main+8944>
test/lang/useOperator.ci:284:[.055085, .05508e) exec(1), time(0.000 ms): <.main+8953>
test/lang/useOperator.ci:299:[.05508e, .05509d) exec(1), time(0.003-0.003 ms): <.main+8962>
test/lang/useOperator.ci:300:[.05509d, .0550ad) exec(1), time(0.003-0.003 ms): <.main+8977>
test/lang/statementIf.ci:26:[.0550ad, .0550b2) exec(1), time(0.001-0.001 ms): <.main+8993>
test/lang/statementFor.ci:12:[.0550b2, .0550b7) exec(1), time(0.000 ms): <.main+8998>
test/stdc/test.math.ci:3:[.0550b7, .0550cf) exec(1), time(0.022-0.022 ms): <.main+9003>
test/stdc/test.math.ci:4:[.0550cf, .0550e7) exec(1), time(0.020-0.020 ms): <.main+9027>
test/stdc/test.math.ci:5:[.0550e7, .0550ff) exec(1), time(0.020-0.020 ms): <.main+9051>
test/stdc/test.math.ci:6:[.0550ff, .055117) exec(1), time(0.028-0.028 ms): <.main+9075>
test/stdc/test.math.ci:7:[.055117, .05512f) exec(1), time(0.028-0.028 ms): <.main+9099>
test/stdc/test.math.ci:8:[.05512f, .055147) exec(1), time(0.028-0.028 ms): <.main+9123>
test/stdc/test.math.ci:10:[.055147, .055164) exec(1), time(0.008-0.008 ms): <.main+9147>
test/stdc/test.math.ci:11:[.055164, .055179) exec(1), time(0.008-0.008 ms): <.main+9176>
test/stdc/test.math.ci:12:[.055179, .055196) exec(1), time(0.008-0.008 ms): <.main+9197>
test/stdc/test.math.ci:13:[.055196, .0551ab) exec(1), time(0.007-0.007 ms): <.main+9226>
test/stdc/test.math.ci:14:[.0551ab, .0551bc) exec(1), time(0.006-0.006 ms): <.main+9247>
test/stdc/test.math.ci:15:[.0551bc, .0551d1) exec(1), time(0.007-0.007 ms): <.main+9264>
test/stdc/test.math.ci:17:[.0551d1, .0551e9) exec(1), time(0.012-0.012 ms): <.main+9285>
test/stdc/test.math.ci:18:[.0551e9, .0551f8) exec(1), time(0.012-0.012 ms): <.main+9309>
test/stdc/test.math.ci:19:[.0551f8, .055210) exec(1), time(0.013-0.013 ms): <.main+9324>
test/stdc/test.math.ci:20:[.055210, .055225) exec(1), time(0.018-0.018 ms): <.main+9348>
test/stdc/test.math.ci:21:[.055225, .055236) exec(1), time(0.012-0.012 ms): <.main+9369>
test/stdc/test.math.ci:22:[.055236, .05524b) exec(1), time(0.013-0.013 ms): <.main+9386>
test/stdc/test.math.ci:24:[.05524b, .055265) exec(1), time(0.013-0.013 ms): <.main+9407>
test/stdc/test.math.ci:25:[.055265, .05527f) exec(1), time(0.014-0.014 ms): <.main+9433>
test/stdc/test.math.ci:26:[.05527f, .0552a0) exec(1), time(0.016-0.016 ms): <.main+9459>
test/stdc/test.math.ci:27:[.0552a0, .0552c1) exec(1), time(0.014-0.014 ms): <.main+9492>
test/stdc/test.math.ci:29:[.0552c1, .0552dc) exec(1), time(0.014-0.014 ms): <.main+9525>
test/stdc/test.math.ci:30:[.0552dc, .0552fe) exec(1), time(0.015-0.015 ms): <.main+9552>
test/stdc/test.math.ci:32:[.0552fe, .055317) exec(1), time(0.007-0.007 ms): <.main+9586>
test/stdc/test.math.ci:33:[.055317, .055337) exec(1), time(0.006-0.006 ms): <.main+9611>
test/stdc/test.math.ci:35:[.055337, .055377) exec(1), time(0.026-0.026 ms): <.main+9643>
test/stdc/test.math.ci:36:[.055377, .0553c9) exec(1), time(0.026-0.026 ms): <.main+9707>
test/stdc/test.math.ci:38:[.0553c9, .0553e2) exec(1), time(0.021-0.021 ms): <.main+9789>
test/stdc/test.math.ci:39:[.0553e2, .055450) exec(1), time(0.037-0.037 ms): <.main+9814>
test/stdc/test.math.ci:40:[.055450, .055469) exec(1), time(0.015-0.015 ms): <.main+9924>
test/stdc/test.math.ci:41:[.055469, .0554d7) exec(1), time(0.034-0.034 ms): <.main+9949>
test/stdc/test.math.ci:43:[.0554d7, .0554f0) exec(1), time(0.016-0.016 ms): <.main+10059>
test/stdc/test.math.ci:44:[.0554f0, .055516) exec(1), time(0.019-0.019 ms): <.main+10084>
test/stdc/test.math.ci:45:[.055516, .055545) exec(1), time(0.019-0.019 ms): <.main+10122>
test/stdc/test.math.ci:46:[.055545, .0555bc) exec(1), time(0.037-0.037 ms): <.main+10169>
test/stdc/test.math.ci:48:[.0555bc, .0555c9) exec(1), time(0.001-0.001 ms): <.main+10288>
test/stdc/test.math.ci:49:[.0555c9, .0555e6) exec(1), time(0.018-0.018 ms): <.main+10301>
test/stdc/test.math.ci:50:[.0555e6, .0555f3) exec(1), time(0.001-0.001 ms): <.main+10330>
test/stdc/test.math.ci:51:[.0555f3, .05560f) exec(1), time(0.003-0.003 ms): <.main+10343>
test/stdc/test.math.ci:52:[.05560f, .05563c) exec(1), time(0.007-0.007 ms): <.main+10371>
test/stdc/test.math.ci:53:[.05563c, .05567a) exec(1), time(0.011-0.011 ms): <.main+10416>
test/stdc/test.math.ci:54:[.05567a, .0556c8) exec(1), time(0.028-0.028 ms): <.main+10478>
test/stdc/test.math.ci:55:[.0556c8, .05571f) exec(1), time(0.034-0.034 ms): <.main+10556>
test/stdc/test.math.ci:57:[.05571f, .055742) exec(1), time(0.024-0.024 ms): <.main+10643>
test/stdc/test.math.ci:58:[.055742, .055773) exec(1), time(0.034-0.034 ms): <.main+10678>
test/stdc/test.math.ci:59:[.055773, .055795) exec(1), time(0.034-0.034 ms): <.main+10727>
test/stdc/test.math.ci:60:[.055795, .0557b7) exec(1), time(0.043-0.043 ms): <.main+10761>
test/stdc/test.math.ci:61:[.0557b7, .0557d9) exec(1), time(0.039-0.039 ms): <.main+10795>
test/stdc/test.math.ci:63:[.0557d9, .0557f1) exec(1), time(0.042-0.042 ms): <.main+10829>
test/stdc/test.math.ci:64:[.0557f1, .05581d) exec(1), time(0.043-0.043 ms): <.main+10853>
test/stdc/test.math.ci:67:[.05581d, .05583f) exec(1), time(0.017-0.017 ms): <.main+10897>
test/stdc/test.math.ci:68:[.05583f, .05586d) exec(1), time(0.017-0.017 ms): <.main+10931>
test/stdc/test.math.ci:70:[.05586d, .05588e) exec(1), time(0.013-0.013 ms): <.main+10977>
test/stdc/test.math.ci:71:[.05588e, .0558a6) exec(1), time(0.013-0.013 ms): <.main+11010>
test/stdc/test.math.ci:72:[.0558a6, .0558c7) exec(1), time(0.013-0.013 ms): <.main+11034>
test/stdc/test.math.ci:74:[.0558c7, .0558e8) exec(1), time(0.017-0.017 ms): <.main+11067>
test/stdc/test.math.ci:75:[.0558e8, .055909) exec(1), time(0.014-0.014 ms): <.main+11100>
test/stdc/test.math.ci:76:[.055909, .05592a) exec(1), time(0.013-0.013 ms): <.main+11133>
test/stdc/test.math.ci:77:[.05592a, .05594b) exec(1), time(0.013-0.013 ms): <.main+11166>
test/stdc/test.math.ci:79:[.05594b, .05596c) exec(1), time(0.013-0.013 ms): <.main+11199>
test/stdc/test.math.ci:80:[.05596c, .05598d) exec(1), time(0.013-0.013 ms): <.main+11232>
test/stdc/test.math.ci:81:[.05598d, .0559ae) exec(1), time(0.013-0.013 ms): <.main+11265>
test/stdc/test.math.ci:82:[.0559ae, .0559cf) exec(1), time(0.013-0.013 ms): <.main+11298>
test/stdc/test.math.ci:84:[.0559cf, .0559e8) exec(1), time(0.014-0.014 ms): <.main+11331>
test/stdc/test.math.ci:85:[.0559e8, .0559fd) exec(1), time(0.013-0.013 ms): <.main+11356>
test/stdc/test.math.ci:86:[.0559fd, .055a16) exec(1), time(0.013-0.013 ms): <.main+11377>
test/stdc/test.math.ci:88:[.055a16, .055a2f) exec(1), time(0.013-0.013 ms): <.main+11402>
test/stdc/test.math.ci:89:[.055a2f, .055a48) exec(1), time(0.013-0.013 ms): <.main+11427>
test/stdc/test.math.ci:90:[.055a48, .055a61) exec(1), time(0.013-0.013 ms): <.main+11452>
test/stdc/test.math.ci:91:[.055a61, .055a7a) exec(1), time(0.016-0.016 ms): <.main+11477>
test/stdc/test.math.ci:93:[.055a7a, .055a93) exec(1), time(0.017-0.017 ms): <.main+11502>
test/stdc/test.math.ci:94:[.055a93, .055aac) exec(1), time(0.013-0.013 ms): <.main+11527>
test/stdc/test.math.ci:95:[.055aac, .055ac5) exec(1), time(0.013-0.013 ms): <.main+11552>
test/stdc/test.math.ci:96:[.055ac5, .055ade) exec(1), time(0.013-0.013 ms): <.main+11577>
test/stdc/memory.ci:13:[.055ade, .055af0) exec(1), time(0.018-0.018 ms): <.main+11602>
test/stdc/memory.ci:14:[.055af0, .055b05) exec(1), time(0.018-0.018 ms): <.main+11620>
test/stdc/memory.ci:17:[.055b05, .055b12) exec(1), time(0.017-0.017 ms): <.main+11641>
test/stdc/memory.ci:18:[.055b12, .055b1f) exec(1), time(0.017-0.017 ms): <.main+11654>
test/stdc/memory.ci:19:[.055b1f, .055b2c) exec(1), time(0.017-0.017 ms): <.main+11667>
test/stdc/memory.ci:20:[.055b2c, .055b39) exec(1), time(0.016-0.016 ms): <.main+11680>
test/stdc/memory.ci:26:[.055b39, .055b5c) exec(1), time(0.023-0.023 ms): <.main+11693>
test/stdc/memory.ci:27:[.055b5c, .055b7f) exec(1), time(0.022-0.022 ms): <.main+11728>
test/stdc/memory.ci:29:[.055b7f, .055b95) exec(1), time(0.018-0.018 ms): <.main+11763>
test/stdc/memory.ci:30:[.055b95, .055ba7) exec(1), time(0.017-0.017 ms): <.main+11785>
test/stdc/memory.ci:32:[.055ba7, .055bca) exec(1), time(0.027-0.027 ms): <.main+11803>
test/stdc/memory.ci:33:[.055bca, .055bed) exec(1), time(0.022-0.022 ms): <.main+11838>
test/lang/array.ci:55:[.055bf2, .055c07) exec(7), time(0.034-0.034 ms): <.main+11878>
test/lang/array.ci:54:[.055c07, .055c0b) exec(7), time(0.002-0.002 ms): <.main+11899>
test/lang/array.ci:54:[.055c0b, .055c17) exec(8), time(0.018-0.018 ms): <.main+11903>
test/lang/array.ci:54:[.055bed, .055c1b) exec(1), time(0.003-0.003 ms): <.main+11873>
test/lang/array.ci:82:[.055c1b, .055c32) exec(1), time(0.018-0.018 ms): <.main+11919>
test/lang/array.ci:83:[.055c32, .055c55) exec(1), time(0.049-0.049 ms): <.main+11942>
test/lang/array.ci:84:[.055c55, .055c78) exec(1), time(0.049-0.049 ms): <.main+11977>
test/lang/array.ci:87:[.055c78, .055c9a) exec(1), time(0.025-0.025 ms): <.main+12012>
test/lang/array.ci:88:[.055c9a, .055cbc) exec(1), time(0.024-0.024 ms): <.main+12046>
test/lang/array.ci:91:[.055cbc, .055cde) exec(1), time(0.023-0.023 ms): <.main+12080>
test/lang/array.ci:92:[.055cde, .055d00) exec(1), time(0.023-0.023 ms): <.main+12114>
test/lang/array.ci:98:[.055d00, .055d35) exec(1), time(0.003-0.003 ms): <.main+12148>
test/lang/array.ci:99:[.055d35, .055d6a) exec(1), time(0.003-0.003 ms): <.main+12201>
test/lang/array.ci:101:[.055d6a, .055da7) exec(1), time(0.003-0.003 ms): <.main+12254>
test/lang/array.ci:108:[.055da7, .055dc0) exec(1), time(0.014-0.014 ms): <.main+12315>
test/lang/array.ci:109:[.055dc0, .055dd8) exec(1), time(0.013-0.013 ms): <.main+12340>
test/lang/array.ci:110:[.055dd8, .055df0) exec(1), time(0.018-0.018 ms): <.main+12364>
test/lang/array.ci:112:[.055df0, .055e10) exec(1), time(0.029-0.029 ms): <.main+12388>
test/lang/array.ci:113:[.055e10, .055e2f) exec(1), time(0.030-0.030 ms): <.main+12420>
test/lang/array.ci:114:[.055e2f, .055e58) exec(1), time(0.030-0.030 ms): <.main+12451>
test/lang/array.ci:115:[.055e58, .055e7b) exec(1), time(0.032-0.032 ms): <.main+12492>
test/lang/array.ci:116:[.055e7b, .055e9e) exec(1), time(0.029-0.029 ms): <.main+12527>
test/lang/array.ci:119:[.055ea3, .055eac) exec(7), time(0.015-0.015 ms): <.main+12567>
test/lang/array.ci:120:[.055eac, .055eea) exec(7), time(0.034-0.034 ms): <.main+12576>
test/lang/array.ci:121:[.055eea, .055f27) exec(7), time(0.034-0.034 ms): <.main+12638>
test/lang/array.ci:122:[.055f27, .055f64) exec(7), time(0.035-0.035 ms): <.main+12699>
test/lang/array.ci:124:[.055f64, .055fa8) exec(7), time(0.157-0.157 ms): <.main+12760>
test/lang/array.ci:125:[.055fa8, .055feb) exec(7), time(0.154-0.154 ms): <.main+12828>
test/lang/array.ci:126:[.055feb, .05602e) exec(7), time(0.157-0.157 ms): <.main+12895>
test/lang/array.ci:128:[.05602e, .056072) exec(7), time(0.152-0.152 ms): <.main+12962>
test/lang/array.ci:129:[.056072, .0560b5) exec(7), time(0.149-0.149 ms): <.main+13030>
test/lang/array.ci:130:[.0560b5, .0560f8) exec(7), time(0.148-0.148 ms): <.main+13097>
test/lang/array.ci:132:[.0560f8, .056141) exec(7), time(0.155-0.155 ms): <.main+13164>
test/lang/array.ci:134:[.056141, .056184) exec(7), time(0.153-0.153 ms): <.main+13237>
test/lang/array.ci:136:[.056184, .0561c1) exec(7), time(0.036-0.036 ms): <.main+13304>
test/lang/array.ci:118:[.0561c5, .0561c9) exec(7), time(0.001-0.001 ms): <.main+13369>
test/lang/array.ci:118:[.0561c9, .0561d5) exec(8), time(0.018-0.018 ms): <.main+13373>
test/lang/array.ci:118:[.055e9e, .0561d9) exec(1), time(0.004-0.004 ms): <.main+12562>
test/lang/method.ci:78:[.0561d9, .0561ee) exec(1), time(0.081-0.081 ms): <.main+13389>
test/lang/method.ci:79:[.0561ee, .056202) exec(1), time(0.075-0.075 ms): <.main+13410>
test/lang/method.ci:97:[.056202, .056215) exec(1), time(0.145-0.145 ms): <.main+13430>
test/lang/method.ci:98:[.056215, .056228) exec(1), time(0.139-0.139 ms): <.main+13449>
test/lang/method.ci:101:[.056228, .05623d) exec(1), time(0.080-0.080 ms): <.main+13468>
test/lang/method.ci:102:[.05623d, .056252) exec(1), time(0.077-0.077 ms): <.main+13489>
test/lang/method.ci:103:[.056252, .056266) exec(1), time(0.075-0.075 ms): <.main+13510>
test/lang/statementIf.ci:4:[.056266, .05628d) exec(1), time(0.021-0.021 ms): <.main+13530>
test/lang/statementIf.ci:12:[.05628d, .0562b4) exec(1), time(0.022-0.022 ms): <.main+13569>
test/lang/statementIf.ci:22:[.0562b4, .0562db) exec(1), time(0.022-0.022 ms): <.main+13608>
test/lang/statementIf.ci:29:[.0562e5, .05630c) exec(1), time(0.025-0.025 ms): <.main+13657>
test/lang/statementIf.ci:28:[.0562db, .05630c) exec(1-1), time(0.000 ms): <.main+13647>
test/lang/statementIf.ci:33:[.056316, .05633d) exec(0), time(0.000 ms): <.main+13706>
test/lang/statementIf.ci:32:[.05630c, .05633d) exec(1), time(0.002-0.002 ms): <.main+13696>
test/lang/statementIf.ci:37:[.056347, .05636e) exec(1), time(0.024-0.024 ms): <.main+13755>
test/lang/statementIf.ci:40:[.056372, .056399) exec(0), time(0.000 ms): <.main+13798>
test/lang/statementIf.ci:36:[.05633d, .056399) exec(1), time(0.025-0.025 ms): <.main+13745>
test/lang/statementIf.ci:44:[.0563a3, .0563ca) exec(0), time(0.000 ms): <.main+13847>
test/lang/statementIf.ci:47:[.0563ce, .0563f5) exec(1), time(0.028-0.028 ms): <.main+13890>
test/lang/statementIf.ci:43:[.056399, .0563f5) exec(1-1), time(0.000 ms): <.main+13837>
test/lang/statementIf.ci:51:[.0563ff, .056426) exec(1), time(0.030-0.030 ms): <.main+13939>
test/lang/statementIf.ci:54:[.056438, .05645f) exec(0), time(0.000 ms): <.main+13996>
test/lang/statementIf.ci:57:[.056471, .056498) exec(0), time(0.000 ms): <.main+14053>
test/lang/statementIf.ci:60:[.0564aa, .0564d1) exec(0), time(0.000 ms): <.main+14110>
test/lang/statementIf.ci:63:[.0564e3, .05650a) exec(0), time(0.000 ms): <.main+14167>
test/lang/statementIf.ci:66:[.05651c, .056543) exec(0), time(0.000 ms): <.main+14224>
test/lang/statementIf.ci:69:[.056547, .05656e) exec(0), time(0.000 ms): <.main+14267>
test/lang/statementIf.ci:65:[.05650e, .05656e) exec(0), time(0.000 ms): <.main+14210>
test/lang/statementIf.ci:62:[.0564d5, .05656e) exec(0), time(0.000 ms): <.main+14153>
test/lang/statementIf.ci:59:[.05649c, .05656e) exec(0), time(0.000 ms): <.main+14096>
test/lang/statementIf.ci:56:[.056463, .05656e) exec(0), time(0.000 ms): <.main+14039>
test/lang/statementIf.ci:53:[.05642a, .05656e) exec(0), time(0.000 ms): <.main+13982>
test/lang/statementIf.ci:50:[.0563f5, .05656e) exec(1), time(0.031-0.031 ms): <.main+13929>
test/lang/statementFor.ci:4:[.056572, .056595) exec(1), time(0.019-0.019 ms): <.main+14310>
test/lang/statementFor.ci:5:[.056595, .056599) exec(1), time(0.000 ms): <.main+14345>
::[.056599, .05659d) exec(1), time(0.000 ms): <.main+14349>
test/lang/statementFor.ci:3:[.05656e, .05659d) exec(1-1), time(0.000 ms): <.main+14306>
test/lang/statementFor.ci:9:[.0565a2, .0565c4) exec(2), time(0.044-0.044 ms): <.main+14358>
test/lang/statementFor.ci:8:[.0565c4, .0565c8) exec(2), time(0.000 ms): <.main+14392>
test/lang/statementFor.ci:8:[.0565c8, .0565d4) exec(3), time(0.007-0.007 ms): <.main+14396>
test/lang/statementFor.ci:8:[.05659d, .0565d8) exec(1), time(0.003-0.003 ms): <.main+14353>
test/lang/statementFor.ci:14:[.0565e1, .056604) exec(2), time(0.044-0.044 ms): <.main+14421>
test/lang/statementFor.ci:13:[.056604, .056610) exec(2), time(0.004-0.004 ms): <.main+14456>
test/lang/statementFor.ci:13:[.056610, .05661e) exec(3), time(0.007-0.007 ms): <.main+14468>
test/lang/statementFor.ci:13:[.0565d8, .05661e) exec(1-1), time(0.000 ms): <.main+14412>
test/lang/statementFor.ci:19:[.05662f, .056633) exec(2), time(0.000 ms): <.main+14499>
test/lang/statementFor.ci:18:[.056623, .056633) exec(7-2), time(0.011-0.011 ms): <.main+14487>
test/lang/statementFor.ci:21:[.056633, .056655) exec(5), time(0.119-0.119 ms): <.main+14503>
test/lang/statementFor.ci:17:[.056655, .056659) exec(7), time(0.000 ms): <.main+14537>
test/lang/statementFor.ci:17:[.056659, .056665) exec(8), time(0.021-0.021 ms): <.main+14541>
test/lang/statementFor.ci:17:[.05661e, .056669) exec(1), time(0.003-0.003 ms): <.main+14482>
test/lang/statementFor.ci:26:[.05667a, .05667e) exec(1), time(0.000 ms): <.main+14574>
test/lang/statementFor.ci:25:[.05666e, .05667e) exec(4-1), time(0.008-0.008 ms): <.main+14562>
test/lang/statementFor.ci:28:[.05667e, .0566a0) exec(3), time(0.066-0.066 ms): <.main+14578>
test/lang/statementFor.ci:24:[.0566a0, .0566a4) exec(3), time(0.002-0.002 ms): <.main+14612>
test/lang/statementFor.ci:24:[.0566a4, .0566b0) exec(4), time(0.010-0.010 ms): <.main+14616>
test/lang/statementFor.ci:24:[.056669, .0566b4) exec(1), time(0.001-0.001 ms): <.main+14557>

---------- Exitcode: 0, time: 17.950 ms
